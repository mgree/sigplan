tractable refinement checking for concurrent objects ahmed paris michael software institute paris abstract efficient implementations of concurrent objects such as locks and atomic collections are essential to modern computing yet programming such objects is error in the synchronization overhead between concurrent object invocations one the to reference implementations or in formal terms one observational refinement testing this refinement even within a single execution is limiting existing approaches to executions with very few object invocations we develop a polynomialtime per execution approximation to refinement checking the approximation is parameterized by an accuracy k n representing the degree to which refinement violations are visible in principle more violations are as k increases and in the limit all are our insight for this approximation arises from foundational properties on the partial orders characterizing the happensbefore relations between object invocations they are interval orders with a well defined measure of complexity ie their length the happensbefore relation with a interval order of bounded length can be efficiently implemented by maintaining a bounded number of integer counters in practice we find that refinement violations can be detected with very small values of k and that our approach far beyond existing approaches categories and subject descriptors f specifying and verifying and reasoning about programs mechanical verification general terms reliability verification keywords concurrency refinement linearizability introduction efficient implementations of concurrent objects such as locks and atomic collections including stacks and queues are to modern computer systems programming them is however error to minimize synchronization overhead between concurrent invocations avoid blocking operations like lock acquisition allowing methods to execute concurrently however concurrency interference and to reference implementations is formally captured by observational refinement given two libraries l and l implementing the methods of some concurrent object we permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm say l refines l if and only if every computation of every program using l would also be possible were l used instead verifying observational refinement is hard and generally undecidable here we develop a tractable algorithmic approach to detecting refinement violations in two parts the first part outlined in section establishes a foundational characterization of refinement in terms of sets of socalled histories histories abstract executions into the happensbefore partial order between invocations we show that refinement between libraries is equivalent to a inclusion problem consequently violations correspond to histories since detection for even a single execution is nphard the second part outlined in section a novel approximation for refinement checking we demonstrate that our approach is feasible leading to scalable algorithms the insight behind our approximation exploits fundamental properties of the histories arising from concurrent executions they are a special class of partial orders called interval orders such orders admit convenient representations leading to efficient automation and reveal a useful parameter for refining our approximation in practice we find that even approximations refinement violations and can be implemented much more efficiently than existing approaches characterizing observational refinement naturally observational refinement verification is challenging the most immediate arises from the quantification over the possible programs a library l refines another library l if every observation of every client program using l is also using l our first contribution is to provide a precise characterization of refinement as a problem defined independently from libraries execution contexts between the partial orders of operations by each library more precisely we associate to each execution e a partial order he on its invocations called a history an operation o is considered to happen before an operation o in he if o completes before o is invoked in e we prove that a library l refines another l if and only if the set hl of ls histories ie associated with ls executions is included in hl this characterization is a fundamental result that offers a fresh view for reasoning about refinement thus far the principal approach for checking observational refinement in the literature is based on linearizability requiring that operations of every execution of l can be into a serial execution of l while preserving the order between operations while linearizability implies observational refinement we demonstrate that the converse does not generally hold to light on the subtle relationship between these concepts we investigate the link between history inclusion and linearizability we prove that when l is atomic which is often the case for reference implementations history inclusion between l and l and therefore observational refinement is equivalent to linearizability observational refinement besides a fresh perspective on observational refinement our characterization leads to an efficient approach for detecting refinement violations exploiting fundamental properties of library executions and their histories we consider a weakening preorder on histories as a means for approximation a history h is weaker than another history h written h h essentially if h is obtained from h by order constraints we show that if a library l admits a history h then l also admits every weaker history h h our approximation principle considers ah h of histories h hl such that checking ah hl is tractable if ah hl then h hl and thus a violation is found the challenge is to design a parameterized approximation ak for k n such that hl is decidable in polynomial time in the size of h the approximation should also be complete in the sense that for any history h there exists k n such that h ensuring that any violation can be captured with a large enough parameter value finally the approximation should be easy to implement and catch violations with small parameter values our approximation scheme exploits a fundamental property of library executions their histories are interval orders a special case of partial orders which admit canonical representations in which each operation o is mapped to a interval io an operation o happens before another operation o if and only if the interval io ends before io begins interval orders are equipped with a natural notion of length which corresponds to the smallest integer constant for which an interval mapping exists our approximation ak maps each history h to a weaker history of interval length at most k orders admit a convenient representation of histories using counting each interval is represented by a counter whose value reflects the number of operations spanning that interval such a representation the to symbolic manipulation of history sets using arithmetic constraints which we describe using a simple operation counting logic we demonstrate that this logic has a polynomialtime modelchecking problem and is suitable for reasoning about concurrent object libraries including atomic collections like stacks and queues we also demonstrate that can be systematically constructed for a broad class of concurrent objects moreover representations can be efficiently in polynomialtime and space using simple counter increments and at the precise when operations begin and end by maintaining a approximation of an execution e we effectively reduce our approximate problem to a safety verification problem by checking whether where is an formula characterizing the histories of hl we demonstrate that our approach is effective in both and contexts used in the dynamic setting we maintain runtime overhead which does not increase in the length of executions our approach far beyond the existing approaches based on linearizability in which exponentially in the length of executions furthermore our approximation ak is for refinement violations with small parameter values violations are most often detected with k and almost always with k in fact we even prove that many violations to atomic collection objects including stacks and queues can always be with k in the context our representation allows us to symbolic program exploration tools including with and with to discover refinement violations struct node top void v struct node nt n n v do struct node t top t while cas top t n int pop struct node nt do t top if return empty n while cas top t n int result return result struct node int data struct node next void thread push int x pop void thread int y pop push push int z pop figure an implementation of stack the pop operation returns the value empty when the stack is empty summary of contributions this work makes the following contributions · a characterization of observational refinement as a problem § and a proof of equivalence with linearizability for atomic reference implementations § · an underapproximation for detecting observational refinement violations based on a weakening preorder on histories exploiting the fact that library histories are interval orders § · an efficient implementation of our approximation using counters specifically we reduce refinement checking to checking § using symbolic arithmetic representations of history sets § demonstrate bounds for objects § and develop an automatic construction of counting representations § · experimental validation of our approach in both and settings § motivating example figure lists a nonblocking stack implementation providing push and pop methods this implementation stores pushed elements into a list rooted at top and avoids blocking lock in of nonblocking cas operations in order to parallelism allowing methods to their internal actions in one atomic step the cas operation assigns top n only if top t unfortunately this implementation from a subtle concurrency bug now commonly known as an bug the bug in the program of figure via the execution depicted in figure a essentially thread assumes the absence of interference from other threads on the successful cas operation thread is right before executing its cas in the pop method at that moment its t variable points to the first element in the list at address added by push and n null while thread updates the list with two additional elements added by push and push the t variable of thread still points to the lists first element at address which was by thread s call to pop and in the call to push when thread its cas succeeds effectively removing two elements from the list instead of one the final pop of thread thus returns empty intuitively this is a problem because the empty value should not have been returned since more elements have been pushed than prior to thread s final pop operation pop ret x pop ret y pop emp before cas thread thread a an execution e of the program it calls returns and assignments and time from left to right pop pop empty push pop push push push push pop push pop pop empty pop b the history he of execution e c a history weaker than he push pop pop push push pop empty d the history he as an interval order push pop pop push push pop empty e the canonical representation of he figure an execution and its history this bug the fact that our implementation does not to programmers of a stack object whose operations execute atomically eg by holding a lock for the of each operation in particular the assignment z empty should never have occurred this idea of is captured by the formal notion of observational refinement essentially an implementation l of a concurrent object refines another implementation l if every observable behavior of a program using l is also observable using l this property clearly does not hold between the implementation of figure and a correct atomic implementation since y x z empty is observable using the implementation yet not using the atomic one observational refinement we formalize the criterion of observational refinement using a simple yet universal model of computation namely labeled transition systems lts this model captures programs with an arbitrary number of threads abstracting away the details of any particular programming system irrelevant to our development a labeled transition system a q q over the alphabet is a set q of states with initial state q q and a transition relation q × × q the ith symbol of a sequence e is denoted ei an execution of a is a sequence e such that for some q q qe q we have qi ei qi for each i such that i e the projection e is the maximum subsequence of e over alphabet ea denotes the set of as executions and ea their projections over note that ea is prefix closed the synchronous product a × a of two is defined as usual ea × a ea ea libraries programs interact with libraries by calling named library methods which receive parameter values and yield return values upon completion we fix arbitrary sets m and v of method names and values example the method and value sets for the stack implementation in figure are m push pop and v n empty we fix an arbitrary set o of operation identifiers and for given sets m and v of methods and values we fix the sets c m m v v o o and r v v o o of call actions and return actions each call action combines a method m m and value v v with an operation identifier o o operation identifiers are used to pair call and return actions we denote the operation identifier of a action a by call and return actions c c and r r are matching written c r when a word e over alphabet such that c r is well formed when · each return is by a matching call ej r implies ei ej for some i j · each operation identifier is used in at most one and i j implies ei ej we say that the wellformed word e is sequential when · operations do not overlap ei ek c and i k implies ei ej for some i j k wellformed words represent executions we assume every set of wellformed words is closed under isomorphic renaming of operation identifiers for notational convenience we often associate o with n eg writing mu and in place of and an operation o of an execution e is completed when both call and return actions and of o occur in e and is otherwise pending example the wellformed words push pop pop ret ret ret and push pop pop ret ret represent executions in which one call to the push method with two calls to pop in the first execution both calls to pop have matching return actions ret ie the operations and are completed while operation is pending in the second it has no matching return libraries the execution of methods between their call and return points accordingly a library cannot prevent a method from being called though it can decide not to return furthermore any library action performed in the interval between call and return points can also be performed should the call have been made earlier andor the return made later our technical results rely on these properties a library thus allows any sequence of invocations to its methods made by some program definition a library l is an lts over alphabet c r such that each execution e el is well formed and · call actions c c cannot be e · e el implies e · c · e el if e · c · e is well formed · call actions c c cannot other actions e · a · c · e el implies e · c · a · e el · return actions r r cannot enable other actions e · r · a · e el implies e · a · r · e el we write e e when e can be derived from e by applying zero or more of the above rules the closure of a set e of executions under is denoted e note that even a library that implements atomic methods eg by method bodies with a acquisition admits executions in which method calls and returns overlap a library which accesses the clients thread identifiers can be modeled by taking thread identifiers as method parameters example any library which admits the execution push ret pop ret with sequential calls to push and pop must also admit push pop ret ret and push pop pop ret ret among others yet need not admit an execution push pop pop ret ret ret with two completed pop operations returning a library l is called atomic if it is defined by the closure of some set e of sequential executions ie el e when such a set e exists it is unique and we call it the kernel of l denoted by l note that l contains only completed operations since e · e e · c · e for any call c atomic libraries are often considered as specifications for concurrent objects example the atomic stack is the library whose kernel is the set of sequential executions for which the return value of each pop operation is either · the argument value v to the last push operation or · empty if there are no push operations in practice the atomic stack can be implemented by the methods of a sequential stack object by acquisition refinement between libraries refinement between libraries is defined with respect to the observable actions of programs which invoke library methods complementary to libraries programs control their execution outside of method call and return points accordingly any program action performed in the interval between call and return points can also be performed should the call have been made later andor the return made earlier a program thus allows any sequence of matching returns generated by some implementation of the methods it invokes definition a program p over actions is an lts over alphabet c r where each execution e ep is well formed and · call actions c c cannot enable other actions e · c · a · e ep implies c a or e · a · c · e ep · return actions r r cannot other actions e · a · r · e ep implies a r or e · r · a · e ep · return actions r r cannot be e · e ep implies e · r · e el if e · r · e is well formed example any program which admits the execution push pop ret pop ret with two sequential pop calls concurrent with push must also admit push ret pop ret pop and push ret pop ret pop among others in which all three calls are sequential and the second pop may return with any value yet need not admit an execution push ret pop pop ret in which the two calls to pop are concurrent the set of executions by a program allows any possible implementation of the methods while programs cannot force methods to execute concurrently they can force methods to execute sequentially eg by waiting for one to return before calling the next refinement between libraries l and l means that any program execution possible with l is also possible with l definition the library l refines l written l l iff ep × l ep × l for all programs p over actions note that is a preorder over libraries as library and program alphabets only on call and return actions c r our formalization that programs and libraries communicate only through method calls and returns and not eg through shared memory example the incorrect stack implementation of figure does not refine an atomic reference implementation since the execution of figure is by its composition with the program of figure history inclusion though we to develop automated techniques to check observational refinement between libraries the definition of section does not suggest any practical means it only suggests every possible execution of every possible program in this section we introduce an equivalent notion based on concise abstractions of program executions called histories besides being independent of programs this equivalent notion helps expose the structure of the refinement problem and suggests practical means of automation which we develop in section histories for given sets m and v of methods and values we fix a set l m × v × v of operation labels and denote the label m u v by mu v a history h o f is a partial order on a set o o of operation identifiers labeled by f o l for which f o mu implies o is maximal in the history he of a wellformed execution e labels each operation with a summary and orders operations · o i e and ei c · iff i j ei r and ej c · f o mu v if e and e mu if e and ret o e an operation of h labeled by l is called an operation the histories by l are hl he e el example figure b the history of the execution in figure a arrows the order relation modulo transitivity operations o and o are ordered in h if os return precedes os call for example push precedes pop however pop is incomparable to pop because pop s return comes after pop s call and pop s return comes after pop s call the order among operations call actions is irrelevant as is the order among their return actions while the general concept of histories allows arbitrary partial orders of operations any history he arising from an lts execution e into a restricted class called interval orders intuitively this is because our execution model assumes that operations share a common notion of global time the actions in an execution are linearly ordered definition an interval order is a partial order o such that o o and o o implies o o or o o lemma the history he o f of a wellformed execution e forms an interval order o proof suppose o o and o o in he and fix i i i i such that ei and ei are the return actions of o and o and ei and ei are the call actions of o and o note that i i and i i since linearly orders i i i i either i i in which case o o or i i in which case i i i i so o o example figure d the history in figure b as an interval order each operation is represented by an interval on the real number line such that o o iff the interval associated to o before the interval associated to o in this work we consider only histories of wellformed executions ie those forming interval orders without explicit this notion of histories gives rise to a natural order relating histories by their operation ordering basically a history h is weaker than another history h if h contains all completed operations of h and preserves the order between hs operations the pending operations of h can be either omitted or completed in h definition let h o f and h o f we say h is weaker than h written h h when there exists an injection g o o such that · o when fo mu v and v · go go implies o o for each o o o · fo for each o o where mu v mu v iff m m u u and v v we say h and h are equivalent when h h and h h example figure c a history h weaker than the history h in figure b note that h contains two pending pop operations one of them is completed in h it corresponds to the pop operation and one of them is omitted in h throughout this work we do not distinguish between equivalent histories and we assume every set h of histories is closed under inclusion of equivalent histories ie if h and h are equivalent and h h then h h as well history inclusion is equivalent to refinement our notion of histories has two important properties which makes refinement between libraries equivalent to inclusion between their history sets the first property is that libraries are closed under the weakening relation essentially when l admits the history he of an execution e then it also admits the history he of any e which is derivable from e our definitions of and coincide to imply he he lemma if h hl and h h then h hl a history h is essentially an abstraction of the set e he h of executions which preserve an order between returns preceding calls the closure properties of definition ensure that a library l admits all executions e with he hl lemma el e c r he hl lemmas and ultimately imply the equivalence between refinement and history inclusion essentially any given history h of a library l can be captured by a program ph whose observations witness the ordering among hs operations however its observations cannot additional orderings between hs operations this is due to the closure properties in definition the refinement l l implies that l also admits those observations through one or more histories h it then follows from lemma that l also admits h h for the reverse direction it follows from lemma that history inclusion implies inclusion of executions and ultimately observations theorem l l iff hl hl proof let h o f hl we show h hl by constructing a program ph over actions which only admits executions with histories stronger than h e e n h he where n o o f o mu v is the number of completed operations in h given such a program ph taking any execution e × l with e n we must also have an execution e × l such that e e by definition of l l since e n and e we also know that h he and since ec r el we have he hl along with any history weaker than he by lemma namely h we construct ph q q over alphabet whose states q o b track operations status the initial state is q o o o transitions are given by for each q q o o m m v v if f o mv and qo for all o o then qo qo if f o m v then qo · a qo if f o m then qo qo it is routine to verify that ph is a program according to definition moreover in any execution e the call of any operation o must come after the return of each o o furthermore all completed operations of h are completed in e if and only if e an note that e may contain more completed operations than h because of the last transition rule but less pending operations because the transition rule corresponding to the call of a pending operation may not have been applied in e it follows that e n h he let p be a program over actions and e ep × l we show that e ep × l since ec r el we know he hl by definition of hl and then he hl by hypothesis by lemma we deduce ec r el and thus by definition of lts composition e ep × l comparison with linearizability the linearizability criterion provides an alternative characterization of library which implies observational refinement in this section we demonstrate that linearizability is generally than observational refinement yet the two criteria coincide when the reference implementation is atomic linearizability is defined by an execution order e e iff there exists a wellformed execution e obtained from e by return actions and deleting call actions such that e is a permutation of e that preserves the order between return and call actions ie a given return action occurs before a given call action in e iff the same holds in e for example the second and the third executions in example are smaller than the first with sequential calls to push and pop an execution e is linearizable wrt a library l iff there exists a sequential execution e el with only completed operations such that e e a library l is linearizable wrt l written l l iff each execution e el is linearizable wrt l since linearizability compares executions of l which may contain pending operations with executions of l in which every operation is completed observational refinement need not imply linearizability when l contains nonterminating methods ie where the calls to these methods are pending in all executions example let l be the library whose kernel contains the single execution e mu m u in which the call to m is pending although l refines itself since refinement is reflexive l is not linearizable wrt itself since e could only be linearizable wrt l if el were to contain one of the following executions mu mu m u ret mu m u ret m u ret mu yet el e clearly contains none of them a typical correctness criterion for concurrent objects is linearizability with respect to atomic versions of themselves despite the negative general result of example when restricted to atomic libraries linearizability and history inclusion and thus observational refinement coincide this relationship essentially follows from the relationship between the order relations and lemma e e iff he he proof by definition e e means that there exists e such that e is a permutation of e preserving the order between return and call actions thus e e and thus he he furthermore since e is obtained from e by returns and deleting calls he he by transitivity he he the other direction is equally straightforward theorem l l iff hl hl if l is atomic proof let h hl by hypothesis any execution e with he h is linearizable wrt l ie there exists an execution e l with only completed operations such that e e by lemma this implies he he by the closure property in lemma if he hl then h he hl let e be an execution of l by hypothesis he hl which by lemma implies e el since l is an atomic library there exists a sequential execution e el with only completed operations such that e e thus e is linearizable wrt l history inclusion by the equivalences of section checking whether a given history he is included in a set hl of library histories is equivalent to checking whether he is linearizable with respect to l for a atomic library l it follows that deciding he hl is nphard for an arbitrary library l since it is nphard for the atomic register object generally speaking the only known algorithms to decide he hl must check whether each possible linearization of the history he is equivalent to some sequential execution of operations according to l backtracking to try alternate on each failed attempt recent work implies that the more general problem of checking whether all histories hl of the original definition of and assumes that l is a set of sequential executions here we consider a slight extension adapted to concurrent executions faithful to the original intention where l may be a set of sequential executions a given library l are included in the set of histories hl of a fixed library l is undecidable since it is equivalent to checking whether l is linearizable wrt l when l is atomic these complexity suggest approximations to the history inclusion problems ie both h hl and its more general variation hl hl in order to tractable algorithms in this work we focus on parameterized under approximations for detecting violations to observational refinement achieving increasing accuracy with decreasing efficiency for this we design a notion of parameterized approximation functions ak which map any history h to a weaker history h and which have the following properties ah ah h completeness there exists k n such that h tractable inclusion hl is decidable in polynomial time when k is fixed this approximation is convenient since whenever is not included in hl then neither is h since hl is closed under weakening if h were to belong to hl then any weakening and in particular would also belong to hl while completeness means that increasing k increases the ability to detect observational refinement violations this must a decrease in efficiency since the inclusion problem hl is nphard when k is not fixed by design the approximation function ak allows us to solve the approximate history inclusion problem hl in polynomial time for fixed k for the more general problem of refinement between libraries l and l our approximation whether hl hl and becomes decidable for fixed k so long as the set h hl is computable completeness of ak ensures overall completeness ie that for any h hl hl there is some k n such that hl hl our key challenge is to develop approximation functions ak for which history inclusion can be computed in polynomial time for fixed k and for which observational refinement violations surface with small k we demonstrate the latter in section ­ in this section we develop a schema of approximation functions for which the approximate history inclusion problem is polynomialtime computable our development exploits structural aspects of the history inclusion problem in particular we exploit the fact that histories are interval orders with a natural measure of complexity ie the interval order length this notion of length we abstract each history h to a weaker history whose length is bounded by k and represent the set hl of histories restricted to interval length k by a formula against which can be evaluated in polynomial time § finally we exhibit a program monitoring scheme which can be used to decide our approximate observational refinement problem h hl hl or as a generalpurpose monitor § history inclusion the past of an element o o of a poset o is the set o o o o of elements ordered before o example in the history h from figure b the pop and pop operations have the same past namely the operation push while the past of the push operation consists of the push pop and push operations this notion of operations induces a linear notion of time into execution histories due to the following fact lemma the set o o of of an interval order o is linearly ordered by set inclusion furthermore this linear notion of time has an associated notion of length which corresponds to the length of the linear order on operations definition the length of an interval order o is one less than the number of its distinct we denote the length of the interval order o underlying a history h o f as len h our approximation functions ak map histories to weaker histories whose corresponding interval orders have length at most k while there are various ways to define such a function ak any such function enables the polynomialtime inclusion check hl which we demonstrate in the following section describes a polynomialtime computable instantiation of ak which we have found useful in practice interval orders have canonical representations which associate to operations intervals on the real number line their canonical representations minimize the interval bounds to the length lemma an interval order o of length n n has a canonical representation i o n mapping each o o to the interval io i j n with i o o and j o such that o o iff sup io inf io the canonical representation thus associates the interval i j to an operation o which succeeds the ith past and precedes the j st past note that the interval of an operation can be determined in polynomial time by counting the distinct among operations example figure e the canonical representation of the history in figure b note that len he we define the counting representation h of a history h o f whose underlying interval order o has the canonical representation i o n as the multiset h f o io o o of pairs defining l h h hl yields a criterion equivalent to history inclusion based on counting representations which follows from lemmas and lemma he hl iff he l example the counting representation of the history h in figure b is the multiset push pop pop push push pop empty this counting representation leads to an effective logical characterization of history sets using arithmetic operations inequalities and a counting function formally operation counting logic is the firstorder logic whose syntax is listed in figure the function is interpreted over a history h o f as i j h o o f o and io i j where i is the canonical representation of o we allow predicates p of arbitrary arity over operation labels so long as they are evaluated in polynomial time furthermore variables are quantified only over the operation labels which occur in the history over which a formula is evaluated the satisfaction relation for quantified is defined by h x f iff o o h f x f o i j n integer constants l constants x l variables x x t i x i j t t f t t p x x f f x f figure the syntax of operation counting logic where h o f the quantifier count of an operation counting formula is the number of quantified variables in an operation counting formula represents a library l up to k when h hl iff h for every history h of length at most k lemma checking if a history h satisfies an operation counting formula of fixed quantifier count is decidable in polynomial time proof this follows from the facts that the canonical representation of h is polynomialtime computable see lemma functions and predicates are polynomialtime computable and quantifiers are only instantiated over labels occurring in h the latter implies that quantifiers can be replaced by a disjunction over the labels occurring in h o f h x f iff h f x f o oo monitoring histories though there are numerous ways to define a function ak which approximates histories to weaker histories the natural solution we consider here is an ak which maintains the last k interval bounds precisely abstracting all previous interval bounds with equality formally given a history h o f such that len h n and k n we define o f by o o iff o o and n k inf io where i is the interval map of h intuitively ak only the ordering between recent operations which have started after interval n k it follows by definition that h since ordering constraints are only removed from note that h if len h k lemma let i and ik be the interval maps of h and for each o o with io i j n k n k we reduce the online of histories to the of integer counters as the first step in establishing the link between history and counter we define the operator for a given history h o f let h o o f o mu h o f o mu v st f o mu where is the transitive closure of o o f o v relating all completed operations to o as the following lemma shows the operator allows us to manipulate our directly without having to maintain the precise history he of an execution e note that besides maintaining this formulation requires us to compute as well lemma let e e · · if len he len he data interval length k n data stream e c r of actions result counting representation initially n s switch input action do if call action then if previous action was return then incr n if n k then end so n incr mu k k end case return action i so k mu i k incr mu v i k end yield algorithm an online operation algorithm for computing the approximation of a given history he · if len he len he additionally · · the second step in establishing the link between history and counter is given by the following lemma which implies that history extension ie execution step corresponds to either a single counter increment or a single and a single increment lemma let len h k if h h then · h h mu k k if h h then · h h mu v i k mu i k where i is the interval map of h and io i k as noted before lemma besides ing counters as operations begin and complete we must compute as well thus merging the interval bounds we in order achieve to maintain this with an a history interval operation ap applied to a counting representation formally for all l and i j k if is completed then i j i j i k j k i j i j k i j i j and if is pending then i j i k i k i k i where the conditional function n × b n is defined by n n if is valid otherwise the following lemma establishes the intended effect of lemma if len h k and h then algorithm computes the counting representation of a given history incrementally according to the and shift operations of lemmas and the variable n maintains the interval length of the execution history he while the variable s maintains the so of the interval of each operation o in he so can be discarded once o completes the corresponding in when o is invoked is given by k as the interval bounds used in may not k when o completes it is possible that some number of shift operations have translated its interval in as the number of performed shift operations is equal to k os in when is given by so k it follows by lemmas and that algorithm computes theorem algorithm computes the history approximation of an execution e in ol · k space and oe time where is the maximum number of concurrent operations in e in the worst case e in practice however one expects the number of threads and thus concurrent operations to be bounded the effect of e on asymptotic space complexity corollary the approximate inclusion problem hl is decidable in polynomial time for fixed k given an operation counting formula for l up to k of fixed quantifier count as an online monitor program pk for history approximation algorithm effectively reduces the approximate refinement checking problem between l and l to a safety verification problem on the composition pk × l as pk tracks the counting representation of the current execution es approximation we must only verify whether satisfies the formula for l up to k corollary given an operation counting formula for l up to k the approximate inclusion h hl hl is equivalent to the safety verification problem pk × l where is interpreted over counting representation atomic collections atomic collection objects including stacks and queues are among the most investigated concurrent objects we demonstrate that our approximation is effective in refinement violations for these objects in the sense that most violations can be with approximations ie k depending on the data structure we achieve this by families of operation counting characterizing these structures with or properties informally if n n is a for then for any history h there exists a weaker history h h with len h n while this h may not correspond directly to for k n we can deduce there exists some h whose violates our results build off of previous of concurrent data structures into a small set of constituent properties for ease of presentation in the following we consider only completed histories ie in which no operation is pending this restriction comes without loss of generality for library implementations which ensure that each operation can complete when by others in any case our can be extended to handle pending operations as well the space complexity of algorithm is constant in the number of operations when the size of integers is fixed as in the case of modern computer architectures otherwise the space complexity is in the number of operations ie in execution length i j x i j ii j j y ik i i i k y y rv x y y x ev x y z z y z fv x x y y y y x y lv x x y y y y x y y figure four families of characterizing atomic data structure violations parameterized by the interval length k n the predicates hold when x is the label of a push pop or operation respectively and y holds when x and y are labels with the same value either in the argument or return position all are of size polynomial in k and have fixed quantifier counts for stacks and queues a formula family is an indexed set i i n we say a history h satisfies written h when h i for i len h we say that a family has a n n when for each history h there exists some h h such that figure defines four families of · rv characterizes remove violations in which a pop operation returns a value for which there is no corresponding push · ev characterizes empty violations in which some pop operation returns empty yet whose span is covered by the presence of some pushed element which has not yet been · fv characterizes fifo violations in which some pair of occur in the opposite order of their corresponding pushes · lv characterizes violations in which some pair of occur in the same order as their corresponding pushes and the second push occurs before the first pop as in previous work our arguments for the partial completeness of these properties rely on data independence ie that library executions are closed under consistent renaming v v of method values and assume that each value is pushed at most once in practice data structures are data independent and the second condition can always be met by tagging each value with a unique identifier however in order to achieve bounded counting representations we may only distinguish between these values up to equivalence relations with finite formally we say a history o f uses unique values when f o mu v and f o mu v implies o o theorem the families rv ev fv and lv of have and respectively proof here we prove the theorem for rv and fv the others follow similarly since rv does not between intervals h o f rv iff ah o f rv next let h o f fv and let and be the instances of the variables x x y and y respectively let denote the formula parametrized by k in the family fv by push pop pop n push pop push pop pop n pop empty figure a family of empty violations parameterized by n n definition h where k len h we consider only the case when holds the other case is similar besides the constraints on operation labels the formula states that all operations end before an operation starts and all operations end before an operation starts let i o n be the canonical representation of h also let j resp j be the maximum upper bound of an interval associated to an resp operation ie j max j o o io i j f o j max j o o io i j f o we define a weaker history h h that contains exactly the same set of operations as h but it preserves only the ordering constraints o o st io j and io j or io j and io j the length of h is at most and h fv since ah h rv has corollary the families of stack rv ev lv and queue rv ev fv have and respectively while rv and fv are complete in the sense that they characterize every possible remove and fifo violation the lv and ev families are incomplete example demonstrates this for ev by a parameterized history hn for n such that hn yet hn for all n while it is possible to define a family which all empty violations in histories with interval length at most k a fact that we demonstrate in section we do not currently know whether it is possible to construct a formula which all empty violations in histories with interval length example in the history of figure n pairs of push and pop operations ensure that throughout the span of the some element is always present ie at every time between the call and return of there exists some element v v such that has completed yet pop v has not yet it follows that any such history would not be included in the histories of an atomic queue library the family ev however only captures such violations for n ie with a single pair spanning despite the theoretical possibility for empty violations which only surface for large n our practical experience suggests small n to suffice the bug b of our static analysis experiment in section as an empty violation and was detected with approximation a n ie where some push operation precedes similarly although the history of figure b satisfies the formula ev so does the weaker length history of figure c furthermore we have found that the same bugs which manifest as empty violations often manifest as order violations as well the bug of figure a is such a case had the first thread executed another push before push then the final pop of thread would have returned yielding the order violation push push pop denotes an atomic fifo queue library with push and pop methods completeness for bounded interval length while section demonstrates complete families queue and stack of operation counting for the and objects for histories of interval length up to and respectively this section complete for histories of any bounded interval length k n for the rest of this section we fix an interval length k n and demonstrate that a bounded enumeration of histories suffices to characterize every possible violation given a history h o f an element o o o is a pair of operations such that f o and f o for some v v we say that two distinct elements o o and o o are redundant with h when their operations have the same and futures and thus will share the same canonical intervals we say the element o o is redundant with h when there exists an element of h with which it is redundant we say that h o o f extends h o f with o when o o iff o o for all o o o and f o f o for all o o lemma let x stack queue if h extends h with o o and o o is redundant with h then h iff h to enumerate the histories let ik i j i j n i j k be the set of integral intervals up to k n and fix an arbitrary total order over ik we define the function h mapping any subset i i in in ik to the history o f where o i i i n i j i j iff f i j if j pop i if j such that i i i i in in then we define the finite set hk hx x ik notice that the histories of hk do not contain redundant elements finally we define the finite subset hk of histories which are not by lx for x stack queue and enumerate them to write the formula characterizing length k violations to lx xk h h where h characterizes the history h o f with operations o on and elements and its extensions h x xn xj xj oi oj note that xk is polynomial in size and has fixed quantifier count for fixed k n theorem let x stack queue if len h k and h uses unique values then h iff h atomic libraries with contextfree kernels while the previous section provides formulae for particular classes of atomic objects here we provide a systematic technique to derive formulae for any atomic library that can be written as a contextfree language including similarly to the definition of past from section we define the future of an operation o in an history o f by o o o o objects such as locks and or contextfree approximations of arbitrary libraries for this construction we require finite sets m and v of methods and values given an atomic library l such that el is context free and an interval bound k n we generate a formula lk representing l up to k our construction relies on theorem we recall that the parikh image of w is the multiset w n mapping each symbol a to its number of occurrences in w and the parikh image of a language e is the set e w w l of its words if el is context free then the language ek e el len he k of ls executions with histories has the same parikh image as a contextfree language and by theorem ek can be represented as a presburger formula from which we derive lk theorem let l be an atomic library over finite sets m and v of methods and values such that el is a contextfree language and let k n then there exists an formula lk representing l up to k this construction is useful in practice allowing us to derive the used in our experiments of section experimental evaluation to demonstrate the practical value of our approach to refinement checking we argue that our · violations with small values of k · can be efficiently implemented for use in systematic concurrency testing and runtime monitoring and · can be efficiently implemented for use in static analysis to argue these points we have studied actual concurrent data structure implementations in cc including the computing suite some of these implementations such as the queue are meant to preserve observational refinement while others such as et als are meant to preserve weaker properties unless otherwise noted we use these implementations without modification except to annotate methods with a fixed set of possible points eg preceding accesses while space including the of our study the sample and analysis which we do include is representative for our first two experiments § § we have developed a tool for systematically a large number of alternate executions involving a limited number of object method invocations we run each operation on a separate thread and execute all thread schedules up to a given number n n of thread at specified points similarly to tool with n there is only one schedule to execute though the number of schedules grows exponentially as n increases for instance with our annotation of in queue we execute f n schedules of a program with method invocations at a rate of roughly one schedules per where f is given by f f f f f while similar in spirit to the second our third experiment § executes all thread schedules up to a given number n n of symbolically we use to a simple program which invokes a limited number of library methods and then version to perform bounded model checking up to a given bound all measurements were made on similar pro intel core ii machines more precisely they have been designed to be linearizable violations covered w k covered w k covered w k covered w k linearization operation counting figure comparison of violations covered with k each data point counts histories on a scale over all executions up to on nonblocking queue with i operations and j operations the is ordered by increasing number of executions ­ over ij we show only points with over executions the largest data points measure the total number of unique histories encountered over a given set of executions second are the number of those histories refinement following are the numbers of those violations covered by ak for varying values of k in this experiment a exposed no violations coverage of refinement violations to show that our approximation ak observational refinement violations with small values of k we measure the number of history violations detected by a traditional linearizability checker versus those by ak the linearizability checker serves as an exact measure due to the equivalence of section while the approximation of a violation he may not itself be a violation one to some execution e for which the violation covers he ie for which he figure demonstrates that ak covers most or all violations with small values of k while a suffices to cover all violations at nearly all data points besides the first point where the sample size of executions is small relative to the operations all values k capture a nontrivial and increasing number of violations note that our results of section are not by the fact that a and a have violations violations were due to not having encountered a enough sample of executions in fact as the size increases the is ordered by number of executions over operations the value of k required to capture a violation appears to decrease all violations being captured by a after a certain point operation counting for testing runtime monitoring figure compares the runtime overhead of our a approximation versus a traditional linearizability checker sampling executions with up to operations on nonblocking queue since computing the set of sequential queue histories over n operations becomes expensive as n increases a timeout of m for n we the computation of entirely simply the of a given execution history without checking inclusion despite our implementation one the cost by linearization as the number of operations increases the we implement a monitor as in see figure comparison of runtime overhead between monitoring and operation counting for a for up to operations each data point measures runtime on a scale normalized to execution time over all executions up to on nonblocking queue with i operations and j operations the is ordered by increasing ij and each data point is from up to executions times do not include of sequential histories for monitoring while our ak monitor well usually maintaining under x overhead the linearization monitor exponentially running with nearly x overhead with operations number of increases exponentially and performance with only operations instrumentation overhead is nearly x our implementation of a avoids this overhead though not optimized we observe a x runtime overhead this scalability suggests that our approximation can be used not only for systematic concurrency testing with few method invocations but also for runtime monitoring where the number of operations grows without limit operation counting for static analysis our approximation ak also leads to an effective static means of refinement checking due to the simplicity of by using only simple increment and operations on integer counters and program assertions on those counters we are able to static verification tools capable of integer reasoning we have found that the major in applying static tools is concurrency even though the required counter reasoning is simple reasoning precisely about thread interleavings is challenging with or without our instrumentation despite the of precise static reasoning about thread interleavings we have successfully applied our approach using two different one based on and and the other based on and both are based on and bounded model checking our results in table report on the latter among data structure implementations we manually injected realistic concurrency bugs all bugs were as refinement violations with approximation a or a in executions of up to of a program with at most push and pop operations and with loops up to times although the time complexity of concurrent exploration is high independently of our instrumentation particularly as the number of increases one clearly that our approximation is effective in detecting violations statically we constructed program assertions automatically via theorem library bug p k m n time queue b head × s queue b tail × s stack b × s stack b push × s stack b pop × s elimination stack b × s elimination stack b × s elimination stack b × s set b × s queue b × s table for the static detection of injected refinement violations with for a given program with i and j invocations to the push and pop methods we explore the schedules of with m loop iterations with a monitor for our ak approximation bugs are b nonatomic lock operation b bug b nonatomic cas operation b b assignment b lock b related work previous work on automated verification for concurrent objects focuses on the linearizability criterion while has long held that linearizability implies observational refinement et al recently proved this fact they also proved that the two criteria coincide when considering only library executions in which all operations have completed our results in section further we show that the two criteria coincide for atomic object specifications and that in general observational refinement can hold for objects the theoretical limits of linearizability are well studied and show for checking a single execution et al show membership for checking finitestate implementations against atomic specifications but only when the number of program threads is bounded et al show the same problem is undecidable with unbounded threads and introduce a decidable variant for a restricted class of executions several approaches for proving linearizability and thus observational refinement have on annotating method bodies with linearization points to reduce the space of possible history to one single linearization these methods often rely on programmer annotation and do not admit evidence of a violation in the case of a failed proof automated approaches for detecting linearizability violations such as enumerate the possible history this exponential cost effectively limits such approaches to executions with few operations as noted in section s approach this cost with linearization points as in the approaches and ultimately from the same problem a failed proof only indicates incorrect annotation references p a f l b and a an integrated specification and verification technique for highly concurrent data structures in tacas pages ­ r k l and d modelchecking of correctness conditions for concurrent objects inf comput ­ d n t w reps m sagiv and e comparison under abstraction for verifying linearizability in cav volume of lncs pages ­ a m c and j verifying concurrent programs against sequential specifications in esop volume of lncs pages ­ springer s c m and r a complete and automatic linearizability checker in pldi pages ­ acm i p w ohearn n and h yang abstraction for concurrent objects theor comput sci ­ b fischer o and g a concurrency for sequential c verification tools in pages ­ ieee p b and e testing shared memories siam j comput ­ t l representation and enumeration of interval orders and phd thesis college t a henzinger a and v vafeiadis aspectoriented linearizability proofs in concur pages ­ m and j m linearizability a correctness condition for concurrent objects acm trans program lang syst ­ c m m and h fast and scalable lockfree queues in volume of lncs pages ­ d and m c bounded model checker contribution in tacas volume of lncs pages ­ a and t w reps reducing concurrent analysis under a context bound to sequential analysis formal methods in system design ­ a s qadeer and s k a solver for reachability modulo theories in cav volume of lncs pages ­ y w chen y a and j sun model checking linearizability via refinement in fm volume of lncs pages ­ m m michael using instructions technical report rc ibm t j watson res ctr m m michael and m l scott simple fast and practical nonblocking and blocking concurrent queue algorithms in pages ­ acm m and n concurrent data structures in d and s editors of data structures and applications pages ­ and press san ca m s qadeer t ball g p a and i finding and in concurrent programs in pages ­ usenix association p w ohearn n m t e and g verifying linearizability with in pages ­ acm r parikh on contextfree languages j acm ­ i the dimension of journal of combinatorial theory series a ­ z and m source language details from verifier implementations in cav volume of lncs pages ­ springer o n g a aiken m sagiv m t and e testing atomicity of composed concurrent operations in oopsla pages ­ acm r systems programming with parallelism technical report rj ibm res ctr v vafeiadis automatically proving linearizability in cav volume of lncs pages ­ p expressing interesting properties of programs in propositional temporal logic in popl pages ­ acm press s j scalable automatic linearizability checking in pages ­ acm 