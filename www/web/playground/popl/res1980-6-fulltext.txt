synchronous schemes and their decision extended abstract problems abstract manna stanford university institute and of pnueli university and science the assignments and the truth values of a class of schemes called synchronous schemes that are implied by the outcomes of tests is defined a synchronous scheme can have several are recorded the of each generated variables but all the active ones are required to statement box is annotated with the keep a synchronized rate of computation as information known at this point the utility of measured by the height of their respective this attached information is that whenever we herbrand a reset statement which a test whose result can be from causes all the variables to a new the information currently available we can tion is it is shown that equivalence the test and just the branch convergence and other properties are decidable to the known truth value if the process for schemes in this class the class of terminates the resulting scheme is free ie synchronous schemes contains as special cases it has the desirable property that every path in the decidable classes of schemes the scheme graph is realizable by some computation schemes with and the convergence and divergence problems of schemes free schemes are decidable bot for all or for some interpretation introduction problems are decided by inspection as is wellknown equivalence convergence a free scheme for some interpretation if and other properties of schemes ii ri it contains a halt statement and it and more generally of schemes for all interpretations if it does not contain cm c are decidable the deep reason for ps in its graph or explicit loop statements this is not the restriction to a single variable but the fact that the computation in a moreover if a scheme is known to be free and is fully annotated in the sense that all known uniform between the values of program the only tool that has been variables are recorded at any point we can developed to date for analyzing general schemes resolve the following inner equivalence is that of and annotating p m problem for a scheme with output variables z g the loops of the scheme are during this relations between process the inter that are implied by and is it true that for any interpretation and any computation z z when the tion halts this property holds for free and this is technical stanford an extended of university abstract of a the computer science dept stanford ca this research in part by national science foundation under grant by the of under contract the research or copies are to prior a fee andor specific permission © fully annotated schemes if and only if z z is implied by the information exit box in the scheme attached to each this procedure approach does not provide a decision for general schemes because the amount of information is unbounded and therefore the process of and a general scheme to form an equivalent free scheme may not terminate thus the only solvable cases are of schemes which are restricted in a way that the amount of information is bounded such can be obtained if we are allowed to discard already information being that the discarded information would never be for again in this work we define and study a class of schemes called synchronous schemes which is a generalization of schemes as well as of schemes p p synchronous schemes allow for many variables but require that the values of these variables during a herbrand computation are kept synchronized in the sense that the differences between their heights are bounded this enables us to discard information concerning values of height lower than the current values and hence suggests that finite will be applicable terminology and definitions the general class of schemes that we der are represented by with the following types of basic statements boxes initialization y yn l where each ti is an expression only constant symbols containing assignments i yl yn q jd termination where each ti is an expression that contain constant symbols as well as the variables i y may these boxes are by edges which are labeled by conditions a condition is a boolean combination of atomic formulas of the for example condition a is a we impose a determinism if the edges leaving a given box are respectively labeled by the conditions c cp then these conditions must be a exclusive i j implies cj ie no two conditions can b exhaustive true ie at least one condition must hold a and b together imply that exactly one exit condition must always hold on the following page is an example of a scheme scheme s in a conventional form and its representation scheme s in our transition graph style a scheme is said to be simple if all its expressions t are of the form f ur and all its tests are literals of the form ur or pu ur where each constant u is a variable or am individual by the results in it is sufficient to consider the behavior of schemes under the class of all herbrand interpretations the sequel we consider only herbrand domains constructed from the individual constants and function symbols of the given schemes for a herbrand term t we define its as nesting depth of the function symbols in t thus for i etc consider a herbrand computation of a scheme s at any stage s in the tion each program variable yi holds some herbrand value which we denote by let his be the height define also ms of this value ie t py f i o f t ly t f o t t y halt o halt a scheme in conventional form a dy ii transformation graph form of the maximum of the heights of the variables yl at state s let as denote maximum of mj for j the up to the current state s ie as j s a scheme is called for an integer k o if in every herbrand tion after each assignment step of the form y l r s to state sl the r going from state heights of the recently assigned values satisfy either a s r or b k that is either all the newly assigned values have height not less than k below the previous maximum or all variables are reset to heights not k a step of the te b is called a reset step a scheme is called for some synchronous k if it is a somewhat different approach is to define a scheme to be if after every step s assigning values to y yj j a we have that r s r or b k as above here as is the maximum since the last recently reset computed thus we relate values to the the heights of maximum as rather than to the maximum ms a scheme is called monotonic if it is these for some k o two concepts are closely related claim a scheme is monotonic synchronous iff it is obviously if a scheme is it is also this is a direct consequence of the fact that as ms since it is a maximum on the other hand it can be shown that a scheme is always n kl monotonic here n is the of variables and is the height of any of the expressions c appearing in the s consider the implications of a monotonic computation at any state of the computation some of the variables are active in the sense that they hold values of heights to the maximum after a finite of computation unless we enter into an loop the maximum must rise and some of the variables rise with it all active computations must occur within a distance k of the maximum some other variables may drop behind and become dead a dead variable may in an assigned expression together provided there is some live with it in the expression variable a dead variable may be by to it a value of height to the maximum in a reset all variables are to values of height k main results the class of synchronous special cases schemes contains the class of schemes with the more general class of with the class of schemes schemes these are the main classes is known to be decidable we derive the following synchronous schemes for which results equivalence for every scheme s c be effectively transformed into an equivalent scheme s which is simple free and synchronous this transformation is carried out by am algorithm which will be discussed later the checks that the scheme under mation is actually reports failure otherwise hence we have for a given k it is decidable whether a scheme is however it is undecidable though partially ble due to whether a scheme is synchronous that is whether there exists a k such that the scheme is the following property enables us to late concerning synchronous schemes within the to automata framework without reduction the class of synchronous schemes is closed under cross product are synchronous so is ie if and properly s defined as a consequence we have of the transformation convergence and divergence both for some interpretation for all inter are decidable for synchronous schemes in comparing two synchronous schemes and s the inclusion problem s s and the equivalence both decidable problem s s outline of the algorithm the main technique used in establishing these results is the algorithm for transforming a synchronous scheme s into a simple synchronous scheme s as described in above roughly this algorithm operates on an arbitrary scheme in the following way a consider a synchronous scheme with no we introduce first auxiliary variables and intermediate computations to make all terms simple next we analyze the scheme by associating with each box in the scheme the following lists of bounded size i a list of the known truth values of tests ii between variables these will be equalities such as y only have to retain note that q such relations we of depth not a dependent on k hence there are only finitely many such possible relations iii the difference in depth of each variable from the maximal depth these will be numbers not k obviously these lists can contain only a bounded amount of information md only finitely many different combinations of these lists exists we use these lists as tags to the nodes in the scheme we may now the original scheme tagging each box with the information a node in the original scheme may correspond to several nodes in the new scheme each tagged with its own annotation providing full information about the inter relations between the variables the resulting scheme will be simple free and synchronous b next we consider a synchronous scheme with our task here is to eliminate the let us partition the scheme s into s sn each of which con a reset instruction as its first instruction but no other instances of be exits any si to any sj which must go through the main entry of s j we apply a above to each of the si s then we form the cross product scheme s which simulates sl sn s allocates disjoint sets of each component si and in parallel the operations required by each of the components a special tracing mechanism is provided for representing the situation that si exits to sj u to decide the equivalence of synchronous schemes we first study the problem of inner equality since the result of the preceding algorithm tags each box with the between the variables we only have to the tag on all exit statements and check whether it contains or implies the statement z z now in order we have only to test equivalence of and to consider the inner equality s problem for acknowledgements we are to richard for their detailed paper reading and of this references c a k on the properties applications of program schemas phd thesis stanford university march cm a k and z manna program schemas with proceedings of fourth acm symposium on the theory of computing may the g s aj theory of program structures schemes semantics tion springer verlag lecture notes in computer science yi the logical schemes of algorithms u problems of vol press new york d c m s programs d m r park and h june m manna z mathematical theory of tion chapter h new york m p m s equivalence problems model of computation phd thesis cambridge in a ri j d on jacm january 