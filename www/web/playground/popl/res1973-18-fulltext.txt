analysis of a simple global data flow problems for by jeffrey s d unman princeton university princeton new abstract there is an ordering of the nodes of a flow graph g which sorts the dominance relation and can be found in steps this ordering is the re of the order in which a node is last visited while growing any depthfirst span tree of g moreover if g is then this ordering sorts the dag of go thus for a flow graph there is a simple algorithm to compute the dominators of each node in bit vector steps the main result of this paper relates two parameters of an if g is d is the largest number of back edges found in any path in g and k is the length of the interval de sequence of g then kd from this result it follows that there is a very simple bit propagation algorithm indeed the obvious one which also uses the above ordering and is at least as good as the interval algorithm for solving all known global data flow problems such as able expressions and live variables key words and phrases code flow graph interval analysis dominance depthfirst spanning tree global data flow analysis available expressions live variables i introduction when analyzing computer code improvement a there problems each of which can programs for is a class of be solved in this work was supported gj by nsf grant essentially the same manner these prob called global data flow analysis problems involve the local collection of information which is distributed throughout the program some examples of global flow analysis problems are available expres sions of c and ul live variables kc reaching definitions of a and a and very variables s there are several general algorithms to solve such problems the interval approach a a ac c ke s and au collects mation by partitioning the flow graph of the program into subgraphs called intervals replacing each interval by a single node containing the local information within that interval and to define such interval partitions until the graph becomes a single node itself at which time global information is propagated locally by the reduction process another approach vi u and propagates information in an obvious manner until all the required information is collected that is until the process con we shall show that this second approach with a suitable node ordering is no worse than the interval approach prior to presenting the main and the algorithm we review part theory of reducible flow graphs result of the t in va v implemented this kind of flow analysis and the obvious algorithm in a bell fortran ii strict ly purposes ii background a flow where graph is a triple g a n is a finite set of nodes leaves b e is a subset the edge xy node x we say of y and y is of called the enters node y and that x is a a successor of x a from xl to is a sequence of nodes x in e for xl such that the path the is of path is a cycle c node no in n is the initial node there is a path from no to every node intervals g let g be a the interval is defined flow graph and h a node with header h as follows of a place h in ih b m is not entering i h if m is a node not yet in ih the initial node and all edges m leave nodes in ih add m to c repeat step b until nodes can t ih no more it should be observed that although m in b above may not be welldefined ih does not depend on the order in which for m are chosen a candidate at one iteration of b will if it is not chosen still be a candidate at the next iteration it is well known that a flow graph can be uniquely partitioned into disjoint in and that this process takes time proportional to the number of edges in the flow graph a if g is a flow flow of defined as follows graph then the de g denoted by is a the nodes of ig are the intervals of g b representing ng k if j to the there is an interval there is any header of k edge from j to that edge from and jk the node node in c the initial node of ig is the sequence gk is called the derived sequence for gk and gk k limit flow graph of g g if g ill gk is called the a flow graph g is called reducible an if and only if its limit flow graph is a single node with no edge hence called the trivial flow other it is called t and t let g let ww be an edge t is removal of this be a flow graph and of g transformation edge let y not be the initial node and have a single predecessor x transformation s the replacement of x y and xy by a node z predecessors of x become predecessors of z successors of x or y become successors of z there is an edge if and only if there was an edge yx or xx whenever t is ap as described here we say that x y there are two results from which interest us first if t and t are applied to a flow graph until no longer then a unique flow graph results independent of the sequence of applications of t and t actually chosen second a flow graph is reducible by intervals if and only if repeated application of t and t yields the trivial flow graph dominance and regions flow path if x and y are two distinct nodes graph g then x dominates y if every in g from its initial node to y con x p and lm let g be a flow graph nn let ele and let m be in n let we say r is a of g with header m if in every path xl and is there is such that a and where some i k b c are and l are in el that is is through access the to every node header only in the region as we proceed to flow graph each edge graph represents a set node represents a set a natural way apply t and t to of an intermediate of edges and each of nodes and edges a in we say that each node and edge in the original flow graph represents itself if t is applied to node w with edge ww then the resulting node represents what node w and edge ww represented if is applied to x and y with edge eliminated then the resulting node z t represents in addition what if x y and two edges xy xu represented and are replaced represents represented by a single edge then what xu and the two lemmas u which follow appear in lemma a let z be a node con during the reduction of some flow graph g if z represents edge xy of g then x and y are represented by z b let w and x be not necessarily distinct nodes constructed during the re of g and let e be the edge con from w to x if e represents yz of g then z by x y is represented by w and c in any graph formed while ing g all nodes and edges represent dis joint sets of objects nodes and edges lemma let g be an rf and let and e ce be a set of nodes and edges represented by a single node at some stage of the reduction of g then there is a unique node m in n such that is a region of g with header m and backward edges since t and t may be applied to an in different sequences it becomes necessary to discuss specific applications of t and t informally a parse of an is a list of the tions made ti or t and the regions to which they apply formally a parse n of an g is a sequence of the form or where u v and w are names of nodes and s is a set of edges we define the parse of an re as follows a a single node with no edge has only the empty sequence as its parse b if g which may not be the flow graph in a sequence of reductions is reduced to g by an application of t to node u and the resulting node is named v in g then followed by a parse of g is a parse of g where s is the set of edges represented by the edge uu from g c if g is reduced to g by an ap of t to nodes u and v with u v and the resulting node is called w then followed by a parse of g is a parse of g where s is the set of edges represented by the edge uv in g d in both b and c above repre in g carries over to g that is whatever an object represents in g is also represented by that object in g ex for those changes in representation caused by the particular transformation tl or t currently being applied let g be an and let v be a parse of g we say that an edge of g is a back with respect to n if it appears set s of an entry of n and a forward otherwise in the next two results appear in lemma are unique the backward edges of an lemma edge of an dominates x edge xy is a backward if and only if xy or y depthfirst spanning trees a a flow ordered tl depthfirst graph g spanning spanning is a directed tree tree rooted by algorithm of a a of a flow graph of the order visited flow graph g with n nodes of g a nodes from to n ie for each node m indicating in which each node was last method al the root of the is the initial node of g let this node be the node m which is visited first in il a visit node m if node m has a suc x not already on the select x as the rightmost son of m found so far in the spanning tree if this step is success full visited there node x becomes the node m to next by step a is no such x go to step a be if let m be the node being visited e i i i if m is the root then halt otherwise down the node toward the and visit this node again by returning step a d root to if uv is the the ancestor the transitive son relations is an edge in a of v and v is the son and descendant relations closures of the then u of u are and let g be a flow let t ne be a of g ee fall into three classes graph and the edges in a descendants edges which run from we call forward to b edges to ancestors or call back edges which from run from a node to descendants itself we c edges which run between nodes which are by the relation we call cross edges the notion of to the right has only been defined for nodes with the same we extend it by saying that if x is to the right of y then all of xs descendants are to the right of all of ys descendants thus if uv is a cross edge of a then u is to the right lemma of an g are exactly any for g the backward edges the back edges of iii node ordering and let t be a of a flow with n nodes we consider two of the nodes of g graph g orderings rithm a a defined in algo b for each node x order is the reverse of we define the of an g to be g all of its back edges t do not this definition of for edges in a with the previous one for edges in an they are not necessarily the same and context should distinguish which one is meant lemma the dag of an order defined the partial order is a subset of by the total proof let g be an let g be the dag of g and let t be any of g it suffices to show that if there is a path in g from the initial node to node y which includes node x with xy then suppose in contradiction that there are two distinct nodes x and y such that there is a path in g from the initial node to y which includes x and then end that is y is last visited after x is last visited while grow ing t either y is an ancestor of x or y is to the right of x in t if y is an an of x then g contains a cycle this is impossible consequently y is to the right of x the path from x to y must go through a common ancestor of x and y tl so there would again be a cycle in g u if i is a predecessor of j in an then either is a back edge or a for edge of an if it is a back edge then either j dominates i or ij lemma and thus i cannot j if ij is a forward edge of an then this is exactly the property of which algorithm b uses the dominators b computes a set of m for each node m from to n for g number reducible flow graph g the nodes are by according to some refer to each node by its output sets where i is in if and only if i dominates j method b and nr jl b mj k such for each node j n in is replaced by the intersection over all predecessors that k j o turn of k of j theorem algorithm that is after algorithm in mj if and only if b is correct b terminates i i dominates j is proof by induction let g be an on j we proceed inductive ing node j i dominates j hypothesis is in after process if and only basis jl trivially true step jl inductive hypothesis for all the case for j assume the k j and con itself if i dominates j every predecessor thus i is in then of j which i not i now suppose i is in mj but i does not j then there is a cycle free path from the initial node to j which does not pass through i let k be the node on the path immediately before j by lemma kj cannot be a back edge else j would k or kj and the path would have a cycle thus kj is a for edge and as ik and i does not k we have by the inductive hypothesis that i is not in k and hence not in o if we implement the dom sets by bit vectors b requires oe bit vector steps this follows because in a flow graph with e edges at most e bit vec tor intersections are computed in step b also the node ordering ed as input can be computed in oe steps tl in au aho one step algorithm and same time bound and unman present an to compute dominators algorithm pm has the allen and ac first ordering of then dominators of an arbitrary their algorithm which is rithm b may require more through the nodes suggest to compute graph but similar to algo than one pass et al present an thm which establishes an interval similar to but takes ordering more than oe steps aho hopcroft and unman have an oe step algorithm to find direct dominators in an in t tarjan presents an algorithm for ng direct dominators in oe n steps t we shall always steps and bit ing complexity important distinguish vector steps this distinction between when before leaving this section another result about we prove lemma if x dominates y the proof let g be a flow graph in which x dominates y and let t be any of g since any path from the initial node to y must include x x is reached before y while growing t thus x is on the backward path in t from y to the initial node that is and note that lemma is not just a of lemma lemma applies to non reducible as well as reducible flow graphs iv the main result following the main result several lemmas of this paper we establish definition the depth of an g is the largest number of back edges found in any path in g definition let g be a flow graph let ig be the derived flow graph of g and let g be g all of its where a is an edge from a node to itself we define the k of the de sequence of g to be o if g is the trivial flow graph otherwise that ko such that a b io c gk is the limit flow graph of g and d lemma let g be an and let g be g at some intermediate stage of its re by t and t if there is a path from node u to node v in g then there exist nodes w and x in g such that w and x are respectively represented by nodes u and v in g and there is a path from w to x ing proof let n be any parse of g which yields g at some intermediate stage the lemma is an easy induction on the number of steps of n taken to reach g ij g lemma by back let g be an nodes edges in g head intervals proof loops so and suppose lemma if the lemma is obvious for self let be a back edge in g thus h m by h is the initial node the lemma follows now consider the initial node where h is not suppose in contradiction that h does not head an interval in g since h must be in some interval let it be in interval k with header k first we note that every interval is also a region by lemma if m is not in k then k is not a region because conditions b and c of the definition of region are violated s m is in k as is an edge m must be added to k before h is but then there is a path from the initial node to k and to m which does not pass through h this would the assumption that h dominates m o lemma if u dominates v in an g u heads an interval in g j is the inter val containing v and iu j then iu dominates j in ig proof neither t nor t creates any new paths between nodes s if iu did not j then u would not v o the following lemma is essential theorem which follows for lemma g let pose let d be the depth d be the depth of ig then dd of an and sup proof assume all the hypotheses and let p be any path in g from pl to pk containing d back edges we shall think of p as an ordered sequence of edges p pp pp where the jth edge in p is pp j be the ith back edge in let p that is is the edge with the least m such that is a back edge and if the ith back edge is then the least mn edge see back edge is the such that figure edge with the is a back since let p is thus is a back edge inp each s in s is first we show that dominates s i for pick your from s because we know that s dominates il is a back edge lemma and we know that there is a path q from s i end k x i o q q d q q q d qb b q d q b q x q q begin pi a path in an from pi to pk containing edges do back to x in p which does not pass through il s suppose in contradiction that s il does not si then there is a path r from the initial node to si not con but by paths r and q we have ing s il s il this dominates a path to contradicts thus x not the fact that dominates s now we claim that all back edges in p except the first one are represented by themselves in ig and are back edges in ig that is an edge in g represented by an edge in ig still exists as an edge in ig whereas an edge in g repre by a node in ig does not to show this it suffices to show that in ig the node representing the interval j con s il dominates and is thus dis from the node representing interval k containing where and that the first back edge is represented a node in ig by since p is it follows that the ith and back edges are dis and thus by lemma the interval l containing s are distinct intervals of g j dominates in ig because s il dominates si in g lemma see figure back j intervals j k of lemma if kl then represents itself in ig because it is an inter interval edge it is a back edge ig by lemmas and in now suppose that kl that is is not in l certainly kj due to the forward path from si to in p s j dominates k by lemma hence x s il il represents itself cause it is an it is a back edge in ig by in ig be edge also lemma finally itself contradicts if the first in ig then the assumption back edge repre d d which dd n theorem main theorem if g is with depth d and derived sequence length k then kd an proof by induction on k basis ko graph thus do g is the trivial hence kd flow induction step inductive hypothesis an g with derived and depth d let d ko assume the for k and consider sequence of length k be the depth of ig case lemma dd thus dd by the inductive hypothesis thus or kd by case dd d or kd by the inductive thus hy case dd this because t and t in their of g to ig do not create nodes in ig which did not lemma hence the back are a subset of those of case cannot occur transformation paths between already exist edges of ig g n the of theorem is that although the interval analysis algorithm must take about ke bit vector steps to solve a global flow analysis problem for an with e edges au there exists an ob bit propagation algorithm to solve such problems in about de bit vector steps we pick up the in the inter val approach because in addition to ing the to a single node known algo a a reverse the interval process and to propagate global information locally figure shows an with k and dl moreover this can be extended in an obvious way so that large yet d remains k is thus arbitrarily there may be a decrease in the time required to solve global data flow analysis problems using the simple bit propagation algorithm when compared in any event to the interval the algorithm algorithm of ul and ki cannot be worse than interval analysis and must as for its i o flow graph g with dl and k v solution of two global flow analysis problems available expressions from c and ul an expression such as ab is able at a point p in a flow graph if every sequence of branches which the program may take to p causes ab to have been computed after the last computation of a or b if we can determine the set of available ex at to the nodes of a flow graph then we know which expressions have already been computed prior to each node thus we may be able to eliminate the redundant computation of some expres sions within each node let d be the set of expressions in a flow graph g com let n we interpret x as the set of expressions which are in node x informally expression is if either a or b is defined within node x the symbol indicates a generic binary operator d let n if an expression is in ax then we imagine that within node x and that nor b is subsequently defined r is neither a node sions from let and for x be respectively the set of available at to and node x each exit the fundamental enable us to compute x are relationships for which each node for section of over all y of x is the for each node x x have the ae largest since solution solution do not necessarily for we want the algorithm which follows is a bit vector algorithm and similar to those in ul and ki except for the node ordering we distinguish between sets and bit vectors by using vectors for sets and for bit c computes for each node m bit vectors ini n graph the nodes are from to n by the time of last visit in a of g ie refer to each node by its number bit vectors where the ith resp is if expression is in j bit vectors have length number of expressions bit and resp p and of only if the ith j all where p is the output bit vectors method cl initially ls for j and al all s c do step c for any bit changes otherwise halt j for any n in j repeat order step c set t of equal to the prod a t here the and no t symbols a stand product or complement functions for the sum and k ranges over all predecessors of node j live variables a path in a flow graph is called with respect to a variable v if there is no definition of v on that path a variable v is live at a point p in a flow graph if there is a path for v from i to a use of v that is v is live if its current value might be used before v is having the set of live variables at exit from each node in a flow graph we can use this information register allocation for among other things we can determine when a value should be kept in a register be cause of a subsequent use let k be the set of variables ring in a flow graph g occur u let n x the clear of x is the set of variables which are not de in node x let hn variables which x ie those clear path from use within node u bx is the set of have exposed uses in node variables with a definition the entry of node x to a x node exit let and x be the set of variables from and on to for each live at node x the fundamental enable us to compute x are relationships which for each node lv for each exit node w in g ie w has successors successors for x not is the union y of x an exit node of over all lv for e node x fix hx have want lv since lv do not necessarily a unique solution for we the smallest such solution let be the bit vector for set d computes bit vectors for each node m nl graph g the nodes are from to n by the time of last visit in a ie its number refer to each node by bit vectors and where the ith bit of resp is i if and only if the ith variable is in j resp bj all bit vectors have length q where q is the number of variables bit vectors method d os for lj initially all d do any otherwise step bit d for changes halt j n in order for any j repeat d set equal to the a where ranges over all successors of node j sum k h vi analysis the algorithms ul and termination and c and d follow ki we focus correctness of directly from on the complexity lemma any path in an g beginning with the initial node is increasing by proof back edges thus is a any such path contains no by the proof of lemma and path in the dag of g sorts the dag of g lemma o theorem step c of algorithm c is executed at most d times for an g proof a o propagates from its point of kill or the initial node to the place where it is needed in dl iterations if it must propagate along a path p of d back edges it takes one iter ation for a o to arrive at the tail of the first back edge of p this follows since all edges to this point are forward or cross edges the numbers along the path must be in increasing sequence by lemma after this point it takes one iteration for a o to up each back edge in p to the tail of the next back edge by the same argument hence we need at most dl iterations to propagate information plus one more to detect that there are no further changes d theorem step d of algorithm d is executed at most d times for an g proof a indicating a use backward along a path to a point in d iterations if there are d back edges in the path from the point to the use it takes one iteration for al to reach the head of the back edge in such a path as in theorem we prove this by noting that forward and cross edges under go from higher to low er nodes an additional iteration enables us to reach the head of each suc back edge rl vii conclusions there is an ordering of the nodes a flow graph g which i sorts the dominance relation of g of ii if g is reducible and sorts the of g iii can be found in oe steps as a direct consequence the dominators of each flow graph in oe bit we can compute node in a reducible vector steps also we have analyzed a simple bit propagation approach for solving global data flow analysis problems which is simple to describe understand and program this approach requires at most de bit vec tor steps whereas the interval approach requires at most ke bit vector steps plus for intervals where k and d with kd are parameters of the moreover although node splitting is necessary when using the interval ap on flow graphs the simple bit propagation approach works on flow graphs directly with no such modification au al references av aho hopcroft and jd u on finding lowest common ancestors in trees proc th annual acm symposium on theory of austin texas pp may av aho and jd unman the of parsing compiling vol ii prentice hall nj and fe allen program optimization annual m york review vol automatic new a a ac c kc ki lm p fe allen control sigplan notices vol pp july analysis no fe allen optimization north amsterdam a basis for program ifip conf holland co fe allen and j graph theoretic constructs for program control flow analysis ibm re search report rc tj watson research center heights ny j global common sion elimination sigplan notices vol no pp cp analysis ordering of nodes no pp and of graphs jacm vol jan j by ms and jd unman graph vol siam j no pp june ms and jd unman of reducible flow graphs tr computer science laboratory dept princeton univ jan hopcroft and jd unman an n algorithm for detecting re princeton sciences graphs proc th annual conf on information and systems pp march k kennedy a global algorithm international computer math vol dec flow analysis pp ga global expression optimization at compile time this proceedings oct in es and cw ob code optimization cacm vol no pp jan rt applications of boolean matrices to the analysis of flow diagrams proc joint computer conf new york pp dec pm s t t t ul u v pw and ef graph cacm vo pp august moore in a directed no m of global flow prentice hall nj mathematical analysis theory to appear re tarjan depthfirst and linear graph algorithms vol no june search siam pp re tarjan finding dominators in directed graphs to appear in proc th annual princeton conf information sciences and sys march re tarjan acm symp austin may testing flow graph proc th annual on theory of comput texas pp jd fast algorithms for the elimination of common computer science laboratory dept of princeton univ march jd unman the elimination on e a fast algorithm for of common proc th symposium and automata theory va private tion of june 