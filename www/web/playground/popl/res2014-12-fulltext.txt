abstract satisfaction department of computer science university of california berkeley department of computer science university of oxford daniel department of computer science university of oxford abstract this article introduces an abstract interpretation framework that the operations in sat and smt solvers in terms of lattices transformers and fixed points we develop the idea that a formula denotes a set of models in a universe of structures this set of models has as fixed points of deduction abduction and quantification transformers a wide range of satisfiability procedures can be understood as computing and refining approximations of such fixed points these include procedures in the family those for preprocessing and in sat solvers decision procedures for equality logics weak and procedures for approximate quantification our framework provides a unified mathematical basis for studying and combining program analysis and satisfiability procedures a practical benefit of our work is a new architecture for implementing solvers categories and subject descriptors f mathematical logic mechanical theorem proving i deduction and theorem proving deduction keywords abstract interpretation logic decision procedures reasoning and abstraction static and satisfiability solvers represent practical of computer science in the face of theoretical results static analysis problems are typically undecidable yet compute information that is in compiler optimization and program verification the satisfiability problem for several logics and theories is nphard but sat and smt solvers handle large problem instances arising in practice in this paper we introduce an abstract interpretation framework that makes explicit some fundamental between the way undecidable and nphard problems are solved in practice this framework has several applications including of satisfiability algorithms the development of smt solvers based on abstract interpretation and the generalization of satisfiability algorithms to static analysis abstract interpretation is a framework for reasoning about fixed points the approach to ap permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work must be for all other uses the popl january ­ san diego ca usa copyright is held by the acm abstract interpretation to a problem is to tions to the problem by fixed points identify a space of fixed point approximations and design an algorithm to compute these the application of abstract interpretation to static can be understood in terms of the schema below the box on the left is called an abstract domain it consists of a lattice a with each element a of a representing a set of program states each statement s in the programming language defines four transformers the predecessor transformer maps a to states the program may have come from before executing s while the successor transformer maps a to states the program may reach after executing s the transformers and capture must behaviour properties of programs are specified as fixed points of such transformers a fixed point iteration property check refinement the box on the right represents procedures that use components of the abstract domain to reason about fixed points iterative procedures are used to compute fixed points these procedures may use a widening or dual widening operator to convergence if the result is not precise enough a narrowing or dual narrowing operator is used to refine the result the architecture above achieves a valuable separation of concerns by allowing the design and implementation of an abstract domain to be independent of the fixed point approximation procedures abstract satisfaction is a framework for applying fixed point approximation to logical reasoning in the same manner that abstract interpretation was first applied to static analysis consider the satisfiability problem for a logic an smt solver typically works in a fragment t of the logic elements of t are represented using data structures such as sets partial functions graphs or matrices these elements are manipulated using techniques called constraint propagation decisions learning and subsumption we show that a solver can be understood in terms of the schema below which closely the structure of a static analyzer elements of t ordered by implication form a lattice of approximations t false true a solver can use deduction to compute facts implied by or use abduction to compute facts that imply these operations define deduction and abduction transformers and and their counterparts and for reasoning t false true ext ext theory propagation conflict detection decisions and learning propagation and learning in solvers can be viewed as the application of these transformers techniques like decisions used by a solver to improve precision correspond to a relaxation of widening called denoted ext and ext while techniques like subsumption and clause minimization correspond to a relaxation of narrowing which we call interpolation denoted int and int thus despite external differences there are fundamental between the of sat and smt solvers and static we believe that making these explicit has several consequences that we discuss below abstract interpretation to smt one consequence is a transfer of techniques from abstract interpretation to smt solvers solvers have been extended with abstractions and joins to improve time and memory efficiency and with widening to aid in loop invariants we show that the internal data structures of smt solvers are lattices which means that these data structures also support joins and widening we show that quantifiers are transformers which means that abstract quantifiers and best abstract quantifiers are well defined notions thus an abstract interpretation perspective suggests a new approximate approach to deduction and quantifier elimination smt to static analysis the main conclusion of our work is that smt solvers like static operate on abstractions however smt solvers return precise results which means their algorithms can be understood as techniques for refining an analysis these techniques are based on properties of lattices and can be used to refine static analyses smt solvers for decidable logics implement refinement procedures that are guaranteed to terminate though termination proofs can be nontrivial the fundamental undecidability of static analysis problems the existence of terminating refinement procedures an insight we present in section is that deduction and abduction in a logic coincide with reasoning about the postconditions and preconditions of conditional statements improvements in deduction should lead to an improved handling of conditionals in static moreover preprocessing and techniques which are responsible for recent performance improvements in solvers can be lifted to static analysis constraints a unification a goal towards which this work is an early step is to achieve a uniform theoretical and practical treatment of static analysis and smt solving specifically if both can be understood in terms of lattices and transformers their and differences can be studied using lattice theoretic techniques the three different problems of combining static combining smt solvers and combining a static analyzer with an smt solver can be reduced to the single problem of combining fixed point approximation procedures existing procedures such as the reduced product and which are now understood to be combination procedures can all be applied to the same task we practical benefits from carrying out a unification a complex piece of software like a static analyzer or an smt solver into smaller blocks consisting of lattice elements transformers and an iteration engine leads to a justified modular design we expect this modularity to contribute to the development of extensible and solvers and and reduce the performance and development overheads involved in integrating different mathematical we denote the complement of a set s as and the set of all subsets of s as the powerset ps the function from x to f gx is denoted f g and a function f is treated as a set a f a when convenient sequences we use sequences to simplify presentation an is a function m a whose length m is denoted we write f for the application f s sn and leave implicit that has length n given a function g a c we write ga c for the function that maps a to c and x distinct from a to gx we write a sequence of substitutions ga ca c · · · with pairwise distinct elements ai as c¯ lattices a transformer is a monotone function on a lattice a lattice is bounded if it has a greatest element called top and denoted and has a least element called bottom and denoted a function f on a lattice is if f x x for all x and is extensive if f x x for all x a function is idempotent if f f x f x for all x an upper closure is an idempotent and extensive transformer and a lower closure is an idempotent and transformer the pointwise order f g between functions from a set to a poset holds if f x gx holds for all x the pointwise meet of f and g denoted f g where both functions map into a lattice is defined as x f x gx the pointwise join is similarly defined the set of transformers on a complete lattice form a complete lattice under the pointwise order a lattice is distributive if every x y and z satisfy x y z x y x z which is equivalent to the identity obtained by meets and joins an element y on a bounded lattice is the complement of x if x y and x y may not exist and when they do may not be unique we use the notation ¬x or x for unique in a distributive lattice are unique a boolean lattice is and distributive the de morgan dual of a function f on a boolean lattice is f ¬ f ¬ the powerset lifting of f a b is the function f pa pb that maps a set to its image under f the least and greatest fixed points of a monotone function f on a complete lattice are denoted and galois connections let l and m be posets two functions l m and m l form a galois connection if for all x l and y m x y if and only if x y a galois connection is written as l m or l m the function is called the left adjoint and is called the right adjoint of the galois connection in a galois insertion is a a collecting semantics for firstorder logic the phrase collecting semantics in abstract interpretation refers to associating meaning to an object in terms of its properties for example a trace property is a set of sequences of states and the collecting trace semantics of a program which is also the strongest trace property the program satisfies is the set of all program executions in this section we introduce a compositional collecting semantics for quantified firstorder formulae our semantics allows us to interpret a formula as an element of a lattice so that abstract interpretation of formulae and of properties of formulae is well defined the collecting semantics of a term is defined by lifting the standard evaluation semantics of terms to sets of environments the collecting semantics of a formula is the set of models of the formula the boolean operations of conjunction disjunction and negation have their standard interpretation as intersection union and set complement quantifiers are interpreted as transformers between structures over different sets of variables of several semantics for quantified firstorder logics we use a treatment due to pitts a key feature of this treatment is to make the set of free variables part of the syntax of a formula the structure of the lattices over which a formula is interpreted are then determined by the syntax of formula quantifiers define transformers between lattices over different sets of free variables see for a discussion of the challenges in giving a semantics to quantifiers structural rules we recall the structural rules for forming terms and formulae the signature of a firstorder logic sig ar consists of disjoint sets sig pred fun of predicate and function symbols whose arity is ar sig n a function symbol is called a constant we use p q r to range over predicate symbols and f g h to range over function symbols let vars be a set of variables and x y z range over variables a firstorder context is a finite sequence of variables in which each variable occurs exactly once we write for the empty sequence for sequence concatenation and var for the set of variables in a context in the case of logic a context is a sequence of pairs where each pair consists of a variable and a sort a context is a of if var var the rules from for forming are given below we abbreviate to terms for convenience in addition to standard rules for variable introduction var and function composition fun we use a rule seq for forming a sequence of terms the rule for function composition has the side condition that ar f is we leave such side conditions implicit in the remaining rules var x x fun f t · · · tn seq from these rules we can derive the rules for complete substitution and weakening weak given below t x¯ r · · · rn t weak t are composed with predicate symbols and boolean operations to obtain we abbreviate to formula in the boolean operator rule below op is one of true false or ¬ applied to the appropriate number of arguments pred p op op the weakening rule for formulae is similar to that for terms quantification changes the set of free variables in a formula and causes contraction of a context x q x x q x the sets of terms and formulae in a context are denoted term and form respectively an atomic predicate is the composition of a predicate symbol with terms and a literal is an atomic predicate or its negation a clause is a disjunction of literals and a is a conjunction of literals a formula in conjunctive normal form is a conjunction of clauses and one in disjunctive normal form dnf is a disjunction of the sets containing these formulae are denoted lit clause and dnf respectively if not specified the formulae we deal with are quantifierfree semantic structures we now introduce a structure in which to interpret formulae this structure consists of a lattice and transformers and provides a template for implementing smt solvers based on abstract interpretation recall that the classical semantics of firstorder logic is given by a m val int which consists of a universe val and an interpretation that maps each function symbol f to a function val val and each predicate symbol p to a relation int p val an environment over maps variables in to values let env var val be the set of environments over the classical semantics of firstorder logic is given by a relation m specifying when an environment satisfies a formula categorical logic does away with environments by observing that env val is isomorphic to val len firstorder significantly extend this observation to provide a semantics for firstorder logic in definition below we adapt the definition of a firstorder to of environments the reader may at the length of the definition one can view the classical and algebraic definitions of semantics as making different tradeoffs in the classical semantics firstorder structures have a definition but the definition of is in algebraic semantics the definition of a structure may appear involved but in our leads to a defined semantics each item in definition is required to provide semantics for some aspect of firstorder logic the lattices of tuples pval n represent the domains over which function symbols are interpreted the lattices of environments represent the domains over which are interpreted we use the function v that maps values to environments to deal with substitution into a term and the function to deal with substitution into a predicate the existential and universal projection functions and give a concrete transformer semantics to quantifiers definition a collecting defined by a firstorder structure m val int consists of the items below the lattices of tuples pval n n n the lattices of environments for every context for every context x xn of length n there are two translation functions for mapping between tuples and environments v pval n v v xi vi v pval n e i vi xi vi e there is a weakening function for mapping environments from a of to environments over wk wk e e for all x in x x for every of an existential projection and a universal projection in e wk e e wk e a lifting of the interpretation of function symbols to sets f pval pval v v the relation for each predicate symbol the existential and universal projection functions as defined above eliminate arbitrary we only use them to eliminate single variables and use the following abbreviations we write x and x for projections that extract a single variable by mapping environments over the context x to those over x conversely we write and all x for projections that eliminate a single variable by mapping environments over x to environments over we also write wk x for the weakening function from environments over to those over x collecting semantics the collecting semantics of terms and sequences of terms with respect to a classical interpretation m follows we drop the subscript m when no ambiguity arises · m term n pval n the semantics function is defined inductively below the semantics of a term t with respect to a set of environments e is given by evaluating t in each environment in e the semantics of a sequence of terms is a set of sequences of values substitution constructs a sequence of values and it to an environment x e x e e val for some e vi ti for all i f t v example below demonstrates how to calculate the semantics of a term in the presence of substitution observe that the term does not have to be rewritten before being evaluated example consider the term t x yy x derived below var x x weak x x y var y y weak y x y fun x y x y var x x fun x x x yx x y x x we interpret variables as natural numbers and as addition the semantics of the term above is a function in x pn x yx x y x x x y x y v x x x x y x y v e x x e x y x y e x x y x e x y x y e x x e e x e in short a set of environments is mapped to values obtained by the value of x by the collecting semantics of terms is the standard evaluation semantics also called forward interpretation implemented in program the semantics of quantifierfree formulae given next is a backward interpretation and is known but is less standard the inverse pval is defined as follows v env v the semantics of a formula is given by a function · m form defined inductively below boolean operators have their standard settheoretic interpretation p true env false ¬ ¬ quantifiers are interpreted using projection functions x x x all x x example we extend example to illustrate the semantics of quantification consider the formula xx yy x z with interpreted as equality over the natural numbers the relation is n n n n and the semantics of the formula is a set of environments over z xx yx x y x z z x yx x y x z e x z z x z n n n as expected z maps to of this example shows that the semantics of a quantified formula can be calculated mechanically by applying the appropriate transformers if the concrete transformers are replaced with abstract transformers we can similarly calculate an abstract semantics the collecting semantics we have defined is consistent with the classical semantics of firstorder logic theorem for each formula in nonempty context classical firstorder interpretation m and environment env m exactly if m we also refer to environments as structures let be a nonempty context a structure is a model of if a formula is unsatisfiable in m if m is the empty set and is satisfiable in m otherwise we refer to satisfiability in a structure as satisfiability for the rest of the paper a sentence is a formula in an empty context the set of environments over the empty context is the empty set if m is we say that is true in m and otherwise is false in m concrete reasoning the basic operations in logical reasoning can be viewed as giving a dynamic interpretation to an implication deduction is the process of deriving from abduction is the process of deriving from in classical logic these processes have we can start with ¬ and attempt to deduce ¬ a process we call or start with ¬ and attempt to ¬ a process we call in this section we model these processes using transformers and characterize properties of formulae as fixed points of these transformers as with fixed point of program correctness these fixed points are not meant to be computed but will be used to design fixed point approximation algorithms the set of formulae that can be derived from a set of formulae using a set of rules r forms the deductive closure of with respect to r deductive closure and automated reasoning procedures have in terms of consequence operator or as the transitive closure of a set of rewrite rules an important difference between these and ours is that we operate on sets of structures so our notions of deduction and abduction are semantic existing can be derived from ours by abstract interpretation but we can also derive abstractions of deduction that operate on objects other than formulae structure transformers a structure transformer for formulae in form is a function t structure transformers encode reasoning about the models and of a formula the deduction transformer which encodes reasoning about models of in the definition below we assume that the settheoretic operations are lifted pointwise to functions p x p ¬ ¬ the use of negation in defining ¬ is problematic in general because lifting such a definition to abstractions requires a structure that supports boolean reasoning we discuss this issue in greater detail the transformer encodes reasoning and of if is used for satisfiability checking can be used for validity checking p x ¬ p ¬ the two transformers above reason in that they start from hypotheses and attempt to derive conclusions the dual notion to deduction is abduction where we start from a conclusion and derive the hypotheses under which that conclusion holds for example if we can true from a formula we know that is valid with respect to a set of structures p x ¬ p ¬ finally we have a transformer which models starting from a conclusion and deriving the hypotheses from which that conclusion does not follow a transformer can be used to the space of p x p ¬ in addition to deduction and abduction quantifier elimination is fundamental to logical reasoning the transformers and all x model quantifier elimination and will be called quantification transformers there are several between deduction and abduction which are preserved in our formulation we make these properties explicit in theorem below the settheoretic identities are not necessarily satisfied by abstract transformers which is why they are not used as a definition the of deduction and abduction as closures extend the existing characterization of logical consequence as a closure the characterization of existential quantification wk x as an upper closure and of universal quantification wk x all x as a lower closure when combined with the view of closure operators as abstractions the connection between quantification and abstraction used in model checking the galois connection between weakening and quantification was first observed by and indicates that even domains that do not support negation will support both existential and universal quantification theorem structure transformers have the following properties the transformers satisfy the identities below x x x x ¬ x x x x ¬ the transformers and are lower closures the transformers and are upper closures the composition wk x is an upper closure and wk x all x is a lower closure the pairs of transformers and all x are de morgan the pairs of transformers form a galois connection on ¬ ¬ figure the vertices represent deduction or abduction procedures for checking satisfiability of or validity of ¬ the edges represent combinations of deduction and abduction procedures the quantification transformers are related to weakening by the following galois connections x and wk x x the galois connections are useful for deriving equivalent of properties of a formula for example the models of are env a formula is unsatisfiable exactly if env which by the galois connection is equivalent to env in words we can determine if a formula is unsatisfiable by trying to deduce false from or trying to from false similarly a formula is valid exactly if env or equivalently env since satisfiability corresponds to existence of a model we can equivalently define it in terms of existential quantification treating quantifiers as transformers allows us to techniques that combine variable elimination and deduction fixed points for satisfiability we now show that properties of a formula can be characterized by fixed points of structure transformers consider the process of computing consequences of we initially know nothing about which we can express as true a single step of a reasoning algorithm may indicate that after k steps the algorithm may deduce that · · · k k what we know about the models of can be represented by the sequence t · · · k the process of deduction can thus be viewed as a greatest fixed point computation whose limit expresses the maximal information we can derive about models of fixed points of structure transformers represent force algorithms the greatest fixed point represents the semantics of a solver that initially assumes that every structure is a model of and then eliminates of the fixed point represents a procedure that by eliminating of the fixed point represents a procedure that initially assumes has no and by finding of while does the same for models of the below first appeared in and is included here to include validity as the dual of satisfiability theorem the following statements are equivalent the formula is unsatisfiable the greatest fixed point is empty the least fixed point has all structures the formula ¬ is valid the least fixed point ¬ has all structures the greatest fixed point ¬ is empty in program analysis and model checking combinations of forward and backward analysis have advantages over a single method in logical reasoning we can similarly combine the benefits of deduction and abduction for instance as shown in conflict driven clause learning combines deduction and abduction the original and algorithm combined deduction via ordered resolution and variable elimination with the pure literal rule solvers that use the pure literal rule for combine all three we define combinations of deduction and abduction transformers below the transformers are defined on × with the lattice order shown for intuition about these combinations consider a greatest fixed point iteration with the transformer da which combines deduction and abduction the first element is env representing that every structure is a potential model and no structure is a potential a single application of da yields env which is a fixed point if is unsatisfiable this fixed point is env representing that there are no models and every structure is a when using abstract transformers a fixed point may not be reached in a single step so iteration allows information to be between deduction and abduction x y x y ¬x y y x ¬x y y x y y y ¬x ¬x y y ¬x y y x y ¬x y × × × × × × the transformer is based on iteration but the other combinations are to the best of our knowledge new an additional possibility for reasoning about satisfiability is to combine deduction with existential quantification ds and abduction with universal quantification aa these are only two of many possible combinations y x y wk x y × y x y wk x all xx y × the application of these transformers to satisfiability is below theorem the following statements are equivalent the formula is unsatisfiable the fixed point is env the fixed point is the fixed point is env the fixed point is env the fixed point is env the fixed point is env env the fixed point is the fixed point is env env connection to programs we now relate deduction and abduction transformers to transformers generated by programs assume a firstorder signature sig and variables vars as before we write abbreviated to b for an assumption statement with a quantifierfree formula b the operational semantics of the statement is below rel b b the context for a program is the set of variables in the program the operational semantics defines the four transformers below which are related to deduction and abduction in theorem post b x x b x x b post b ¬ post b ¬ ¬ ¬ theorem for a quantifierfree test we have that post and pre the consequence of theorem is that the same transformers can be used for deduction and abduction in an smt solver or for reasoning about conditionals in program analysis improvements in solvers lead to improved reasoning about conditionals and vice versa moreover the galois connection between deduction and abduction is a special case of the classic galois connection between postcondition and precondition transformers what of assignments a result of categorical logic shows that substitution defines a transformer that has two which universal and existential quantification transformers for assignments are closely related to transformers for quantification consequently assignment transformers which are in program analysis define approximate quantification procedures improvements in quantifier elimination procedures should lead to better transformers for assignments due to space restrictions we do discuss this connection further abstract reasoning this section presents three ideas the first is a standard application of abstract interpretation to the collecting semantics of formulae if concrete transformers are replaced by abstract transformers we obtain sound but incomplete conclusions about the properties of a formula the second is the notion of an abstract reasoning domain which provides the building blocks for smt solvers based on abstract interpretation in the same way that traditional abstract domains are building blocks of program the third idea is that standard logical notions such as or completeness are properties of a galois connection between lattices of structures and lattices of formulae abstract interpretation we recall essential notions of abstract interpretation assume two posets c and a related by a galois connection between an abstraction function c a and a function a c the fundamental fixed point approximation theorem of abstract interpretation is below with af representing the abstract transformer corresponding to f theorem let c a be a galois connection between two complete lattices and f c c and af a a be transformers satisfying f af then and in the case that c is a powerset lattice ps we call a if x x for all x s and if x x for all x s an abstract transformer af a a is a sound overapproximation of a concrete transformer f ps ps if f af and is a sound underapproximation if f af an abstract transformer af is complete for f at c if it satisfies f c af c and is complete if f af we say that f is fixed point complete if an abstract transformer af is complete for f at a if af a f a and is complete if af f abstract interpretation of formulae we introduce abstract which are derived from collecting by replacing concrete transformers with abstract transformers evaluating a formula with respect to an abstract allows us to approximate the semantics of a formula in a manner definition an abstract a consists of the following complete lattices and transformers abstract value lattices n for each n n abstract environment lattices for each abstract translation functions av n and n whenever len n an abstract weakening function for each context and projection functions for every of an abstract interpretation and its inverse f for every function symbol f sig an abstract interpretation of every predicate symbol p sig every abstract lattice above is related to the corresponding concrete lattice by a galois connection c a we extend the convention for collecting structures and write and x for elimination of a single variable the abstract semantics of terms and of formulae with respect to an abstract is given by the functions below · a term n n · a form we obtain these by replacing concrete transformers and semantics by their abstract counterparts in the definition c given earlier existing abstract domains already implement several components of definition these domains have abstract value and environment domains the abstract semantics of terms is called forward abstract interpretation of expressions and the abstract semantics of a quantifierfree formula is called backward abstract interpretation of expressions in the abstract semantics of a quantifierfree the concrete semantics if c a underapproximation is defined abstract domains in program analysis need not have a representation of the empty set for example the abstraction is a sound overapproximation when dealing with satisfiability a representation of the empty set is necessary to express that a formula is unsatisfiable soundness as defined below includes this condition the abstraction is not necessarily sound in the sense below definition an abstract a soundly a collecting c if every lattice in a satisfies and concrete and abstract transformers satisfy f af an abstract transformer af is the best abstract transformer if af f when dealing with these definitions are the soundness of abstraction for formulae is given below we discuss negation is more detail theorem if a is a sound overapproximation of c and is c a the interval domain we present an extended example of ab interpreting quantified formulae over intervals it is known that interval propagation can be used reason about terms but the ex we present shows that it also supports sound but incomplete reasoning about quantifiers the example also a difference between abstract quantifiers and best abstract quantifiers the complete lattice of intervals is defined over the set a b a b a b z with representing the empty interval and being the interval structure i contains the items below the value lattices n are product lattices n the interval environments are var the weakening function extends an interval with the new vari able going to y y var var the projection functions are given below x x x var x x x var if y for all y var var otherwise existential projection certain variables and universal projection is not only if the variables being are all the interpretation of functions and predicates depends on the signature of the theory considered example we compute the abstract semantics of the formula x x y using the interval domain x x y x y the domain also supports abstract quantification y x y y now consider y whose semantics is x y we have that x but showing that the existential projection transformer we have defined is not the best possible negation theorem only applies to formulae example illustrates the problem of formulae with negation example consider a logic with unary predicates of the form x k interpreted over the integers consider the parity lattice par e o which represents even and odd numbers let x k par be e if k is even and be o otherwise the complement in this lattice cannot be used to approximate negation to see why consider evaluating ¬x as x par which is e o but o does not include all models of ¬x the only sound abstraction of negation is to map every element to more generally in domains that allow for strict overapproximation of the semantics of a formula the only sound abstract negation will map every element to this problem only exists if the syntax of formulae have arbitrary negation if negation is limited to atomic predicates definition can be extended to include an abstract interpretation of the negation of every predicate definition can be extended to require sound overapproximation of negation of predicates and theorem can be extended to formulae in negation normal form a similar restriction is applied when model checking is combined with abstraction abstract reasoning domains we now identify the structure of an abstract domain for logical reasoning in addition to a lattice that provides approximate semantics of formulae and abstract transformers that provide approximate semantics for logical operators the domain includes operators for inductive reasoning in the sense of logic unlike deductive and reasoning which are both sound with respect to implication inductive reasoning models generalization or specialization which are not necessarily sound widening and operators implement inductive reasoning in program craig interpolation is another technique used for narrowing is a restricted form of interpolation in a lattice because it maps a pair satisfying a b to an element i satisfying a i and i b narrowing does not have the syntactic constraints of craig interpolation because the lattice is not necessarily constructed from formulae notion of interpolation which we call separation maps a pair satisfying a b to an i satisfying a i and i b while interpolation and separation are on boolean lattices they are not in general hence have distinct definitions definition a reasoning domain is an extension of an abstract sig structure with the following operations abstract transformers and for deduction and abduction a unary extensive function ext l l called and its dual ext l l called a partial interpolation function l × l l satisfying x y y whenever x y the element y is called an interpolant a partial separation function l × l l satisfying x y and y y whenever x y the element y is called a we use the word function and not transformers above because the operations need not be monotone as with widening example we apply abstract interval deduction by computing with x x y x and e e e x x y x x y e e x e x e y x e x y the fixed point is in the concrete but yields more information in the abstract than one transformer application the overapproximation and underapproximation conditions given earlier provide the following abstract satisfaction theorem theorem let o be an reasoning domain and u be an one if in o then is unsatisfiable if env in u then is unsatisfiable galois connection of syntax and semantics the first abstraction we identify is between syntax and semantics the galois connection below has been observed in different settings in the literature we are not aware of this connection being identified in the setting that we use theories and a theory is a set of formulae each called an axiom a complete theory is a set of formulae closed under implication the theory of a set of structures s consists of formulae which are true in every structure in s a set of structures s is definable if there exists a formula such that s these notions lead to a galois connection th st th s s st theorem there is a galois connection st th between structures and formulae the superset order is chosen because we interpret a set of formulae as their conjunction the galois connection allows us to view formulae as abstractions of structures and is appropriate for our goal of studying satisfiability in a investigation one may prefer to to formulae and view structures as abstractions by the galois connection a complete theory is one satisfying and a set of structures s is definable if s proof systems the galois connection of syntax and semantics allows us to view proof rules as transformers on an abstract domain of formulae and logical soundness and completeness as soundness and completeness in the sense of abstract interpretation a proof rule is a relation between formulae in a rule containing n n the formulae n are called and n is the a proof system is a collection of proof rules of possibly different a unary rule is a set of formulae which are also called the hypotheses a formula is derived from a set of formulae using a proof system written if occurs in or if is derived from n by applying an nary inference rule and the formulae n are derived from the deductive closure of a set of axioms with respect to a proof system is the set of all formulae that can be derived from with a proof system is sound if every derived from is in the theory of a proof system is complete if every in the theory of can be derived from a is a derivation of false a proof system defines a transformer from a set of formulae to its immediate consequences there exist i n is in a proof rule the fixed point with respect to the superset order contains all formulae derivable from since multiple applications of proof rules are required to derive a conclusion is not usually a closure operator properties of proof systems become properties of the abstract transformer lemma a proof system is sound exactly if st th and is complete exactly if th st while deductive soundness corresponds to soundness in abstract interpretation deductive completeness is fixed point completeness which is only one of several completeness notions abstract satisfaction procedures the framework in the previous section has already been applied to characterize satisfiability procedures for propositional and firstorder logics in terms of the lattices and transformers the method of truth tables propositional resolution and boolean constraint propagation were formalized as greatest fixed points in the classic algorithm was shown to be a fixed point refinement procedure in and was formalized as a combination of deduction and abduction in the congruence closure algorithm for the theory of equality with uninterpreted functions is a fixed point in a lattice of partitions and the application of the algorithm for deciding difference logic is a fixed point in a lattice of weighted graphs the algorithm used in smt solvers was characterized as an approximate reduced product construction in though different frameworks were used to give a characterization of the procedure and method those procedures can also be formulated in the language of this paper this section introduces a simple and systematic formulation of the abstractions above we introduce of and dnf formulae a wide range of lattices used in practice such as partial assignments equality graphs the intervals and binary implication graphs admit such a representation we exhibit galois connections showing that and dnf and their define semantic abstractions moreover these lattices support logical notions such as resolution the pure literal rule and subsumption we demonstrate that pre and techniques used in sat solvers can be understood as abstract quantification procedures thus these procedures have a semantic justification abstract soundness proofs and generalize to program analysis and closure we will use the notions of upward and downward closure to and dnf formulae to logics defined over posets a subset q of a poset a is closed if for every x in q and y in a y x implies that y is in q a set is called a the smallest containing q is denoted q and the of a singleton set x is denoted x in examples we denote a as the set of its maximal elements the lattice over a written da is the set of of a ordered by inclusion strictly because the lattice with respect to the identity relation is isomorphic to ps the dual notion to is the smallest containing q is q and ua is the lattice with intersection as join and union as meet let and max q denote the minimal and maximal elements of a poset q these sets form when convenient we assume that are represented by minimal elements and by maximal elements an abstraction a of a powerset lattice is disjunctive if a b ab completion is an operation that an abstraction with disjunction the completion of a is the lattice da with the abstraction and functions below unlike the standard treatment we use as abstractions da da ps x x q da ps da x x p ua ua ps x x q ua ps ua x x p for proofs that the pairs of functions above form galois connections and that the domains are disjunctive we can define the completion of a lattice if a lattice a ps the completion ps and the completion ps generalised abstract domains there is some about whether the use of representations is or to solvers we believe that is for solvers because it leads to simple and efficient data structures we also believe there must be deeper algebraic properties of that are to solvers one reason is because as we observed earlier leads to a simpler treatment of negation another is that several domains used in practice have generalized representations consider a poset of generalised literals one may think of as a set of semantically distinct formulae we define generalised clauses and dnf formulae by using to form conjunctions and to form since up and become if the identity relation is used as the order standard and clauses are special cases of this definition if contains formulae the function for the poset a is the function st clause dnf figure refinement order between the generalised domains p ¬p p prop partial assignments x y x y x vars equality graphs x y x y x vars difference graphs x k x k k n interval m n m n lit binary implication graphs table domains viewed as generalised clauses and from formulae to models if a is a generalized literal we write a for a literal that satisfies a a the relationship between these domains is depicted in the diagram in figure where an upward line denotes an abstraction relationship constructed by powerset operations are of generalised and formulae which are in turn of generalised which are of environments on the other hand the dual constructions give us domains of clauses generalised clauses dnf and generalised dnf respectively another property of this construction is that all domains obtained are distributive because and lattices are distributive as we show these domains are distributive lattices but do not express disjunction table lists domains that have generalized descriptions partial assignments consider a set of boolean variables prop a set of literals lit and the identity relation the lattice is isomorphic to the lattice of partial assignments the main data structure in solvers based on this domain was studied in equality graphs consider generalized clauses over the literals x y x y with the identity relation on literals identity between literals is different from the equality between variables over equality literals define equality graphs which are used in several solvers figure a graph with elements representing literals at the top two important operations in equality logic decision procedures are transitive closure and cycle detection we formalize transitive closure by the transformer trans trans g g x y x z z y g recall that a reduction operator is an abstract transformer satisfying that a a for all a observe that transitive closure is a reduction operator and the saturation of a graph with transitive edges is a greatest fixed point a conflicting cycle in an equality graph contains only equalities and exactly one edge a graph with a conflicting equality edge edge figure equality graphs over three variables the elements at the top are literals and the elements at the bottom all to the empty set y x x y y x x y x y x x y x y x y x y x y x y x y figure the lattice of interval environments over two variables the elements at the top represent the poset of literals while elements at the bottom represent singleton values cycle satisfies g the elements at the bottom of figure all contain conflicting cycles and to the empty set a similar abstract domain and reduction operation appear in the logic of order and directed graphs in interval consider the set of single variable inequalities x k x k k z which form a poset under implication the elements of are light grey in figure by representing intervals as instead of pairs we obtain a setbased representation that supports proof rules such as resolution and other algorithms in solvers that target clauses and example illustrates how intervals can be manipulated using example the interval domain as defined in section is not distributive because identities such as the one below fail now consider intervals represented as the meet in this lattice is union and join is intersection so it is trivially distributive we represent by their minimal elements x x x x x x x x x x x x a similar calculation yields the expected interval for the other interval expression the representation expresses the same concrete elements as the classic pair representation of intervals but contains more redundancy binary implication graphs if the set of generalised literals contains clauses of length such as p ordered by equality each generalised literal represents two implications q p and ¬p q which can be viewed as edges in a directed graph the resulting binary implication graph abstract domain is used for preprocessing in sat solvers though a analysis has not been previously applied to binary implication graphs we need not explicitly define galois connections or their approximation properties as these follow from the representation as with equality graphs transitive closure is a reduction the domains the generalized domains show that formulae have a lattice structure that is usually not recognized to see the difference between and consider the set x x x represents a clause but not a generalized clause while x x is a generalised clause solvers use a variety of subsumption techniques to minimize formulae without explicitly checking implication the inclusion orders in figure correspond to subsumption notions and also implication for instance p p q and p are logically equivalent but we can only show p p p q using the lattice order from the abstract interpretation perspective subsumption is not a substitute for implication but is fundamental to the lattice structure of and dnf domains abstract transformers in solvers generalized unit rule the unit rule in sat solvers asserts that if a represents a region of the search space and the all but one literal in a clause the remaining literal can be added to the clause the abstract conflict driven learning algorithm of the unit rule to abstract domains based on the notion of meet the unit rule can be viewed as a technique for refining generalized using generalized clauses a where a a and for all b a b we write for the function that maps elements a to fixed points a x of a function f y x the main observation of was that boolean constraint propagation is a fixed point x defined pointwise over unit rules the generalized in table when combined with the generalized clauses also support the unit rule and failed literal failed literal is a preprocessing technique in sat solvers the technique chooses literal a computes and if the result is adds the singleton clause b to where b satisfies that a b no action is taken if the result is not bottom note that we have not only described failed literal but also its generalization to domains clause variable elimination is a fundamental operation underlying quantifier elimination deduction and syntactic simplification of formulae the simplest form of sound variable elimination is to drop clauses from a formula in which the target variable occurs this idea directly to generalized domains if we drop constraints based on the literals they contain drop × c p p c c in general is an overapproximation of the deduction transformer if p is a boolean variable also existential quantification with respect to p resolution the resolution principle asserts that if c p and ¬p d are both satisfiable so is c d the variable p is the pivot and c d is the generalised domains support a generalization of resolution res × resp c d c p d q p q generalized domains that apply this transformer can produce proofs which is a first step towards combining existing abstract domains with techniques example the generalised element x x x x represents a conjunction of of bounds standard interval propagation will lose precision in the clauses while standard resolution does not apply because no constraint is the negation of another the result of generalized resolution with respect to the literal x is x x though arithmetic techniques methods can deduce the same information generalised resolution is simple and suffices in this case the pure literal rule clause is a sound but incomplete simplification technique because a formula that is unsatisfiable might become satisfiable after clause the pure literal rule introduced in the original algorithm of and can be understood as an application of clause only in situations where it does not change the satisfiability of a formula we formalize the pure literal rule for generalized domains recall that is the set of generalized literals we say that a set of literals a is pure if for each a in a no b satisfying a b is also in a we assume that is the disjoint union of two pure sets p and n such that for each a in p there exists a b in n satisfying that a b and the elements of p are positive literals and of n are negative literals define a set of a lattice of p and a lattice of polarity maps p p polarity analysis of a generalized formula computes a polarity map such that is or if the generalized literal only occurs or only in and is if does not occur in and is if occurs both and in the polarity of a literal is if a is in p and is if is in n the polarity map for a literal sends to its polarity and sends all literals b a to the empty set the polarity map for a generalized clause is the pointwise join of of polarity maps of its literals the polarity map of a generalized element is the pointwise join of of polarity maps of its clauses note that the join is used in both cases the pure literal rule for a generalized formula applies drop to a formula only if the polarity map for does not send the literal to the pure literal rule is a sound overapproximation of the deduction transformer and is a refinement of clause in propositional logic the pure literal rule applied to a variable p is also a sound abstraction of the existential quantification transformer wk p discussion and related work this paper to a research that to close the gap between abstract interpretation techniques and deduction algorithms both in theory and practice one direction of this program is to use deduction algorithms to refine static analyses precision loss due to joins was reduced by a static analysis with unification or best abstract transformers have been synthesized using satisfiability solvers and method while applied satisfiability techniques to reduce precision loss in fixed point iteration another direction in this is to characterize satisfiability procedures as abstract interpretations boolean constraint propagation was shown to be an abstract interpretation in and was generalized to combine deduction and abduction over lattices in method was characterized as a technique for refining abstract transformers in the method for theory combination implemented in smt solvers was shown to be a special case of the reduced product of abstract domains the technique for reasoning about a theory by combining a sat solver with a theory solver was also shown to be a special case of the reduced product in in addition to static analysis applications these provide a new way for lifting solver algorithms to new logics for example method was lifted to arithmetic in while was lifted to floating point logic in note that the combination was lifted to abstract domains prior to the reduced product characterization abstract satisfaction is in an attempt to with static analysis if static analysis is ignored the framework provides one generic approach to implementing decision procedures the separation of boolean and theory reasoning in can be to performance and has driven the search for other frameworks abstract natural domain smt generalized and the model construction calculus are attempts in this direction conclusion abstraction is fundamental to practical reasoning about computationally problems abstract interpretation has traditionally been applied to reason about undecidable problems such as checking semantic properties of programs this paper introduced a framework for applying abstract interpretation to problems that are nphard but decidable such as satisfiability this framework allows for novel of smt algorithms solvers can be viewed as abstract interpretation which combine several different weak abstractions to achieve a result moreover while solvers use incomplete abstractions they produce complete results this is not due to but refinement techniques our framework makes some of these techniques explicit but more importantly provides a general vocabulary for studying a wide range of satisfiability procedures while the focus of this paper has been theoretical our goal is to contribute to the practical state of the art the original abstract interpretation framework provided a simple for constructing static abstract satisfaction plays a similar role and provides a foundation for the development of smt solvers there are three different for future work one is to apply abstract interpretation to the implementation of smt solvers by constructing sound but incomplete solvers and abstract quantification procedures from existing abstract domains the second axis is to lift techniques in smt solvers to improve the precision and efficiency of program analysis the classic and method have each been lifted to a single static analysis problem but more applications and evaluation are required to understand their in a static analysis context preprocessing subsumption and techniques have all been integral to improving the performance of solvers and the connections in this paper indicate that such techniques should lift to program analysis as well the final axis is to investigate new implementations of abstract domains with interfaces rich enough to support smt solving static analysis implication graph construction and domain and theory combinations we look forward to these developments acknowledgments this work was supported by the corporation project project and the fp the research reported in this paper was between and in was supported by a microsoft research references n b and l de lemma learning using joins ­ in m v l a and d an abstract interpretation of in m v l a and d verification of floatingpoint programs with abstract in sas r e d j s a o and b deciding arithmetic with abstraction in tacas pages ­ springer e m clarke o and d e long model checking and abstraction acm toplas ­ sept s natural domain smt a preliminary in formats pages ­ p cousot semantic foundations of program analysis in s muchnick and n jones editors program flow analysis theory and applications chapter pages ­ prenticehall inc p cousot the design of a generic abstract interpreter in m and r editors system design series f press amsterdam p cousot abstract interpretation mit course p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in popl pages ­ acm press p cousot and r cousot systematic design of program analysis frameworks in popl pages ­ acm press p cousot and r cousot abstract interpretation and application to logic programs journal of logic programming p cousot and r cousot abstract interpretation frameworks journal of logic and computation ­ aug p cousot r cousot and l theories solvers and static analysis by abstract interpretation jacm ­ jan b a and h a introduction to lattices and order cambridge university press cambridge uk m and h a computing procedure for quantification theory jacm ­ july l m de and d a satisfiability calculus in pages ­ v l and d satisfiability solvers are static in sas pages ­ springer v l and d abstract conflict driven learning in popl pages ­ new york ny usa acm press v l d and m numeric bounds analysis with learning in tacas pages ­ springer n and a effective preprocessing in sat through variable and clause elimination in sat pages ­ germany springer j w failed literals in the procedure for sat technical report university h g r a and c fast decision procedures in cav pages ­ r f and f making abstract interpretations complete jacm ­ s gulwani and a combining abstract interpreters in pldi pages ­ acm press l a m and d deciding floatingpoint logic with systematic abstraction in pages ­ w r s f and a gupta program analysis via satisfiability modulo path programs in popl pages ­ t a henzinger o and s qadeer from to symbolic model checking ­ m j h m and a efficient simplification based on binary implication graphs in sat pages ­ d j s a and o satisfiability solving of presburger arithmetic in cav pages ­ july d and g an decision procedure for transitive relations with uninterpreted functions in pages ­ w in foundations ­ k r m leino and f using to infer loop invariants inside an smt solver or a theorem prover as abstract domain in workshop on invariant generation pages ­ report k l interpolation and model checking in cav pages ­ k l a and m sagiv generalizing to richer logics in cav pages ­ o and o yet another decision procedure for equality logic in cav pages ­ d and l using bounded model checking to focus fixpoint iterations in sas pages ­ i of quantifier logics an overview an international journal for symbolic logic ­ r a and c solving sat and sat modulo theories from an abstract procedure to jacm ­ a m pitts categorical logic in s abramsky d m and t s e editors of logic in computer science volume algebraic and logical structures chapter pages ­ oxford university press t w reps s sagiv and g symbolic implementation of the best transformer in pages ­ p smith the galois connection of syntax and semantics technical report cambridge university p j there are no problems sat pages ­ a and t reps a generalization of method in sas springer a v and t w reps a method for symbolic computation of abstract operations in cav a and s gulwani logical interpretation static program analysis using theorem proving in pages ­ o procedure for equality logic with uninterpreted functions in volume of workshop proceedings 