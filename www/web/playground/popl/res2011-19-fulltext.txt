the design of a programming language for children on the matthew microsoft microsoft research abstract is a relatively new programming language designed specifically for children to learn through independent exploration to lower the barrier to entry for new programmers by presenting a simplified programming model which nevertheless has significant expressive power is integrated in a realtime d environment and is designed to with modern games in terms of intuitive user interface and graphical production values in this paper we will review key tradeoffs made in the design of the programming language and illustrate how it is one of very few languages designed using user interface design principles and to the extent that the of and objective factors considered in the language design have in presenting a model of programming which is uniquely and for users categories and subject descriptors d programming techniques programming d software engineering design tools and techniques ­ user interfaces software engineering case d software engineering programming environments ­ graphical environments integrated environments interactive environments d programming languages language ­ specialized application languages very highlevel languages concurrent distributed and parallel languages general terms design human factors languages keywords games game programming d user interface k programming programming early goals of was initially inspired by the relatively easy access to programming ­ through a basic interpreter ­ provided in early s personal computers like the ii and the for programmers coming of age in that time there was little to do with a computer permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright © acm but program or play simple games copied from significantly many programmers their first lines of code in order to modify these games to be more to their we that this of play and learning had largely been lost to the of the programming community modern games do not typically come with source code cannot be on the and ­ particularly in the area of games require such advanced engineering that they present an barrier to entry it was our expectation that providing a more easily accessible powerful programming experience to children would benefit the children in their development and eventually increase the overall size and quality of the programming community more children would be drawn to programming as a tool for expressing their own ideas rather than an motivated choice with limited personal with we set out to provide a new first programming experience that the early pc play games fix them up and eventually create your own from we realized very early that the of have a very different context than we ourselves had in the s particularly in regard to user interface and the games themselves which often have art comparable to those of the largest we want a st language for building s games instead we our new language should be able to achieve the same quality of work product that experience in commercial games this indicated to us that we should a higher level of abstraction than basic in order to meet sophisticated of game behavior while keeping the learning curve by the language semantics with a realtime d game engine we to allow to common assumptions ­ such as ­ to focus on what was new about their own game designs environment although our focus for was to create a new programming language our chosen domain ­ d ­ required that we also supply tools necessary for and the game world includes a full d development environment include a editor layout tools character and other mechanisms which allow to create the world data against which their code will operate similarly the runtime includes a full complement of fundamental game technology detection etc although implementing such basic game technology as a engine is a deep and for an advanced programmer our with children showed a clear focus on new forms of which typically assume that already works we decided to provide enough functionality out of the box that the problems the were trying to solve through programming were problems they already found interesting ­ their own game design ideas design once we had chosen our north star ­ to achieve the level of ease of entry and relative expressive power of s basic environments we for modern of highlevel systems with expressive power even if they were not programming environments per se one such was the blocks created by the this allows very small children to create a variety of different by changing the and order of a set of electronic on a the element of this was how the user interface out the possibility of a syntax error as long as the are placed into the spaces a will result there are no illegal combinations possible we this into a key image a robot onto which the user places containing high level concepts such as move see or left which then into coherent behavioral statements this a motivation to protect the user from having to abstract structure or sequencing rules another was the environment created by at computer in the s in there was no distinction between the programming environment and the finished project a user created a new program by modifying an already running ­ ­ program we that in this model a user is with a single level of abstraction ­ a program that can be modified rather than the more and complex concept of a program which creates programs which is presented in modern interactive development environments such as or the foundations product from more recent software history we studied the logical blocks model presented by project and the game programming environment in alice in to contribute something beyond what these modern programming tools had already achieved we that these environments closely modeled the syntax and level of abstraction of programming languages such as java we ourselves if we could use either higherlevel language constructs or more integrate common game engine concepts to allow our users to achieve more complex games in fewer lines of code than these other environments this a key point in the language design as we realized that modeling the semantics of languages was not a goal because it had already been done quite effectively rather we implicitly gave ourselves permission to a completely new language if we could ourselves that that language would more express the ideas of a trying to design a new game a full of our is possible some of the others included smalltalk lisp and in particular the objectoriented interactive environments such as the model of programming by the and dataflow programming environments such as and our use of the domain was implicit in our goal of speaking to existing ­ making and games the modern world is realtime and d which led us to examine literature which deals extensively with controlling behavior in a realtime d environment one particularly example of this was which how surprisingly behavior can be achieve by simple combinations of and light in different combinations in our first design exploration we to the popular early game using a library of and blocks within a tool we quickly discovered that even simple behaviors would quickly become very large complex diagrams and were too lowlevel to achieve the expressive power we were after after a round of early paper work we discarded this approach and back to the paradigm one of the original team members had recently completed a research prototype for a new graphical user interface for commands to a computer this prototype of a virtual of representing os concepts such as and document a user would construct a hand ­ like a hand ­ of these in a d environment and then play the hand and the system would infer a command for example selecting a labeled and a for a document would cause the document to be the positive results from this internal microsoft prototype motivated us to find a way to incorporate this hand of paradigm in our language design and user interface as we to explore scenarios and design goals using paper we found increasing in the literature of at mit just as subsumption architecture reduced processing requirements for realworld we realized these concepts could also be used to achieve greater expressive power for game designers based on these and more popular descriptions of behavior programming michael designed a basic model for the language which is still in use a detects objects in the world used in include physical such as see and touch and also slightly more abstract such as which detects the of time and which detects changes to game create sets of objects which are available for further processing a filter reduces the set of objects detected by a a produces a set and the filter reduces that set can be done on object types tree on object attributes such as color or on characteristics such as distance far or many few a selector operates on the set by the filter to select a single object for operation in actual use the selector is most commonly used other selectors include and random an causes the executing robot the subject to take some action towards itself or the object provided by the selector the object finally a further the information derived from the subject object or global state a set of these primitives combine to form a rule within that rule the filters and selectors form a clause while the and one or more form and clause at runtime any clause which detects at least one matching object in the environment causes the rules clause to take effect or the core set of filters etc is based on primitive functionality oriented towards game design such as see and filters that can reference object type like tree or color and like move with filters such as towards or away see ­ ­ move ­ towards is a common world equivalent in note that this approach does not a particular order for the primitives in a rule at this point in the design we chose an order that provided the most direct mapping to first user interface in designing we gave equal weight to the design of the language itself and of the user interface used to create and edit programs our design process incorporated user interface design principles such as elements after the user has made use of preceding elements and such as testing using both paper and interactive the first version of the user interface had the simple goal of allowing end users to create rules by combining the language primitives listed in the previous section for this we chose a straightforward implementation of a grid where each row corresponds to a single rule and each column to a primitive type in the order ­ filter ­ selector ­ ­ in figure we see a single rule consisting of nodes on a bar each node can be using an controller to open a allowing the user to select a primitive to be placed at that node in this image the user has on the node and is a circular of including see and touch as well as the remember and figure a screen from the first public of ­ then known as ­ at microsoft tech in march of tests for the first user interface a few problems the first from our approach of having empty cells for each primitive type note that a user can add several filters to a rule see ­ red ­ ­ filter filter selector since we know how many filters a user would need for a given rule we simply left filter spaces this was usually enough however users new to the system to see it as a minimum requirement and to add filters to every rule this often led to rules that were specific see ­ red ­ ­ big and could not select matching objects in the environment we needed a way to guide the user to create rules with the minimum effective number of primitives such as filters while allowing more advanced users to express more specific rules when necessary rule and in our previous example we considered the user interface for a single rule rules can be together to form a page in the user interface this is depicted as a vertical stack of rules in order from top to bottom with the rule having the number these numbers indicate the priority of the rules with the priority rule appearing at the top of the screen for many simple programs has no effect rules are executed concurrently with all tested against the same world state however more subtle or complex behaviors are possible by programming conflicting rules and allowing to mask the results of some rules for example one might create the program see ­ ­ move ­ away see ­ ­ move towards in this example the robot will move towards any and away from anything in the case of a the rule to move away from objects will take priority a common use for this effect is to have a robot that unless it an in which case it will give this ability to have multiple simple programs by each others outputs can be seen as a simplified version of subsumption architecture with the difference that in is based on a simple linear priority ordering rather than a hierarchical of behaviors program editor the next major of the program to two key issues the first was the of users to fill in every slot and create specific rules as we mentioned earlier the second issue was a problem of in realworld design challenges users to use the same selector almost exclusively the selector which simply the object detected in the clause ex see ­ ­ move towards vs see ­ ­ ­ move ­ towards this new design also recognized a natural hierarchy in the primitives filters have a mapping to the filters red blue etc apply to the see and have a similar relationship to the toward and away can similarly be seen as children of the move given this hierarchy the team designed a new presentation which presented only two a and an this presentation of an empty rule is shown below figure revised rule editor focuses on the key and primitives in this simplified presentation a more intuitive interpretation of the syntax the and are equivalent to a and a response or to the classic clause in most procedural languages based on of our test we on labels for each of these clauses of when for the filter clause and do for the clause these labels can be seen in figure in this new presentation we also emphasize the hierarchical relationship between and filters and between and in figure below we see a filter clause see ­ red ­ with two filters and an clause with a single move ­ toward figure a fully rule in the new rule editor notice the clear of and clauses less visible in this is that the tile is larger than the filters and the tile is larger than the tiles another significant change with this is that the selectors are no longer presented to the user since users almost universally chose the selector we made this the default while the underlying architecture still allows for different types of selectors the user interface no longer this capability as of this writing we are considering the selector concept in the user interface as part of a deeper design investigation around set semantics iteration and concurrency details of which are beyond the scope of this paper consideration of state and variables at this point in the evolution of the language it was become clear that we needed a model for management of state we considered adding classical variable types such as string and integers but to do it in a way which maintained the of the programming user interface two insights this part of the design the first was the general value in work that reaction that state should be read from the environment and models were to be avoided the second on personal correspondence with earlier of prototype languages at microsoft who had found that children in abstractions like variables and more interested in realworld concepts like and moving in the end we decided to avoid typical presentation of variables in of on world state although this was already a useful paradigm in has two advantages over the field that made it even more useful the first is that we could new capable of writing state into the simulation environment additionally our being virtual are perfect and can be counted on to read state back from the environment and without error a classic example of style state is object color characters can to each others color and also use the color to change their own or each others color seen programs where characters signal their program state to each other by changing their own color providing a lightweight synchronization mechanism that has the side effect of being visible to the user and therefore easier to understand and in the initial release of we also include a representation that has proven useful and as all our language constructs has an intuitive the score has primitives for setting and testing although we present this in the for the obvious reason ­ keeping track of winning ­ we were to see our users use exactly as generalpurpose integer variables keeping track of iterations resource counts and even between characters state machines and structured programming another classic do we or dont we moment as sample programs started to use more complex realworld game designs while and can achieve surprisingly subtle behavior pages of rules can become with more than or so lines and our users a way to different modes of behavior clearly this was an to introduce subroutines and structured programming at the same time directly to those concepts would put on our design goals of intuitive user interface and minimal abstraction given the rules was currently composed of the notion of in parameter passing and return address stacks to take our user experience off the deep end and well beyond what a year old might explore on their own in the end we with a minimal block structure with a realworld ie the page each program automatically presents one page of initially empty rules most new programmers will several without that a robot can have more than one page as they explore the set of more they discover or are shown a switch page that allows a robot to change from one page of rules to a completely different page of rules no state is passed again we rely on the environment to hold our model the for this a page with an arrow is elsewhere on the screen in a ui that shows the user how to move between pages in the editor in the real world was first released on the in june of and then for the pc as a free in january of it is currently in use in around the world and has been translated to several languages by users environments range from single players on the at around by to a k system in what we to provide a programming language so embedded in a modern experience that children would their time learning to program their own games based on the seen on the and positive in press we believe we have achieved that one result that us was that users in several school environments seem to be divided between and as our first was in an program our early user feedback may have us to an experience that regardless of this is an effect we are just beginning to investigate and would like to build on opportunities although the team to build a server for resource limitations us from it to end users we feel that this limited the ability of to be motivated by each others work ultimately holding back the growth of the user base feedback from some academic has indicated a for a from to programming languages while we remain focused on the possible programming experience rather than pure preparation we recognize the of an integrated from to say c or javascript next steps as of this writing we have a major scheduled to in fall of in early we plan to begin work on a global sharing server which will allow children to share their with and in other and we are also in university to help us extend with specialized scenarios and more advanced language constructs we have shared the source code with several university efforts notably in support of logic extension for in development at uc it is our hope that the community of will help it to reach its full potential as an new language for children references microsoft web site online november k t language and grammar specification wa usa microsoft research let the players play other remarks about paul and sl international society of the learning sciences proceedings of the th international conference of the learning sciences volume computer inc script language guide the language reading ma addisonwesley matthew et al alice learned from building a d system for proceedings of the conference on human factors in computing systems the the sn a smalltalk the language and its implementation boston ma usa addisonwesley co inc isbn a the reference manual ca usa co inc isbn a declarative approach to in programming languages mm and al et wa usa sn proceedings ieee workshop on languages pp new approaches to ra sl science vol a intelligence without reason cambridge ma usa mit a intelligence without representation f computation intelligence park ca usa association for artificial intelligence the impact of web in the department of and early development state of design for games sl acm proceedings for the th international conference on foundations of digital games the early history of smalltalk alan c sl acm the second acm sigplan conference on history of programming languages dont play a and systems vol 