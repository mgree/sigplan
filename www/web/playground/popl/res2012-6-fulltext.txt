the of bisimulations and kripke logical relations dreyer vafeiadis max institute for software systems abstract there has been great progress in recent years on developing effective techniques for reasoning about program equivalence in mllike is languages that combine features like higherorder functions recursive types abstract types and general mutable references two of the most types of techniques to have are bisimulations and kripke logical relations while both approaches are powerful their complementary advantages have led us and other researchers to whether there is an essential tradeoff between them furthermore both approaches seem to from fundamental limitations if one is interested in scaling them to reasoning in this paper we propose relation transition systems which together some of the most aspects of and bisimulations in particular show how bisimulations support for reasoning about recursive features via coinduction can be synthesized with support for reasoning about local state via state transition systems moreover we have designed to avoid the limitations of and bisimulations that their generalization to reasoning notably unlike are composable categories and subject descriptors d programming languages formal definitions and theory d programming languages language constructs and features f logics and meanings of programs specifying and verifying and reasoning about programs general terms languages theory verification keywords kripke logical relations bisimulations relation transition systems contextual equivalence higherorder state recursive types abstract types transitivity global vs local knowledge introduction one of the challenges in programming language semantics is to find scalable techniques for reasoning about the observational equivalence of programs even when the intuitive principles of local reasoning suggest that a change to some program module should not be observable to any client it can be difficult to establish that formally denotational semantics offers a tractable way of proving equivalence of programs by showing that they mean the same thing in some adequate model of their language however traditional denotational methods do not scale well to general permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm purpose languages like ml that combine support for functional programming eg higherorder functions polymorphism abstract data types recursive types with support for imperative programming eg mutable state and control effects among other things fortunately in recent years there has been a of interest in the problem of developing effective methods for reasoning about program equivalence in mllike languages a variety of promising techniques have and while some of these methods are denotational most support direct reasoning about the operational semantics of programs in particular there has been a between techniques based on kripke logical relations and bisimulations this paper is motivated by two highlevel concerns and bisimulations offer complementary advantages which we would like to synthesize in a single proof method there is a specific sense in which both and bisimulations appear to be limited and some fresh idea seems necessary to this limitation concerning motivation the techniques use state transition systems to provide more flexible principles for reasoning about local state than bisimulations do however in order to account for the presence of recursive features such as recursive types and higherorder state require tedious manipulation of stepindexed constructions in contrast bisimulation techniques use coinduction to model such recursive features very but their support for reasoning about local state is weaker than see section these complementary have led us and other researchers to whether there is some fundamental tradeoff between and bisimulations concerning motivation we are interested in scaling equational reasoning techniques to the setting of reasoning ie reasoning about equivalences between programs in different languages reasoning is essential to the development of compositional certified compilers and may also have applications to the verification of programs unfortunately both and bisimulation methods rely on technical devices that prevent them it seems from scaling to the setting specifically in order to deal with higherorder functions bisimulation methods employ various syntactic devices that restrict the applicability of the methods to reasoning see section for details in contrast have been shown to generalize to reasoning but there remains a key problem proofs are in general not composable at least in part due to the use of stepindexed constructions as mentioned above in order to prove compositional correctness of compilers for mllike this has led to a series of written by authors of the present how to hide the of languages it is crucial to be able to prove the correctness of each phase and then compose them so lack of transitivity is a for that application contributions in this paper we present a new technique for reasoning about program equivalence called relation transition systems together some of the most features of and bisimulations while their limitations in particular show how the use of state transition systems from can be synthesized with the coinductive style of reasoning from bisimulations thereby enabling clean and elegant proofs about local state and recursive features simultaneously thus concerning the open question of whether there is a fundamental tradeoff between and bisimulations we provide a answer no there is not we explore here in the setting of fa cbv calculus with general recursive types products sums and general references as this provides a clear point of comparison with recent work on both and bisimulations with one exception see section we believe are capable of reasoning effectively about all the challenging f equivalences studied in the papers and we demonstrate effectiveness on several such equivalences although we do not study reasoning in this paper we have designed so as to avoid the use of any technical devices that would a future generalization to the setting to achieve this goal we had to come up with a novel way of for higherorder functions in the context of a coinductive proof method without relying on the syntactic devices that previous bisimulation methods use our new technique we call global vs local knowledge is one of the major contributions of this paper relying on this new technique we have proven that equivalence proofs are composable which suggests they may serve as a foundation to for reasoning the remainder of this paper is structured as follows in section we define f the language under consideration in section we our key novel technical idea of global vs local knowledge we then present the formal development of for reasons we begin in section with the presentation of a relational model for a pure subset of f with recursive types and then proceed in sections and to extend that model to handle the full language f in section we demonstrate the expressive power of our method by proving several challenging equivalences from the literature in section we briefly sketch our proof of transitivity for the model the transitivity proof for full f is complex and sophisticated a detailed discussion that is beyond the scope of the present paper we will present it in a paper finally in sections and we discuss related and future work and conclude our online appendix provides detailed proofs of the metatheory of both on paper and in coq the language f in figure we present the syntax and the operational semantics of f a completely standard language extended with products sums general recursive types and general reference types formally we distinguish between static programs p which are explicitly typed and do not include memory locations since the programmer cannot write them and dynamic expressions or terms e which include memory locations and in which all type information is erased the static semantics of f see the online appendix defines the program typing judgment p · and · x while base unit int bool typ base × ref p prog x n tt ff if p then p else p p p p p inj p inj p case p of inj x p inj x p roll p p fix f x p p p p p pack p as p as x in p ref p p p p p p v val x n tt ff v v inj v inj v roll v fix f x e e pack v e exp v if e then e else e e e e e inj e inj e case e of inj x e inj x e roll e e e e e pack e e as x in e ref e e e e e e k cont · if k then e else e k e v k k k inj k inj k case k x ei roll k k k e v k k pack k k as x in e ref k k k e v k k e v k h heap loc fin loc h if tt then e else e h e h if ff then e else e h e h v v i h vi h case v x ei h ej vx h fix f x e v h f x ef vx h e h e h pack v as x in e h h roll v h v h ref v h v where domh h v h v v h v v h v h h tt h h ff where h ke h ke where h e h e figure the syntax and semantics of f the dynamic semantics says how to execute expressions e there is a straightforward erasure of programs p into expressions written p and when discussing equivalence informally we will often over the distinction using evaluation contexts continuations k we define the smallstep reduction relation between configurations consisting of a heap and an expression the reduction rules shown in figure are deterministic except for the rule for allocating reference cells which is completely nondeterministic for technical reasons we find it convenient to assume that allocation is in fact deterministic but we do not care which deterministic allocator is used thus we will assume that is some unknown of the rules shown in the figure and our model will be parametric wrt that it is easy to show that if two f programs are contextually equivalent under all deterministic then they are contextually equivalent under a nondeterministic allocator so nothing is lost by this assumption in the following we write for the reflexive transitive closure of we also say that a configuration diverges denoted h e if it can perform an infinite sequence of reductions two programs are contextually equivalent if under any welltyped closing context c as defined in the appendix they either both terminate or both diverge definition contextual equivalence let p and p then p ctx p def c h c · · h cp h cp global vs local knowledge our new method of relation transition systems is essentially coinductive following the style of existing bisimulation techniques in many respects as explained in the introduction coinductive reasoning makes it easy to deal with recursive features such as recursive types and higherorder state without requiring the use of stepindexed constructions the two main ways in which differ from existing bisimulation techniques are in their treatment of local state from recent work on we the idea of using state transition systems to establish invariants on how a modules local state may over time enable one to encode more flexible state invariants than are expressible using bisimulations higherorder functions in order to reason about higherorder functions in a coinductive style but without ourselves to reasoning we employ a novel technical idea global vs local knowledge the treatment of local state using state transition systems follows prior work very closely so we further discussion of that idea until section and focus attention here instead on motivating our new idea of global vs local knowledge coinductive reasoning one way of contextual equivalence is as the largest adequate congruence relation being adequate means that if two terms of base type are related then either they both diverge run forever or they both evaluate to the same value eg if one term evaluates to then the other must evaluate to as well being a congruence means the relation is closed under all the constructs of the language eg if f and f are related at and e and e are related at then f e and f e are related at to prove using coinduction that two terms e and e are contextually equivalent at type one must exhibit a term relation l that contains e e and then prove that l is an adequate congruence the relation l serves as a generalized coinduction hypothesis by which one proves equivalence for all pairs of terms related by l simultaneously however while it is possible for one to employ this kind of coinductive proof it is typically not very because proving a relation to be a congruence directly can be tedious bisimulation techniques help make coinductive proofs by the congruence proof burden typically this is achieved by only requiring one to show that l is closed under typedirected uses ie evaluation or of the terms it relates this results in proof obligations that look like the following if e e l then either e and e or v v e v and e v and v v l if int v v l then n v v n if × v v l then v v v v vi vi vi and v v l and v v l if v v l then v v vi roll vi and v v l the most problematic proof obligation is the one for function values it usually looks something like this simplifying fix to if v v l then x e e vi and v v v v g l in other words if l relates function values v and v then applying them to any equivalent arguments v and v should produce results that are also related by l the big question is what is this relation g from which the arguments v and v are drawn global vs local knowledge first some nonstandard terminology there are many equivalent terms in the world but when we do a bisimulation proof we only make a claim about some of them so let us make a distinction between local and global knowledge about term equivalence the relation l describes our local knowledge these are the terms whose equivalence we aim to validate in our proof the relation g on the other hand the global knowledge about all terms that are equivalent in the world in proof obligation we draw equivalent function arguments from g rather than l since they might indeed from else in the program some unknown client code and thus our local knowledge l may not be sufficient to justify their equivalence this leaves us with the question of how to define g global knowledge coming up with a sound and practically usable choice for g is far from obvious and existing bisimulation methods make a variety of different choices for example · applicative bisimulations define g to be the syntactic identity relation on closed values this is a nice simple choice which works well for pure calculus unfortunately for higherorder stateful languages like f it is unsound so more advanced approaches are needed · bisimulations take g to be the context closure of l ie the relation that extends the syntactic identity relation on closed values by including closures of open values v with pairs of values w w that are related by l formally w w l · normal form or open bisimulations the whole question by choosing a fresh variable name x and representing equivalent arguments by the same x as a result these bisimulations are built over open terms and proof obligation above must be updated to account for the possibility that the evaluations of e and e get stuck trying to the same free variable x more about that below all of these methods define global knowledge in a very syntactic way that is well suited to proving contextual equivalences however as explained in the introduction we wish to develop a method that will be capable of generalizing to the setting of reasoning where g may relate different languages we therefore an account of global knowledge that is more semantic over global knowledge the essential difficulty in choosing g has to do with higherorder functions if the argument type is or contains a function type then equivalence at is very hard to characterize directly our solution is simple we dont try to define the global knowledge at all instead we take g to be a parameter of our model our key observation is that it is not necessary to down exactly what g is so long as we make our coinductive proof for l as parametric as possible with respect to it we will what as parametric as possible means in section this parametricity makes our proofs quite robust by allowing g to be instantiated in a variety of different ways in particular we make no assumptions about the values that g relates at function type for all we know g might even include garbage like int int tt our approach can be viewed as a more semantic account of the idea behind normal form bisimulations see above which is we are over a lot of details here to be precise bisimulations are actually sets of ls for more details see section conversely if were eg in a firstorder language it would be easy to characterize equivalence at directly the ability to instantiate g with a relation is surprisingly useful we will make critical use of it in our transitivity proof in section to model equivalent arguments as black boxes about which nothing is known consequently just as for normal form bisimulations we need to adapt proof obligation above to account for the possibility that e and e get stuck for normal form bisimulations e and e may get stuck if they try to a free variable x and so normal form bisimulations proof obligation to allow e and e to reduce to terms of the form kx v and kx v where k and k are equivalent continuations and v and v are equivalent values in our case e and e may get stuck if they try to apply some functions that are equivalent according to the global knowledge but that turn out like and tt to not even be functions hence we will allow e and e to reduce to terms of the form v and v where k and k are equivalent continuations and where f f v v g in this way the parameter g serves as a semantic analogue of free variables in normal form bisimulations intuitively although the idea of over the global knowledge may seem surprising at first we find it to be of method for modeling system f in method a potential cycle in the definition of the logical relation for impredicative universal types is avoided by over an arbitrary relational interpretation of the abstract type in our scenario the problem of how to define the global knowledge is avoided by over an arbitrary relational interpretation of function types in essence we are treating a function type as an kind of abstract type the coinductive proofs about different modules in a program all treat the global interpretation of abstractly while simultaneously they each contribute to defining it over the global knowledge turns out to be very useful first and it makes it easy to soundly compose our coinductive proofs for different modules together and hence prove soundness of our method wrt contextual equivalence second it enables us to reason about open terms section and higherorder state invariants section replacing the use of context closure or free variables for those purposes in and normal form bisimulations respectively finally it is the key to establishing transitivity for our proof method section a relational model for to ease the presentation of relation transition systems we begin in this section by using the idea of global vs local knowledge motivated in the previous section to define a relational model for a of f containing base function product sum and recursive types but not universal existential or reference types this model cannot properly be called an model since it does not include any transition systems the transition systems will come into play when dealing with state in sections and however by ignoring the aspect of for the time being we can focus attention on other aspects of the model figure lists the various semantic domains we will be using here type denotes the types of and denotes closed types ie types with no free type variables the next four are standard relations on closed values closed expressions closed continuations and heaps indexed by the relevant types in case of input and output types next we define what we call the flexible types along with the flexible relations which are just relations on closed values indexed by such flexible types whereas bisimulation methods typically allow terms of arbitrary type to be included in the bisimulation we find it useful to restrict local and global to relate only values of flexible types intuitively these are the types at which value equivalence may depend on knowledge in f there will be several kinds of flexible types but in the only flexible types are function types type base × × × × × × heap × figure semantic domains for r r if r × v v v v v v r v v r r inj v inj v v v r inj v inj v v v r r roll v roll v v v r figure value closure for if r then r e if e e undef otherwise f v v defined r r r r lk l l is monotone wrt g f f lg f f g g lg figure definition of local and global knowledge for in contrast value equivalence at the remaining product sum and recursive types which we call fixed and upon by all modules once the meaning of the flexible types is defined this is achieved by a closure operation that takes a relation r and returns its closure r it is defined as the least fixedpoint of the set of equations in figure note that r only occurs so r is inductively well defined even though the type gets on the rhs in the case of local and global knowledge in a local knowledge l lk is essentially a flexible relation except that as shown in figure this relation is actually parameterized by the global knowledge g in effect lg describes the values that we wish to prove are equivalent assuming that g correctly represents the global knowledge this is necessary in order to reason about open terms and we will see its utility below in the proof of compatibility for fix we require that l is monotone wrt g intuitively passing in a larger global knowledge should never result in fewer terms being related by l we also require that the values related by the local knowledge at function type are indeed functions in the sense that their application to an arbitrary value should not be a stuck configuration but should reduce at least for one step this is a technical requirement that is used in our transitivity proof in section we want to restrict attention to global that are closed wrt the local knowledge in question for a particular l we define to be the set of flexible relations g st g lg this requirement makes sense since the global knowledge must by definition be a superset of any local knowledge observe however that we do not restrict what other values g relates indeed g may relate values at function type that are not actually functions or that are obviously eg and tt cf section relating expressions and continuations figure shows how equivalence is defined for expressions e and continuations k eg e e e e v v e v e v v v g k k e e e ke e ke e e sg g k k k k v v g kv kv eg rv f v f v f f rf v v rv g e e g eg e l e g dom x x x g e e eg e e l e l e figure mutually coinductive definitions of closed expression equivalence e and continuation equivalence k and definitions of consistency and program equivalence for specifically we introduce two new relations e and k which are defined given a type a local knowledge l lk and a global knowledge g we say that two expressions are locally equivalent written e e eg if they either both diverge or both terminate producing related values along the way however they may make calls to external functions that is functions that are related by g but not necessarily by the local knowledge lg more precisely we say two closed expressions are equivalent if and only if one of the following three cases holds both expressions diverge run forever both expressions run successfully to completion producing related values both expressions reduce after some number of steps to some expressions of the form vi where both the fi and vi are related by the global knowledge g at the appropriate types and the continuations k and k are equivalent we say that two continuations are equivalent if instantiating them with equivalent values according to the global knowledge g yields equivalent expressions as e and k are defined mutually dependent over a complete lattice and all operations involved are monotone we can take the meaning of these definitions to be either the least or the greatest fixedpoint we choose the greatest fixedpoint corresponding to coinduction because this can in principle relate more terms and is somewhat easier to work with consistency and program equivalence we say that a local knowledge l is consistent in figure if and only if any two functions that it declares equivalent do in fact to equivalent expressions when applied to equivalent arguments in the formal definition we over an arbitrary global knowledge g the functions being tested for equivalence are drawn from the local knowledge lg while the arguments to which they are applied are drawn from the global knowledge g we say that two expressions are equivalent at type in the context written e e if and only if there exists a consistent local knowledge l that shows that e and e are equivalent at type for arbitrary value substitutions and that are related at by an arbitrary global knowledge g extending l two programs are equivalent simply if their versions are equivalent expressions p p properties of program equivalence and soundness we move on to some properties of our constructions in particular were we to extend the language with other forms of recursion such as while loops or primitive recursion the coinductive interpretation would be essential for proving congruence of expression equivalence f x e e fix f x e fix f x e fix e e e e e e e e app p p p refl e e e e e e c ce ce x e e v v subst e e e e e e e e expand x e e v v x e v beta figure some basic properties of our equational model the following lemma states that consistency of local is preserved under pointwise union this is important for ensuring that equivalence proofs for different subterms which rely on different local can be soundly composed lemma if and then l figure shows some of the basic properties of our program equivalence relation first we have a set of rules stating that equivalence is compatible with all the language constructs these rules state that if two terms start with the same term constructor and their immediate subterms are equivalent then so are the composite terms for brevity we just present the rules for recursive function definition fix and function application app whose proofs are the most interesting we briefly sketch the proof of the fix rule from the premise there exists l such that f x e l e define l g fix f x e fix f x e i dom y y y g note here how the of l over g provides it with a source from which to draw the closing substitutions and the goal now is to prove fix f x e fix f x e showing that l and thus l l relates any appropriately closed instances of these two values is simply a matter of unfolding def it therefore remains to establish l by lemma this down to showing e e eg for any g l where · i dom · y y y g · v v g · i i f f x ei finally as fix f x e fix f x e l g g we can instantiate f x e l e with i and are done the proof of rule app relies on lemma as well in order to show that the consistent local for its two premises combine to form a consistent local knowledge for the conclusion in addition the proof relies on the following lemma about equivalent expressions or continuations into equivalent continuations proved by mutual coinduction and case analysis lemma if k k then e e eg ke ke eg k k kk kk to prove app we apply the first case of this lemma with ei i ei and ki · which leaves us to prove k and k to be equivalent according to k unfolding the definition of k we have to show that for arbitrary equivalent values v and v v e v e is in e for which we apply lemma again with ei i ei and ki vi · then we are left to prove v · and v · equivalent ie that v v v v is in e for arbitrary equivalent values v and v which follows from the third disjunct of the e definition as a consequence of these compatibility rules by a straightforward induction on the typing derivation we can show that equivalence is reflexive on welltyped programs rule refl this corresponds to the fundamental property of logical relations equivalence is also symmetric this follows trivially from the symmetric nature of our definition likewise by induction on the typing derivation of contexts we can show that our equivalence is a congruence if two equivalent terms are placed in the same contexts the resulting compositions are equivalent next we have a property for values an expansion law for pure execution steps and finally a direct corollary of these two namely equivalence on value arguments we move to a key lemma about e given a consistent local knowledge l if the global knowledge extends l with some additional external knowledge r then the third case in the definition of e can be restricted so that it applies only to external function calls ie calls to functions related by r not by l lemma external call for any any g and r we have g lg r eg where the definition of er is the same as e except that in the third disjunct sg g is replaced by sr g the follows directly from the observation that r g to prove the other direction we essentially have to eliminate all uses of the third disjunct of e where the functions being invoked are related by g r since all such functions are by definition in lg and since we know we can in fact always inline the equivalence proofs for all such function calls a corollary of lemma for g and r is adequacy which says that equivalent closed terms either both diverge or both terminate returning proper values in particular they never get stuck during evaluation lemma adequacy if e e then e e v v e v e v finally combining adequacy and congruence we show our main soundness theorem for welltyped programs our equivalence relation is included in contextual equivalence theorem soundness let p and p if p p then p ctx p example consider the following example concerning streams as functions taken from and pierce unit int × ones unit int × fix f x roll f unit int × fix f x roll f succ fix f s let n s s roll x n f s in the goal is to show roll succ roll ones constructing a suitable local knowledge note that we have succ roll ones roll for x succ roll ones we define a local knowledge l that relates exactly and lg unit int × proving its consistency for g we must show roll succ roll ones × using the second case in e and the definition of g this reduces to showing and roll roll g the former is trivial the latter is equivalent to int × which holds by construction because g extends lg showing the programs related by it it remains to show g roll succ roll ones eg again using the second case in e we end up having to show roll roll g which we have already done above local state transition systems a review in the next section we will extend our model to account for abstract types and state the key extension there will be to incorporate support for state transition systems in the style of dreyer et als recent work on we use this section to review the basic idea behind that work by means of a concrete example perhaps the simplest example that demonstrates the utility of for reasoning about local state is the state change example due originally to which is itself a variant of pitts and example unit unit int v f f f e let x ref in f x f x f x here and in later examples we write x e for fix f x e when f is not free in e the goal is to show that v and e are contextually equivalent at the type to see intuitively why they are equivalent observe that e allocates a fresh local location x which initially points to and then returns a function it v when v and v are applied at any point in the future to some callback function f they both call f twice before the first and second calls v will set x to and respectively thus even if the second call to f internally applies v again the last thing x will get set to before it is is always note that this reasoning as that control flow in the language is the sense that the call to f cannot escape its current also that the language lacks exceptions both are true for f in order to prove this example we need to be able to establish an invariant concerning the local state of v however we really need more than just a simple fixed invariant because the only such invariant that holds here is the one stating that x points to either or and that is not strong enough this is where come in dreyer et al prove this example using the following sts x l public a dx private the states of this sts represent the possible abstract states in which the functions we are proving equivalent may find themselves and associated with each abstract state is a physical relation on heaps in the left state the heap of the second program must contain x and in the right state it must contain x no restrictions are placed on the heap of the first program since v does not manipulate any local state the relation between these abstract states is by two transition relations on the state space a private and a public one the intuition is that the private or full transition relation includes all legal state transitions while the smaller public transition relation the legal transitions that function calls can make when their behavior is viewed for proving equivalence of v and v we require transitions of some kind from each of these states to the other because repeated applications of v will indeed result in x back and between and however the transition from x to x may be considered private not public because when the behavior of v is viewed it will never start with x and end with x moreover restricting the public transition relation in this way is essential to making the proof go through since the second call to f starts with x and is required by definition to make a public transition we know that when it returns x must still point to and thus x will evaluate to what we have described here is the highlevel idea of the equivalence proof of v and e which is essentially the same when using our as it is when using one differ ence is that with the proof is driven by the need to show that v thus also v in the logical relation at the type with there is no logical relation defining what it means for functions to be related at type instead in typical coinductive style we need to enter v and v into the local knowledge of our which in turn generates a proof obligation to show that these function values do in fact behave equivalently when passed arguments that are related by the global knowledge this ends up being only a minor change to the structure of the proof we will see the formal proof of this example in section relation transition systems for f in this section we present our relation transition system model for f this model generalizes the model from section in a very simple way whereas previously type ref n ref n figure semantic domains for f r r if r pack v pack v v v r figure value closure for f if r then r s n l h set × ps × s × ps × s × × sp s × sp s are is a subset of l monotone in st arg wrt p in nd wrt in rd wrt h monotone in rd arg wrt sp s g n n f f f f v v v v where f v v defined v defined beta e e if h h e h e undef otherwise world w w s s g figure definition of worlds relation transition systems and auxiliary definitions we proved two terms equivalent by a consistent local knowledge l we now do so by a consistent world w worlds worlds are state transition systems equipped with public and private transitions just as described in section that control how the local knowledge of a module and the properties of its local state may over time formally figure a world consists of the transition systems possibly infinite state space s the private or full transition relation and a smaller public transition relation both a set of type names that are used to represent abstract types n a mapping from states to local l and a mapping from states to heap relations h for now ignore the distinction between different kinds of worlds as well as the sp sp and p objects in that figure as before the local knowledge at each state is parameterized must be monotone global knowledge g the same applies to the heap relation which describes pairs of that are owned by the the parameter g here provides a way of referring to the global equivalence on values when establishing invariants on the contents of local heaps this is especially critical in dealing with higherorder state while the local knowledge mapping must be monotone in its state index wrt the heap relation mapping need not be indeed since a modules local state is hidden from the environment there is no reason to require that heaps related in one state will continue to be related in future states eg in the example in section x or x but not both we have seen in the previous section section how a local knowledge and its closure relate values at types this carries over to the full setting but how do we deal with the additional types of f ie with universal existential and reference types s × loc × loc n g h h domh domh h h g figure provides the meaning of reference types treatment of universal and existential types universal types like function types are considered flexible that is the local knowledge can relate any values at any closed type as long as when instantiated those values can run for at least one step existential types like product types are considered and thus their interpretation is given by the value closure figure note that the witness of related packages must be the same type how then do we support reasoning about parametricity the key is that the witness type may be an abstract type name we extend the syntax of types in our model with type names n figure and the local knowledge of a world can pick a subset of these names and interpret them however it wants to avoid conflicts with other worlds the choice of names must be recorded in the n component of the world no other names may be interpreted treatment of reference types reference types are considered flexible but they really are a special case intuitively the collection of all reference types can be seen as a separate module that is used by all other modules consequently we construct a designated world explained below that ref and bar ordinary worlds from relating anything at such types we therefore distinguish between two kinds of worlds local worlds and full worlds for both are defined in terms of the same underlying structure of dependent worlds a dependent world is a world as described above except that it is parameterized by a preorder p sp p that its local knowledge and heap relation may depend on via the sp sp argument of l and h in figure intuitively p is the state transition system of some other world and sp is that worlds current state thus a full world w world is simply a world depending on nothing a singleton set in contrast a local world w is a world that depends later be linked and does not itself relate any values at reference types as a matter of notational convenience if w world and s ws then we will often just write for and similarly for the h component we use the dot notation to project components out of a world the world for reference types figure defines world the world that provides the meaning of reference types its states are finite relations between a type and two locations that are functional in the location arguments they associate each allocated location on the left with the corresponding one on the right and the type of values stored the relations are finite because only a finite number of locations can ever be allocated and as by the language they can only grow over time its local knowledge relates precisely the locations related by the current state at the corresponding reference types the heap relation relates heaps that contain exactly the locations related by the current state and that store globally related values at those locations note the critical use of the global knowledge parameter g in defining h hh h h h h h h h h h h ws s × ws w p p p p p p w p p p p p p wn wn sg g sg sg g sg w ws ws × ws w w p p p p p p w w p p p p p p w wn wn wn w s sg sg sg w s sg sg sg figure lifting world and separating conjunction × of worlds lifting and separating conjunction of local worlds now if we have a local world w then we can link it with thereby lifting it to a full world w world this operation is defined in figure the full worlds transition system is the synchronous product of s and ws its local knowledge relates values iff they are related by either components local knowledge and its heap relation relates heaps iff they can be split into disjoint parts that are related by h and wh respectively note how the state of the reference world is passed to wl and wh along with the state of w itself similarly given two local worlds w w that own disjoint sets of abstract types ie wn wn we can construct their separating conjunction w w the definition is given in figure note how the same shared state is passed to the l and h components of both w and w separating conjunction of worlds is a generalization of the union operation on local which we have seen in section to be critical for composing proofs cf lemma program equivalence with these constructions in hand we can now describe the definition of program equivalence in figure we say that two expressions are equivalent iff there exists a local world w that does not depend on a particular choice of names to represent its abstract types is stable and when lifted relates the expressions stability means that the local worlds heap relation in some sense changes whenever the shared world is advanced to a future state then w should be able to to that change by moving to a public future state s such that any local heaps that were related previously by wh are still related at s this is a very technical condition that is required for soundness but is satisfied trivially in the common case that wh does not actually depend on its parameter see the end of this section for further discussion a world w such as w relates two expressions w iff a it is b it is consistent and c the expressions when closed using related substitutions are related by the expression re see below says there exists a state at which wh relates the empty heaps consistency is essentially the same as for but extended straightforwardly to universal types in all these definitions the global knowledge g is drawn from as before this enforces that g must contain the local knowledge at reference types and at abstract type names owned by w however also enforces that g must not extend the local knowledge intuitively this is because w should completely control the meaning of those types furthermore since g is it must like the local knowledge of w be monotone wrt r r r r r ref n n r n rn g ws g is monotone wrt s gs ew gs s e e h h hf hf h hf defined h hf defined h hf e h hf e h h v v h hf e h hf v h hf e h hf v s s s s s h h gs v v gs h h k k e e h hf e h hf ke h hf e h hf ke s s h h gs e e gs s s g g k k kw g s s kw gs s k k v v gs kv kv ew gs s rv f v f v f f rf v v rv f f f f rf w stable w g s g s e e gs ew gs s g s h h s s h defined s s h h s s h defined e w e e e w g s dom x x x gs e e ew gs s n n infinite w wn n e w e figure mutually coinductive definitions of expression equivalence ew ws × ws and continuation equivalence kw ws × ws and definitions of world consistency and program equivalence for f expression and continuation equivalence the new definitions of e and k are also given in figure notice that they are now defined relative to a world w as ew and kw and that their types have changed to ws × ws and ws × ws respectively they take both an initial state s and a current state s as arguments given a world w a global knowledge g states s s ws and a type we say that two expressions are locally equivalent written e e ew gs s iff when executed starting in heaps that satisfy the heap relation of w at the current state s then as before one of three cases holds both expressions diverge run forever both expressions run successfully to completion producing related values in this case the values need not be related in the current state s but rather in some future state s s which however must also be a public future state of the initial state of the expression s s moreover this future state must be consistent with the resulting heaps h h gs both expressions reduce after some number of steps to some expressions of the form where ei are either both applications or both instantiations that are related at some future state s s this state must be consistent with the corresponding heaps finally the continuations k and k are equivalent under any public future state s s and any pointwise larger global knowledge g g we restrict s to be a public future state of s rather than an arbitrary future state because the effect of a function call or universal instantiation is assumed to always be a public transition for this assumption to be sound in return we will have to ensure that the behaviors of equivalent function bodies indeed change the state only into public future states this is why we thread the s argument through the coinduction and check that the final state in the previous case is a public future state of s the intuitive reason for over a larger global knowledge g is this at the point when the continuations are run not only might w s state s have changed to a future state s but also the states of all other modules which is reflected by the growth of the global knowledge in all three cases the definition over frame heaps hf and hf the execution of e and e should not update any disjoint part of the heap that they do not own according to the heap relation of the current state this aspect of our definition is a semantic version of the frame rule of separation logic and allows us to concentrate the reasoning about the heaps only on the parts of the heaps accessed by the program the frame rule into the semantic model is quite common in more recent models of separation logic essentially because it allows one to avoid proving any safety monotonicity or frame properties of the operational semantics itself properties of program equivalence and soundness the properties presented in section for as well as the corresponding soundness proofs extend naturally to the full model but we omit further details here due to space considerations we plan to present them in an expanded version of this paper we refer the reader to our online appendix see the link at the end of the paper a word on dependency in the examples in the next section we will not actually rely on the ability of local and heap relations to depend on the state of the reference world consequently the stability property in the definition of program equivalence will be trivially satisfied by choosing s s however dependent worlds are of critical importance in the transitivity proof for full f we will report on this issue in a future paper examples in this section we present several example equivalence proofs for convenience we drop the argument from the l and h components of local worlds since we do not use it in our examples state change recall the example from section and its highlevel using an sts we will now show in some formal detail how this proof is done using our method concretely we prove v e where unit unit int v f f f v f x f x f x e let x ref in v constructing a suitable we construct an w that we will then show to be consistent and to relate v and e since the programs dont involve abstract types we can define wn to be empty the sts that we build into w is essentially the one from section a state s ws is to be understood as follows for each running instance of e identified by the location that that instance initially allocated s says whether it is in the left state points to or in the right one points to accordingly the heap relation wh at state s is just s finally the local knowledge wl at state s relates v with v x for any location belonging to an instance ws loc fin heap w s s doms doms w wn s s w s s v v x doms s it is easy to see that w in particular wl and wh are monotone as required note that the dependency is and that w for s to show v w e two parts remain proving its consistency establishing is the real of the proof consider two functions related by wl at a state s clearly one is v and the other is v x for some doms now suppose we are given related arguments v v unit we need to show v v v v s note that for h h s we know by construction that h and h s consequently for any frame heaps hf hf we have h hf v v s hf v v where s denotes the restriction of s to domain doms since h hf v v h hf v v it suffices by the third disjunct in the definition of ew to find s s such that s s s sg g · v · v s int naturally we pick s s s then holds by construction of w and it remains to show after the whole procedure one more time we arrive at the goal of finding s s such that s s s sg g · · s int naturally we pick s s s then holds by construction of w and it remains to show we observe that for any s s it must be that s since s hence for h h s we know by construction h consequently for any frame heaps hf hf we have h hf h hf since of course h hf h hf and by definition we are done if we can show s s indeed this is easy to verify showing the programs related by it given how we constructed our this final goal is fairly easy to formally we must show v e s s for any g s note that if h h s then for some fresh we have h e h v x and of course h v h v it therefore suffices to find s s such that the following hold h h s v v x s we pick s s note that s is welldefined because is fresh so doms and that s s as required to show it suffices by definition of gk to show v v x s this holds by construction of w and s and so does a free theorem the next example demonstrates the treatment of universal types and the fact that our method may be used to prove at least some simple socalled free theorems suppose p and p v we want to prove that h v for any h we start by applying refl to obtain v v this gives us w with v w v and wn n for some arbitrary n of our choosing we now instantiate g to be the least solution of s gs from v w v we then get v v s where s is the state w consequently we get s s such that v v gs gs from the construction of g and we derive s for any so in particular we have sn in fact due to the construction of g lemma tells us sn for r s together with this allows only two cases for any heap h either h diverges then we are done or it terminates and the resulting values are related by gs n for some s s however because n and wn we know gs n gs n which rules out that second case abstraction this final example originally due to ahmed et al demonstrates the interaction of local state with abstract types unit × unit × × bool e let x ref in pack int pack int x x x x x x p p p e let x ref in pack int pack int x x x x x x p ff both e and e return a name generator adt consisting of two abstract types and together with a function for generating a fresh name of type a function for generating a fresh name of type and a function for comparing an name and a name for equality both implementations represent names as integers and in e the comparison operation really tests the names for equality in e however the comparison just always returns false right away nevertheless the two programs are contextually equivalent because the names and the names are generated by the same underlying integer counter and thus no value can be both an name and a name at the same time we now show the construction of an w that can be used to prove e e let a infinite n be given since loc is also infinite we can think of n as being split into n loc n loc we define w as follows ws s loc × loc fin pn × pn doms partial bijection s s s s s w w w s s ws × ws s s s s s s s s s s wn n n n n s s s s s n s s s s s n doms s unit n doms n × n bool p p p p ff doms h h domh doms domh doms s s s h h max s s here is short for and i for the appropriate projection function similar to the world construction in section states s ws are functions defined for those locations that intuitively were allocated in an instance of e and e respectively they are mapped to sets s and s of positive integers representing the current of the abstract types and respectively for that instance the crucial invariant here is that s and s are always disjoint the local knowledge wl declares es functions equivalent to those of e it also defines the meaning of type n as the identity relation restricted to those numbers that in the instance pair identified by and similarly for n and to keep the definitions as simple as possible the state space includes some states that actual program behaviour cannot result in but that nevertheless are consistent with the property we want to prove according to this interpretation the transition relation only allows s and s to grow the distinction between public and private transitions is not needed for this example finally wh says that the related heaps at state s are any h h where hi contains exactly those locations allocated in instances of ei and each such location stores the largest value out so far no matter if at or this latter condition is critical to ensure that s and s disjoint in each instance using this world it is straightforward to finish the proof details can be found in the online appendix world generators as one may observe from the examples in sections and worlds must often describe nary state spaces where each state consists of n copies of states drawn from some simpler state space one copy for each dynamic instance of the object or adt thus it would be convenient if one were able to reason about program equivalence under the case of a single copy ie n fortunately it is not hard to i define a world generator that given a world automatically performs the and ii show that program equivalence in a world implies equivalence in the automatically world for space reasons we do not present the details here but refer the interested reader to our online appendix where the proofs of the examples from sections and are simplified greatly with the help of such a world generator transitivity in this section we briefly sketch our proof of transitivity of equivalence in the pure simplified setting of as defined in section transitivity also holds for the full model described in section but the proof of that result is much more complex involving a notion of weak isomorphism between worlds so we leave its presentation to a future paper the main lemma we would like to prove is the following lemma if e l e and e l e then there exists l such that e l e naturally we can expect l to be some sort of composition of the given local l and l defining this composition is however quite subtle the problem is that the local knowledge takes the global knowledge g as a parameter but then what global gl and gl should be passed on to l and l in constructing l assuming we pick gl and gl appropriately l can be defined as follows lg where stands for ordinary relation composition the key part of the proof is showing transitivity of e g e e e e e e eg in order to prove this we want the disjunct of e by which e and e are related to match the disjunct of e by which e and e are related recall the three in the definition of e to illustrate say e and e are related because they reduce to related values second disjunct now consider the three cases regarding e and e they both diverge fortunately this contradicts our assumption about e so this case cannot arise they are related for the same reason as e and e e and e reduce to related values this is the good case relying on of reduction we are done if we can show transitivity of the value relation formally we need to show that gl gl g they reduce to related function calls with related continuations it is how to make sense of this situation so we want to rule it out in order to make case straightforward to show while simultaneously out case from consideration we will need to define gl and gl carefully the key idea is as follows for each pair of function values f f g come up with a value v that uniquely identifies f and f and that is not a normal function but rather a bad value that gets stuck when applied to an argument the first requirement allows us to ensure gl gl g as needed in proving transitivity of the value relation by relating f v gl and v f gl the second requirement together with lemma rules out the bad case above formally since type and are countable sets there exists an injective function i type × type × × n using this function one can decompose g as follows g f i f f f f g g i f f f f f g taking gl to be g is however incorrect because if l relates any values at function type then the global knowledge will not be closed wrt it ie g to address this problem we simply close g accordingly ie we take gl to be the least solution to the fixedpoint equation gl g and similarly for gl with these definitions we can show gl gl g if g moreover if we are in case above then lemma tells us that the functions being f f are really external meaning that they are related by g but by construction this means that f is an integer and thus e gets stuck the prior assumption that e and e reduce to values for further details we refer the interested reader to our online appendix related work and discussion our method of relation transition systems builds closely on ideas from several prior techniques we compare here only to the most immediately related work kripke logical relations the method of logical relations is an old and important technique for proving a variety of deep properties in languages such as strong normalization and parametricity although they were originally toward reasoning about pure calculi logical relations have been successfully generalized to reason about state in pitts and work on kripke logical relations logical relations are indexed by possible worlds which characterize the runtime environment eg the assumptions about heaps under which two programs are considered to be equivalent in the most recent work on dreyer et al showed how to generalize pitts and technique to reason about modules whose correctness proofs require finegrained control over how local state over time and mllike languages with higherorder state wrt point they model possible worlds as state transition systems as we have described in section adopt dreyer et als sts technique directly and thus it is relatively straightforward to port all the f equivalence proofs given in their papers from using to using wrt point the challenge of supporting higherorder state in kripke logical relations is that a naive attempt to construct a model of general reference types leads to a circularity intuitively and are related at ref under a possible world w iff w encodes the invariant that the heaps of the two programs map and to values v and v that are logically related at type but how can the logical relation be indexed by a possible world w which itself is defined in terms of the logical relation if is restricted to base type eg int no issue because the logical relation at int is simply the identity relation but at higher type we have a problem dreyer et al handle higherorder state by means of appel and technique of stepindexed logical relations that is they cut the semantic circularity by indexing the model by a natural number step index k which represents the number of steps left on the clock and which gets every time around the cycle between logical relations and possible worlds while is a powerful it can be somewhat to work with due to the tedious of step counting throughout proofs more importantly it seems difficult to compose proofs ahmed studied the transitivity problem in her first paper on binary there she observed a serious problem in proving that appel and original binary formed a per she proposed a way of transitivity of for a pure language with recursive types but her approach relies on syntactic typing assumptions into the model such an approach is to scale to reasoning about the intermediate and lowlevel languages of a certified compiler one of our goals which in general may be untyped moreover we are not aware of any successful attempts to generalize her technique to for richer languages employ the idea of global knowledge in order to avoid the need for in modeling higherorder state specifically by the heap relations in our worlds over the global knowledge g we give heap invariants a way of referring to the global value equivalence which is essentially what the stepindexed of kripke worlds is trying to achieve as well in contrast to we already have a proof that equivalence for f is transitive and our method does not in any syntactic typing assumptions in fact our transitivity proof depends on instantiating global knowledge parameters with syntactically illtyped relations bisimulations aside from their general coinductive are closely related to two different bisimulation techniques from normal form or open bisimulations we take the idea of treating unknown equivalent functions as black boxes in particular our expression equivalence relation e which deals explicitly with the possibility in its third disjunct that related terms may get stuck by calling unknown functions is highly of the formulation of normal form bisimulations the main difference is that we express the notion of semantically via the global knowledge parameter g whereas normal form bisimulations express it syntactically by requiring related stuck terms to share a common head variable normal form bisimulations draw much from models and our distinction between global and local knowledge has a as well we leave a deeper study of the connection to game semantics to future work et als bisimulations bisimulations are perhaps the most powerful form of bisimulation yet developed for mllike languages as the latter name suggests these bisimulations are not term relations but sets x whose elements are themselves term relations r possibly with some additional information such as knowledge about the state of the heap in essence each r x defines some piece of local knowledge following our terminology about program equivalence in order to show x to be a bisimulation one must check that for all r x uses of terms related by r will never result in different outcomes and will always produce values that are related by some r x st r r viewed in terms of one can understand an bisimulation x as effectively defining an abstract state space with each r x as a distinct state however the transition relation between these states is essentially in roughly speaking a term relation r is accessible from another term relation r if r r thus bisimulations provide less control over the structure of the transition system than do and they do not support anything directly analogous to the distinction between public and private transitions as a consequence bisimulations are most effective at proving equivalences that require transition systems with only public transitions eg the abstraction example and their proofs for examples where private transitions are required eg the state change example are it is an open question whether bisimulations can be generalized to support the full power of with both public and private transitions our approach to reasoning about parametricity of by the local knowledge of a world with relations at abstract type names is inspired directly by and pierce large vs small worlds while build very closely on the state transition systems in dreyer et als there is a big difference between them which we like to think of in terms of large vs small worlds under dreyer et als approach in order to demonstrate the equivalence of functions f and f under a possible world w one proves that they behave the same when passed arguments that are related under any future world w of w which may contain arbitrary new invariants concerning the local state of other modules in the program one can really think of the future world relation ie the kripke structure as defining its own transition system or large world with the possible worlds w as its states in contrast our rely only on small worlds for us worlds w are static entities that contain only the local invariants relevant to the module we are reasoning about and nothing about any invariants for other parts of the program in proving equivalence of functions f and f under w we never quantify over any future worlds that extend w of course in order to support compositional in order to show that consistency of worlds is preserved under separating must show that f and f behave the same when applied to arguments drawn from some larger relation than just w s local knowledge but for that purpose we quantify over the global knowledge g which is not a world but rather an arbitrary extension of w s local knowledge these different accounts of worlds are strongly of the different techniques that have been proposed for modeling resource invariants in logics of locks et al and et al presented roughly two different models of a concurrent separation logic for local reasoning about programs that dynamically allocate locks and store them in the heap the central challenge in developing such a model is in dealing with the semantic circularity that arises when for locks whose resource invariants are essentially recursive et al deal with this circularity syntactically by assuming a static set of named sorts of resource invariants which includes not all possible invariants but only those needed for reasoning about a particular program in contrast et al and more recently et al deal with the circularity defining once and for all what recursive resource invariants mean using the latter is analogous to dreyer et als large worlds approach which defines the space of all possible heap invariants while the former is analogous to our small world approach of defining only the heap invariants needed within the module we are reasoning about which is better it is hard to say our relations seem easier to compose precisely because we make no assumption about the of functions defined outside of whatever module we are reasoning about that is the global knowledge g that we quantify over eg when proving world consistency could include complete garbage and the transitivity proof sketched in section relies in a fundamental way on the insertion of garbage into the global knowledge on the other hand it is also possible that this approach is what leads our model not to validate equivalence the with equivalence one limitation of is that they do not validate the equivalence rules for function and universal types to see why suppose the rule for functions were true a similar argument applies to f f x f x then by definition there would exist a consistent world w st for all g and for all functions f and f related by g we would have f and x f x related by g as well were over the role of states and transitions here because orthogonal the problem is that it is easy to construct an g that contains f f but not f x f x the same gs that make our proof of transitivity section possible also cause to fail as a result there are certain examples that have appeared in the literature on relational reasoning for mllike languages which our method cannot handle precisely because they depend on equivalence the one is the syntactic minimal invariance example which demonstrates that the infinite expansion at a general recursive type eg unit is equivalent to the identity function the lack of in our model makes a lot of sense because our proofs make no assumptions about whether unknown functions are even expressions let alone whether they in this respect are again similar to normal form bisimulations which are sometimes easier to prove congruent in their there are known ways to close normal form bisimulations over equivalence by the definition of consistency and it is possible that we could adapt such techniques to work for however our concern based at this point solely on intuition is that there may be a fundamental tradeoff between supporting and supporting transitive composition of equivalence proofs in that case we would consider transitivity a more important at least in the context of reasoning about compiler correctness moreover our lack of support for may in fact our method applicable to reasoning about higherorder languages with more restricted equational theories eg ocaml with its equality tests on function pointers we leave this matter to be explored further in future work conclusion and future work we have developed a novel transition systems for proving equivalence of mllike programs combining some of the best aspects of kripke logical relations bisimulations and normal form bisimulations in addition to providing a useful synthesis of the complementary advantages of its ancestors our method shows as a way of reasoning about equivalences between different languages thanks to our of syntactic devices that would reasoning and the transitive of equivalence proofs we have briefly sketched the proof of transitivity here in a simplified setting and we intend to report on the full transitivity result in a paper we have mechanized the metatheory of in coq and made the proofs available at the link below there are several directions for future work first and we aim to concretely demonstrate the of for reasoning for example we would like to take and recent work on kripke logical relations between ml and assembly replace the logical relations with and then apply the technique to reasoning about compositional correctness of compilation second following dreyer et als work on kripke logical relations we would like to explore how well our account of can be adapted to handle the introduction of control effects callcc exceptions into the language andor the restriction of the language to firstorder state in principle we believe it should be possible to employ techniques similar to but we have not yet tried we have recently discovered what appears to be a deep connection between our technique of global vs local knowledge and recursion in particular the notion of a l is defined to be a of an f if g l l f g this a to our definition of consistency for local l at least in the pure setting of section one interesting feature of is that they a robust version of fixedpoint theorem which applies even when the f is not monotone indeed in our scenario f is not monotone due to the quantification over related function arguments and this is precisely what motivated our over g we intend to explore this connection further in future work online appendix details of the metatheory in pdf and coq are available at acknowledgments we thank and the anonymous reviewers for very helpful feedback on the paper as well as andrew pitts for us to the connection with recursion references s abramsky the lazy lambda calculus in d a turner editor research topics in functional programming pages ­ a ahmed semantics of types for mutable state phd thesis princeton university a ahmed stepindexed syntactic logical relations for recursive and quantified types in esop a ahmed and m an cps translation via semantics in icfp a ahmed d dreyer and a representation independence in popl a appel and d an indexed model of recursive types for foundational proofcarrying code toplas ­ n benton and ck and compiler correctness in icfp l birkedal r e j and k first steps in guarded domain theory in the of trees in lics l birkedal n and h yang semantics of typing and higherorder frame rules for algollike languages a l birkedal and k a stepindexed kripke model of separation logic for locks in d dreyer a ahmed and l birkedal logical stepindexed logical relations ­ june d dreyer g and l birkedal the impact of higherorder state and control effects on local relational reasoning in icfp d dreyer g a and l birkedal a relational modal logic for higherorder stateful in popl jy girard y and p taylor proofs and types volume of cambridge in theoretical computer science cambridge university press a j berdine b cook n and m sagiv local reasoning about locks and threads in a a appel and f oracle semantics for concurrent separation logic in esop ck and d dreyer a kripke logical relation between ml and assembly in popl v p b and e from applicative to bisimulation in v and m wand small bisimulations for reasoning about higherorder imperative programs in popl j a fully abstract trace semantics for general references in icalp s eager normal form bisimulation in lics s b and p b typed normal form bisimulation in csl s b and p b typed normal form bisimulation for parametric polymorphism in lics n p inductive types and type constraints in the secondorder lambdacalculus of pure and applied logic ­ ­ a s and n game semantics for good general references in lics g d dreyer and a parametricity ­ b c pierce and d sangiorgi behavioral equivalence in the polymorphic picalculus journal of the acm ­ a pitts typed operational reasoning in b c pierce editor advanced topics in types and programming languages chapter mit press a pitts and i operational reasoning for functions with local state in a m pitts relational properties of domains information and computation ­ j c reynolds types abstraction and parametric polymorphism in information processing d sangiorgi the lazy lambda calculus in a concurrency scenario information and computation ­ d sangiorgi n kobayashi and e bisimulations for higherorder languages in lics k and s a complete coinductive syntactic theory of sequential control and state in popl e a complete characterization of observational equivalence in polymorphic calculus with general references in csl e and b pierce a bisimulation for type abstraction and recursion journal of the acm ­ j and l birkedal a kripke logical relation for program transformations in icfp t and v inductive types journal of computing ­ v vafeiadis concurrent separation logic and operational semantics in p wadler theorems for free in 