advanced automata minimization university of i richard university of edinburgh abstract we present an efficient algorithm to reduce the size of nondeterministic bu¨chi word automata while their language additionally we describe methods to solve automata problems like equivalence and inclusion for much larger instances orders of magnitude than before this can be used to scale up applications of automata in formal verification tools and decision procedures for logical theories the algorithm is based on new transition pruning techniques these use criteria based on combinations of backward and forward trace since these relations are themselves we describe methods to compute good approximations of them in polynomial time extensive experiments show that the complexity of our algorithm the size reduction of the automata depends very much on the class of instances but our algorithm consistently all previous techniques by a wide we tested our algorithm on bu¨chi automata derived from many classes of random automata and automata derived from mutual exclusion protocols and compared its performance to the wellknown automata tool goal categories and subject descriptors d software verification model checking f models of computation automata general terms automata minimization inclusion checking keywords bu¨chi automata simulation minimization introduction nondeterministic bu¨chi automata are an effective way to represent and manipulate regular languages since they are closed under boolean operations they appear in many formal software verification methods as well as in decision procedures for logical theories for example in ltl software model checking temporal logic specifications are converted into bu¨chi automata in other cases different versions of a program obtained by abstraction or refinement of the original are translated into automata whose languages are then compared testing the of an implementation with its requirements specification thus reduces to a language inclusion or language equivalence problem another application of bu¨chi automata in software engineering is program termination analysis by the termination permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm method via an abstraction of the effect of program operations on data the termination problem can often be reduced to a language inclusion problem about two derived bu¨chi automata our goal is to improve the efficiency and scalability of formal software verification methods we consider efficient algorithms for the minimization of automata in the sense of obtaining a smaller automaton with the same language though not necessarily with the absolute minimal possible number of states and in general the minimal automaton for a language is not even unique the reason to perform minimization is that the smaller automaton is more efficient to handle in a subsequent computation thus there is an algorithmic tradeoff between the effort for minimization and the complexity of the problem later considered for this automaton if only computationally easy questions are eg solvable in then extensive minimization usually does not pay off instead the main applications are the following computationally hard automata problems like equivalence and inclusion these are but many practically efficient methods have been developed still these all have exponential time complexity and do not scale well typically they are applied to automata with ­ states unless the automaton has a particularly simple structure thus one should first minimize the automata before applying these methods a good minimization algorithm makes it possible to solve much larger instances even better many instances of the equivalence and inclusion problems can already be solved in the polynomial time minimization algorithm eg by reducing the automaton to the trivial universal automaton so that the complete exponential time methods only need to be invoked in a small of instances cases where the size of an automaton strongly affects the complexity of an algorithm in ltl model checking one searches for loops in a graph that is the product of a large system specification with an automaton derived from an smaller automata often make this easier though in practice it also depends on the degree of nondeterminism procedures that combine and modify automata repeatedly model checking algorithms and decision procedures for logical theories compute automata products unions projections etc and thus the sizes of automata grow thus it is important to minimize the automata to keep their size eg in general finding an automaton with the minimal number of states for a given language is computationally hard even deciding whether a given automaton is minimal is already thus much effort has been to finding methods for partial minimization simulation a central role in these efforts because they provide computable of trace however the quality of the approximation is in many practical examples simulations yield relations by allowing the player to her in the simulation game but they are not easily computable in practice we present methods for transition pruning ie removing transitions from automata without changing their language the idea is that certain transitions can be removed because other better transitions remain the better criterion relies on combinations of forward and backward simulations and trace we provide a complete picture which combinations are correct to use for pruning moreover the transitions can be removed in parallel ie without the simulations and trace after every change which makes the method efficient and practical we present an efficient practical method to compute good of trace by introducing lookahead simulations while it is correct to use full trace and simulations in our minimization methods these are not easily computed however lookahead simulations are and it is correct to use them instead of the more expensive trace and simulations lookahead itself is a classic concept in parsing and many other areas but it can be defined in many different variants our contribution is to identify and formally describe the for simulation that gives the optimal between efficient and the sizes of the relations practical of lookahead range from to depending on the size and shape of the automata our experiments show that even lookahead helps considerably in obtaining good approximations of and simulations we show that variants of the polynomial time minimization algorithm can solve most instances of the language inclusion problem thus the complete exponential time methods of need only be invoked in a of the cases this allows to scale language inclusion testing to much larger instances eg automata with states which are beyond traditional methods we performed extensive tests of our algorithm on automata of upto states these included random automata according to the model automata obtained from ltl formulae and realworld mutual exclusion protocols the determined time complexity on random automata is quadratic while the never observed worstcase complexity is on the worstcase space complexity is quadratic our algorithm always better on average than all previously available practical methods however the exact advantage depending on the type of instances cf section for example consider random automata with ­ states binary alphabet and varying transition density td random automata with td cannot be much by any method the only effect is achieved by the trivial removal of dead states which on average yields automata of of the original size on the other hand for td the best previous minimization methods automata of ­ of the original size on average while our algorithm automata of ­ of the original size on average while we present our methods in the framework of bu¨chi automata they directly carry over to the simpler case of automata a literature search showed that this has never been formally described so far a nondeterministic bu¨chi automaton ba a is a tuple q i f where is a finite alphabet q is a finite set of states i q is the set of initial states f q is the set of accepting states and q × × q is the transition relation we write p q for p q a transition is iff any path can contain it at most once to simplify the presentation we assume that automata are forward and backward complete ie for any state p q and symbol there exist states q q q st q p q every automaton can be converted into an equivalent complete one by adding at most two states and a linear number of transitions a state is dead iff either it is not reachable from an initial state or it cannot reach an accepting loop in our simplification techniques we always remove dead states a bu¨chi automaton a describes a set of infinite words its language ie a subset of an infinite trace of a on a word w · · · or starting in a state q q is an infinite sequence of transitions q q · · · by i we denote the finite prefix q · · · i qi and by i the infinite suffix qi i qi i · · · finite traces starting in q and ending in a state qm q are defined similarly a finite or infinite trace is initial iff it starts in an initial state q i if it is infinite then it is fair iff qi f for infinitely many i the language of a is la w a has an infinite initial and fair trace on w language inclusion when automata are viewed as a finite representation for languages it is natural to ask whether two different automata represent the same language or more generally to com these languages for inclusion formally for two automata a qa ia fa a and b qb ib fb b we write a b iff la lb and a b iff la lb the language problem consists in determining whether a b or a b holds respectively for general nondeterministic au language inclusion and equivalence are which entails that under standard assumptions they admit no efficient deterministic algorithm therefore one considers suitable definition a preorder on qa × qb is good for inclusion iff the following holds if q ia q ib · q q then a b in other words give a sufficient condition for sion by matching initial states of a with initial states of b they are not necessary for inclusion since there are several initial states moreover if computing a preorder is efficient than also inclusion can be established efficiently finally if a preorder is then all smaller are too ie is downward closed another interesting problem is how to simplify an automaton while preserving its semantics ie its language generally one tries to reduce the number of this is useful because the complexity of decision procedures usually depends on the size of the input automata a classical operation for reducing the number of states of an automaton is that of where states of the automaton are identified according to a given equivalence and transitions are accordingly since in practice we obtain equivalences from suitable we directly define wrt a preorder formally fix a ba a q i f and a preorder on q with induced equivalence given a state q q we denote by q its equivalence class wrt and for a set of states p q p is the set of equivalence classes p p p p for efficiency reasons our implementation works directly on incomplete automata definition the of a by is a q i f where q q q q q q q q ie transitions are induced clearly every trace q q · · · in a immediately induces a corresponding trace q q · · · in a which is if the former is respectively consequently a a for any preorder if additionally a a then we say that the preorder is good for definition a preorder is good for iff a a like also are downward closed since a smaller preorder is less therefore we are interested in efficiently computable a classical example is given by simulation relations simulation relations basic forward simulation is a binary rela tion on the states of a it relates states whose behaviors are step related which allows one to reason about the internal structure of automaton a ie how a word is accepted and not just whether it is accepted formally simulation between two states p and q can be described in terms of a game between two players and where the latter wants to prove that q can any behavior of p and the former wants to it the game starts in the initial configuration p q inductively given a game configuration pi qi at the ith round of the game chooses a symbol i and a transition pi i pi then by choosing a matching transition qi i qi and the next configuration is pi qi since the automaton is assumed to be complete the game goes on forever and the two players build two infinite traces p p · · · and q q · · · the winning condition depends on the type of simulation and different types have been considered depend ing on whether one is interested in or relations here we consider direct delayed and fair simulation let x di de f the play if c x holds where c di i · pi f qi f c de i · pi f j i · q j f c f if is fair then is fair intuitively direct simulation requires that accepting states are matched immediately the strongest condition while in delayed simulation is allowed to accept only after a finite delay in fair simulation the weakest condition must visit accepting states only if infinitely many of them thus c di implies c de which in turn implies c f we define relation x q × q by that p x q iff has a winning strategy in the game starting from configuration p q clearly simulation between states in different automata a and b can be computed as a simulation on their disjoint union all these simulation relations are which can be computed in polynomial time moreover direct and delayed simulation are but fair simulation is not lemma for x di de f x is a preorder and for y di de y is also trace while simulations are efficiently computable their use is often limited by their size which can be much smaller than other one such example of is given by trace which are obtained through a modification of the simulation game as follows in simulation games the players build two paths by choosing single transitions in an alternating fashion moves by knowing only the next step move of we can obtain relations by allowing a certain amount of lookahead on moves in the case of lookahead ie where has to reveal her whole path in advance we obtain trace analogously to simulations we define direct delayed and fair trace inclusion as binary relations on q for x di de f inclusion holds between p and q written p x q iff for every word w · · · and for every infinite p p · · · starting at p p there exists an infinite q q · · · starting at q q st c x all these trace are the corresponding simulation ie x x since has more power in the trace inclusion game also di is a subset of de which in turn is a subset of f regarding di is like di this follows from while f is not since it is than fair simulation which is not while delayed simulation de is delayed trace inclusion de is not lemma for x di de f inclusion x is a preorder moreover di is a preorder finally though de and di are incomparable there exists a common generalization included in de called delayed simulation which is backward simulation and trace inclusion yet another way of obtaining is to consider variants of inclusion which go backwards in time backward simulation bw where it is called reverse simulation is defined like ordinary simulation except that transitions are taken backwards from configuration pi qi selects a transition pi i pi with a transition qi i qi and the next configuration is pi qi let and be the two infinite backward traces built in this way the corresponding winning condition considers both accepting and initial states c bw i · pi f qi f and pi i qi i bw is an efficiently computable preorder incomparable with forward simulations it can be used to establish language inclusion by matching final states of a with final states of b to forward simulations in this sense it is lemma backward sim is a preorder the corresponding notion of backward trace inclusion bw is defined as follows p bw q iff for every finite word w · · · m and for every initial finite p p · · · m pm ending in pm p there exists an initial finite q q · · · m qm ending in qm q st for any i if pi f then qi f note that backward trace inclusion deals with finite traces unlike forward trace which is due to the between past and future in automata clearly we observe that even bw is theorem backward trace inclusion is a preorder proof we first prove that bw is let bw let w · · · la and we show w la there exists an initial infinite and fair q q · · · for i let wi · · · i with w and let i be the delayed simulation is defined as a variant of simulation where has lookahead only on the input word w and not on actual that it subsumes di is nontrivial prefix of for any i we build by induction an initial finite i ending in qi of length i at least as many accepting states as i and at the same time i does for i just take the empty trace q for i assume that an initial i ending in qi has already been built we have the transition qi i qi in la there exist q qi and q qi st we have a transition q i q in a we can assume that q qi since qi q by qi bw q there exists an initial finite ending in q by the definition of backward inclusion at least as many accepting states as i which by inductive hypothesis at least as many accepting states as i therefore i i qi is an initial finite ending in qi moreover if qi f then since backward inclusion respects accepting states qi f hence qi f and consequently i at least as many accepting states as i since is fair the finite initial traces · · · visit many accepting states since a is finitely branching by lemma there exists an initial infinite and fair therefore w la we now prove that bw is let a and b be two automata for backward notions we require that every accepting state in a is in relation with an accepting state in b let w · · · la and let p p · · · be an initial and fair in a since infinitely many accepting states and since each such state is to an accepting state in b by using the definition of bw it is possible to build in b longer and longer finite initial traces in b many accepting states since b is finitely branching by lemma there exists an infinite initial and fair in b thus w lb transition pruning minimization techniques while minimization techniques reduce the number of states by merging them we explore an alternative method which ie removes transitions the intuition is that certain transitions can be removed from an automaton without changing its language when other better transitions remain definition let a q i f be a ba and let p a tive asymmetric relation on the automaton is de as p q i f with p r p r · p r by the assumptions on p the automaton p is uniquely defined notice that transitions are removed in parallel though p might depend on p is not even if the removal of a single transition changes this is important because computing p may be expensive since removing transitions cannot introduce new words in the language p a when also the converse inclusion holds so the language is preserved we say that p is good for pruning ie p is iff pa clearly is downward closed like and we study relations obtained by comparing the of transitions over the same input symbol formally given two binary relations rb rf q × q we define rf p r p r p and r · is monotone in both arguments in the following we explore which state relations rb rf induce relations rf it has long been known that pid di and id are see where the removed transitions are called little moreover even the relation rt f pid di p r p r p r is and r f r is ie strict fair trace inclusion suffices if the remaining transition can only be used once however in general pid f is id bw bw id di di × × de f figure relations rf not moreover even if only transitions are f is not cf fig theorem for every asymmetric and transitive relation r di pid r is proof let a pid r we show a a if w · · · la then there exists an infinite fair initial trace on w in a we show w la we call a trace q q · · · on w in a if it does not contain any transition q j j q j for j i st there exists an a transition q j j qj with q j r qj ie no such transition is used within the first i steps since a is finitely branching for every state and symbol there exists at least one successor that is still present in a because r is asymmetric and transitive thus for every trace on w there exists an i good trace on w st and are identical on the first i steps and c di because r di since is an infinite fair initial trace on w which is trivially good there exists an infinite initial trace on w that is for every i and c di moreover is a trace in a since is fair and c di is an infinite fair initial trace on w that is for every i therefore is a fair initial trace on w in a and thus w la theorem for every asymmetric and transitive relation r bw pr id is proof let a pr id we show a a if w · · · la then there exists an infinite fair initial trace on w in a we show w la we call a trace q q · · · on w in a if it does not contain any transition q j j q j for j i st there exists an a transition qj j q j with q j r qj ie no such transition is used within the first i steps we show by induction on i the following property p for every i and every initial trace on w in a there exists an initial trace on w in a st and have identical from step i and c di the base case i is trivial with for the induction step there are two cases if is i good then we can take otherwise there exists a transition qi i qi with qi r qi without restriction since a is finite and r is asymmetric and transitive o qi i qi and c di then by induction hypothesis moreover and have identical from step i finally by c di and c di we obtain c di given the infinite fair initial trace on w in a it follows from property p and lemma that there exists an infinite initial trace on w that is for every i and c di therefore is an infinite fair initial trace on w in a and thus w la theorem if a a bw then di is proof let a di we show a a let w · · · la then there exists an infinite fair initial trace on w in a we show w la we call a trace q q · · · on w iff it is initial and there does not exist any trace q q · · · on w st c di and q bw q we call a trace q q · · · on w iff it is and does not contain any transition q j j q j for j i st there exists an a transition q j j qj with q j bw qj and there exists an infinite trace j from qj with c di j j since a is finite there are elements among those finitely many successors of every state q j from which there exists an infinite trace j with c di j j thus for every infinite trace on w there exists an i good trace on w st and are identical on the first i steps and c di since there is an infinite fair initial trace on w there also exists a and thus good fair initial trace on w because bw has maximal elements then it follows from the property above that there exists an infinite initial trace on w that is for every i and c di in particular this implies that is fair so is an infinite fair initial trace on w that is for every i let now q q · · · we show that is also possible in a by assuming the opposite and deriving a contradiction sup pose that contains a transition q j j q j that is not present in a then there must exist a transition qj j qj in a st q j bw qj and q j di qj we cannot have j because in this case would not be and thus not even good so we get j since q j bw qj and q j j q j there must exist a state qj st qj j qj and q j bw qj in particular qx f qx f for x j j by a a bw we obtain that either q j qj or q j bw qj the first case would imply that is not because q j di qj and thus yield a contradiction therefore we must have q j bw qj we cannot have j because in this case would not be and thus not even good so we get j the whole argument above with j j j substituted for j until we get a contradiction or is reached reaching also yields a contradiction to of as above therefore is a fair initial trace on w in a and thus w la theorem di is proof let a di we show a a let w · · · la then there exists an infinite fair initial trace on w in a we show w la given some infinite initial trace q q · · · on w we call it iff its first i transitions are also possible in a we now show by induction on i the following property p for every infinite initial trace q q · · · on w and every i there exists an infinite initial trace q q · · · on w that is and c di and j i q j di qj the base case i is trivially true with for the induction step consider an infinite initial trace q q · · · on w by induction hypothesis there exists an infinite initial trace q q · · · on w that is and c di and j i q j di qj if is i good then we are done otherwise the transition qi i qi is not present in a since a di there must exist a transition qi i qi in a st qi bw qi and qi di qi it follows from the definitions of bw and di that there exists an infinite initial trace q q · · · on w st c di qi di qi and j i qj di qj this last property uses the fact that di propagates forward direct trace inclusion di does not suffice by induction hypothesis there exists an infinite initial trace q q · · · on w that is and c di and j i qj di qj by transitivity we obtain c di qi di qi and j i qj di qj if is i good then we are done otherwise the argument of the above and we obtain an infinite initial trace q q · · · on w that is and c di that qi di qi and j i qj di qj this process cannot repeat infinitely often because this would imply an infinite strictly increasing for x which is impossible in finite automata therefore for some finite index x we obtain an infinite initial trace x qx qx · · · on w that is i good and by transitivity c di x and j i q j di thus x is the trace that we were looking for given the infinite fair initial trace on w in a it follows from property p and lemma that there exists an infinite initial trace on w that is for every i and c di therefore is an infinite fair initial trace on w in a and thus w la theorem implies that di is but di is not see figure moreover pid de is not even if a a de see figure the and transition pruning techniques described above use combinations of backward and forward simulations and more general trace in particular they previous attempts to combine backward and forward simulations for automata minimization by preorder but not preorder is defined as the largest fragment m di bw st m di m in particular m is a preorder that is however an automaton a that has been by the techniques described above cannot be further reduced by me preorder first we have a a bw a di by repeated second there cannot exist any distinct states x y in a st x di y x bw y by the pruning techniques above used with simulations as approximations for trace and the removal of dead states under these conditions with preorder has no effect as the following theorem shows theorem let a be an automaton st a a bw a di and x di y x bw y x y then a am proof we show that x y which implies a am let and by definition of m there exist z st x di z and y bw z and w st x bw w and y di w since m di m we have thus there exists a k st x di k and w bw k by transitivity of bw we also have x bw k by we get x k thus x bw w and w bw x by we get x w thus y di w x di z and by transitivity y di z moreover y bw z as above by we get z y thus x di z y and y di w x by we get x y di bw a b c p a q a a c p a q a a r a r bw di a s a d a a s e ab d a a di is not if the dashed transitions p a q and r a s are removed then ae is no longer accepted note that a a bw this example even holds for and k cf section a q a b a b a ps a b r a c b is not closed under c pid de is not we union pruning automaton a with have q de p but removing pid di id would the dashed transition p a remove the transitions p a r and q makes the language empty q a s and thus would no even though a a de longer be accepted a b a p a a b qr d f is not in the automaton above both transitions p a q and q a r are moreover r f q even r de q and q bw p however removing the smaller transition q a r changes the language since a is no longer accepted thus f is not even when one restricts to only transitions unlike pid f figure pruning counterexamples lookahead simulations while trace are as than simulations it is not feasible to use them in practice because they are too hard to compute even their membership problem is as a first attempt at achieving a better tradeoff between complexity and size we recall simulations which are obtained by providing with several pebbles instead of one however computing simulations is not feasible in practice either on automata of nontrivial size therefore we explore yet another way of obtaining good of trace inclusion we introduce lookahead simulations which are obtained by providing with a limited amount of information about future moves while lookahead itself is a classic concept eg in parsing it can be defined in several different ways in the context of games like in simulation we compare different variants for computational efficiency and approximation quality simulation simulation preorder can be generalized by allowing to control several pebbles instead of just one in simulation k position is a set of at most k states while still exactly state which allows to her in the simulation game the direct delayed fair and backward winning conditions can be generalized to the framework for x di de f bw and k is than and it implies by increasing k one can control the quality of the approximation to trace inclusion direct delayed fair and backward simulations are not transitive in general but their transitive closures are the direct delayed and backward variants are also however computing simulations is infeasible even for values for k in fact for a ba with n states computing simulation requires solving a game of size n · nk even in the simplest case of k this means at least space which is not practical for large n for this reason we consider a different way to extend power ie by using lookahead on the moves of simulation we generalize simulation by having the players select sequences of transitions of length k instead of single transitions this gives more information and thus yields a larger simulation relation in general simulation and simulation are incomparable but simulation is strictly contained in simulation however the use of lookahead in causes at least two issues for a ba with n states we need to store only n configurations p q which is much less than simulation however in every round we have to explore upto dk different moves for each player where d is the maximal of the automaton in practice eg d k this is still too large lookahead between and k depending where she is in her response to long move thus might lack lookahead where it is most needed while having a large lookahead in other situations where it is not useful in the next notion we attempt at this simulation is kept about next k moves ie she always has lookahead k formally a configuration of the simulation game consists in a pair i qi where i is the sequence of the next k moves from pi that has already committed to in every round of the game reveals another move k steps in the future and then makes the first of her k moves to which as usual a pair of states p q is in simulation if can this game from every configuration q where is a sequence of k moves from p k is ordinary simulation simulation is strictly contained in simulation but incomparable with simulation and larger than simulation while this is the strongest way of giving lookahead to it requires storing n · dk configurations which is infeasible for nontrivial n and k eg n d k simulation we introduce simulation as an optimal between and simulation intuitively we put the lookahead under control who can choose at each round how much lookahead she needs up to k formally configurations are pairs pi qi of states in every round of the game chooses a sequence of k consecutive transitions pi i pi i · · · ik then chooses a number m k and with a matching sequence of m transitions qi i qi i · · · im the remaining k m moves of are and the next round of the game starts at in this way the players build two infinite traces from p and from q backward simulation is de similarly with backward transitions for acceptance condition x di de f bw this play if c x holds definition two states p q are in written p kx q iff has a winning strategy in the above game since kx is not transitive unless k we denote its transitive closure which is a preorder by kx and its asymmetric restriction by kx kx kx lookahead simulation offers the optimal tradeoff between and simulation since the lookahead is discarded at each round simulation is strictly included in lookahead where the lookahead is never discarded however this has the benefit of only requiring to store n configurations which makes computing lookahead simulation on the other side when always chooses a maximal reply m k we recover simulation which is thus included in simulation moreover thanks to the fact that the lookahead most of the game can be solved without ever reaching the maximal lookahead k for a fixed attack by we only consider responses for small m k until we find a winning one and also attacks can be built incrementally since if she for some lookahead h then she also for h h in practice this greatly up the computation and allows us to use in the range depending on the size and structure of the automata see section for the experimental evaluation and benchmark against the goal tool simulation can also be expressed as a restriction of simulation where is allowed to split pebbles thus but after a number m k where m is chosen dynamically by she has to discard all but one pebble then is allowed to split pebbles again etc thus simulation is contained in simulation though it is generally incomparable with simulation direct delayed fair and backward simulation have a fixedpoint characterization expressible in µcalculus which can be useful for a symbolic implementation however our current algorithm computes them with an representation automata minimization we minimize automata by transition pruning and while trace would be an ideal basis for such techniques they ie their membership problems are instead we use lookahead simulations as efficiently computable in particular we use · in place of direct trace inclusion di which is · in place of delayed simulation · in place of fair trace inclusion f which is · in place of backward trace inclusion bw which is by theorem for pruning we apply the results of section and the substitutions above to obtain the following relations pid id p di rt for we employ delayed and backward simulations which are below we describe two possible ways to combine our simplification techniques and which are parameterized by the lookahead value k we the following minimization procedure which repeatedly applies all the techniques described in this paper until a fixpoint is reached remove dead states transitions wrt the relations above using lookahead k wrt and the resulting simplified automaton cannot be further reduced by any of these techniques in this sense it is a local minimum in the space of automata applying the techniques in a different order might produce a different local minimum and in general there does not exist an optimal order that works best in every instance in practice the order is determined by efficiency considerations and easily computable operations are used first remark while with ordinary simulation is idempotent in general this is not true for lookahead simulations because these relations are not preserved under unlike ordinary simulation moreover wrt forward simulations does not preserve backward simulations and our experiments showed that repeatedly and wrt and in addition to our pruning techniques yields the best minimization effect the procedure strictly subsumes all automata minimization methods described in the literature removing dead states pruning of little transitions preorder except for the following two the fair simulation minimization of works by merging fair simulation equivalent states and then checking if this operation preserved the language in general fair simulation is not it subsumes with de but not and is implemented in goal we our methods against it and found to be much better in both effect and efficiency cf section the of are incomparable to the techniques described in this paper if applied in addition to they yield a very extra minimization effect this procedure is defined purely for comparison reasons it demonstrates the effect of the lookahead k in a single operation and works as follows remove all dead states and then wrt although achieves much less than it is not necessarily faster this is because it uses the more expensive to compute relation directly while applies other pruning operations first and only then computes on the resulting smaller automaton language inclusion checking the language inclusion problem a b is it can be solved via of b and more ef by and references or methods or variants of construction since these all have exponential time complexity it helps significantly to first minimize the automata in a preprocessing step better minimization techniques as described in the previous sections make it possible to solve significantly larger instances however our techniques can not only be used in preprocessing but actually solve most instances of the inclusion problem directly this is significant because simulation quadratic complexity cf section minimization inclusion checking algorithms generally benefit from minimization preprocessing cf sec however pre the languages of a and b in the preprocessing is not actually necessary a preprocessing on a b is said to be iff it produces automata a b st a b a b regardless of whether a a or b b in the following we consider two preprocessing steps simplify a in theory the problem a b is only hard in b but polynomial in the size of a however this is only relevant if one actually constructs the complement of b which is of course to be avoided for polynomial algorithms it is crucial to also minimize a the idea is to remove transitions in a which are covered by better transitions in b definition given a qa ia fa a b qb ib fb b let p a × b be a relation for comparing transitions in a and b the version of a is b p qa ia fa with p r a p r b p r a b implies b p b since b p a when also the other direction holds so pruning is inclusion preserving we say that p is good for a ie when a b b p b intuitively pruning is correct when the removed edges do not allow a to accept any word which is not already accepted by b in other words if there is a counter example to inclusion in a then it can even be found in b p as in sec we compare transitions by look ing at their for state relations rb rf qa × qb let rf p r p r p r since pruning does not have to respect the language we can use much weaker ie relations for comparing let bw be the variant of bw where accepting states are not taken into consideration theorem f is good for a proof let p f one direction is trivial for the other direction by assume b p b but a b there exists a w la st w lb there exists an initial fair trace q q · · · on w in a there are two cases does not contain any transition qi i qi that is not present in b p then is also an initial fair trace on w in b p and thus we obtain w b p and w lb contradiction contains a transition qi i qi that is not present in b p therefore there exists a transition qi i qi in b st qi bw qi and qi f qi thus there exists an initial fair trace on w in b and thus w lb contradiction we can approximate bw with the transitive closure of a corresponding simulation which is defined as except that only initial states are considered ie the condition is c bw i · pi i qi i let be the transitive closure of since is downward closed and · is monotone we get this corollary corollary p is good for a simplify b let a × b be the synchronized product of a and b the idea is to remove states in b which cannot be reached in a let r be the set of states in a × b reachable from ia × ib and let x qb be the projection of r to the we obtain b from b by removing all states x and their associated transitions although b b this operation is clearly fair simulation as a better relation we further generalize the preorder by allowing even more freedom the idea is to allow to take jumps during the simulation game in the spirit of for a preorder on q in the game for simulation is allowed to jump to larger states before taking a transition thus a move is of the form qi qi i qi qi i · · · im and she eventually builds an infinite trace we say that this trace is accepting at step i iff qi f qi qi qi and fair iff it is accepting infinitely often as usual fair simulation holds iff the corresponding game with the fair winning condition lifted to traces not all induce simulations the preorder is called if for every word w there exists a initial fair trace on w iff there exists an initial fair one thus allows to convert traces into ones consequently for a preorder fair simulation is one can prove that bw is while bw is not we even improve bw to a slightly more general relation by only requiring that at least as many accepting states as does but not necessarily at the same time formally pm qm iff for every initial p p · · · m pm there exists an initial q q · · · m qm st i pi f i qi f theorem the preorder is proof since is reflexive the existence of an initial fair trace on w directly implies the existence of a initial fair trace on w now we show the reverse implication given two initial traces on w p p p p · · · and q q q q · · · we define c jc iff i j pi f pi pi pi i j qi f qi qi qi we say that an initial trace on w is iff it does not jump within the first i steps we show by induction on i the following property p for every i and every infinite initial trace p p p p · · · on w there exists an initial trace i q q · · · i qi · · · on w st i and the of the traces are identical ie qi pi and i ii for the case base i we take now we consider the induction step by induction hypothesis we get an initial trace i st i and qi pi and i ii if i is i good then we can take i i otherwise i contains a step qi qi i qi first we consider the case where there exists a qi f can count st qi as accepting qi in te that the ith f even if qi step in i and qi are not accepting by def of there exists an initial trace on a prefix of w that ends in qi and accepting states at least as often as the prefix of i that ends in qi again by definition of there exists an initial trace on a prefix of w that ends in qi and accepting states at least as often as thus accepting states at least as often as the prefix of i that ends in qi by the definition of c c by composing the traces we get i qi i thus i is an i good initial trace on w and i ii ii and i and i the other case where there is no qi f st qi qi qi is similar but simpler let be an initial fair trace on w by property p and lemma there exists an infinite initial fair trace on w thus is as a direct consequence fair simulation is since is difficult to compute we approximate it by a corresponding which in the same spirit counts and compares the number of to accepting states in every round of the backward simulation game let be the transitive closure of corollary fair sim is advanced inclusion checking algorithm given these techniques we propose the following algorithm for inclusion checking a b use the procedure to minimize a and b and ad apply the minimization techniques from sec lookahead simulations are computed not only on a and b but also between them ie on their disjoint union since they are we check whether they already witness inclusion since many simulations are computed between versions of a and b this witnesses sion much more often than checking fair simulation between the original versions this step either stops showing inclusion or produces smaller automata a b check the fair simulation from sec between a and b and stop if the answer is yes if inclusion was not established in steps or then try to find a counterexample to inclusion this is best done by a method using subsumption techniques eg use a small timeout value since in most instances there exists a very short counterexample stop if a counterexample is found if steps failed in practice use any complete method eg or con to check a b at least it will benefit from working on the smaller instance a b produced by step note that steps take polynomial time while step takes exponential time for the latter we the improved ramsey method of and the variant of construction implemented in goal this algorithm allows to solve much larger instances of the inclusion problem than previous methods ­ ie automata with states instead of states cf section experiments we test the effectiveness of minimization on random automata on automata derived from ltl formulae and on automata derived from mutual exclusion protocols and compare it to the best previously available techniques implemented in goal a scalability test shows that has quadratic complexity and it is more efficient than goal furthermore we test our methods for language inclusion on large instances and compare their performance to previous techniques due to space limitations we only give a summary of the results but all details and the tools are available unless otherwise stated the experiments were run with java on intel x and gb memory random automata the model generates random automata according to the following parameters the number of states n the size of the alphabet the transition density td number of transitions relative to n and and the acceptance density ad percentage of accepting states apart from this they do not have any special structure and thus minimization and language inclusion problem are harder for them than for automata from other sources see below random automata provide general test cases on average moreover they are the only test cases that are guaranteed to be towards any particular method thus it is a particular sign of quality if a method performs well even on these hard cases the inherent difficulty of the minimization problem and thus also the effectiveness of minimization methods depends strongly on the class of random automata ie on the parameters listed above thus one needs to compare the methods over the whole range not just for one example variations in ad do not affect much but very small values make minimization harder for the other methods by far the most important parameter is td the following figure shows typical results we take n ad and the range of td for each td we created random automata them with different methods and the resulting average number of states after minimization each curve represents a different method rd just remove dead states light light heavy and heavy and goal the goal curve shows the best effort of all previous techniques as implemented in goal which include rd with backward and forward simulation pruning of little transitions and the fair simulation minimization of which subsumes with delayed simulation bb ab cd b ef e b b ef b b b b b b a a ff f sparse automata with low td have more dead states for td no technique except rd has any significant effect goal just slightly worse than heavy but it is no match for our best techniques heavy all others particularly in the interesting range between and moreover the minimization of goal in particular the fair simulation minimization of is very slow for goal the average minimization time per automaton between s at td and s maximal at td in contrast for heavy the average minimization time per automaton between s at td and s max at td so heavy not only much better but also at least times faster than goal see also the scalability test for td heavy yields very small automata many of these are even universal ie with just one state and a universal loop however this is not due to trivial reasons otherwise simpler techniques like light and goal would also recognize this consider the following question given random automata with parameters n and td what is the probability un td that every state has at least one outgoing transition for every symbol in such an automaton would be trivially universal if ad theorem un td n t n t with t n · td n t mn t n n i min n and n t n t proof for each symbol in there are t n · td transitions and n possible places for transitions described as a grid n t is the number of ways t items can be placed onto an n × n grid st every row contains item ie every state has an outgoing transition n t is the number of possibilities without this restriction which is trivially n t since the model chooses transitions for different symbols independently we have un td n t n t it remains to compute n t for the ith row let xi n be the maximal column contain ing an item the remaining t n items can only be distributed to lower columns thus n t t n with m xi and a standard problem from the result follows for n we obtain the following values for un td for td · for td for td for td for td and for td so this transition saturation effect is in our tested range with td while heavy performs very well an even smaller lookahead can already be sufficient for a good minimization however this depends very much on the density td of the automata the following shows the effect of the lookahead by comparing for varying k on different classes of random automata with different density td we have n and ad and every point is the average of automata aa a a a a a a a a a a a cd the big advantage of heavy over light is due to the pruning techniques however these only reach their full potential at higher thus the smaller difference between heavy and light indeed the simulation relations get much with higher lookahead k we consider random automata with n and td a nontrivial case larger td yield larger simulations we let ad resp ad and the size of fair delayed direct and backward simulation as k increases from to every point is the average of automata ee ff aa aa aa aa a a aa aa aa aa a a f f ee ff simulation is not much larger than direct simulation for k but they benefit strongly from higher k backward simulation increases only slightly eg from to pairs for ad initially it seems as if simulation does not benefit from higher k if ad is small on random automata but this is wrong even random automata get less random during the minimization process making lookahead more effective for simulation consider the case of n td and ad initially the average ratio di di is but after with de this ratio is ltl for model checking are converted into bu¨chi automata this conversion has been extensively studied and there are many different algorithms which try to construct the smallest possible automaton for a given formula see references in it should be noted however that ltl is designed for human readability and does not cover the full class of regular languages moreover bu¨chi store contains automata for almost every and none of these automata has more than states still since many people are interested in ltl to automata conversion we tested how much our minimization algorithm can improve upon the best effort of previous techniques for ltl model checking the size of the automata is not the only criterion since more nondeterminism also makes the problem harder however our transition pruning techniques only make an automaton more deterministic using a function of goal we created random of nontrivial size length predicates and probability weights for boolean and for future operators we then converted these formulae to bu¨chi automata and them with goal of the different implemented in goal we chose which is also used by the model checker since it was the only one which could handle such large formulae the second best was which on of the instances but produced much larger automata than the other ran out of time h or memory gb on most instances we thus obtained automata and them with goal the resulting automata vary significantly in size from state to states then we tested how much further these automata could be reduced in size by our heavy method in summary of the automata could be further reduced in size the average number of states from to and the average number of transitions from to since larger automata have a effect on we also computed the average reduction ratio per automaton ie i note the difference between the average ratio and the ratio of the average ratio was for states and for transitions the computation times for minimization vary a lot due to different automata sizes average s but were always less than the time used by the ltl to automata translation if one only considers the automata above size states then the results are even stronger of these automata could be further reduced in size the average number of states from to and the average number of transitions from to the average reduction ratio was for states and for transitions to conclude our minimization can significantly improve the quality of ltl to automata translation with a overhead mutual exclusion protocols we consider automata derived from mutual exclusion protocols the protocols were described in a language of guarded commands and automatically translated into bu¨chi automata whose size is given in the column original by row the protocols are fischer fischer fischer and we minimize these automata with goal and with our heavy method and describe the sizes of the resulting automata and the runtime in subsequent columns java on intel i in some instances goal ran out of time h or memory gb original trans states goal tr st na na na na na na time goal h h s s s s s heavy tr st time heavy s s s s s s s s scalability we test the scalability of heavy minimization by applying it to random automata of increasing size but fixed td ad and we ran four separate tests with td and in each test we fixed ad and increased the number of states from n to n in increments of for each parameter point we created random automata and them with heavy we analyze the average size of the automata in of the original size n and how the average computation time increases with n for td the average size of the automata around of the original size regardless of n for td it around for td it decreases from at n to at n for td it decreases from at n to at n note that the lookahead of did not change with n surprisingly larger automata do not require larger lookahead for a good minimization we the average computation time measured in ms in n and then compute the optimal fit of the function time a nb to the data by the method ie this computes the parameters a and b of the function that most closely the experimental data the important parameter is the b for td we obtain n n n and n respectively thus the complexity of heavy almost this is especially surprising given that heavy does not only compute one simulation relation but potentially many simulations until the repeated minimization reaches a fixpoint quadratic complexity is the very best one can hope for in any method that explicitly compares by simulation relations since the relations themselves are of quadratic size lower complexity is only possible with pure partition refinement techniques eg bisimulation which is on log n but these achieve even less minimization than with direct simulation ie next to nothing on hard instances td fit td data td fit td data td fit td data td fit td data time in ms average time for heavy minimization for td with fit the computation time of depends on the class of automata ie on the density td as the scalability test above shows moreover it also depends on k the following graph shows the av computation time of on automata of size and varying td and k the most difficult cases are those where minimization is possible and thus the alg does not give up quickly but does not reduce the size of the instance for this is around td like in the scalability test language inclusion checking we test the language inclusion checking algorithm of section with lookahead upto on nontrivial instances and compare its performance to previous techniques like ordinary fair simulation checking and the best effort of goal which uses minimization followed by an variant of construction in this test we use only the polynomial time steps of our algorithm thus it may fail in some instances we consider pairs of random automata with states each and ad for each separate case of td and we create such automata pairs and check if language inclusion holds for td inclusion holds except trivially if one automaton has empty language for td inclusion often holds but is easier to prove for td our algorithm solved of instances ie included in step and in step step and failed average computation time s ordinary fair simulation solved only included instances goal timeout min gb memory solved only included instances the same as fair simulation and instances for td our algorithm solved of instances ie included in step and in step and step and failed average computation time s ordinary fair simulation solved only included instances goal timeout min gb memory solved only included instances the same as fair simulation and instances for td our algorithm solved every instance included shown in step and step average computation time s ordinary fair simulation solved only of the included instances goal timeout min gb memory solved only of included instances the same one as fair simulation and of instances conclusion and future work our automata minimization techniques perform significantly better than previous methods in particular they can be applied to solve automata problems like language inclusion for much larger instances while we presented our methods in the context of bu¨chi automata most of them trivially carry over to the simpler case of automata over finite words future work includes more efficient algorithms for computing lookahead simulations either along the lines of for normal simulation or by using symbolic representations of the relations moreover we are applying similar techniques to minimize references tool l and r advanced automata minimization tech rep u of edinburgh p yf chen l l cd r and t simulation subsumption in bu¨chi automata and inclusion testing in t b cook and p editors computer aided verification volume of lncs pages ­ isbn doi url p yf chen l l cd r and t advanced bu¨chi automata inclusion testing in jp and b editors international conference on concurrency theory volume of lncs pages ­ sept p a yf chen l and t for reduction on alternating bu¨chi automata in volume of pages ­ p a yf chen l r and t when simulation meets in tools and algorithms for the construction and analysis of systems volume of lncs url d and o minimization acm trans comput logic ­ april doi url l bu¨chi automata can have smaller in l m henzinger and j editors icalp volume of lncs pages ­ isbn doi url l generalized simulation relations with applications in automata theory phd thesis university of edinburgh d l a j hu and h checking for language inclusion using simulation in computer aided verification volume of lncs springerverlag doi url l and algorithms for finite automata in tools and algorithms for the construction and analysis of systems volume of lncs pages ­ springerverlag k a hierarchy of polynomialtime computable simulations for automata in international conference on concurrency theory volume of lncs pages ­ springerverlag doi url k and g optimizing bu¨chi automata in international conference on concurrency theory volume of lncs pages ­ springerverlag k t and r a fair relations parity games and state space tion for bu¨chi automata siam j comput ­ doi s url s and m bu¨chi and termination in s and a editors tools and algorithms for the construction and analysis of systems volume of lncs pages ­ doi url s and m y efficient bu¨chi checking in tools and algorithms for the construction and analysis of systems pages ­ s o m y and t unifying bu¨chi constructions in m editor computer science logic volume of pages ­ doi p and d fast ltl to bu¨chi automata translation in cav volume of lncs pages ­ springer s r and f fair simulation minimization in cav volume of lncs pages ­ springer m r henzinger t a henzinger and p w computing simulations on finite and infinite graphs in foundations of computer science dc usa ieee computer society isbn url t a henzinger o and s k rajamani fair simulation information and computation ­ doi url g the model checker addisonwesley t and b minimal nfa problems are hard in j b and m editors icalp volume of lncs pages ­ doi s and n generalized bu¨chi automata in computer aided verification volume of lncs pages ­ springerverlag doi url o and m verification of fair transition systems in computer aided verification volume of lncs pages ­ springerverlag url c s lee n d jones and a m the principle for program termination popl pages ­ doi j and g point the presburger arithmetic suite in proceedings of the th international conference on tools and algorithms for the construction and analysis of systems tacas volume of lncs springer i mathematics of choice the mathematical association of n from nondeterministic bu¨chi and automata to deterministic parity automata in lics pages ­ ieee r and s more deterministic vs smaller bu¨chi automata for efficient ltl model checking in correct hardware design and verification methods volume of lncs a p m y and p the problem for bu¨chi automata with applications to temporal logic theor comput sci ­ jan doi url f and r efficient bu¨chi automata from ltl formulae in computer aided verification volume of lncs pages ­ springerverlag doi url d and m model checking bu¨chi specifications in volume report research group on mathematical i yk yf chen wc chan and cj goal extended towards a research tool for automata and temporal logic in c and j editors tools and algorithms for the construction and analysis of systems volume of lncs pages ­ isbn url yk js and bu¨chi store an open of bu¨chi automata in p and k leino editors tools and algorithms for the construction and analysis of systems volume of lncs pages ­ isbn url 