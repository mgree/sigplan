modular reasoning about concurrent higherorder imperative programs birkedal department of computer science university categories and subject descriptors d programming languages formal definitions and theory ­ semantics d software engineering verification keywords contextual equivalence data abstraction program logics introduction modern programming languages permit a powerful combination of language features concurrency higherorder functions and mutable shared data structures these features are all very important for programming in practice however it is wellknown that the combination of them makes it difficult to write correct and secure programs and it is therefore important to develop techniques for formal reasoning about correctness and security of programs with these features to get scalable methods that apply to realistic programs it is crucial that the mathematical models and logics support modular reasoning meaning that specifications and proofs are compositional wrt the program structure and specifications and proofs can concentrate on the resources that a program actually acts upon instead of its entire state in this talk i will give an overview of some of the central developments that my group has on when generalizing reasoning techniques for simpler programming languages to concurrent higherorder imperative languages i will consider both relational models and program logics based on higherorder separation logic kripke logical relations one of the most fundamental notions in formal reasoning about programs is contextual refinement which expresses when one program fragment may be replaced by another one without changing the overall behaviour of a complete program this is the notion of correctness that one is interested in when eg reasoning about data abstraction or proving compiler optimizations correct it is difficult to reason directly about contextual refinement of programs and thus there has been a lot of work on extending the techniques of bisimulations and logical relations from simplytyped purely functional programming languages to programming languages with permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work must be for all other uses the popl january ­ san diego ca usa copyright is held by the acm recursive types polymorphism dynamically allocated mutable references and also concurrency for the work on logical relations the main challenges have been to develop mathematical techniques that are expressive enough to construct the interpretation of all the types ­ this is difficult when the programming language includes recursive types and general references which a definition of the relation by direct induction over the types to develop models that are sufficiently expressive for reasoning about uses of local state ie to define the logical relations in such a way that one can show that two programs that use local state in very different ways to implement the same functionality are indeed related and to develop logical relations for concurrent languages which allow one to reason about one thread at a time while still for the possible interference of other running threads to address these challenges we have developed new kinds of kripke logical relations using guarded recursion the resulting models have been used eg to prove correctness of a parallelization theorem which expresses when it is sound to evaluate two expressions in parallel instead of sequentially by giving a relational model for a system and to show correctness of finegrained concurrent data structures by showing that they are contextual refinements of their counterparts so that clients can reason about finegrained concurrent data structures as if all to them were higherorder separation logics instead of specifying a program by relating it to another program we can specify programs using program logics separation logic allows specifications and proofs to concentrate on the resources that a program actually acts upon instead of its entire state to allow specifications and proofs to be compositional wrt the program structure we developed higherorder separation logic to reason about higherorder imperative programs we introduced nested triples these features facilitate modular reasoning about sequential higherorder programs with limited forms of sharing to also for concurrency and sharing we make use of earlier work that extend relyguarantee versions of separation logic with protocols access to shared mutable state for modularity we use higherorder quantification over socalled impredicative protocols to show soundness of the logic we build a nontrivial model using guarded recursion the resulting logic can be used eg to give modular specifications of layered and recursive higherorder abstractions as used in and network applications for implementing asynchronous io 