correct blame for contracts no more university robert bruce findler university flanagan university of california matthias felleisen university abstract behavioral software contracts interface information with logical assertions a rigorous enforcement of contracts provides useful feedback to developers if it signals contract violations as soon as they occur and if it assigns blame to with precise correct blame assignment gets programmers started with the debugging process and can significantly decrease the time needed to discover and fix bugs the literature on contracts lacks a framework for making statements about the correctness of blame assignment and for such statements this paper the gap and uses the framework to demonstrate how one of the proposed semantics for higherorder contracts satisfies this criteria and another semantics assigns blame to the wrong module concretely the paper applies the framework to the lax enforcement of dependent higherorder contracts and the picky one a higherorder dependent contract specifies constraints for the domain and range of higherorder functions and also relates arguments and results in auxiliary assertions the picky semantics ensures that the use of arguments in the auxiliary assertion satisfies the domain contracts and the lax one does not while the picky semantics more contract violations than the lax one it the wrong module hence the paper also introduces a third semantics which the problems of the picky semantics without giving up its advantages categories and subject descriptors d formal definitions and theory semantics d language constructs and features constraints general terms languages design reliability keywords higherorder programming behavioral contracts blame assignment and felleisen were supported by fa and nsf findler by nsf and flanagan by nsf permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm dependent contracts lax or picky software behavioral software contracts for two reasons on one hand contracts help explain and protect the interface of components eg modules classes procedures functions on the other hand programmers can use the familiar programming language to specify contracts which makes it easy to read write and interpret them while both arguments obviously apply to contracts for firstorder languages findler and felleisen s introduction of contracts for higherorder functions raises subtle yet practically interesting questions one particular question concerns dependent higherorder is contracts that can state assertions relating the potentially higherorder argument to the potentially higherorder result such contracts come with two distinct semantics in the literature the first is the socalled lax semantics of findler and felleisen which uses the argument in the assertion without monitoring the argument contract in contrast the second picky semantics of and monitors the argument contract during the evaluation of the component and during the evaluation of the assertion for some natural number n and real d f real real real fp real real i n define x define f x f x abs fp x figure a higherorder dependent contract to make this discussion concrete consider the dependent function contract in figure this fragment known as plt scheme and plt specifies a function that maps a function f and a real number to a function fp the postcondition adds that for some number n of numbers x the of f at x is within of the value of fp at x a picky interpretation enforces that f and fp are applied to real numbers and produce such numbers during the evaluation of the postcondition a lax interpretation does not check these specifications et al compare these two forms of dependent contracts and relate contracts to flanagan s hybrid types they come to the conclusion that picky contracts signal the same violations as lax contracts and possibly more for example may actually produce a complex number and we use et al s terminology types o o num bool terms e v x e e e e e e e e e e if e e e values v xe tt ff e contexts e e e v e e e v e e e ve e e ve e e v e if e e e figure pcf syntax the contract may thus f the picky interpretation this potential problem while the lax one doesnt our experience shows however that et al s result doesnt the issue when a picky contract signals a contract violation it may blame the wrong party in this paper we develop a third notion of contract monitoring and demonstrate that it satisfies an intuitive correctness criterion we start from the observation that et al are correct in that a picky interpretation is important for dependent contracts if the dependency assertion violates a contract the computation may go wrong in all kinds of ways the question is which party the monitoring system should blame for such a problem the picky interpretation either the server or the client our new interpretation treats the contract as an independent party and it for problems where picky the wrong party to compare the three possible interpretations we develop a unified semantic framework based on a reduction semantics felleisen et al for a language with contracts the three interpretations are expressed as three different extensions that specify the semantics of dependent contracts we then the framework with the necessary information to track code ownership and contract obligations two novel technical notions that might prove useful in other contexts this framework is used to formalize the following correctness criterion a contract system should only blame a party if the party the flow or return of values into the particular contract check that failed we can prove that our new interpretation satisfies this criterion while picky fails to live up to it inspired by our theoretical result we with an dependent contract combinator i in addition with the existing lax combinator d finally we explain how to use the framework to implement a tool that explains the that contracts imposes specifically the tool out contract obligations from complicated contracts and them with we have implemented the tool and include some to illustrate its contract pcf pcf plotkin is the starting point for our model figure summarizes the wellknown syntactic domains in this setting a program is a closed term also we the language with a standard type system and a callbyvalue reduction semantics though for lack of space we omit the details plotkin felleisen et al similarly we use type annotations only when needed adding higherorder contracts adding plain higherorder contracts findler and felleisen to pcf is straightforward see figure first pcf is with contracts a contract type and new terms for contracts to terms and raising contract violations second we extend our type system with rules for the extra terms the resulting language is pcf with contracts is equipped with two kinds of contracts flat contracts and higherorder contracts the former are predicates on base values the latter combine a contract on the arguments of a function with a contract on the result of the function contracts types terms con e e e o bool con con con con e e figure syntax and types the most important new construct is the monitoring construct e which places a contract between a term e the server and its context the client it demands that any value that flows between e and its context is for with the contract for a flat contract the predicate is applied to the value for a higherorder contract the pieces of the contract are attached to the argument and range position of a wrapper function and the contract is as the function flows through the program a monitor comes with three labels a pair of distinct blame labels k and l for the two to the contract and a contract label j for the origin of the contract in source code the contract label j usually differs from k and l but under some it may be equal to either of the two labels are drawn from the enumerable set l the label lo is used as the label of the whole program denotes a subset of l when a contract fails a contract error is raised where l denotes the party responsible for the violation e contexts e e e v e v x e v e if e v v e figure semantics the introduction of contracts requires small changes to the reduction semantics figure out the details starting with the slight modification of the set of evaluation contexts the bottom half shows the reduction rules for contract checking and blame assignment adapted from findler and felleisen s original semantics a higherorder monitor is split into two parts a monitor for the argument with blame labels a monitor for the result with the original blame labels in an implementation these labels are synthesized from the program text a firstorder monitor is transformed to an if statement that checks whether the guarded value satisfies the contracts predicate if the predicate is satisfied the value is returned otherwise a contract error is using the first blame label to the party finally when a contract error is raised the evaluation is aborted and the contract error is returned as the final result adding dependent contracts in contrast to conventional contracts for firstorder functions the higherorder contracts of the preceding section cannot express dependencies between arguments and results therefore findler and felleisen with a functional contract form that the result contract over the argument contracts d x findler and felleisen s reduction rule for these dependent contracts captures this intention e d x v l lax e v x a dependent monitor acts like a higherorder monitor the subtle difference is that the parameter x of the function captures the free occurrences of x in the contracts postcondition as a result any argument to the function is substituted for x in and is then used in the argument position wrapped with an argument monitor and observe that the precondition is not enforced during the evaluation of postcondition this gap the for potential of the argument in ie uses that dont to they consider this a problem and in turn they propose the following change to the rule e d x v p picky e xx v x specifically every free occurrence of x in is replaced with x thus any argument to the function remains protected by even inside note how the injected monitor carries the same blame labels as the monitor for the argument in the body of the function et al compare the lax and picky contract sys and conclude that the former signals strictly fewer contract errors than a picky contract system more precisely for any pro gram the following statements hold · neither contract system signals a contract error · both raise an error and blame the same party or · the picky contract system a contract violation and the lax system does not raise a contract error their results characterizes two different of contract code on the one hand a lax contract system treats contracts as trusted code both have to the contract and have that its evaluation doesnt violate any invariants on the other hand a picky contract system considers contracts to contain potentially code to enforce the contracts within this code a picky system values that flow into the contracts the problem with the picky system is that it may blame the server or the client for violations of a contract when neither of in principle this reduction rule should use a let to preserve a strict callbyvalue but due to the restrictions on our grammar for contracts a straight substitution is technically correct and an alternative definition for the picky rule is to not switch the blame labels on the internal monitor doing so does not affect our results them can control the flow of values into the responsible monitor to illustrate this point and to provide an alternative we introduce a third contract monitoring system that considers contracts as entities when a dependent contract a value ing to this revised system the contract for the violation here is the reduction rule e d x v i e j xx v x the rule makes the contract responsible if it an value to a function argument during the evaluation of the dependency it this switch of with the creation of a new monitoring expression for the argument with the contract label as the negative blame label this new argument expression is substituted into the range part of the contract for an example consider this monitor expression where x x d f f x p p d here the server is the function x while the client is the context x the contract is a higherorder dependent contract where p checks for positive numbers ie p and has the standard recursive definition the argument x flows to the postcondition of and replaces f to protect it from potentially contract code it is wrapped with a monitor that enforces j x since is a dependent contract too the continues when the postcondition is eventually checked this function for x is applied to x in that case the latter flows to the postcondition of and replaces g with another domain contract each of the three rules gives rise to a semantics for in principal we extend with m where m l p i to get the three complete reduction relations since there is no of ambiguity we the symbol m and use it for the complete semantics two more the treatment of contracts as independent is compatible with some practical uses in our implementation first contracts for unit system are given as part of the signature and felleisen show that linking such units may the signature itself our framework finally provides a semantic explanation for this second in firstorder module system contracts are specified via ie in the export interface of modules this form combines identifiers with contracts and contracts to these values as they flow across the module boundary when things go wrong with the dependencies in such the monitor should not apply when the client is already labeled with the contract label in that case the value flow is entirely within the contract party and should strictly speaking not be to model this behavior we would have to add the side condition l j and add a second rule e d x v i e v x if l j both variants of satisfy the main theorem which is why this paper focuses on the simpler approach contracts the monitoring system considers the contract a part of the server module and the server module we can express this our framework with the small change of using the module name as the contract label finally typed and felleisen the interaction of typed and untyped modules with contracts derived from types since one of the basic assumptions of typed is that untyped modules unchanged it implements this protection mechanism with this contract form guarantees that values from an untyped module satisfy the specified contract put differently the form the import boundary if a programmer attached dependencies to these contracts the code would have to be considered as a part of the client module we can capture this semantics by using the modules name as the contract label comparing contract systems equipped with three additional contract monitoring systems we can now explore their relationship consider this example f f xx where p p d f f the example uses the for the contract label so that we can include and two additional of in our comparisons as needed we replace with k for with l for and a distinct label j for recall that the reduction rules for the lax and picky contract monitoring systems do not employ the contract label the evaluation of yields the following results for the five different contract monitoring systems program monitoring system result lax picky j error j k l the table demonstrates several points first when a program yields a plain value according to the lax system the picky system may still find a fault during contract checking and signal a violation second the picky system here party k the server component for a contract violation the specific violation is that f is applied to in the dependency assertion even though the domain contract that the function is only applied to positive numbers third the system the contract itself rather than the server fourth the system based on the rule with the picky system because it considers all code in a contract as part of the server finally the system party l after all the of f is internal to the client which chooses to the restrictions on the domain of f another example shows that picky can also blame the client when things go wrong with the contract f f xx gg where p p d f f p specifically evaluating yields the following results program monitoring system result lax picky j error j k l again the lax system does not signal contract violations while the other four report one here the system the contract itself rather than the client which is by the picky and systems the system the server together the two examples demonstrate that none of our new monitoring rules are logically related to picky if we take blame into account in short the introduction of contracts as independent calls for a comparison that takes into account why a contract violation is detected and why the party is note however that the contract system signals an error when the picky system signals an error and vice versa though the errors necessarily labeled with the same party proposition e i iff e p proof idea by a straightforward bisimulation argument the bisimulation used for the proof relates two expressions that are structurally identical except that their labels can differ tracking ownership and obligations while the preceding section the problems of the picky contract system and the difficulty of comparing contract systems in general it also implies a new way of about contract violations the first major insight is that the picky system may blame either the server module or the client module when in fact the contract itself is from here it is obvious to what a contract monitoring system would do if contracts were a part of the server a part of the client or a third party doing so produces the second major insight namely that none of these alternatives with the picky semantics putting the two insights together implies that we need a semantics that for each party keeps track of its contract obligations and for each value accounts for its origin once a semantics provides this additional information we can check whether a contract system ever a party for an obligation if the party has no control over the values flow into the contract in this section we semantics with ownership and obligation information which is maintained across reductions in the next section we use this information to state a contract correctness property and to measure how the various monitoring systems with respect to this property ownership to model an ownership relationship between and code we extend with a new construct that relates terms and values to terms e e l values v v l during reductions terms and values come with a stack of owners transfers from one party to another the notations e ln and e ln are for such stacks e l ln and e ln l respectively ownership l for an expression means its result is attributed to l in turn a value with an ownership l from component l or is affected by a traversal through component l and obligations contracts consist of trees with flat contracts at the exploiting the analogy with function types findler and felleisen implicitly decompose these trees into obligations for servers the of ownership comes from the work of et al on principals for a comparison see section positive positions and clients negative positions their semantics tracks this connection via labels errors use them to contract and felleisen use this idea for a static decomposition of contracts into server and client obligations they define two functions from contracts to contracts that out the respective obligations the one for out server obligations replaces flat contracts in negative positions with and then the overall contract analogously the decomposition map for out client obligations replaces flat contracts in positive positions with for instance the contract of the example in section yields these server client p p d f f p p d f p p d f f decomposition implies that each flat contract imposes obligations on a specific component ie party to a contract since one and the same server may connect with many different clients and since systems may use the contract itself as a component it is not just one party that is associated with a flat contract but many hence we modify the syntax of contracts to statically associate flat contracts and owners contracts flat e l d x in contrast with ownership obligations come as sets of labels not vectors after all there is no need to order obligations or to change them during an evaluation of course a static attribute about a dynamic obligation calls for a way to determine whether such annotations are wellformed wellformed ownership and obligations only some annotations make sense for a source program both ownership and contract monitors specify boundaries and at the source level these boundaries should coincide we therefore introduce a wellformedness judgment to enforce these conditions for source programs before doing so we present the simple typing rules for the two new constructs e o bool e e l concerning ownership annotations a source program may contain those at only two places in contract monitors and in flat contracts since contract monitors establish a boundary between the client component and the server component we demand an ownership annotation on the server component and that a match of these annotation with the positive label of the monitor conversely the context of such an expression must belong to the client finally flat contracts must come with ownership labels consistent with the surrounding monitors because they are turned into plain code during the evaluation and the semantics must track where they from we express this constraint with the wellformedness relation l e which says that l e and checks that e is wellformed equivalently l is the owner for the context of e a closed expression e is a wellformed program if lo e where lo is the label for the owner of the program figure defines most of this wellformedness judgment for terms that do not involve monitors and contracts the definition is a structural judgment and base values and variables are wellformed under any owner the actual key is the one for contract monitor which we present separately according to our informal description a wellformed contract monitor is a boundary between le l e l e l e e le l xe le l l e l e l e l if e e e l e l l e l e l e e l e l e l e e l e l e l e e l e l e l e e l n l tt l ff l x figure ownership coincides with contract monitors a client and a server this shape for the judgment l e k it says that if l the context and k is the blame label for the server then the blame label for the client should be l and the wrapped expression e should come with an ownership annotation that it to k next e must be wellformed with respect to its owner k because it may contain additional contract monitors but even with this antecedent the wellformedness judgment is incomplete after all the contract that the flow of values between the server and the client contains code and this code must be furthermore we must ensure that all flat contracts within are obligations of the appropriate including the contract monitor itself which is represented by the contract label j putting everything together we get this wellformedness rule for contract monitors in source programs k e k l j l e k it relies on a wellformedness judgment for contracts to which we turn next j j j j j j j d x j flat e j figure obligations coincide with labels on monitors roughly speaking j says that contract is wellformed for sets of positive and negative obligation labels and respectively and the owner j of the contract monitor that the contract to a boundary as the definition in figure shows the two sets are for the of higherorder dependent contracts for the negative positions in the precondition of dependent contract label j is added to indicate that these are also obligations of the owner of the contract monitor for flat contracts the positive obligation labels must coincide with the obligation labels of the contract note that the wellformedness of flat contracts also enforces an ownership annotation specifically the owner of the context which by assumption is a contract monitoring construct labeled with also the owner of the predicate in the flat contract the antecedent of the rule recursively uses the wellformedness judgments for ownership to ensure that e itself is wellformed ownership and obligations semantics the final change to the model concerns the reduction semantics specifically we change the reduction relations so that each reduction step keeps track of ownership and obligations while ownership and obligations do not affect the semantics per se the information is critical for characterizing the behavior of contract monitoring systems as we show in the next section our first step is to the grammar of evaluation contexts with a parameter that accounts for the owner of the hole in the parameterized grammar el of figure the parameter l points to the ownership annotations that is to the hole of the context e contexts el gl gl gl e v gl gl e v gl gl e v gl gl e v gl gl e v gl if gl e e gl f l gl l f f e v f f e v f fe vf fe vf f e v f if f e e f figure parameterized evaluation contexts evaluation contexts are labeled with the label label for the whole they do not contain an ownership constructs on the path from the hole to the root f from now on all reduction relations assume labeled evaluation contexts this implies that newly created values are always assigned an owner for the reduction relations concerning primitive operators and conditionals the changes are straightforward and summarized in the top part of figure for the rules concerning monitors with flat and plain higherorder contracts and their blame assignments specified in the lower part of the same figure we also know that they do not need to manipulate any ownership annotations these reduction rules remain unchanged modulo the labeled evaluation contexts the obligation annotation on flat contracts is ignored for details see the bottom part of figure we add one last simple rule separately m since the act of errors the surrounding evaluation context the format of this rule doesnt fit the table note that the context on the right is lo and l may not equal lo the reduction of v redexes typically demands several with respect to ownership to start with the function and the argument may belong to different furthermore the context together the operand and operator and the semantics should keep track of this together the two observations suggest the following relation el xe ln v m el v xe ln · · n k n l n k n l zero l zero n k v k v l v k v l if tt l ee if ff l ee v v m · · · · · · · · · · · n where n n n n where n n n tt ff if n v where v v v v where v v v e e v x if e v v figure ownership and obligation propagation the relation says that after tagging the value with the ownership label l of the context the value moves under the ownership annotations of the function the result is a value whose innermost owner is l and whose outermost owner is l of ln v the properly annotated value is then substituted into the body e of the function for its parameter x the result itself is owned by the same owner as the function put differently it is best to view function application as a form of communication between two components the function and its context the context the argument declares itself its owner and then passes it to the function the function accepts the argument its ownership and the result into its body recursion is treated as a special form of function application m el the owner of the context l and user of the recursive function declares itself owner of before substituting it in the body of the recursive function all the complexity of tracking ownership is due to dependent function contracts consider the simplest variant lax e d x v l lax e yx v y for this version of the reduction rule uses y as the parameter of the function on the right hand side the use of y as parameter demands that we also replace all occurrences of x in with y so that when the function is applied the actual argument is substituted into the dependent range contract without the substitution the reduction would create free variables rewriting the lax rule in this way reveals that it encodes a masked function application the problem is that as discussed above a function application must add the label of the responsible owner at the bottom of the stack and this label is not available here instead it is found at the flat of the contract which according to the static semantics of the preceding subsection must come with an ownership annotation the solution is to introduce the substitution function which copies the ownership label from flat contracts to the substituted term the value v is by this change of parameters because we assume the usual hygiene condition barendregt for metavariables with this substitution function in place it is easy to specify the three variants for the reduction of dependent functional contracts · · · · d x v l v x d x v p v x d x v c j v x lax picky we conclude this section with the definition of the auxiliary substitution function flat e l flat e l x e l d x d x d y d where x y the definition is total the of the contract syntax enforces that flat contracts always have the annotations expected by the domain of the substitution function this also guarantees that the reduction relations m are welldefined correct blame using ownership and obligation annotations we can formulate what it means for a contract system to correctly blame a after all the tracking of ownership and obligations is entirely independent of the contract checking and it is thus appropriate to use tracking as an independent specification of contract monitoring values should be from one of the of the contract are checked only against flat pieces of the contract for which the party is responsible now we can phrase this property in terms of ownership and obligations when the evaluation reaches a redex that checks a flat contract on a value then the owner of the value must be the same as the positive party of the monitor and in addition the positive party is included in the obligations of the contract definition blame correctness a contract system m is blame correct if for all terms e such that lo e and e m v v v k and k the identity of the labels is irrelevant the definition says that when the reduction of a wellformed program reaches a state in which it checks a flat contract then the server positive label of the monitor and the ownership label on the value must coincide and furthermore the set of obligations for the flat contract must contain this label conversely if these obligations are not met the monitor may blame k for a contract failure even though the party had no control over the flow of v into this monitor we can prove that the contract system and even the lax system are blame correct while picky the proof of the positive theorem directly follows from a subject reduction theorem for ownership annotations this latter theorem requires a complex proof which is the subject of the second subsection the third subsection explains how to prove the two main theorems to start with however we that ownership annotations and obligations do are orthogonal to semantics it is all about information propagation the addition of ownership and obligation annotations does not affect the behavior of any programs our revised semantics simply propagates this information so that it can be used to characterize execution states in order to formulate this statement we use the symbol for the reduction relations of section and for the relations of section proposition the following statements hold for m l p c let e be a wellformed program lo e let be the plain expression that is like e without annotations if e e then f let be a plain program there exists some labeled program e such that lo e furthermore if then e e proof idea by a straightforward bisimulation argument one consequence of this proposition is that picky and still the same number of contract violations proposition subject reduction while l e specifies when source programs are wellformed the reduction semantics creates many expressions that do not satisfy these narrow constraints for example a wellformed program contains only monitor terms of the form e k a reduction sequence may contain programs with differently monitors however in particular due to the reductions of higherorder de contracts the expressions may be applications e k er or variables x fortunately such are only temporary in the case of the application the ar er is always wellformed under l and when it is by e k the monitor expression is once again wellformed in the case of the free variable we can show that x is always replaced with a value of the form v k which to the standard form to formulate a subject reduction theorem we must generalize both the judgment for wellformed programs l e and the one for wellformed contracts j first we the two relations with an environment that records the label of bound variables l x l e l x e l xe l with environments it becomes possible to check variable occurrences in monitor terms second we add a rule for checking expressions that already have an owner k e l e k while these terms show up only within monitors in source programs they flow into many positions during evaluations using this new rule we can check these cases too all other those concerning the environment and otherwise check expressions in the same way as the corresponding rules of the preceding section the rule for variables ignores the environment variables not in monitor terms can be replaced with wellformed terms of any owner for details see figure the purpose of the environment is to check expressions without ownership annotations in monitor terms here is the key rule k e k l j l e to check whether the wrapped expression is wellformed it to the auxiliary relation k e the contract is checked as before though with an environment with k e we can check the ordinary ownership terms but also applications and variables as introduced during reductions for j e j e j e j e e j e j j j e j e j e j if e e e j e j e j e e j e j e j e e j e j e j e e j e j e j e e j n j tt j ff j x j j j j j j j j d x j e j flat e j figure obligations coincide with labels on monitors function applications the label serves as ownership label for the operator and the operand similar to the standard application rule k e k e k e k e for free variables the environment serves as the source of the ownership label x k k x after all the variable in this position is going to be replaced by a value via a function application and the substitution is going to use a value with the specified label finally for a guarded term with an ownership annotation it suffices to check if it is wellformed with respect to the specified owner k e k e k a wellformed program in the sense of the preceding section is a wellformed program in the sense of revised judgment too proposition for all e and l l e implies l e proof idea by straightforward induction on the height of the derivation l e a program that is wellformed according to l e reduces to wellformed programs this statement holds for a contract system using the lax reduction rule as well as for or those using theorem let e be a program such that lo if e l e then lo e if e i e then lo e e then proof we proceed by case analysis on the reduction of e · el n k n l by assumption lo e for which lemma implies that l n k n l we can use the same label to check n via the inference rules ie l n hence lo · the cases for other primitive operations are similar to the first · l el by assumption and lemma l from lemma we get that l and in turn lo el · el xe k v l el v l k xe k again by tion and lemma we conclude that l xe k v and therefore l xe k and l v next we distinguish two cases depending on the length of k first assume the vector is empty in that case the inference rules imply l x l e combining this judgment with l v we may conclude that l v via lemma finally from here it is easy to get lo el v the desired conclusion second let k be the first element of k in that case the inference rules imply k x k e since l v still holds we conclude again via lemma that k v l k xe since k is the outermost element of k we finally get the desired sion lo el v l k xe k · v l el if ec v v the assumptions imply l v via lemma and hence ec ec j with j ec furthermore the same reasoning yields v v k and k v since the rules for wellformed expressions imply l if ec v v is wellformed the desired conclusion follows immediately · el v l el v x with the usual reasoning we get l v v v k and k v the contract check yields two pieces of knowledge l k j and k l j from an additional application of the inference rules for wellformedness we get k x l v x and with the help of lemma l x l v x finally from a last application of the inference rules for wellformedness we get l v x · finally let e d x v and observe that e l el v x via lemma we derive l d x v thus v v k with k v but also l k j j and k l j the rest of this argument uses the same strategy as the preceding case except that we use lemmas and to derive the key result l x l v x the proof of part differs from the proof of part only in the case for monitors with dependent contracts therefore let e d x v and recall that the contraction proceeds as follows e i el j v x once again we derive l d x v via lemmas hence v v k with k v but also l k j j and k l j by the wellformedness k x l v x now with the help of lemmas and we can derive l x l j v x thus we conclude the proof with another application of the inference rules for wellformedness the proofs of the central lemmas depend on a series of auxiliary lemmas about the properties of wellformed terms and contracts substitution and contract substitution lemma if l then k e proof idea by induction on the size of ek lemma if l e k e and x dom l e proof idea by induction on the height of l e lemma if l x k e v v k and k v then l proof idea by induction on the height of l x k e note that l x k x is a base case lemma if l e and x dom then l x k e proof idea by induction on the height of l e lemma if j and x dom then j x l proof idea by induction on the height of l for the flat contracts case we employ lemma lemma if l e and x dom l x k x proof idea first we generalize the lemmas statement if l e and x dom l x k x then we proceed by induction on the height of l e lemma if j and k x l x with x dom then j x k proof idea by induction on the height of j for the flat contracts case we employ lemma lemma if l e l x k x x dom then l x k x proof idea first we generalize the lemmas statement as follows if l e l x k x x dom then l x k x we proceed by induction on the height of l e lemma if j and then j proof idea by induction on the height of j main theorems when a program is wellformed its monitors obviously satisfy the blame correctness criterion theorem l and i are blame correct proof this theorem is a straightforward consequence of theorem to wit the subject reduction theorem says that a program satisfies the subject including when its redex is a monitor term containing a flat contract from the proof of the subject reduction theorem we know that the subject implies l v k the label on the context is the same as the client label by lemma but we also need to know that the server label l is a member of the contracts obligations this has to be the case given that the monitor term is wellformed note how the proof is independent of the reduction semantics as long as it satisfies the subject reduction property the picky contract system fails to satisfy an analogous theorem theorem there exists a program e such that lo e and e p el v l but k l proof here is one such program where k lo l l hh x gg k f hh x the restriction on the labels intuitively corresponds to the composition of the two different modules k and lo through the contract l note that l is a family of programs one per label l this label is the label of the contract monitor and consequently must be the owner of all embedded flat contracts in principle l could be the label of the client the server or any other lo label but in the end our choice must subject reduction while l performs no interesting computation its contract l plays a critical role to explain the contract though it is best to start with the type of h num num num num num num num the type tells us that h a complex higherorder function and produces a number instead of plain numbers however we wish to deal with positive numbers only we thus know that l must have at least something like the following shape pl pl pl pl pl pl pl next we add two dependencies pl pl d f pl pl d pl pl the two key points to notice are in this contract g is in the scope of f and while f in the server wrapped expression g in the client context and both flow into the contract equipped with this informal and approximate understanding we can now turn to the actual contract l pl lo pl k d f l pl k l pl k pl lo d gl pl k l flat f g l k pl flat xx l note how l invokes f on a positive number and g on now we show that l must be set to lo in order to satisfy blame correctness first note that for for all l l lo l if k lo second the reduction of l eventually checks that is greater than ie that the postcondition contract l is satisfied l p el pl lo l l in order for the picky system to satisfy the blame correctness condition l must be equal to lo which means the term looks like this lo lo lo unfortunately the next few steps of the reduction process produces a state that is inconsistent with blame correctness specifically l also checks that gs precondition holds for lo lo lo p lo lo lo this last state however is inconsistent with the subject because k cannot equal lo indeed the next few reduction steps result in a failed check the contract monitor k which the owner lo of the value the picky system fails to assign blame properly in essence the proof of the theorem shows that there is no correct strategy for associating pieces of contracts with components in a picky semantics no matter which labeling strategy we use a contract violation may blame a component that has no control over the value our model introduces two concepts that are potentially useful for practical programmers obligations and ownership according to our judgments for wellformed contracts and expressions a obligation is a static property of contract text when with complex contracts a programmer may benefit from such information in the in contrast ownership information is a dynamically property and it is particularly useful in a debugger for determining the and current owner of values as they flow from one component to another to test the of obligation information we have implemented a tool that analyzes modules and contracts and them with obligation information the tool is a for findler et al our for the programming language in this section we refer to the tool as though in it is simply a part of the tool the tool operates on modules in two different modes in server mode analyzes the module from the perspective of the of services it all the contracts that are attached to exported identifiers and uses · red to tag the servers obligations · to the servers assumptions ie the parts of the contract that the other party is responsible for and · to signal that a part of the contract is both an assumption and an obligation in client mode analyzes the module from the perspective of a consumer of services once it has the results it proceeds as in server mode except that it uses red for the clients obligations and for the clients assumptions for a simple example consider the module in figure the module specification lists one exported function according to its contract the function a nonempty list of numbers and returns an number a code inspection shows that the function actually returns a random element of the given list figure obligations and assumptions for the top of figure shows the result of using the tool in client mode as expected the nonempty list part of the contract is colored in red because any user of is required to use a nonempty list of numbers as an argument also because the client may assume that is a function and not some arbitrary value the contract constructor with the reverse reasoning explains the coloring of the lower part of figure which shows the result of using in server mode for a second example consider a function with the contract from section its contract is significantly more complex than because it comes with two higherorder components and a postcondition note that this contract uses the i contract combinator the contract into a party with obligations and assumptions here the contract is the server module meaning i is interpreted using the semantics practically speaking the obligations and assumptions of the server also include the obligations and assumptions of the contract the top of figure shows the result of using the tool in client mode the color assignment roughly follows the same contravariant traversal of pattern as the contract in figure when it comes to the code however the color of the keyword indicates that the postcondition is an assumption for the client just like the other postcondition of the contract the lower the servers obligations and assumptions which are more interesting than the clients the difference is due to the servers dual role as both a service and as the owner of the contract recall that the contract is responsible for the preconditions of f and fp in the postcondition while the server may assume that f and fp meet their postconditions as a result the used for f from the servers perspective coincide with those used in the client mode for fp however both parts are colored because the obligation of the server is the contract assumption and vice versa since the server is both the server and the contract party in this case the user must be ready to treat the precondition and postcondition of fp either as an assumption or as an obligation depending on the use figure obligations and assumptions for related work provenance is the of origin context and history information of data it plays an important role for the correct and secure behavior of large software and hardware systems et al and the study of provenance from a formal perspective is still at an initial stage et al our notion of ownership is a means of keeping around some origin and context information about program values so it can be viewed as a form of provenance also ownership can be used as a basis for studying formal properties of this kind of provenance however our technique and its use to prove properties of contract systems is not related to any provenance tracking technology tracking information flow in a computer system is a specialized kind of provenance secure information flow as by is the restriction of flow of data in a computer system only between agents that have the appropriate level of there are both software and hardware techniques for secure information flow our instrumentation of the dynamic semantics techniques used for proving sound type systems that enforce secure information flow et al introduce program principals as a means to prove type abstraction properties related to information flow with a syntactic proof technique in a principal semantics different principals own different components and exported values carry the principal of their component of origin since the principals semantics prevents reductions that involve values with different principals a client component is to use a servers functions on the servers values in short the semantics dynamically enforces a form of information hiding it is now easy to see how a principals semantics supports a syntactic soundness proof for abstract types if the interface between the server component and the client abstract types and if the type system soundly enforces type abstraction stuck states become unreachable during computation although both principals and ownership annotations point to the source of values and functions the principal semantics differs substantially from our ownership semantics most importantly principals may change the evaluation of a program ownership does not when a function from one server is applied to a value from a client or a different server the principal semantics is stuck in contrast ownership annotations are simply propagated in our reduction rules they do not affect computation ownership information is instead used to formulate a criteria for determining the correctness of blame assignment we can imagine using an ownership semantics to formulate syntactic soundness proofs for type abstraction while we do not see any advantages over the principals semantics for this application as explained in the introduction et al study the full relationship between lax and picky contract systems on one hand and manifest contract systems on the other for the latter the type system propagates some of the contract constraints while and flanagan established a tight relationship for a world without dependent contracts et al demonstrate that the full picture is rather complex in particular they show that as far as contract violations are concerned manifest contracts strictly between lax contracts and picky contracts in general this work extends our investigation of behavioral software contracts meyer introduced software contracts via the design of the programming language and the creation of a software engineering since then contracts have been used both for extended static checking et al et al and runtime monitoring of higherorder programs findler and felleisen and introduce picky contract monitoring and explore a model for higherorder contracts and use it to prove properties of findler and higherorder contracts findler et al propose an alternative view namely contracts as projections which relates contracts to scott s denotation model of types and flanagan relate findler and higherorder contract to type casts their result a form of extended static checking et al which et al consider a manifest form of contract xu et al use and ideas to develop static contract checking for haskell using symbolic evaluation et al and et al both introduce contracts to haskell but end up with two different contract systems the first performs eager contract checking while the second is lazy et al compare eager and lazy contract checking for lazy languages through a series of formal properties but do not reach a definite conclusion finally in the context of et al et al develop a method for proving the wellformedness of specifications and they discuss how their technique can benefit from automated theorem proving the goal of this line of research is significantly different than ours it concerns extraction of proof obligations for the verification of contracts internal consistency unfortunately contracts capture only firstorder properties and it is if their technique is applicable in a higherorder world furthermore their static semantics lacks a formalization of the contract which plays an important role in our work conclusion this paper introduces a new semantics for dependent contracts in response to et al s comparison of two alternatives our work the motivation behind the picky con system and turns the lax system into a choice for the programmer like the picky system the new system arguments and results inside dependency assertions in contrast to the picky system each contract is treated as an independent party with its own obligations to meet most importantly we introduce a semantics that tracks value ownership and contract obligations and we formulate the first ever correctness criterion for blame assignment our major theorems show that the system guarantees that contract monitors blame only components that are in control while the picky system fails to satisfy this intuitive correctness property for blame assignment our results suggest several changes to the implementation of contracts in first even though the lax semantics is blame correct we now support the semantics for dependent contracts to ensure that only are second by instantiating the contract party we obtain of an semantics that support the entire variety of contracts in use contracts contracts and contracts for mllike modules where signatures have an independent the notion of wellformed obligations is the basis of a tool that can module programmers of their obligations and assumptions in complex higherorder contracts acknowledgments thanks to matthew for how to exploit macro system to implement we discussions with and we are to the anonymous reviewers of popl for their useful feedback references h p barendregt the lambda calculus ­ its syntax and semantics volume of studies in logic and the foundations of mathematics northholland m k r m leino and w the spec programming system an overview in construction and analysis of safe secure and smart devices pages ­ a jm n and d making components contract aware ieee computer ­ july m and d sound and complete models of contracts journal of functional programming ­ r and j for scientific data processing a survey acm computing survey ­ j s n foster m and s provenance a future history in of the th acm sigplan conference companion on object oriented programming systems languages and applications session oopsla pages ­ o d and c lazy assertions in revised papers of the th international workshop on implementation of functional languages pages ­ m p and s eager and delayed contract monitoring for callbyvalue and callbyname evaluation journal of logic and algebraic programming page to appear d e a lattice model of secure information flow communications of the acm ­ d l k r m leino g nelson and j b extended static checking technical report src research report c and m felleisen on contract satisfaction in a higherorder world acm transactions on programming languages and systems accepted with for publication m felleisen r b findler and m semantics engineering with plt redex mit press r b findler and m contracts as pairs of projections in proceedings of the th international symposium on functional and logic programming pages ­ r b findler and m felleisen contracts for higherorder functions in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ r b findler j c flanagan m s p and m felleisen a programming environment for scheme j program ­ mar r b findler m felleisen and m an investigation of contracts as projections technical report tr university of computer science department c flanagan hybrid type checking in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ m and plt reference technical report plt inc m b c pierce and s weirich contracts made manifest in proceedings of the th annual acm sigplansigact symposium on programming languages popl pages ­ j and c flanagan unifying hybrid types and contracts in proceedings of the th symposium on in functional programming pages ­ r j and a typed contracts for functional programming in in proceedings of the th international symposium on functional and logic programming pages ­ k a j s n and c flanagan unified hybrid checking for firstclass types general refinement types and dynamic url g t a l and c ruby a notation for detailed design in h b and i editors behavioral specifications of and systems pages ­ academic b meyer design by contract in advances in objectoriented software engineering pages ­ prentice hall b meyer the language prentice hall b meyer objectoriented software construction prentice hall g d plotkin callbyname callbyvalue and the calculus theoretical computer science ­ g d plotkin considered as a programming language theoretical computer science ­ a a and p checking wellformedness of specifications in proceedings of the th international symposium on formal methods fm pages ­ d s scott data types as lattices siam journal of computing ­ y l b and d a survey of data provenance in acm record ­ t s and m felleisen contracts for firstclass modules in proceedings of the th symposium on dynamic languages pages ­ acm s and m felleisen logical types for untyped languages in proceedings of the th acm sigplan conference on functional programming icfp pages ­ s and m felleisen the design and implementation of typed scheme in proceedings of the th annual acm sigplansigact symposium on the of programming languages popl pages ­ d xu s peyton jones and k static contract checking for haskell in proceedings of the th annual acm sigplansigact symposium on programming languages popl pages ­ s d and g morrisett principals in programming languages a syntactic proof technique in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ 