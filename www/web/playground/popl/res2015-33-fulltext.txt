representation of concurrent trace sets gupta thomas a henzinger university of pennsylvania popl consist complete well easy to abstract we present a method and a tool for generating representations of sets of concurrent traces we focus on trace sets that contain all correct or all incorrect permutations of events from a given trace we represent trace sets as that are boolean combinations of happensbefore constraints between events to generate a representation of incorrect interleavings our method iteratively interleavings that violate the specification and of the discovered interleavings into an its complement yields a representation of correct interleavings we claim that our trace set representations can verification fault repair and synthesis techniques for concurrent programs we demonstrate this by using our tool in three case studies involving synchronization synthesis bug summarization and abstraction refinement based verification in each case study our initial experimental results have been promising in the first case study we present an algorithm for inferring missing synchronization from an representing correct interleavings of a given trace the algorithm applies rules to rewrite specific patterns in the into locks barriers and constructs in the second case study we use an representing incorrect interleavings for bug summarization while the itself is a concise counterexample summary we present additional inference rules to help identify specific concurrency bugs such as data races order violations and access bugs in the final case study we present a novel predicate learning procedure that uses representing abstract counterexamples to counterexampleguided abstraction refinement cegar in each iteration of the cegar loop the procedure refines the abstraction to eliminate multiple spurious abstract counterexamples drawn from the categories and subject descriptors d formal methods keywords trace generalization concurrent programs synchronization synthesis bug summarization cegar permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm introduction sets of concurrent traces containing permutations of events from a given concurrent trace are useful for predictive analysis eg and synchronization synthesis eg of concurrent programs most approaches using such trace sets are restricted to specific aspects of reasoning about concurrent programs such as data race detection detection of safety violations and assertion failures moreover the representations of trace sets and exploration strategies used in some of these approaches the target trace sets in this paper we present a complete representation of such concurrent trace sets which can verification fault repair and synthesis techniques for concurrent programs the representation is complete in the sense that it encodes every trace in the trace set of interest concurrent trace sets first we fix some terminology an execution of a concurrent program p is an alternating sequence of variable valuations and events corresponding to a feasible interleaving of instructions from the threads of p an execution is good if it satisfies a given specification and bad otherwise a trace is a sequence of events corresponding to an interleaving of instructions from the threads of p the trace of an execution is the sequence of events within the language l of a trace is the set of all executions with trace a trace is feasible if l is nonempty and infeasible otherwise a feasible trace is good if all executions in l are good and bad otherwise we group traces into the n of a trace contains all permutations of that preserve s event order the good ng of a trace is the set containing all the good traces in n the bad nb of a trace is a set containing all the bad traces in n the languages ln and are the unions of the languages of all traces in n ng and nb respectively representation of concurrent trace sets there are multiple ways to represent trace sets some representations may be more expressive or useful for reasoning about concurrent programs than others a candidate representation that has been used for certain trace sets is a partial order over events the of a trace as defined above can also be represented as a partial order however the good or the bad of a trace is in general not a partial order for instance for the this research was supported in part by the european research under grant agreement by the science project sn rise and the nsf figure online this trace is drawn from a program consisting of three threads one for one for and one for checking consistency of the account after completion of a and a int x balance init x balance thread int temp tw temp balance tw balance temp tw thread int temp td temp balance td balance temp td thread tc assume and tc assert balance x exact representation of nb tc exact representation of ng tw td tc tc representation of sound overapproximation of nb td tw representation of sound overapproximation of ng tw td ain all the examples in this paper we represent traces using typed global variable followed by each threads typed local variable declarations and instructions note that this representation a trace and not a program trace in fig ng is not a partial order but is a disjunction ie union of partial orders in our work we represent trace sets as an is a boolean combination of happensbefore causality constraints between events can represent arbitrary finite sets of finite traces and in particular good and bad see fig as we will see later are not only expressive but also enough to be usable for objectives given a trace and a correctness specification we present a method to generate an b representing the bad of to generate b we first encode all the bad executions in ln in a quantifierfree firstorder formula such that an execution is a model of iff is a bad execution in we then incrementally construct b initially b is set to false in each step we invoke an smt solver to obtain a model for that does not belong to the language of the subset of nb represented by the current b generalize the trace of the model into an and update b by adding as a disjunct we iterate until there is no new model of the trace generalization used in each iteration has the following properties a the model obtained in the iteration satisfies and b any trace in n that satisfies is bad the final obtained is an exact representation of nb while an exact representation is a goal the corresponding b may not be to gain and utility we in in particular we permit the inclusion of infeasible traces to obtain a representing a sound overapproximation of nb the overapproximation of nb is sound in the sense that it is guaranteed to not include any good traces to generate such a we the above procedure we use dataflow analysis and minimal core core computation for generalizing the trace of the model into an in step of each iteration this new trace generalization step has the following properties a the model obtained in the iteration satisfies and b any trace in n satisfying is either bad or infeasible b the representation of a sound overapproximation of nb yields g a representation of a sound overapproximation of ng note that the exact representation of nb does not yield an exact representation of ng in fact our existing methodology cannot produce an exact representation of ng fig shows the exact representation of nb and the representations for sound of ng and nb obtained by our method for the example trace shown we implemented the above procedure as a tool and used it to generate representations of trace sets of programs drawn from the software verification and the of and we demonstrate the applicability of our representations of good and bad of a trace to three case studies involving synchronization synthesis bug summarization and verification based on counterexampleguided abstraction refinement cegar case study synchronization synthesis concurrent programs are targets for automated program completion in particular for synthesis of missing synchronization we present a novel algorithm that uses g to synthesize synchronization for eliminating the bad of the algorithm proceeds by applying rewrite rules to derive synchronization primitives such as mutex locks barriers shared exclusive locks and statements from patterns in g for example a missing mutex lock in the example in fig that ensures the instructions at tw and tw in thread do not interfere with the instructions td and td in thread is identified by the pattern tw td in g we emphasize that most other synchronization synthesis techniques generate atomic sections rather than locks statements etc atomic sections are not directly implementable moreover our synchronization primitives can potentially permit more correct concurrent behaviours than atomic sections we have implemented this algorithm as an extension of our tool and used it to successfully synthesize synchronization for our benchmarks case study bug summarization error detection tools based on model checking and static analyses typically provide counterexample traces to help with program debugging however these traces can be long and with unnecessary data providing little insight about the actual bug in our second case study we use b the representation for a sound overapproximation of a traces bad for counterexample and bug summarization the b encodes relevant ordering information about all counterexamples in the of and can be viewed as a counterexample summary while this can already be useful feedback for a human debugger we present a set of rules to infer specific bugs such as data races atomicity violations access bugs and order violations these rules work by identifying particular patterns in b and combining them with some lightweight dataflow information we have extended for bug summarization and evaluated it on our benchmarks case study cegar we also recognize an application of our representation of bad of abstract counterexamples in cegar for concurrent programs cegar often takes many iterations to find the right predicates for proving correctness of a program the choice of refinement procedure usually determines the number of iterations necessary many heuristics have been proposed to find relevant predicates quickly eg this problem is in concurrent program verification where the existence of a large number of interleavings can delay the discovery of interesting spurious counterexamples that lead to relevant predicates we present a new predicate learning procedure that uses the b representing the bad of a spurious counterexample of an abstract concurrent program in each iteration of the cegar loop our procedure refines the abstraction to eliminate multiple spurious abstract counterexamples drawn from b using a method similar to interpolants we have integrated our refinement procedure within and have been able to reduce the number of iterations needed to verify various example programs we introduce a novel representation for concurrent trace sets based on sec have several useful properties they can express arbitrary finite trace sets they enable efficient computation and concise expression of unions over trace sets this is exploited by our tool to compute representations of sound of good and bad of a trace are an intuitively representation for trace sets they can reveal specific patterns of causality relations between events that can verification fault repair and synthesis techniques for concurrent programs we demonstrate the use of our tool in three applications synchronization synthesis sec bug summarization sec and cegar acceleration sec trace and representations in this section we formalize concurrent executions traces and trace we also present algorithms and experimental results for computing good and bad the case studies in sections and are based on the techniques presented here concurrent programs and traces we consider concurrent programs composed of a fixed number of sequential threads in further discussion we fix a concurrent program p v t tk sv lv where t tk are a set of threads sv is a set of shared variables each is the set of local variables of thread ti and v sv i is the set of all variables let vi sv denote the set of variables that can be read from and written by thread ti as the main objects of study in this paper are traces we keep the simple by not specifying syntactic and control flow details of threads at this stage in this paper we assume that variables range over integers and program instructions perform standard linear arithmetic operations however our techniques apply to a much variety of variable domains and operations concurrent executions a concurrent execution e is an alternating sequence of valuations i of variables v and events ei corresponding to some interleaving of instructions from the threads in each i execution of ei from valuation i leads to valuation i each event e is a labelled statement of the form t stmt where t is a thread identifier is a location identifier and stmt is an atomic instruction we write for the thread identifier t without loss of generality we assume that the location identifiers of events from each thread are sequential natural numbers ie the first event from a thread gets location identifier the next gets and so on further we notation by often writing t instead of the event with label t we represent the sequence of events from thread t with location we assume that all location identifiers from one thread are unique thus multiple occurrences of the same instruction for example in the body of a loop are with unique identifiers identifiers between and by t we also use the symbol l to denote location identifier ranges such as we use two different to express atomic instructions · guarded actions here an instruction from thread ti is either a guarded action assign or an assertion where g is a boolean expression over vi and assign is a parallel assignment v vm expr of expressions over vi to variables in vi · transition predicates here an instruction from thread ti is a predicate over variables from vi vi where vi contains versions of variables in vi intuitively variables from vi and vi represent the values of program variables before and after the execution of the instruction respectively for example the assignment x x y is represented as x x y the advantage of this formalism is that it can express nondeterministic statements which we need to model abstract programs in sec assertions are represented as before ie as where g is a boolean expression over vi an execution e is good if for each assertion ei t the boolean expression g evaluates to true under valuation i the execution is bad otherwise concurrent traces a concurrent trace e en is a sequence of events that corresponds to some interleaving of instructions from threads in p the language l of a trace e en is the set of all executions e where ei ei for i n for a set of traces n we notation and write ln instead of n l we denote by events the set e en of events in for any two events ei ej events we say ei ej if ei occurs before ej in a trace is feasible if its language has at least one execution ie l and is infeasible otherwise a feasible trace is good if all executions in l are good and is bad otherwise representing trace we reason about traces that differ only in the scheduling choices using trace the n of a trace is a set of traces n events events ei ej events ei ej intuitively n contains all traces having the same events as and having the same order of events within each thread a trace in n may be infeasible good or bad we denote the subsets of good and bad traces in n by ng and nb respectively we call nb and ng the bad and good of note that n corresponds to a partial order events with ei ej iff ei ej and however ng and nb do not in general correspond to a partial order cf the exact representation of ng in fig representing subsets of trace we represent subsets of trace using happensbefore formulas or an for a trace is either a a basic constraint of the form ej where ei ej events or b a boolean combination of ie one of or ¬ where and are the semantics of an for a trace is subset of n defined as follows a for a basic constraint ej we have that ej n ei ej and b for boolean combinations we have that and ¬ n respectively remark our only represent constraints on scheduling one could define more expressive constraints which in constraints not just on scheduling but also on variable val in individual executions however our hypothesis is that happensbefore constraints on scheduling are sufficient to express many interesting properties of traces and executions this is also supported by empirical data that shows that most concurrency bugs are due to bad ordering of instructions in a trace rather than the interaction between schedules and variable valuations computing good and bad in this section we present an algorithm for computing an exact representation for the bad of a trace however as this representation may be and complex we further provide an algorithm to produce sound of nb and ng ie to find g and b such that ng g nb b and g nb b ng encoding bad executions given a trace our algorithm is based on constructing a quantifier free firstorder formula that represents all bad executions in ln we use the concurrent trace program encoding which is based on a concurrent single static assign ment form of traces we recall the encoding below to make the presentation we present the encoding for the case where instructions are expressed as guarded actions the case where instructions are expressed as transition predicates is similar given a trace we first rewrite it into the form · for each variable v we introduce a unique name for each event e that may change the value of v here w stands for write further for each variable v we introduce a unique name v to represent the value of v at the start of an execution · for each event e that reads a variable v we replace v as follows if v is a local variable we replace v by where e is the most recent event from the thread that writes to v and if v is a shared variable we replace v by where r stands for read and we store an additional constraint where v where ei ranges over all events from other threads that write to v and the most recent event from the same thread that writes to v the functions above are analogous to the functions used to express joins in sequential single static assignment encodings ie v expresses that e reads either the initial value of v or the value written by one of e e · further for each event e we define the condition that e is reached if e is the first event in a thread we set true otherwise depends on the previous event from the same thread in say e if e is an assertion we let otherwise e is a guarded action assign and we let g example in the running example from fig the statement tw temp balance would be encoded as balance given a trace rewritten in the form the following constraints encode executions in the n of · thread orders in any execution in the of the order of events in each thread is the same as in the trace we define po ej ei ej · variable assignments this part of the encoding is a di translation of the assignments in each event into con we have vd e m i e where e ranges over events of the form t stmt with stmt being expr · constraints each constraint chooses a value for a read of a shared variable from possible writes formally each con v is rewritten as v i ei e ei ej intuitively the above formula states that a the value of v read by e is either the ini tial value of v or written by one of e e b if the value is the initial value all ei happen after e and c if the value is written by ei then ei is reached and all con writes either happen before ei or after e we denote by pi the conjunction of all such constraints for example for the function from example the corresponding constraint is balance td tw · correctness condition for correctness if an assertion event e t is reached then ge must hold hence the correctness condition is cor ge where e ranges over assertion events the final encoding for bad executions is given by po vd pi we also encode the complementary correctness condition as po vd pi cor for convenience we use an formula to represent the condition that each assumption must hold we have e where e ranges over all events an execution corresponds to a model v of if a the value of each v in v is the initial value of v in b the value of each in v is the value of v read by e in c the value of each in v is the value of v written by e in and d the value of ej in v is true if and only if ei occurs before ej in theorem given a trace a for every model v of there is a bad execution such that corresponds to v and b for every there is a model v of such that corresponds to v bad computation with an smt encoding of bad executions in the of a trace we now present an algorithm to compute a representation of nb algo proceeds by repeatedly computing satisfying assignments to using an smt solver lines and and the in the models lines and we with additional constraints to ensure that the same satisfying as are not returned each time algorithm computing the bad of a trace require trace ensure b such that nb b b false while ¬b is satisfiable do v satisfying assignment for ¬b b e v e b b b return b bad while algo com an exact representation of nb it is inefficient in practice hence we the goal of an exact representation instead we compute a sound overapproximation of nb which may include infeasible traces but not good traces given trace algo com sound of nb and ng algo performs several optimizations with respect to algo to weaker constraints from each model of ie algo attempts to larger subsets of n into b in each iteration · dataflow analysis from the model v of the data flow analysis those happensbefore constraints b that are necessary to preserve the dataflow into the failing assertion in the corresponding execution we use the function df v e line to compute constraints that ensure e can be reached and can read the same variable values as in v given the execution corresponding to v let and e represent the variables read by e the vari ables read by e in the guard if e is not a guarded assignment and the event that writes the value of v read by e we have df v e df v e df v e where we let df v e v e e df v e and df v e e v e e df v e where event e ranges over e e v e intuitively df v ensures that e can read the same values as in v and df v ensures that e is reached we then get additional constraints necessary to ensure conflicting writes do not affect the dataflow into the assertion line · unsatisfiable core computation next we perform two of generalization on b through unsatisfiable core computation in the first round we construct a formula b where the initial variable values to the ones from v line a satisfying as to this formula models executions where no fail ing assertion is reached therefore if the formula is unsatisfiable the happensbefore constraints from the un satisfiable core line ensure that all executions satisfying are bad note that if all instructions are the above formula is always unsatisfiable in the second round line we follow a similar procedure but with the for b here a model is a good execution and hence the constraints from the unsatisfiable core line ensure that any feasible execution is necessarily bad roughly the first round allows us to generalize the hb formula in the case of bugs the second round lets us generalize further in the case of bugs the sound overapproximation g of ng is obtained by b line note that b returned is in disjunctive nor form dnf while g is in conjunctive normal form algorithm computing sound of the bad and good of a trace require trace ensure b g such that ng g nb b and g b b false while ¬b is satisfiable do v satisfying assignment for ¬b dataflow analysis df df v e where e is the failing assertion in v df writes v v ek ei v ei v ej ek v ek b df ej computation vv v vv if b is unsatisfiable then b t b hard if b is unsatisfiable then b t b hard f ea b b b g ¬b return b g theorem for a trace if algo returns b g then nb b ng g and g nb b ng implementation and evaluation we have implemented algorithms and in a tool accessible at consists of lines of c code and uses z to smt queries we use a new input format for specifying traces the format consists of global and threadlocal variables along with types and any initial valuations and the instructions in format in each thread this makes independent and easy to use with any frontend that can translate instructions to the syntax we use a modified version of to generate files for bad traces in turn uses to find bad traces in programs and to translate c statements into the format has a number of different output algo generates an in dnf which is often large algo generates a in dnf the sizes of whose are locally in our experience the core provided by z is often far from minimal hence we first use z to compute an core and then use a custom minimization use z incrementally with to and expressions for core minimization can also generate an in representing bad however this is computationally more expensive experiments our benchmarks are from a set of sources namely the concurrency track of the software verification suite sv and the of suite cr and suite es we also use a set of small examples with common bug patterns suite hm the cr suite contains versions of real code from the linux kernel to test the limits of we use the examples that have two threads each executing a loop of x iterations for correct behaviour each iteration should execute atomically with respect to iterations of the other thread however the locks required to ensure this are missing we ran our experiments on a with a core core i cpu and gb of ram running linux our results are presented in table the time reported only includes the time taken by and not the time needed to find a bad trace in the benchmark program the column in table indicates the complexity of the benchmarks in terms of the number of threads and instructions the performance of smt queries involving is mostly by the number and size of functions the column indicates the number of functions and average number of arguments per function the performance of using algo and algo are in columns marked algo and algo respectively for each algorithm we report the number of iterations the total time taken and the size of the generated b as the number of and the average number of terms in each disjunct algo times out after in many such cases we report the number of loop iterations completed before the timeout with algo terminates within seconds for each benchmark this time is compared to the time taken to find the initial counterexample trace for example took to find the trace while our analysis completed exploration of its bad in seconds we tested the limits of our tool in the examples with iterations per thread we the timeout and the limit of our current implementation case study synchronization synthesis in our first case study we use the representation of a sound overapproximation of the good of a trace returned as g by algo to synthesize synchronization that eliminates the bad of missing synchronization primitives such as locks barriers and statements present themselves as easily patterns in g our procedure derives the required synchronization using rules that rewrite such patterns into the corresponding primitives table experiments b generation name define use locks stage receiver md lazy locks hb lc rc barrier locks stateful read write lock loop fib ic rtl rtl rtl rtl rtl serial serial rtl serial loop loop loop loop loop suite sv cr cr es hm cr cr sv hm cr hm sv sv hm sv cr cr cr cr cr cr cr cr cr cr na na na na na iterations algo algo k k k k k k k k k k k k k k k k k k k k total time algo algo ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms ms to ms s ms min ms s ms min ms ms ms to s to ms to ms to ms to s to s to ms to s to s to s to s s ms to ms to s to min to min size of b algo algo to k k k k to to to to to to to to to to to k to to to to synchronization primitives we first describe various synchronization primitives that we derive recall from sec that we use the notation t to refer to events labelled with t and the notations t and tl to refer to corresponding event sequences a t t denotes a wait to make t wait for t to complete and a to make t signal t upon completion locks a lock lk tl denotes a common lock each event sequence i n to ensure that these event sequences cannot execute concurrently barriers a barrier barrier t tn n at location i of thread ti i n prevents each thread ti from beyond i until every other thread tj reaches j in other words ti cannot execute the event at i until every other tj executes the event at j locks a lock or a lock sh ex permits concurrent execution of all event sequences i n while preventing concurrent execution of a any two and with i j and b any and rewriting g to derive synchronization during the rewrite process below we use disjunctive formulae denoted by where each disjunct is either an atomic of the form i tj j or a synchronization primitive for a trace we repeatedly apply the rewrite rules from fig on g in as returned from algo until no more rules are applicable the and rules introduce the locks and barrier primitives the rule merges locks across pairs of threads while the rule merges locks that can potentially lead to deadlocks the and rules inductively derive locks and barriers spanning multiple threads the rule derives a shared exclusive lock from already inferred locks since g as generated by algo is already optimized we do not merge primitives we explain two of the above rules here the premise of the rule for two event sequences t and t such that one of them has to finish execution before the other starts ie t t equivalently the two event sequences do not execute concurrently this is enforced by the lock lk t t the premise of the rule looks for two already derived locks acquired by two threads in different orders which may lead to a deadlock and merges these locks into one note that the rewriting process always terminates however depending on the order of rules applied we may obtain different formulae upon termination we get a formula over synchronization primitives we pick a set s of synchronization primitives consisting of one primitive from each conjunct let ps be the program obtained by inserting each synchronization primitive in s into the corresponding position in the original concurrent program p theorem soundness of rewrite rules given a trace let ps be obtained as described above let ln be a execution of ps then ie is not bad while ps is not guaranteed we perform simple consistency checks when choosing s to prevent obvious deadlocks for example we ensure that primitives in s do not introduce ordering cycles over events note that our rewrite rules are by no means complete it may be possible to derive the above synchronization primitives using different rules that represent other scenarios further our rewrite figure rewrite rules for synchronization synthesis t t lk t t t t t t t barrier t t lk tl n i lk lk tl lk tl tl lk tl tl tl tl lk tl tl tl tl lk t a a t a a lk t b b t b b a b a lk t a max a b t b max b a b a b barrier t tn n n i barrier ti i tn n barrier t tn n n i m j lk m i m j lk sh ts ls ex tx lx system can also be extended to other synchronization primitives we now present examples the application of our rules example for the example trace shown in fig g is given by tw td applying the rewrite rule yields lk tw td example for the example trace shown in fig a g is given by ts tf tf ts applying the rewrite rule yields lk tf ts tf ts applying the rule yields lk tf ts barrier tf ts example for the example trace shown in fig b g is as shown the and are not relevant for this example except for the fact that is common to the rd and th conjuncts is common to the th and th conjuncts and · applying yields tf ts lk tf ts lk tf ts lk tf ts lk tf ts · applying next yields tf ts lk tf ts lk tf ts · finally applying the rule yields tf ti ts ti lk tf ts lk tf ts note that the rule does not apply to the last two conjuncts as one possible solution for s is tf ti ts ti lk tf ts experiments we implemented the above procedure as an extension to given a trace supports synchronization synthesis as an optional step after generating representations of ng and nb the implementation first attempts to apply the rules and in that order then the merging rules are applied first merging locks across thread pairs and then merging barriers and locks spanning multiple threads we report the results of synchronization synthesis ments in table in each case we report the numbers of locks l barriers b and wn primitives synthesized the synthesized synchronization matched our human intuition about the needed since generates fairly small g formulae the synthesis takes less than in every case table experiments synchronization synthesis name define use locks stage receiver md lazy locks hb lc rc barrier locks stateful read write lock l b wn name loop fib ic rtl rtl rtl rtl rtl serial serial rtl serial l b wn case study bug summarization in our second case study we use the representation for a sound overapproximation of the bad of a trace returned as b by algo for counterexample summarization and bug summarization the b relevant ordering information about all counterexamples in the of and can be viewed as a counterexample summary for instance in fig c one may view b tp as a counterexample summary that indicates a possible order violation while such a bug report can already be useful to a human debugger a of the dataflow through the events in b can enable formulation of a more precise bug summary to this end we present a set of rules to help infer specific bugs such as data races order violations and access bugs inferring bug summaries from b we assume b is in dnf our inference rules are presented in fig for a thread t a location and a global program vari figure example programs int float value value value value sum int flag flag init value value value interrupts init interrupts value sum flag flag thread float temp thread ti ti init tf value tf value tf temp sum tf sum temp tf value tf value tf flag thread first int temp tf assume tf assert tf temp tf temp tf interrupts interrupts thread temp init ts value ts value ts temp sum ts sum temp ts value ts value ts flag thread second int temp ts assume ts assert ts temp ts temp ts interrupts interrupts thread tc assert interrupts g tf ts thread tc assume flag and flag tc assert value value value value tf ts ts tf tf ts ts g ts tf tf ts tf b interrupt handler simplified of the linux a normalization the goal of the program this trace is drawn from is to a set of values such that their sum computes to the program consists of three threads the first and second thread process one half each of the set of values once the first and second thread run to completion the third thread checks if the sum of the normalized values is network driver once the variable is set by the thread the hardware starts producing interrupts the handling of these interrupts by the two threads is correct only if the driver initialization is complete captured by the variable the add items to a the addition of items is modeled using a counter the variable interrupts counts the total number of interrupts handled pointer start by the threads and the thread uses int init interrupts to check for in the thread tp tp start start network thread tn assume tn assert start start pointer dereference int memory init memory thread int loc data page tp page tp loc tp data tp assert data void start thread does something int page loc b tp c network device this trace is drawn from a sim td page td loc td td of the linux network driver the thread signals that a network device is using b tp td the variable and sets start to point to the d the thread reads a memory location start method the network thread calls open loc from and reads data from that memory location once the network device is the open method the thread reads the current memory location loc from dereferences the start pointer updates with a new memory location and copies the data from the old memory location to the new memory location figure inference rules for bug t t v v t t v t t v v v t t t v t t v v v t t t v v v v t t t v w t v w t t v w v w t t v v n t t v t t t t ain this figure and able v a v denotes that event t reads from v b v denotes that event t writes to v and c v denotes that event t reads from or writes to v in the discussion below we combine these with ordering constraints in a natural manner for example v v says that event t happens before t and that v and v hold data races recall that in our framework every instruction is assumed to execute atomically this includes statements of the form v v which may execute at a lowlevel hence to infer data races corresponding to concurrent accesses of a shared variable v we need to model statements at a lower level ie by separating events into several lowlevel atomic events in most cases these lowlevel atomic events either read or write variables but not both for instance a decomposition of an event e with instruction v v is given by e e where event e has instruction r v event e has instruction v r and r is a local variable modelling a register in this case a data race between event e and some other event e accessing v in another thread itself in a trace as the ordering pattern e e e hence the rule infers a possible data race between events labelled and tl if the pattern v v v is found in b further if e is also decomposed into e e where e reads from v and e writes to v a data race can manifest in a trace as e e e e the rule infers a possible data race between t t and t t if the patterns v v and v v is found in the same disjunct of b atomicity violations the rules the rules if the dataflow and ordering pattern v v v in b the first rule infers a possible atomicity violation of the event sequence t via event t if the patterns v v and v v manifest in the same disjunct of b the second rule infers a possible atomicity violation of the event sequence t and event sequence t two stage access the rules capture two classic scenarios of access bugs indicating violations of some consistency requirement of accesses to v and w in particular the values of v and w read by a thread could be inconsistent if either of the following patterns manifest in b a v v w w or b v v w w ordering the rule infers a specific type of order violation indicating the use of a variable before it is defined given b in dnf if the ordering v v in a disjunct the rule infers a order violation if there exists a trace n such that satisfies and t precedes all events that write to v in starting from b given in dnf we repeatedly apply the inference rules from fig until no more rules are applicable we report all inferred bugs as possible violations note that our goal here is only to the user in program debugging our inference rules are not complete we do not claim that our inferred bugs will in the programs executions or that they will match a human intuition we now present examples the ap of some of our bug inference rules example for the example trace shown in fig b is given by td tw since balance balance balance and balance hold we can apply the rule to infer a y note that this bug inference matches the synchronization lk tw td synthesized in example example consider the example trace shown in fig c in our encoding the pointer start is modelled as an integer variable that is initially since start is uninitialized the pointer dereference in tn is modelled as for this example b is given by tp since and hold and trace tp tn tn tp satisfies the last premise of the rule we can apply the rule to infer a order violation between tn and tp example for the example trace shown in fig d b is given by tp td since memory and memory hold we can apply the rule to infer tp experiments given a trace supports bug summarization as an optional step after generating b starting from b in dnf the implementation attempts to apply the and inference rules in that order identical bug reports are merged to avoid the experimental results of using our bug summarization on our are presented in table we report the numbers of data races dr atomicity violations av access bugs s and bugs du inferred the human column in the table presents a classification of the bugs present in the benchmarks as reported by an user stands for order violation the last column indicates if bug summary matched the human classification for the of benchmarks summarized the bug correctly yes in some cases did not infer a bug summary ­ for the serial benchmark bug summary the human classification for each example the implementation takes at most table experiments bug summarization name s dr av du human bug sum right du yes define use du yes du yes locks dr yes stage s yes receiver ­ md du yes lazy ­ locks hb dr du yes lc rc ­ barrier locks dr yes stateful ­ read write lock av yes dr yes fib av yes ic av yes rtl du yes rtl du yes rtl ­ rtl ­ rtl ­ serial no serial ­ rtl ­ serial ­ case study cegar in the final case study we present a procedure for learning predicates for refinement in a cegar loop with the help of an loop proceeds by building an abstract model of an input program and applying a on the abstract model if the abstract model satisfies the correctness specification then the input program is correct otherwise the finds an abstract counterexample ie an execution in the abstract model the abstraction counterexample is spurious if there is no concrete execution that corresponds to the abstract counterexample given a spurious counterexample the refinement procedure refines the abstract model this is done by finding predicates that the abstraction procedure to construct the next abstract model by adding the relevant details to the current abstract model such that the spurious counterexample is absent from next abstract model the process starts over with the newly refined abstraction after a number of iterations the abstract model may have no more counterexamples which proves the correctness of the input program for simpler presentation we assume that the input program is correct and all the abstract counterexamples are spurious an loop often takes many iterations to find the right set of predicates to prove correctness of the input program this usually depends on the design of the refinement procedure many heuristics have been proposed to find the relevant predicates in fewer iterations see for example we aim to use to the search for the right predicates ie reduce the number of iterations of a cegar loop our refinement procedure takes a concurrent abstract counterexample as input and returns refinement predicates first we the counterexample using and obtain an b that encodes a set of incorrect interleavings we sample a number of interleavings from b and attempt to compute refinement predicates that simultaneously remove all the spurious interleavings using a method similar to interpolants abstraction and refinement an abstract model of a concurrent program p v t tk sv lv is another concurrent program p v t tk sv lv such that for each i k and event e in ti there is an event e in ti such that if e is feasible then e is feasible in predicate abstraction the abstract event e corresponding to an event e is defined using a set of predicates as follows let us suppose predicates m are used for abstraction let i m let i be the weakest precondition of e over i and i be the weakest precondition of e over let i and i be the weakest formulas that are boolean combinations of m and imply i and i respectively e is feasible iff i m i i i let e be a spurious counterexample ie a trace in the abstract model that violates the specification a refinement procedure computes additional predicates n n over program variables that satisfy the following constraint n true n f i ei i i note that the formula i is the formula i where each variable v is replaced by its version v recall that v represents the value of v the execution of an instruction an abstract model computed using predicates n is guaranteed to not exhibit the spurious counterexample sampling an we pass trace e en to and obtain an b in dnf to represent bad abstract traces b is a formula over events e en with slight of notation we assume that b is a formula over events e en which can be obtained by replacing abstract events by their corresponding concrete events in b we sample a few concrete infeasible traces that satisfy b and try to compute the simultaneous refinement predicates ie predicates that eliminate all the traces from the abstract program intuitively learning predicates simultaneously using multiple spurious counterexamples may allow us to find more general predicates both sampling and simultaneous refinement are heuristics choices here we present one possible choice for the sampling however one can imagine a wide array of heuristics for these choices in our sampling heuristic we search for two in b of the form ea eb and eb ea such that negation of any in is not in we generate traces and such that a they satisfy ea eb and eb ea respectively and b they are of the following form e ea and ek e e eb ek ix f ix e ek e ek e ek e ek if ea eb and eb ea are able such traces always exist both the traces have a common prefix and suffix and two middle segments e ek and e ek are from the traces we obtain refinement predicates k kk kk and k by solving the following constraints k true i ei i k prefix i k kk i ei i i i mid trace i ik k kk i ei i i i mid trace i ik k kk kk i ei i k f i suffix in the above equations the first and last constraints correspond to the prefix and suffix respectively the second and third constraints correspond to the middle segments of the two traces constraint solving for simultaneous refinement we discuss how to solve the above constraints for refinement the above constraints are a set of nonrecursive horn clauses many techniques exist to solve such constraints eg since we are for simultaneous refinement we prefer the solutions for the unknown predicates to be simple atomic formulas if an unknown predicate appears as of multiple implications for example k then the solver may naturally give a solution that is a disjunction of two atomic formulas we use the method that is presented in sec of for the theory of linear arithmetic that forces a solver to return solutions for the above constraints with single atomic formulas if such a solution exists table experiments cegar acceleration example example example example iterations times iterations times experimental results we have implemented the above refinement procedure in and refer to the modified version as in table we present the result of running and on three hand examples each of these examples contain two threads and lines of code our method reduces the number of iterations in all the examples however the total time of verification increases for two examples due to the fact that our refinement procedure is not well optimized related work representations of trace sets the encoding used in sec was introduced in and subsequently generalized in we may find more applications and variations of our tool from exploring other suitable happensbefore constraint based encodings of interesting interleavings from the body of predictive analysis literature cf concurrent counterexample traces have been generalized into partial order traces in as demonstrated in this paper partial orders may not be adequate to represent arbitrary trace sets the work in introduces a new data structure an inductive dataflow graph idfg to generalize proofs of programs while is also a representation of concurrent trace sets it is not clear how one may apply for program debugging or synthesis in other work interference scenarios have been proposed in to represent concurrent executions that are equivalent under the same input values for sequential programs the authors in represent all counterexamples of recursive programs using pushdown automata synchronization synthesis in the formal methods and programming languages community synchronization synthesis of concurrent programs has been an active area of research for a long time in the past the approaches in were based on inferring synchronization by constructing and exploring the entire product graph or corresponding to a concurrent program recent approaches infer synchronization incrementally from traces or of bad traces however the techniques from infer atomic sections rather than sections are not directly implementable and need to be translated into locks either manually or using other automated techniques see for example et al introduce a tool that bugs in concurrent c programs by matching bug patterns and however in their case the bug patterns are simple corresponding to only conjunctions of happensbefore constraints and hence cannot infer synchronization such as barriers on the other hand the tool is very robust and practical and has generated and corresponding for real libraries bug summarization while there have been various techniques for fault error explanation counterexample minimization and bug summarization for sequential programs we restrict our attention to relevant works for concurrent programs in the authors focus on counterexamples in programs to a set of crucial events that are both necessary and sufficient to reach the bug in the authors introduce a heuristic to simplify concurrent error traces by reducing the number of there are several papers that survey and classify common concurrency bug patterns we can extend our bug inference rules using the bug patterns from the papers finally there is a large body of work on automatic detection of specific bugs such as data races and atomicity violations cegar there are several works to the cegar loop by finding better predicates eg in the setting of hardware modelchecking for circuits et al extend the cegar loop by adding several predicates if a spurious counterexample is found they generate all counterexamples of the same length and information about valuations crucial to the of the counterexamples in a similar setting wang et al improve the cegar by introducing a technique to eliminate all spurious counterexamples for an invariant et al apply cegar optimizations to software model checking and speed up the search for predicates that make the counterexample spurious however they do not use interpolants and instead search the counterexample for conflicting predicates et al use predicates obtained from cegar to guide checking and extend its reach remarks we propose a representation for concurrent trace sets based on we present a method and a tool for generating representations of sound of good and bad of a trace we use to successfully three applications in concurrent program reasoning synchronization synthesis bug summarization and cegar we believe that our representation and algorithms can significantly the applicability and utility of techniques for concurrency while the initial experiments using have been promising there are several for future work we plan to extend to infer synchronization from traces over different set of events in the bug summarization domain we plan to add a larger class of bug inference rules for cegar based verification we plan to implement a more efficient refinement procedure and explore other sampling rules for abstract counterexamples acknowledgements the authors would like to thank and for enabling discussions the authors would also like to thank the anonymous reviewers for their considerable constructive feedback references a and k interpolants in cav pages ­ s d y lin and s generation of all counterexamples for pushdown systems in pages ­ d status report on software verification in tacas pages ­ d t henzinger r majumdar and a rybalchenko path invariants in pldi pages ­ d and e a tool for software verification in cav pages ­ http p and j using counter example abstraction refinement to find complex bugs in date pages ­ n k and a rybalchenko on solving universally quantified horn clauses in sas pages ­ p c t henzinger a l and t efficient synthesis for concurrency by transformations in cav pages ­ p c t henzinger a l and t synthesis for concurrency in cav pages ­ s t and s gulwani inferring locks for atomic sections in pldi pages ­ e clarke d and f a tool for checking programs in tacas pages ­ e clarke d n and k predicate abstraction for in tacas pages ­ e m clarke and e a emerson design and synthesis of synchronization skeletons using branching time temporal logic springer e m clarke o s y lu and h counterexampleguided abstraction refinement in cav pages ­ l de and n z an efficient smt solver in pages ­ a a d and t predicate abstraction for concurrent programs in cav pages ­ d and k effective static detection of race conditions and deadlocks in pages ­ e y and s ur concurrent bug patterns and how to test them in page pp a a n and h testing in pages ­ a z and a podelski inductive data flow graphs in popl pages ­ m g s r and m iterative abstraction refinement an evaluation in tacas pages ­ a gupta c and a rybalchenko solving horn clauses over in pages ­ t a henzinger r jhala r majumdar and k l abstractions from proofs in popl pages ­ j p and g maximal sound predictive race detection with control flow abstraction in pldi pages ­ n and k a trace simplification technique for effective debugging of concurrent programs in pages ­ g w d b and s lu automated in pages ­ v and c wang universal causality graphs a precise happensbefore model for detecting bugs in concurrent programs in cav pages ­ s and v producing short counterexamples using crucial events in cav pages ­ s lu s park e and y learning from a study on real world concurrency bug characteristics in pages ­ z manna and p synthesis of communicating processes from temporal logic specifications in toplas pages ­ j m l d and b fischer in tacas pages ­ m said c wang z yang and k generating data race witnesses by an analysis in formal methods pages ­ t s and m using counterexample analysis to minimize the number of predicates for predicate abstraction in pages ­ s m g nelson p and t a dynamic data race for multithreaded programs acm trans on computer systems pages ­ k g and g detecting errors in multithreaded programs by generalized predictive analysis of executions in pages ­ r a v and a aiken interpolants as in cav pages ­ n and c wang on interference abstractions in popl pages ­ y j c j yi and c flanagan sound predictive race detection in polynomial time acm sigplan notices pages ­ m e and g synthesis of synchronization in popl pages ­ m t e and g inferring synchronization under limited in tacas pages ­ c wang s m and a gupta symbolic predictive analysis for concurrent programs in fm pages ­ c wang b li h g and f improving by following multiple threads in abstraction refinement ieee pages ­ c wang r m and a gupta symbolic analysis for atomicity violations in tacas pages ­ 