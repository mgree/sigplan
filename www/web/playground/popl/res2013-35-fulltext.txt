processing systems nonstandard modeling of signals university university of of abstract we exploit the apparent similarity between stream processing and signal processing and transfer a deductive verification framework from the former to the latter our development is based on rigorous semantics that relies on nonstandard analysis specifically we start with a discrete framework consisting of a stream processing language its fixed point semantics and a program logic in the form of a type system for partial correctness guarantees this stream framework is as it is to one for of streams that typically arise from sampling signals with smaller the logical infrastructure of under a certain continuity assumption we identify with signals our final outcome thus obtained is a deductive verification framework of signals in it one verifies properties of signals using the discrete proof principles like fixed point induction categories and subject descriptors f logics and meanings of programs specifying and verifying and reasoning about of programs f logics and meanings of programs semantics of programming semantics keywords hybrid system stream processing signal processing type system nonstandard analysis introduction signal by signals we mean values that depend on continuous time that is functions s r c signals are everywhere in the real world they are the most straightforward model of physical like position etc signals have been studied extensively in the theory of systems or more recently from the engineering viewpoint of control theory the use of complex numbers of the range is due to our use of i the unit in our leading example in § this choice is not important our theory behaves the same for both c r and r permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm hybrid system in the modern world where more and more physical systems are under the control of computers etc signals that are not entirely discrete jumps caused by digital their they play an important role in the study of hybrid systems an aspect of the more general topic of systems an tool for modeling and simulation of hybrid systems supports the design of a hybrid system as a signal processing system composed of blocks above right a signal processing system is one that receives processes and outputs signals stream processing study of formal computer science in traditionally been focused on discrete data this is changing though there stream processing system is a studied notion together with related notions like dataflow network and reactive programming a stream is an infinite sequence a a of data thus it is a value s n c with a discrete notion of time it an obvious similarity to the notion of signal moreover common graphical of stream processing systems look very much like block diagrams this similarity is the starting point of the current work the difference between signals and streams is whether the time domain is continuous r or discrete n if one can unify this difference the discrete techniques for streams that have been in computer science can be readily applied to signals this is what we do by the mathematical of nonstandard analysis allows us to think of flow dynamics as if it is a of jumps each of which is infinitely small nonstandard analysis is an alternative formalization of continuity uses the explicit notion of ie infinitely small number original formulation of analysis was based on but a naive use of such immediately leads to a contradiction it was who gave a logically rigorous foundation for using the notion of in our previous work we used to represent flow dynamics by means of while iteration of a loop changes values what is about is its logical infrastructure its result called the transfer principle states that a formula is valid for real numbers if and only if it is valid for ie reals extended with therefore reals vs ie discrete vs continuous in the setting of are the same from a logical point of view this allowed us in to transfer a logical ie deductive verification technique for discrete programs as it is to hybrid systems in the current work we use the same idea to fill in the gap between signal processing and stream processing we similarly transfer a deductive verification method too in it we employ the formalism of a firstorder functional stream processing language is modeled after the language to represent stream processing systems is in fact not only about analysis its use is found in many branches of mathematics such as general topology iii and posets in this paper we present another instance of such namely domain theory with appendix b part of which already appeared in we use it in the definition of denotational semantics of sprocdt overview of the technical development on the right in is the overview of our development it is around two key ideas sampling and execution signal safety sampling safety deductive verification sampling typically sprocdt type system a computer science approach to the study of signals starts off with sampling a signal f execution type system a sampling interval results in a stream f f f f ´ obviously such sampling cannot be cannot know what happens to f ing seconds of the sampling interval then a natural idea is to consider infinitely many sampling intervals that are small as shown on the right this results in a stream of streams f i j that is jn f f f ´ b b f f f f f f ´ ´ c c a roughly a is such a stream of streams this sampling still cannot be exact for all signals f after all there are only many sampling points while r is however if f satisfies some continuity assumption we could the value f t for t r as a certain limit of values specifically based on the figure below on the right we collect the following values from the sampling result f t f t f t f t this construction is called here is up we will formalize these sampling and smooth ing operations and in § there we propose a class of functions ie a continuity re that makes sampling in exact that is id in this paper in fact we use a refined no tion of it is not simply a stream of streams described above but is the transform of the notion of stream the intuition behind this refined notion is a is a stream f f dt f dt with an in sampling interval dt the jth stream f f j f j ´ in then occurs as its jth approximation transform is an construction its benefit is that we can transfer a logical theory of streams as it is to that of streams via the transfer principle in this idea of using an sampling interval is already presented in § where they establish id for functions f r r that are everywhere continuous they also an extension to continuity since we aim at hybrid applications our class of functions def is and contains some examples such as a ball execution the second key idea is about integrating into program semantics and the latter from dis to for this purpose we use the idea called execution it was first used in our previous work for a language with while loops here we briefly review the idea as presented in it later to the current setting of stream processing its very first example is the program on the right here dt is a constant that denotes t while t do an value if that is the case the t t dt while loop will not terminate within finitely many steps never it is intuitive to imagine the execution of the program to increase t from to in a smooth and continuous to put this intuition into rigorous program t semantics we think of the following section while t do execution for each natural number i we t t i consider the ith section of the program that is denoted by and shown on the right concretely is obtained by replacing the dt in with i informally i is the ith approximation of the original a section does terminate within finite steps and yields i as the value of t now we collect the outcome of section execution and obtain a sequence i which is intuitively thought of as a approximation of the actual outcome of the original program indeed in the language of the sequence represents a number r that is close to in based on this idea we presented a framework for mod and verification of hybrid systems it consists of an language while and a program logic hoare augmented with a constant dt and called and exploiting the transfer principle in roughly states that reals and are logically the showed that the rules of precisely the same as those of hoare are sound and relatively complete underlying is the denotational se of programs defined in the above way in we applied several static analysis techniques mainly for invariant discovery to this setting we also implemented an automated verification tool it was in that the use of dt is not only for while programs but is probably a general methodology for a discrete verification framework to our current work is one such example the framework of a stream processing language and a program logic in the form of a type system is to the one for processing here execution takes the following concrete form as a processing language we introduce sprocdt it is a stream processing language augmented with a constant dt for an interval the denotation p of an sprocdt we note that programs in are not executable in general this is already clear in the example of we rather think of as a modeling language on which we can carry out static deductive verification the same is true of the language sprocdt introduced in the current paper program p takes a and returns a is defined by p i ´ j pj j that is the section pj an program is applied to the jth stream of the input and their outcome is up example the curve here is a program in sprocdt node returns s where s s c × dt c c s × dt node main returns proj the third line main is and can be ignored for the moment the core part is the mutual recursive definition of the s and c whose intuition we now explain the operator means delay by one step ie dt seconds a a b b a b b therefore the recursive equation s s c × dt means for each n that in fact ranges over numbers sn sn cn × dt if n otherwise this yields the following equations s dt cn the value sn is that of one step before sn ie dt seconds before sn thus the equations are identified with the differential equation cost with the initial value sin intuitively the section execution of the curve as the limit of the ap with dt this is like the graphs on the right in the current work we employ a more advanced dt dt part of than used in it allows us to transfer statements not only on facts but also on ones more precisely we can now transfer formulas of the firstorder language lx def that has as a binary predicate the details of this part of is rather complicated but most of them are not needed in § we list the minimal set of necessarily definitions and results a usage scenario our technical framework summarized in is to be used in the following way we are given two data a signal f and a safety property p the goal is to verify that f satisfies p towards that goal one first models f by an sprocdt program typically we are not given f as a mathematical entity ie a function f r c but we get its formal specification written in some formalism like and diagrams in this case modeling of f amounts to translation of a specification say in into an sprocdt program this modeling part is briefly discussed in § but a more extensive treatment is left as future work the question then becomes whether the sprocdt program satisfies the safety property p for that we can use a type system for sprocdt p is translated into a suitable type p and we try to derive a judgment p using the typing rules the typing rules include the proof principle of fixed point induction once the derivation is done by type soundness thm it guarantees that the denoted by satisfies p finally by thm it implies that the signal satisfies p thus we are done under the condition that the sprocdt modeling of f is correct ie f note that the last is all about the metatheory the actual verification task is derivation of a type judgment and this is done in the same deductive style as the verification of stream processing in its course the metatheory is completely organization of the paper in § we list the definitions and results of that are used later a prototype stream language is introduced in § together with its denotational semantics and a type system for safety guarantee it is modeled after and is nothing novel but the framework is carefully designed so that it allows the transfer to sprocdt in § finally in § we translate signals into and also the safety guarantee for obtained by the sprocdt type system to that for signals § is to a verification example our intention is to use the current framework for hybrid systems as mentioned like def are out so that it many common hybrid dynamics our leading example example which is used in § is however a totally continuous one this is due to the limited space in § we conclude we defer most of the proofs to the extended version in this paper we sometimes refer to appendix it is found in related work the current work shares with the observation of the similarity between signal processing and stream processing in they extend by they go on to a compilation framework that discrete and continuous parts of a program passing the latter to an external solver to approximate continuous dynamics for the correctness of the compilation they introduce formal semantics which like ours takes continuous dynamics as a of jumps they also employ a type system for the separation of discrete and continuous parts of a program despite these the current works objective is quite different from aim to exploit logical infrastructure to transfer deductive ie logical verification from discrete stream processing to signal processing the extension of by in is not designed towards this objective formal verification of diagrams has been studied eg in in diagrams are translated into hybrid automata which are amenable to model checking in translation of a discrete fragment of into is presented combines symbolic analysis and numerical simulation towards the goal of simulation coverage all these papers agree on one point lacks formal semantics in semantics is defined operationally by formalizing the simulation algorithms used in the implementation of we hope our modeling will serve as a basis of denotational semantics of to the purely discrete world formal verification of stream processing systems is studied often in the abstract interpretation community application of these results to our current deductive approach is an interesting direction of future work for hybrid systems in general there have been extensive research efforts from the formal verification community unlike the current work where we turn flow into jump via dt most of them feature distinction between flow and these include modelchecking approaches based on hybrid automata deductive approaches one of the most of which is a recent series of work by and his including interestingly in it is argued that being hybrid imposes no additional burden to deductive verification this with our view that being discrete and being are logically the same some verification techniques from the static analysis community have been successfully used in hybrid applications modeled with explicit differential equations ­ the basic idea of the current of our previous is to transfer discrete verification techniques as they are to settings it is never our intention to the of discrete techniques to continuous ones the formal verification community has out a of discrete techniques our case is that their application domain can be pushed further to indeed we see as an extremely efficient formalism for continuous dynamics we plan to incorporate them into our framework the use of as a foundation of hybrid system modeling is not proposed for the first time see eg compared to this existing body of work we claim our is the use of logical infrastructure especially the transfer principle for deductive verification based on a concrete modeling language in particular the basic idea of the current paper namely stream processing signal processing as well as two important technical ideas namely sampling intervals and domain theory in are already in unlike the current paper where we introduce a concrete programming or modeling language sprocdt in they work with an abstract graphical language of string diagrams for monoidal categories notations and terminology the syntactic equality is denoted by an infinite stream s a a over s is identified with a function s n s we write si for its ith element ie si ai for a nonnegative real r r r n denotes the least natural number that is not smaller than r that is r r r in this paper we use some domain theory for which our principal reference is we will be using them simply in most results are formulated in terms of directed cpos the equivalence between these two cpos is found in prop we also assume the least element in cpos a nonstandard analysis here we list the minimal set of necessary definitions and results in nonstandard analysis more details are found eg in in first we present an elementary part of we fix an index set i n and an f pi that extends the filter fc s i i s is finite its properties to be noted for any s i exactly one of s and i s belongs to f if s is ie i s is finite then s belongs to f definition d x for a base set x typically it is n r or c we define the set x of by x xi f it is the set of infinite sequences on x modulo the following equivalence f we define a a f a a by i i ai ai f for which we say ai ai for almost every i therefore given that two sequences and ai i coincide except for finitely many indices i they represent the same the predicates other than such as are defined in the same way a consequence is the existence of an number a is positive but is smaller than any standard positive real r r r definition a r is limited if it is not infinite ie if there is a standard positive real k r such that k r k it is wellknown see that a limited r has a unique standard real that is infinitely close to r this standard real is called the of r and denoted by the notion of is a generalization of that of limit if then a ´ ai see eg remark it is common in to take an index set i that is than n and an f pi over i the of doing so is that the resulting § can be chosen to be an see ii in this paper however we and choose i n as the index set in what we need from the logical machinery of goes beyond the elementary fragment presented above it a set formal language lx and a socalled as a model the definitions and results listed below are all and commonly used in we follow ii in which more details can be found a is a universe constructed step by step from a certain base set x we assume n x definition a v x over x is v x s nn vn x where vx x and ordered pairs a b and tuples a am are defined in v x as is usually done in set theory eg a b a a b the set v x is closed under many set formation operations for example the function space a b is thought of as a collection of special binary relations a b pa × b hence is in v x transform we use the following predicate logic lx definition the language lx terms in lx consist of variables x y x x and a constant a for each entity a v x formulas in lx are constructed as follows · the predicate symbols are and both are binary the atomic formulas are of the form s t or s t where s and t are terms · any boolean combination of formulas is a formula we use the symbols ¬ and · given a formula a a variable x and a term s the expressions x s a and x s a are formulas note that quantifiers always come with a bound s the language lx depends on the choice of x it determines the set of constants we shall also use the following syntax in lx as is common in their translation into proper lx formulas is straightforward s t st st st st pair s sm tuple direct product inclusion short for x s x t function application short for x st t x s function composition s tx inequality in n short for s t where n remark we note that lx on a different level from the languages that we introduce later such as sprocdt and their assertion languages lx is used to define the semantics of those languages and is a meta language in this sense definition semantics of lx we interpret lx in the v x in the obvious way let a be a closed formula we say a is valid if a is true in v x validity is defined only for closed formulas the socalled construction yields a canonical map v x v x a a that is called the transform it is a map from the universe v x of standard entities to v x of nonstandard entities we skip the details of its construction later in this section we take a closer look the map becomes a a notion in most notably it satisfies the transfer principle lem definition transform of formulas let a be a formula in lx the transform of a denoted by a is a formula in lx obtained by replacing each constant a occurring in a with the constant a that the element a v x lemma the transfer principle for any closed formula a in lx a is valid in v x if and only if a is valid in v x the transfer principle is a powerful result and we will totally rely on it in the semantics of sprocdt here are the first examples of its use lemma for a v x x we obtain an injective map a a b a b a as a restriction of in if a is a finite set the map is an isomorphism a a let a b be the set of functions from a to b we have a b a b a × · · · × am a × · · · × am and a · · · am a · · · am for a binary relation r a × a we have r a × a moreover r is an order if and only if r is an order internal sets the distinction between internal and external entities is central in in this paper however it is much of since all the entities we use are internal here we present only the relevant definitions leaving their to in appendix b especially rem b we will see that being internal is crucial for transfer definition internal entity an element b v x is internal with respect to v x v x if there is a v x such that b a it is external if it is not internal lemma f a b is internal if and only if f a b the construction we collect some necessary facts about the construction of the in its details are beyond our scope they are found in the map in fact into the following three steps v x v x m q f v x the first factor maps a v x to the constant function a such that ai a for each i i recall that we have chosen i n rem the second takes a modulo the f finally the third factor m is the socalled for an intuition let us exhibit these maps in the simple set of § the first factor corresponds to forming constant streams a a a a the second is modulo f of the third map m does is a function that is only needed in the extended setting of tures the next result thm is about starting from the corner in it follows from the definition of m and is a crucial step in the proof of the transfer principle lem it serves as an important lemma too later for the semantics of sprocdt lemma theorem let a be a formula in lx with its free variables contained in x xm and a am s nn vn x vn x then a m ax m is valid i i is f as a special case let s v x then m a s ai s for almost every i corollary let a b v x and for each i i fi a b and xi a then m is an internal function a b and m a moreover m m m the stream processing language in this section we introduce the language for stream processing together with its denotational semantics and a type system the last is much like a program logic for partial correctness the whole framework is nothing surprising is modeled after its semantics is defined as usual following kahn and the type system is with a limited expressive power the point is their clean logical foundations which allow us to transfer the whole sprocdt § syntax for an example of an program see example it is an sprocdt program but the two languages are very close definition we fix a set of stream variables and for each m n n a set of node names of arity m n these sets are assumed to be disjoint the syntax of is defined in table some of its details are in order the set consists of the expressions a constant c c stands for the c c the operator is for the power a a b b ab ab for each j n we have an operator followed by it means a a b b a aj b b the expression f e em invokes the node whose name is f declared elsewhere in the same program it with the input e em and returns the kth component of its output the set consists of the expressions for streams in the boolean values b tt ff the operators and are the obvious extensions of c b c b and c b the last is defined by c c tt if c c r and c c ff otherwise each node nd nodes comes with a certain arity m n and its name f is chosen from it takes as input and returns as output in the node nd in table the variable xi is for an input stream and the local variable yi is used in the mutually recursive computation inside the node specified by y e yl el these and together constitute the set of bound variables in nd the restriction in table that only these variables are allowed to occur in nd finally a program of is a finite sequence of nodes with the last one designated as the main node the restriction in table means that we can invoke a node only if it is declared in the program denotational semantics we define the semantics of in the denotational style exploiting the cpo structure of streams this approach to the denotational semantics of stream processing systems back to kahn specifically our semantic domains are as follows definition c b by c we denote the set of finite and infinite streams over c that is c c cn we also define b for b tt ff by b b bn notation in what follows it is convenient to regard a finite stream as if it is an infinite stream using undefined we identify a a am with an infinite stream a a am the intuition is production of the element am never terminated thus the elements never produced hence in c if am then am for any m m the following result approach lemma the prefix order on c makes it a cpo that is any element is chain s the empty s · · · has a stream the same si its too least based on this observation we introduce the semantics as follows definition environment a stream variable environment is a function j c that assigns c to each stream variable x a node environment k assigns to each node name f a continuous function ct ´ here mf nf is the arity of f and the set ct is that of continuous ie but not necessarily preserving functions from to with respect to the order in lem therefore k is an element of the following set k q f c mf ct c nf ´ we denote the sets of stream variable environments and node environments by and respectively lemma the sets and are cpos with the pointwise extension of the order structure of c specifically between k k we have k k if and only if m n n f s cm k n k s ´ k s ´ here k is the kth projection k cn c the order on is similar using these environments we define the semantics of expressions as follows we go step by step definition e jk and b jk in table we define the denotation e jk c of a expression e under variable and node environments j and k here the definition of e e jk simply says that is applied recall that a finite stream a am is identified with a am the operator returns if any of its arguments is this is the same for if then else ¬ etc that appear later in table the definition of e e jk is the equation put in formal terms recall that means nontermination notation in the definition of f e em jk recall that k is the kth projection see lem also note the type of k see we simultaneously interpret expressions as in ta ble recall our definition of between complex numbers see the semantics of recursion is by least fixed points definition nd k let nd be a node nd » node f x xm returns e en where y e yl el ­ of arity m n we define its denotation nd k cm cn as follows given s s sm cm as input first we solve the following recursive equation and obtain a variable environment j as its least solution j » j x s xm sm y e jk yl el jk ­ on the righthand side x s means a function update the variable environment j thus obtained is used in nd k s sm e jk en jk cn definition pg let pg be a program nd f fn and be the names of nd and and be the arity of we define the denotation pg as follows we define a node environment k to be the least solution of the following recursive equation k » k f nd k fn k k ­ the node environment k thus obtained is used in the following note the type see pg k we need the following lemmas for def ­ to make sense these follow from the fact that all the constructs in the denotational semantics are continuous which is proved in appendix a lemma for any node nd and any k the function nd k cm cn is continuous therefore the function on the righthand side of is indeed a node environment lemma the recursive equations ­ have least solutions proof by the continuity of the relevant operations including » j j x s xm sm y e jk yl el jk ­ and lem type system for safety guarantee we now present a program logic for is a firstorder functional language therefore as usual our logic takes the form of a type system there we identify types with predicates our type system is rather restricted and is solely at the partial guarantee of safety that is it gives no guarantee in the e b nodes nd programs pg x c e e e × e e e e e if b then e else e f e em where x c c j n b f and k n true false b b ¬b e e e e where e ei » node f x xm returns e en ­ where y e y e yl el where f xi yi ei ei x xm y yn are all distinct and the variables occurring in ei ei are restricted to xi and yi nd nd where nodes and the node names occurring in or are restricted to f fm and the distinct names of nd and table syntax of x jk j x c jk c c e e jk e jk n e jk n ´ nn where × e e jk e e jk jk e e jk jk e e jk j e jk jk k ´ e jk ´ if the length of e jk is at least j if the length of e jk is k and k j if b then e else e jk if b jk n then e jk n else e jk n ´ nn f e em jk k e jk em ´ jk true jk tt tt false jk ff ff b b jk b jk n b jk n ´ nn ¬b jk ¬ b jk n ´ nn e e jk e jk n e jk n ´ nn jk e jk n ´ nn e e jk n e jk n e jk n if n or e e jk n if e e jk n table denotation e jk b jk case of nontermination our focus on partial safety is by and is much like common program logics we leave as future work verification of liveness properties the latter necessarily involves the analysis of termination ie in stream processing remark for functional stream processing languages type system with the · modality is wellknown its concern is for the ie totality termination of stream computation this is orthogonal to ours partial safety in semantics of stream processing subject to types is proposed using an alternative to the cpo semantics which we have its being that one can form a semantic domain consisting solely of total streams ie cn instead of c application of these results to and further to sprocdt is left as future work type syntax our type syntax is from that of dependent type systems the latter are known for their expressiveness and have been used for verification of higherorder programs eg in our type system as a feasibility study of the methodology is much more restricted see example a p v c a a a × a a a a where v var and c c true false p p p p ¬p a a a a a a v n p v c p where v var and a ai q vn u c p where u v var p and u v q vn p where v var p and v where m i i n table type syntax for definition types for the syntax of our type system for is shown in table the set is that of arithmetic expressions each of which denotes a number in c we assume a countable set var of vari ables note that this is different from the set of stream vari ables the up operation see § is included for a later use the set is that of assertion formulas it follows the usual syntax of firstorder predicate logic a type for is an expression q vn u c p it consists of variables u v a formula p and the q n c its informal meaning is u c p v × u c p v × u c p v × · · · that is the set of streams s such that its nth element u sn and v n satisfy p for each n n a type for is similar t q vn p if tn is equivalent to p with v n for each n n a node type m n represents the set of nodes of arity m n that when with streams satisfying m output streams satisfying n in the expression q vn u c p the variables u and v are bound we identify types modulo renaming of these bound variables the same is true of v in q vn p example the type q vn u v u specifies that the elements s s of a stream s are real and our types can thus express safety properties regarding the limitation of the expressive power it is straight forward to extend the type system with stream types of arity k q vn u uk p ¯ where u uk v this extension allows us to about among distinct streams so can we about between input and output we can auxiliary output streams that copy input streams and compare them with the output furthermore we can express temporal properties to see if a stream s is increasing we can check if the pair s s satisfies the binary type u u u in this paper we restrict the presentation to unary stream types for the sake of simplicity this is not to say that the type system is expressive for example the type judgment x y if x y then y else x whose validity is not hard to see cannot be derived by the typing rules in its derivation one would need a type which is due to the free variables x y in it the syntactic restrictions in table compared to a dependent type the type system for example we do not need the wellformedness condition of type environments which is usually needed in dependent type systems see eg these restrictions is future work type semantics definition valuation a valuation is either undefined or a function l var c the set of valuations is denoted by val that is val var c the function update lu c cm with l val ui var and ci c is defined by lu c if any of ci is the usual function update otherwise therefore if the length of s c is not more than n valuation lu sn is defined to be definition semantics of the denotation a l c of an arithmetic expression a under a valuation l val is defined in the usual manner we define between valuations and formulas in the usual manner too for example l def l or a l r l v np def l or lv n p for any n n and so on in particular the valuation val satisfies any formula a formula p is valid p if l p for any l val definition semantics of types between a s c and a type s is defined by s q vn u c p def lv n u sn p for each n n and l val note that the valuation l in the definition is because of the restriction that u v note also that when sn then lv n u sn is def which satisfies p this reflects our focus on partial correctness when the computation does not when the length of s c is l and its l th element never gets does not matter what the type specifies about the l th and later elements of s similarly between a t b and a type the satisfaction relation t is defined as follows t q vn p def for each n n tn or tn tt lv n p for each l val ´ that is tn if and only if p nv finally between a continuous function g cm ct cn and a node type the satisfaction relation is g s » sm s m s s sn · · · sm · c n def ·· sn gs sm ­ type derivation in type judgments we have two kinds of environments definition type environment a stream type environment x xm m is a finite set of pairs of a stream variable xi and a type i we require x xm to be distinct similarly a node type environment f fm m is a finite set where fi is a node name and is a node type with the same arity we denote the sets of stream and node type environments by and respectively notation we sometimes write x in this case it is assumed that x is in with some and x denotes this unique definition type judgment in our type system for we have four classes of type judgments here is a · e meaning the expression e is of the type if the variables denote the streams to and the node names denote the nodes to · b b meaning the same between expressions and types · nd meaning the node nd is of the node type if the node names denote the nodes that to · pg meaning main node is of the node type definition type derivation the typing rules for are as shown in table we write j if the type judgment j is derivable type soundness definition between a stream variable environment j c and a stream type environment x xm m we define j by j def i for each i m here the latter is as defined in def similarly between a node environment k and a node type environment f fm m we define k if and only if i for each i m lemma the c ie the empty stream satisfies any type that is the same for b similarly we have for and for definition validity of type judgments we say a type judgment e is valid and write e if for any j and k j and k imply e jk the validity of the other three classes of type judgments is defined in the same manner theorem type soundness a derivable type judgment is valid that is j implies j proof the proof is mostly straightforward by induction in appendix d we show some cases the cases node and prog involve the principle of fixed point induction the processing language sprocdt sprocdt syntax definition sprocdt the syntax of sprocdt is the same as that of table except that we have two additional and r dt in the set e x c e e · · · the same as in table dt e r dt e where r r in sprocdt we call the elements of expressions the same for too intuitively the stream expression x x c q vn u c u c const ei q vn ui c pi for i v nu u u cp p u u u e e q vn u c p p × ei q vn u c pi for i v nu c v j p p v j pv e e q vn u c p b q vn pb ei q vn u c pi for i v nu p p pb p p ei e i for i if b then m e else f e q vn u m c p e v em k nu c p p e q vn u c p n cs if bi q vn pi for i b b q vn p p for i and true false are similar ei q vn ui c pi for i v nu u cp p p u e e q vn p equal e c p v nu cp q vn p p ei c pi for i v nu u cp p p u b e q vn p e v p b q vn p less xi i for i m ej yj for j l ek k for k n node nd v n u m c pi » node f x xm returns yl el v e n u en ­ c qj qj m for j n n where i c pi i q vn u c pi j q vn u c qj j q vn u c qj ´ nd m n fi for i m prog nd fi is the name of the nodes table typing rules for dt represents the constant stream dt dt each dt is thought of as a positive sampling interval in tion to for the delay by j steps we now have r dt for delay by infinite steps with dt being the sampling interval dt is the sampling frequency therefore delay by r dt steps means delay by r seconds for the semantics of sprocdt we use the second key idea of execution see § in it an sprocdt program is first split up into its sections each section is an program and hence is interpreted in a usual manner § the outcome of each section is up and the outcome of the original sprocdt program in § we formalize this idea in the terms of § definition section ei of sprocdt expressions let p be an sprocdt expression for each i n its ith section pi is the expression obtained from p by replacing the stream expression dt with i the operator r dt with sprocdt semantics we repeat the development of the semantics of streams with via interpret sprocdt here we rely on domain theory formulated in an setting its details are found in appendix b part of which already appeared in definition environment for sprocdt the set of stream variable environments for sprocdt is the transform of for recall that c by lem a variable environment for sprocdt is precisely an internal function j c similarly the set of node environments for sprocdt is the transform of that for we shall first define the denotation e jk c of a expression e in sprocdt under j and k this is done we proceed exploiting the machinery in § finally leading to def given e in sprocdt each section ei def is an expression its denotation def yields a function ei × ct c its continuity is proved in lem a we collect ei for each i this results using lem in the following function m ei ´ in × ct c lem b × ct c the last denotes the space of continuous functions def b whose details can safely be for the moment definition e b the denotation e of a expression e in sprocdt is defined as follows us ing e m ei ´ in × ct c the denotation b × ct b of b in sprocdt is defined in the same manner we now interpret nodes and programs in sprocdt there are two equivalent ways to do so here we present the definition that is similar to def this is more convenient for the later use in § see rem for the other definition definition nd pg given a node nd in sprocdt of arity m n its denotation nd is defined by nd m ´ in ct cm ct cn ´ where ct cm ct cn is as defined in def its continuity is proved in lem a for a program pg in sprocdt of arity m n its denotation pg is defined similarly by pg m ´ in ct remark a of the definition of nd def is that the relationship between nd and e for e occurring in nd is not visible at all conceptually this is in fact we can define nd directly from e like we did in solving a equation in the for the latter we use the technique presented in see appendix b especially lem b the two definitions indeed coincide see appendix c for details sprocdt type system for safety guarantee we introduce a type system for sprocdt as a transform of that for it might be hard at this stage to make sense of a s satisfying a type it will be used in our main theorem thm sprocdt type syntax a p v c a a a × a a a a dt dt where v var and c c true false p p p p ¬p a a a a a a v n p v c p where v var and a ai q vn u c p where u v var p and u v q vn p where v var p and v where m i i n table type syntax for sprocdt definition types for sprocdt the syntax of the sprocdt type system is in table it is almost the same as that for table the differences are we have dt that represents an sampling interval quantifiers in and stream types are taken over n c instead of standard numbers we define sections of type expressions this is like def definition section of type expressions the ith section pi of an sprocdt type expression p is obtained from p by ing dt with i quantifiers v d replacing where d dt with i n c with replacing quantifiers v d and replacing v n and u c in the stream types q vn u c p and q vn p by the standard quantifiers a section pi is obviously an type expression sprocdt type semantics definition valuation for sprocdt the set of valuations for sprocdt is val the transform of the set val var c in def by a valuation for sprocdt is either an internal function l the function update val ui var and ci c is the transform of the corresponding ation in def namely the latter induces a function by val × var × c val l uc lu c its transform under in is an internal function val × var × c val we the injection var var from lem and obtain val × var × c val we define the function update by lu c l u c definition semantics of the denotation a l c of a under a valuation l val is defined as follows it is when l otherwise v l dt l a a l lv c l c a l where × in the first line var var and c c are from lem in the second line recall that i n rem thus dt l is in fact the number in § in the last line c c is the transform of the satisfaction relation l p between l val and p is defined in the usual manner for example l a a def l or a l a l r a l a ´ l a formula p is valid written p if l p for any l val we shall characterize this semantics in a manner so that we can later apply theorem lem for each a in sprocdt its section ai determines by def a function ai val c thus by lem we have m ai ii val c lem val c similarly a formula p for sprocdt determine m p i ii val b val b m p i ii b b lemma between def and ­ the following hold a l m ai ii l p m p i ii tt p m p i ii tt the next definition is parallel to def definition the satisfaction relation between a s c n c where is due to lem b and a type q vn u c p is defined by s q vn u c p lv n u sn def p for each n n and l val in the setting of the previous definition each section i c p i determines a function by def q vn u c p i ´ c b therefore by lem we obtain m q vn u c p i ´ ii c b lemma between def and the following holds s m u c p i ´ ii s tt similarly for types and node types the satisfaction relations are defined much like in def see appendix d they have the following too lemma t q vn p g m m q vn p i i ´ iii t tt ´ ii g tt sprocdt type derivation typing rules in sprocdt are almost the same as in in particular the use of is transparent this reflects the idea that standard numbers and are logically the same definition type environment a stream type environment and a node type environment for sprocdt are defined in the same way as in def the former is a finite subset xi i var × we denote the sets of stream and node type environments by and respectively definition type derivation the type judgments and the typing rules for sprocdt are the same as for table except for · they are transformed that is the quantifiers c x c etc are replaced by the corresponding c x c etc · we have the following two additional rules r dt is similar to there r dt is short for r × dt dt q vn u c u dt dt r e dt e q vn u c p r dt sprocdt type soundness definition the satisfaction relation j between j def and def is j def j xi xi for each i m where xi is the image under var var lem the satisfaction relation k between k and is defined in the same way definition validity of type judgments we say a type judgment e is valid and write e if for any j and k j and k imply e jk the validity of the other three classes of type judgments is defined in the same manner lemma validity of a judgment is determined e m i i ei iii tt finally we come to soundness its proof is totally modular exploiting the of s it is that the content of rules does not matter as long as they are sound for theorem type soundness of sprocdt a derivable type judgment is valid in sprocdt that is j implies j signals as we introduce a translation between signals and this enables sprocdt to model signals and its type system to provide signals safety guarantees such signals cannot just be any function f r c we introduce a certain class of functions that makes the translation work def the class is closed under common operations like integration and too the basic idea of a translation between signals and § is already in where they establish the correctness of their translation for functions f r r that are everywhere continuous they also an extension to continuity since we aim at hybrid applications our class of functions def is and contains some examples such as a ball in for simplicity we prove results for the signals and streams extension to ones is straightforward we can separate real and parts and identify c with r signals functions that are right continuous with left limits everywhere play an important role in the theory of stochastic processes they are called our class of continuous enough signal is based on this definition signal a function f r r is of class if it is right it has left limits f t for each t r and its right derivative fr tt is of class a function f r r is of class if it is right continuous and has left limits everywhere a function f is of class if it is of class for all n n a function f r r is said to be a signal if it is of class and for any t r there is such that f is of class c in the interval t t signals denotes the set of signals many common hybrid dynamics are f fr indeed signals in our sense but not all of them a first example o t o t of the modeled as a signal on the right however if we re f time and flip the re is not a signal the halting point o t o t t has no interval t t in which the function is of class c another arises from the ation in the function f t e t sin t if t if t around t very fast but very small due to the factor e t it is a signal however comparison with results in a non is clearly not right continuous at t our notion of signal still has reasonable closure properties lemma a signal f signals is right and resulting again in signals remark the notion of function is used mostly in the context of stochastic systems this is also the case in the hybrid system literature our use of the notion suggests it might also be related to the question of see eg though the details are yet to be out signals as we define the sampling map and the signals r map and show that they form r r faithful translation of signals into that is roughly f recall that in we are restricting to definition signals r is defined by h m f j i jn ii i this is exactly the sampling put in the terms here f j i jn is in r for each i i n hence by lem we have m f j i jn ´ ii belong to r the converse operation need not yield a signal or even a function r r the stream in need not converge that is in the terms the f t f t ´ can be an infinite number this results in the extended output type r r in the following definition of definition the mapping r r r is defined as follows let h r and t r the latter induces a function i from i n to n lem yields m i as an element of n this is to h r n r lem b and we define h m i id is put precise using def theorem for each f signals and t r the t is limited and f t modeling signals in sprocdt from this point on we are back in the setting we rely on the definitions and results in extended from r to c soundness of signal verification via sprocdt relies on the correct modeling of a signal f as an sprocdt program cf the usage scenario in § its extensive the translation of and diagrams into sprocdt programs will be presented in another here we present some basic results definition sprocdt model let f signals a expression e in sprocdt is said to be a model of f under j k if e jk f t for all t r it is similarly defined for an sprocdt program pg to be a model of f proposition let e e be models of signals f f under j k for each c c the constant symbol c is a model of the constant signal ct c e e is a model of the signal f f computed pointwise under j k for × e r dt e is a model under j k of the signal f sec f the latter is defined below it is easily seen to be a signal f sec f ft ft r if t r if t r as to lem we also have sprocdt programs for right and integration we leave them to another in example we have used an sprocdt model of the curve where the latter is defined using an its intuitively obvious correctness can be proved by showing that is a solution of the defining the curve safety guarantee for signals in translating safety guarantees from sprocdt to signals the prop q v u p cannot be just all samples only many t r a sufficient condition is given by s being closed it means that the set u v p is closed in c the type syntax for signals is restricted accordingly in particular adding ¬ or makes logical fail definition type syntax for signals a v c a a where v var c c × p true false p p p p a a a a v c p where v var a ai q wr u c p where u w var p and u w where i m i n the set is that of signal types definition semantics of signal types a valuation l is the same as in def l p with p is defined as usual too between f signals and f is defined by f q wr u c p def t r l val lw t u f t p as in def l in the above is since u w definition translation of types to each type expres sion p for signals def we assign an sprocdt type expression it is defined by replacing the signal type q wr u c p with the type q vn u c quantifiers v c with v p c × the idea of is to represent time w in p by the step number v by the sampling interval dt theorem soundness let f signals be a signal and q wr u c p be a signal type assume further that an sprocdt program pg is a model of f def then pg hs f we expect the opposite direction of the theorem to fail in lefthand side guarantees safety also for a time t that is infinitely large we also note that while the signal type syntax def is more restricted than that of sprocdt § in deriving the lefthand side of the theorem one can safely use the full sprocdt type system an example the curve we verify the range of the curve specifically we show that in example satisfies for any real constants t and q wr u c t w u our intuition of the formula in is w t u due to the restricted syntax of signal types def it is written as in by thm it suffices to derive the following type judgment using the typing rules of sprocdt goal goal q vn u where c t v × dt u in its derivation the most significant step below uses the principle of fixed point induction to deal with the recursion s and c in this step is an instance of the node rule table a s c s c × dt b s c c s × dt c s c s s c node returns s where s s c × dt c c s × dt here the type environment inv s c plays the role of an invariant the types are concretely as follows q vn u q vn u c c u u i · · here i is the unit in is goal it is straightforward to derive the assumptions of the derivation of a is in appendix d b is similar c is by therefore we have derived the conclusion of to it we apply the and prog rules and derive our final goal goal the former requires the side condition v n u c u i t v × dt u i · ´ i i · its is proved in a discrete manner using lem see ap d as is always with the logics invariant discovery is the part in sprocdt type derivation in this example we discovered the invariants by solving the recurrence relations derived from the program this is a totally discrete conclusions and future work starting from a familiar framework of a stream processing language its denotational semantics and a type system as a program logic we extended it with a constant dt and obtained a framework for translation of signals into enables us to use deductive verification in sprocdt for certain safety guarantees of signals the logical infrastructure of provides the framework with a rigorous mathematical basis some directions of future work are mentioned in the related work part of § here we add a in this paper we have made one technique namely discrete sampling and thus exact we are interested in use of in other techniques such as the transform type inference for sprocdt is future work due to its character as a program logic the situation would be much like with logics even type checking ie proof search would be undecidable and the challenge would be in invariant discovery acknowledgments thanks are due to the participants of hybrid systems theory and practice for useful discussions in particular to for our attention to functions we are also to the anonymous for their useful suggestions and critical questions and to for letting know of their work which to our we were not aware of until the last stage of the papers preparation ks is supported by for research activity no and by project hs ih are supported by for a no and by mathematical modelling project first program references s abramsky and a domain theory in s abramsky d m and t s e editors of logic in computer science volume pages ­ oxford univ press r c n t a henzinger ph ho x a j and s the algorithmic analysis of hybrid systems theor comp sci ­ r and s a nonstandard semantics for kahn networks in continuous time in m editor csl volume of pages ­ isbn a t b and m divide and types and compilation for a hybrid synchronous language in j and b d editors pages ­ acm a t b and m nonstandard semantics of hybrid systems j comput syst sci ­ s and d modelling of complex systems systems as dataflow machines ­ o and a an operational semantics for simulation engine in r h and w yi editors pages ­ acm isbn m l and j theoretical foundations of stochastic hybrid systems in international symposium on mathematical theory of networks and systems p d n and j a declarative language for programming synchronous systems in popl pages ­ acm press isbn a and m abstract simulation a static analysis of models in t chen d n and w editors pages ­ ieee a and l static analysis of synchronous programs in signal for efficient design of embedded systems in j and b d editors pages ­ acm r on the an introduction to nonstandard analysis springerverlag i and k in nonstandard static analysis of hybrid systems in p and s a editors cav volume of notes comp sci pages ­ springer a e and p a an introduction to nonstandard real analysis academic press g kahn the semantics of simple language for parallel programming in ifip pages ­ n r and n benton semantics of reactive programs in lics pages ­ ieee computer society isbn e a lee and h operational semantics of hybrid systems in and pages ­ isbn z manna and a pnueli temporal verification of reactive systems safety springer isbn m and l editors hybrid systems computation and control th international workshop march proceedings volume of lecture notes in computer science springer isbn h a modality for recursion in lics pages ­ ieee computer society isbn a logical analysis of hybrid theorems for complex dynamics springer isbn a stochastic differential dynamic logic for stochastic hybrid programs in n and v editors volume of lecture notes in computer science pages ­ springer isbn a the complete proof theory of hybrid systems in lics a nonstandard analysis princeton univ press e and a generating polynomial invariants for hybrid systems in and pages ­ isbn s automatic invariant generation for hybrid systems using ideal fixed points in k h and w yi editors pages ­ acm isbn s h b and z manna constructing invariants for hybrid systems formal meth in sys design ­ p and b from hybrid dataflow languages to hybrid automata a complete translation in t and i m mitchell editors pages ­ acm isbn r a survey of stream processing inf ­ k and i programming with a for hybrid system modeling in l m henzinger and j editors icalp volume of notes comp sci pages ­ springer isbn k h and i processing systems nonstandard modeling of continuous signal processing extended version with proofs t dependent types from counterexamples in m v and j palsberg editors popl pages ­ acm isbn s c p and a translating to acm trans embedded comput syst ­ z and p hudak functional reactive programming from first principles in m s lam editor pldi pages ­ acm isbn k r nonstandard analysis of ordered sets order ­ 