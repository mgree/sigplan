information effects p james university university abstract computation is a physical process which like all other physical processes is reversible from the notion of type isomorphisms we derive a typed universal and reversible computational model in which information is treated as a linear resource that can neither be duplicated nor erased we use this model as a semantic foundation for computation and show that the gap between conventional computation and logically reversible computation can be captured by a system our system is structured as an arrow metalanguage that creation and erasure of information as explicit effect operations computations arise from interactions with an implicit information environment thus making them a derived notion much like open systems in we sketch several applications which can benefit from an explicit treatment of information effects such as quantitative informationflow security and differential privacy categories and subject descriptors d formal definitions and theory f semantics of programming languages f studies of program constructs type structure general terms languages theory keywords arrows linear logic quantum computing reversible logic introduction turing that his model was so simple so transparent and well defined that it would not depend on any assumptions about that could be and therefore that it could become the basis of an abstract theory of computation that was independent of the underlying he thought as once put it that he understood paper but he was real paper is different from the abstract that the turing machine uses the turing machine is entirely classical and does not allow for the possibility the paper might have different symbols written on it in different and that those might interfere with one another p the above quote by david originally stated in the context of quantum computing from the observation that even permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm the most abstract models of computation some laws of indeed conventional classical models of computation including boolean logic the turing machine and the calculus are on primitives which correspond to physical processes for example a gate is an logical operation in the sense that its inputs cannot generally be from observing its output and so is the operation of overriding a cell on a turing machine tape with a new symbol and so is a reduction which typically or values in a way that is destructive and our main thesis is that by physical primitives conventional abstract models of computation have also included some implicit computational effects which we call information effects as a consequence of this approach many applications in which information manipulation is computationally significant are put beyond the reach of our conceptual model of computation such applications include quantitative informationflow security differential privacy computing vlsi design and models of computation in more detail in the fundamental laws describe processes in closed systems where every action is reversible open systems which allow processes are a derived notion they can be considered as a subsystem of a closed system which treats the rest of the system as a global environment the analogy to computation and as the remainder of the paper formalizes an computation can therefore be considered as one that with some global environment via implicit computational effects put differently computational models like the calculus some implicit computational effects which following the of programming language research we find useful to expose and study as firstclass entities structure and main results · we develop a pure reversible model of computation that unlike many other models does not an existing model our model is obtained from the type isomorphisms and categorical structures that models of linear logic and quantum computing technically the model treats information as a linear resource that can neither be erased nor duplicated in a way that is of contraction and weakening in linear logic and the and theorems of quantum · we develop an arrow metalanguage that layers effects on top of the pure reversible model above using an arrow abstract type these arrow effects consist of an explicit erase operation that can be used to discard values and an explicit create operation which can be used to introduce and duplicate an embedding of our reversible programming model in haskell along with several examples can be from values this construction has the immediate benefit that the information effects are exposed and tracked by the type system · we show how to translate a firstorder functional language with loops to our reversible model the translation the implicit erasure and duplication of information in the source language as explicit computational effects the translation and its associated correctness proof constitute the main technical contribution of the paper · we establish connections to and explore how the explicit treatment of information effects can benefit applications such as quantitative informationflow security and differential privacy logical and information we review the notion of logical and its connection to information reversible logic work on reversible models of computation established the following fundamental theorem theorem for every finite function bool m bool n there exists an invertible finite function r bool rm bool rm with r n such that x xm y yn iff r rx xm false false y yn the proof of the theorem is constructive intuitively the function is compiled to a reversible function r which takes extra arguments and produces extra results when the extra arguments are each fixed to the constant value false and the extra results are ignored the reversible function behaves exactly like the original function for example the function and bool bool can be compiled to the function bool bool which behaves as follows v v v if v and v then v v not v else v v v a quick of the truth table of the function shows that it is reversible moreover we can check that v v false if v and v then v v true else v v false which that we can recover and if we ignore the first two outputs fundamental theorem already includes some of the basic of our results specifically it establishes that · it is possible to base the computation of finite functions on reversible functions · functions are special cases of reversible functions which interact with a global heap which the fixed constant values and a global garbage which the results and · it is possible to translate functions to reversible functions to expose the heap and garbage in this context our results can be seen as extending in the following ways · instead of working with truth tables we work with a rich type structure and use partial between the types · we introduce term languages for and reversible computations and develop a typedirected compositional translation · we extend the entire framework to deal with infinite functions eg on the natural numbers · we establish that the of the heap and the garbage constitute computational effects that can be tracked by the type system of computation and information work was performed in the context of the work of and that established the result known as the principle relating computations to increase in information uncertainty entropy definition entropy of a variable let b be a not necessarily finite type whose values are labeled b b let be a random variable of type b that is equal to bi with probability pi the entropy of is defined as pi log pi definition output entropy of a function consider a function f b b where b is a not necessarily finite type whose values are labeled b b the output entropy of the function is given by qj log qj where qj indicates the probability of the output of the function to have value bj definition we say a function is if its output entropy is equal to the entropy of its input for example consider a variable of type bool × bool the information content of this variable depends on the probability distribution of the four possible bool × bool values if we have a computational situation in which the pair false false could occur with probability the pairs false true and true false can each occur with probability and the pair true true cannot occur the information content of would be log log log log which equals bits of information if however the four possible pairs had an equal probability the same formula would calculate the information content to be bits which is the maximal amount for a variable of type bool × bool the minimum entropy corresponds to a variable that happens to be constant with no uncertainty now consider the bool bool function not let pf and pt be the probabilities that the input is false or true respectively the outputs occur with the reverse probabilities ie pt is the probability that the output is false and pf is the probability that the output is true hence the output entropy of the function is pf log pf pt log pt which is the same as the input entropy and the function is as another example consider the bool bool function x true which its input the output of the function is always true with no uncertainty which means that the output entropy is and that the function is not as a third example consider the function and and let the inputs occur with equal probabilities ie let the entropy of the input be the output is false with probability and true with probability which means that the output entropy is about and the function is not as a final example consider the bool bool × bool function x x x which its input let the input be false with probability pf and true be probability pt the output is false false with probability pf and true true with probability pt which means that the output entropy is the same as the input entropy and the function is logical we are now ready to formalize the connection between and entropy once we define logical of computations definition logical a function f b b is logically reversible if there exists an inverse function g b b such that for all values v b and v b we have f v v iff gv v the main proposition that and our approach is that logically reversible functions are proposition a function is logically reversible iff it is looking at the examples above we argued that and are not and that not are as expected neither nor and are logically reversible and not is logically reversible the situation with is however subtle and some explanation first note that the definition of logical does not require the functions to be total and hence it is possible to define a partial function that is the logical inverse of the function maps false false to false true true to true and is undefined otherwise that partial functions like are requires some care let the inputs to occur with equal probabilities ie let the entropy of the input be the of one might reason that the output is false with probability and true with probability and hence that the output entropy is which contradicts the fact that is logically reversible the is that entropy is defined with respect to observing some probabilistic event an infinite loop is not an event that can be observed and hence the entropy analysis just like the definition of logical only applies to the pairs of inputs and outputs on which the function is defined in the case of this means that the only inputs that can be considered are false false and true true and in this case it is clear that the function is as expected linear logic is often used as a framework for controlling resource use linearity however must not be with the criterion of information preservation presented here consider x if x then true else true which is equivalent to the constant function x true above in a linear type system that tracks the syntactic occurrences of variables would be acceptable because x is linearly used however as shown above the function is not despite this difference there does however appear to be some deep connections between linear logic and the physical notions of reversible and quantum computing indeed as girard explains pp linear logic a simple and change of viewpoint from other logics and this change has a physical building on the insights of we now turn our attention to defining a logically reversible language with a type structure and a term language a natural starting point for such a language is the notion of type isomorphisms in this section we restrict ourselves to isomorphisms between finite types and show that they naturally lead to a simple programming language which we call in addition to presenting the syntax type system and semantics of we establish that is universal for reversible circuits types the set of finite types b is constructed using sums and products of the primitive type we have the following syntax for types and values value types b b b b × b values v left v right v v v the type has exactly one called sums allow us to create values that we can distinguish using left and right constructors and pairs allow the encoding of tuples thus we have the type judgements v b v b v v b × b v b left v b b v b right v b b two types b and b are isomorphic if we can construct a map between their values the set of sound and complete isomorphisms for finite types is the congruence closure of the following primitive isomorphisms b b b b b b b b b b b b × b b × b b × b × b b × b × b b b × b b × b b × b these isomorphisms are already familiar to us from arithmetic or logic reading as true × as conjunction and as disjunction note however that the isomorphisms do not include some familiar logical in particular b b b × b b b × b b even though these identities are expected in propositional logic they are not satisfied in standard arithmetic nor in any logic that accounts for resources like linear logic syntax and semantics we turn the above isomorphisms into a programming language by associating primitive operators corresponding to the lefttoright and reading of each isomorphism we these operators into the table below swap b b b b swap b b b b b b b × b b × b × b × b × b b × b × b × b b × b b × b b × b factor each line of this table is to be read as the definition of one or two operators for example the third line declares the two operators × b b and b × b each of the two cases of commutativity defines one operator that is its own inverse now that we have primitive operators we need some means of composing them we construct the composition combinators out of the closure conditions for isomorphisms thus we have program constructs that witness id symmetry sym and transitivity and two parallel composition combinators one for sums and one for pairs c b b c b b c b b id b b sym c b b c c b b c b b c b b c b b c b b c c b b b b c × c b × b b × b definition syntax of we collect our types values and combinators to get the full language definition value types b b b b × b values v left v right v v v types t b b swap × × factor c id sym c c c c c c × c by design every program construct c b b has an adjoint c b b that works in the other direction given a program c b b in we can run it by it with a value v b the evaluation rules c v v for the primitive isomorphisms are given below swap left v right v swap right v left v left v left left v right left v left right v right right v right v left left v left v left right v right left v right v right right v v v v v × × v v v v v v v v v v v v v v v v left v v left v v right v v right v v factor left v v left v v factor right v v right v v the semantics of composition combinators is cv v c v v c v v id v v sym c v v c c v v c v v c v v c c left v left v c c right v right v c v v c v v c × c v v v v the use of the sym constructor uses the adjoint to reverse the program we can now verify that the adjoint of each construct c is its inverse in the sense that the evaluation of the adjoint maps the output of c to its input this property is a strong version of logical in which the inverse of a program is simply obtained by the adjoint operation proposition logical c v v iff cv v expressiveness there are several universal primitives for conventional hardware circuits for example and in the case of reversible hardware circuits the canonical universal primitive is the gate mentioned in sec which we can express in as shown below let us start with encoding booleans the type is the type of booleans with left representing true and right representing false boolean negation not is simply swap the gate takes three boolean inputs if the first two inputs are true then the third bit is even though lacks conditional expressions they are expressible using the distributivity laws as we demonstrate given any combinator c b b we can construct a combinator called if c bool × b bool × b in terms of c where if c behaves like a if expression if the supplied boolean is true then the combinator c is used to transform the value of type b if the boolean is false then the value of type b remains unchanged we can write down the combinator for if c in terms of c as id × c id factor let us look at the combinator as if it were a circuit and values are like that flow through this circuit the diagram below shows the input value of type × b processed by the operator which converts it into a value of type × b × b in the left branch which corresponds to the case when the boolean is true ie the value was left the combinator c is applied to the value of type b the right branch which corresponds to the boolean being false passes along the value of type b unchanged xb y b cb b xb right left y we will be many more such diagrams in this paper and it is useful to note some conventions about them indicate a value that can exist in the program each whenever possible is annotated with its type and sometimes additional information to help its role when multiple run in parallel it means that those values exist in the system at the same time indicating pair types when there is a disjunction we put a between the combinators for distribution and factoring factor are represented as other may be used and in each case types or labels will be used to their roles finally we dont draw boxes for combinators such as id commutativity and associativity but instead just the as appropriate the combinator if not has type bool × bool bool × bool and its second argument if the first argument is true this gate if not is often referred to as the gate if we iterate this construction once more the resulting combinator if has type bool × bool × bool bool × bool × bool the resulting gate checks the first argument and if it is true proceeds to check the second argument if that is also true then it will the third argument thus if is the required gate partial o we extend with recursive types and a family of looping operators the resulting language o is still a language of but because it can express infinite loops the may be partial despite this extension the strong version of logical prop still holds for o types and trace operators we extend in two dimensions i by adding recursive types and ii by adding looping constructs the combination of the two extensions makes the extended language o expressive enough to write arbitrary looping programs including nonterminating ones definition syntax of o we extend def as follows value types b x values v v combinator types t b b isomorphisms fold unfold combinators c trace c the remainder of this section explains the new additions in detail first as we illustrate below it is possible to write infinite loops in o and hence the combinators may correspond to partial we distinguish the type of partial from the previous type of total by using the symbol instead of types the finite types are extended with types these types fit naturally within the framework of a reversible language as they come equipped with two isomorphisms fold and unfold that witness the equivalence of a value of a recursive type with all its fold unfold to create recursive values we introduce the notation v with the following type rule v v in other words to construct a value of type we must first have a value of type depending on the structure of b this may or not be possible for example if the recursive type is then to construct a value of that type we need to have a value of the same type ad in contrast if the recursive type is µx x then we can create the initial value left of type µx x which leads to the value left of type µx x and then right left right right left and so on in fact the type µx x represents the natural numbers in unary format the semantics of fold and unfold is simply fold v v and unfold v v trace operators traced categories have proved useful for modeling recursion in the context of the fundamental idea is to add a trace operator with this typing rule b c b b b b trace c b b c b b intuitively we are given a computation c that accepts a value of type b b and we build a looping version trace c that only takes a value of type b as the diagram illustrates the value of type b is injected into the sum type b b by tagging it with the right constructor the tagged value is passed to c as long as c returns a value that is tagged with left that tagged value is back to c as soon as a value tagged with right is returned that value is returned as the final answer of the trace c computation formally we can express this semantics as follows c right v v c left v v trace c v v left v v right v v where for each c is an internal cyclic version of c as before each combinator has an adjoint and the language is reversible proposition logical c v v iff cv v proof the operators fold and and unfold are adjoint to each other the adjoint of trace c is trace c expressiveness we now present several programming examples that illustrate the expressiveness of o these examples are interesting in their own right and are further developed in the haskell code which includes implementations of various recursive functions on numbers and lists of more immediate however is that these examples establish constructions used to compile conventional source language constructs to o as explained in the next sections in the code below we use bool as abbreviation for and nat as abbreviation for µx x in most cases we present the examples using diagrams the full details are included in the haskell code bounded iteration the simplest class of examples takes a number n and iterates a particular combinator n times for example it is possible to write a function even nat × bool nat × bool which given inputs n b reveals whether n is even or odd by not starting with b the iteration is realized using trace as shown in the diagram below where we have omitted the boxes for fold and unfold x nat bool y bool y nat x nat y nat x nat bool y not bool y nat bool the combinator just b b below a value into a larger type this combinator is significant because it shows that o admits nonterminating computations as the adjoint of just diverges on left nat nat unfold b nat b using just we can write add and sub as add just fold and sub sym add the definition implies that sub diverges we can also create for any particular value v a constant function returning v for example we can trivially write functions that introduce the values false and true as bool just just not given these functions we can a value into a left or right for example a a a × id we can introduce as follows nat trace swap fold similarly we can also introduce an empty list of any type more precisely let the encoding of lists be b µx b × x given a type b and a combinator to introduce a constant of type b we can write b which introduces an empty list of type b adding an element to a list can be achieved using a construction that is similar to add accessing the head and tail of a list can be realized using constructions that are similar to sub source language having designed o as a language that the physical idea of we now wish to demonstrate how programming language constructs correspond to open systems which implicitly communicate with a global heap and garbage to make this idea concrete we need a canonical language we use for that purpose a simplytyped firstorder functional language with sums and pairs and for loops the language is fairly conventional and is presented without much discussion we present this language as two fragments the first of these let is strongly normalizing and the second includes natural numbers and for loops for iteration the syntax of let is given below base types b b b b × b values v left v right v v v expressions e x let x e in e left e right e case e xe xe fst e snd e e e type environments x b environments x v the most interesting aspect of let is that expressions may freely erase and duplicate data in ways the extended language includes additionally operations on and a for loop base types b nat values v n expressions e n add e sub e e for x e if e do e the most interesting aspect of the extended language is that it admits partial functions its type system is entirely conventional except for the rule below e b x b e bool x b e b for x e if e do e b here is an example of iterative addition of two numbers n and m in this syntax snd for x n m if not fst x do sub fst x add snd x the not operator over the type bool can be macro encoded as not x case x for the semantics we say eval let e v if e let v according to a conventional bigstep relation mapping closed expressions and environments to values of which we show a few representative cases below x v x let v e let v e x v let v let x e in e let v e let left v e x v let v case e xe xe let v e let v e let v e e let v v e let v e x v let false for x e if e do e let v e let v e x v let true for x e if e do e x v let v for x e if e do e let v and translations an overview the technical goal of the next four sections to is to translate the source language with primitives to the target language o arrow metalanguage the first important point is that the translation is defined via a metalanguage for information effects this metalanguage the typing and semantics of the effects from the remainder of the language thus a role similar to monadic metalanguage in the translation of conventional computational effects eg control operators our metalanguage is defined not by extending the calculus with monadic combinators but by extending o with arrow combinators starting with o instead of the calculus is expected since o plays the role of the pure language in our setting just like the calculus plays the role of the pure language in the conventional setting the choice of using the arrow combinators rather than the monadic combinators is because the notion of information effects does not appear to be expressible as a monad for the purposes of presentation the metalanguage is defined in two stages ml in sec which is used to compile the subset of the source language using two effect combinators create and erase and in sec which is used to compile the full source language using an additional effect combinator thus and focus on the translation from let to and sec handles the translation from to o translation from source to metalanguage the translation from the source language to the metalanguage essentially the implicit erasure and duplication of environment bindings for example the evaluation rule of a pair see sec the environment which can only be done in the metalanguage using explicit occurrences of the create effect combinator similarly the evaluation of a variable projects one value out of the environment implicitly the rest of the environment which again can only be done using explicit occurrences of the erase effect combinator technically we define two translations t let ml and to the first maps the subset of the source to ml sec and the second is an extension that handles the full source and targets sec translation from metalanguage to target this translation essentially needs to compile the effect combinators to the target language the basic scheme is based on idea described in sec an function of type a b is translated to a bijection h a g b where h is the type of the heap that the constant values and g is the type of the garbage that the and outputs once the primitive effect combinators have been translated the arrow combinators then thread the heap and garbage through more complex computations technically we again have two translations one for the subset of the source language and one for the full source language the first translation t ml sec selects particular values for the heap and garbage to embed the effects into the second translation to o sec works for the full language it has an important difference which arises from the fact that there is an inherent between create and erase the operator create is always used to create a known constant while erase is used to erase information that is only known at run time this inherent of the operators is a consequence of the fact that the source language is forward deterministic but lacks backward determinism as we saw in sec o can express the creation and erasure of constants and we this to completely eliminate the heap in of using arrow metalanguage ml to construct our arrow metalanguage ml we simply add the generic arrow combinators to and add the particular operators that model the information effects we wish to model in particular this idea has been the basis of translations similar to ours the literature also includes translations for other languages that share some of the intuition of the translation we present but differ significantly in the technical details if had an operation that introduced values unknown at compile time such as an input operation or a random number generator we would have to the heap we add two operators create and erase which correspond to the creation and erasure of information that is implicit in the semantics of let these operators are not isomorphisms and hence cannot have types they can only have arrow types definition syntax of ml the sets of value types values and isomorphisms are identical to the corresponding sets in see def the extended combinator types and arrow computations are defined as follows types t b b b b arrow comp a a a a × a a a arr a a a first a left a erase the type b b is our notion of arrows the three operations arr and first are essential for any notion of arrows the operation left is needed for arrows that also implement some form of choice the two operators and erase model the particular effects in the information metalanguage the types of the arrow combinators in ml are similar to their original types in the traditional arrow calculus except that arr types to the abstract arrow type instead of lifting regular function types to the abstract arrow type a b b a b b a b b arr a b b a a b b a b b a b b first a b × b b × b left a b b b b b erase b the semantics is specified using the relation ml which refers to the reduction relation for we only present the reductions for the arrow constructs a v v a v ml v a v ml v arr a v ml v a v ml v a a v ml v left a left v ml left v left a right v ml right v a v ml v first a v v ml v v erase v ml ml b the operator erase at type b takes any value of type b and returns which contains no information for any type b returns a fixed but arbitrary value of type b which we call b and which is defined as b × b b b b b left b the two operators and erase along with the structure provided by the arrow metalanguage are expressive enough to implement a number of interesting idioms in particular it is possible to erase a part of a data structure as shown using below it is possible to a value in a sum type as shown using below it is possible to about choices as shown using join below and it is possible to make a copy of any value as shown using below part of a data structure the combinator of type b takes a pair and the second component we apply erase to the second component of the pair and then to arr × b b to the thus we have b b erase b b b × b b second erase arr where second a arr first a arr the combinator that the first component of a pair is defined a value in a larger type the combinator b b b takes a value and it in a larger sum type its definition is involved so we begin by defining the following combinator in b b × b b b × b id factor given values v and v both of type b the application of to left v v produces left v v which moves the left constructor from v to v we use this combinator to implement as follows let us give the input to the name v we first create a default value left v of type b b use to produce left v v and complete the definition by using to erase the default value v thus is arr first arr or b bb b create b y b b b bb bb b right left y the symmetric combinator can be defined similarly about choices join we define an operator join b b b that takes a value of type b tagged by either left and right and removes the tag the definition converts the input b b to × b and then the first component arr arr arr factor copying values as the following lemma shows it is possible for any type b to define an operator that can be used to copy values of that type lemma for any type b we can construct an operator of type b b × b such that v ml v v proof we proceed by induction on the type b · case we need to exhibit a combinator a × and this is given by a arr · case b × b by induction we have combinators a b b × b and a b b × b and we have to construct a the required combinator a uses a and a to the components and then the pairs into place b b b a b b b a b b b b b b thus we can write a a a where is the operator which the pairs as · case b b by induction we have combinators a b b × b and a b b × b we have to construct a b b b b × b b consider the diagram below which has the type b b × b b b a b b b b b b b this combinator b and then applies to one of the copies let us call this combinator a b b b we can do the same with b except that we apply resulting in combinator a b b × b b the required combinator a can be constructed by applying these in parallel and factoring out the results ie a a a arr factor translation from let to ml the translation t maps a closed term of type b in let to an ml combinator c b as the translation is typedirected it must also handle terms with free variables that are supplied by an environment environments a let type environment is translated to an ml type as follows × x × × b a value environment is translated to a value v × × x × v lemma lookup if x b and × is the encoding of then there exists a combinator × b that looks up x in × proof the required combinator a depends on the structure of · case this cannot arise because must contain x · case x b and x x then a · case x b and x x then we know that the required x must be bound in ie x b thus by induction there exists a × b so the required combinator is a a id the translation t we translate a let judgment of the form e b to an ml combinator a × b in such a way that the execution of the resulting ml term simulates the execution of the original term because the evaluation of let expressions requires an environment the evaluation of the translated combinator must be given a value v of type × denoting the value of the environment lemma t and its correctness for any well typed let expression e b t e b gives us a combinator a and a type × in ml such that a × b v b if e let v then a × ml v we simultaneously present the translation and prove its correctness · case erase × we have that erase v ml · case x x b xb × b · case let x e in e e b x b e b a × b a × × b let x e in e b a × b b to construct the required a we first × we can apply a to one of the copies to get b the resulting value of type × × b is the input required by a which returns the result of type b b a b a b thus the required combinator is a second a a · case e e e b e b a × a × b b e e b × b a × b × b as with let we × and use each copy to create one component of the pair thus we have a a a · cases fst e snd e e b × b fst e b a × b × b a × b we have a a and similarly for snd e we have a a · cases left e right e e b left e b b a × b a × b b we have a a and similarly for right e we have a a · case case e xe xe e b b x b e b x b e b a × b b a × × b b a × × b b case e xe xe b a × b a b b y b b b b here we have × and constructed bb using one copy of × and a we then distributed × over b b and resulting in two possible environments × × b or × × b at this point we can apply a and a to these environments resulting in b b which we can join to get the desired result b thus we have a left c arr arr arr a a join translation from ml to the translation t maps an ml combinator a b b to an isomorphism h × b g × b the types h and g are determined based on the structure of the combinator a and are fixed by the translation t the translation is set up such that when we supply h for the heap along with the given input value of type b the compiled combinator produces some unspecified value for g and the value for b that the original arrow combinator would have produced lemma t and its correctness for any ml combinator a b b ta b b gives us c h and g in such that · c h × b g × b · v b vg g v b if a v m l v then c h v vg v as before we present the translation along with the proof of correctness · arr a arr a b a b b b c h × b g × b to construct the required c we choose h g and thus we have c id × a it is easy to verify that c v v assuming a v v · a a a b a b b b a a b c h × b g × b c h × b g × b b c h × b g × b we choose h h × h and g g × g and we have c × id × c id × c × where × × id × · first a given that a b b translates to c h × b g × b we translate first a b × b b × b to c h × b × b g × b × b where h h g g and c × c × id × · left a given that a b b translates to c h × b g × b we translate left a b b b b to c h × b b g × b b as explained next assume c h v vg v we need to prove c h left v vg left v c h right v vg right v here vg and vg have the type g and v b v b and v b we define the required types h and g as shown below h h × b b × b b gg g where g g × b × b b g h × b b × b we construct the required c in terms of two combinators c and c that handle the left and right cases of the input b b we first construct the combinator c that has the following type and semantics c b × h g × b b c v h vg left v to construct c we need the combinator that was defined in sec we can draw a diagram for c as follows hb bb b b h b g c b b b g b b b b b b the combinator c uses c to obtain a value of type b and then uses to construct a value of type b b we can now define c that works on the right branch to be c b × h g × b b c v h vg right v as before we need the combinator but this time at the type b × b b the diagram for c is shown hb bb b b b b b b b b h b bb b b the definition of c takes the value of type b and constructs a value of type b b using and swap given the construction of c and c we can construct the required c as c h × b b g × b b c c × c factor · create create b c h × g × b we choose h b and g and we have c the definition of create is simple because we have taken care to correctly thread a value of type h and create simply this value · erase erase b e h × b g × we choose h and g b and we have c note that this is operationally the same as create the difference is in the types since we have set up the rest of the computation to thread the value of type g through and never expose it to erase a value we simply have to move it to the garbage translation from to o the required translation t o is into to and to o where the intermediate language extends ml arrow metalanguage the arrow metalanguage extends ml with natural numbers and loops definition syntax of base types b b × b b b nat values v v v left v right v n types t b b b b arrow comp a a a a × a a a trace a arr a a a first a left a a erase the types extend the finite types with nat which is an abbreviation for µx x in addition to the usual finite values we also include natural numbers n which are abbreviations for sequences of that end with left the arrow type is analogous to of ml we use a different symbol to emphasize that the underlying are partial the set of underlying isomorphisms extends the ones for finite types with unfold nat nat fold we define nat and hence finally the language includes one additional arrow combinator with the typing rule y y a b b b b a b b in contrast to trace which defines looping computations whose bodies are partial can be used to define looping computations whose bodies may create and erase information the semantics of is similar to that of trace but with an important technical difference the body of the may produce garbage values which collects in a list as the iteration see the last case of the translation to below as before we can any particular value lemma for any type b we can construct an operator of type b b × b such that v ml v v proof this is an extension of lemma the only new datatype is nat we create a and use the loop of sec to iteratively add translation to from to the translation to extends the translation t from let to ml lemma to and its correctness for any well typed expression e b to e b gives us a combinator a and a type × in such that a × b v b if e let v then a × ml v · cases add e sub e these follow from simply lifting the add construction and its adjoint from sec e nat add e nat · case e a × nat a arr add × nat e nat a × nat e nat a × bool where a a arr unfold first erase · case n the required combinator of type nat is given by erase add n where add n is n iterations of add · case for x e if e do e e b x b e bool x b e b a × b a × × b a × × b bool b for x e if e do e b a × b the construction is illustrated in the diagram below in which of type used for erase etc have been for the sake of clarity b b b b b a a b b bool erase b a bool b erase b y y conceptually each iteration of the is determined by the result of a if the conditional is true then the iteration causes a to be executed translation to from to o translation to is similar to t as discussed in the overview sec the significant difference comes from the fact that o can create constants hence eliminating the need for an input heap type the translation only needs to track the garbage produced by combinators proposition for any type b of we can construct b such that ml b lemma to and its correctness for any combinator a b b b b gives us c and g in o such that · c b g × b · v b vg g v b if a v m l v then c v vg v the interesting cases to consider are · case arr c the required combinator is c b × b where the garbage is · case the required combinator is × b with g · case erase the required combinator is b × with g b · case a a b b b b c b b a b b c b g × b b g × b as shown in sec we can create and manipulate empty lists of any given type in o the diagram below is the required combinator c with g g ie the resulting garbage is the list of garbage values produced at each step in the iteration of type g g b g b b g g g just cb b g b b g g fold g b b g b applications the technical contribution of the paper was to designing a semantic foundation of computation which treats information as a computational resource we now briefly explore the application of such a framework to security and privacy quantitative information flow research in the domain of quantitative informationflow security is at tracking the amount of information leakage through a computation instead of ad hoc analyses one can in our framework simply observe the programs types and see how much information has been erased as an example consider a password checker check bool × bool bool which takes a bit user input and has access to a bit secret password the type bool × bool has with probability an attacker the real password log bits learned and with probability wrong thus eliminating one candidate password log log bits learned making the average information log log log one call to the password checker has thus hidden bits of information from the attacker the principle implies that the bits by check must be for by some logically erasure of bits and indeed the minimum any o implementation of check must erase is bits which would manifest itself by a use of erase at type bool × bool the fact that types indicate a lower bound on a programs secrecy further investigation further a analysis allowing us to capture the exact erasure of fractional bits may be achieved by the type system of to track the probability of disjunctive branches such as in the probabilistic calculus and differential privacy physical processes operate on physical representations of values which exist in space and have associated costs eg amount of energy physical processes must not only be reversible but they must do so in a way that respects this additional structure and captured this additional restriction on physical processes using what they called conservative logic in which values can only be around by computation this guarantees that processes maintain whatever cost is associated with the values they operate on in quantum this additional restriction is modeled in a different way using the mathematical structure of spaces specifically the fundamental building blocks of quantum computation are that i quantum states are equipped with an inner product that induces a norm ie a metric and that ii quantum transformations must be unitary ie must be reversible transformations that preserve the norm induced by the inner product they key definition is the following definition given a metric d on values of type a function f is said to be an iff d f x f y d x y for all x y in an development and pierce introduce a calculus for differential privacy the fundamental building blocks of their calculus are i that types are equipped with a metric that defines what it means for values to be close and that ii functions must preserve between the values they key definition is the following definition function given a metric d on values of type a function f is said to be iff d f x f y c · d x y for all x y in other words the distance between the values x and y in the domain of the function cannot be by more than a factor c clearly quantum evolution is restricted to the special case of sensitive functions to further investigate this connection would require us to extend our model by associating a metric with each type however unlike previous work the introduction of the metric in our case would be justified by additional physical considerations conclusions and future work starting with the notion that closed physical systems are the we have developed a pure language in which computations preserve information we show that even what are often called pure functional languages exhibit computational effects related to the creation and deletion of information this development the fact that information is a significant computational resource that should in many situations be exposed to programmers and static analysis tools one of our main contributions therefore is in the information theoretic analysis of computations for example in the domain of quantitative information flow security and the traditional world of type and effect systems the main thesis of the paper is that the study of programming languages their typing their semantics their computational effects and even their security properties can benefit from taking the physical aspect of computation our paper provides the conceptual foundation for such reversible computing our pure language is logically reversible and hence shares some common features with previously developed reversible languages although none are based on the simple notion of isomorphisms between types the practice of programming languages is with ad hoc instances of reversible computations such as database transactions mechanisms for data provenance stack and exception traces rollback version control systems reverse engineering software transactional memories continuations backtracking search and features in commercial applications a possible application of our work is that in principle such reversible programs could be automatically derived from common programs which are typically easier to write by translations similar to the one we presented similarly our diagrams could be directly realized as hardware circuits and the way for speculative execution and backtracking infrastructure in that are inherently reversible and use minimal resources quantum computing many programming models of quantum computing start with the calculus as the underlying classical language and add quantum features on top of it this strategy is natural given that the calculus is the canonical classical computational model however since quantum evolution is reversible this strategy the development of quantum languages as it forces the languages to complicated ways to restrict their implicit information effects a simpler strategy that no generality is to build the quantum features on top of a reversible classical language optimality and equivalence preservation for our purpose of establishing a semantic connection we have made no attempt to optimize the types h and g generated by the translation to the reversible target language for applications concerned with the implementation of o circuits optimizations like in original paper will need to be developed also equivalent source terms may be translated to terms of different types as the types h and g are chosen by the translation based on the syntax of the input terms the situation is similar to the closure conversion translation of a compiler which the type of the environment and the fix should follow the same general strategy higherorder functions as the development of lambda calculi with linear and types shows controlling the creation duplication and sharing of resources is largely orthogonal to higherorder functions furthermore existing work suggests that adding higherorder functions to a language like o can be done in a systematic way as shown for example by the int construction of and in the context of traced monoidal categories or by abramsky and in the context of the geometry of interaction and in the context of the geometry of synthesis these constructions need to explored in the context of o acknowledgments we thank ahmed and for helpful discussions we also thank the anonymous reviewers for their helpful comments and suggestions this project was partially by of the vice for research and the of the vice for research through its research support program we also support from institute for advanced study references s abramsky some paths in process algebra in u and v editors concur volume of lecture notes in computer science pages ­ springer s abramsky a structural approach to reversible computation theor comput sci ­ december s abramsky and r new foundations for the geometry of interaction inf comput ­ may a ahmed and m typed closure conversion preserves observational equivalence in icfp pages ­ acm t and j a functional quantum programming language in p editor lics pages ­ ieee computer society press june h g of the of garbage collection in proceedings of the international workshop on memory management pages ­ springerverlag c h logical of computation ibm j res ­ november w j r p james and a traced symmetric monoidal categories and reversible programming in workshop on reversible computation l cardelli and g on the computational power of in third international conference on algebraic d s and p a static analysis for information flow in a simple imperative language j comput ­ august d the of a di c and h reversible combinatory logic ­ august r types for quantum computation phd thesis oxford university c differential privacy in icalp pages ­ m isomorphisms of generic recursive polynomial types in popl pages ­ acm e and t conservative logic international journal of theoretical ­ d r geometry of synthesis a structured approach to vlsi design in popl pages ­ acm jy girard linear logic theor comput sci ­ r and m an automatic program for lisp sigplan not ­ may l m and k data support for a multiprocessor in pages ­ new york ny usa acm m recursion from cyclic sharing traced monoidal categories and models of cyclic lambda calculi in pages ­ springerverlag j and o danvy a generic account of continuationpassing in popl pages ­ acm l a logically reversible evaluator for the callbyname lambda calculus complex systems j hughes monads to arrows sci comput program ­ a r and d traced monoidal categories math proc ­ w e a reversible machine in international workshop on implementation of functional languages pages ­ springerverlag y the linear abstract machine theor comput sci ­ july r and generation in the computing process ibm j res ­ july x ma j and f a model for computing and energy of devices and circuits j comput syst ­ e and m exact computation of the entropy of a logic circuit in proceedings of the th great symposium on vlsi dc usa ieee computer society i reversible higherorder computations in workshop on reversible computation p security of looping constructs in popl pages ­ acm j l and entropy in proceedings of the ieee international symposium on information theory page a b linear programs in a simple reversible language theor comput sci ­ january y g morrisett and r harper typed closure conversion in popl pages ­ new york ny usa acm e moggi notions of computation and monads inf comput ­ july sc mu z hu and m an injective language for reversible computation in international conference on mathematics of program construction pages ­ p ohearn on typing j program ­ july a d c and h probabilistic lambdacalculus and quantitative program analysis j log comput j and b c pierce distance makes the types grow stronger a calculus for differential privacy in icfp pages ­ acm b j running programs backwards the logical inversion of imperative computation formal aspects of computing ­ a sabelfeld and a myers languagebased informationflow security ieee journal on selected areas in communications ­ p and b a lambda calculus for quantum computation with classical control ­ t reversible computing in proceedings of the colloquium on automata languages and programming pages ­ springerverlag a van a lambda calculus for quantum computation siam journal on computing ­ p wadler linear types can change the world in m and c jones editors ifip tc working conference on programming concepts and methods pages ­ north holland t h b and r principles of a reversible programming language in conference on computing frontiers pages ­ acm h c s a r and a energy as a first class operating system resource sigplan not ­ p logical ibm j res ­ november 