the a dual calculus for unconstrained strategies univ paris paris f paris france abstract we present a calculus which combines a simple representation of finite behaviors with two dual binders and ¯ infinite behaviors are obtained through a fixedpoint operator which is used to give a translation of terms the duality of the calculus makes the roles of a function and its environment as usual the environment is allowed to call a function at any given point each time with a different argument the function is allowed to answer any given call each time with a different behavior this grants terms in our language the power of functional references the for this language comes from game semantics indeed its normal forms give a simple concrete syntax for finite strategies which are inherently this very direct correspondence allows us to describe in terms a number of features from game semantics the fixedpoint expansion of translated terms corresponds to the generation of infinite plays from the finite views of an strategy the duality between terms and corresponds to the duality between player and this duality also gives rise to a lemma the paper is divided into two parts the first one is purely and requires no background in game semantics the second describes the fully abstract game model categories and subject descriptors i languages and systems keywords game semantics lambdacalculus introduction game semantics has proven to be a very effective tool as both a precise and model of languages it was used to give models for many languages and has otherwise been the for many analyses this interest has also made game semantics a subject of investigation this time not as a tool but for itself in particular recently a growing body of work is derived from game semantics but why reverse the roles and a new language for permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm a semantics one answer is that an interesting model has its own coherent structure which may not be present in the initial object in the case of game semantics the model uses a notion of interaction history which both the program and its environment access in a way this gives a precision level which was in fact too high for the first language modeled the purely functional pcf this led to the definition of the and visibility conditions following the presentation in which force the strategy to depend only on a subset of the interaction history this restriction introduces an between the information available to the player and the corresponding to the between a function and its argument thus the duality of the unconstrained model is not visible in the languages syntax later it was shown that strategies give a fully abstract model for a functional language extended with higher order references additionally removing the condition which is also present in yields a language with nonlocal control this correspondence between different restrictions in the model and well known language features is but the languages presented in the works because they contain the calculus as a still do not exhibit the duality that we in the case of for example the set of all strategies is built by a single memory cell strategy is added ones in comparison our approach does not give a special role to strategies instead we use finite strategies which are inherently as our building blocks the set of finite strategies is and it is compact in the set of all strategies syntactically this leads to a very direct relationship between the model and the terms of our syntax indeed long normal forms can be seen as a concrete syntax for finite strategies the syntax that of calculus by adding a ¯ binder for together and ¯ bindings correspond to the game notion of justification which is itself between the player and the in the calculus an occurrence of a variable x represents a call to an argument which was received at a previous point in the history this point being represented by the binder x in the in addition an occurrence of a u represents an incoming call to an argument which was passed at a previous point represented by the calculus is with a confluent set of reduction rules the base language which does not include fixedpoint is strongly normalizing the model is given in a framework of game semantics which we take as simple as possible for this purpose we choose types built from and the operators × and only therefore we do not make the usual distinction between questions and answers moves which are used when modeling base types other than and thus no condition is defined we also do not impose determinism and include plays in strategies the language is fully abstract for this semantics the expressive power of the language is illustrated by a translation of the calculus section and a coding for a section an implementation of the language is available we start with a very simple example which is the translation in our language of the identity yy u yy ¯ details about this translation and the fixedpoint operator are given in section the operator is a nondeterministic sum but for now we will focus on the expression on its lefthand side we can see that the of the initial term are still present in this expression indeed here the translation can be seen as a of the initial term with the following meaning name u this function if the environment calls u it will pass it an argument name it y then call y all the present in that expression are unary meaning it could be written yy ¯ the notation which is automatic after an occurrence of a variable y or of a u represents in the spirit of the ccs or calculus notation · by itself the behavior of the expression yy ¯ only approximates that of the term yy this is because the last constructor ¯ that the interaction stops a better approximation can be obtained yy u yy ¯ here the expression yy u yy ¯ will to the environment call u not once but twice in a row and in the same way by calling the argument y it just received this means that it will have the same behavior as the translation of the term yy when interacting with the translation of the environment xx x c each occurrence of x in the environment corresponding to an occurrence of u on the other hand the expression yy ¯ would have after the first call of x the translation of yy can be expanded to produce interactions of any length the query u as many times as necessary and always with the same behavior this corresponds in game semantics to the condition of for strategies which essentially that any queries must be as if it was the first of its kind this corresponds to the of the program to remember the previous calls and thus to the absence of references terms of the on the other hand do have the power of references as we will see on our next example new r r false m n where m x then if x then diverge else c else diverge n r not r r note here that the use of references in n is necessary for the interaction to reach the subterm c of m indeed a context with an behavior would not be able to separate m from the program diverge when m calls x for the first time n as the boolean true m then calls x a second time and n as the boolean false finally m calls c if n had the same way twice which it would be forced to do if it did not contain references m would have we will present in our language an interaction similar to that of m and n this requires a few first instead of booleans which are absent in our setting we will use the type × with the behavior of representing the value true and representing false thus instead of m we will consider the term m m x c additionally the behaviors of m m and n are infinite whereas as we saw in our first example terms in our syntax more naturally represent finite behaviors for example n as true then false then true etc but the term we will give will only to the first two queries we now consider the interpretation of m as a strategy the picture below shows a play of this strategy in the usual graphical representation note that the labeling x x and c is not part of the play × × xc x x c the moves of the play are represented as in order from top to bottom the first move is the initial query made by the environment the m the player by a move labeled by x the then plays one of two possible moves in the product × m plays x again the this time chooses the second possibility m finally plays c the two possible moves in × correspond to calls to either the first or the second argument passed to x by m simulating a value of either true or false for x in the same way the position of the moves labeled by x or c correspond to m calling either its first argument x or its second one c in both cases the move is placed under the occurrence of corresponding to the return type of x or c this illustrates how the strategy contains all the information of the term in general the positions of the moves are not enough and the justification pointers are also required here they are represented as arcs between moves we now give a more detailed labeling of the play using syntactic elements from our language × × u xc x v x ¯v ¯w w c the label for each move consists of a name followed by zero or more binders in this representation all moves are labeled by a name and all justification pointers correspond to the link between a name and its binder the same could have been done with the calculus syntax but only for player moves when there is more than one binder for example in the label x they distinguish between available moves which could be justified by the current one here either v or w this gives a representation of the position in the with v and w corresponding to the simulated value true and false for x again the same could be said when labeling with the calculus syntax but only for player moves the syntax is dual on one hand are variables x c which label player moves and binders x y on the other hand u v w which label moves and their binders ¯v ¯w this labeling can be obtained in a systematic way given a choice of names for every moves notice that here we chose similar names v w and v w for moves at the same position in the but they are indeed different moves distinguished by their for example the move following x ¯v ¯w could have been justified by x in which case its label would be w resulting in a different play this new syntax can be used to directly represent plays for example the above example is denoted by x ¯v ¯w w c ¯ note that the alternation between player and moves is marked by a and that the sequence ends with ¯ which denotes the empty strategy it has a dual this is a valid in the syntax of the its interpretation is the smallest strategy containing the play in question and its prefixes in a sense a strategy such as this one is passive it for the to make the first move in this work we are also interested in strategies in which the player acts first these strategies are used to interpret terms in the to illustrate we modify by removing the initial move this yields the term x ¯v ¯w w c ¯ we now give an strategy on the corresponding to the type × u y z z ¯ this approximates in our setting the behavior of the program n it to the initial query u by calling y thus as which represents true then to the second occurrence of u by calling z as y z z which represents false as we mentioned before this is only an approximation in the sense that a third query u would be met with no reaction this could be made more obvious by replacing ¯ in by u the obtained being observationally equivalent to note that was also an approximation of the strategy of m this is because and represent finite strategies whereas any nonempty strategy contains infinite plays for example the strategy of m will keep to its initial move as many time as necessary whereas will only to u once we can now represent the interaction of m and n as the interaction of and x ¯v ¯w w c ¯ u yz y u y z z ¯ cc ¯ xc c the interaction operator in is denoted by it con a term and a the result is a term as indicated above reduces to cc ¯ before we give more details about the reduction notice that and are essentially dual and that the of which are not in are precisely those appearing in the result of the interaction this is a fundamental property of the language a normal branch and its dual will each other without blocking when interacting moreover because this dual always exists for any term representing a play as does we immediately have a context which will reach the end of this play here this can be seen as a form of out lemma for the language in this example we obtain a tor between and a term of the same type xc which sim diverges in that it plays no moves the reduction rules of the language are given in section additionally the full reduction of is given in the appendix a we simply illustrate below two of the main points of the rules x xu xu x u xu xu the operator which is created when the dual binders x and are eliminated is called connection it binds both x and u in this first reduction holds for any term and provided that x is not free in and u is not free in the second shows how x and u are also eliminated together once they are connected by the operator this reduction holds for any term and provided that can be put in a certain form for example v the paper is divided into two parts the first part which does not require any background in game semantics describes the language from a point of view its syntax in section the typing system in section its reduction rules in section and its extension by a fixedpoint operator in section a comparison with other languages in section and a lemma in section are also included in the second part we describes the game model we define basic operations on games and plays in section we give the semantics of the language in section and list its main properties including full abstraction in section we expand on the notion of view and its link to history access control in section section discusses future works and in section we conclude syntax we assume two disjoint infinite sets of names variables denoted by x y · · and denoted by u v · · x x l s ¯ u where l is a set of pairs of the form x u called links and s is a stack of the first line defines a syntax of terms v called connection binds all the xi ui and vj in the constructors x and are also binders we note fn the free names of and for fn we write x l when x u l for some u and for u l finally unary operators take precedence over binary operators typing types are of the form t t × t in the examples of the introduction we a for ¬a sequents are of two forms a and a in both cases the environment is a set of the form xi and for the typing rules are given in fig as in section the translation from calculus preserves types modulo the equivalence a × b c a b c in particular the yy ¯ seen in the introduction shares the type of the identity yy which it approximates y ¯ u y y ¯ u yy ¯ u u yy ¯ u yy ¯ reduction rules we define below an equivalence relation on terms and and in figure we define a base reduction relation in this figure a ¯ x a b x a × b b u a a × b x ¬a × b a x ¬a × b x b a u ¬a u u ¬a a a a a a a a b x l s × a v s u l v a a b figure typing rules g g denote guarded ie of the form ¯ or u we then define the relation as the composition b moreover by convention will denote the union of and of the transitive closure of the relation is the smallest equivalence relation such that · it includes renaming · it makes the operator commutative and associative with neutral element or ¯ depending on the polarity · it makes all operators over for example x x x · it contains the following three rules l s l s l s ll note how in the last rule the stacks s and s are with s the to first a term or in normal form exactly when it does not contain the operators or if additionally it does not contain the operator it is said to be a normal branch for example all the terms and named in the introduction are in normal form and all are normal branches except which contains a the main properties of the language are listed in section after its extension with in section but already we can note a property which is specific to the language without fixedpoint proposition the as defined in section equipped with the reduction is strongly normalizing proof each rule in figure has the effect of reducing the size of a term or to which a or is applied thus those toward the leaves of the syntactic tree additionally consider a term or which contains only one or and no then there this is correct in the setting of this work where a welltyped term of the form ¯ is such that is of type however in an untyped setting one should restrict ¯ to be true only if is guarded this restriction is not necessary for g x g x g g ¯v u v b u g ui fn b x g x b x g b u fn b v b u v v u l l x b b s l x x l u l x l l sx ¯v u l sx ¯v w l sx ¯v ¯ b b b l v x u l x u l x u l l ux ¯v w l ux ¯v w l ux ¯v ¯ b b b x ¯v w l x ¯v ¯ x ¯v ¯ x l w l x l w l x l figure reduction rules is one and only one reduction rule which applies together with the equivalence rules which apply to the operator this proves by induction that the reduction only terminates on normal forms fixedpoint and expansion in game semantics strategies naturally represent programs with the power of functional references to obtain the behaviors of purely functional programs this power must be limited using conditions called and visibility states that for a given query of the environment the program must always in the same way the formal definition is in section in this section we will see how translated terms generate this infinite number of identical reaction through fixedpoint expansion we extend the syntax with additional constructions and an additional rule shown below the new fixedpoint names are ranged over by and their variants they appear in the environment as distinguished variables u ¬a a u ¬a u u ¬a u ¬a u u ¬a b the new reduction rule extends the base reduction b defined in figure and thus extends the reduction relation the typing ensures that a fixedpoint name is always guarded by the same u we now define a lifting which takes a term and returns in which u occurs at every possible position in u fn u u v · · · the omitted rules in this definition that passes through every other operator for example and note that the operation applies only to terms while for a given applies to both terms and and preserves polarity as an example consider the effect of on the term xx ¯ ¯ xx u xx u xx u xx u xx u xx u · · · this transforms the finite behavior of of the xx ¯ into an infinite behavior which to the initial query u as many times as needed without the fixedpoint finite terms in our syntax could only describe finite behaviors with the exception of the infinite behaviors due to lack of expansion the operation allows us to define a translation tr from the calculus to the trm m n m xm xm x x ¯ note the initial lifting which makes this translations return an strategy the correction of this translation with respect to the semantics of the and of the calculus in a comparable setting is stated in section in particular this translation preserves the type modulo the equivalence a × b c a b c which corresponds to an equality of the corresponding it does not however send normal forms to normal forms on the contrary the translation of any term except has an infinite reduction path as in the above example but if the term was normal this reduction path consists exclusively of fixedpoint expansion as long as the guard condition imposed by typing is for all occurrences of and this expansion is well it will always produce a move u in one reduction this the definition of terms and which may contain any of the extended language except and we give two examples of the translations action the first is which is simply ¯ which we have already seen a more complete example is given by the once expanded identity ¯ ¯ ¯ y v y v v y u ¯v v u · · · v y u · · · v · · · notice the sequence v y u which illustrates that the is ready to to u in every branch of the terms whose strategy correspond to a program without effect can be described directly as a of the as described in section comparison with other languages the calculus and similar languages there are many between the and the calculus essentially in the behavior of terms without binders or ¯ for example the following reductions are very similar here is to be of a certain form for example v xu x u xu calculus x¯ p xq p in x¯ p two processes xq and x¯ p interact along a shared private channel x whose scope is restricted by x the input x and the output x must occur before p and q can interact with the outside world the same description applies to xu x u the input x and the output u form a private xu channel restricted by and the two processes x and u interact along this channel as can been seen on this example a lifting by x or u corresponds to an action of arity zero x or x¯ no information beyond the action itself is transmitted in that sense the seems closer to a simpler language such as ccs there are other with this language the notion of recursive process definition in ccs a def p where p may contain a is closer to our syntactic fixedpoint construction than to the replication of the calculus note that in our language denote a fixedpoint and not a restriction as in calculus additionally the operator in ccs is similar to ours other aspects of the bring it closer to the fusion calculus this language introduces fusion actions which link pairs of names and shows a complete symmetry between the input and the output whereas the calculus gives a special role to an input of the form which binds y in p when the output x¯ y q does not bind y in q the fusion calculus is more effective at representing shared state between processes and strong reduction strategies involving reduction under abstraction both of which require elaborate encoding in the calculus these two strength are also present in the which represent strategies corresponding to programs with shared states and allows reduction inside any context in particular this allows reduction under abstraction in the image of a term by the translation seen in section but just as the calculus the expressivity of the fusion calculus depends on actions which send and receive channel names whereas our language relies on its system of binders ¯ and in particular this means that we have no which makes reasoning on much simpler additionally in the fusion calculus the are represented as a global equivalence relation on names which is independent from the scope operator in comparison our notion of links is local and represented with binders the we briefly mention this language described in as an other example of a syntactic duality between programs and their environments with two dual binders the µ and µ but the similarity is only in the when a term starting with a µ and an environment starting with a µ interact the two dual binders do not fusion in a single symmetric step as would and ¯ instead such an interaction is a critical pair in which either the µ or the µ may be eliminated and the choice between those two possibility correspond to either callbyvalue or callbyname disciplines in general the duality in this language is a tool to study cbv and whereas in our language there are no critical pairs and the object of study is the power of effects languages with references there are many differences between the and languages with references in particular the one presented in which is a simply typed calculus extended with reference types our language allows reduction under any context and that the reduction is confluent when the language in uses an abstract machine with a store additionally in this work the power of references is obtained by duality and not by via a strategy the expressive power of the two languages can be compared by considering their semantics aside from the differences in the chosen setting integer types and the family construction for callbyvalue behavior are not used here the strategies represented in and in this work are the same with one distinction this difference concerns strategies which are not singlethreaded these are represented in the but not in the language described in singlethreaded strategies only differ from others in that their reaction to initial moves must always be the same this appears clearly in the difference in the example between new r r true m n and in the first case for n to behave differently on its second call a reference r must be defined before the application m n if r was declared inside n this behavior would not be possible as it is not a singlethreaded strategy on the other hand this same behavior is directly represented by more directly a simple strategy can be expressed in the we start with an example in a language with references new r r c r c r this program behaves as c we represent this program in our setting as the interaction of the term defined as the translation of a term with a cell which represents the and will be defined later c c cell c ¯ here receives two variables and these correspond to the read and write methods of the reference both are provided by cell the write method takes two arguments a value and a representing the rest of the program here we can see two successive writes one with value c and one with value c followed by a read we now give the memory cell cell write read val read write the two write and read are the methods mentioned above when the write method is called it takes a variable val the value and k which is immediately called this gives the hand back to the calling term if a call to read immediately follows the memory cell by calling val to show how the strategy answers to a read after two successive writes we apply one step of fixedpoint expansion to the cell read val read write val k k write read val read here we have also applied renaming to val k and this shows that after two consecutive calls to write the will answer any call to read by calling the new variable val note that the other branch of the read val will be discarded as soon as the makes the second call to write to show that cell indeed reduces to c ¯ we give which is the relevant branch of more precisely is a term in normal branch form which is a subterm of some expansion of ¯v u v c ¯ cell l c ¯ c ¯ where l is write read val v k u val v k u duality and the lemma the most feature of our language is the duality between terms and this duality is the representation of the symmetry between the player and the in game semantics in particular it shows that any action taken by the can be matched by the player this allows a strategy to follow and thus to recognize any possible play which is why in game semantics the existence of a between two different strategies is immediate syntactically this translates to the following which is a form of lemma for the and will provide us with when proving full abstraction in section we first define the dual of a normal branch which is obtained by replacing each constructor with its dual and each variable x or u with a new or variable typically denoted by x¯ or respectively we write or for contexts which are terms or lemma for any term of the form where is a closed normal branch and any of the form g where ¯ is the dual of g l g for some set of links l for any of the form where is a closed normal branch and any term of the form g where ¯ is the dual of g l g for some set of links l to illustrate consider the following xx x ¯v ¯w w c ¯ yz y u y z z ¯ l c ¯ ¯ c ¯ where l x u y v z w y v z w note that to obtain this form the equivalence l l ll needs to be used this example is taken from the introduction with the and note · the operator which modification that c is free in whereas was a closed term in the introduction this makes the application of the lemma more direct to make the duality obvious can be rewritten as polarity operations on plays x¯ ¯ we now give basic operators on sets of plays if s is a player starting play and m is an move we define the in which case the value of l is x x¯ v w v w tion or lifting m · s as the sequence m · s where m every linking each variable or of to its dual move which was in s and if the polarity of m and s are here we leave implicit for simplicity a game semantics thread of a play s is a subsequence of moves of s which are all and strategies justified by the same initial move in the following definitions denotes a strategy and the following definitions are those of the standard game semantics but with the following simplifications no distinction is made between questions and answers and therefore starting strategies m an alphabet s a play and a b and x x denote we use letters · · · for strategies to them from elements of the syntax there is no condition there is no condition of determinism and we allow plays in strategies these games can be equipped with a structure of cartesian closed category · prefixes is the set of prefixes of the play s this extends to sets of plays · thread threads is the play obtained by keeping only the an a is a triple ma a a where moves of s which are justified by the first move of s · ma is a finite set of moves called the alphabet of a · a ma p o is a polarity or labeling function on ma p denotes a player move and o an move · a is an enabling relation on ma × ma giving a forest structure on ma and satisfying a a b aa ab b b a a aa o in the second case a is said to be initial the basic and are the with zero and one move respectively given a and b one can build a × b · ma mb · a b the in set · a b iff a a b or a b b as well as a b · hiding as is obtained by removing in s any move not in ma this may leave some moves in s without a pointer · interleaving merging merge s s s b where a is the a of and b is the of similarly merge s s a s b where a is the of and b is the of · renaming s ma the renaming of moves in s for two isomorphic a a this extends to strategies both player and · connection let be a strategy on the a × c b × c where c and c are isomorphic then ab s s c s c · is obtained by removing the justification pointers of each move m in s such that m is initial in a this extends to sets of plays · ma mb · ab a b · b ab a iff b b a or b initial in a a a or b is initial in b and a is we are now able to give an interpretation a in the obvious way for any type a as defined in section for the sake of simplicity we will in general a and a a legal play s on an a is a sequence of moves of a of alternating equipped with justification pointers any occurrence b of a move in s must point to an occurrence of a move a earlier in s with a a b with the exceptions of initial moves which have no pointer the set of legal plays on a is written pa we will also use the relaxed notion of plays which imposes no condition on the justification pointers a strategy on a is a set of legal plays on a a strategy is finite if all its plays are of finite length and strategies the defined above may be called because of the polarity of initial moves we define the allowing plays improves the symmetry between player and and avoids some the cost is that two strategies only on plays will be observationally equivalent semantics the types are interpreted as as seen in section the interpretation for an environment xi is that of the type a × · · · × an and similarly for a a typing of the form a is interpreted as an strategy on the a × a typing of the form a is interpreted as a strategy on the × a in the following definitions we use the notations of the typing rule corresponding to each case in some instances indices are added to distinguish isomorphic · u we note × a × a the of in the following u q · s s this differs slightly from the usual definition of hiding in which some of the moves which their pointer gain a new one if a move which it still exists we close by prefixes here because the condition s c s c plays where q is the only move of the resulting strategy plays on × a we started with this construction as it is the most representative of the of the language the strategy is lifted by an move q but instead of this move being a fresh one it is the initial move in the corresponding to the type of the u recall that this type is necessarily a negation form the existence and uniqueness of q the moves of a occurring in are also renamed to their counterparts in a which is the copy of a contained in the and specific to u this a from the outside intuitively this means that we build plays on a by the first move q then by using an existing play on a we also need to fix the pointer structure which otherwise would show the initial moves of as having a itself justified by q in fact the resulting strategy will only play in if it already q followed by some player move but the type is more and would have allowed moves in to be immediately to reflect this we the moves which are initial in showing that they did not need any justification the same is done for the initial moves of a ie for q · x we note × a × b a × the of in the following x q · s s s b · s b where q is the only player move of the the resulting strategy plays on × a × b × b this construction is very similar to the previous one but must support partial application note that in u the types of u and must match whereas in x the match is only partial leaving b out this translates to moves between two copies of b the first one noted b was already present in the environment as part of the type of x while a new one noted simply b is introduced by the construction the introduction of this new copy is done when we pick plays in while the behavior is enforced by the condition s b s b only moves in the current thread that are justified by the new occurrence of q are copied in this way thus as in the previous construction of u we are extending the behavior of the strategy in the corresponding to a given variable or name by adding a single new thread which is with the negation move specific to that name · we note a × the of and b × the of in the following rename rename merge note the identification of the environments and of the two strategies · we note × a × b the of and a × the of in the following rename rename merge this is similar to the previous construction but with the addition of the implicit connection between the two strategies on the shared type a the remaining constructions are all straightforward · l s we note s × l × × l × s × a the of in the following l s · x here the type changes but neither its interpretation nor the strategy · · · · is the empty strategy · ¯ is the empty strategy · in section we defined the lifting using the fixedpoint this is coherent with the approach of this work but in the semantics it is more natural to proceed in the other direction we will thus define a semantic operation the lifting it is the set of plays s such that all threads of s seen as separate plays are in q · where q is a fresh move and it can be shown that the result is a strategy which satisfies a form of weak it always the same way to the query q the initial lifting move this is close to the usual definition of single strategies the difference is that single strategies may have more than one initial move and are weakly for each of these we now use as the basis for the definition of on one hand the strategy to its initial move as many time as by as on the other hand it contains moves corresponding to the distinguished variable a connection operation is used to link these two types of moves formally we note a × a × the of in prefixes q s · s a × × a s a · s a where q is the only move in in addition to the operations connection and this definition uses elements of the definition of x with the move corresponding to as the lifting move q thus the strategy to start as a first time · we do not write the definition of which is identical to that of a standard variable call lemma these definitions are correct ie each of the above constructions defines a strategy or strategy on the appropriate or properties we have now seen two versions of the and their respective semantics we will now list their main properties when a distinction between the two languages is needed we will refer to the syntax described in section as the base language while the extended language includes the fixedpoint these strategies are captured by of the form · · · where is a syntactic operation defined later in the same section subject reduction lemma if is a term in the extended such that a and then a the dual also holds confluence theorem the reduction relation for the extended is confluent ie for any term we have the dual also holds proof the proof follows the pattern of a proof of the confluence of calculus as described we define a new relation which corresponds to multiple parallel applications of the reduction inside a term or this relation verifies the churchrosser property and its transitive closure is equal to reduction soundness proposition the reduction for the extended is sound and the dual also holds proof as an illustration we detail the case of the rule sx ¯v u v to make the notations more compact we will write ab for a × b and for example for ab moreover a will mean that plays on a and similarly for a we start from the righthand side of the rule v b the s l ¬a s b while x and u have type consider now the lefthand side u x ¯v u q · s sb b s b q · s s u s sb threads sb sx ¯v u b x ¯v u the semantic constructions on each side of the rule send plays of to sets of plays in either sx ¯v u or let s be a play of we can assume that its image in the lefthand side is not obtained from any of its strict prefixes this amounts to say that the conditions of the type s c s c are the moves of b in s are renamed to b which must match moves in b some of which must match moves in b the target the moves of b which will in the end be matched in b are exactly those in the first thread of plays in u ie those justified by the new occurrence of q introduced by the lifting these are exactly those which in b those originally from b are justified by a later occurrence of q which has been these transformations preserve relative order and relative justification additionally initial moves in a copy of b which gain a q or q through lifting are again initial in the image of s as both q and q are absent from it we now compare with the image of s by the syntactic construction of the righthand side this image too contains only moves of b which appeared in s and also preserves the justification structure and the relative order of these moves under our assumption that the image of s in the lefthand side was maximal among its prefixes all the moves of b appearing in s appear in its lefthand side image from this it can be that in s the moves of a and a s and s and and match by tracking the behavior of s in the copies of a s and l as we did for b therefore all the moves of b in s also appear in the image of s in the righthand side and thus the two coincide translation from calculus lemma the translation tr defined in section is correct given a simply typed term m whose type contains only as base type we have trm m where · is for example the semantics of m as a pcf term as seen in and all moves in trm are taken to be questions strategies can also be described directly as the written in the following syntax x x ¯ this intuitively builds strategies which are weakly for every query notice that do not appear explicitly in this syntax lemma for any in the above syntax is the definition of is at the beginning of section in the above lemma we did not mention terms to in the framework of the standard notion of strategies but obviously extends to strategies and the syntax above is one way of defining such an extension full abstraction as is the case in other works including is obtained by the set of finite strategies is compact in the set of all strategies for the order the inclusion in the following we distinguish a and a a lemma for any finite strategy on the a there exists a closed normal of type a such that the dual also holds proof the is obtained using the systematic labeling of plays which we sketched in the introduction each play of the strategy can be represented in this way the obtained are in finite number in our setting have finitely many positions making any strategy a tree and their sum by the operator represents the full strategy note that construction does not use the tight connection between terms and strategies is illustrated by the following proposition proposition for any welltyped term in the extended for any finite play s s b b s b where b is a normal branch the dual also holds proof this is a consequence of the construction used in the proof of full abstraction we now define the observational equivalence as well as an equivalence relation on strategies definition two terms and are said to be observationally equivalent noted if for any context c and any variable c c c ¯ c c ¯ for some and the dual is defined similarly definition for two strategies and we write pe when their sets of plays are equal theorem full abstraction for any terms of the same type in the extended pe the dual also holds proof to prove this we define potentially infinite terms and and prove that both and pe are equivalent to we first show that for any welltyped term and any n n there exists n with n such that n is in normal form up to depth n except for subterms whose interpretation is the empty strategy this is proven by induction on terms and using properties of contexts of which lemma is an example from n we build n in which subterms with empty interpretations have been replaced by then of the form u have been replaced by ¯ the sequence nn has a limit and is defined as the expansion of this limit this potentially infinite term directly represents the strategy up to pe similarly to what was seen in the introduction for finite strategies history access control and the notion of view in game semantics the condition of restricts the information and actions available to a strategy by limiting its access of the history to a specific subsequence called the view in this section we will show how the description of as a fixedpoint expansion seen in section gives a direct syntactic representation of views this new notion is more general and allows to define a more precise history access control we start by the standard definition of the view let s be an play of in the following · if s is of the form s · a where a is an initial move then views a · if s is of the form s · a · s · b where b is justified by a then views views · a · b where b is justified by a an strategy satisfies the visibility condition if for all plays s · a where a is a player move the of a in that play is in views finally if satisfies the visibility condition it is called if its behavior depends only on the current view ie if s s are plays s · a · b s · b pa and views · a views · a then s · a · b where a is the of the behavior of an strategy is characterized by the set of its views the generation of the full strategy from this set is exactly the process of expansion taking the simple example of the only view of the strategy corresponds to xx in the case of there are two views ¯ and y ¯ these can be seen as the states of the program and the moves as the transitions between the states for example the move v is a transition from the first to the second view of this transition leads to a view which extends the previous one on the other hand if the plays the move u from the second view it forces a transition back to the first view this second case in which a transition goes back to a previous state is exactly represented by the occurrences of u in the translated term v y u the occurrences of u can be seen as a goto instructions which points back to the binder in the above there are three such transitions from the first view to itself along u from the second view to itself along v and finally from the second view to the first along u when adding the forward transitions this the with a structure an automaton the difference with an actual automaton is that the alphabet the set of names is infinite syntactically expansion may duplicate binders increasing the number of available names additionally when a transition goes back to a previous state it a new copy of the program a subsequent move may jump between copies in addition to backward or extending the current view for example contains the following play y u x y x ¯v v y ¯ here the second occurrence of v illustrates such a jump the first copy here corresponds to v y ¯ and the second copy by the second occurrence of u corresponds to u x y x ¯v notice that when the plays the second occurrence of v this move cannot extend the current view at this point nor jump back in that view it has to jump to the still first view where the binder ¯v lies syntactically the fact that a backward jump keeps the old view is due to the presence of instead of in the definition of we now formalize the notion of syntactic view let be a term in the extended let be the term obtained by removing all and in the occurrences of a being replaced by if is a normal term then its branches are called the generalized views of the generalized views of a are defined the set of generalized views of a normal term or determines its level of access to the history of the interaction every transition between views which is due to an occurrence prevents the program to follow the transition and to distinguish this play from a one in the previous example this means that the program cannot distinguish between an interaction history containing only one move u or two successive moves u in this example the restriction of information corresponds to the of this is not the case for the cell defined in section this is not it differently to different calls to the read but it is imposed a form of history access control in particular it cannot distinguish between two occurrences of read if a write does not occur between the two this behavior can be seen as form of conditional for the read future work toward better static control of effects section gives a to write static program specifications in the in this section we used the fixedpoint to define a construction we then defined a syntax of terms and which includes this new construction but does not include the u and their binder this forces elements of this syntax to to a certain discipline set by the definition of in this example it was merely to the well known behavior of strategies but this method can be generalized in the previous section we saw that the fixedpoint allows us to describe history access control in a flexible way we used cell as an example of a strategy a discipline other than the of section could be used to formalize this notion of conditional and give a syntax of terms which are guaranteed to respect it this method could also be used to give corresponding to classes of strategies described in other works for example in operators are defined on games corresponding to either the player or the the right to in the history the composition of these operators builds the strategies but taken separately each operator describes a new discipline additionally the modular approach of this work may benefit from a description another example is given by the strategies which were inspired by terms used in decidability results these strategies a very specific discipline their actions the available player moves are restricted according to a first notion of view which is more strict than in the case of but their available information depends on another notion of view which is more lax than for these interaction of such strategies certain properties in particular it does not require a because they are not they correspond to programs with effects but with important restrictions the examples above come from theoretical works but we believe that the ability to define meaningful constraints on behaviors with effect can have more practical applications and that this approach could provide which allow some of the power of effects but still guarantee safety properties conclusion we have presented a language which very directly reflects the structure of game semantics this has allowed us to give a syntactic account of many key concepts of the model we have shown that the implicit in strategies could be seen as a fixedpoint expansion on translated terms we have recognized views in the syntactic branches and seen that the transitions between these views were made explicit by the structure of pointers given by the and the fixedpoint this immediately gave a generalization of views as a flexible way to express history access control beyond we have seen that the power of effects is obtained by of the calculus in other words that this power corresponds to a symmetric access to the history for the player and the this naturally leads to the of through duality any normal branch can be matched by its dual giving a form of lemma finally we have argued that our language gives an interesting method of effects without them entirely which could lead to better static control of effects references s abramsky k honda and g a fully abstract game semantics for general references in logic in computer science proceedings annual ieee symposium on pages ­ ieee s abramsky r and p full abstraction for pcf information and computation ­ s abramsky and g linearity sharing and state a fully abstract game semantics for algol with active expressions in algollike languages hp barendregt the lambda calculus its syntax and semantics volume north holland m and c with interactive types and completeness in logic in computer science lics th annual ieee symposium on pages ­ ieee m and j a logic of in computer science logic pages ­ springer m j and g imperative programs as proofs via game semantics in logic in computer science lics th annual ieee symposium on pages ­ ieee pl curien and h the duality of computation in acm sigplan notices volume pages ­ acm pl curien and h abstract machines for games a the implementation manual r m and pa categorical for strategies in logic in computer science lics nd annual ieee symposium on pages ­ ieee strategies and interaction draft h games and reduction for classical pcf typed lambda calculi and applications pages ­ and on full abstraction for pcf i ii and iii information and computation ­ j full abstraction for functional languages with control in logic in computer science lics proceedings th annual ieee symposium on pages ­ ieee j some programming languages suggested by game models electronic notes in theoretical computer science ­ pa asynchronous games the true concurrency of concur concurrency theory pages ­ pa and n resource modalities in tensor logic of pure and applied logic ­ h sequential logical foundations of computer science pages ­ decidability of all minimal models http j and b the fusion calculus expressiveness and symmetry in mobile processes in logic in computer science proceedings annual ieee symposium on pages ­ ieee a a complete reduction example in figure we show the complete reduction of one of the examples of the introduction the term this figure was obtained as an output of the implementation which is available at x ¯v ¯w w c ¯ u y z z ¯ u x ¯v ¯w w c ¯ u u y z z ¯ u x ¯v ¯w w c ¯ u u y z z ¯ xu cx x ¯v ¯w w c ¯ u u y z z ¯ xu cx x ¯v ¯w w c ¯ u u y z z ¯ c xu x x ¯v ¯w w c ¯ u u y z z ¯ c xu x x ¯v ¯w w c ¯ u u y z z ¯ c xu x x ¯v ¯w w c ¯ u u y z z ¯ c xu x x ¯v ¯w w c ¯ u u y z z ¯ c xu x x ¯v ¯w w c ¯ u u y z z ¯ u u y z z ¯ v x ¯v ¯w w c ¯ xu c x x ¯v ¯w w c¯ u u y z z ¯ xu x u y z z ¯ v x ¯v ¯w w c ¯ c xu x u y z z ¯ v x ¯v ¯w w c ¯ c xu x u y z z ¯ v x ¯v ¯w w c ¯ c xu u y z z ¯ v x ¯v ¯w w c ¯ c xu u y z z ¯ v x ¯v ¯w w c ¯ c w zy u y z z ¯ v x ¯v ¯w w c ¯ c w zy u y z z ¯ v x ¯v ¯w w c ¯ c y u y z z ¯ v x ¯v ¯w w c ¯ c y u y z z ¯ v x ¯v ¯w w c ¯ c y u y z z ¯ v x ¯v ¯w w c ¯ v x ¯v ¯w w c¯ u y z z ¯ c y u y z z ¯ v x ¯v ¯w w c ¯ y v x ¯v ¯w w c¯ u y z z ¯ c y v x ¯v ¯w w c¯ u y z z ¯ c y v x ¯v ¯w w c ¯ u y z z ¯ c x ¯v ¯w w c ¯ u y z z ¯ c x ¯v ¯w w c ¯ u y z z ¯ c x ¯v ¯w w c ¯ u y z z ¯ c x ¯v ¯w w c ¯ u y z z ¯ c x ¯v ¯w w c ¯ u y z z ¯ u y z z ¯ w c ¯ c x ¯v ¯w w c ¯ u y z z ¯ x ¯v ¯w u y z z ¯ w c ¯ c x ¯v ¯w u y z z ¯ w c ¯ c x ¯v ¯w u y z z ¯ w c ¯ c v y z z ¯ w c ¯ c v y z z ¯ w c ¯ c y v w z z ¯ w c ¯ c y v w z z ¯ w c ¯ z w y v c z ¯ w c ¯ z w y v c z ¯ w c ¯ z w y v c z w c ¯ z w y v c c ¯ cc ¯ figure a complete reduction example 