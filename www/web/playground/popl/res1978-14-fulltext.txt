conference record of the fifth annual acm symposium on of programming languages a simplifier based on efficient decision algorithms greg nelson and artificial intelligence laboratory computer science department stanford university stanford california abstract we describe a simplifier for use in program manipulation and verification the simplifier finds a normal form for any expression over the language consisting of individual variables the usual boolean connective the conditional function cond denoting ifthenelse the integers the arithmetic and predicates and the lisp constants and predicates nil car cons and atom the functions store and select for storing into and selecting from arrays and uninterpreted function symbols individual variables range over the union of the the set of arrays the lisp and the booleans true and false the constant function and predicate take their natural interpretations the is that is it simplifies every valid formula to true thus it also a decision procedure for the quantifierfree theory of arrays and the above functions and predicates the organization of the simplifier is based on a method for for several theories into single decision algorithm for a larger theory containing the original theories more precisely given a set s of functions and predicates over a fixed domain a program for s is a program which determines the satisfiability of conjunctions of literals signed atomic formulas whose predicates and function are in s we give a general procedure for combining programs for sets s and t into satisfiability program for s ut given certain conditions on s and t we show how a satisfiability program for a set s can be used to write a complete simplifier for expressions containing functions and predicates of s as well as uninterpreted function symbols the simplifier described in this paper is currently used in the stanford pascal verifier this was supported by the advanced research projects of lhe department of under contract and by the national science foundation under contract mix introduction in this section of the language accepted by our simplifier and give some examples of simplifications we will also define for a set s of functions predicates and constants essentially such a determines the satisfiability of conjunctions of signed atomic formulas whose predicates and function are in s the formal definition specifies the interpretations of the elements of s in such a way that it makes sense to merge satisfiability procedures for two sets s and t into one for s ut section gives our method for doing this based on interpolation craig shows how a satisfiability procedure can be used to implement a simplifier for arbitrary expressions section contains some remarks language accepted by the simplifier the simplifier accepts the usual boolean connective and also the function cond means if p then a b the other functions predicates and constants to which the simplifier currently gives an interpretation are those of the following theories the theory of under addition the theory of list structure with car cdr cons atom and nil and the theory of arrays under storing store and selecting select the are assumed for these functions arithmetic vx vz ax z a we also allow the other arithmetic relations c and by a and the can be defined in terms of o and sin the usual way the above axiom is the axiom for a commutative group with a order a model for the theory with this axiom is the theory of under addition and sz is called z instead of for reasons arrays v qv ve vi vj i e j e j the simplifier accepts store and select functions which operate on arrays or vectors denotes the ith component of the vector v we may write for is the vector whose ith component is equal to e and whose jth component for j i is the jth component of v list structure d vx y x a y y a a y a x note that is not assumed for instance x is regarded as satisfiable let be the conjunction of the above axioms given a quantifierfree expression f the simplifier tries to find the simplest f such that entails f f and returns f in particular if entails f the simplest f such that entails f f is the boolean constant true which the simplifier will return thus the simplifier is a decision procedure for the quantifierfree theory by the results in this paper apply to many logical theories but we will illustrate them with the theories which our simplifier currently handles we use z v and as names for the theories of arrays and list structure we also use these letters for the axioms for these theories note that each theory has exactly one axiom and for their satisfiability programs besides the satisfiability programs z and our simplifier contains a program called which determines the satisfiability of conjunctions of equalities and between terms containing uninterpreted functions and predicates for instance will return unsatisfiable given the formula x y a fx fy is therefore a satisfiability program for the quantifierfree theory of equality with uninterpreted function symbols examples of the use of the simplifier here are some examples of simplifications x fx x true true z o x y o true add v true i j vii this formula expresses the theorem that if the ith and jth elements of a vector v are and if the resulting vector is identical to the original vector then the ith and jth elements were the same satisfiability programs the logical are a v cond v and a of a is any atomic symbol which occurs free in the formula thus the parameters of the formula qv vx px fx a are q p f and a the parameters of the axiom for a theory are the primitive constants functions and predicates of the theory for instance the parameters of are car cdr cons atom nd nil if is an axiom then a term is an if and only if each of its parameters is a parameter of or an individual variable we define and analogously for example x y and x s y are but x s is not we call a term an if none of its parameters are parameters of any axiom that is if all its parameters are uninterpreted we similarly define and formula note that this definition only makes sense if we have already fixed the other theories we are interested in we will assume we have fixed and v a program for is a program which determines whether a conjunction l a a lk of k satisfiable in the theory by that is whether a li a a lk is satisfiable specifies a set of functions and predicates and also their interpretation his makes precise the definition given in the introduction there are efficient satisfiability programs for z v and for z the algorithm is very fast in practice nelson nelson and describe algorithms for and which determine the satisfiability of conjunctions of length n in time n johnson and tarjan have the underlying algorithm to on log n describes an algorithm which runs in linear time if list structure is assumed to be acyclic the satisfiability problem for is npcomplete and sethi but the expensive cases do not seem to arise in practice merging programs in this section we show how to write a satisfiability program for say z a d given one for z and one for it is not obvious how to do this since there may be mixed terms in the conjunction like our method for merging satisfiability programs for two theories will work whenever their sets of parameters are disjoint this is the case for z v and we will also show how a satisfiability program for a theory can be used in conjunction with to decide the of conjunctions of which contain uninterpreted function symbols as well as parameters of the theory we will first illustrate how we merge satisfiability programs example let f be the following unsatisfiable conjunction x s y a y s x a a po the first step is to make each atomic formula that is contain only parameters of one theory we do this by introducing new variables to replace terms of the wrong type and adding equalities defining these new variables for instance the second conjunct would be a except that it contains a term which is not a we replace by a new variable g say and add to the conjunction the equality g defining g by in this fashion we eventually obtain a formula f which is satisfiable if and only if f is such that each literal of f is in our example f is x a g a i gi we next divide f up into three conjunctions fe fz and fl f contains all the literals fz all the literals and fl all the literals here is f divided up into parts fz xy y g e pg true pg g fx g fy l g these three conjunctions are given to the three satisfiability programs z and since each conjunction is satisfiable by itself there must be interaction between the programs to detect the the interaction takes a particular restricted form we require that each satisfiability program deduce and propagate to the other satisfiability programs all new equalities between variables by the conjunction it k considering for example if x s y and y s x are to z it must deduce and propagate to the other satisfiability programs the fact that x y the other satisfiability programs add x y to their conjunctions and the process continues eventually either some satisfiability program will find that the conjunction it has received is unsatisfiable in which case the original formula was unsatisfiable or else the will stop with each conjunction satisfiable in this case one more test described in the next must be made to that the ai is satisfiable in our example this test is not needed let us illustrate this by with our example the satisfiability programs z and have just received respectively fz fe and fl v is not needed since there are no at first only can deduce an equality between variables the equality g g it propagates this equality z can make use of this fact and propagates x y now propagates g g when z receives this new equality it propagates g g now has an inconsistent conjunction and signals unsatisfiable the following shows the received by the satisfiability programs together with the propagated equalities listed in the order in which they were propagated z j xy g xy g g pg true pg false g fx g fy g g unsatisfiable g gg there are several important observations to make first the only interactions that take place between satisfiability programs is by of equalities between variables we prove in section that this is sufficient for completeness it is sometimes necessary to do a as described in section it is important to realize that it is never necessary to propagate nor equalities other than those between variables this is intuitively for instance after receiving g g there was no need for z to propagate that y s x or that x y g even though these were facts since none of the other satisfiability programs could make use of this information none of them knows anything about or further it is that no such as x y need be propagated even though every theory shares and the x y is needed to prove inconsistency only if x y is but if some program that x y it will propagate this fact to the other programs in particular the one that has x y the latter will deduce the inconsistency finally the only satisfiability programs that made use of a new equality such as x y were those programs whose conjunctions contained occurrences of both x and y for instance when propagated g g only z ever made direct use of this equality it is in fact the case that when equalities are propagated the only satisfiability programs that need to receive the equality are those which already know about both variables in the equality joint satisfiability procedure in this section we present a joint satisfiability procedure which combines satisfiability algorithms for several theories we assume that we have just two theories and f with no common parameters the general case follows easily and that we have satisfiability procedures for determining if literals literals and literals are satisfiable given a conjunction f of the joint satisfiability procedure determines whether a f a f is satisfiable fa fb and fe are program variables containing conjunctions of literals make f assign conjunctions to fp fa and fb by the method described in section so that fe contains an a an b a fe a fa a fb a a satisfiable iff f a a is and unsatisfiable if any of fp a fa a fb are unsatisfiable return unsatisfiable propagate equalities if any of the formulas f a fa a fb some equality between variables which is not by both of the other formulas then add the equality as a new conjunct to of fa fb and fe do not it go to case split necessary if any of the formulas f a fa a fb a disjunction u vi v v uk vk of equalities between variables without any of the equalities alone then apply the joint satisfiability procedure recursively to the k formulas fa a u vi vk if any of these formulas are satisfiable return satisfiable otherwise return unsatisfiable if this step m reached there are no equalities to propagate and no case splits to be done and fe f fb are each satisfiable return satisfiable clearly if the procedure returns unsatisfiable then f is unsatisfiable we will prove in the next section that the procedure is also correct if it returns satisfiable the joint satisfiability procedure we have described here is too to be implemented it will be subsumed by the simplification algorithm described in section we conclude this section with an example involving v and z which illustrates case splitting suppose that after step the formulas are fv x a vj y fz xe e true each formula is satisfiable and the whole conjunction is unsatisfiable but there are no equalities to propagate in step in step v propagates the disjunction x e e v x m y each case leads to a contradiction in z as this example shows case splitting is essential to the completeness of the method it is potentially very expensive but we have found that it does not occur frequently in fact v is the only satisfiability procedure in our system which can cause a split z cannot since a conjunction of linear inequalities in can never a disjunction of equalities unless it entails one of the otherwise we would have a convex set contained in the union of two but not in either of them alone which is impossible we can also prove that and never produce splits we call theories which never produce splits convex when z is extended to be a satisfiability program for the integers it will no longer be convex since for example xl entails yz without either disjunct alone however since we need propagate only equalities between variables not between variables and constants such as z will not cause splits unless there are variables equal to respectively the theory of sets which we intend to add to the simplifier is another example of a theory for example x e y z causes a case split correctness of the joint satisfiability procedure the proof of correctness requires several lemmas our first goal is to define the of a essentially the is the strongest boolean combination of equalities between variables which the formula entails for example the of the formula x fa a y fb is a b x y and the of xy we make the following assumptions about the underlying formal system individual variables are from function variables and propositional variables are from other individual variables and there is no quantification over functions or predicates the results of this section hold without these restrictions but the proofs are easier using and less tedious using l we define a simple formula to be one whose only parameters are individual variables for instance x y v z y is but xy is not thus an simple formula is a propositional formula whose atomic formulas are either propositional variables or equalities between individual variables because of the next lemma this also characterizes arbitrary simple formulas lemma every quantified simple formula f is equivalent to some simple formula g g can be chosen so that its individual variables are all free individual variables of f proof suppose f is of the form x x if x is a propositional variable we can take true v false as g otherwise let be the formula resulting from by first replacing any occurrences of x x and x x by true and false respectively and then replacing any remaining equality involving x by false then if vi vk are the parameters of f is equivalent to o v v v since in any interpretation x will either equal one of the vi or else be different from all of them by repeatedly eliminating quantifiers in this manner we will eventually obtain an equivalent quantifierfree formula whose only variables are free variables of f if restriction above is lifted lemma holds only if we allow simple formulas to contain equalities between function variables for example vx fx gx is a quantified simple formula equivalent to the simple formula f g lemma interpolation lemma if f entails g then there exists a formula h such that f entails h and h entails g and each parameter of h is a parameter of both f and g proofi see craig lemma if f is any formula then there exists a simple formula the of f which is the strongest simple formula that f entails that is if h is any simple formula by f then entails h can be written so that its only variables are free individual variables of f proof let gk be the set of all simple formulas which f entails for each gx choose hx so that f o hx o g the only parameters of hx are parameters of both f and ga and hk is the existence of hx is guaranteed by lemmas and now each hk is a propositional formula whose atomic formulas are propositional variables which are parameters of f or else equalities between individual parameters of f an infinite conjunction of propositional formulas over a finite set of atomic formulas is always equivalent to some finite propositional over these atomic so there is a finite formula h which is equivalent to the conjunction of all the ha whose only parameters are free individual parameters of f but any simple formula gk by f is by some ha and so by h we can therefore take h to be the of f if is an axiom the of f is the of a f thus the of x s y a y s x is x y when no confusion can result we will not specify the axiom here are some examples of a y fb ab xy i ej ij xe i ej a xe xy note that the addition of an individual variable as a label affects the y a b o u xa a yb a t xb a ya as a final example to relate the notion of to that of joint here are the of the formulas which appeared in the example of section z i z l j xy y g pg pg g fx g fy g gg xy a gc gg ge gg as we found in section the are inconsistent an essential fact needed for proving the correctness of the joint satisfiability procedure is that these are always inconsistent if the original formula is this is a consequence of the following lemma lemma if a and b are formulas parameters are individual variables s a whose only common then a b obviously the left side of the equivalence entails the right side so we need only show the converse from a a b a b we get a b a b and so by interpolation lemma there is a formula h by a which entails b a b and whose only parameters are parameters of a and b but these must be individual variables so h is simple and therefore b a b writing this as b o a a b and observing that the right hand side of this is simple we have a b or a a b which proves the lemma now we are ready to prove the correctness of the joint satisfiability procedure we will prove that if step is reached f is satisfiable it follows by induction on the depth of recursion that the procedure is also correct whenever step returns satisfiable to show that f is satisfiable it suffices to show that a a a fa a b a fb is not false but by lemma this is equivalent to a a fa a a fb thus it suffices to show that when step is reached the conjunction of the of the three formulas is satisfiable if step is reached f fn and f b all the same set of equalities between variables let s be this set of equalities and let t be the set of all other equalities between variables of f we claim that the interpretation which makes every equality in s true and every equality in t will satisfy a fa and a fb for if it does not satisfy say then would the disjunction of all equalities in t but if this were the case step would have caused a case split and step would never have been reached simplification based on programs in section we define what we mean by an incremental satisfiability program in section we describe how such programs can be used to implement a simplification procedure which is a generalization of a joint procedure in section we discuss some aspects of the efficiency of our simplification procedure in section we discuss some of its incremental satisfiability programs an satisfiability procedure is one which accepts literals one by one and which can determine at any whether their conjunction is satisfiable if in addition it can mark its state accept more literals and later return to the marked state by the which were after the mark it is called now on we will assume that all the satisfiability programs we use are incremental and and that they propagate the equalities and of equalities which are by the conjunctions they have received more precisely a satisfiability program for a theory consists of a global data structure for representing conjunctions of literals together with the following functions for manipulating it if q is the conjunction then currently represented by a where p is a literal changes to represent q a p if q a p is unsatisfiable returns false otherwise if there are any equalities between variables which are by qa p but not by q then returns the of all equalities if there are any of equalities between variables which are by qa p then returns one of these otherwise returns true the current state of changing the conjunction that it represents without before the last call to to the state it was in just to where f is a expression or a boolean constant returns an expression f equivalent to f in this example f is the normal form for f in this context for o returns x and y returns o if x y is by cl will only be called when consistent any decision algorithm can be used to implement a satisfiability program with these properties however it generally requires considerable effort to construct an efficient satisfiability program from an efficient decision algorithm we have implemented satisfiability procedures for z v and the program for is described m detail in nelson nelson and describe the data structure used by all programs except z and describes the programs for and the program for v is trivial it splits whenever it finds a term of the form that is it does the obvious split required by its axiom before giving the simplification algorithm we define the auxiliary function assert which accepts an arbitrary literal splits it into pieces and calls the appropriate assertion functions we define it for the case where there are satisfiability programs for two theories and lo in this program pe pa pb are variables containing formulas divide q into pieces and as described in section set pe pb pa if any of p a pb pe are false return false if any of pa pb pe are return one of these if all of pa pb pe are true return true one or more of the formulas are conjunctions of equalities and the others are true this step will propagate the equalities set each of the variables and to be the formula pe a pa a pb and go to we define the functions push and pop they call the push and pop functions for each of the satisfiability algorithms we also assume the existence of a function which takes an arbitrary term and simplifies it using the information in and it does this by calling the functions for these three theories we omit the details assert push pop and are used by the simplifier as a program accepting arbitrary of the language we have four observations to make about these functions first a term t in an literal which has been replaced by a new variable v in step of some call to assert may in a subsequent call be replaced by another new variable w this is all right since both t v and t w are sent to the relevant satisfiability program second a record is kept of the individual variables generated as labels for terms in step so that can put the back together generated labels by the terms represent it is not necessary to send all the equalities to all the satisfiability programs in step as mentioned in section an equality need only be sent to a program if both variables in the equality are parameters of the conjunction represented in the program fourth it is important to note that assert push pop and do not form a satisfiability program since assert may return a disjunction without doing a case split to determine if any of the are satisfiable it would be possible to change assert to investigate each branch of the disjunction but this is not enough to be of use in a simplifier when a case split occurs for which some but not all of the cases are satisfiable the simplifier needs to branches of the split are satisfiable for example consider the problem of simplifying x e a x to x the simplifier must discover that the satisfiable branch of the split is the one in which x this is why assert returns the disjunction to the simplifier the latter does the case split as described in the next section simplification in this section we will use lisp list notation for expressions our simplifier first puts expressions into cond normal this is similar but not identical to the cond normal form in an expression is defined to be in cond normal form if the following holds the expression does not contain any boolean connective other than cond thus a a b is replaced by the equivalent cond a b false and a try cond a false true no first argument to a cond is a cond thus cond cond p a b c d is replaced by cond p cond a cd cond b c d no expression of the form cond p b is the argument to any function other than cond thus f cond p a b is replaced by cond p f a f b every boolean subexpression other than constant subexpressions true and false is the first argument to a cond for instance a single atomic formula p which is not the first argument to a cond is replaced by cond p true false is replaced by f cond x y true false and cond x y f true f false in practice the transformation required by clause is not carried out if the subexpression is a second or third argument to cond since this would space the cond normal form of cond p a b if a and b are boolean is cond p cond a true false cond b true false but we store it as cond p a b in the discussion below we assume that the transformation has been made we will not consider here how to determine whether a subexpression is boolean cond form is not a canonical form since two syntactically different expressions each in cond normal form may be logically equivalent an expression in cond normal form corresponds naturally to a binary tree whose nodes are labelled with atomic formulas we call this tree the tree for the expression to the expression cond p a b corresponds the tree whose root is with p whose left son is the tree for the expression a and whose right son is the tree for the expression b the tree for any expression e is a node with zero with e thus every node in a cond tree is either an internal node with two sons and a boolean expression as label or a leaf node whose label is either or one of the constants true or false the maximum number of nodes in the cond tree for an expression of length n may be exponential in n but by sharing structure the tree can be represented as a directed graph and the amount of storage required is linear in n let n be a node of the tree then nl n nk is the branch to n if n is th root of the tree nk n and for each nil is a son of ni the context at n is defined to be the conjunction l a a where each li is the label of ni if nil is the left son of ni and the negation of the label of ni otherwise the context of a node is exactly the condition that must hold for an evaluator to reach the node during evaluation of the expression that is if the conditional expression is regarded as a program fragment the context of a node is the strongest invariant assertion on the arc leading to the node for example consider the following expression in cond normal form cond p cond qa b cond r c d the context of the node for b that is p a q is the condition that b would be evaluated if the whole expression were evaluated it follows that the disjunctive normal form of a formula is the disjunction of the contexts of the leaves labelled with true in the cond tree for the formula cond normal form is much more compact than traditional disjunctive normal form because in the former are represented as branches in a tree or paths in a directed graph and thus may share structure to simplify an expression the simplifier traverses its cond tree maintaining as it does so a representation for the context of the node it is it ignores nodes whose contexts are inconsistent besides pruning away the branches which are inconsistent the simplifier together branches to leaves with equivalent labels lf the expression is a valid formula every leaf which is reached will be labelled true all these branches will be and true will be returned similarly an unsatisfiable formula simplifies to false the following algorithm simplifies a formula f which we assume is in cond normal form is a function which returns the cond normal form of its argument if f is not of the form cond p a b return f is of the form p a b call push set q if q false then pop and return p cannot be true so f is equivalent to b in the context in which it appears furthermore the context of b is equivalent to the context of f if q true then set aa otherwise set aa cond q a nil in this case q is a disjunction the third argument to the cond is irrelevant as explained below call pop and go on to step call push set q assert if q false then pop and return aa p cannot be false so f is equivalent to a in the context in which it appears and the context of a is equivalent to the context of f if q true then set bb c otherwise set bb q b nil call and go on to step if aa bb return aa otherwise aa true and bb false return expression cond p aa bb let p p otherwise return if the note how into the oi instance suppose that returns a disjunction d v e in step we simplify the normalized form of cond d v e a nil which is cond d a cond e a nil in simplifying this a is simplified twice once assuming d and once assuming e the nil is never reached since its context d a e is inconsistent with the context of f we will now sketch the proof of the completeness of the algorithm we say that the context of a node is convex if it does not any disjunction of simple equalities without one of the whenever the context of its argument is simplify calls itself recursively on some cond expression thus whenever its argument is not a cond expression its context is convex the proof of correctness of the joint satisfiability shows that if a context is convex and no satisfiability algorithm has propagated false then it is consistent therefore whenever simplify returns from step the context is consistent if f is valid every leaf of its cond tree with a consistent context is with true so every term returned in step is true by induction that aa and bb are always true and therefore that the algorithm is complete comparison with theorem proving we do not know how to give an adequate analysis of our simplifier since its in practice is much better than its worst case behaviour wc our using form with an obvious alternative approach using disjunctive normal form which we call a approach we assume that we are only interested in proving validity of formulas and are not interested in simplifications of arbitrary expressions we assume that the formula is represented as a cond tree with n internal nodes the most obvious algorithm to prove the formula is to put its negation into disjunctive normal form and to test each disjunct for this corresponds to testing that the context of each leaf with false is unsatisfiable the standard approach builds up the context for each leaf from that is from the root of the cond tree the number of call to assert equals the sum taken over all leaf nodes with false of the length of the branch to the leaf this sum on to n and has an average value of on if om considers all binary trees with n internal nodes and all node with true or false to be equally likely there ar no calls to push or pop a satisfiability program can be used our algorithm makes n calls to push n calls to pop am n calls to assert therefore algorithms to zero the number of calls to push and pop while the number of calls to assert ti determine which method is better we would need to know th expected number of calls to assert which each algorithm make on realistic input distributions and the relative costs of satisfiability algorithms and ones the which arise in the stanford verifier are implications between conjunctions of formulas with structure arise in program verification whenever the assertion on a simple loop is a conjunction of if there ar n conjuncts in the antecedent of such a formula and m conjunct in then the disjunctive normal of th negation of the formula has length mn while the cond has only m n internal nodes a ca therefore make as many as mn calls to assert while algorithm will make at most m n calls t assert push an pop on this sort of example our approach seems finding the simplest form in this section we will note some problems with our present simplification algorithm these problems do not arise when our simplifier is used as a theorem prover but only when it is being used to simplify expressions which do not simplify to an atomic symbol such as true these problems arise in the design of any simplification algorithm first a problem common to all normal forms is that they may lose some of the structure of the original expression it s hard to recover this structure if the expression does not significantly simplify for instance using cond normal form the formula a v b v c a d v e v f is simplified to cond a cond e true cond d true f cond b cond e true cond d true f cond c cond e true cond d true f false and cond e true cond d true f is duplicated in three places our simplifier actually converts this formula back to a formula involving the usual boolean connective but the present version of the simplifier does not find the original and simplest form of the expression this has not been a serious problem in our system it only becomes a problem when the original formula is not and is in a form close to conjunctive normal form another problem occurs when simplifying conjunctions like x y a y s x a x y the simplifier that the last is redundant and simplifies the conjunction to x s y a y s x instead of to x y had the equality appeared first both inequalities would have been removed as redundant there does not seem to be any way to handle this problem without extending the set of primitives for manipulating contexts for example if a call to assert made earlier conjuncts in the context redundant this might be detected and exploited it probably would not be too difficult to modify assert in this manner but it might create complications in the simplification algorithm a significant problem concerns implementing the test aa bb in step of our simplification algorithm this is intended to branches of the cond tree which lead to identical for example cond p should simplify to if aa or bb are atomic symbols there is no problem if they contain testing for logical equivalence is possible but probably if they contain no then testing them for equality using the lisp equal will usually be sufficient if puts expressions into a canonical form however there is a difficulty consider cond x f f x which we would like to simplify to f x our chooses f not f x as the canonical form when x is known so in step aa is f and bb is f x a completely adequate test for the two branches would require testing whether qa p aa bb in which case bb should be returned otherwise whether qa p aa bb in which case aa should be returned q is the context of f which is of the form cond p a b again the overhead may be this problem practice section actually arises frequently and is more in than any of the other problems we have mentioned in this notes the language accepted by the simplifier is richer than that described in section all predicates including and boolean connective are considered functions that is functions which evaluate to the booleans true and false are allowed to contain arbitrary expressions expressions are allowed as functions the following simplifications illustrate this generality fx v x true fx f gx the axioms assumed by our simplifier do not enforce strict typing for instance y e is an acceptable expression that the simplifier will simplify to itself we plan to add type predicates or type and a type to next version of our simplifier the does not store conjunctions of atomic formulas as strings or lisp but in a graph with one vertex for each term and subterm in the conjunction another data structure is used to represent an equivalence relation on the vertices two vertices are equivalent if the terms they represent are known to be equal in this context to propagate an equality a satisfiability procedure merges two equivalence classes this can be done very efficiently the details of this representation are given in nelson and using this representation it is not necessary to generate labels for terms which appear in this representation also allows the efficient implementation of other routines in our simplifier more efficient such as push and pop obviously one way to implement push would be to have it make a physical copy of the existing context equally obviously this is not very satisfactory the approach we take is to keep a history of all changes we make to our global data then involves these changes until we reach the context of the last call to push the simplifier includes a decision procedure for the theory of the but not for the theory of the integers in this respect our simplifier does not differ from most theorem provers a satisfiability program for the integers would have to be able to determine whether a conjunction of linear inequalities is satisfiable over the integers this s commonly called the integer programming problem it is much more difficult in practice than the rational linear programming problem most formulas that tend to arise in practice at least in program verification and program manipulation do not depend on subtle properties of the integers further there are some heuristics such as converting x y into x s y which treat integer variables as and work well in practice we also wish to handle multiplication in our simplifier multiplication of two variables by a constant is correctly handled one approach would be to include some heuristics to handle the cases that arise in practice another approach which we prefer would be to implement a decision procedure for the reals under addition and multiplication our simplifier is not a general purpose theorem prover it cannot prove quantified theorems of the predicate calculus however in the stanford verifier it is used in conjunction with a program called the which accepts lemmas during a simplification the the free variables of the lemmas and sends the instantiated lemmas to the simplifier in our system the rule handler stands in the same relation to the simplifier as the satisfiability programs the rule handler can be viewed as a satisfiability program driven by axioms we thank the stanford verification group for their in waiting two years for this simplifier references craig w craig three uses of the theorem in relating model theory and proof theory journal of symbolic logic volume and sethi p and r sethi assignment commands and array structures manuscript johnson and tarjan d s johnson and r e tarjan finding equivalent expressions manuscript y j a basis for a mathematical theory of computation in computing programming and formal systems by p and d northholland amsterdam nelson c g nelson documentation for z unpublished nelson and c g nelson and d c fast decision algorithms based on and find proceedings of the th annual ieee symposium on foundations of computer science october d c reasoning about recursively defined data structures proceedings of the fifth acm symposium on principles of programming languages january 