a parametric segmentation functor for fully automatic and scalable array content analysis cousot new york university institute of mathematical sciences cousot centre national de la microsoft research microsoft research abstract we introduce a parametric segmentation abstract domain functor for the fully automatic and scalable analysis of array content properties the functor enables a natural and efficient lifting of existing abstract domains for scalar variables to the analysis of uniform compound datastructures such as arrays and collections the analysis automatically and semantically arrays into consecutive possibly empty segments segments are delimited by sets of bound expressions and abstracted uniformly all symbolic expressions appearing in a bound set are equal in the concrete the can be naturally combined via reduced product with any existing analysis for scalar variables the analysis is presented as a general framework parameterized by the choices of bound expressions segment abstractions and the reduction operator once the functor has been instantiated with fixed parameters the analysis is fully automatic we first in to and experiment with the abstractions and the algorithms to obtain the appropriate cost then we implemented it into an abstract static contract checker for net we validated the precision and the performance of the analysis by running it on the main libraries of net and on its own code we were able to infer of nontrivial invariants and verify the implementation with a overhead to the best of our knowledge this is the first analysis of this kind applied to such a large code base and proven to scale categories and subject descriptors d software engineering program methods validation assertion checkers d programming languages formal definitions and f logics and meanings of programs specifying and verifying and reasoning about verification assertions invariants f logics and meanings of programs semantics of programming analysis general terms algorithms design languages performance reliability security theory verification keywords abstract interpretation array abstraction array content analysis array property inference invariant synthesis static analysis program verification permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm introduction our goal is to augment static for very large programs with a new fully automatic static analysis determining properties of array elements with good precision but at low cost so as to scale up the approach is in the context of abstract interpretation the first objective of the array content analysis is to reduce the false alarms due to accessing array elements which analysis is often in particular because their proper initialization is unknown the second objective is to allow for automatically proving user provided prepost conditions and assertions of complexity on arrays such as the non relational property all elements are initialized but not the relational one the array is sorted as in to with verification we want to be able to the ratio towards more or less precision one extreme being the classical analysis by array the other being an element by element analysis of maximal precision and cost motivating example let us consider the example in fig extracted from the public constructor of the random class of the net framework the constructor all the elements of the private array to be the initialization process is quite complex relying on some number theory properties which are scope of the paper the precondition requires the parameter not to be the smallest bits integer to prevent from an next an array of elements is allocated and assigned to the last array element is set to the value of whereas all the others are zero because of net semantics the first loop loop sets all the elements of to be according to the indexing sequence leaving the first and the last elements unchanged therefore the assertion at the end of loop holds the next loop loop the values in the array updating the last element of the array but not the first to prove the second assertion one should prove that i the last element of is definitely updated in the inner loop to a value and that ii the inner loop is executed at least once array expansion the first and most precise approach for proving the two assertions i expands the cells of the array to local variables ii fully the loops the example will then become even with hardware and tools we totally the first loop we the second loop according to some interesting variables manually determined and we tried to prove the second postcondition using and the smt solver z we let the verification process run for a whole without getting an answer the theorem prover public int num new int num int num loop for int i i i int index i num num num num if num num num i ai loop for int j j j loop for int k k k k if i ai figure a motivating example taken from the core library of net assert forall is the api adopted in net from v to express preconditions assertions and bounded universal was overcome by the large number of case splits it had to perform because of conditionals in loop bodies and the lack of primitive support for the remainder operation which had to be array at the opposite side of the precision there is the of all the array elements into one summary location it is immediate that this is not going to work for instance in loop the value of is with the others that any value can be written anywhere in the array predicate abstraction the method of qadeer and flanagan uses some easy syntactic heuristics to derive the predicates used for the abstraction which unfortunately do not work here for instance one needs to know that index to determine that the last element of is never in loop or that num both properties cannot be inferred with syntactic heuristics array partitioning the array partitioning approach of reps and sagiv later improved by and the task of array partitioning from that of establishing array properties given a partition of the array into slices the analysis the slices with some abstract value the partitioning is done either syntactically or by some the syntactic approach used in the examples of simply does not work here eg it cannot determine which array element is written at and in general it is in the generic setting of the bytecode analysis where highlevel syntactic structures are compiled away as a consequence at the early stages of this work we tried to implement the second approach in the idea was to first perform a preliminary analysis of indices to provide a restricted domain for each loop and then to perform the array analysis generalizing sect turned out to be extremely bad the first generated too many partition slices also by et al sect the second analysis needed to the index analysis eg to distinguish the first iteration from all the others and the partition analysis eg to track how abstract values between partitions the analysis of the example induced a × with respect to a run of without the array analysis we have therefore developed a new approach subject of this paper in which i the scalar analysis and the array analysis are performed at the same time which is also more precise ii the array segmentation is automatically and semantically discovered by the analysis and iii the segmentation admits possibly empty segments in particular possibly empty segments are a winning choice because they enable a compact representation for array partitions avoiding the exponential multiplication of slices of the works sect yang et al similar advantages when using possibly empty list segments for shape analysis and templates the technique of gulwani and is extremely powerful yet expensive it requires i the user to provide templates for the array invariants and ii the abstract domain to perform for the index variable it can infer all the invariants of our example provided some refinement in the handling of transition functions for quantified facts and in the underapproximation algorithm their technique uses uninterpreted functions and a guess prove cycle to determine for guards unfortunately the abstract domain of uninterpreted functions a complexity which affects the analysis cost according to sect at best the quantified domain induces a of their analyzer and at most a wrt a normal run on small examples as a comparison the functor abstract domain presented in this paper induces a with respect to a normal run on production quality libraries cf sect yet presenting a high precision deductive methods program a la or spec require the user to provide loop invariants in our running example we needed to provide a few to be exact to help both tools prove the assertions in the code first we have to add the invariant on the content of to every loop in the code then we added the loop invariant num i to loop j to loop and k to loop in general such program are very powerful but the impose a burden that very few programmers are to pay for furthermore deductive tools can check the correctness of a program fragment eg a method but they cannot infer facts to be used on larger pieces of code eg class invariants to verify whole classes theorem the method of and uses a saturation theorem prover to generate loop invariants the idea is to encode the changes to an array at the ith iteration as a quantified fact and then to systematically apply resolution to derive a closed form one not the loop iteration i a problem with such a technique is termination for instance to determine when the right loop invariant has been produced by a saturation step this may require a human help the saturation process when a postcondition does not work for instance if we remove the first assertion in fig then the process may go on forever furthermore their method is based on the use of monotonic changes to the array which is not the case for loop and it requires a of causing an extra the techniques of jhala and and of podelski and make use of the loop postconditions to be proven in order to infer the quantified loop invariants suppose we remove and from the example then their techniques unlike ours cannot infer the postcondition that all the elements of are initialized to a value at the end of the random constructor in practice such a postcondition is needed for instance to prove that it is an object invariant for the class random and hence to prove the safety of the public methods furthermore the techniques above do not always guarantee termination the updates technique of and aiken is very expressive and it can be extended to precisely track complex containers properties it is exposed to a potential exponential explosion too their technique is the lifting to the reduced power of a pointsto analysis practically every time an array is accessed or created the pointsto edges are modified new constraints are added and calls to an smt solver are to prove the of the edges and simplify the constraints this may influence the performance of the analysis and also affect the precision whenever the expressions go out of the language treated by the smt solver as for instance the in fig our approach our analysis infers all the invariants for fig without user interaction no templates no annotations nor partitions are required no hypotheses are done on the structure of the source program the invariants are inferred even if the assertions are removed from the code the code is analyzed in a little bit less than for reading the bytecode performing a stack analysis heap analysis nonnull and numerical analysis alone the analysis is an instance of which we introduce in this paper is a functor abstract domain which existing analyses for scalar values to uniform compound data structures as arrays or collections in this paper we will concentrate on arrays but it is immediate to see how the results generalize to collections as found in objectoriented languages such as c or java as well as matrices when instantiating the functor on itself the analysis automatically the array into a sequence of possibly empty segments delimited by a set of segment bounds the content of each segment is uniformly abstracted the array analysis can be combined via a reduced product with an abstraction for scalar variables therefore the has three main parameters i the expressions used to describe the segment bounds ii the abstract domain used to abstract the segment values and iii the abstract domain used to abstract scalar variables when the three parameters above are chosen to be i simple expressions in the form k or x k where x is a variable and k is an integer ii and iii intervals then for loop our analysis infers that all the values of the arrays with in the range are greater or equal to and that the last element of the array is not the uses the information to infer the segmentation below which is enough to prove the assertion values in brackets are bounds intervals denote the abstraction for the array elements in the bounds see sect oo for loop the analysis that all the array elements including the last one have been with a value oo the loop invariant for loop is then the union of the two invariants above that is as the first segmentation subsumes the second one if directly propagated after the loop this invariant is too weak to prove the assertion the is by the fact that we are not considering that the body of loop is executed at least once so that is at least once because of standard static analysis techniques such as loop unrolling or backwards goal propagation sect can be used to recover the needed precision and hence refine the abstract of loop to this another advantage of our analysis which benefits for free of precision refinement techniques applied to the analyzer our contribution the main advantages of our analysis can be summarized as the array segmentation is automatically and semantically inferred during the analysis by semantically we mean that the of the array is done during the analysis using semantic information unlike the approaches which derive the partition by looking at the syntactic structure of the program the segments are consecutive without holes a hole being just another segment the segments derive from the way array elements are modified and accessed segments are delimited by bounds in increasing order denoted by sets of simple symbolic expressions with equal but unknown values the combinatorial explosion in the handling of is avoided by considering symbolic segment bounds as well as possibly empty segments the relations between array and array elements can be inferred by abstracting pairs made of the array index and the value of the corresponding array element vs abstracting array element values only the ratio in the abstraction of the array content can be using a functor abstract domain the array content analysis is parameterized by the abstract domain representing symbolic segment bound expressions the abstract domain abstracting the pairs index value in segments the abstract domain assigning values to segment bound expressions and the reduction between those domains by instantiating the array segmentation abstract domains functor with different abstract domains different static can be automatically generated with different allowing the cost versus precision tradeoff of the analysis to be depending on the target application at no cost of the static analyzer we have first implemented our technique in a research prototype to quickly experiment with the algorithms and the abstractions then we fully implemented it in an static contract checker for net based on abstract interpretation the functor abstract domain enabled a natural lifting of the abstract domains already present in to array contents to the users this is exposed as a simple in the development environment we validated the precision of the analysis by using it to check its own implementation the analysis is extremely fast we the cost of the array analysis on to be less than of the total running time when running it on production code sect to the best of knowledge this is the first analysis of this kind applied to such a large scale array initialization we explain the details of our technique on the initialization example of fig slightly more general than loop we illustrate how we avoid the combinatorial explosion on the partial initialization example of fig and on the array example of fig manual proof a manual proof of the exit specification would involve a loop invariant at program point stating that if alength then i and the array a is empty or else alength in which case either i and the array a is not initialized or else i void a int i while i alength ai i i figure the fully initialized example we want to prove that i alength ai at program point so that a a ai formally the invariant alength i alength i alength j i aj holds at point this invariant shows that array content analyses must be able to i express of array descriptions ii express properties of array segments that is sequences of values of consecutive array elements and iii relate the symbolic limits i alength of these segments to the scalar program variables automatic proof and the meaning of the abstract invariant predicates in our array segmentation analysis instantiated eg with constant propagation we automatically get the abstract invariant predicates p a i t alength p a i t alength p a alength i where pi is the abstract invariant predicate at program point i in this example the properties of scalar variables need not be used the abstract values for constant propagation can be ie bottom meaning unreachable an integer constant meaning equal to that constant or t ie top meaning unknown in the array environments such as a i t alength in p each array of the program such as a has its content described by a segmentation such as i t alength from the symbolic segment bounds such as i and alength we know that i since all expressions in a bound are equal and that i alength since the segment bounds are in increasing order strictly increasing in absence of the segments are not empty except if the upper bound of the segment is marked with the segments are consecutive without holes since a hole can always be represented by a segment possibly empty if the hole may or may not be absent each segment uniformly describes the array elements within that segment bounds lower bound included upper bound in i t alength the array element abstract value is t meaning in the constant propagation analysis that the array values are unknown so the invariant p states that i alength j alength aj z in particular when i alength the interval alength is empty so the quantified expression holds the invariant p states that i alength in absence of question marks these inequalities would be strict that a a ai when i and that the values ai ai are unknown when alength i so the array is divided into consecutive segments which may be empty and are delimited by symbolic expressions in increasing order the abstraction of the array elements within one segment is uniform but different segments can have different abstract properties this invariant can also be written i alength j i aj with the convention that is the empty set in which case aj is not evaluated which is made explicit by a disjunction of cases marked in segmentation bounds in order to avoid combinatorial explosion appear in restricted form only either as possible segment emptiness or symbolic bounds which may have different values or in the segment content analysis see sect for example the postcondition p expresses that either the array is empty ie alength i or else alength i and all array elements are initialized to note that the case alength is this comes from the initial condition stating that alength since most programming languages like c c and java do not allow arrays of negative size we handle all such runtime errors including division by zero index out of bounds by execution this is a sound treatment of their undefined semantics in absence of runtime errors but may otherwise miss some other possible erroneous executions following from the fact that execution goes on in practice with an undefined semantics detailed of the initialization example analysis we now consider the details of the analysis of the code of fig with constant propagation the initial condition alength is recorded in the segmentation of array a p a t alength the assignment i sets the value of the scalar variable i to the equality i is valid after the assignment and so is recorded in the lower bound of the array segment initially p p p denotes of the loop so that the abstract loop invariant is initially p p p p using the join in the constant abstract domain for segments x x x x x i i i and i j when i j p p pi a i t alength the loop is entered when i alength so that the array hence its only segment cannot be empty so is p a i t alength the analysis of the array assignment ai splits the array segment around the index i and assigns to the array element the value of expression in the constant domain that is p a i i t alength note that the segment i i is definitely not empty while the segment i alength may be empty the scalar variable assignment i i is invertible since the old value of i is the new value of variable i by so the segment bounds involving variable i have to be modified accordingly p a i i t alength the next approximation of the loop invariant is p p p this join first involves the unification of the segment i alength of p and that i i alength of p keep ing only the expressions appearing in both we get i alength and i alength split the bound i we get i alength so that the union with i alength can now be performed in the constant domain i alength i alength since the ments may be empty in at least one of the cases that is for nonempty segments and otherwise for possibly empty ones we get p p u p a i t alength the next iteration is similar p a i t alength p a i i t alength p a i i t alength p p u p a i t alength void a int c int i j while i alength if for some predicate p cj i figure partial array initialization techniques use four partitions encoding the fact that at loop exit c may be empty partially filled filled or totally filled our analysis i represents the same information with only one segmentation and ii infers the segmentation automatically so that we have reached a fixpoint it remains to compute p a where alength i since the segmentation of p provides the information that i alength the array content analysis always terminates since the only two reasons for nontermination are impossible the array might have infinitely many symbolic segments as in n n n n which is by segmentation unification and widening a segment might take successive strictly increasing abstract values which is by the use of a convergence acceleration for segment content analysis no widening was necessary for constant propagation which satisfies the chain condition i i z partial array initialization full array initialization is a very well studied example and techniques perform reasonably well on it however partial array initialization fig illustrates the multiplication of partitions which makes those techniques at the end of the loop our analysis instantiated with constant propagation infers the following segmentation for c j t which captures the fact that c may be empty when j i may be not initialized when j may be partially initialized when j i may be fully initialized when j i compare it with approaches where the abstract state at the end of the loop contains four one representing the concrete state when none of the c elements is initialized j two representing the partial initialization of c distinguishing when j or j and one representing the total initialization j we tried this example using our early implementation of and we a × with respect to a normal run of it is worth noting that the experimental results reported in and those in are even worse than our first implementation for this example lifted with the functor abstract domain was so fast that we were unable to measure its impact on the the additional cost is in the order of magnitude the of the virtual machine jit garbage collector ie few array example the array algorithm of fig maintains an invariant a b alength void a i ai ai int a b alength while a b if aa then a a else b b int x aa aa ab ab x figure the array example where positive numbers are on the left of a the negative numbers are on the right from b included and in the middle between a and b the numbers remain to be handled if aa is positive the limit a is moved to the right otherwise aa is with ab and b is moved to the left the algorithm terminates when the central is empty this invariant which is automatically inferred by the automatic array segmentation analysis illustrates the interest of using possibly empty segments p a a b alength a boo p a boo p a b a alength boo abstract domains and functors an abstract domain d includes a set d of abstract properties as well as abstract functions and operations for the partial order structure of abstract properties the join the meet convergence acceleration operators widening and narrowing the abstract property transformers involved in the definition of the semantics of the programming language the abstract evaluation of program arithmetic and boolean expressions the assignment to scalar variables a monotonic concretization function provides the meaning of abstract properties in terms of concrete properties an abstract domain functor d is a function from the parameter abstract domains d dn to a new abstract domain dd dn the term functor is from ocaml terminology the formal parameters d dn of the abstract domain functor d can be instantiated to various actual abstract domains without to rewrite the code of the static analyzer so various abstractions can be at no programming cost the abstract domain functor dd dn abstract properties d dn of the parameter abstract domains d dn to build a new class of abstract properties d eg abstract environments mapping program numerical variables to intervals and operations eg assignment of an interval to a variable for short we can omit the parameters writing d or op when the parameters d dn are clear from the context concrete semantics we describe the elements of the semantics of programming languages to which our array content analysis does apply that is scalar variables simple expressions and arrays and corresponding assignments scalar variables semantics the operational semantics of scalar variables with basic types bool char int float etc is assumed to be concrete variable environments rv mapping variable names i x to their values i v so that rv x v in the following we let alength x be the name denoting the length of the array a simple expressions semantics the program simple expressions e e containing only constant scalar variables and mathematical unary and binary operators have a semantics e in the concrete variable environment so that e rv v for simplicity the values in our examples are chosen to be integers so v z the semantics of scalar variable assignment is as usual i e i e where i vi v and i vj j when j i arrays semantics the operational semantics of array variables such as a a are concrete array environments ra mapping array names a a to their values a a rv × e × e × z z × v so that ra a a in order to be able to relate array element values to their we assume that the concrete value of an array a is a a a a where · rv is a scalar variable environment sect · e is an expression in our examples which value evaluated in the variable environment yields the integer lower bound of the array · e alength in our examples is an expression which value evaluated in the variable environment yields the integer upper bound of the array · a maps an index i to a pair ai i v of the index i and the corresponding array element value v the instrumented semantics of arrays makes explicit the fact that arrays relate to indexed element values by considering array elements to be a pair of an index and an array element value this instrumented semantics is in contrast with the classical semantics a h v of arrays mapping in h to array element values in v the explicit inclusion of the array bounds is useful to handle arrays of parametric length such as javascript arrays or collections in languages nevertheless the examples here consider arrays of fixed length maybe unknown with the inclusion of the concrete variable environment is also necessary to explain segments which are whose bounds may symbolically coincide at different program points although they may take different concrete values over time so that the length of the segment can vary during execution as shown eg in sect by p and p the semantics of an array element access ae is classical the expression e is evaluated to an index i the array variable a is evaluated to its array value a a where is the concrete variable environment it is a buffer runtime error if i or i in which case the value of ai is undefined so that program execution is assumed to stop otherwise the index is so ai i v is welldefined and v is the value in the classical sense of the array element ae obviously storing i v instead of v is useless but for the fact that the instrumented semantics can be used to make the array content analysis more precise example let us consider the initialization example of fig with the additional assumption that alength at program point the final values of the scalar variables are given by such that i alength n where n is the unknown array length the final value of a is a alength a with ai i for all i n because and alength are easily understood from the context we write ai i by of notation where the value i of i is assumed to be in the analysis of the example of fig the pair ai i v was first abstracted to v which is the case for all abstract domains such as constant propagation which cannot establish a relation between the index i and the array element value v array properties are sets of concrete array values and so belong to a relations between array values are thus abstracted away we have no hypotheses on expressions but z e and x e so that the expressions used in segment bounds can at least be integer constants or scalar variables which is necessary in most programming languages to express bounds the variable and expression abstract domains scalar variable abstraction we let x be an abstract domain encoding program variables including a special variable v which value is assumed to be always zero so x x v where v x operations include the equality comparison of variables properties and property transformers of concrete variable environments in rv are abstracted by the variable environment abstract domain rx which depends on the variable abstract domain x so that r is an abstract domain functor the abstract properties r are called abstract variable environments the concretization v denotes the set of concrete variable environments having this abstract property it follows that v r rv the static analysis of scalar variables may or may not be relational for abstractions rv is first abstracted to x v and r x v where the abstract domain v abstracts properties of values in v with concretization v v v expressions in simple normal form the symbolic expressions appearing in segment bounds belong to the expression abstract domain ex the abstract properties e consist in a set of symbolic expressions depending on the variables in x restricted to a canonical normal form plus the bottom expression corresponding to and the top expression abstracting all symbolic expressions which cannot be put in the considered normal form the array bound expressions are assumed to be converted in canonical normal form eg via auxiliary variables so that becomes int x x bi ax different canonical forms for expressions correspond to different expression abstract domains ex in our examples and in the implementation the abstract expressions e are restricted to the normal form v k where v x is an integer variable plus an integer constant k z v k represents the integer constant k an alternative example of convenient normal form would be linear expressions av b where v is a variable and a b z a for constants concretization given an abstract domain for scalar variables with concretization v r x z the concretization ee of an expression e e depends on the abstract value r of the scalar variables in x and is the set of possible concrete values of the expression so e e r v such that e e v ev i i and otherwise ev i v i v abstract operations on expressions in simple normal form simple operations are defined on symbolic expressions in normal form such as the check that an expression depends or not on a given variable or the substitution of an expression for a variable in an expression followed by its reduction in normal form returning if impossible given two expressions in normal form we must be able to answer the question of their equality and inequality which in the abstract is always true false or unknown these abstract equality and inequality tests of expressions may be more or less sophisticated we consider below three cases of increasing complexity which one is chosen can be a parameter of the analysis syntactic comparisons in their simplest form the comparisons can be purely syntactic for example v i v j is true if and only if v v and i j false if v v and i j and unknown otherwise similarly v i v j is true if and only if v v and i j false if v v and i j and unknown otherwise the comparison of i and v j where v v always has an unknown result this is very simple but rather variable comparisons an immediate refinement consists in using the abstract information r available on scalar variables this is always possible since the corresponding abstract domains whether relational or not do have primitives to handle program conditional expressions for example assume that rx is an interval analysis v a b and v a b the comparison v i v j is true when v v and i j or v v but using the abstract variable environment b i a j false when v v and i j or v v but using the abstract variable environment b j a j and unknown otherwise relational domains such as and can directly answer such questions in that case the expression abstract domain e is an abstract domain functor ex rx depending on the variable abstract domain x and the variable environment abstract domain rx note that comparison of expressions e e e must be done for all possible variable abstract domains r which requires all of them to share a common abstract interface for expression comparison a reasonable choice is to translate the comparison of normal expressions in e to that of program expressions which have to be evaluated in the abstract using r comparisons the information in the array segmentation can be used to symbolically compare expressions in fact a segmentation e em e em en n maintains the information that e em e em en where the ith inequality is strict when i is empty and not strict when i is in its simplest form two expressions are known to be equal if they appear in the same segment bound if they appear in different segment bounds of the same array strictly when separated by at least one and otherwise their comparison is unknown more sophisticated algorithms can be used depending on the allowed syntactic form of normal expressions for example in the case of expressions of the restricted form v i i z where constant expressions are represented by the distinguished variable v which value is assumed to always be zero we can use algorithm to compare their symbolic values a graph matrix is constructed with an edge v v labelled i j whenever vi vj respectively ij when vi vj is derived from a segmentation of some array equalities are represented by two inverse inequalities arcs between incomparable variables are marked including when i j or i j so that the relation is abstracted away the shortest closure algorithm is used to derive all possible comparisons derived by repeated application of the transitivity of comparisons a cycle v v for a variable v in the transitive closure matrix means that is in the concrete a constraint v k v holds when the label of arc v v is less than or equal to k in the transitive closure matrix another similar example is algorithm for comparison of linear expressions of the form av bv c where a b c z segment bounds abstract domain functor the segment bound abstract domain functor b takes any of the expression abstract domains e discussed in sect and produces an instantiated segment bound abstract domain be whose abstract properties are sets of expressions b e the empty set denotes while nonempty sets e em of expressions e em e are all equivalent symbolic denotations of some concrete value generally unknown in the abstract except when one of the ei is a constant concretization the concretization b b rv of segment bounds is the set of scalar variables concrete environments making the concrete values of all expressions in the set to be equal e em so b and bs e e s e e where e is the concrete value of expression e in the concrete environment for example v c c and otherwise v c v c when normal expressions and segment bounds are simplified and compared in the context of variable abstract environments r sect the concretization can be chosen as b b r rv such that bs v e e s e e abstract operations on segment bounds the segment bound abstract domain operations include basic set operations such as the empty and singleton constructors test for emptiness inclusion strict inclusion and equality union intersection as well as a widening when the normal form of expressions does not enforce the of the number of expressions which can all have the same concrete value a simple widening limits the number of expressions that can appear to a maximum given as a parameter of the analysis in order to handle assignments to scalar variables the segment bounds abstract domain be has an operation that eliminates from a set of expressions all the expressions that contain a given variable using the check provided by the expression domain parameter e in sect similarly to handle invertible assignments to scalar variables an operation is available to substitute an expression for a variable in all expressions of a set a resulting expression being eliminated from the set when the expression domain parameter cannot put it in normal form after a sideeffect free assignment ie or an equality test ie we have i e so ee can be added to a segment bound containing the expression ei provided the expression domain parameter e can put ee in normal form based on the comparison of expressions in sections sect the segment bounds abstract domain functor can compare sets of equal expressions for example s s is true if there exists an expression e in s and expression e in s such that the expression domain parameter e can determine that e e is true s s is false if the expression domain parameter e can determine that there exists e s and e s such that e e otherwise the comparison s s has an unknown result array element abstract domain the array element abstract domain a abstracts properties of pairs index value of indexed array element the concretization is a a z × v properties in z × v may not or may be first abstracted to v when we do not want to relate array element values to their index in the first case we have a relational analysis eg in sect in the second a eg in sect conversion between the variable and array element abstract domains in general the variable and array elements abstractions do differ so that a conversion from one to the other is needed a variable to array element abstract property conversion is involved in an assignment ai e handled as ai ie while an array element to variable property conversion is required in an assignment x ai and no conversion is required in ai aj or i j this is taken care of by a conversion abstract domain providing the two conversion functions therefore the analysis must be parameterized by a conversion abstract domain functor ca r which contains two conversion functions from variable abstract properties in r to abstract array elements properties in a and this domain can also abstract ie into e to get array content analyses not relating to indexed array elements the array segmentation abstract domain functor the array segmentation abstract domain a r abstracts a set of possible array contents by consecutive segments covering all array elements the ratio of the array segmentation analysis can be to a specific application domain by changing the abstraction r of scalar variable environments sect the normal form e of symbolic expressions sect hence that of the segment bounds be sect the abstraction a of the abstract array elements sect as well as the various parameters of these abstract domains such are the degree of refinement of expression comparison in e in sect hence of segment bounds comparison of be sect and the conversions sect examples of array segmentation functor instantiations to illustrate the possibility of relating the value of array elements to their index let us consider the static analysis of int n i int a new while i n ai i i ai i i typical of data transfer protocols where even and odd packets contain data of different types eg sec we will combine parity where ie is unreachable o is odd e is even t ie is unknown and intervals example the first abstraction is the reduced product of par ity and intervals where pairs of a parity and an interval denote the conjunction of both properties with a reduction eg of bounds by parity such as e e and parity for constant intervals such as t o in the following analysis of this abstraction is used both for variables and array elements hence ignoring their relationship to since i e parity e interval e p a i t n i e n e p a e i t n i e n e p a e n i i e n e the analysis of i starts with the initial value e and is e after one iteration which is to hence stable the narrowing phase starts with the test i n where n in so i is in e hence e by reduction through after one more iteration we get back e to narrow which is e and is a fixpoint example the second abstraction is the reduced power of intervals by parity whose abstract properties have the form o ie meaning that the interval is io resp ie when the parity is o resp e in the following analysis of we use the reduced product of parity and intervals for simple variables and the power of parity by interval for array elements hence ignoring their relationship to since i e maps parity e to interval e for example o e means that the indexed array elements must be even with value included between and p a i o n i e n e p a o e i o n i e n e p a o e n i i e n e observe that the abstraction is more powerful but the result is exactly the same as in the above analysis in ex using the reduced product since o e is exactly e on array elements example the third abstraction also uses the reduced power of intervals by parity but this time in a relational way for arrays thus relating the parity of an index to the interval of possible variation of the corresponding element so i e is a map of parity i to interval e we get p p p a i o n i e n e a o e i o n i e n e a o e n i i e n e so that the array elements with odd index are shown to be equal to while those of even index are zero abstract predicates the array segmentation abstract predicates belong to s b × a × b × a × k × b × k and have the form e em p e em p pn en where · the segment bounds ei b i n n are finite nonempty sets of symbolic expressions in normal form e as respectively considered in sect and sect · the pi a are abstract predicates chosen in an abstract domain a denoting possible values of pairs index indexed array element in a segment of sect and · the optional question mark i follows the upper bound of a segment its presence means that the segment might be empty its absence means that the segment cannot be empty because this information is attached to the segment upper bound which is also the lower bound of the next segment the lower bound e em of the first segment never has a question mark is a complete lattice with the symbolic expressions e in a given segment bound de on scalar variables but not on array elements hence should be handled as ax so that the auxiliary variable x can appear in a segment bound for array a the consecutive segment bounds are in strictly increasing order in the concrete except when followed by a question mark meaning that the preceding block may be empty there is no hole between segments since this hole can always be viewed as another segment whose properties are unknown the first block limit always contains an expression in normal form denoting the array lower bound while the last block always contains an expression in normal form denoting the array upper bound within one block the abstraction is uniform but can be relational since the array semantics of sect can relate the array value ai to the index i a possible refinement would be to introduce relationships between segment emptiness marks so as to express that in i t n both segments cannot be simultaneously empty which we do not do for the sake of efficiency concretization given the v r rv for the variable abstract domain and a a z × v for the array elements abstract domain the concretization s of an abstract array segmentation is an array property so s s r a the concretization of a segment b p b is the set of arrays whose elements in the segment b b satisfy the abstract property p stands for while stands for sb p b h a v e e b e e b e e e e h i e e ai ap the concretization of an array segmentation is the set of arrays whose elements in all segments bi bi i n satisfy abstract property pi and whose lower and upper bounds are respectively given by b and bn n h a pi i e b e en bn en h and s segmentation unification given two with compatible segment bounds in general for the same array the objective of segmentation unification is to modify the two so that they coincide by compatible we mean that the first the last segment bounds should have a nonempty intersection in practice this is always the case as the first segment bound always contains and the last segment bound always contains the symbolic name for the array length eg alength on the best unification the problem of segmentation unification admits a partially ordered set of solutions in general not forming a lattice the minimal elements hence the least precise are those where all the segments are and only the are preserved example let a and b be distinct variables when unifying a b with a b c both a and b are minimal solutions but not comparable the maximal elements hence the most precise are the common refinements of both example when unifying abc with b ac both ac and b c are maximal but not comparable solutions in general a solution is such that the bounds i do appear in one or the other initial segmentation and ii preserve the original orderings one segment can be empty in one segmentation like i and nonempty in the other one like p i therefore segmentation must include the splitting of empty segments like i p i such an empty segment splitting is used in the of segments which are not all commutative so that the abstract value p of the created empty segment must be chosen as the neutral element of the considered operation eg p is for join for meet on the left and on the right of the partial order the involved in a unification are usually related to different program contexts example assume we want to unify and obviously in two different contexts the common refinement is for and for which would yield the join pi however it might be the case that i from the abstract variable environment in which case the expression i in the lower bound of the first refined segmentation is undefined therefore the of the common refinement if any depends upon the abstract variable environment too to sum up we want the array segmentation analysis i to have the possibility of being completely independent of the variable analysis see sect ii to have a deterministic behavior in presence of several maximal common refinements therefore we present a segmentation unification which does not provide any guarantee on the of the result but instead one which i is always welldefined in absence of knowledge of the contexts of the ii does terminate iii is deterministic the segmentation unification algorithm the first step of the algorithm is checking the compatibility of the two input to verify that they do have common lower and upper bounds then the unification proceeds recursively from left to right and maintains the invariant that the left part is already unified we let l resp r denote the left resp right neutral element b p b and b p b have same lower bounds and so keep the first segments as they are and go on with b and b in case b b p b and b p b with b and b b let b be the set of expressions in b appearing in the second segmentation blocks b if b is empty then go on with b p b and b p b following case otherwise go on with b l b p b and b p b as in case the case is similar in case and with b b and b b b b let b resp b be the set of expressions in b resp b appearing in the second resp first segmentation blocks b b if b and b are both empty go on with bp b and b p b as in case else if b is empty so that b is not empty then go on with b p b and b r b p b where r is the right neutral element the case is similar finally if b and b are both nonempty then go on with b l b p b and b r b p b as in case in case b p b and b p b with b b we cannot be on the first left segment block so we have on the left b p b p b and b p b p b and go on by merging these consecutive blocks b p p b and b p p b finally at the end either we are left with the right limits that have both been checked to be equal or else we have b p b and b with b b because we have maintained the invariant that b is always equal to b in the concrete so necessarily since then b b b and so we end up with b b b and b b b example in the analysis of the example of fig we have to unify i t n and i i t n which becomes i t n and i t n by and we go on with i t n and i t n which by the symmetric in of becomes i t n and i t n so we go on with n and n which terminates the recursion by thus returning i t n and i t n their array segmentation join is then i t n taking the disjunction of potential segment emptiness the algorithm never adds any new expression to the segment bounds nor increments the total number of segment bounds in splits and so does terminate the algorithm has a lookahead of cf case it can be easily refined to provide a larger lookahead at a price of an increased complexity however an advantage of the algorithm is that its behavior and output are deterministic for instance in the ex our algorithm returns the segmentation c a lookahead algorithm should make the choice between the two maximal solutions in general the algorithm can be easily adapted and refined to take into account specific knowledge when comparing segment bounds for instance the total order induced by constants sect partial for an array segmentation join s a segmentation unification is performed and then the array element abstract domain join a is applied for the meet s a segmentation unification is performed and then a meet a for the widening s a segmentation unification is performed and then a widening a moreover the widening merges consecutive segments with same abstract value could also be used to limit the size of segment bound sets andor the number of segments given as parameters of the analysis for the narrowing s a segmentation unification is performed and then a narrowing a for the partial order s a segmentation unification is performed before returning the conjunction of the comparisons a the potential segment emptiness must also be taken into account that is abstract transfer functions abstract value of an indexed array element assume that we have to evaluate ae for the array a abstracted by the segmentation the expression b e bn is evaluated in the abstract and a is if the result is unreachable dead code false definite error or unknown tial error let b be the largest segment bound such that b e is true b otherwise and bh be the smallest segment bound such that e bh is true bn otherwise assuming that execution goes on only in absence of buffer the value of ae is then h k pk where is the join in the domain a abstracting index value of indexed array element pairs a call to a conversion func tion of c is necessary if this abstract value in a must be converted to a variable abstract value in r assignment to an array element in an array element assignment ae e with abstract variable environment where the array a is abstracted by the segmentation we first determine the range of segments such that b e bh is definitely true the segmentation of a can be thought of as being ab to bp b h k pk bh ph where is if all the h are so that the block b bh can then be empty and otherwise of course it may happen that h in which case only one segment is con or and h n in which case all segments are in all cases the assignment is definitely in the ment b bh may be at its this segment is split let p a be the abstraction of the value of the pair e e in a after the array element assignment the array tation of a becomes bp b h k pk el p e h k pk bh r ph l is unless the ment bounds comparison discussed in sect can determine that b e is always true similarly r is when e bh for sure and otherwise there are special cases when the index expression e or e or both cannot be put in the normal form of e we have to merge the bh corresponding segments to get bp b ph in the worst case this p is the h k pk case of the assignment in fig if the segment bounds comparison can determine that b e we get bp b e h k pk bh r ph pn similarly if e bh for sure we get bp b h k pk e test of an array element a test of an array element ae can be done by getting the abstract value of i v of in a restricting the abstract value i v by restricting i to the array bounds execution is assumed to stop in case of buffer and v to the test cv and assigning the restricted value back to the array element ae for a simpler uniform treatment of tests involving both scalar variables and array elements i v in a can be converted to the variable abstract domain r and back after handling the test using c assumption for the content of an array for a statement in the form of assume i a b assuming a b are within the array bounds i we infer an abstract segment value as in the previous case let us call it p ii we abstract the bounds a b in the quantification to their best possible approximation a b in the bounds abstract domain iii we the most generic abstract segmentation a t a p b t alength and we use the scalar abstract domain to get of some of the finally the abstract predicate is using the meet operation with the abstract value in the of a for example using the abstract domain of intervals a t alength k alength oo assume forall i k ai a oo k t alength in fact the abstract segment is a t oo k t alength which can be reduced using the abstract domain of scalars to a oo k t alength the constant zero is trivially equal to itself and k is positive but it may be equal to the length of the array a finally the value in the of a is refined via the meet operation invertible assignment to a scalar variable in an invertible assignment to a scalar variable x fx y where y y ym we have f y where f is the value of f denotes the value of the variable x before assignment denotes the value of the variable x after assignment f has no side effect so the values y of the variables y are not changed and f y for such an invertible assignment all occurrences of the variable x in the expressions in the segment bounds must be replaced by the expression f x y and the resulting expressions simplified into canonical normal form if any and otherwise in case a segment bound becomes empty because normalization is impossible the two adjacent segments must be for the example in fig we have a i i t n i i a i i t n assignment to a scalar variable in a non invertible assignment x f x y no inverse f y is available for example in x f y for such a non invertible assignment x e all expressions in the segment bounds containing occurrences of the variable x must be eliminated from these segment bounds in case a segment bound becomes empty the two adjacent segments must be then the variable x and expression e are added to the segment bound containing an expression e such that e e is definitely true in the abstract in the simple purely syntactic case of sect e e true is by e e so that x is added to all segment bounds containing e for the example of fig we have a t n i t n t i a i t n i n t in case of an assignment x f y x y where yi y yi yi ym is available the expression y yi yi ym can be added to all segment bounds containing an expression whenever simplification in canonical normal form is possible for example a i j t n i j a i j t n comparison of scalar variable expressions the equality comparison e e where e and e have equivalent normal forms together with the segment bounds comparison discussed in sect that may be able to determine that e bi is always true will add e and e to bi moreover if e bj for sure and i j then the segmentation will be reduced to bi bj e or to when one of recall that e b is e b e e a int i alength while i i i ai figure example of a backwards initialization array segmentation reduction is needed to prove the postcondition j alength aj the i j is since then e e the comparison e e has the same effect when j i or when e e and i j otherwise e e and strict inequality e e with e bi and e bi can be used to remove a on the possible emptiness of a segment which becomes array segmentation reduction a program analysis is the product of a segmentation analysis for arrays and the analysis of scalar variables the two analyses can be completely independent which is an important feature for the array segmentation analysis to be easily inserted in any analyzer without having to make any hypothesis on the static analyzer the consequence is that the result may not be as precise as possible let us illustrate this on the program of fig using the independent product of interval abstractions for array elements and scalar variables the post condition derived by the static analyzer with sect at program point is a i alength i alength oo it states that it is possible that i but the array segmentation analysis cannot prove that this is indeed always the case it is in general always more precise to consider the reduced product of the array and variable analyses this consists in reduction operators that propagate information for one abstract domain to the other for example it may be useful to propagate the relational information of array segmentation equality of expressions in a segment bounds and segment bounds in increasing order strictly increasing in absence of unless a more precise relational domain is already used for scalar variables in the other direction the information provided by the scalar variable analysis can be propagated to a possibly empty segment b p b can be reduced to a nonempty one b p b if the scalar variables environment implies e b e b e e is always true in the abstract the abstract test returning either true false or unknown similarly a possibly empty segment bp b may be definitely empty and reduced to the bound b b when e b e b e e true in the reduction example of fig the fact that i implies that the segment i is empty in which case the reduction automatically yields a i alength i alength oo which is exactly the expected result at program point implementation and allow the specification of contracts preconditions postconditions and the api is included in net starting from v is an abstract static analyzer developed at used to statically check i contracts and ii the absence of common runtime errors such as nonnull dereferences or buffer is used both inside and outside microsoft on large production projects when a method is analyzed its preconditions is turned into an assumption and its postcondition into an assertion for each method call appearing in the method body its precondition is turned into an assertion and the postcondition into an assumption are assumed at the entry of public methods and at the exit point a detailed description of the treatment is scope of this paper further assertions are generated from the body text eg when an array is accessed the indexing expression is better being in bounds analyzes the bytecode which presents several advantages independence from the compiler the language the language version but also some lack of program structure after reading the bytecode extracting the contracts creating the control flow graph and simplifying the program a heap analysis is run so to resolve aliasing and the program is turned into a scalar form the heap analysis makes some assumptions on parameter aliasing we refer the interested reader to on the top of the program scalar form several forward value analyses are run and their results are used to the assertions assertions are using simple builtin decision procedures if an assertion cannot be then the analysis is refined by using a more precise abstract domain or a backward propagation if refinement does not work then a is reported to the user warnings are because of a lack of knowledge eg missing postcondition precondition too weak incompleteness of the analysis in all the static analyses or because of too complex assertions eg quadratic inequalities before this work quantified assertions over arrays eg all the elements are nonnull were not understood by which reported warnings for assertions as eg the ones in fig furthermore the analysis was also very in handling array loads and iterations over collections so that each time a value was loaded from an array nothing could be stated on that value hence the worst case was assumed the analysis precision those issues were a main request from users implementation of in we fully implemented in to the user typically a programmer with no background in formal methods is exposed as a simple in when the is enabled the is instantiated with the abstract domains in the array analysis is orthogonal to the other components of so that it can benefit of precision improvements for free for instance if a more precise scalar variable abstract environment is used then the analysis is likely to get more precise functor instantiation in the current implementation i the abstract domain used for the segment elements is the disjoint union of intervals with ii the expressions used in the segment limits are the simple expressions of sect augmented with explicit casts to model the fact that alength and int alength both denote the length of an array a in the bytecode and iii the scalar numerical abstract domain is the one provided by in the particular run several numerical abstract domains are available in among them combined with linear equalities numerical domains are composed according to a tree topology reduction is achieved via or of information an abstract domain can push information to abstract domains of lower rank and information from all other do the segmentation abstract domain is at the root of the tree it pushes bottom contradiction expression equality when the two expressions appears in the same bound array values eg in x ai if it determines that ai null then it pushes the information x null it comparisons exp exp exp exp exp exp integer constants all the variables which are known to be definitely constants intervals eg in x which is the range for exp abstract values eg in ai z which is the abstract value for z the array analysis is currently implemented as a value analysis run on the top of the heap analysis when in particular array aliasing has been resolved as a consequence the abstract transfer functions implemented in the analyzer are very similar to those described in sect with some to meet the of the net semantics and infrastructure array creation when an array is created with the instruction a exp then the segmentation d alength exp is where d denotes the abstraction in the segment value abstract domain of the default value for the type of the array elements eg is the default value for int and null is the default value for reference types the segmentation is then refined some information from the scalar variables abstract domain in the particular case first the numerical abstract domain if exp if the answer is true then the is if the answer is false then it means that exp as if exp then a buffer occurs causing the concrete execution to stop and having some other analysis the bug therefore the empty segmentation is returned otherwise the original segmentation could not be refined and it is returned as it is assertions implements a very simple and specialized decision procedure to check whether an quantified assertion over arrays holds at a given program point given the statement assert i e e uses the numerical abstract domain to provide a lower bound l for e and an upper bound u for e to be used to determine an v for the values of ai in the range l u the expression cv which does not contain any reference to array values is then constructed and its truth is decided by the internal decision procedures commonly used in example let us consider the example in fig and let us suppose that at the end of the method there was the statement assert i alength ai infers the limits to be and alength and it uses the abstract state p to determine that in such a range v ai the proof obligation is then trivially function calls function calls are as relies on their contract instead so they are turned into two instructions an assert for the precondition and an assume for the postcondition segmentation unification in the implementation we slightly refined the algorithm of sect to with some produced by the bytecode representation and heap analysis in general in a segmentation done at bytecode level one will find many more than those that one may expect in particular when reasoning at the equivalent source code the first modification is the introduction of a step which the to remove those segment bounds and hence segments containing variables appearing only in one of the two of course those would have with the original algorithm but the step has the advantage of making the algorithm faster and more precise as shown by the next example example suppose we need to unify the segmentation a with b alength the step removes a from the first segmentation enabling the segmentation unification algorithm to produce a more precise result without we would have needed a deeper lookahead for the algorithm to prevent the abstraction of the bound b the second modification is a refinement of the step to take into account constants if b and b contain a constant then we can use this information to new bounds as illustrated by the next example example suppose we need to unify alength with alength the result of the unification is alength experimental evaluation we validated the of the analysis by running on large production quality libraries we validated its precision by running it on its own implementation is written in c analysis of large libraries we report the experience of running on the main libraries of the net framework the and libraries provide core such as basic types optimized data structures cryptographic primitives date manipulation interfaces with the operating system etc the other libraries focus on database web contents xml parsing and creation libraries have been by several different programmers over the years hence present all kinds of different programming and optimizations we randomly a large set of methods containing loops with arrays for instance this is how we the example in fig we found few cases of code as fig whereas fig is a lot more common pattern other common idioms include the initialization using multiple loops conditional initialization of an array prefix or followed or not by the initialization of the remaining array segment or a from our manual inspection we that simple partitions based on the assumption that arrays are uniformly traversed from the first to the last element eg simply do not apply to existing net code other partitioning heuristics do not apply as well roughly because at bytecode level the structure of loops has been compiled away we conclude that an array analysis technique in order to be effective should handle very efficiently the above cases at the beginning of this project our first attempt was to implement the technique of on the top of a semantic analysis to determine the array partitions turned out to be extremely bad up to × slower wrt a normal run of the main reasons for the bad performance were i the large number of generated slices because of lack of possibly empty segments unlike us ii the need to the analysis once the partition is discovered eg to distinguish the first iteration from all the others iii the cost of partition changes detailed in sect more generally the problem of is that they abstract too much the concrete environment eg by separating the array partitioning from the discovery of array partitions we do it at the same time instead and eg by the relative of array slices we have consecutive segments the information lost because of the abstraction must then be during the array analysis next we developed in which we made sure that i the array analysis is run at the same time as the scalar variable analysis and ii explicit partition enumeration is avoided by means of possibly empty segments ie at each program point there is at most one approximation for a given array we first sketched the analysis in a research prototype to experiment and the algorithms and then we validated it by integrating it in our analysis turned out to be extremely fast we report the experimental results in for each library we report the number of functions the analysis time without the array analysis the analysis time with the array analysis the and the number of inferred nontrivial array invariants in function postconditions the libraries are not annotated with contracts so we cannot report on it in the experimental setting is run in its configuration except for the iterative refinement which is off as it is not needed for the particular experience the is a core running windows and net v the first observation is that the introduces a analysis less than whereas it a of nontrivial array invariants more interestingly we did not encountered any corner case causing the analysis time to up unlike previous published similar techniques this fact makes us to state that the analysis up well we were also by the fact that the analysis was able to handle complex initialization patterns such as the one in fig which were not considered at all during its design meaning that the analysis is robust enough to handle code a problem that unfortunately several static analyses usually developed for few coding patterns time w func time arr inv table the execution time with and without the array analysis the and the number of nontrivial array invariants time is in the of array analysis is a analysis of annotated code to validate the precision of the analysis in the context of contract checking we ran it against its own implementation in once again we run in the configuration and iterative refinement on we implemented with a pair of mutable sequences one for the bounds and the other for the array elements each sequence should only contain nonnull elements sequences are implemented as partially filled arrays to optimize cache the class abstracts sequences allowing for insertion manipulation update and removal of elements methods in total the object invariant of states that all the elements in the partially filled array are nonnull the analysis of without the functor analysis takes seconds warnings out of proof obligations the analysis of with the functor analysis takes seconds with warnings therefore the more precise analysis is also faster the reason why is that the array analysis induces a and discover more facts on the program which can be directly used to the proof obligations without moving to more refined analyses once has been verified then we considered the tion methods where we were able to prove further proof obligations out of total analysis cost was the remaining warnings are by a possible violation of the precondition of the segment unification algorithm of and maybe of existing smt solvers overall our experience matched the feedback from our users we do not have access to their code though reduced the number of false positives at a cost conclusions our main goal was to have a precise and scalable static analysis for array contents we achieved it through these core ideas i to derive the segment bounds through array accesses in array element tests and assignments so that we do not rely on the or other to infer the segment bounds ii to exploit segment unification for partial order joins meets and iii to carefully treat disjunction via possibly empty segments symbolic bounds with different instances and relation of array values to although expressiveness of array segmentation is limited our analysis is without hidden hypotheses it has proved to be simple enough to scale up in static analysis tools whereas a previous attempt based on did not we used it to validate its own implementation effectively reducing to zero the false alarms the approach is applicable to matrices of higher dimensions by recursively instantiating the functor on an array instantiation the work can be extended to relational properties among segments by using an auxiliary scalar variable to denote the value of any element of a segment and relating the values of these auxiliary scalar variables for different segments by a relational abstraction in the scalar environment this would handle the partitioning in quicksort relational properties can also be considered by using several auxiliary scalar variables xi xj to denote the values of elements indexed i j within the segment and relating them in the scalar environment this would handle sorting algorithms of course and relational properties can be combined the extra cost makes those relational analyses probably in a generalpurpose and scalable static verifier such as acknowledgments we would like to thank for the discussions and the support provided with the implementation of the of forall in work supported by the nsf in computing references m k leino and w the spec programming system an overview lncs ­ springer m by r b and k leino a modular verifier for objectoriented programs lncs ­ springer m m and f embedded contract languages acm d t a henzinger r majumdar and a rybalchenko path invariants pldi ­ acm p j g and e beyond assertions advanced specification and verification with and lncs ­ springer p cousot verification by abstract interpretation verification ­ theory practice lncs ­ springer p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints th popl ­ acm p cousot and r cousot systematic design of program analysis frameworks th popl ­ acm p cousot r cousot j l a d and x combination of abstractions in the static analyzer lncs ­ springer l de and n z an efficient smt solver tacas lncs ­ springer d timing assumptions and verification of finitestate concurrent systems automatic verification methods for finite state systems lncs ­ springer i t and a aiken updates beyond strong vs weak updates esop lncs ­ springer i t and a aiken precise reasoning for programs using containers th popl acm m and f static contract checking with abstract interpretation lncs springer c flanagan and s qadeer predicate abstraction for software verification th popl ­ acm int device interface specification technical report int inc d t reps and s sagiv a framework for numeric analysis of array operations nd popl ­ acm s gulwani b and a lifting abstract interpreters to quantified logical domains th popl ­ acm n and m discovering properties about arrays in simple programs pldi ­ acm r jhala and k array abstractions from proofs cav lncs ­ springer m affine relationships among variables of a program inf ­ g a unified approach to global program optimization st popl ­ acm l and a finding loop invariants for programs over arrays using a theorem prover lncs ­ springer v and f a more scalable approach to infer linear inequalities lncs ­ springer sh lee and algorithm based on priority of separate buffers for and services letters ­ f modular analysis for object oriented languages sas lncs ­ springer f and m on the relative completeness of bytecode analysis versus source code analysis cc lncs ­ springer f and m a weakly relational abstract domain for the efficient validation of array accesses ­ acm m d m and d heap analysis in the presence of collection libraries ­ acm k l quantified invariant generation using an saturation prover tacas lncs ­ springer b meyer the language prentice hall a the abstract domain higherorder and symbolic computation ­ v pratt two easy theories whose combination is hard technical report mit b et de des sciences de paris ab ­ m a podelski and t abstraction refinement for quantified array assertions sas lncs ­ springer r deciding linear inequalities by computing loop jacm ­ h yang o lee j berdine c calcagno b cook d and p w ohearn scalable shape analysis for systems code cav lncs ­ springer 