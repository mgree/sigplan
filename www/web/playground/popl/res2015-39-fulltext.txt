probabilistic termination soundness completeness and compositionality university abstract we propose a framework to prove almost sure termination for probabilistic programs with real valued variables it is based on ranking a notion analogous to ranking functions on programs the framework is proven sound and complete for a meaningful class of programs involving and bounded nondeterminism we complement this foundational insight by a practical proof methodology based on sound conditions that enable compositional reasoning and are amenable to a direct implementation using modern theorem provers this is integrated in a small dependent type system to overcome the problem that ranking functions fail when combined with among others this compositional methodology enables the verification of probabilistic programs outside the complete class that admits ranking categories and subject descriptors d software engineering verification f logic and meanings of programs specifying and verifying and reasoning about programs general terms probabilistic programs termination keywords probabilistic programs program verification termination introduction termination is one of the simplest and yet most important liveness properties if the program involves or is operating in a randomized environment the natural of termination is almost sure termination saying that the probability of eventually terminating is one so divergence has zero probability proving termination of programs is equivalent to constructing a ranking function that is a mapping v s d such that vs vs for all transitions s s in the program where d is wellfounded a partial order without infinite chains in case of programs over countable state spaces and bounded branching one can restrict to n as wellfounded relation having a numeric domain allows one to synthesize ranking functions via the solution of convex optimization permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work must be for all other uses the popl january ­ copyright is held by the acm problems in addition the value vs provides an upper bound on the maximum number of steps before termination if assuming the program to start at state s for probabilistic programs ranking functions provide a sound method to prove termination but are far from being complete to illustrate this consider the following probabilistic program while n do c uniform if c then n n fi od clearly the program terminates with probability one since ig the command forever has probability zero yet there cannot exist a ranking function proving termination be cause each time the conditional branch is the program state remains unchanged but wellfounded relations are however with probability the next value of n will be to n and with the same probability it will be n this means that the expected value of variable n after each iteration is by and were the first to connect tic program termination to ranking functions or functions these constitute the of rank ing functions for probabilistic programs by considering expected values instead of values they allow the value of some states to increase when executing some transitions as long as the expected value ie its average decreases formally a mapping v s r is a ranking functions if there exists a constant such that vs ps s vs s s whenever is a program instruction enabled at state s and ps s is the probability of going from s to s using the command a notably r is a wellfounded relation on the positive reals where a b a b ranking functions provide a sound method to prove almost sure as termination and in analogy to ranking functions vs is an upper bound on the expected number of steps before termination thus in fact ranking functions guarantee a stronger property namely that the expected time to termination is finite this is sometimes referred to as positive almost sure termination for probabilistic programs with countable state spaces ranking functions not only are a sound method to prove positive almost sure termination but a complete one ­ but only as long as nondeterminism is absent we overcome this foundational restriction with this paper and embed the resulting theory into a practical compositional proof method when dealing with nondeterminism and families of play an important role as we will see one of the distinct technical aspects of our approach is that the semantic space of a probabilistic program is set up in such a way that all possible share a common probability space this enables correct reasoning about of the involved in our setting the base are ranking which in turn are a generalization of ranking functions the main contributions of the paper are · we present a new semantics for nondeterministic programs where share a common probability space section · we demonstrate that the ranking functions proposed by and are not complete for positive almost sure termination in the nondeterministic case and the same holds for ranking section · we extend the ranking approach of and to the bounded nondeterministic case at a sound and complete characterization of terminating programs section · we provide a compositional and sound proof method for almost sure termination the framework only relies on the synthesis of probabilistic linear loop invariants sections and · we provide a method to identify program variables that must have finite expectation theorem motivating counterexamples ranking functions provide the to bound the expected number of steps a probabilistic program will take as such they are sound and complete for positive almost sure termination provided the probabilistic program is deterministic in the presence of bounded nondeterminism the notion appears to have a natural extension obtained by requiring that the expected number of steps needed is finite for all possible of the nondeterminism however as we illustrate below and in contrast to results that were for a theorem the completeness results for positive almost sure termination do not extend to the case of nondeterministic programs moreover we show below that ranking functions are still incomplete even if besides all also the of all is known to be finite a simple show consider the program illustrated in figure it represents a show where after the and prior to termination state the is spent one unit at a time a participant can initially state either answer a question or decide to stop the game immediately if the participant to finish he obtains a f n where n is the number of questions thus far if the participant answers correctly he can continue in case of failing a question he the game immediately and receives a gn for the participant in question the is so difficult that he that the best strategy is to answer at random state ¢ analyzing this game we first observe that the participant will receive with probability one a finite amount of because the event of questions correctly forever has probability zero we now analyze the expected amount of that the participant will receive this depends on the number n of questions the participant is to answer before and of course on the choice of f and g f n gk gk en n k e k kn k the e corresponds to the expected gain if the participant never stops questions thus he always gets the n en does not work in a scenario where f n n and gn n we see that clearly en en and en as n so it seems that the best strategy is to never give up however e this is because the limit of the expectation is not the expectation of the limit in other words there is no optimal strategy despite being able to find a ranking function for each particular resolution of the nondeterminism as all en are finite we are unable to build a single universal ranking function it would require assigning to some of the states en neither consider now the case where f n n and gn n now we have en as n so now the is bounded and our participant will not get rich for sure in this case the aspect of interest is the expected that the participant will receive under the assumption that he already m questions correctly n k nm km with m n here the maximum expectation after m questions turns out to be m m obtained by n yet the maximum expectation after the m th question right or wrong is m m m and that value is again m m therefore the expectation remains invariant ie a function assigning to each state the maximum expected termination time does not rank in expectation and this function cannot be to a ranking one without assigning to at least one of the states works now suppose that we but not the participant are able to record all results of the random choices and their effects prior to the show suppose also that the results of the random choices are independent of the strategy of the participant about when to stop we might for instance know that the fourth random choice will make the participant miss the fourth question thus we are sure that he will get the if he to answer at least four questions we can then also infer that he will the if he is enough to before the fourth question in other words we know the maximum amount of the participant is capable of winning regardless of his strategy as this is random we can analyze its expected value e if f k f k gk then e f k k k in the above two examples e is infinite because f k k in section we show that a ranking function can only be constructed if and only if e is finite the proper definition of e which implicitly ranges over all possible strategies relies on a novel semantics for nondeterministic and probabilistic programs introduced in section in this section we present some basic concepts of probability and measure theory as needed for this paper more detailed descriptions can be found in reference such as and measure theory an arbitrary set that contains all possible outcomes of an experiment is called a sample space a algebra f is a collection of subsets of that is closed under complement and countable union and f the elements of f are called events we say that a is if a f in case r the algebra denoted by br is the algebra generated by the class of open sets a function f is measurable with respect to f and f if f b f for all b f a probability measure µ is a function of signature f such that µ and it n i c while c do if then c if c then n n else i gn fi else c i f n fi od ¢ i gn n n i i i i while i do i i od i f n figure show example is additive the probability of a countable disjoint union of events is given by the sum of the individual probabilities an event a occurs almost as if similarly a is a null event if two events a and b are independent when b two algebras f and g are independent if all events a f and b g are independent given an element x x is the distribution of x and satisfies xx the conditional measure of µ under a nonnull event b is a a probability space is a triple f µ where f is a algebra of and µ is a probability measure for f random variables a function x r is a random variable rv on f µ if it is f a rv x is discrete provided the range of x is countable a particular discrete rv is the function of a measurable set a it takes values in and satisfies a a the expected value of a random variable x is the e x x where is the integral see for a detailed in case of a discrete rv the expected value can be expressed as a weighted average in particular ea if ex is a finite value we say x is it ensures that is finite for any measurable event a a finite or infinite sequence fn of algebras is a if fk fk f for all k n for example consider the experiment of two ie the sample space is hh t t ht t h a possible is f f hh ht t t t h and f p a sequence of random variables xn is adapted to a fn if xn is for all n and it is if xn is fn measurable for all n times a discrete random variable t that takes values in n is a time with respect to a fn if the event t n is since each element fn of a is a algebra then the events t n and t n are also from the previous example a time is the rv th that satisfy th h th t h and is otherwise we have f and th th t h f f th hh ht times several properties that we will exploit in this paper for example if t and t are times so are t t minimum t t maximum and t t also any random variable that takes a constant value in n is trivially a time the expected value of a time can be expressed in a very convenient form et pt k k we can also define the algebra ft of events that occur up to time t as follows a ft n a t n fn notice that t is measurable in ft if s and t are times with s t then fs ft thus sequences of increasing times define a conditional expectation given an rv x on a probability space f µ and g a of f the conditional expectation ex g is a rv measurable in g that satisfies x ex g for all a g aa intuitively ex g is the expected outcome of a random experiment represented by x if some partial information of the result is available represented by g consider again the experiment of two the expected number of observed heads is one however if the result of one of the is already known then the expected value changes it would be in case the heads and otherwise some important properties about conditional are the following ex ex ex y g ex g ey g h g ex g if g h g g if x is their intuitive meaning is as follows if no information is available it is the same as taking the expected value the conditional expectation depends on the maximum amount of available information the expectation depends only on unknown information uniform the concept of uniform is an extension of of a rv to a family of random variables similar to the notion of uniform convergence in real analysis a collection xn is uniformly ui if the following holds k sup n informally the expected values of a ui family are bounded and the probability mass is globally within this boundary ie for any constant we can find a constant such that for all n and all events a such that uniform is a central concept in probability theory it is a necessary and sufficient condition to guarantee that a sequence of rv in probabilities also in expectation and it ensures that exn is finite thus it will also play an important role in our probabilistic programs in this section we present the syntax of our probabilistic programs and we provide a semantics in terms of random vectors over a probability space syntax our programs will be composed by the following grammar statement expr distribution if then statement else statement fi while do statement od statement statement expr constant expr expr expr expr expr expr expr expr expr expr and or here distribution stands for any probability distribution that is and has a known expected value like uniform exponential normal etc the program if then p else p fi represents a nondeterministic choice between the statement p and p if p is a statement contained inside a program p we say p is the parent of p and we denote it by p p p p is the reflexive version of it is worth that probabilistic choices p p p in the style of and morgan can be encoded in our framework as c if c p then p else p fi given an arithmetic or boolean expression e the set of variables that occur syntactically in e is denoted by the set of variables that are modified by a program p ie all the program variables that appear on the left of assignment instructions is denoted by semantics there are several ways to define semantics of probabilistic programs kozen provides a denotational semantics in terms of continuous linear transformations of probability distributions given an initial distribution of the program variables the semantics is a distribution indicating the distribution of the program variables at termination time the is a probability distribution provided the program as terminates nondeterminism is not considered in this semantics but can be introduced using probabilistic on another probabilistic nondeterministic programs can be represented operationally as markov decision processes the usual approach then is to define the sample space as the set of possible path executions after nondeterminism is resolved by means of a scheduler the latter is basically a mapping from finite paths determining the program state to enabled commands each scheduler induces a probability measure on measurable paths therefore the same program under two different yields two different probability spaces the approach we follow is closer to the latter but is equipped with a more refined semantics the core is that all are defined over the same probability space still they induce distinct random processes this will allow us to break conceptual limitations of the earlier approaches an event may then have distinct interpretations according to the scheduler considered other events have a global meaning these global events in turn will enable us to identify the set of programs where ranking functions provide a complete proof methodology another feature of our semantics is that it does not have a builtin distinction between probabilistic and commands at each step a value is from a distribution but the executed command is free to use or to entirely ignore the outcome definition guarded command given a finite set of real valued variables v x xn a guarded command is a tuple li g f lf that consists of an initial location li a final location lf a guard g that is a measurable set an update vector f f fn of functions a command is enabled if the program counter is li and the variables satisfy g after an enabled command the program counter is set to lf the values of the program variables are modified according to the update vector the value of xk is determined by fk rn r the new valuation depends on the old values and a single value at each step the underlying probability space is assumed to ensure that the value to the right probability distribution definition probabilistic program a probabilistic program is a tuple l v l l where l is the program counter v is a finite set of real valued program variables is a finite set of guarded commands l is the initial program location and l is the location reached upon program termination we require that for each location and variable valuation at least one command is enabled except for the final location it is possible to have multiple commands enabled simultaneously namely when several commands have the same initial location and their guards overlap the resulting nondeterminism in such programs is resolved by means of a scheduler a realistic scheduler can at each step base its decision on the information currently available including information about the past in particular a scheduler cannot decide to perform an action based on information about events that will occur in the future also it must satisfy certain conditions so as to obtain a fully stochastic process when removing nondeterminism before we into the formal definition of we first need to formalize the notion of available information this formalization will be provided by a of the probability space of our program and will be the same for all this in turn will allow us to observe the behavior of all scheduler simultaneously definition semantic space of programs let p be a probabilistic program with n variables a semantic space of p is a tuple f µ x such that · f µ is a probability space · is a of f · x is a random vector of size n that is measurable in f · is a sequence of distributed random vari ables with cn and independent of fn x is the initial valuation of the program variables cn plays the role of a possibly and represents a value at step n this definition does not define a unique semantic space for a program but instead specifies the minimum requirements to obtain a meaningful semantics this generality is essential for the decomposition presented in section however the most basic with the desired properties is c where xk e l true k e k n l xk distribution l true k n k n l p p p p if g then pt else pf od l g n l g n pt pf true n l true n l if then pt else pf od l true n l true n pt pf true n l true n l while g do pw od l g n l g n l pw true n l table semantics of probabilistic programs all the program locations are assumed to be unique c cn is the smallest algebra that makes c cn measurable definition implicitly assumes all sampling instructions of p modeled by cn to have the same distribution we impose this restriction for the sake of clarity of the it can be by the uniform unit distribution for and all other distributions from there by inversion but this forces us to explicitly deal with spaces which our arguments with all the proofs contained in this paper can be adapted to that general setting the fn characterizes the information available after executing the first n commands the result of the initial distribution of the program variables measurable in f fn and the values of c cn all measurable in fn the independence requirement does not only guarantee cn being independent of cm it also ensures that fn does not leak any information about the future that is cn is precisely at time n to see this take cm with m n independence implies a b a a for all events a fn and all real intervals a b if the random variable cm were we would be able to take cm a b as a with a b a contradiction in the above equality definition scheduler given a semantic space f µ fn x cn a scheduler is a collection nn of functions with signatures m such that n is the condition imposed on is crucial the function n selects the command to be executed at step n the decision depends only on the initial state and the past observed samples events the value of the current and future samples measurable in f fn have no influence on how the scheduler the nondeterminism present notice that the probability measure µ in the semantic space does not depend on the scheduler thus different can be defined under the same probability space this is the key feature of our semantics that do incorporate in their decisions can be modeled in our framework by the in our semantic space for example we can use u c u cn un with uk uniform in the interval the scheduler n can use the result of un as it is fn measurable definition operational semantics let p l v l l be a probabilistic program with f µ fn x cn being its semantic space the semantics of p under a scheduler n is given by the following sequence of ran dom vectors on the probabilistic space f µ that is adapted to fn l x l xn l x xn cn where kn n the command selected by the scheduler to be executed at time n a scheduler is valid if every selected command is enabled in the respective state ie the following holds n k ln xn gk a valid scheduler is if it the next command to execute based solely on the current value of the program variables l xn l xm n m in the rest of the paper we only consider valid this restriction does not affect any of our results since this class is provably enough to prove almost sure termination however it simplifies our proofs as can be viewed as a function l × rn m the connection between our program syntax and guarded commands ie the intuitive semantics of probabilistic programs is given in table where k is the projection of a tuple of size n on the kth component and denotes set note that the structure displayed on the right of figure is a compressed version of what is obtained when applying this semantics to the program on its left almost sure termination in this section we the notion of almost sure termination and its variants for this we introduce the notion of ranking which are a generalization of ranking functions we prove that the synthesis of ranking is a sound and complete proof method for positive almost sure termination for a restricted yet useful class of programs a program terminates if the time ie number of steps until the location l is reached is finite for this to hold one has to prove that the program eventually reaches that location we introduce two random variable t and t that measure these times the former indicates the time step when the program under scheduler reaches the final location l the latter is the time step for which it is guaranteed that any valid scheduler has already terminated we that t can be defined in our setting just because all share a common probability space the formal definition of these rv is as follows t t ln l sup t it is not difficult to prove that t is indeed a time more is the argument for t the definition of t involves a over an set of times and an number of operations over measurable sets does not necessarily yield a measurable object lemma t and t are times proof t is a first time and is as such the typical example of times to see that t is also a time it is enough to see that t n fn take any sequence of length c cn such as ck m and consider the scheduler kk where k ck i k n and ck enabled otherwise with i the minimum enabled command after k steps the definition for the case ck not being enabled is to ensure that k is measurable the command ci is always well defined as each non terminal state has at least one enabled command any path that terminates in more than n steps will be included in t n for a proper sequence c cn the number of such sequences is exactly m n a finite and thus t n t n remark the change in the program counter from step n to step n depends only on the selected command and not on the result of the probabilistic experiment performed at step n therefore we can infer whether or not the program terminates at step n by the resolution of the scheduler at step n that depends only on events however t n is still since fn fn we are now in the position to define some important notions of termination in the presence of probability definition almost sure termination given a program and its semantics l xn for any valid the program is said to be almost terminating if for all pt if in addition et for all valid then it is said to be positive almost terminating ranking functions have been introduced to reason about programs involving discrete probability measures and count able state spaces a ranking function v can be interpreted as a random variable vn as follows vn vl xn from this perspective condition implies vn is a discrete thus the natural generalization of ranking functions on continuous distributions are definition ranking a sequence of rv yn adapted to fn is a if and fn yn in addition it is a ranking if yn and fn yn yn for some constant this definition is a slight variation of ranking from and the difference being that we give an explicit lower bound thus if then yn as and therefore termination can be another difference is a namely we do not require that the expectation always decreases by yn we require that only as long as the program is still running the connection of ranking and positive almost sure termination is given by the following lemma the result is similar to but we provide an alternative proof lemma let yn be a ranking with as required in the definition above and t n yn then pt and et e y proof first we prove by induction that ey kn the base case n is immediate since the sum ranges over an empty set for the inductive case fn yn yn x y ex ey fn yn and linearity inductive hypothesis ea pa ey kn arithmetic ey kn since yn and then kn e y for all n therefore the series k this implies that as n and hence in particular pt it remains to prove that the expectation of t is bounded by ey et k pt k definition of t k previous derivation py e y theorem soundness let p be a probabilistic program with semantics l xn and a ranking yn such that yn implies t n for all valid then p almost sure terminates and t is proof this is a direct consequence of lemma the counterexample in section the following incompleteness result theorem incompleteness there exists a program p with t for all valid and sup et finite such that there is no ranking that guarantees p terminates however we can characterize the programs on which can be used to prove termination theorem completeness if t is then there exists a ranking proof we propose the random process yn as a ranking where yn et fn t n notably the conditional expectation is well defined since et to see that yn is adapted to fn we note that the first term is by the definition of conditional expectation the second term is since t is a time and thus t n fn in fact for n the previous event is in fn lets prove that yn is a ranking fn definition of yn fn t n fn linearity fn fn et n fn and t n is et fn t n a b a b ab et fn t n t n twice and a b a a b yn yn theorem is concise elegant and seems constructive but one needs to know about the terminating behavior to apply it and still one might face that the synthesis of distributions is in general in the remainder of this paper we attack this problem by building a practical framework to synthesize ranking program manipulation we now turn to the question how to analyze properties of complex probabilistic programs the general idea is to decompose them into ones that are smaller and easier to reason about for example if our programs is a sequential composition of several we would like to infer properties for each subprogram and then transfer the results to the original program kozen showed that sequential programs correspond to function composition conditional branching to conditional probabilities and iterations to fixed points or to infinite the results presented in this section the kozen decomposition in the context of semantics for a program p we have a semantic space f µ fn x cn for the program semantics and we would like to an adequate semantics for a subprogram p of p that is we need to build a semantic space f µ fn x cn for p in such a way that we can relate the semantics x of p with the semantics x of p in the probability space f µ it does not come as a that the fn should correspond to the events that occur once l is reached in p ie fn ft n where t is a time such that lt l similarly the candidates for cn are also ct n yet we must prove that they satisfy the conditions of definition this is only the case if l is as reached lemma let t be an as finite time with respect to the fn and cn be as in definition then for all n ct n has the same distribution as cn moreover ct n is ft and independent of ft n proof the result follows from the fact that the event t can be ignored we first prove that ct n has the same distribution as cn n a t as finite k n a t k substitution k a t k independent of fk k apt k cn distributed ca k pt k t as finite ca the proof of ct n being independent of ft n is similar and thus omitted we now prove that ct n is ft ct n a t n m fm a b a b b cm a t m n fm cm is and fm true sequential programs consider a sequential program p of the form p pm we can define the random variable t k as the time when the subprogram pk is reached and t k as the amount of time spent on it t k t k n ln t k t k being a first time t k is a time the other random variable t k is however not necessarily a time as it measures a relative amount of time however we can transform it into a time by the time frame lemma t k is a time with respect to the ft kn proof we need to prove t w n is ft t k n ft kn definition of ft m t k n t k n m fm m t k m fm t k is a time true another interesting property is that if an event is not termi in pk ie t k and t k then t k and t l for all l k also t k can be as lk t l lemma let p pm be a probabilistic program with se space f µ fn x cn a scheduler and its associated semantics l xn such that t k as finite then f µ fn x cn is a valid seman tic space for program pk where fn ft kn x xt k cn ct kn moreover both semantics are related as follows l x n l xt kn t t k the identities in the previous lemma are well defined because all random variables belong to the same probability space f µ conditional branching and nondeterminism for branching structures like if g then pt else pf od we define the following times t t t f n l lt n l lf since both branches cannot be taken simultaneously the statement t t t f holds with in turn we can the time of termination of the original program as follows t t t t f the second corresponds to the execution of the join transition from table one may be to analyze pt and pf in f µ fn x cn in fact if both pt and pf terminate then the full program does but the converse does not hold for example a nonterminating pt does not termination for initial valuations that do not satisfy the condition thus we should eliminate such events from the semantics of pt and pf to do so we define the semantics of both branches in different probability spaces but we maintain the same measurable space f moreover null events in one probability space are as valid in the other one lemma let if g then pt else pf od be a probabilistic pro gram with a semantic space f µ fn x cn and a scheduler defining a semantics l xn then f xt cnt is a valid semantic space for pt with fn xt x cnt cn and similarly for f µf xf and pf where µf the semantics are related as follows lt l xn lf xf n l xn l xn g lt g lf xf n in f in f µf in f µ notice that xn and are all random vectors in the probability spaces f µ f and f µf since they are f the different probability measures just induce different stochastic behaviors as characterized in the above lemma notice that since is we can use the same analysis for the nondeterministic case because the nondeterministic condition can be replaced by a measurable set while loops the last program construction that we have to decompose is the while loop w while g do pw od there are some important random variables that characterize w s w n ln lg n lg k t lg where n l kn is the number of times location l was reached in the first n steps the random variable indicates the time when w starts the kth iteration in case w performs the loop body less than k times we could consider to be infinite but instead we consider the kth iteration to take place immediately at the time w terminates this ensures that t ie we have a partial order on the times with t as a similar to our handling of the sequential operator indicates the time spent at the kth iteration with in case the loop or diverges prior to the kth iterations the last random variable introduced above sw counts the numbers of times the guard of the loop is evaluated before termination some important identities can be derived lk t similar random variables are to be defined in case of nested while loops for the present work we only need the of sw considering the case where w w and kj indicates the current iteration of loop wj we define n ln n kj notice that whenever one of the parent loops wj terminated before kj iterations lemma let w be a program of the form while g do pw od equipped with a semantic space f µ fn x cn and a scheduler that defines a semantics l xn then f xk is a valid semantic space for pw where xk x then the following equalities as hold provided gk is not empty and is as finite lk l x gk k gk xk in f in f µ l gk lk gk lk xk in f µ a maybe surprising result is that sw is a time for a specific lemma the random variable sw is a time with respect to the proof we need to prove sw n is measurable sw n definition of ft m m sw n m fm sw n t w t w m fm t w is an time true the above lemma turns out to be very important to prove termination it suggests that we only have to look at the random process l in order to prove termination of w compositional reasoning about termination in this section we present a compositional framework for almost sure termination that fully exploits the program structure in general we are a loop w while g do p pn od where each pk can be another loop we aim to prove w is as terminating by showing that each nested loop of w is as terminating together with an as termination proof for a version of w we take great care to make the resulting framework apt for implementation a probabilistic argument if w does not involve any them we can apply a very simple compositional variant rule using logic k pk terminates and r z pk r z k r z pk r z is wellfounded while g do p pn od terminates this proof rule induces a ranking function on programs to apply this rule we need to prove the termination of each inner loop separately and ensure that the variant argument r does not increase in any pk additionally we need to find at least one pk where r indeed decreases the inference rule is sound but not complete as r can be increased in an inner loop as long as that gets later despite its simplicity it is a powerful inference rule since it can be applied recursively until a simple while loop without nesting remains thus one only needs a procedure to synthesize ranking functions for simple loops combined with effective decision procedures to verify the and strictly decreasing conditions condition r z pk r z is basically another way of expressing r r where r is the value of the expression r after executing pk such a predicate involving and expressions can be regarded as a transition invariant also predicates r r and r r correspond to conditions and ranking in the work of manna and we aim for an extension of the to the probabilistic case the need to synthesize ranking instead of ranking functions we thus need to construct the probabilistic counterpart of transition invariants or more precisely of conditions and ranking since we are dealing with decreasing the natural way forward considers probabilistic transition invariants as relations between expressions and the conditional expectation of ones this means requiring er r r for an effective way of ensuring this is given by the following inductive definition x e p p if while v e p p pt pf pw notice that the base case corresponds to the weakest precondition of that simple assignment in case that e is lin ie an expression of the form g e gn en where gk is a conjunctive linear predicate and ek is a linear expression the theorem can be applied to check p as pointed out by et al if p is satisfied it ensures that en is a of the scheduler provided all ek are the probabilistic counterpart of the ranking condition is x e p p if while v e p p p p pt pf f where is existentially quantified p guarantees that the expectation of e strictly decreases by the execution of p notably e is not necessarily after the execution of a loop because the loop body might be executed zero times the conditions dec and dec constitute an over approximation and can be so as to provide a more precise but costly analysis definition compositional ranking given a loop while g do pw od a compositional ranking r is a linear expression over the program variables such that pw and pw a counterexample although it does appear that with this probabilistic interpretation the is sound in the context of probabilistic programs this is not the case in general consider the following nonterminating program p with a nested loop p x while x do c while c do c if c then x x else x fi od x x od the inner loop p once the value is greater than in that case the variable x is set to the next instruction the value of x to and thus the guard of the outer loop remains satisfied suppose that we that the program never terminates and we instead want to find a compositional ranking for p so as to prove as termination the obvious choice would be x it is in every outer iteration and the program as soon as x is in the guard of p we only need to prove that the value of x decreases in expectation after p terminates ie we aim to show ext f x where x and xt are the values of x before and after executing p we want to prove the above by showing that the value of x does not increase in expectation after a single iteration exn fn xn for all n the latter is true because exn fn exn fn e fn xn effectively x is a compositional ranking su according to definition but ext f x since xt ie condition does not imply while it should be implied if the probabilistic version of the v rule were sound the root of this problem is that dec cannot be used to prove in the following section we show under which dec can indeed be used safely preserving probabilistic transition invariants in this subsection we present sufficient conditions to guarantee that properties are kept after almost sure termination we also give stronger conditions that are relatively straightforward to as a basis we use that the properties are at a time whenever the underlying is uniformly theorem optional sampling let xn be a and tn a sequence of increasing times then is a in if either one of the following conditions holds · tn cn for all n where cn are constants · xn is uniformly the first condition allows us to infer the property on bounded terminating programs for example without loops for the general case however we are left with the second condition which in turn forces us to prove condition unfortunately the latter is not readily in theorem provers and thus is an for our efforts to arrive at a directly implementable framework we therefore on making it more lemma ui of dominated sequences let xn be a random process and y be an rv such that xn y for all n then the random process xn is uniformly lemma let xn a random process adapted to fn such that xn and exn xn fn c for some fixed constant c and let t an time then is uniformly proof let dn xn n for all n then x k dk for all n using lemma we only need to prove that the expectation of the is finite fn definition of dn exn n fn t n is and exn xn n hypothesis ct n applying we obtain n then e k dk linearity k previous derivation c k pt k characterization of et t as we use to guarantee as termination requiring t is not a in our framework the main implementation benefit of this lemma is that the condition exn xn fn c can be directly inferred from a program statement using normal static analysis or the following function that take into account the expected behavior bm x e v if ee x v c v x otherwise bm p p bm if g then pt else pf od bm while g do pw od bm p bm p bm pt bm pf v as uniform families preserve properties in general one can use lemma also as a means to prove that a program is not positive as terminating this down to finding a positive that is only when the program terminates corollary let yn a positive with respect to the fn ie fn yn and yn for all n such that yn fn c then the time t yn is not unless y probabilistic typechecking as termination the theory developed thus far around probabilistic tions on the program variables and we discussed the basis of ob these assertions in a symbolic manner however the results are correct only if we guarantee that the program variables appear ing in the assertions are this task is in itself not trivial a program could induce an arbitrary distribution on the program variables including some with for example infinite expectation we know that all variables are of type r but we need means to infer which ones are we will attack this remaining prob lem now by means of static typechecking with dependent types to guarantee that the relevant expressions are we again rely on uniform as this implies bounded expectation we shall label each program instruction with two sets of pro gram variables yielding the form y yn p z informally it means that if variables y yn are be executing p then z will be after p ter a program will be if the labeling is obtained using the inference rules in table the rule for loops is based on the requirements of lemma the linear combination of in random variables is also a rv of the form x y is not necessarily even if both x and y are as an example consider x that is n with probability n then e x but e x this restriction can be relaxed if a previous static analysis of the program shows that at least one the two variables is bounded the rest of the rules are base p a p b a p b seq a p p b a b a p b a a b b mod a p b e linear a a x e a x e nonlinear a a x e a x ap b a b while a while g do p od a bm p a p b a p b if a a if g then p else p fi b b table inference rules theorem given a program a p b with semantic space f µ fn x cn and a valid scheduler such that i pt ii y for all variables y a and iii for all w p then zt is for all z b and for all linear expressions e such that as bs for all as s bs with s p a p f e b p f e for some fixed c e bm p e f c for some fixed c proof structural induction on p for any semantic space for the base case a x e b we only need to analyze the case when x b the only rule from table that can be applied is thus e is linear a y for all y xt e is properties ac follow immediately from the definition of dec dec and bm for the sequential composition a p b p c and using i we have t and t as finite applying the induction hypothesis ih on a p b using the same se space we obtain y t for all y b and ac for all linear expressions we can apply ih on b p c and the semantic space f µ ft n x ct n using lemma we obtain zt z t t is for all z c properties ac are again straightforward from the function definitions the conditional branching case proceeds similar but uses lemma lets prove the looping case a while g do pw od b from i we can deduce as finite we also have that a pw a is thus we can apply ih with respect to the semantic space f xk as defined in lemma by induction on k we obtain y at time for all y a and conditions ac are satisfied at time if the program variable z b then z bm pw in turn we can apply lemma as sw is and obtain z uniform when at times thus z is when the program terminates condition a follows from lemma and theorem conditions b and c are trivial since w f and bm w the previous theorem ensures uniform of program variables at specific points in the execution however it requires to prove that loops are expected to be executed a finite number of times this is weaker than requiring positive as termination but is clearly stronger than as termination in case of nested loops the next theorem shows that the probabilistic argument is sound if a is provided yet such a labeling must ensure that compositional ranking employed are theorem compositional termination given a program a p b and a semantic space f µ fn x cn such that y is for all y a and for each al w bl in p we have a compositional ranking r satisfying i al ii p w and a p b imply a b then pt and for all loops and all proof by induction on the structure of p for any semantic space the base case is trivially terminating for the sequence and conditional branching we have to apply similar arguments as in theorem thus we omit them we turn to proving that while g do pw od is as terminating we can assume that a pw a is ie that the mod rule was not applied to p and therefore a aw bw nesting an induction on k we can prove using ih that pw as terminates with the semantic space f xk using lemma and theorem we can then infer that is as finite and that in the original semantic space of p because pw and a thus is a ranking with respect to the and from lemma sw is we are only left with the need to prove that t is as finite here the identity comes in to ensure that since all the involved rv are as finite theorem only ensures as termination ie the random variable t is not necessarily the terminating argument built into the proof is not a global that decreases in expectation at each step instead it is a ranking that decreases after as finite random steps as a concrete example the following labelled program will be used to demonstrate that our proof system is indeed capable of proving as termination of programs where et is not finite in other words it that we can prove as termination com in settings where global arguments must fail x c u c u x while c do c u x x u while x do c u x x x c u x od c u x c u u c u x od c it is easy to see that the program is according to the rules in table furthermore c is an obvious ranking for the outer loop and so is x for the inner loop thus we can apply theorem to decide that the program as terminates furthermore we can infer that sw the number of times the outer loop is executed and the number of steps in the kth iteration are all in particular since sw is a simple geometric distribution and k as the value of x is by on average starting off from k at the beginning of the kth iteration also k as x is by at most this why the program as terminates however e k ps kk ie the program does not terminate in finite mean time an extensible framework independent of the above type system one would intuitively expect that if a program almost terminates for all possible initial states ie via distributions then the program terminates under any arbitrary distribution including those the initial precondition in our labeling theorem a program p with variables xn terminates for all initial valuations such that xn if and only if it terminates for all initial valuations such that exn proof notice that one implication is trivially true suppose p terminates for all initial valuations that make the variables let us fix an arbitrary probability space f µ and an initial valuation x such that all xn are finite consider the semantics of this program under a scheduler and define a t we want to prove lets consider the semantics of the same program under the same probability space but with a different initial valuation namely thus we can consider the following measurable sets am t m and im n xn m notice that is and therefore we also have am im a am a and im thus im and in turn as needed this theorem is weaker than expected namely we guarantee termination for those initial distributions that make the program variables but inside our framework we get this for free to the mod rule on the other hand theorem allows us to incorporate a powerful inference rule into our framework p as terminating a v abs a p a thereby the requirements on compositional ranking so that they only need to ensure of variables this rule makes it possible to into our framework background knowledge about program fragments especially by standard termination arguments related work termination of concurrent probabilistic programs was first studied by and pnueli they focused on finite state programs under fairness assumptions in that setting termination is a pure topological property actual probabilities do not play a role later they gave a sound and complete characterization for almost sure termination in case of countable state spaces and proposed a sound and complete method for proving termination of finite state programs their approach is based on and proceeds by finding a regular expression on the possible outcomes of the random experiments that guarantees termination regardless of the actual state used abstract interpretation techniques to approximate the probability distribution of loops he proved termination in cases where the probability of executing a loop more than n times decreases exponentially with n et al proved as termination in the context of probabilistic pushdown automata using lemma and morgan propose a sound variant rule for probabilistic programs their notion is less general than ranking as they require variants to be upper bounded and studied positive as termination in the context of term rewriting systems developed a proof system for positive as termination for rewrite systems under innermost strategies using induction it is not clear how the author dealt with the problems discussed throughout this paper and applied aspects of theory in the context of verification of deterministic probabilistic programs presenting sound conditions to prove termination using global ranking termination analysis for programs has in the last there are several approaches to prove termination of functional programs and rewriting systems including the size change principle and dependency pairs in case of imperative programs modern approaches rely on synthesizing several small ranking functions and combining them approaches try to find an order in the ranking functions in such that the largest modification always decreases ramsey methods exploit the fact that a relation is wellfounded if its transitive closure is contained in a disjunction of wellfounded relation for a summary on both methods we refer to that proposes a hybrid approach discussion based on a novel treatment of probabilistic program semantics this paper has successfully addressed several open questions in probabilistic program termination research on the foundational side we have extended the theory of ranking to provably work with bounded nondeterministic programs this is with a sound and complete proof method for almost sure termination together with a safe method to identify the set of program variables having finite expectation the framework is strictly from the distributions appearing in a program as long as they are and their are known care has been taken to make the entire approach readily implementable our framework is thus capable of proving automatically as termination on programs that state of the art methods like are unable to verify moreover it goes strictly beyond positive as termination that is the largest setting where ranking functions are complete among others our contributions can be used to improve the weakest expectation calculus of and morgan in two dimensions first we can weaken their requirement to provide a proof of termination so as to ensure total correctness the second aspect to improve upon is related to the fact that soundness of their method is in practice restricted to weakly finite programs ie where the number of reachable states from any initial states is finite this is rooted in a requirement that all variables are bounded which in turn directly ensures that all relevant expressions are our theorem in conjunction with theorem can be used to drop restrictions and thereby extend the scope of programs considerably probabilistic programming is a relatively new area of research that merges concepts form programming languages machine learning static analysis and probabilistic model checking probabilistic models are described as probabilistic programs and inference methods are used to compute exact or approximate values of probabilities and our work can be used in these contexts to perform static analysis of probabilistic programs prior to using methods as simulation results on nonterminating programs or programs where first do not exist are and usually furthermore termination analysis is also an important to guarantee the correctness of probabilistic program slicing acknowledgments this work is supported by the eu th framework under grant and the research centre and by the international program for research we would would like to thank r and jan for their comments in a preliminary version of this paper for many discussions and the many anonymous reviewers for their comments references r b and c probability and measure theory j berdine a b cook d and p w ohearn variance analyses from invariance analyses in popl pages ­ acm o and f proving positive termination in lncs ­ springer a r z manna and h b the principle in icalp lncs ­ springer a r z manna and h b linear ranking with reachability in cav lncs ­ springer t j s and a analyzing probabilistic pushdown automata formal methods in system design ­ a and s probabilistic program analysis with in cav lncs ­ springer m and s proving termination one loop at a time in cw report pages ­ k u m and h synthesis of linear ranking functions in tacas lncs ­ springer b cook a see and f ramsey vs termination proving in tacas lncs ­ springer n n y sagiv and a a general framework for automatic termination analysis of logic programs algebra comput ­ j a and s proving termination of probabilistic programs using patterns in cav lncs ­ springer j and k markov decision processes springerverlag new york inc new york ny usa r w assigning meanings to programs mathematical aspects of computer science ­ f g foster on the stochastic matrices associated with certain processes the of mathematical statistics ­ j r and p the dependency pair framework combining techniques for automated termination proofs in lncs ­ springer i induction for positive almost sure termination in pages ­ acm a d gordon t a henzinger a v and s k rajamani probabilistic programming in pages ­ acm f jp and a on a for probabilistic loop invariants in lncs ­ springer f jp and a operational versus weakest semantics for the probabilistic guarded command language perform eval ­ s and m concurrent probabilistic programs or how to schedule if you must siam j comput ­ s m and a pnueli termination of probabilistic concurrent program acm trans program lang syst ­ ck a v s k rajamani and s slicing probabilistic programs in pldi pages ­ acm c jones probabilistic nondeterminism phd thesis university of edinburgh jp a l and c c morgan generation for probabilistic programs automated support for methods in sas lncs ­ springer s and z manna a closer look at termination inf ­ d kozen semantics of probabilistic programs j comput syst sci ­ d n a and c m termination analysis with compositional transition invariants in cav lncs ­ springer c s lee n d jones and a m the principle for program termination in popl pages ­ acm a and c morgan abstraction refinement and proof for probabilistic systems springer d an abstract analysis of the probabilistic termination of programs in sas lncs ­ springer a podelski and a rybalchenko transition invariants in lics pages ­ ieee computer society a podelski and a rybalchenko a complete method for the synthesis of linear ranking functions in lncs ­ springer k and a v termination detection in logic programs using argument sizes in pages ­ acm press d probability with cambridge university press 