record of the fifth annual acm symposium on principles of programming languages verification and design aspects of true concurrency david computer science department university of california california introduction most abstract models set of parallel pro define a computation of the model to be a sequence it is either a sequence of actions taken by the system or a sequence of states of the system existing between actions is represented only by the fact that following a given action or state the next action or state is not necessarily unique that is par is represented by nondeterminism a w has called this representation approach concurrency as opposed to true concur he among others has the of a l ordering between events that are only known to be partially ordered in this paper a definition of an algebraic model of a set of sequential pro model is presented are directed the computations of this acyclic graphs the nodes of each computation graph represent computer opera tions and the edges represent the partial ordering of operations with respect to time examples demonstrate that these directed graphs aid in focusing a attention on the most important features of a com the model suggests the following cation paradigm since systems often execute a certain sequence of actions to achieve a certain goal verification procedures should identify these sequences whether or not each is performed with in a single process a key notion in the abstract model is the treat ment of synchronization mechanisms as processes a programming language syntax called path which is suggested by this notion is presented path programs are a generalization of the path expressions of and the programming notation is based on the assumption each shared that a processor can be to data structure in the system the of this processor is to control the synchronization of operations on the data structure the mathematical model definition a schema abbreviated is a triple mv a p is a finite alphabet of variable here v vl v f letters or e names or informally just variables al an is a finite alphabet of action or operation let each operation in ae of three types active passive or the subset of active and passive operations is further into subsets called classes each class contains one or more passive opera tions and one or more active operations each active operation in a synchronization class is said to correspond to each of the passive operations in the class and vice versa every a in a has two subsets of v associated with it their names are ref and mod is called the set of variables referenced by a and is called the set of variables modified by a il is called the set of variables in a those operations for which are called decisions all decisions are operations for which are called assignments every as operation has a function letter fa with it p pn is a finite set of each is a for s i s n pi es rl l et c a is the set of actions pl can e cannot contain both active passive operations from the same synchronization that and class if ei contains one passive operation from a synchronization class then it must contain all the passive operations in the class for s ij n i j et n ej d si e el is a designated starting action for pi ri c el is a relation on the actions of p i e it is ps flowchart lg inv is the set of variables age pi can access formation rules for the relations r are as follows an assignment action a single active or a set of passive it cannot be related to both can be related or operations to op a decision action has two sets of operations it can be related to these sets are called the true branch and the false branch respectively each can be a single active or op or a set of passive operations neither branch can be a combination of both active and passive operations we follow the the model itself in a manner first a com is defined to be essentially a set of se each of these is generated by one of the processes in as if it were alone in the world next a pairing is to be an bijection that pairs the active and passive operations of a tion finally a computation is constructed from computation and a pairing by each pair to be a single action a definition given an m v a p a dis connected computation for m is a directed ac graph that has the form of a collection of chains that is linked sequences of nodes associated with each node of the graph is its name which is an element of a called an instance a node which has name of a for each process a e a is pt in p there is at most one chain of instances from ei in the computation a chain associated with process p must begin with a node labeled where s is ps designated start action there s can be a branch from a node labeled aj to a node labeled a only if aj ak ri definition given an m v a p and a computation cd a ng p is a to tal bijection from the instances of active opera tions in cd to the instances of passive operations in cd p must satisfy two properties active passive for every operation operation node b which is an instance a pb must be an instance that corresponds to a of an of the p must sense if there node bl to bz arcs from be is a path of directed then there cannot be to in the arcs a path following from of definition given an m v a p a dis connected computation cd and a pairing p for cd a computation c is a directed acyclic graph formed from cd by removing every instance of passive operations for every node b which is re moved the arc leading into b is into and the arc leading out of b is changed to lead out of if cd contains no active or instances then cd itself is a computation the following represent a simple schema containing three processes operations are represented by boxes active operating by boxes and passive operations by boxes pl p p a possible is represented xa by the bl computation of this following graph xc b suppose b is to bl and b the node b and associates a passive operation let p be the bijection marked bl with the the node marked which corresponds which upper node marked b with the lower instance the above p is the of b then the computation computation following a c bl b formed from and choice of the instances of a and c in the above computation are with respect to the ordering imposed by the edges according to the of the with one another this that any temporal relationship makes them is practically between them is un known and furthermore irrelevant given that they involve no common variables and other synchronization mechanisms are represented in a schema as pro which execute passive operations such a representation is when the life his of a shared variable is an important part of a computation an by the gram example x gets s defined of such a computation program by the fo code is provided this pro cobegin x xl x xl some unspecified on the tions of tie shared var x is assumed the verification task is to show that if x o at the start of the program then x when the program ter found it necessary to introduce additional variables into the program before per forming the verification these auxiliary vari ables were essentially abstract representations of program counters as were quite similar place variables the schema version gram is represented as active operations are shown as and passive operations as of this pro follows where boxes boxes lj i process pa represents the synchronization which keeps the of x from overlapping in time because this is ex represented in the form of a sequential program it can play a part in the verification if x o and ps loop is executed twice x this partial correctness result is with out to additional schemas are also useful for rep sets of processes which are messages a simple example is the following pair of processes which communicate via a buffer the producer process reads a value from the input stream and places the value in the buffer the consumer process removes the value from the buffer and it to the output stream consumer er bx input m output y a suppose the buffer being used has room single value then whatever synchronization mechanism is actually employed its be to that into the buffer and from the buffer strictly alternate therefore the syn mechanism can be represented by the following process e r r the computations of the consisting of the above three processes will be of the following form x input q x such computations explicitly trace the life his of each of the values as it is read in placed in the buffer removed from the buffer and ten out in both the above examples a key feature of the computations appeared as a sub graph a sequence of operations was executed in order to a certain goal or in neither example was each operation in the sequence executed in the same process verification pro which take into account these across process sequences are more direct and less than those which deal directly only with processes verification techniques based on the mu schema model are proposed in the dissertation space limitations their discussion here besides of these sequences is not dependent on any particular verification technique many verification methods are capable of taking into ac count the fact that not only can the life history of a process be of primary interest but also the life history of a variable or a value path programs in a schema representation of a computer system the arbiter of operations on a shared variable is considered to be one of the pro in the system this notion can be trans into a design approach in this approach the designer assumes that every shared data structure in the system has a processor assigned to it this is similar to the assumption commonly made in concurrent programming that every process has a processor to it as processing units grow smaller and and as multiprocessor networks continue to both of these assumptions become more real the programming notion presented here amounts to a of the monitor concept of and hoare bh ha monitor tion contains a small program segment which is to be executed as an initialization step at creation time the modification proposed here is to replace that program segment with a program which executes throughout the life of the monitor this program called a path program is not only for the initialization of the monitor variables but also for the synchronization of op on the monitors shared variables the concept is a direct generalization of the ex press ion idea of and ab they propose that a data type include in its a path expression that is a regular expres sion formed from the names of the operations this regular expression specifies the order in which the operations could occur a path program also specifies the ordering of operations in ad it can make decisions based on the values of the monitor variables furthermore it can compute new values and assign them to monitor variables monitors as originally developed used or conditional critical regions for with the appropriate synchronization p primitives occurring within the monitor operations data types with path expressions all syn to a finitestate con this controller is defined by the path ex monitors with path programs give this controller full turing machine power monitors with path programs programming language involve constructs the fol monitor declaration bracket each short for operation the definitions of the monitor procedures each of bracket the path program the definition of allow where is the name of one of the monitor operations can occur within the path program semantically it that the monitors processor will permit some outside process to execute the operation named and wait until this operation has been completed before executing the statement following the allow statement the construct syntactically a pascal case statement it appears in a path program at a point where any one of a set of monitor operations can be allowed or or or statement statement semantically the construct that the path program should halt until an external process per an exec statement on an operation from the set sup pose is the monitors con process should permit the execution of this operation next the controller process should ex statement which might be compound next control should pass to the statement following exec occurs in the code of a pro external to the monitor semantically the exec the allow construct of the path program the process stops when this statement is reached and until the path program reach es a statement either an allow or an which enables the the external process is then permitted by the monitor to execute the operation if more than one process is waiting to execute the operation then one of them is allowed by the path program to pro while the rest must continue to wait some fair policy must be included in the im of the constructs the x gets program serves example of the use of the notation ae a simple pi begin exec increment end p begin exec increment end monitor var x integer x end lp allow increment observe how the path program initialization and synchronization the shared variable contains both the mechanisms for the next example is based on the bounded buf monitor presented by hoare his tor is here rewritten as a monitor with a path pro gram and are addition and mod uo n respectively denotes the message data type not specified here bounded buffer monitor var of n n get buf q count put buf count o o while o count n get count count or et count last pointer o count fi o then else allow put count r allow get count count a e th it is get and assertions easy to verify that that count n before can be used just programs count o before each each put inductive as they are for se this example demonstrates how a path pro gram describes the history of a shared variable it describes the activity of the shared variable from the point of view of the shared variable ra than the point of view of the external process es this point concept extends to other parts of the monitor as well the get and put operations are from the point of view of the external process calling the monitor these operation the caller definitions are only concerned with what expects to happen to his parameters synchronization is dealt with exclusively in the path program the schema model is intended to be able to represent any system of parallel pro not just those which of monitors with path programs the pairs formalize the synchronization activities of a system being modeled by an the ab of the pairs an assumption made in every conceptual model of parallel processes whatever the level of detail under discussion the existence of a lower more primitive assumed synchronization for example mechanism is always discussions of monitors using conditional critical regions typically will detail the implementation of the conditional cal regions but leave completely the mechanism which prevents more than one monitor process call at a time it is in this sense meaningful to discuss imple the path program primitives in terms of path program primitives the authors tion contains details of how the exec and allow primitives can be implemented to lower level monitors with path programs whose are in turn implemented in hardware as hardware costs decrease and as automated systems continue to be a new systems design paradigm becomes feasible it will no longer be necessary to design software systems to fit existing hardware instead a design process could be as the first step all parts of the system could be de signed in a lowlevel algorithmic language as the second step parts of this would be chosen to be implemented in hardware while other parts are implemented as software the key aspect of such a design will the the algorithmic language it must be simple enough to act ae a hardware design language yet powerful enough to be appropriate for specifying software the possibility of tation mentioned above gives to the can for such a design language of a pascal syntax using monitors with path programs references e a proving assertions a about parallel programs jan bh p principles prenticehall systems r and specification of process synchronization ing path expressions lecture notes science a the us in hoare ca r monitors an operating system structuring concept cacm oct a w lecture conference on petri nets july given at the mit and related meth r m parallel programs formal cacm verification july of h c correctness in operating systems ph d thesis university sept r on synchronization tive systems ph d thesis carnegie mellon university d w a true concurrency approach to process modeling verification and design ph d thesis university of california oct s s axiomatic proof tech for parallel programs ph d thesis cornell university july 