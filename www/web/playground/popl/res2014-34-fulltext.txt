authenticated data structures andrew michael and university of college park usa abstract an authenticated data structure is a data structure whose operations can be carried out by an untrusted prover the results of which a verifier can efficiently check as this is done by having the prover produce a compact proof that the verifier can check along with each operations result thus support data and processing tasks to untrusted servers without loss of integrity past work on has focused on particular data structures or limited classes of data structures one at a time often with support only for particular operations this paper presents a generic method using a simple extension to a mllike functional programming language we call · with which one can program authenticated operations over any data structure defined by standard type constructors including recursive types sums and products the programmer writes the data structure largely as usual and it is compiled to code to be run by the prover and verifier using a formalization of · we prove that all welltyped · programs result in code that is secure under the standard cryptographic assumption of hash functions we have implemented · as an extension to the ocaml compiler and have used it to produce authenticated versions of many interesting data structures including binary search trees trees skip lists and more performance experiments show that our approach is efficient giving up little compared to the data structures developed previously categories and subject descriptors d programming languages language constructs and types and structures general terms security programming languages cryptography introduction suppose data would like to allow third to its data providing a query interface over it to clients the data wants to clients that the will answer queries over the data even if they or another party that a have an to lie as examples the data might be providing data a certificate revocation list the tor list or the state of the current permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm such a scenario can be supported using authenticated data structures computations involve two roles the prover and the verifier the plays the role of the prover storing the data of interest and queries about it the client plays the role of the verifier queries to the prover and verifying that the returned results are at any point in time the verifier holds only a short digest that can be viewed as the current contents of the data an copy of the digest is provided by the data owner when the verifier sends the prover a query the prover computes the result and returns it along with a proof that the returned result is correct both the proof and the time to produce it are linear in the time to compute the query result the verifier can attempt to verify the proof in time linear in the size of the proof using its current digest and will accept the returned result only if the proof verifies if the verifier is also the data the verifier may also update its data stored at the prover in this case the result is an updated digest and the proof shows that this updated digest was computed correctly computations have two properties correctness implies that when both execute the protocol correctly the proofs given by the prover verify correctly and the verifier always receives the correct result security implies that a computationally bounded malicious prover cannot the verifier into accepting an incorrect result authenticated data structures can be traced back to the wellknown hash tree can be viewed as providing an authenticated version of a array more recently authenticated versions of data structures as as sets dictionaries range trees graphs skip lists hash trees and more have been proposed in each of these cases the design of the data structure the supporting operations and how they can be proved have been from involving a new potentially proof of security this state of has the of new datastructure designs as previous ideas are not easily reused or we believe that will make their way into systems more often if they become easier to build this paper presents · lambda a language for programming authenticated data structures · represents the first generic languagebased approach to building dynamic authenticated data structures with provable guarantees the key observation underlying design is that whatever the data structure or operation the computations performed by the prover and verifier can be made structurally the same the prover constructs the proof at key points when executing a query and the verifier checks a proof by using it to the query checking at each key point that the computation is · implements this idea using what we call authenticated types written · with coercions and unauth for introducing and eliminating values of an authenticated type using standard func this property is sometimes called soundness but we this term to avoid confusion with its standard usage in programming languages tional programming features the programmer writes her datatype definition and its corresponding operations eg queries and updates to use authenticated types for example as we show later in the paper the programmer could write an efficient authenticated binary search tree using the type definition type tip bin of × int × along with essentially standard routines for and insertion then given such a program the · compiler produces code for both a prover and a verifier that will produce or respectively a proof of the correct execution of the corresponding operation proofs consist of a stream of what we call shallow projections of the data the prover while running its routine the provers code adds to this stream at each unauth call while the code from the stream at the corresponding call checking for consistency we give a more detailed overview of how this approach works and how authenticated types are represented in section importantly as we show in sections and any welltyped program written in · to a prover and verifier which are correct and secure where security holds under the standard cryptographic assumption of hash functions · provides two key benefits over prior work first it is extremely flexible we can use · to implement any dynamic data structure both queries and updates expressible using data types involving sums products and recursive types our theoretical development though not our implementation also supports authenticated functions previous work by et al can also be used to build but it supports only queries and not incremental updates requires the data structure have a single root and does not support authenticated functions flexibility does not its performance to the best of our knowledge the asymptotic performance of every prior construction from the literature based on hashing can be matched by · we have implemented an optimizing · compiler as an extension to the ocaml compiler described in section and using it we have implemented trees authenticated binary search trees trees skip lists and trees as well as improvements to standard data structures experiments described in section the expected asymptotic performance of · show the benefit of the two compiler optimizations we implemented which exploit tradeoffs and demonstrate that the performance of · is with versions second main benefit is ease of use we find that it is relatively simple to construct an using · just write the standard data structure in a purely functional style and in authenticated types we give a for this in the next section there is no need for the designer to prove anything assuming the resulting program type checks the programmer is that the produced prover and verifier code both correctness and security by contrast et al provide no such support programmers must write and check their implementations manually · can be freely composed and just as one might expect with normal data structures a fact which we hope will make them more readily all of this is in contrast to the state of practice with summarized in section which to versions that are hard to build and compose in summary this paper makes the following contributions we present · a purely functional language in which one can write a rich array of authenticated data structures using a novel feature we call authenticated types informally hash is if it is computationally infeasible to find distinct inputs x x such that we treat this more formally in section n h n h n h str n h n h n n str h n str h n str h n str h h h h h figure a tree and proof for fetch describing the path with edge and node we formalize the semantics and type rules for · and prove that all welltyped · programs produce protocols that are both correct and secure we have implemented · as an extension to the ocaml compiler and used it to program a variety of existing and new showing good asymptotic performance that is with implementations overview this section presents an overview of our approach we begin by describing trees the canonical example of an authenticated data structure then we give a for · by showing how we can use it to implement trees we conclude with a discussion of the flexibility and benefits of using · to write efficient authenticated data structures background trees the canonical example of an is a tree which is the authenticated version of a full binary tree where data is stored at the leaves but not the interior nodes a tree of height h can represent an array of n h elements x xn each leaf node is coupled with a digest that consists of the hash of the associated element while each internal node contains a digest that is the hash of the concatenation of the of its two children a of a tree for h is given in figure each leaf is associated with a string str str etc each node is according to its position in the tree with x y indicating x as the row and y as the column the canonical query the value xi at index i n when thus the prover call it p returns the value xi along with the set of needed to compute the root digest the verifier call it v keeps a copy of the root digest itself and checks the proof by this digest from the proof to make sure the two match figure shows the proof for a fetch at position i ie the leaf at position n it consists of three elements in sequence the string str the hash h and the hash h these are labeled with the nodes of the tree that they relate to verification proceeds bottom up v computes the hash of str which is h and that with the hash h provided in it then these two and takes the hash to compute what should be the digest for node n ie h then it h the hash for n provided in with its computed digest for n and the result it then that this computed digest equals h the digest it stores for the whole tree performance analysis because the tree is balanced the size of the proof is always log n additionally the computational cost for each of p and v is log n the overall size of the data structure stored by p is on whereas v at no point requires more than a constant amount of storage or memory in particular v only stores a digest of the tree between fetch operations the full code for our implementation is available at the following url type tree tip of string bin of × type bit l r let rec fetch list string match idx unauth t with tip a a l idx fetch idx l r idx bin r fetch idx r figure trees in · the tree is assumed to be complete ie with a number of leaves and because v processes each hash in order it can discard it immediately after it is read for this reason we often refer to as a proof stream security analysis as described in the introduction we are interested in two properties of this scheme correctness says that when p executes a query f over a tree t correctly then v gets the same result as it would have if it had just computed f t normally the second property security says that a computationally bounded prover p cannot cause v to accept an incorrect answer the basis of this property is the use of we can show that if p can cause v to accept an incorrect answer then the proof returned by p will yield a we state these properties precisely in the context of · in section introducing · a language for programming the tree verification procedure was carefully designed with the properties of the underlying data structure in mind in particular there can be but one path from the root to a given leaf and from this path we can determine sufficient to the root digest the question is how might we generalize this approach to arbitrary data structures t involving arbitrary computations f we designed · as a solution to this problem · is a completely standard purely functional programming language extended with authenticated types · along with coercions and unauth which have type · for introducing authenticated values and type · for eliminating authenticated values respectively a function f using authenticated types is compiled to variations fp and fv for the prover and verifier respectively data of type · stored at the prover is like a normal value of type but augmented with while data of type · stored at the verifier is simply a compact digest the coercions at the prover facilitate proof generation while at the verifier they check a provided proof in short design exploits the observation that proof generation and proof verification can be made structurally identical essentially by them on top of the ideal computation of f t example as an illustration figure shows a version of trees written in our · implementation the type tree is simply a binary tree with strings stored at the leaves the fetch function takes an index expressed as a list of bits which is interpreted as a path through the tree with l bits the traversal to the left and r bits it right the function returns the string associated with the tip that is eventually reached notice that since the argument t has type the function must call unauth t to coerce it to a tree to be matched against we give a use of in section interpretation of authenticated types all standard constructs have the usual semantics in both fp and fv but authenticated types are interpreted differently prover for fp values of type · consist of pairs h v where v has type and h is its digest ie a hash of the shallow pro t h h where hash h h h hash h hash h figure a · tree t at the prover of type from figure and proof stream for query fetch t r l of relevant shallow projections are given in the lower right of v the shallow projection of a value is just the value itself for all values of type that do not consist of any authenticated types · while the shallow projection of an authenticated value h v is just the digest h the formal definition is in figure looking at the definition of type tree in the figure we can see that recursive references to the tree in the bin case are authenticated as such the provers representation is just as described in the previous subsection each node of the tree has the form bin h v h v which consists of the left subtree v and its digest h and the right subtree v and its digest h each digest consists of the hash of the shallow projection of its respective tree so if v was a leaf the shallow projection is just itself and thus h is the hash of on the other hand suppose v was a node bin h v h v then h is this nodes shallow projection and h is its digest verifier for fv values of type · consist solely of the digest h of some value of type as such for our example while the prover maintains the entire tree data structure the verifier only keeps the digest of the root in general values in fv are the shallow projections of their corresponding values in fp we define this notion formally in the next section to the coercions for both the prover and verifier the v coercion computes the hash h of the shallow projection of v for the prover this hash is with v while the verifier only h itself the interesting part is the semantics of unauth for the prover unauth is called with h v and it simply returns v in addition it computes the shallow projection of v and adds it to the proof which is just a list of such shallow projections we often refer to as a proof stream to emphasize the list structure for the verifier unauth takes a hash h and compares it to the hash of the element s at the head of the proof stream which should be a shallow projection of type if all is well this element is the one the prover put there and so the will match and the coercion returns s otherwise there is a problem and verification fails example query figure the provers version of an object of type corresponding to the tree from figure these trees are structurally similar but not identical in particular notice that a nodes digest is stored with the pointer to that node rather than at the node itself suppose the prover executes the query fetch r l t which corresponds to the query from section the figure also the proof stream it produces along with the of shallow projections of relevant tree elements the first thing the prover will execute is unauth t which returns the pointer to the first node and stores its shallow projection in the proof that this is the same as the node but the subtree pointers have been execution continues to the third case of the match which recursively calls fetch l r where r is bound to the authenticated value h v such that v is the right subtree the prover then invokes unauth on this pair returning v and adding to the proof stream this time we take the second case of the match on h so the call to unauth returns and adds its shallow projection itself to the proof stream execution concludes with str as the final result while the final proof stream consists of three elements representing the three nodes visited the verifier begins with the proof stream and just the digest of t which is h it then runs fetch r l t using its version of the code it first executes unauth h which compares h to the hash of the first element s of the proof stream which is the match as per the equations given in the lower right of the figure and thus execution continues using s execution proceeds to the third case of the match recursively calling fetch with l and h this time calling unauth h results in comparing h to the hash of the second element in the proof stream which is and once again the match and the proof stream element is returned the second branch of the match so the recursive call passes and h finally unauth h compares h to the hash of the final element of the proof stream which is returned as the match thus execution concludes with the final result as str as all hash checks the verifier has the provers execution is correct analysis · trees are asymptotically as efficient as the and as secure as before the verifier maintains only the digest between queries and the size of the fetch proof and the time to generate and verify it is n the proof stream consists of one shallow projection for each recursive call to fetch the argument for security once again on though · verification checks the root digest topdown rather than bottomup our proof stream has some redundancy it contains h h h and h whereas in figure the proof contains only h and h but this is only a constant factor and can be optimized away cf section discussion benefits of · the primary benefit of writing in · over prior approaches is flexibility and ease of use · can support essentially any computation over a data structure that is expressed as a functional program moreover as proved in section writing an in · ensures it is both correct and secure there is no need for a designer to make a new argument for each new data structure as far as we are aware · can be used to implement any previously proposed based on hashing as described in section so far we have successfully implemented trees and authenticated versions of binary search trees trees skip lists and variations of the block chain all of which asymptotically identical or better performance than their counterparts support for updates et al also previously proposed a generalpurpose scheme that supports based on dags in principle their scheme could also support the data structures but only for query computations not updates by contrast updates are completely natural in · for example the function update in figure updates a tree the verifier could a request to the prover to run update r l t str the prover will produce a proof stream for the operation along with a new authenticated tree t that contains the modification and which shares much of the structure of the original tree t as per standard functional programming style the prover can then update its root to now be t and then send the verifier the result of the execution which is the digest portion of t and the proof stream let rec update list match idx unauth t with tip idx l r update idx r let update cps list let rec update k idx t x match idx unauth t with tip unauth k x l idx update t idx l x r idx update t idx r x in update t t idx t type stack e sl of × sr of × let update stk list let rec build idx t × stack match idx unauth t with tip s build idx l s r build idx r s l in let rec apply match s with e child r apply r unauth s l apply child unauth s in apply build idx t e figure functions for updating a tree in · the verifier can then use in the usual way to verify that the digest of t is indeed the right result and then update its local root controlling performance the fact that · is a generalpurpose programming language means that it substantial flexibility to the designer in an design to her needs as one possible the designer might operations to better control space usage consider the update function once again while the proof stream only a constant space overhead since the verifier can discard each element after it is read we observe that executing update will require n stack space since the function is not tail recursive one way to eliminate this overhead is to rewrite update in continuationpassing style cps such that the continuation itself is authenticated as for the function update cps given in the middle of figure as such recursive uses of nested continuations will be replaced with a hash effectively bounding the depth of the stack encoded in the continuation to the best of our knowledge no prior work has considered authenticated closures another way to achieve the same effect but perhaps less is to use an explicit authenticated stack as is done by update stk given at the bottom of the figure the designer could also performance by the definition of the data structure itself for example we could have defined trees instead as follows type tree tip of string bin of × tree in this case we are only hashing nodes and will never hash this definition makes more sense when the hash of the tip is larger in general the prover will return the shallow projection of the result of a computation back to the verifier when the result is a normal value the prover will thus return the value itself as with the result in our fetch r l t example query types values v e × µ · x xe rec inj v inj v v v roll v v let x e in e v v case v v v v v v v unauth v figure syntax for types and terms than the representation of tip itself eg if the tree stored integers instead of strings as another variation we might imagine defining a tree that only its children type tree tip of string bin of tree × tree of × tree then the tree might go several levels using bin before using this design thus increases the constant factor on asymptotic space usage but may reduce time all of these are possible and easy to experiment with thanks to the fact that · is a generalpurpose programming language however this flexibility both ways there is nothing at the moment the programmer from producing a design as an extreme example the programmer could write type tree tip of string bin of tree × without any use of authenticated types this design will be secure and correct as with every · program but will effectively require the verifier to maintain the entire tree not simply a digest fortunately there is a simple rule of that may have already become evident to the reader by this point the datastructure type definition should recursive references thus for shallow projections to be we leave to interesting future work the task of the transformation of a type definition to an efficient authenticated one · a language with authenticated types this section formalizes · our language for writing computations over authenticated data structures we present the syntax typing rules and operational semantics for · programs the next section proves that · computations produce correct and secure results syntax figure presents the syntax for · other than authenticated types · the type language is entirely standard consisting of the unit type function types sum types product types × recursive types µ and variable types arising from these in this syntax our authenticated tree type defined in figure would be written · × · where string would itself be encoded eg as a list of integers our formal language does not include parametric polymorphism for simplicity but adding it would present no difficulties the language does not support references because would for · values in particular given an authenticated value h v where v is a reference a mutation via v may h terms values v and expressions e are in normal form to keep the semantics simple in this form the grammar forces us to write let x e in let y e in x y instead of the more familiar e e for example in addition to variables x the term language includes functions xe and function application v v values inj v and inj v which are eliminated by case v v v where v and v are expected to be functions v inj v v inj v v v v case v v v v v · v · unauth v figure selected typing rules products v v eliminated by expressions v and v values of recursive type introduced via roll v and eliminated by v and finally fixpoints rec for defining recursive functions where inside of ye references to x refer to the function itself authenticated types · are introduced by coercion and eliminated by unauth typing the typing judgment for · programs is the usual one written e it states that expression e has type under environment where is a map from variables x to types typing rules for most constructs are standard selected rules are given in figure operational semantics in practice our compiler takes a program like the one in figure and outputs versions to be run by the prover and the verifier in our formalization we define distinct semantics for the same program as determined by an execution mode m where m p for the provers execution and m v for the we also define a mode i for the ideal case representing a computation that happens in the normal way ignoring authenticated types this is needed for stating the security and correctness properties we define a smallstep operational semantics of the form e m e where m is the mode and is the proof stream which is a list of shallow projections s this can be read an expression e coupled with a proof stream can evaluate one step in mode m to produce an expression e and an updated proof stream we define e mi e to be the transitive application of the relation it states that e evaluates in i steps to e in mode m starting with proof stream and with the proof stream is produced in mode p so is a prefix of in this mode the stream is consumed in mode v and thus is a suffix of the proof stream is ignored in mode i we use the operator to denote the concatenation of two proof streams treating as associative with the empty stream as the identity we write s as the singleton stream containing element s the rules for standard language features are identical in all three modes and are standard they are defined in the top portion of figure and we discuss them briefly in order the rule for function application xe v v for x in substitution is written application of a recursive function is similar when the function rec is on the lefthand side of an application we substitute x in the function body e with the recursive function itself is used to sequence computations either evaluating the bound expression e one step or else if this expression is a value v substituting that value for x in the body e the semantics of case depends on whether it is given inj v or inj v in the former case we substitute v in the first lambda term the true branch else we substitute it in the second false one projection from a pair v v produces v for and v for finally the recursive type coercions and roll each other xe v rec v m m ye v where e let x v in e m case inj m case inj m v v m v v v m v roll v m v e m e let x e in e m let x e in e e e e mi m im e e e e m e figure standard and operational rules v unauth v v unauth h v v i v i v p hash v v p v v v hash v hash s h s unauth h v s where v h h v figure operational rules for authenticated values x x h v h xe xe v v unauth v unauth v v v v v v v roll v roll v v v rec rec v v case v v v case v v v let x e in e let x e in e figure shallow projection of an expression e written e the rules for the relation are given at the bottom of figure and are also standard the operational rules for authenticated values are given in figure for mode i authenticated values of type · are merely values of type and the operations are for mode p values of type · are implemented as a pair h v of a hash h and a value v of type as shown in the rule the hash is computed by applying a hash function hash over the shallow projection of v written v we do not formalize the semantics of hash explicitly in practice it can be implemented by the value it is given and hashing that using a hash function the shallow projection operation is defined in fig for functions xe involves the functions code such that functions will have the same hash value we discuss implementing authenticated functions more in section it is essentially a fold over the structure of the term preserving that structure in every case but that of values h v here we simply drop the value v and retain the hash h another interesting case is functions xe we recursively into e to translate any h v values that appear there such values will not appear in source programs but they can arise via substitution under returning to figure the semantics of unauth h v is to strip off the hash returning v while adding the shallow projection of v to the end of the proof stream finally for mode v the representation of · is the hash h of a value of type the rule constructs this representation while the unauth rule checks that the hash value matches the shallow projection at the head of the proof stream metatheory we want to show that welltyped · programs will a produce correct is results that all three modes agree else b a malicious prover has been able to find a hash which by assumption is computationally difficult we call property a correctness and property b security in this section we state and prove these two properties type soundness to begin we want to prove that design is sensible in that the ideal semantics is sound and entirely ordinary we can prove the standard type soundness lemma about the ideal modes semantics lemma type soundness if e then either e is a value or there exists e and i such that e ii e and e proof the proof is completely standard using progress and preservation lemmas and on e ii e agreement now we must define what we mean when we say that the different execution modes agree on their cannot be that these results are syntactically equal because each mode authenticated values differently for example consider the update function from figure in the ideal setting this function will return a normal tree · values are the same as those of type the tree v will contain no on the other hand the prover will return a value h vp where h is the digest of vp for the same insertion on the same tree the results v and h vp in i and p modes respectively should agree without being equal v will just be a normal tree while vp will contain the elements and subtrees the should be the same and running the insertion at the verifier will return a digest h which should match the digest in the provers returned value h vp we formalize this connection as a relation e ep ev given in figure which states in environment ideal expression e prover expression ep and verifier expression ev all agree at type in every case but that of authenticated values the last rule agreement follows syntactic structure of the terms and the shape of each rule matches that of the standard type rules the rule for authenticated values formalizes the intuition given above it states that v h vp h · holds when a the digest h of both the prover and verifier is the same b this digest is the hash of the shallow projection of the provers value vp c the provers value vp with the ideal value v now we prove some useful facts about terms in agreement lemma agreement suppose e ep ev then ep ev e ep ev implies that ep ep and ev ev x x e ep ev xe v vp vv v vp vv v v vp vp vv vv e ep ev x e ep ev let x e in e let x ep in ep let x ev in ev x ye rec rec rec v vp vv inj v inj vp inj vv v vp vv inj v inj vp inj vv v vp vv vp vp vv vv vv vv case v v v case vp vp vp case vv vv vv v vp vv v vp vv v v vp vp vv vv × v vp vv × vp vv v vp vv × v vp vv v vp vv µ roll v roll vp roll vv µ v vp vv µ v vp vv µ v vp vv v vp vv · v vp vv · unauth v unauth vp unauth vv v vp vp hash vp h v h vp h · figure agreement relation defines those expressions that agree ie that are if not syntactically the same in the ideal prover and verifier modes the most interesting rule is the last one while the rest are versions of the standard type rules e either e ep and ev are all values or none of them are proof by induction on e ep ev the first part shows the agreement relation is con to the shallow projection provers term only ever with a term when the latter is the shallow projection of the former moreover we prove for any given ideal term e there is at most one pair of terms ep and ev that agree with it under a given environment and type that agreement implies e is welltyped and that values only agree with other values client and server agree in a application scenario a sent by the client will reference the data structure stored at the server using a free variable eg the t in the query fetch t to run this query on the server we substitute the provers representation for t while to verify the result at the client we substitute ts digest these representations should agree the following lemma states that given an expression e containing free variables with authenticated types substituting authenticated values that agree for the free variables of e produces versions ei ep and ev that also agree lemma given the following e where e contains no values of type · for all xi domain a xi for some i b vi hi vp i hi for some hi vi and vp i ep e h vp x hn vp n xn ev ei then ei ep ev the proof of this lemma follows from straightforward application of the following substitution lemma lemma substitution if x e ep ev and v vp vv then ep vp x ev vv x proof the proof is by induction on x e ep ev the only interesting case is when x v h vp h · the empty environment in the premise v vp vp ensures that v and vp contain no variables so the substitution will be the identity and the result follows by assumption correctness and security now we can state and prove our main theorem theorem which the two properties of interest correctness and security for both properties we start with the assumption that terms e ep and ev agree which will be the case at the start of evaluating a as per lemma the evaluation represents the specification of correctness if e can evaluate to e in ideal mode in i steps then the verifier when the proof stream produced by the provers evaluation of ep should evaluate to some ev which along with the provers resulting term ep with e on the other hand if the verifier does not consume but rather some other chosen stream a that does not contain as a prefix eg because the server is or then the only way the verifier can accept an incorrect result is if the adversary has found a hash that is the consumed stream a contains an element s that corresponds to an element s in such that s s but hash s hash s as discussed further in section this implies the standard cryptographic notion of security for this setting if hash is here is the theorem stated formally theorem suppose that e ep ev correctness if e ii e ev such that · ep pi ep · ev vi ev · e ep ev then there exist ep security if a ev iv ev then there exist e ep such that · e ii e · ep ip ep · a · e ep ev or else there exist j i ep s and s such that · ep pj s ep · a s · s s but hash s hash s the proof is by induction on the length i of the derivations relying on two lemmas about the correctness and security of evaluation which we present next lemma correctness if e ep ev and e i e then there exist ep ev and such that for all p e ep ev p ep p p ep ev v ev proof by induction on e ep ev most cases are straightforward and follow by application of the substitution lemma the two interesting cases deal with authenticated computations · suppose e ep and ev are v vp and vv respectively each can take a step in its respective mode producing v hash vp vp and hash vv respectively leaving the proof stream unchanged ie now we must prove v hash vp vp hash vv · which in turn requires proving v vp vp and hash vp hash vv both are the consequence of lemma and e ep ev · suppose e ep and ev are unauth v unauth vp and unauth vv respectively by inversion on e ep ev we know that v h vp h · and by inversion on this we know v vp vp and h we can set vp and then each term can take a step in its respective mode to v vp and vp which agree by lemma finally we demonstrate that a verifier term that begins in agreement and takes a step remains in agreement unless an adversary has to find a hash lemma security given the following · e ep ev · a ev v ev then there exist e ep and such that for all p · e i e · p ep p p ep and either e ep ev and a or else there exists a pair s and s such that s and a s with s s but hash s hash s proof by induction on e ep ev since ev is not a value we know from lemma that neither are e or ep so we can always introduce e and ep most cases are straightforward because evaluation yields and a and e ep ev can be obtained directly from inversion on e ep ev the remaining cases are for let binding and unauth the former follows by induction for the latter we have e ep and ev are unauth v unauth vp and unauth vv respectively since these terms agree by assumption we know that vp h vp and vv h for some vp from the rule for p we know vp then there are three possible outcomes depending on a a or a s and hash s h in which case a ev is stuck and we have a contradiction a vp and ev vp from which e ep ev follows directly a s and vp s but hash vp hash s although the security property guarantees that the ideal computation can always take as many steps as the verifier in particular the verifier cannot run forever if the ideal computation terminates we would also like to show that ideal computation can take as many steps as the prover remark suppose e ep ev and p ep ip p ep then there exists e ev such that e ep ev e ii e and ev vi ev proof this follows from straightforward induction on derivation length i and e ep ev applying lemmas and cryptographic security in the cryptographic security definition for a fixed protocol eg as per et al somewhat informally there is an attacker who is assumed able to control the interaction between an prover and verifier the attacker may specify a sequence of operations queries q qt that the verifier to the prover for each such query the prover generates and sends a proof to the verifier both update their local state as appropriate finally the attacker specifies a query qt along with an generated proof string a the attacker succeeds if a causes the verifier to output an incorrect result for the given query the is parameterized by a security parameter k which we may identify with the output length of the hash function being used the is secure if no attacker running in polynomial time in k succeeds with probability security is proven by contradiction with the of an appropriately chosen hash function to translate the standard cryptographic notion to our setting we must address three first we must provide a notion of programs and inputs such that the is specified by an arbitrary · program and the adversary is allowed to choose the inputs second in order to show contradiction with we must define a specific procedure by which the hash function is instantiated after the program and the adversary are fixed finally we must relate the number of reduction steps taken by a · program to a number of steps taken by a turing machine we then claim that the reduction argument in theorem implies that this security definition holds for every · program inputs we can treat the free variables in an open · expression as program inputs in our running example for instance the expression fetch idx t has idx and t as free variables the adversary chooses the inputs by computing welltyped and values to substitute for each of the free variables choosing the hash function our language is parameterized by an arbitrary hash function which we have assumed is however to be precise is only defined formally for a family of hash functions rather than some fixed hash function see and that is is defined according to the following game first take an arbitrary adversary that runs in polynomialtime given a security parameter k next choose hash randomly from a family of functions and give the adversary a description of hash as input the family of hash functions is if the the adversary outputs a in hash with probability in k the following game captures this notion in the context of · let e be an arbitrary welltyped · program specifying the data structure being supported and let a be an arbitrary adversary that runs in polynomialtime in k choose hash at random from a family of hash functions and then compile ep and ev a succeeds if given k and hash as input it outputs values to substitute for the free variables of e ep and ev and a proof stream a such that after some polynomial of steps i the verifier outputs an incorrect answer ie a value ev such that a ev iv a ev for some a but there is no e ep such that e ii e and e ep ev note that the game begins with an arbitrary welltyped · program e before the hash function has been chosen although · is parameterized by hash the ideal terms are invariant to the choice of hash function so we can fix e and e before choosing hash however the prover and verifier terms ep and ev may actually contain so we must instantiate hash before compiling ep and ev if a succeeds then by theorem we can evaluate ep and ev on a for j i steps and extract the s and s thus it only remains for us to show that evaluation of ev and ep also takes polynomial time and then we can obtain from a a polynomialtime algorithm with the same success probability polynomialtime execution it is well known that standard lambdacalculus evaluation and execution are equivalent that is a lambdacalculus interpreter implemented as a turing machine can simulate i lambdacalculus evaluation steps in steps the only nonstandard terms in · are and unauth and each involves at most one hash computation during evaluation the time to compute a hash is proportional to the size of the shallow projection which depends on the hash output length k therefore if an ideal program e takes i steps to reach a value a turing machine can simulate the execution of e in steps and the corresponding ep and ev in steps since we assume i is bounded by the entire evaluation is implementation this section describes our prototype extension to the ocaml compiler for supporting authenticated types we discuss basic compilation two optimizations we implement and current limitations our technique for extending the ocaml compiler is based on a post by compilation the compilation process works as follows the programmer writes an ocaml program p like that of figure that contains uses of authenticated types the code will link against the module whose signature declares · as abstract and declares the polymorphic types of the and unauth coercions program p is then passed to our extended compiler which depending on a mode flag replaces each application of and unauth it finds with a call to a prover or implementation the resulting code is linked with the module this module given in figure defines type · as either a digest just the hash represented as a string or as a pair of the hash and a value of type the next four functions define the provers and versions of and unauth respectively the calls to and unauth will be replaced by calls to these functions instead we can see that their code largely matches the operational rules given in figure where the proof stream from the rules is implemented as ocaml channels output and input the one is that prover and unauth prover additionally take a function shallow that is invoked to perform the shallow projection operation this operation is needed because ocaml does not provide a generic method for over the structure of a term as such our compiler generates shallow projection functions where needed and includes them in the replaced calls to and unauth the type of the shallow projection operator is determined by the concrete type inferred at each call for example the unauth in let x int unauth y is inferred to have type int therefore we need a shallow projection operation of type int int which is just the identity the generated code will refer to the modules shallow · function shown at the bottom of the figure for handling nested authenticated values library functions are provided to enable the programmer to manipulate the proof and verification streams for example by to a file or a or performing multiple authenticated operations with separate proofs in a single execution figure shows the result of compiling a variant of authenticated binary search trees the top of the figure is the code provided by the programmer compilation will replace the call to with a call to and the call to unauth with a call to unauth these functions are defined at the bottom of the figure and employ the needed shallow projection operations the hash function referenced in figure is polymorphic having type string it is implemented by first the argument and then hashing it using which is widely used as a hash function for we use default implemented in the module this choice has an implication for security the worstcase cost to compute the hash of a malicious string is bounded only by the representation of an integer in ocaml either or bits depending on the os we used the option for the module to guarantee that any two equal objects have equal type · is written in as but we continue writing · for consistency it may be the case that two terms of different types have equal using however since we only interpret values according to known static types no polymorphism it would take a at the same type to security in our formalism which is essentially dynamically typed we assume in the abstract hash function is type · digest of string the digest prover of string × let prover shallow v · shallow v v let unauth prover shallow let prover x v in to channel output shallow x x let verifier v · v let unauth verifier let v in let y from channel input in assert h hash y y let shallow · · · figure the implementation of type constructor · and the prover and unauth and coercions code type tip bin of × int × of × int × let is empty bool unauth t tip let mk leaf xint x tip generated prover code let rec shallow function tip tip bin x y z · x y shallow · z x shallow x and shallow × int × × int × function x y z shallow x y shallow z let unauth unauth prover shallow let prover shallow figure example types and generated code for prover optimizations our compiler implements two optimizations that reduce the size of the proof stream reuse and suspended reuse we can reduce the size of the proof stream and speed up when we that the same elements may appear in the proof stream more than once for example a client may a of operations to the server that end up many of the nodes of the the client could cache the shallow projections of these elements locally instead of reading them from the proof stream multiple times this optimization requires modifying the unauth and functionality the modification is for both prover and verifier a counter is each time or unauth is called each party maintains two data structures a mapping from counter values to shallow projections indicating the ordering and a mapping from to counter values and are referred to as the cache as they contain corresponding elements when unauth is called if the digest exists in the prover resp verifier from the cache the corresponding shallow projection then updates the counter value associated with it in the cache otherwise the prover it to resp verifier reads it from the proof stream and adds it to the cache if the size of the cache the parameter then the least recently used element the smallest key in is removed the proof benefits come at the cost of having to store the cache this optimization eliminates redundancy in shallow projections that contain computable from nested shallow projections appearing subsequently in the proof stream this idea is implicit in the verification procedure for trees section we can approximate the optimization for arbitrary data structures in · by modifying unauth for both the prover and verifier to use a buffer to for the prover the goal is to decide which in a shallow projection can safely be omitted which are those that correspond to nodes that will be visited during subsequent calls to unauth to achieve this we extend the representation for · values type · of string × × bool ref each time unauth is called the shallow projection is computed differently each immediate child would be replaced with but is instead replaced with where flag is a fresh mutable flag initially false that indicates whether the digest can be omitted when one of these children is accessed by unauth the corresponding flag is set rather than writing the shallow projection immediately to the proof stream it is to a queue the queue is when execution reaches a annotation this is a that need no longer be suspended its placement has no effect on security but it is best used at the end of a distinct operation before a queue element is added to the proof stream occurrences of are replaced with when flag is true and replaced with when flag is false when the verifier a shallow projection object in the proof stream containing values its digest cannot be computed immediately so the object is stored in a set referred to as the buffer if unauth is subsequently called on an immediate child of a node in this buffer even if the shallow projection is available in the proof stream the root hash is unknown so it cannot be immediately validated either thus we extend the · representation again with a new tag type · of string ref × unit unit for every object placed in the buffer each immediate is replaced with a containing a callback closure and a mutable reference initially empty containing a hash when a leaf node is accessed the reference is updated with the actual digest of the leaf and the callback is invoked the callback a pointer to the parent node and checks if all immediate children have been with if so the callback removes the node from the buffer computes the nodes digest and takes one of two actions if the reference already contains a digest then the two are compared for equality if not then the reference is updated with the computed digest and the callback closure is invoked thus validation propagates from the leaves to the root a of this optimization is that it the verifier to potential resource attacks as potentially infinite computation is performed on untrusted data before it is validated a solution would be to bound the number of steps the program should take before the buffer is another is that this optimization requires additional storage on the verifier in contrast to the original tree optimization supporting full ocaml our compiler prototype supports the ocaml equivalent of the type language given in figure with the exception of function types this support has been sufficient to program a variety of interesting data structures as described in the next section to implement authenticated functions requires that we be able to perform the shallow projection of a lambda term our formalism does this by folding over the syntax of the lambda terms body to find authenticated values h v and replace them with values h in an implementation this operation is to transforming a closures environment we could do this quite naturally using and mapclosure operator but unfortunately as they point out it is not clear how to implement this operator in a statically typed language since the compiler cannot in general know the types of a given closures environment variables we could imagine storing type information with the closure eg crary et als term representations for types in support of a generic runtime shallow projection operation as per the formalism in the the most natural use of authenticated closures we have found is to support shallow cps transformations we can use an explicit stack to the same effect as shown in figure among other ocaml features not yet supported the most desirable is authenticated polymorphic types similarly to closure environments the compiler cannot know types needed to perform shallow a value given to and unauth is polymorphic then its type is determined by how type variables are instantiated at a particular callsite once again a generic shallow projection operator as per our formalism and easily implemented in a dynamically typed language would fit the we could imagine requiring that and unauth each take an additional type parameter in most cases it could be statically determined but to support polymorphism it could be passed as an argument eg to the polymorphic function containing the call evaluation to demonstrate the effectiveness and generality of our language and compiler we have implemented a variety of we analyze their performance and it with benchmarks for selected algorithms our benchmarks were using an ec instance an intel e processor with gb of ram all data structures were stored in ram complete code is given in our extended technical report trees our version of trees was given in figure as trees are the most common authenticated data structure and are readily implemented we compared the running time of our compiled verifier routine to implementations in ocaml and in c see figure c the benchmark consists of random accesses to trees of height h for h each array element is a byte string thus the largest tree contains approximately elements and stores approximately mb of data in total compared to the version in c the program generated by our compiler is slower by only a factor of two the ocaml code is about slower than the c program profiling with reveals that substantial overhead is due to the routine used by our compiler the ocaml code avoids this by the child directly trees a tree is a binary indicates that internal nodes only store keys and the values are stored only in the leaves this data structure is appropriate for a dictionary we consider authenticated search trees to be the second authenticated data structure proposed by and to implement certificate revocation lists our results are asymptotically equivalent the storage cost to the prover for the entire data structure is on while the computation cost per operation for both prover and verifier is n the size of the proof stream is also n note that we also implement an authenticated version of normal binary search trees too and these also have the expected performance in figure a we show the empirical runtime performance of the authenticated tree for both the prover p and verifier v modes as well the ideal mode with the · annotations and commands erased to show the overall computational overhead of authentication the benchmark consists of random into a random tree containing k elements for each k p runs approximately faster than v this is because v computes a hash during both unauth and instructions whereas p only computes a hash during according to profiler analysis using v of its time in the hash routine and in routines p of its time computing performing and in garbage collection the overhead of p is approximately a factor of compared to the ordinary data structure we omit similar benchmarks for our other algorithms as the results are similar we measured the largest amount of memory allocated by ocaml during this benchmark as shown in figure b this illustrates the key advantage of an authenticated data structure scheme while p space overhead by a factor of vs the ideal mode the space requirement of the v is effectively constant finally we used this benchmark to evaluate the effectiveness of our two compiler optimizations on proof size see figure d for a binary tree the buffer results in a reduction of almost since only one of the left or right child must be transmitted for each node the reuse cache is most effective when the tree is small and mostly in the cache thus since the parameter in our benchmark is the proof is nearly empty up to trees of height however because the benchmark consists of random queries the leaves and nodes toward the bottom are accessed almost uniformly at random so only a constant number of nodes the root are read from the cache each query the cache would be more in applications where some nodes were accessed much more frequently we only implemented the two optimizations separately combining the two is left as future work skip lists skip lists are randomized data structures providing similar performance in expectation to binary search trees our results are asymptotically equivalent to previous work on authenticated skip lists the storage cost to p for the entire data structure is n where n is the number of elements inserted the expected computational cost to p and v as well as the size of the proof stream is n but on in the worst case trees trees are data structures that can be used to efficiently query the distance of the shortest path between two vertices in a graph eg many maps a of a graph is a collection of vertices a binary partition on the graph such that any path from a vertex in one partition to a vertex in the other partition must pass through a vertex in the a consequence of the theorem is that every graph has a that is small random algorithms can be used in · as long as p and v both use the same function and o n where n is the number of vertices yet induces a balanced partition both partitions have at least n elements a search struc ture can be built over the graph by recursively constructing for each partition while the solution of storing the short distance between every pair of vertices requires on storage the tree requires only on space the shortest distance between any two points can be computed in o n log n time using this data structure a potential application of an tree is for a mobile device user to query a service for directions along with a proof that the response is actually the shortest path rather than eg one that the user out of their way past for which the vice might receive a profit using our authenticated com the proof size and computation cost for p and v is also o n log n we include this primarily as an example of a data structure that has not been treated as an in prior work but is straightforward to using our framework is a network implementing a virtual it features an authenticated data structure called the which represents a history of transactions a global can be computed from the which abstractly speaking contains a set of currently valid a valid transaction removes a past from the and adds a new one assigned to the of the the current data structure from two a verifier needs to maintain an entire copy of the global to efficiently perform validation of transactions which may become as the number of increases and at time a new client needs to the entire transaction history and perform a linear computation in the size of the block chain to construct the even when it the root digest these can be resolved if we build the as an authenticated set into the block chain data structure we have done this in our language by composing the data structure with a consisting of our authenticated tree thereby reducing client storage to m where m bounds the number of in the full details are given our technical report related work as mentioned earlier authenticated data structure research has had a of results from the cryptography community authenticated versions of set dictionaries range queries certain graph queries etc to the best of our knowledge no one has a general authenticated data structure implementation for generic programs those work is by et al which proposes a method for designing authenticated data structures for a class of data structures referred to as search dags their model is limited to static data structures ie it does not support updates which are supported by · our approach is also easier to use since the programmer writes largely standard purely functional implementations of data structures and their operations and the compiler generates the code in their approach the task of designing and implementing still must be done by hand our generated implementations have performance with known constructions based on we note however that while most are not all known constructions are based on hash functions for example based constructions exist for set operations using alternative algebraic primitives other than can sometimes yield asymptotically better constructions a running time b memory usage c our · compiler vs hand d proof size with optional optimized code figure empirical performance evaluation results for into a tree a running time for prover verifier and ideal b memory usage heap size c running time for fetch operation in a balanced tree for the program generated by our compiler ocaml code and c code for random in a binary search tree d the effect of two optional optimizations on proof stream size compared with two optional optimizations a of size and the buffer beyond the optimizations we have implemented see section there are other known optimizations that we have not an included an example is the technique of commutative hashing due to et al which reduces the proof size when it is irrelevant which of possibly several child nodes are traversed we believe it is likely that optimizations for specific data structures could be incorporated generally into our compiler other optimizations lie further outside our model an example is a line of work beginning with original paper in which the stored data is not arbitrary but is instead generated eg using a number generator in this case the provers storage costs can be significantly reduced by data on the rather than storing it in our performance evaluation we consider memory usage and running time however some work in authenticated data structures considers io efficiency another practical characteristic verified computation and arguments of knowledge can also yield asymptotically better protocols for ensuring integrity of computation eg with o amount of client computation other than reading the input and output however while known verified computation schemes and are orders of magnitude more expensive than constructions based on in practice due to the use of cryptographic primitives such as fully encryption is a language for writing verified computations over hidden inputs this is achieved by compiling programs to custom protocols thus unlike · provides correctness security and privacy however this comes at the price of a more limited language eg does not support branching or higherorder functions generally in addition absolute performance is much worse due to the use of more cryptography conclusions we have presented · the first programming language for authenticated data structures we have formally proven that every welltyped · program to a secure protocol and we have implemented · as a simple compiler extension to ocaml so that a programmer can easily derive an authenticated data structure from any ordinary one the protocols generated by our compiler are with the in we believe this work is long are a technique in cryptography and yet researchers have the simple connection between in our notion of authenticated types we plan to extend our language to be more expressive and to include more efficient techniques based on advanced cryptographic primitives we hope our work adoption in future secure computing infrastructure acknowledgments we thank and the team for several that inspired our approach and and the anonymous reviewers for comments on of this paper this research was in part by nsf grant and by the us research laboratory and the uk of under agreement number the views and conclusions contained in this document are those of the authors and should not be interpreted as representing the policies either expressed or implied of the us research laboratory the us the uk of or the uk the us and uk are to and for purposes any copyright notation references a m t and r persistent authenticated dictionaries and their applications in proc pages ­ london uk uk springerverlag p m and y optimal tradeoff for tree traversal theor comput sci ­ mar k crary s weirich and g morrisett intensional polymorphism in semantics journal of functional programming u and s an invariant cost model for the lambda calculus in logical approaches to computational barriers pages ­ springer p m c and s g data publication in data and application security pages ­ springer r theorem and its applications lecture advanced graph algorithms max c flanagan a b f and m felleisen the essence of compiling with continuations in proc pldi c fournet m g and z a compiler for data processing in usenix security r c and b computing computation to untrusted in pages ­ springer r c b and m quadratic span programs and without report m t c and r on the cost of and authentication in skip lists in proc intl workshop on experimental algorithms volume of lncs pages ­ springer m t r and a implementation of an authenticated dictionary with skip lists and commutative hashing in proc information conference and ii ii pages ­ m t r and n efficient authenticated data structures for graph and geometric search problems ­ j and y introduction to modern cryptography press f li k yi m and g streams enabling authentication of window queries on streams in pages ­ c g p m a and s a general model for data publication available from c g p m a and s g a general model for authenticated data structures ­ jan r c secure communications over channels communications of the acm ­ r c a certified digital signature in g editor proc volume of lncs pages ­ springerverlag a m j and e full version authenticated data structures jan e m and g authentication and integrity in databases trans storage ­ s a electronic system technical report unpublished m and k certificate revocation and certificate update in proc usenix pages ­ berkeley m and k certificate revocation and certificate update ieee j on sel areas ­ c and r time and space efficient algorithms for authenticated data structures in information and communications security pages ­ springer c r and n authenticated hash tables in proc acm conference on computer and communications security ccs pages ­ acm october c r and n optimal verification of operations on dynamic sets in pages ­ b c j and m nearly practical computation in proc ieee w skip lists a probabilistic alternative to balanced trees communications of the acm ­ j m and b a firstclass nonstandard interpretations by opening closures in popl r authenticated data structures in th annual european symposium on algorithms sept 