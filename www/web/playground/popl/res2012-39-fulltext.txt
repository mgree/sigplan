a unified approach to fully lazy sharing univ paris paris f paris france abstract we give an axiomatic presentation of for weak calculi that makes it possible to formally compare many different approaches to fully lazy sharing and obtain two important results we prove that the known implementations of full laziness are all equivalent in terms of the number of reductions performed although they behave differently regarding the duplication of terms we establish a link between the optimality theories of weak calculi and firstorder rewriting systems by expressing fully lazy lifting in our framework thus the firstorder essence of weak reduction categories and subject descriptors i languages and systems evaluation strategies general terms theory languages keywords sharing full laziness rewriting lambdacalculus weak reduction optimality labelling introduction in the implementation of functional programming languages a fundamental problem is the efficient evaluation of reduction this problem has been studied for a long time its difficulty comes from the fact that one has to minimize the number of steps as well as control the actual cost of single reduction steps the minimization of the number of steps requires in turn to handle two different issues avoiding computations and of work in calculus some reduction strategies can completely avoid computations however it is also known that no reduction strategy can completely avoid lam hence in any case one has to with that still occur and find some appropriate ways to deal with them this is exactly the point of sharing building implementations in which the duplicated occurrences of a given original subterm keep a unique shared representation this allows one to evaluate all the copies simultaneously as if they were only one the idea is to make sure that some parts of a program which are logically duplicated in the term representation of the program remain single pieces in the memory of the evaluator permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm sharing cannot be achieved using only terms it requires the use of other technical tools for instance graphs closures or program transformations the various resulting may be comparable this paper focuses on one particularly rich of sharing called fully lazy sharing described in section and aims at formally relating its various implementations this is done by defining a framework called systems in which they can all be expressed and compared this unified approach provides compiler writers with increased knowledge on the wide of full laziness in particular it replaces a series of sometimes informal of equivalence by a central theorem ensuring that all the considered approaches are equivalent with respect to the number of shared steps as a consequence one can safely restrict any subsequent comparison of two fully lazy models to other parameters of interest such as their space consumption or the actual cost of maintaining sharing having a unified framework will also simplify the task of comparing full laziness to the other efficient implementation techniques such as other of laziness up to optimality or partial evaluation the rest of the introduction is organized as follows section presents the various technical tools commonly used to specify sharing section describes how these tools have been used and combined over the past years to propose different definitions of fully lazy sharing and section details our approach and the contributions of the paper many tools for sharing graphs the most intuitive way of expressing sharing might be by using graphs in the the binary node represents application and redexes are marked with lines for instance in the center of the following picture an abstraction xt is applied to an argument a the function body t contains two occurrences of the variable x the argument a is thus logically duplicated on the left t x aa ta xx t a the simplest notion of sharing which may be referred to as lazy sharing or just laziness prevents the previous duplication by keeping a unique with two pointers to its location right hand side part of the previous picture here the term laziness is to be taken in literal sense the are as long as it is possible but some of them will a reducible expression or redex designs a place where an evaluation step can take place eventually happen for instance a shared function has to be copied prior to any instantiation as shown in the picture below c x ta xx c x t t xx a extraction of free parameters the previous feature graphs built with calculus constructs and in particular with binders this requires either to define variable renaming conversion or to add some special structure to represent binding in any case the resulting graph formalism is quite complex graph reduction can be made easier by terms that are higherorder terms to applicative expressions that are firstorder terms this is the point when compiling the calculus into combinators or techniques that finally led to the lifting program transformation this transformation extracts all the free variables from a function and replaces what remains of the function by a symbol called new reduction rules are added to deal with the new symbols closures and memory heaps while graphs are a simple and old way to describe lazy sharing the reference system for the semantics of lazy evaluation is j natural semantics it introduces let in constructs to name the arguments of the applications and then puts these arguments in a heap sharing then appears as memoization when one needs to access the content of a variable the corresponding expression found in the heap is evaluated and the heap is updated with the obtained result in contrast to the previous bigstep approach a smallstep description of lazy evaluation based on terms is the callbyneed calculus of z et al here again sharing is expressed thanks to additional let in constructs used as closures similar effects can also be achieved by expressing sharing using explicit substitutions the bigstep and smallstep can be related by wellknown transformations labels and weak reduction finally laziness is seen in mar as the optimal way of sharing in weak calculi variants of the calculus where reduction under abstractions is restricted first jj described optimal sharing for the plain calculus unrestricted untyped usual calculus by means of labelled terms then l mar adapted these ideas for a weak calculus and for firstorder rewriting and an additional result that is not valid for the plain calculus labelled terms represent graphs implementing optimal sharing in mar the link between labelled terms and graphs is made by interpreting the label of a term as its location in memory or by its coordinate x x t x x tt we call this principle the idea is also explored in in this setting the equality of labels corresponds to the physical equality of two terms which should in turn imply their syntactic equality two terms at the same place to be equal the reduction of a is simulated by the reduction of all the labelled with a given label one then needs to ensure that the sharing property terms with equal labels are syntactically equal is preserved by reduction full laziness state of the art the main idea full laziness is based upon the following remark the constant parts of a function body are not affected by the instantiation of the function hence they need not be duplicated this can be formalized by means of the notion of free expression we recall the definition given in say a subterm s of t is free in xt if all the free variables of s are free in xt a maximal free expression of xt is a free expression of xt which is not contained into any other free expression of xt fully lazy the various definitions of fully lazy sharing come from a combination of the previous idea with one or more of the technical tools described in section the first description of fully lazy sharing is in the graph evaluation technique presented by cp this graph reduction performs only a partial copy of a duplicated function body by avoiding the copy of its maximal free expressions see example a o shivers and m wand sw the graph structure of to allow a simple and efficient implementation for this they also use a different characterization of what has to be copied which we detail in section two other approaches combine graphs with other tools first s reaches a simple graph formalism thanks to a version of lifting following lifting replaces the extraction of the free variables of a function by the extraction of its maximal free expressions second t jj and l derive a graph implementation of fully lazy sharing through the principle using labels that characterize optimal sharing for a weak calculus studied in h this approach can copy fewer graph nodes of the duplicated abstractions see example b finally z and m felleisen af and p use the extraction of maximal free expressions to build fully lazy versions of respectively the callbyneed calculus and natural semantics for laziness both solutions are based on closures represented by let in constructs the former solution af uses a more restrictive definition of free expressions and hence may in some cases copy more nodes than the others see example c example lines identify the parts of the function that are duplicated by the different models see section for a formal statement x x x z y z x yy z y z x yy z y z x yy a b c af summary the following table sums up how each of the previous works gives its own view on fully lazy sharing with different inter of the same main idea and using various combinations of technical tools that are sometimes comparable we use the symbol to mean as many copied nodes as tools graphs extraction closures labels af more sw fewer this paper proposes a formal setting in which all the approaches mentioned above can be expressed this allows us to formally compare them and leads us to the two following conclusions · the previous approaches correspond to at least three different graph implementations this means that strictly speaking they do not all induce the same amount of sharing hence despite the fact that all these approaches intend to implement the same idea their equivalence is not obvious · however all these approaches have the same reduction space this means that the different implementations of fully lazy sharing perform the same number of reductions in other words any further comparison of these approaches need not take this parameter into account content of the paper an axiomatic framework for we build in section an axiomatic framework which generalizes the work of t jj and l and allows us to express all the previous approaches we use labelled terms to describe the graphs optimal sharing for a given notion of weak reduction various weak reduction notions are defined thanks to an axiomatic description of the parts of the program where reduction is forbidden in any case the restrictions concern only evaluation in the body of a function called partial evaluation this implies that the callbyvalue and callbyname strategies are always valid however the different weak calculi may or may not be confluent see h and example this approach of allows us in section to relate all the definitions of fully lazy sharing that do not rely on and lifting in other words this axiomatic framework which is designed in higherorder rewriting covers the definitions of full laziness which directly operate in the higherorder world af sw the remaining approaches using a translation to firstorder rewriting by lifting are studied separately in section the translation to firstorder by means of combinators of d turner is out of the scope of the present paper since these combinators simulate explicit substitutions and then introduce additional reduction steps notably due to its axiomatic nature our framework is not suitable for an immediate implementation on the other hand this approach us something about full laziness in general and on its various concrete implementations the of our framework lies in the fact that it cannot be seen as a straightforward generalization of any of the of full laziness taken in isolation the axiomatization rather comes from an analysis of the and the differences of all the concrete systems this yields a new system whose specific properties may be understood as the intersection of the particular properties of the various concrete systems in other words our axiomatization tries to the essence of full laziness a formal coding of higher order into first order by lifting the lifting program transformation turns a term into a firstorder term the main feature of lifting is the transformation of abstractions into function symbols also called over which firstorder reduction rules are defined as in lm this transformation a tight relation between weak calculus and firstorder rewriting usual definitions of proceed by first defining the transformation of abstractions and then iteratively applying the process to a term until it contains no more abstractions definitions differ in particular in the way in which a single abstraction is transformed and on the order in which the iteration is applied for instance describes a bottomup tion while iterates in an unspecified order we ensure the of these two views by giving a definition of lifting in which the order of the iterative process is irrelevant since lifting is an iterative process that turns a term into a firstorder term none of the intermediate steps is in either of these worlds nevertheless we would like to the source the target and all the intermediate steps of the transformation into a single formalism to this aim we use combinatory reduction systems a higherorder rewriting framework introduced by and in that abstractions and symbols the reduction as well as the target firstorder reduction have a straightforward encoding into rules moreover fully lazy lifting itself can then be seen as a rewriting process it is expressed in section as a confluent and strongly normalizing reduction relation we provide a new proof of correctness of fully lazy lifting by showing that the transformation preserves reduction sequences each single reduction step in the source resp target system is simulated by exactly one single step in the target resp source system the proof is smallstep the reduction sequences are proved to be preserved in every intermediate step of the transformation moreover we prove that the notion of optimal sharing is also preserved which has two consequences · the direct and the lifting based approaches of full laziness are equivalent · lifting establishes a link between optimal sharing in the weak calculus and the better known optimality theory of firstorder rewriting mar ter this in a new way the firstorder nature of weak reduction without any de bruijn indices or explicit substitutions contrary to mar a final remark is an point which happens to have some theoretical while reduction and lifting considered separately can be seen as orthogonal systems their combination cannot as far as the author is aware the system derived in this paper is the first successful labelling of a system outline the paper three main parts section presents the abstract notions of prefix weak reduction and and gives a proof of the sharing property for the axiomatic framework section restricts the to enforce full laziness and proves a generic equivalence between several notions of fully lazy sharing section focuses on the particular fully lazy system of sw whose properties allow a clean definition of fully lazy lifting which establishes a strong link between weak reduction and firstorder rewriting for lack of space most proofs are only sketched here the full versions are in a companion technical report sharing and reduction we define in this section an axiomatic framework in which the higherorder approaches af sw to fully lazy sharing can be expressed we propose an axiomatic notion of weak reduction in subsection whose optimal sharing is characterized by the systems introduced in section section then shows that reduction of labelled terms in systems represents reduction of graphs all this is expressed in combinatory reduction systems for lack of space we only recall the basic syntax and mechanisms in brief a system is orthogonal when no two rules are applicable to overlapping sets of positions of a term see for instance ter we refer the reader to for a presentation the grammar of in a is t x xt f t tn zt tn where x is a variable x denotes the binding of a variable f is an nary function symbol taken in a signature and z is an nary metavariable a term is a without metavariable and a reduction rule is a pair l r of closed satisfying the following conditions the metavariables in l appear as zx xn with x xn distinct bound variables and all the metavariables of r also appear in l a rule matches a term by application of a valuation that maps nary metavariables to nary contexts avoiding variable capture reduction by a rule l r with valuation in a context c is cl cr weak reduction systems this section gives an abstract definition of weak reduction in the calculus and states one of its crucial properties disjoint redexes remain disjoint along any reduction sequence lemma this lemma serves in particular in the definition of graph reduction in section weak reduction the reduction of socalled frozen redexes which are identified by their belonging to the prefix of some abstraction prefixes are parts of abstractions defined by a prefix function satisfying the axioms of a weak reduction system weak reduction systems are over the signature · a binary symbol for application · a unary symbol for abstraction · a unary dummy symbol · for all n n a countable set fn of nary symbols from now on by term we mean a term over the signature notation t u v w a we use the usual notion of positions of terms notation q contexts and free variables we write the substitution by u of all the free occurrences of the variable x in t application and abstraction symbols are used to terms in this signature which is made in the usual way the term for instance is encoded in the term xx y we write xt as a shorthand for xt hence the encoding of is simply written xx y and the usual reduction is represented by the rule z zz the symbols in the sets fn are used in section to represent until then they play no role and may be ignored the dummy symbol has no meaning in itself it is needed for labelling subsection and serves in particular as a container for dynamically created labels in the graphical interpretation of labelled terms the occurrences of will represent see subsection as a consequence occurrences of should not interfere with reduction this leads to the following countable set of rules to simulate reduction by allowing any number of s between the application and the abstraction z z z z z z z z z the two s in the right hand sides are used for the correct labelling of reductions see subsection the use of the dummy symbol is inspired by the notion of expansion in term rewriting systems ter write t t a reduction of a term t to a term t the usual notions of ancestors and descendants which track subterms along reduction in the calculus are straightforwardly adapted as illustrated in example a residual of a redex r is a descendant of r which is still a redex example the term t xx x y reduces by rule to t y y the two occurrences of y in t are the descendants of the y in t and the latter is the ancestor of the the in t has no descendant and the s in t have no ancestor we call plain calculus the usual reduction relation where the previous rules can be applied in any context weak reduction consists in restricting this reduction relation particularly it affects the reduction under abstractions before introducing the formal definition let us present two different wellknown examples example the naive weak reduction simply any reduction under abstractions a more refined version studied in particular in h allows no reduction between an occurrence of a bound variable and its binder formally if r is a redex of r then the reduction cr cr is allowed if and only if the context c binds no variable that appears free in r we call this version reduction it is known that reduction yields a confluent weak calculus while naive weak reduction does not h to specify the previous notions we introduce a notion of prefix call a nary closed prefix of a term t a nary context p which does not contain any free variable and such that there are terms t tn satisfying t pt tn example gives two closed prefixes of the same term call a prefix function a function that takes a term t as input and returns a closed prefix of t example let t xz z yy z x the two contexts x y x and x yy x are two closed prefixes of t called respectively spine and skeleton see section these two prefixes are marked with lines in the two following x x z z y x y z z z y x y z spine skeleton a weak reduction system is defined below by a prefix function p satisfying some conditions the first condition is a simple restriction linked to bound variables the second condition the evolution of pt when free variables of t are substituted by terms in particular is required to contain pt and the extension from pt to has to be uniform this is enforced by the use of an function p call a weak reduction system a prefix function p such that · for any term xt such that p and xt pt tn the variable x does not appear free in any of the which are called the parameters of xt in other words contains all the occurrences of x that are free in t · there is an auxiliary prefix function p such that for any p in the codomain of p and for any terms t tn where no free variable of a ti is bound in p the equation tn pp t p tn holds a weak reduction system defines a notion of weak reduction as follows reduction is forbidden in the prefix of any abstraction call a frozen position of a term t a position that is in the prefix of some abstraction of t call a frozen redex a redex whose main symbol occurs at a frozen position example the two weak reductions of example can be captured by our axiomatic definition naive weak reduction is given by pn such that p where t px xn and x xn are all the free variable occurrences of t the auxiliary function is pn pn the whole substituted term is included into the prefix reduction can be given by such that p where t pt tn and t tn are all the maximal free expressions of t the auxiliary function is the constant mapping returning the empty unary context the prefix is stable by substitution we will see in section that is not the unique representation of reduction an important feature of weak reduction is that it cannot nest the residuals of disjoint redexes this fact is formalized in lemma and will be useful in section to ground the notion of parallel reduction lemma disjoint residuals let t t be a reduction and r rn non frozen redexes of t occurring at disjoint positions then the descendants of r rn also occur at disjoint positions example shows why lemma is a feature of weak reduction which is not valid in the plain calculus example suppose r and r are two redexes in the left term r is frozen for any weak reduction system x r r x r r to the implementation of optimal sharing for weak reduction systems in next section we give a characterization of redex creation in these systems suppose t t in a weak reduction system a redex of t is created by if it is not the descendant of a non frozen redex of t the reduction can create redexes in t at exactly three places at the root of the the body of the main abstraction is connected to the context this can create a new between an application and a abstraction at the places where a substitution occurs the argument is connected to the body of the main abstraction or to the context if the body is in the prefix of the main abstraction a previously frozen redex can be by as r in example in other words a reduction forbidden by the weak restriction in t can be in t systems we define in this section a labelling for weak reduction systems which characterizes optimal sharing and yields a graph implementation as in the labels record the past history of a term this is done in a distributed way since each label only what is relevant to its position the important point for optimality is that the labels of a redex r are characterized by the past reductions that to the creation of r which is by the lemmas and these two lemmas also play a key role in the proof of the preservation of the graph structure socalled sharing property in section to this contribution relation into the labels we build compound labels of the form where a label is modified by the name of a redex the labelled reduction then modifies the labels of the positions where the reduction can contribute to something following the characterization of redex creation given at the end of the previous subsection names and contribution are required to satisfy three axioms which ensure that the name of a redex correctly reflects its the labelled terms are formalized as usual terms over a labelled signature since the labels should not interfere with the normal reduction behaviour the labelled reduction is defined for any possible labelling of the source for any countable set l whose elements are called labels and written a labelled signature l is defined as the set f f l from now on a term denotes a term over l in other words the labels are associated to the symbols and never directly to the variables or the bindings remark that the labels are arbitrary objects in a concrete definition they can be simple letters as well as structured objects we write xt resp x as a shorthand for xt resp x write t for the label of the root symbol of the labelled term t write k k t as a shorthand for k t where the case k represents t write the trivial map from terms over l to terms over that removes the labels of all symbols by requiring the condition pt pt we get a straightforward extension to l of any weak reduction system p over since neither s nor labels shall interfere with reduction labelled redexes allow any number of occurrences and can be with any labels for any l a redex is a term of the form k k xt a labelled reduction is defined later since it requires an additional notion of systems given below we consider sets of labels of the form l vn generated by the following grammar for any two countable sets v and n vn v n vn the label denotes the label modified by write n as a shorthand for n any i is called a of n the labels the labels in v denote positions that are free from any past history they will be modified into labels of the form n along the reductions let s be a tuple p n v where · p is a weak reduction system · n is a countable set whose elements are called redex names notation · v is a countable set whose elements are called labels with two distinguished elements and · is a function from vn labelled redexes to names · is a transitive and relation on n called contribution relation the terms considered in s are the vn labelled terms call term a term whose labels are all and different write the set of all the of the name contribution is extended to labels define if is a label and otherwise write when s is a system if the following axioms are satisfied · redex k k xt a i i · name scope if xp is in the codomain of p and at au are any terms and t tn u un are terms whose free variables are not bound in xp then k k tn at k k un au · name equality if r r then r r the axiom redex states that the name of a redex collects the of the essential parts of the redex that means its main application its main abstraction and all that in between these two positions the axiom name scope states that the name of a redex does not depend of what is deeper than the smallest prefix of the main abstraction while axiom name equality states that the equality of the names of two redexes implies the equality of their respective root labels example let v be any countable set the names in are sequences of labels since the names also take part into the definition of the labels a mutually recursive definition of names and labels is required l l l v define the name of a redex as seq k k xt a k the contribution relation is defined by seq n if and only if there is at least one i such that seq i for p pn the system p v seq seq is a system the definitions of seq and seq correspond to the system presented in the names in are contexts with once again a mutually recursive definition using l define ctx k k xt a k k xp where p xt xp write ctx c if there is a label in c such that ctx for v ctx ctx to be a system the axiom redex requires that the prefixes satisfy the following property all the of the labels of a prefix xp contribute to fortunately in this system this property is an invariant of labelled reduction defined below the system pn v ctx ctx is not a labelling system since it breaks the axiom name scope labelled reduction is defined by a rule scheme which propagates the name of the reduced redex in the reduced term for recording of the contributions for this the constructor extends to a function on labelled terms t is defined as the labelled term t in which all the labels are modified by the function labelled reduction in a system is defined by the rule scheme k k tn a px at tn where xp p tn and where k k tn a the name is added in three areas of the reduced term at the root of the with the new label at the places where a substitution occurs with the new label remark in example how and work as parentheses in the syntactic tree of the term in the prefix of the main abstraction of the redex as an additional to labels remark that these three places follow the three cases of redex creation given in section and that removing the labels in this rule yields exactly the reduction of section example let r x yy a be a redex we reduce r in two systems of example in pn v seq seq the name of r is the sequence and the prefix of the abstraction is its whole body then all the labels are modified in the x x y y a µ y y aa in v ctx ctx the name of r is the labelled context x the only mod labels are those of the prefix of the abstraction marked with lines below x x y y a µ y y aa this section ends with the two lemmas and which show how the labels reflect the contribution relation between redexes in particular the name of a redex r characterizes the past reductions that led to the creation of r lemma redex stability let r be a non frozen redex of a term t if rd is a descendant of r after a reduction t t then rd is still a possibly frozen redex and rd r lemma direct contribution if a redex of name c is created by the reduction of a redex of name then c sharing this section proves the main property of systems parallel labelled reduction simulates graph reduction theorem as in the labelled terms are linked to graphs with the principle seen in the introduction labels are interpreted as memory locations the proof of the simulation is then done by ensuring that the two following invariants are preserved by parallel labelled reduction a term t has the sharing property written st when any two subterms of t with same label are syntactically equal this is the main property we want to preserve a term t has the property written mt when for any non frozen redex of name and any subterm of label in t it is not true that this property is widely used in the subsequent proofs it ensures in particular that all the occurrences of a given label are created at the same time see example lemmas and are the of the preservation of the property parallel labelled reduction is defined for any term t satisfying the sharing property st let be the label of a non frozen redex of t since st holds all the redexes labelled by are equal and have disjoint positions however some may be frozen the parallel labelled reduction of written t t is then defined as the simultaneous replacement of all the non frozen redexes with label by their by lemmas and parallel labelled reduction is well defined as a sequence of single steps for instance any iterated reduction of the non frozen redexes with label theorem preservation of sharing if mt st and t t then mt and st proof sketch verification of mt suppose there is a redex r with name and a subterm u with label in t such that if r is created by the reduction then lemma contradicts mt else lemma and axiom redex either mt or axiom name equality verification of st let u and v be two subterms of t with same label by case on the origin of both labels if one is created and the other is a descendant of a label of t then by mt and lemma we reach a contradiction else both have the same origin and evolution using st example shows why m is necessary to the preservation of sharing s example consider the system v seq seq defined in example and the labelled term t x zz y the property st holds since all the labels of t are different remark that t contains a redex zz y of name hence mt does not hold since t contains a label then t x y t where the two subterms of t with label are different st is finally labelled terms represent graphs and parallel labelled reduction represents graph reduction full laziness this section shows how the various known implementations of full laziness correspond to several at least three different systems section thus they correspond to different graph reductions different amounts of sharing however we are going to prove in section that these implementations are equivalent along this section the signature is restricted to encodings into systems the of is labels denote memory locations what happens to the labels during reduction describes directly what happens to the nodes of the corresponding graph · a new label corresponds to a new node there are two cases a label of the form or appears only on it represents a new indirection node that contains a pointer leading to the term any other denotes a new copy of a node labelled · an unchanged label is a node by the reduction the key of the encoding of graph reduction systems or systems into systems is to modify exactly the labels of what is needed to be copied since the rules of a system modify exactly the labels of the prefix of the main abstraction this amounts to take as prefix of a abstraction exactly what has to be duplicated of its body remark our rule suggests that an arbitrary number of can be in unit time the techniques presented in can be used to avoid chains of to describe the encodings of the higherorder approaches to full laziness into systems we formally define two useful prefixes mentioned in example · call spine of a term xt the prefix xp where p is the prefix of t which contains exactly the positions that are above a free occurrence of x including the free occurrences of x remark that in any weak reduction system p any prefix contains the spine of xt · call skeleton of a term xt the prefix xp where p is the prefix of t containing exactly the positions that are not in a free expression of xt as done in sw the skeleton can also be seen as an iterated spine to get the skeleton of xt start with the spine of xt and iteratively add to the obtained prefix the of all the abstractions that are in the prefix built so far the two approaches by cp and o shivers and m wand sw reach fully lazy sharing by two graph implementations in which the duplicated part of an instantiated function is its skeleton the former uses the definition based on the maximal free expressions while the latter follows the characterization by iterated spine they are both represented by the weak reduction system such that is the skeleton of xt in p lazy semantics and proposes a fully lazy variant using additional if xp is the skeleton of xt and xt tn then xt is replaced by let x t xn tn in xn with x xn fresh variables after this extraction of the maximal free expressions t tn of xt a duplication of the abstraction the subterm xn but does not duplicate the t tn this is again represented by the weak reduction system the work by t jj and l already uses a system isomorphic to a system their labelled reduction modifies only the labels of the spine of the main abstraction thus it corresponds to a weak reduction system where is the spine of xt moreover their frozen redexes are the redexes containing a free occurrence of a variable bound above they coincide with those given by in their callbyneed calculus af z and m felleisen allow the substitution and thus the duplication of values their fully lazy extension consists in restricting these allowed to a set of fully lazy values values that do not contain any free expression the difference with the previous cases lies in their nonstandard definition of free expressions they use the usual criterion given in section but they the variables and the abstractions hence their fully lazy values correspond to the prefixes of the weak reduction system such that · if xp is the skeleton of xt and xt tn then xt t tn · xt xt · t t · if t then t else t t finally the higherorder approaches af sw to full laziness correspond to three different weak reduction systems and which we are going to relate in the next section example illustrates how the systems and can yield the same parallel labelled reduction in of their differences example let t r be a term such that r r are two redexes that do not contain any free occurrence of x hence a duplication of the spine of t marked with lines in the picture do not duplicate these redexes x y z x r r yz if r resp r contains a free occurrence of y resp z then both redexes are at least partially contained in t and thus duplicated in this system however in this case r and r are and remain frozen in both systems and their label will change before they are the additional are not equivalence of the parallel labelled reductions in this section we define a family w of weak reduction systems that contains and and we show that all the systems based on the weak reduction systems of w are equivalent in the sense that they can simulate one another using exactly the same number of shared reduction steps for this we define a relation on labelled terms which is stable by reduction and prove that any two terms in relation share the same redexes the relation relates two terms t and t of two different systems s and s whenever t and t can be reached from a common source by two equivalent reduction sequences in s and s the whole being called a reduction sequence the definition of w follows two ideas the weak reduction systems in w shall enforce reduction for this the third point in particular prevents some applications to be included into a prefix and all the prefixes are built from and skeletons the first two points which make the proofs tractable a weak reduction system p is in w if the following additional conditions are satisfied · for each abstraction t xu either pt is the spine of t or pt pp t p tn where p is the skeleton of t and t pt tn · for any xt p xt or p xt · p t t · if p t then p t else p t p t let p and p be two systems of w a reduction sequence in the systems p and p is a pair such that i is a reduction sequence in pi and for any j n the redexes reduced by the single steps j and j have the same position qj in the respective source terms the notion of reduction sequence extends to parallel labelled reduction in two systems based on two possibly equal weak reduction systems of w let t resp t be a term in a system s resp s write t t when there is a term t in the intersection of s and s and a reduction sequence in the systems s and s such that i is a parallel labelled reduction sequence from t to ti remark if t t then the two terms have the same set of positions in particular they contain the same number of occurrences for any labelled term t the labels in t induce an equivalence relation on the subterms of t say that two subterms u and u of t are if and only if u u theorem sharing equivalence if t t then the of t and t induce the same on their non frozen applications proof sketch we prove two invariants on the pair t t the equivalence classes of non frozen applications are equal in each spine the equivalence classes of applications are equal by definition of t t there is a parallel labelled reduction sequence leading from a term t to t t the proof of both invariants is by induction on the number of parallel steps in remark by theorem that any intermediate term t in the reduction sequence satisfies mt and st theorem proves in particular that is a bisimulation any t u t u t u diagram or can be closed as tu t u this means that in w two systems generate the same notion of parallel labelled reduction in other words their possibly different have the same impact on the reduction this applies in particular to and and thus it shows that all the notions of full laziness in af sw define the same reduction spaces fully lazy lifting the primary goal of the present section is to prove that the notion of full laziness defined by fully lazy lifting in is equivalent to the unified notion of the previous section this study of lifting also reveals a strong relationship between optimal sharing in weak calculi and the optimality theory of firstorder rewriting mar ter in this section fully lazy lifting is ultimately seen as a morphism between two systems the source is the set of the terms equipped with weak reduction whereas the target is the set of firstorder terms built with equipped with their associated firstorder reduction rules however the source and the target system are mixed in the intermediate steps fully lazy lifting is then defined as an of an object system combining the source and the target our object system is a over a labelling of the signature defined in section the weak reduction is as defined in section the forming the target subsystem are represented by the symbols in f n fn and their reduction rules are defined in section fully lazy lifting itself is represented by a set of rules which is proved to be confluent lemma to be strongly normalizing lemma to preserve reduction theorem and to preserve shared reduction theorem since we aim for this last result on shared reduction and since shared reduction is formalized in this paper by the labels our lifting is defined on labelled terms section introduces an extension of systems and defines fully lazy lifting as a rewriting process section proves that fully lazy lifting is a bisimulation between the source system and the target system and section proves that parallel labelled fully lazy lifting preserves optimal sharing fully lazy lifting systems this section introduces the fully lazy lifting systems as an extension of the systems then lifting is defined as a reduction in a lifting system this reduction is confluent and strongly normalizing the basic mechanism of lifting is the replacement of a whole prefix by a the prefix and the being related by an abstract invertible function called in order to preserve sharing this replacement has to preserve all the information contained in the labels our solution consists in labelling the with a structured label containing all the labels of the prefix hence the basic operations of lifting are reversible and we define two inverse transformations contraction and expansion which relate labelled prefixes and labelled fully lazy lifting is related in this paper to the weak reduction system of example whose definition is below the ch subscript is omitted along this section · is the skeleton of xt · p t for any term t the structured labels used for labelled lifting are similarly to terms see example for any countable set v whose elements are called atomic labels the set v of tree labels over v is defined by the following grammar v v vv v the label is an empty label which is used to denote the lack of label of the empty context see example the labels in v are used as labels along this section a tree label is wellformed when no atomic label appears twice in it for any n a label n with v is wellformed when is wellformed the relation is defined on tree labels as when and have an atomic label in common the notion is used in section to express invariants on labels for any v and any n the extends to vn as follows if and only if n and n with v and a is an injective partial function mapping nary skeletons to nary function symbols for any set of atomic labels v and any set of names n a is extended to vn labelled skeletons and vn labelled symbols by the following rules · if p is labelled with labels then p f such that f p and p where x t xt t t f t tn t t t t t tn · if p can be decomposed as p p then p p · else p is undefined the extension of to labelled skeletons is still injective hence the labelled admits an inverse example consider the skeleton p x yy x the collected label is p it is interesting to compare the graphical representations of the pre fix and the label x y x y suppose x x g then · g x x · g x x · g is undefined because the label has not the same structure as g · x x is undefined because the labels have different and for any set of atomic labels v for any set of names n and for any contraction and expansion are two rule schemes on vn labelled terms for any skeleton xp and symbol f such that xp f we have the two rules contraction zn c f z zn expansion f z zn e zn call an object redex a labelled term having one of the two following forms source redex k k xt a target redex k k f t tn a remark that the set of object redexes is stable by c and e a fully lazy lifting system is a tuple n v such that · p n v is a system · is a · p with contraction and expansion · is a function from object redexes to names that is stable by contraction and expansion in a fully lazy lifting system n v we consider terms with l vn example shows a straightforward extension of the function seq of example which is not stable by contraction example then gives stable variants of the functions seq and ctx example consider the redex r xx y a which can be to r f y a for some unary symbol f then and the name is not stable example define seq n k k and xt a n k with where is and is the leftmost atomic label of this name function is stable since the leftmost atomic label is stable by contraction and expansion if p xt p then define ctx k k xt a form k of k f xp by lifting where f is the unique normal see definition of lifting and lem and below this name function is stable by tion we call source reduction the reduction whose rule scheme can be simplified k k zn z px zz zn where xp is a skeleton and where k k zn z we call target reduction the firstorder reduction defined by the scheme k k f z zn z t px zz zn where f xp and where k k f z zn z call object reduction the union of source reduction and target reduction o t remark target reduction can be decomposed by expanding the function symbol and then applying reduction remark consider the system s v ctx ctx where and ctx are defined in example ctx is defined in example and v is any countable set the target reduction of s is isomorphic to what is called in ter for a clean definition of lifting and for simple proofs of its basic properties we use an extended notion of positions of a term the socalled positions contain the usual syntactic positions but also the positions that are hidden in through the each symbol represents a prefix and the positions of these prefixes are taken into account in positions the set qt of positions of t is defined by qx q q t qt qt qt t qt qt qf t tn qf i the following cases define lifting as a reduction · if xp is a skeleton such that xp f then zn f z zn · inside if f x xn q gx xn where x xn are fresh variables then f z zn q g z zn · context if t q t and c is a unary context with a hole at position q then ct qq ct while is the main rule of lifting inside allows us to close confluence diagrams see example and to consider lifting as an orthogonal rewriting system in the sense of an inside reduction can be seen as a reduction inside a symbol an equivalent of inside naturally appears in af or as a reduction in the context of a let in construct note that in the rule context c is an arbitrary context this means that there is no particular weak restriction here example let t xz z yy z x be a labelled term where some labels are omitted write f x yy x µ g yy f x g x µ the dotted lines denote the skeleton of the abstraction y while the lines or dotted denote the skeleton of the tion x x x y z z y z x g z z z x z z z inside z z z remark the reduction is a straightforward use of contraction c and the reduction inside can be using contraction c and expansion e if t t by inside then there are u and u such that t e u c u c t lemma property if t u and t v with u v then there is w such that u w and v w lemma termination the system is strongly normalizing lemma implies that is confluent and that all the between two given terms have the same length ter an immediate corollary of lemmas and is that any term has a unique form lifting as a bisimulation this section proves that does not only transform terms but also reduction sequences and that the transformation operates forward as well as backward formally the closure of the relation written is a bisimulation between o and itself thanks to the formalism which allows reasoning on the intermediate steps of the transformation the proof can be reduced to a simulation property lemma lemma simulation · if t o t u then there is u such that t u u · it t u o u then there is t such that t o t u proof sketch by case on the relative positions of the two redexes most cases use the stability of and the of p with the diagram is closed by t u because a can or duplicate the considered lemma yields as immediate corollary theorem bisimulation the relation is a bisimulation between the reduction o and itself which means that any diagram tu tu tu o or o can be closed as o o tu tu this bisimulation is a strong property for lifting it associates a transformation of reduction sequences to the transformation of terms moreover there is a bijection between the single steps of the image and the antecedent reduction sequences in the next section we show that this holds also for parallel labelled reduction lifting as a graph bisimulation for r t o c e write r the simultaneous reduction of all the of label in a term satisfying the sharing property s this last section shows that preserves sharing the same subterms are shared in the source and in the target of this reduction this allows us to conclude that the full of and are bisimilar in this section we use again the invariants s and m introduced in section in our new setting we extend m to any object redex we moreover use the following three invariants say a term t has the independent labelling property written it when all the labels of t are wellformed and there is no pair of labels of t such that and this property is useful to ensure that contraction and expansion do not break the sharing property say a term t has the skeletons property written tt when every skeleton p in t is of the form n p where p has only labels this property allows applying a to any prefix and rules out the last case of example say a term t has the binding property written ht when any two variables with the same label are either both free or both bound by abstractions the same label this property the sharing property when both are present two whole skeletons are shared whenever one of their nodes is shared finally say a term t has the smith property written when the five properties are satisfied by t as well as by f for any f appearing in t or recursively in the antecedent by of a symbol lemma for any r t o c e and any two terms t t if and t r t then proof sketch by remarks and we need only consider the cases where r c e as in theorem the proof is by case analysis on the origin of the considered labels theorem preservation of optimal sharing let t be a term such that suppose t t let u resp v be a subterm of t with ancestor u resp v in t then u v if and only if u v proof suppose u v case on the origin of · if u v its over · if u and v then v such that n and n with appearing into which implies and contradicts it · if u and v then u v suppose u v if then u u v v else u v u u v v and u v in particular u v finally write t t is t and t are we deduce that t u t u t u any o or o can be closed as o o tu t u this implies that the implementations of full laziness in and define the same reduction space which also to optimal sharing along mar ter for the firstorder system defined by the target reduction t and to optimal sharing along for the reduction of the calculus conclusion sharing and in particular fully lazy sharing is described and implemented by different technical tools including graphs closures and program transformations as a consequence the many definitions of fully lazy sharing af sw are sometimes comparable yet they all intend to implement the same basic ideas this paper all these views of full laziness to achieve this we define an axiomatic framework of systems in which the various approaches can be expressed then we prove that all the resulting systems are bisimilar in the sense that they have isomorphic reduction spaces in particular by linking to other definitions of full laziness we the intuition of its authors that fully lazy sharing gives an optimal sharing for the weak calculus of h last but not least we show that weak reduction in calculus can be expressed in orthogonal firstorder rewriting by means of fully lazy lifting with a correspondence between their reduction steps this last property makes our firstorder formulation really different from the that use de bruijn indices or explicit substitutions mar moreover our transformation preserves optimal sharing and expresses fully lazy sharing as optimal sharing for the target firstorder system related work related approaches to the efficient implementation of functional programming languages include in particular the study of optimal reduction and the attempts to implement it the study of optimal reduction mar gk vo traditionally uses three equivalent called labelling extraction and this paper extends the characterization of optimality to weak reduction systems the possibility of a straightforward implementation in graphs of the characterization of optimality has for long been known to be a feature of firstorder rewriting mar that did not hold in the calculus however more recently this feature has been observed in a weak restriction of the calculus the present paper this observation by showing that it holds in any weak reduction system and explains this firstorder behaviour of weak reduction by a link between weak reduction systems and firstorder rewriting two kinds of implementations are known to perform less shared reduction steps than some fully lazy implementations in particular partial evaluation has been compared to and optimality is as an of hence this paper shows that partial evaluation as well as any implementation of optimality ag pq is able to perform less shared reduction steps than any implementation of full laziness on the other hand a global comparison between all these approaches is still missing in particular the following facts keep the question open for now the number of shared reduction steps in a fully lazy system is related to the actual cost of performing the reduction on a turing machine simple extension of lm but this does not hold with optimal sharing am future work fully lazy lifting is shown to be a powerful tool to give a faithful firstorder account of higherorder systems this us to carry on in at least two directions · generalization of lifting to any weak reduction system satisfying our axioms two interesting and challenging examples would be the plain lifting of in which the prefixes are not stable by reduction and a new notion of lifting based on which would turn the into since the can bind variables in their holes some function symbols would also bind some variables in their arguments · generalization of sharing and lifting to higherorder rewriting which includes richer systems that rewrite functions such as proof and compilers as far as the author is aware general higherorder rewriting knows no notion of weak reduction or lifting however the present work seems to be abstract enough to be generalized to higherorder frameworks such as combinatory reduction systems acknowledgments the author would like to thank for her continuous support van for several discussions and for a but remark that this investigation and di danvy john field and the anonymous reviewers for numerous helpful comments and suggestions references af and m felleisen the callbyneed lambda calculus j program ­ m felleisen j m odersky and p wadler the callbyneed lambda calculus in popl pages ­ ag a and s the optimal implementation of functional programming languages cambridge university press am a and parallel beta reduction is not elementary recursive in popl pages t a unified approach to fully lazy sharing technique hp barendregt r and m sleep needed reduction and spine strategies for the lambda calculus inf comput ­ t jj and l sharing in the weak lambdacalculus in on type theory lambda calculus and the mind residuals in higherorder rewriting in pages ­ h n and j r combinatory weak reduction in lambda calculus ­ o danvy k j and i interpreters for callbyneed evaluation in pages ­ d p l and f lang addressed term rewriting systems syntax semantics and extended abstract ­ gk j and z relative normalization in deterministic residual structures in pages ­ d and z expression reduction systems and extensions an overview in processes terms and cycles pages ­ ck and dk partial evaluation is laziness in pages ­ hughes super combinators a new implementation method for applicative languages in lfp pages ­ t lambda lifting transforming programs to recursive equations in pages ­ s peyton jones the implementation of functional programming languages prenticehall inc v van and f van combinatory reduction systems introduction and survey theor comput sci ­ lam j an algorithm for optimal lambda calculus reduction in popl pages ­ j launchbury a natural semantics for lazy evaluation in popl pages ­ lm u and s on constructor rewrite systems and the lambdacalculus in icalp pages ­ jj optimal reductions in the lambdacalculus in to hb curry on combinatory logic lambda calculus and pages ­ mar l optimal derivations in weak and in orthogonal terms rewriting systems in popl pages ­ pq m and f parallel environment for optimal lambdacalculus reduction acm trans comput logic july p deriving a lazy abstract machine j program ­ sw o shivers and m wand bottomup reduction and dags in esop pages ­ ter term rewriting systems cambridge da turner a new implementation technique for applicative languages in ­ vo v van higherorder families in pages ­ c p semantics and of the lambda calculus phd thesis n yoshida optimal reduction in with shared environments j of computer software ­ 