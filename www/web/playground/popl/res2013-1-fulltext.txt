full abstraction for nominal scott domains andrew m pitts university of cambridge abstract we develop a domain theory within nominal sets and present programming language constructs and results that can be from this approach the development is based on the concept of orbitfinite subset that is a subset of a nominal sets that is both finitely supported and contained in finitely many this concept appears in the recent research of et al on automata over infinite languages and our results establish a connection between their work and a of topological discovered in a quite different setting by and turner as part of a nominal domain theory for concurrency we use this connection to derive a notion of scott domain within nominal sets the for existential quantification over names and definite description over names turn out to be compact in the sense appropriate for nominal scott domains adding them together with to a programming language for recursively defined higherorder functions with name abstraction and locally names we prove a full abstraction result for nominal scott domains analogous to classic result about pcf and conventional scott domains two program phrases have the same observable operational behaviour in all contexts if and only if they denote equal elements of the nominal scott domain model this is the first full abstraction result we know of for higherorder functions with local names that uses a domain theory based on ordinary extensional functions rather than using the more intensional approach of game semantics categories and subject descriptors f mathematical logic and formal languages mathematical calculus and related systems f logics and meanings of programs semantics of programming semantics general terms languages theory keywords denotational semantics domain theory full abstraction nominal sets symmetry introduction various forms of symmetry are used in many branches of mathematics and computer science the results in this paper have to do with using symmetry to extend the reach of computation theory from finite data structures and algorithms to ones that although they are infinite become finite when by a suitable no permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm tion of symmetry we focus on higherorder functional computation with data that may involve many different names and given by permutations of those names a simple example of such data is the abstract syntax trees for a language involving binding constructs such as the calculus with named bound variables infinitely many abstract syntax trees represent a particular term modulo their bound names this way of equivalence via symmetry was the initial for the development of nominal sets a theory for mathematical structures involving atomic names that is names whose only attribute is their identity based on name permutations and the notion of finite support we review this concept in section nominal sets have been used to develop the semantic properties of binders and locally names with applications to functional and logic programming to equational logic and rewriting to type theory and to interactive theorem proving see the the work by et al on the calculus and provides a somewhat different application of nominal sets an independent one since it uses a notion of named set that only subsequently was shown to be equivalent to nominal sets the use of of names of fresh communication channels in this case to get finite representations of infinitely many states is at the in their work it has recently been subsumed and generalised in a of what one might call orbitfinite automata theory in this paper we bring together the names and binders and the orbitfinite state space aspects of nominal sets we observe that a key concept underlying the research of et al that of being an orbitfinite subset turns out to a notion of topological introduced for quite different purposes by and turner in their work on nominal domain theory for concurrency we explain the connection and use it to develop a version of the classic notion of scott domain within nominal sets previous work on denotational semantics with nominal sets has on simpler notions of domain analogous either to chain complete posets or to algebraic lattices a domain element is compact if it stands for a finite approximation of a computation we define this notion for our setting in definition and show that the for there exists a name such that and the unique name such that are compact plotkin proves that pcf with is fully abstract with respect to conventional scott domains in the sense that two expressions have equal denotations if and only if they the have the same observable operational behaviour in all contexts we obtain an analogous result for nominal scott domains through adding the above together with to a programming language for recursively defined higherorder functions with and locally names thus this paper makes the following contributions · we show theorem that a finitely supported subset of a nominal set is compact with respect to unions that are uniform directed in the sense of and turner if and only if it is orbitfinite · we use orbitfinite subsets to the notion of scott domain from ordinary sets to nominal sets we prove that the category of nominal scott domains is cartesian closed has least fixed points and is closed under forming domains of name abstractions sections and although there are infinitely many names the nominal scott domain of names has some strong properties in particular we show that the for existential quantification over names and definite description of names are elements of their function domains examples and · we define a language pna programming with name abstractions that extends pcf language with names that can be locally abstracted and in order to illustrate these facilities for programming with name abstractions pna has a nominal algebraic datatype for representing terms operational semantics is inspired by in particular its method for name abstractions makes use of local names we give a simple denotational semantics for pna using nominal scott domains and prove that it is computationally adequate theorem · we extend pna to a language pna with syntax operational semantics and denotational semantics for for existentially over names and for definite descriptions of names we prove that the nominal scott domain model of pna is fully abstract any two expressions are contextually equivalent if and only if they have equal denotations in the model theorem there are full abstraction results for higherorder functions with local names using the intensional approach of game semantics but our theorem is the first such result we know of that is based on ordinary extensional functions there is no similar result known for which uses generative rather than local names to implement the features that pna provides for programming with name abstractions and yet pna extended with recursive types is in principle as expressive as in view of and pitts our proof of theorem seems novel compared with other proofs of full abstraction results in the literature we only sketch it details will be published elsewhere on the other hand it gives rise to some open problems that we discuss in section together with a number of possibilities for future work exploiting the use of orbitfinite subsets within nominal domain theory finite support we are interested in the denotational semantics of programs written in languages binding constructs involving names that can be tested for equality to take symmetry into account we fix some infinite set a of atomic names and consider finite permutations of a that is a a with the property that a a holds for all but finitely many a a recall that an action of such permutations on a set x is a binary operation · satisfying id · x x where id is the identity permutation and · · x · x where is composition actions of finite permutations of a on sets x and y can be extended to their cartesian product x × y by defining for each x x and y y · x y · x · y more interestingly given actions on x and y we get an action on the set of functions y x by defining for each f y x · f x x · f · x where is the inverse of the permutation in particular taking y true false a set with trivial action · true true · false false we get an action on x and hence on subsets of x for each s x · s · x x s programs being finite syntactic objects only involve finitely many atomic names in their construction whereas the elements of a set x used to denote program behaviours may well be infinite mathematical objects we wish to limit our attention to infinite behaviours that depend only upon finitely many atomic names as doing so yields a richer and better theory we can make precise what it means to only depend upon finitely many atomic names entirely in terms of symmetry that is in terms of the permutation action an element x x is supported by a set a a of atomic names if every permutation satisfying a a a a also satisfies · x x that is permutations that preserve a also preserve x we say that a set x equipped with an action of finite permutations of a is a nominal set if each of its elements is supported by some finite set of atomic names in this case one can show that for each x x there is a smallest finite subset of a supporting x which we write as x we also write a x to mean a x note that since x is a finite set and a is not given x we can always find some a a satisfying a x given a nominal set x the subsets that a finite support with respect to the action in are called finitely supported subsets of x not every subset is finitely supported for example when x a with action a the only finitely supported subsets are those s a for which either s or a s is finite we write for the collection of all finitely supported subsets of x and with the action in this is a nominal set indeed it is the power object in the sense of theory for a model of higher order logic based on nominal sets the main difference between this model and the classical one is that it fails to satisfy choice principles as we discuss next this difference causes nominal domain theory to be something more than just classical domain theory carried out in the nominal model of higherorder logic joins a key idea behind domain theory is to give denotations to programs with potentially infinite behaviour as a limit of approximations for domain theory based on approximation via a partial order rather than a metric limits are joins of chains linearly ordered subsets or more generally joins of directed subsets where every finite set of elements has an upper bound in the subset so long as one considers chains of arbitrary length there is no difference between using joins of chains and using directed joins however the equivalence of the two approaches relies on the axiom of choice and as we noted above that fails to hold for nominal sets therefore in the nominal version of domain theory limits in terms of joins of chains is more restrictive than using joins of arbitrary directed subsets of course both the chains and the directed subsets should be finitely supported to make sense and turner provide a reason for restricting attention to joins of chains they show that a key notion provided by the nominal approach the operation the associated model of set theory goes back to work in the s by and who it specifically to the axiom of choice see remark of name abstraction preserves joins of chains but does not necessarily preserve joins of directed subsets in general we give below a simplified version of the example of the failure of name abstraction to preserve joins of all finitely supported directed subsets definition name abstraction a nominal poset is simply a nominal set d equipped with a partial order that is by the action of permutations d d · d · d given such a d we get a preorder on a × d by defining a d a d to hold whenever we have a a · d a a · d in d for some or indeed for any a a a d d as usual a a denotes the permutation that a and a leaving all other atomic names fixed we write ad for the poset obtained by a × d by the equivalence relation associated with this preorder and a d for the equivalence class of a d defining a permutation action by · a d a · d one can show that ad is also a nominal poset with a d d a an element of ad is an abstract form of equivalence class for elements of d it is abstract because d itself may not consist of syntactic just need to know how name permutations act on its elements example for any nominal set x partially ordering the elements of the nominal set of finitely supported subsets of x by inclusion we get a nominal poset consider the case when x a given a a the name abstraction function pfsa mapping each s pfsa to a s does not preserve all joins of finitely supported directed subsets for example consider the directed subset f consisting of all finite sets of atomic names f has empty support and its join f is equal to a however upon a a in a one has a a a a a a a and one can check that a f f f a a a so a f a f f f a motivation for using nominal rather than ordinary domains to do denotational semantics is precisely to gain access to this operation of name abstraction which can be used to model language features involving binders so finding a setting in which name abstraction preserves limits of approximations is crucial it turns out that the problem with the directed subset f in the above example is its lack of what and turner call each f f is a finite set of atomic names and hence is supported by f itself thus there is no single finite support for all the elements of f definition given a nominal set x call a subset s x uniformly supported if there is a finite set a f a that supports each x s a subset of a nominal poset is a subset s that is both uniformly supported and directed a complete partial order is a nominal poset that has joins s for all subsets s lemma in a nominal poset d every finitely supported chain c is necessarily uniformly supported in particular each d c is supported by c for a proof see turner lemma as turner points out using this lemma the classic result of can be extended to show that a nominal poset is a if and only if it has joins for all finitely supported chains so in effect give us a domain theory within the higherorder logic of nominal sets based on as we will see in section they also give us access to the construct we model potentially infinite program behaviours in languages with names using denotations that are joins of approximations to the behaviour each approximation should be finite in a suitable sense for classical domain theory this amounts to being compact also known as isolated with respect to directed joins by analogy we make the following definition definition algebraic an element u d of a d is if for all subsets s d u s d s u d we write kd for the set of elements of d we say that d is an algebraic if each of its elements is the join of a subset of kd d is algebraic if in addition the underlying set of kd is countable recall that a subset of a set is compact with respect to directed joins unions of subsets if and only if it is a finite set here we are restricting attention to a smaller class of joins the ones therefore we expect to be a more notion of we show in the next section that it corresponds precisely to the notion of orbitfinite subset introduced by et al orbitfinite subsets the action of finite permutations of a on the elements of a nominal set x partitions it into two elements x and x are in the same if x · x for some finite permutation for example a itself has just one a × a has two namely a a a a and a a a a a and in general an has always finitely many in contrast the nominal set a of finite lists of atomic names has infinitely many since lists of different length cannot be in the same definition orbitfinite subsets a finitely supported subset s of a nominal set x is said to be orbitfinite if it is contained in the union of finitely many of x et al investigate orbitfinite data structures and algorithms for a generalised version of nominal sets over any symmetry note that an orbitfinite subset may well have infinitely many different elements for example a is an orbitfinite subset of itself in order to compute with orbitfinite subsets one needs an effective presentation of them and their operations the following notion turns out to give an alternative of orbitfinite subsets that is suitable for calculation it was introduced independently by turner definition section definition definition and et al section whose hull terminology we adopt here see also and definition whose closures are of the form definition orbitfinite let x be a nominal set given finite subsets a f a and f f x define · x a x f where a means that is a finite permutation of a that each a a it is not hard to see that is supported by a and contained in a finite union of of x namely the of each x f what is less obvious is that every orbitfinite subset is of this form this follows from a key technical property of proved independently by turner lemma and et al lemma a a f a f f x a a f f x f this property can be used to prove the following theorem that makes the connection between orbitfinite subsets and the notion of from the previous section consider the nominal poset of finitely supported subsets of a nominal set x the partial order being subset inclusion it joins for all et al section use the term finitary subset for what we call an orbitfinite subset finitely supported subsets given by union and hence in particular it is a theorem an element of the is if and only if it is an orbitfinite subset of x and it is an orbitfinite subset of x if and only if it is equal to for some a f a and f f x every s is the join of the orbitfinite subsets contained in and with the same support as s thus is an algebraic in the sense of definition so there is the following analogy finite sets directed orbitfinite nominal sets which we apply next to the classical notion of scott domain that in the denotational semantics of higherorder functional pro gramming languages lemma nominal scott domains a nominal scott domain d is by definition an algebraic with a least element and joins for all finitely supported subsets that have upper bounds or equivalently by theorem joins for all orbitfinite subsets that have upper bounds remark flat domains if x is a nominal set the flat nominal poset x is given by x with partial order d d d d d and permutation action extending that on x by · it is easily seen to be a nominal scott domain with kx x definition the category has nominal scott domains for its objects and for its morphisms the functions f d d that are both that is f · d · f d holds for all finite permutations and all d d and that is monotone and preserving joins remark domain theory the nominal domain theory for concurrency of and turner introduces the notion of join and contains a of compact elements in terms of the hull construct from definition however their domains are more specific than ours as they are based on path sets subsets of which form complete lattices modulo their category is a full of theorem is cartesian closed proof the terminal object is given by the trivial flat domain the product of d and d is given by their cartesian product with permutation action as in and partial order d d d d d d d d d d have an underlying set consisting of all functions f d d that are finitely supported with respect to the usual permutation action for functions given in the partial order on such functions is also given as usual f f d d f d f d for ordinary scott domains compact elements of the exponential are given by joins of finite bounded sets of here given elements ui i one can show that the u u d d if u d then u else is in kd d that a typical element of kd d is the join of an orbitfinite bounded set of such step functions so in view of theorem kd d is countable because kd and kd are and that every element of d d is a join of elements in kd d we give some examples of elements of in associated with the flat domain of atomic names a the examples show that although a has a infinite underlying set it has very different proper from the flat domain of natural numbers n eg the permutation action on n is discrete · n n these examples will be important for the development in section example name equality test let true false be a discrete nominal set for each atomic name a a consider the function eq a a given by d true if d a false if d a a if d for each d a then using the notation from definition and one finds that eq a true a false where a is any atomic name not equal to a thus from the proof of theorem we have ka example exists name for each f a define exists af true if a a f a true false if a a f a false otherwise any a a one can show that exists a is equal to true true false false and hence that exists a ka example definite name description note that the functions in example satisfy eq a eq a a a hence for each f a we can define f a if f eq a for some a a otherwise then any a a one has a a and hence ka a remark least fixed points as for any cartesian closed category theorem allows us to model typed calculus using nominal scott domains and functions also supports the usual interpretation of recursively defined terms via least fixed points for if d and f d d then f f is a subset of d each element is supported by f whose join is fix f the least fixed point of f by the usual argument indeed for each nominal scott domain d the function assigning least fixed points gives us a morphism in fix d d d it is probably the case that has the algebraic properties over the category of nominal sets needed to model recursive definitions at the level of types cf section and section however we have yet to check the details of this abstraction and restriction the following result is the basis for giving denotational semantics using nominal scott domains to languages with name binding operations such as the one considered in section theorem if d is a nominal scott domain then so is the nominal poset ad from definition the operation of name abstraction a d a d extends to a morphism ad in once we define d proof if s is then so is d d a d s for any a a the same holds if s is finitely supported and bounded from above in both cases a s one finds that the join of s in ad is a d d a d s thus ad has joins and joins of bounded finitely supported subsets and its least element is a for any a a the above description of joins in ad implies that a u k a d if and only if u kd and hence that ad is algebraic it also implies that each d d a d is algorithms that manipulate binders not only construct name abstractions they also them apart for example supports computation with name abstractions via a convenient form of pattern matching that allows bound entities to be named while invariance under equivalence the mechanism underlying this form of of name abstractions is most easily understood in terms of name to which pattern matching can be translated given d and e ad for each a a with a e there is a unique element e a d satisfying e a e a called the of the name abstraction e at the atomic name a section note that this operation is partially defined to form e a we require a e meaning that a not in the support of e for flat domains we will make a total function simply by mapping the pairs where is undefined to d however for domains this is not possible because in general it does not give a monotone function for example in a a a a assuming a a but we cannot define the of a a a at a to be the least element of pfsa since a a a a a and a a a a one way to deal with this of in a programming language is to its type system with freshness assumptions to ensure statically that name abstractions are only at fresh names this is the solution adopted by the original version of and is the one chosen by and turner in their language nominal later versions of use a conventional type system and enforce freshness conditions dynamically via the use of local names in expressions at the of purity we do the same with the language introduced in the next section but achieve purity via the use of local names rather than generative ones these will be modelled by some extra structure on nominal scott domains in the form of name restriction operations section that enable us to give morphisms ad × a d in for the operation of name definition name restriction a name restriction operation on a nominal scott domain d is a morphism r ad d in satisfying the structural properties a d r a d d and r a r a d r a r a d for all a a a and d d we usually write r a d as ad with the particular morphism r understood from context using this morphism as in pitts corollary we can extend the partial operation of to a total function ad × a d satisfying a d a d a d a aa a · d if a a a d the fact that this is and hence determines a morphism in follows from the description of joins in ad in the proof of theorem the following result shows that domains arising in the denotational semantics of higherorder functional programming with name abstractions section all carry a name restriction operation the theorem can be proved by extending the results in pitts section from nominal sets to nominal scott domains theorem every flat nominal scott domain x has a name restriction operation satisfying ad d if a d if a d for all a a and d x if d d have name restriction operations their product d has one satisfying ad d ad ad for all a a d d and d d if d d and d has a name restriction operation then whether or not d has one as well the exponential d d has such an operation satisfying af d af d if a d for all d d and f d d finally if d has a name restriction operation then the name abstraction domain ad has one satisfying a a d a ad if a a for all a a a and d d remark in the above theorem the name restriction operation for is rather subtle property at first seems like only a partial specification for the function af but in fact determines it uniquely since it implies that for all d d af d aa a · f d for any a f d see theorem it is easier to see that uniquely defines name restriction for name abstraction domains because given a a we can always choose a representative for the equivalence class a d with a a theorem gives operations that model locally names in programming languages for example in one can see that and pitts use the name restriction operation constructed as above for continuation domains of the form d to model the operational semantics of which evaluates a local scope by generating a name that is fresh for the current state in this paper we use functional theory of local names which is modelled in rather easily in view of the above theorem the next section introduces a language corresponding to a simply typed fragment of but with this kind of locally name pna programming with name abstractions the programming language pna programming with name abstractions is basically pcf with names added like pcf pna has arithmetic constructs callbyname higherorder functions and fixedpoint recursion what distinguishes the two languages is that pna treats names as firstclass and has constructs for locally scoping them them testing them for equality and for name abstraction and to exercise the use of name abstraction it also features a representative nominal algebraic datatype namely a type for equivalence classes of terms for example when subst is the pna expression defined below subst e a e computes the term obtained by substitution of the term represented by e for all free occurrences of the variable named a in the term represented by e typ bool nat × name term types e exp expressions x variable x v t truth f if e then e else e conditional o number zero s e successor pred e predecessor zero e zero test e e pair fst e first projection snd e second projection x e function abstraction e e function application f ix e fi t re c a atomic name a a a e local name e e e name ee name equality test v e variable term a e e application term l e lambda term case e of v x e a x x e l x e term case a e name abstraction e e name c can canonical forms t f o s c e e x e a v c a c c l c a c figure syntax of pna subst y term x name fix f term term y term case y of v x if x x then y else y a y y a f y f y l z l a f z a figure gives the syntax of pna in the grammar for expressions the part below the dotted line is what is added to pcf there are two kinds of identifier in the language variables x y z f v and atomic names a b c a the sets v of variables and a of atomic names are disjoint and infinite both kinds of identifier may be bound and the languages binding forms are x a case e of v x a x x l x and a we identify expressions up to equivalence of bound identifiers for any expression e we write for its finite set of free atomic names and fve for its finite set of free variables the reason for making a syntactic distinction between variables and atomic names is that they behave differently various properties of pna such as its typing judgement are preserved by the operation of substitution of expressions for variables but are only preserved by permutations of atomic names rather than more general forms of substitution for names the operation of simultaneous substitution of expressions e en for distinct variables x xn in an expression e is written as where the substitution avoids capture of both free variables and free atomic names by the languages binding forms the operation of applying a finite permutation a a to an expression e is written · e it x x c bool e bool e e if e then e else e o nat e nat s e nat e nat pred e nat e nat zero e bool e e e e × e × fst e e × snd e x e x e e e e e e fix e aa a name aa e a e e name e name e e e e e name e name e e bool e name v e term e term e term a e e term e term l e term e term x name e x term x term e x term e case e of v x e a x x e l x e aa e a e e e name e e figure pna typing rules is defined by into all subexpressions and applying to occurrences of atomic names this is an action in the sense of section and makes the set exp of pna expressions into a nominal set since the elements of exp are expressions up to equivalence support in this nominal set is given by the finite set of free names of each expression pna is a simply typed language the grammar for types figure extends that for pcf in a version with products × with a type name of names a type term of terms modulo equivalence and name abstraction types the inductively defined typing judgement e read as in the environment the expression e has type is defined in figure by the usual rules for pcf and below the dotted line rules concerning names the typing environments x xn n are finite functions from variables to types that track occurrences of free variables in e note that because there is only one sort of name we do not to add a component to tracking occurrences of free atomic names in e in figure we extend usual rules for an inductively de bigstep evaluation relation with the rules below the dotted c t f o e e x e cc ec se sc e t e c if e then e else e c e f e c if e then e else e c e sc pred e c eo zero e t e sc zero e f e e e e c fst e c e e e e c snd e c e x e c e e c e c fix e c aa aa e c ac c a e c e a e a e c e e e a a · c e a e a e e t e a e a a a e e f ec ve vc e c e c a e e a c c ec le lc e v c c case e of v x e · · · c e a c c cx c case e of · · · a x x e · · · c e l c c case e of · · · l x e c ec a e a c e a c e a a a e e c a a a · c c figure pna evaluation rules line that concern names the evaluation rule for local names makes use of the auxiliary definition in figure thus the relation e c defines when a pna expression e evaluates to canonical form c see figure for the grammar of canonical forms as for pcf we only evaluate expressions that are in the sense that fve though they may contain free atomic names for evaluation this is because unlike variables atomic names are canonical forms we also choose to evaluate under name abstractions so that a e is in canonical form if and only if e is this permits a representation of equivalence classes of terms in pna that is as simple as representation of numbers they are in bijection with canonical forms of type term it is certainly possible to give a different operational semantics in which one does not evaluate under name abstractions the corresponding denotational semantics would make more use of lifting than does the one in section to name abstractions pna features an operational version of the total operation discussed in section its behaviour is given by the last rule in figure and corresponds to property c t f o s c ac c ae e a e a e ax e x a e a a aa a ac c av c v c ac c al c l c ac c ac c aa c c a c c ac c a a aa c a c figure partial operation of name restriction ac c as for pcf the pna evaluation relation is easily seen to be deterministic e c e c c c and e e c c it is also e c · e · c remark local names evaluation of locally names a e makes use of functional theory of local names because that way of evaluating them the intended model of pna using nominal scott domains in a typedirected fashion as can be seen in the partial operation of name restriction on canonical forms ac c defined in figure this operation is partial because aa c holds for no c thus unlike in pitts we choose to follow odersky and make a a a stuck expression that does not evaluate to any canonical form and whose denotation is this has the advantage that there are no values canonical forms of type only values of that type correspond to equivalence classes of terms the use of local names means that the operational semantics of pna is unlike the operational semantics of the more usual generative version of a used in the calculus at the same time it is known to be as expressive as that version in as much as there is an adequate translation from generative into local names definition contextual equivalence as usual a pna context c is an expression with a single subexpression replaced by the and ce is the expression that results from replacing by an expression e possibly capturing free variables and atomic names in e given welltyped expressions e and e we write e pna e and say that e and e are contextually equivalent if for all contexts c for which ce bool and ce bool hold it is the case that ce t if and only if ce t example although pna contains the expressions of the calculus as a subset the two languages have different semantics for local for pna versus generative for the calculus this affects properties of contextual equivalence in the two languages for example if x e then a x e pna x a e is valid however this is not always the case in the calculus example one can prove by checking that this identity holds in the denotational model developed in the next section and then to the computational adequacy result proved there theorem on the other hand of some calculus equivalences are also true for pna once one takes into account the fact that like pcf pna is callbyname but the calculus is callbyvalue for example here are callbyname of equivalences in pitts and example a x name x a pna x name if x x then f else f name bool a a f name bool eq f a f a pna f name bool a if f a then t else t name bool bool here eq bool bool bool is an abbreviation for a test defined using conditionals in contrast to the calculus where it takes some effort to prove equivalences like and for pna these properties are easily seen to hold in the straightforward and computationally adequate denotational semantics that we describe next denotational semantics of pna for each pna type we define a nominal scott domain by recursion on the structure of as follows · bool the flat domain cf remark on a discrete nominal set with two elements true false · nat n the flat domain on the discrete nominal set of natural numbers n · × × the product of nominal scott domains · the nominal scott domain of finitely supported functions theorem · name a the flat domain on the nominal set of atomic names a a b c · term the flat domain on the nominal set of equivalence classes of terms theorem t a at t t where a a · a the domain of name abstractions of the nominal scott domain theorem typing environments are interpreted as finite cartesian products x xn n · n finite tuples can be interpreted as partial functions from variables to domains such that dom dom and x x for all x dom we call such partial functions environments if x dom and d then we write x d for the x environment that maps x to d and otherwise acts like for each welltyped expression e and environment we define an element e satisfying the clauses in figure by recursion over the structure of e the clauses for syntax constructs from pcf are analogous to the standard denotational semantics of pcf in scott domains the functions and in the clauses for fst e and snd e are the first and second projection functions for pairs fix in the clause for fix e is the least fixed point function the clauses below the dotted line in figure are for the new syntactic constructs of pna in the clauses involving expressions of type term we use t to denote the equivalence class of the syntax tree t of a term we use the function from in the clause for expressions e e the clause for a e makes use of the name restriction operation that each has by of theorem note that the side conditions in the clauses for a e and a e are always satisfiable as we identify expression up to equivalence one can these clauses without side strictly speaking it is by structural recursion since we identify expressions up to equivalence of bound identifiers x x t true f false e if e then e else e e if e true if e false otherwise o se n if e n n otherwise pred e n if e n n otherwise true if e n zero e false if e n n otherwise e e e e fst e e snd e e x e d e x d e e e e fix e fix e a a a e a e if a e e e a a · e if ei ai a i otherwise e e e if e a a otherwise ve a if e a a otherwise a e e t t if ei ti i otherwise le at if e a t a otherwise case e of v x e a x x e l x e e x a if e a e x t x t if e t t e x a t if e at otherwise a e a e if a e e e e figure pna denotational semantics conditions cf figure a e a e a e a a e by to the slightly subtle properties of the name restriction operation for exponential domains remark notation for the empty typing environment there is a unique environment given a expression e we simply write e for e using the developments from sections and one can prove the following results lemma the denotation of any welltyped pna expression e is a welldefined finitely supported and function e lemma pna soundness if e c then e c proof the proof is by rule induction for using the following properties of the denotational semantics whose proofs we omit · substitution lemma if e and x e then holds and for all we have e x e · lemma · e · e · restriction lemma if ac c with c and c canonical forms of type then the name restriction operation defined on as in theorem satisfies a c c the following result allows one to establish pna contextual equivalences by proving equality of denotations theorem pna computational adequacy given e and e if e e then e pna e proof it is not hard to see that the denotational semantic is compositional in the sense that e e ce ce so in view of lemma it suffices to show that if e is a expression of type bool then e true e t we prove this by a suitable logical relation d e d e between the semantics and the syntax of pna see chapter for a good of this method of proving computational adequacy for the scott domain model of pcf the definition of is by recursion on the structure of the type d e d c e c c d for bool nat name term d d × e d e d e d fst e d snd e d e d e d d e e na d a e a the definition is standard except for the last clause which is for name abstraction types there we use the freshness quantifier na of nominal logic thus d e holds if and only if d a e a holds for some a d e or equivalently for any a d e the proof that this logical relation is closed under restriction abstraction and d e a ad a e d e a a d a e d e a d a e a is not straightforward and we omit the details here with those properties the fundamental property of the logical relation follows by induction on the structure of expressions in particular we get e e e this combined with the definition of bool yields using theorem we can prove many contextual equivalences in pna such as those in example in a straightforward manner via the denotational semantics for example is proved by the following argument since we identify expressions up to equivalence for any given a a we can pick a representative expression a x name x a such that a a then a x name x a a a x name x a a by definition in figure a x name x a a by since a a as a a false x name if x x then f else f a similarly a x name x a x name if x x then f else f hence a x name x a x name if x x then f else f and so holds by theorem to prove example one can combine the definition in figure with the fact that if a a f a then f a f a a · a a a · f a f a since f a in contrast to the situation here properties like and for the calculus which uses generative rather than local names can be hard to establish whether one uses operational or denotational techniques see which on an equivalence like full abstraction for pna plotkin proves that the scott domain model of pcf is computationally adequate but not fully abstract equality of denotations implies but is not implied by pcf contextual equivalence furthermore he shows that the scott model becomes fully abstract once one extends pcf with a construct moving to nominal scott domains and pna negative result can certainly be extended to show that the converse of theorem fails to hold we do not yet know what happens if one adds just to pna see section however adding not only but also operational versions of the in examples and we will show that the nominal scott domain model is fully abstract for contextual equivalence in the extended language note that this section does not give a full abstraction result for the more common generative local names used for example in or the calculus generative names can be modelled in through a continuation monad as described at the end of section but full abstraction fails in this model because of the results of page definition the language pna is obtained by extending pna with expressions for for existentially over name there exists some x name such that and for forming definite descriptions over name the unique x name such that the syntax typing and evaluation rules for this extension are given in figure contextual equivalence for the extended language e pna e is defined in the same way as it is for pna in definition remark the addition of existential quantification and definite description is mainly motivated by the need for them in our proof of e ··· e por e ex x e the x e expressions as for pna existential name quantification definite name description e bool e bool e por e bool x name e bool ex x e bool x name e bool the x e name e t por e e t e t e por e t e f e f e por e f eax t ex x e t a e b a f ex x e f eax t a e a b a a f the x e a e por e por e e ex x e x name e the x e x name e figure pna full abstraction theorem existential quantification for num rather than as here for names occurs in original pcf paper and definite description has a long history in logic but it is harder to from a programming language tive in fact a definite description functional for numbers rather than for names is not computable the of ex x e and the x e provide an example of the of finite modulo symmetry mentioned in the introduction for example to prove ex x e f we just have to pick one of the infinitely many atomic names a that do not occur free in e and then show eax f and f for each of the finitely many atomic names b that do occur free in e this works because the property of evaluation implies that if eax f then eax f holds for any a not occurring free in e the denotational semantics of pna expressions is given by extending the definition in figure with the clauses at the bottom of figure here por k is the usual function satisfying true por d d false if d true or d true if d false and d false otherwise exists a ka is as in example and ka a is as in example theorem full abstraction for pna for all welltyped expressions e and e in pna we have e e e pna e fa the sketch of the proof of this result the rest of this section the extension of theorem to pna is straightforward and gives us the lefttoright implication in fa establishing the re implication leads to an investigation of the of elements of the nominal scott domain model by pna expressions however our proof of the implication in fa does not exactly follow any of the proof patterns linking with full abstraction by curien in particular we only know that the elements of the nominal scott domain are definable in pna for certain types that avoid the use of function types in which the nominal scott domain might contain elements with nonempty support so nat is ok but name is not for example this leads us to make the following definition definition simple types let typ be the subset of the collection of types figure given by the following grammar nat name × nat the following lemma is the key to the of simple types it is where the presence of the x e expressions in pna gets used lemma any type is a of a simple type meaning that there are closed pna expressions i and r with x r i x id proof first note that because name abstraction satisfies a form of expansion a e a e if a each is a of name in fact via i x y name x y r f name a f a cf theorem secondly using the x e expressions we also have that name itself is a of name nat via i x name y name if x y then o else s o r f name nat the x zero f x again using the x e expressions one can also show that term is a of nat × name nat proof omitted finally it is not hard to see that bool is a pna definable actually of nat using these four facts one can proceed by induction on the structure of types to show that each is a of some simple type lemma if is a of then full abstraction at implies full abstraction at ie fa fa that i is injective since it has a left inverse r and hence e e thus e e combining these two lemmas to prove theorem it suffices to show that fa holds for all simple types as in curien this follows from of all elements of the nominal scott domains that is for all u k we wish to prove that u e for some pna expression e remark of elements are all the elements of the nominal scott domain definable in pna for any type we introduced simple types because we did not find a way to prove such a result at all types we succeed in showing at simple types essentially because the of simple functions are restricted to nat which makes life much easier in this setting if all the definable used in our proof of theorem were actually definable pairs in the sense that x i r x id holds then at simple types would immediately imply at any type unfortunately for name abstraction types and do not form an pair there remains the possibility that pairs as above can be used to show at all types for a simpler language without name abstraction such as the calculus of odersky extended with fixed points the proof of at simple types in principle follows the structure of the traditional proof by plotkin a modern account of this proof can be found in however in our nominal setting many uses of finite subsets in the traditional proof are replaced by uses of orbitfinite subsets and their presentation as orbitfinite theorem the definition of involves existential quantification over finite permutations of a and for the proof we need to reduce this to existential quantification over elements of a this is where the presence of ex x e expressions in used along with a traditional use of por to prove the following two crucial lemmas neither is trivial to prove in particular lemma works by a subtle case distinction over all the different ways the atomic names in the supports of u and u can overlap lemma true is for every u k and a f a lemma suppose that satisfies · for all v v k that do not have an upper bound in v true v false is then true u false is for any u u k and a f a satisfying · for all finite permutations a a satisfying a see definition it holds that u and · u do not have an upper bound in using these two lemmas one can show by simultaneous induction on the structure of that · u and u true are definable for all elements u k and · u true u false is definable whenever u u k are elements that do not have an upper bound in most of the work lies in the case for functions types which for simple types are of the form nat by theorem and each element u of nat can be represented by u for some a f a f u n uk nk u uk k and n nk n one has to perform another induction on the size of f and make a case distinction based on the existence of u n u n f such that for all a the compact elements u and · u have no upper bound in using lemmas and the proof goes through following the structure of theorem thereby showing full abstraction for pna open problems failure of full abstraction in the nominal scott domain model is fully abstract for just is it necessary to add thanks to a for pointing this out both ex x e and the x e to in order to obtain full abstraction we do not yet have examples of contextually equivalent expressions in or that have different denotations in probably the method of logical relations can be adapted to establish such contextual equivalences but we have yet to this is there a fully abstract model of pna based on games in nominal sets just as pcf is of more interest from a programming point of view than we regard pna extended with recursive types as a pure version of that is potentially useful for functional programming with data involving binders game semantics provided an interesting solution for the original full abstraction problem for pcf and its nominal version has provided computationally useful fully abstract models of generative local state can nominal game semantics provide a similar thing for pna is there a nominal scott domain semantics for the form of nominal computation by the n language with n et al extend the simplytyped calculus with a collection orbitfinite subsets section via a syntax for orbitfinite definition it is natural to consider adding fixed point recursion to this language with a denotational semantics using nominal domains rather than nominal sets the denotational semantics of such an extension of n will require the development of orbitfinite power domains in whose elements are orbitfinite subsets of the elements of d what recursive domain equations can be solved in in his thesis section shows that the traditional method for constructing invariant solutions for locally continuous functors of mixed variance can be applied to the simple notion of nominal domain given by nominal posets with joins of finitely supported chains this can be extended to and we expect it can also be used for nominal scott domains but we have yet to check the details an interesting alternative approach is to develop a nominal version of information systems and construct solutions for recursive domain equations via inductively defined nominal sets of information tokens we have to develop such a theory of nominal scott information systems in which the role of finite sets is replaced by orbitfinite nominal sets unpublished from a logical point of view nominal information systems are of nontrivial nominal posets with all orbitfinite meets rather than just finite meets we expect this machinery can be used to good effect for the orbitfinite power domain construct mentioned above as well as for a version for nominal scott domains of monad for dynamic allocation section a freely generated name restriction operation remark conclusion the results in this paper provide further evidence for how a semantic theory domain theory in this case is by using nominal sets we gain the ability to model constructs involving names and their while preserving many aspects of the classical theory the complications arising from the use of nominal sets their paper is concerned with general nominal sets here we restrict our attention to the equality symmetry and nominal sets in the original sense are feasible and orthogonal to the other developments at the same time their use gives access to new constructs that are far from trivial this is the case for the notion of orbitfinite subset which formalizes the important idea of modulo symmetry within nominal sets we agree with et al that this is an important notion with many potential applications here we have used it to develop a nominal domain theory that via our full abstraction result has a good fit with computation involving local names and name abstractions acknowledgments the support of a cambridge this research was also supported by advanced grant events causality and symmetry we thank michael d and the anonymous for their helpful comments references url s abramsky domain theory in logical form of pure and applied logic ­ s abramsky d r a s ch l and i d b nominal games and full abstraction for the in proc lics pages ­ ieee computer society press s abramsky r and p full abstraction for pcf information and computation ­ s abramsky and a domain theory in of logic in computer science volume semantic structures chapter oxford university press m l b and s towards nominal computation in proc popl pages ­ acm press m b and s automata with group actions in proc lics pages ­ ieee computer society press m and s a characterization of languages in proc icalp part ii volume of lncs pages ­ springerverlag v and u local names and dynamic deallocation of names information and computation ­ pl curien and full abstraction in computation meaning and logic to gordon plotkin volume of pages ­ m j a study of substitution using nominal techniques and sets theoretical computer science ­ ­ m j foundations of nominal techniques logic and semantics of variables in abstract syntax of symbolic logic ­ m j and v freshness and in sets of traces with names in proc volume of lncs pages ­ springerverlag m j and a m pitts a new approach to abstract syntax with variable binding formal aspects of computing ­ f m and u about permutation algebras and named sets higherorder computation ­ j m e and ch l on full abstraction for pcf i ii and iii information and computation ­ p t of an a theory and number ­ in oxford logic oxford university press j a game semantics of names and pointers of pure and applied logic ­ s and a m pitts relating two semantics of locally names in proc csl volume of international proceedings in pages ­ g po sets and directed sets with applications algebra ­ e moggi an abstract view of programming languages technical report department of computer science university of edinburgh u and m calculus structured coalgebras and minimal in proc volume of lncs pages ­ springerverlag a s and n algorithmic games for full ground references in proc icalp part ii volume of lncs pages ­ springerverlag m odersky a functional theory of local names in proc popl pages ­ acm press a m pitts nominal logic a first order theory of names and binding information and computation ­ a m pitts recursion and induction journal of the acm ­ a m pitts structural recursion with locally names journal of functional programming ­ a m pitts and m j a metalanguage for programming with bound names modulo renaming in proc volume of lncs pages ­ springerverlag a m pitts and i d b observable properties of higher order functions that dynamically create local names or new in proc volume of lncs pages ­ springerverlag g d plotkin considered as a programming language theoretical computer science ­ f pottier static name control for in proc lics pages ­ ieee computer society press d s scott domains for denotational semantics in proc icalp volume of lncs pages ­ springerverlag m r the fresh approach functional programming with names and binders phd thesis university of cambridge m r and a m pitts on a monadic semantics for freshness theoretical computer science ­ m r a m pitts and m j programming with binders made simple in proc icfp pages ­ acm press i d b names and higherorder functions phd thesis university of cambridge dec s process calculi operational models and structural operational semantics phd thesis university of cambridge t foundations of functional programming world scientific d c turner nominal domain theory for concurrency phd thesis university of cambridge d c turner and g nominal domain theory for concurrency in proc csl volume of lncs pages ­ springerverlag n nominal game semantics phd thesis university of oxford n automata in proc popl pages ­ acm press n program equivalence in a simple language with state computer languages systems and structures ­ 