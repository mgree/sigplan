syntactic analysis of precedence graph grammars by technical university of berlin department of abstract the analysis of derived by a contextfree is a rather complicated algorithm analogously to the development for ten years we define the as a subclass of the contextfree allowing for easier parsing algorithms by we can decide locally if an edge or a node is part of a handle and if it in which direction to proceed to reach one introduction marked graphs and graph grammars is a programming language where parts of a program may be described by diagrams see de the syntax of these represented as marked graphs is determined by a contextfree so the problem of of leads to the problem of looking for a derivation of this during syntactic analysis in order to do the next reduction step we have to search in a graph for a suitable subgraph to reduce it is wellknown that this problem is solvable from the viewpoint of theory alone in practice such an algorithm will work only for very small graphs and even then will be very in order to get better we restrict our attention to a certain subclass of contextfree graph grammars which we call precedence graph grammars and turn out to have the following properties the search for the next handle ie here the next subgraph to reduce can be done locally by one edge and corresponding these grammars are and the can be done without definition a marked graph is a system where k is a finite set of nodes a set of edges kk v a mapping for labelling the nodes rr m a mapping for labelling the edges we suppose v and m as wellknown finite sets their formal definition will be part of the grammar so that they have not to be included in the above definition for the description of graphs with several edges labelled differently between the same nodes we may generalize r to a relation which domain is the whole set of r picture i gives an example for our use of marked graphs in order to eliminate such trivial differences between graphs as eg a different order of numbering the nodes we define in and usual way and equivalence of marked graphs the next important step is to describe the process of substituting a certain subgraph by another graph we define this derivation step as in which is different from the way in c q fq i v fr picture i example for a piece of a and the formal description by a marked graph the meaning of the labels for the edges is obvious let be a marked graph g with a subgraph g and the remaining g b e c a u s e we r e s t r i c t our a t t e n t i o n to connected graphs only there must be some edges in g between k and k the set of nodes of g and g resp definition r r kk these edges will be used to tie the graph which is to replace g to the remaining parts of g suppose that a marked graph g contains a s u b g r a p h gi i c g w h i c h we want to replace by gr how to tie gr to the ends of the edges of and if for example xy g and we know the nodes z in g which must be connected to x after replacement r then we can describe these new edges by pairs yz k i x k r so we have t o g e t h e r with g and g r a set r additionally we let this process of of in element depend on the label of this edge for this distinction we have a label relation t m where the domain is the total set ht but which may have more than one value t for an element h analogously we have for the of the elements of a set f and the r e l a ti o n f m such that for every h h f there is at least one mm f with hm m definition a graph grammar is a system gg where v is a finite set of symbols a set of terminal symbols m a finite set of labels for edges s a marked graph the start graph and p a finite set of productions of the form p g i g r h f m f h t m t where g and g r are marked graphs with the set of nodes k and kr resp m fh f t m as above m and example the following example from the grammar let be gg where t o m and v r r i i o the start graph consists of only one node labelled t without any edges we use a graphical description of the productions consisting of two parts on the left side there is a description of the graphs for both sides of the rule ie of g and gr on the right side we give the marked graphs repre both sides of the rule for distinction the nodes of the left side are twice the elements of h f and h t are represented by dashed arrows so that an arrow from a to b stands for the element ab r or resp the labels for the edges are attached to the corresponding arrows so we define p to consist of the rules i to described in picture definition for two marked graphs g and g like above there exists the relation g gg g iff there exists a production p in the graph grammar gg p such that i g i c g and g r c g ii g gl g g r iii zx i yx zy g h f xz i c yz h t no of a rule i i s t r i i i marked graphs both sides id in v in v jn ti r r picture graphical representation of the rules of the grammar in example i the relation gg turns out to be uniquely and effectively to construct declared in the usual way g of the relation as reflexive is gg and transitive picture gives an example of the derivation of a s i m p l e s t r u c t u r e w i t h the g r a m m a r of e x a m p l e i the hierarchy was in order to describe the derivation process of contextfree graph grammars and to define such a grammar to be we define generalized derivation trees which are no real trees but which give a similar description of the derivation of a no of the rule derived picture representation as a marked graph i o i c i gh e in l r i r picture example for a derivation with the grammar example i we define grammar to be contextfree iff the left hand graph g of every production has only one node in is shown that the graph grammars include as a special case the grammars one only has to restrict to one sort of edges and to require that r is totally ordered therefore we get as result a hierarchy of graph grammars which is proper because graph as the derivation tree does for a word derived by some contextfree grammar precedence graph grammars we generalize the idea of precedence for easier parsing in the following way to graph grammars every edge of a marked graph has exactly one of the three attributes starting at some arbitrary node x we proceed one edge starting resp ending at x to the node y at the end resp start of this edge as long as this edge xy resp yx has the a t t r i b u t e resp a h a n d l e for r e d u c t i o n of the actual graph is a subgraph where all edges have the attribute and for all connections to the is true if a is a node of the handle and b a node of the which are by the edge ab resp ba then the attribute of this edge is resp t · where k resp r is the label function for nodes resp edges remember that we the graph on the right side to be connected so if we found one node of a handle we can find the others by edges with attribute only second step for all edges pointing from outside into a handle we have to insert such an edge is always from an edge ab on the right side of a rule kb is a nonterminal the actual handle is derived from kb and during this derivation the edge in question always was inherited the following algorithm searches for all the symbols derivable from kb and to which the original edge ab may be left z picture example for a graph with attributed edges and four handles the labels are omitted for easier understanding we can imagine that the attributes indicate the of a node for an edge ab means that a and b are on the same level means that a is over b and indicates that a lies lower than b the search for a handle means then to look for a consisting of one or some nodes from which every existing edge goes down to a lower node how to realize these informal ideas the names for the nodes at both ends of an edge are arbitrary and therefore cannot serve to the attributes to the edges we will choose the attributes depending on the symbols of the nodes at both ends of the edge and on the label of the edge so we get a mapping this map is to be implemented in form o a three dimensional array our socalled there is a representation of the following in terms of other relations combined by concatenation and star operation as well but i prefer to give the following algorithmic definition for the in four steps first step for all edges ab on the right side of a production we must do the entry kb p r o c into symbol u label rel symbol v void if v nonterminal then co let b e the r u l e s w i t h v on the l e f t s i d e co for j from i to n do f o r x e a w i t h rel e m pf x do if a then e l i f o then e l s e s k i p co we r e a c h e d a l o o p co fi od od else skip co end of recursion v is terminal co fi third step in correspondence to the second step we have to treat the edges starting at some node of a handle and ending at some node which belongs to the this is done by the algorithm p r o c out o f symbol u label symbol v void if u nonterminal then co let be pl pm the rules with u on the left side co for j from to m do f o r x e h t w i t h re e m t x pi do if out e l i f p k x r e l v o t h e n c o n f l i c t k x rel v else skip co we reached a loop co fi od od else skip co end of recursion u is terminal co fi fourth step in the second and third step we out the cases where necessarily a reduction of the node at one end of an edge had to be done before the other could be reduced but by combination of the situations of the second and third step during derivation there may exist edges where the next reduction step can be performed at both ends to realize our original aim it would not be necessary to do any entry into the in this case but in order to use the for a better and early we enter a special symbol to the p r o c complete symbol v void for ue v with do for v v with do if then then fi od od the algorithms to test the second condition are shown above there are also available algorithms to test if a grammar the third condition theorem a precedence grammar is and can be without in a very efficient way in the following we give an outline of a recursive parsing algorithm which works only for correctly derived because all error handling is omitted p r o c analyze node a void while diagram start graph of the grammar do while there is no complete to which do a node with higher od reduce the reached and replace by b od the efficiency of this parsing method is due to the fact that we in the parsing process for every edge it is decidable by simple if it belongs to a handle within the in if b i ii in in in vl if t i i i i c i · picture for the of example i i i i i i i i i i definition a contextfree is a precedence grammar iff i it is u n i q u e l y i n v e r t i b l e ii for all edges on the right side of the rules the three algorithms work without conflict iii the grammar derives only connected graphs and every edge is inherited to at least one node bool procedure there is nd complete to which belongs and in the case that the actual node is not part of a handle we get information where to proceed by node with higher in picture we demonstrate how this algorithm the diagram which was derived in picture by the g r a m m a r of e x a m p l e i no of the rule which is going to be representation of the diagram which is reduced up to now by a marked graph reduced diagram v i i ¢ the part of the graph which if has to be visited to find the next handle with precedence attributes i in lo q q in l i it i p i c t u r e how the p r o c e d u r e analyze w o u l d p a r s e the d i a g r a m d e r i v e d in p i c t u r e picture consists of three parts on the left there is a marked graph representing the diagram in the middle on the right side we give the part of the marked graph which has to be to find the next handle in the right part the labels are omitted and the precedence attributes are attached to the edges the actual handle is in order to eliminate trivial we suppose that the nodes are visited in the natural order of integers conclusions we tried to apply these ideas of precedence grammars to the graph grammar by which the programming language is described and we get similar results as early attempts to apply ideas to existing linear programming languages there are of course precedence conflicts which can be eliminated by changing the grammar but this must be by higher complexity of the grammar greater number of nonterminals and rules especially references de d e n e r t e syntax dissertation berlin dfs a programming language l e c t u r e n o t e s in comp s c i e n c e s no s p r i n g e r verlag pp graph an algebraic approach proc th annual conf on switching and automata theory pp fr dissertation berlin f des fr math nr august st dissertation berlin 