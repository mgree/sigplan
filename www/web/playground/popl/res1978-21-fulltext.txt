conference record of the fifth annual acm symposium on principles of programming languages nondeterminism in logics of programs preliminary report by david and r pratt laboratory for science massachusetts institute of technology abstract mass third nondeterminism one methodology for we investigate the principles underlying reasoning about nondeterministic programs and present a logic to support this kind of reasoning our logic an extension of dynamic logic and subsumes most existing firstorder of nondeterministic programs including that developed by dijkstra based on the concept of weakest precondition a significant feature is the strict separation between the two kinds of nonterminating computations infinite computations and failures the logic has a semantics an essential to establishing completeness of of the logic we give an axiomatization for flowchart regular programs that is complete relative to arithmetic in the sense of cook having a satisfactory tool at hand we turn to the two procedures that though written independently are intended to on solving a single problem the approach is to make one procedure an interpreter for the other augmented transition networks supply an instance of the style the user of this system writes a grammar for a specific natural language which amounts to a nondeterministic program to be run on interpreter which though of the details of specific languages nevertheless much parsing knowledge to the problem of making choices let unspecified by the users program this technique is in wide use in other areas of artificial intelligence and a way of such al programming languages as etc of the concept of the total correctness of nondeterministic programs providing in passing a critical evaluation of the widely used predicate transformer approach to the definition of programming constructs by dijkstra our axiom system a complete axiomatization of fourth from a strictly mathematical viewpoint there is something about taking such constructs as if ee and do as primitive constructs ij then else involves the two concepts of testing and choosing and do involves the two concepts of testing and a more basic approach is to develop these concepts separately however in the concept of testing from the concepts introduction of choosing and we have removed the parts of the if ee and while do constructs responsible for their interest in nondeterminism determinism nondeterministic programs have considerable his interest could be attributed to a concern for generality anything we have to say about nondeterministic programs covers deterministic as a special case however there are also deeper reasons for this interest first nondeterministic programs have been proposed as a model of parallel processes such parallelism arises in computers where nondeterminism expresses the apparent of the scheduler it als arises in the management of external physical devices where the nondeterminism captures the behavior of physical devices second nondeterminism is component of a programming style that imposes the constraints on the processor executing the program for example a certain program may run correctly provided that initially x is even if the programmer requires the processor to set x to an even number of the programmers choosing the processor may be constrained byte oriented machine where integers are represented as setting x to a particular number requires four operations but if the programmer has merely setting it to an arbitrary even number the processor can satisfy the request with one operation by setting the byte to say zero this report was with the support of the national science foundation under no fifth from a practical point of view when reasoning about deterministic programs it can sometimes be convenient to make what amounts to claims about nondeterministic programs when we argue then xx else xx cannot affect y a part of our argument might be that whether we execute or wx y will not change the fact that the whole deterministic no role in this argument which amounts to the observation that the program u xx cannot change y is a program calling a or program fl the choice being made arbitrarily ie nondeterministically by the same token the observation that xo do xx leaves the parity of x unchanged depends on the fact that executing xx arbitrarily often ie executing xx leaves the parity of x unchanged a is a program calling for a number of executions of program a the choice of number being made nondeterministically this illustrates the or applying nondeterministic reasoning to deterministic programs the interest abstract programs concretely a program is listing unless we consider its aspects such as its its proof of correctness or the actual cost of writing it at any event we shall consider in this paper that its listing everything we know about the program to facilitate reasoning about a program we shall often find it convenient to discard information about that program the amount of information discarded depends on the nature or the reasoning when he reasoning involves only inputoutput behavior of a program as it does in discussing partial correctness the appropriate degree of abstraction treats programs as functions on states or binary relations in the case o nondeterministic programs however this degree of abstraction is when one wants to distinguish between different kinds of nontermination such as versus or when one wants to deal with running time or space or the programs interaction with its environment as it runs or any other aspect of a program not covered by simple initial state relationships paper we shall find to talk about three kinds of programs namely concrete programs or elements of a computation trees and binary relations on states the interest in computation trees is that they exhibit in a natural way just those details relevant to the main problems we address in this paper namely how to talk about the behavior of nondeterministic programs taking into account behavior such as and failing a computation tree is a tree whose vertices are states each path of the tree represents a possible state or computation sequence for the program the root of the tree identifies the starting state of the program the interest in binary relations may be attributed to the fact that much reasoning about programs on their external behavior the question of which state or states in the presence of nondeterminism the program will ultimately the processor into from a given starting state such reasoning can often be confined solely to the external of the program and its in which case it is convenient to take as the objects under discussion not the programs themselves but merely their behaviors the appropriate abstract object that associates with each state of the world a final state is a to states when possible the appropriate choice of object binary relation on the three levels of abstraction concrete computation trees and binary relations form a of levels of increasing abstraction or equivalently decreasing information if one were to embed our treatment in a more algebraic framework than we shall do in this paper one would treat the concrete programs as an initial algebra of a category of abstractions with a chain of arrows homomorphisms from the initial algebra to computation trees and to binary relations in act we shall explicitly exhibit these homomorphisms but we shall not explicitly adopt a approach in so doing i upper and lower bounds much discussion about programs takes the form of bounds on their behavior for example we may claim that if and when program a terminates x this is an bound on the behavior of u in that ty may not terminate in not satisfying x it transitions having a final state not satisfying x but says nothing about the or transitions conversely we may claim that it is always possible for xo do xx to terminate with xo this is a bound it the existence of transitions with final state satisfying xo one such transition for every possible starting state because of the always however it says nothing in itself the possibility of other transitions though in this instance the knowledge that the program is deterministic allows us to infer as an upper bound the absence of any other transitions more generally that a program is deterministic is by itself an upper bound that it is total there always exists a halting computation amounts to a lower bound a substantial difference between our approach to bounds and that implicit in weakest precondition w operator is that we shall at all times keep the upper and lower bounds separate it will become evident when we come to prove our completeness results that such a separation is essential to the success of an approach such as ours to getting completeness results in this area in contrast dijkstra lets the single operator impose both upper bounds partial correctness and lower bounds proper termination simultaneously and we do not see how to deal with the combination in any way that is not equivalent to the decomposition made explicit in our approach contents elsewhere see and we describe a language for reasoning about bounds on abstract programs which we called dynamic a language sufficiently general that it the expressive power of most existing firstorder languages proposed for this purpose yet so simple in its that it would appear to be suitable as a standard tool convenient terminology for defining the concepts and constructs arising in other languages in section we first recall the basic concepts of dynamic logic dl as given in and we then describe the and the computation sequences of a program u in state the importance of the notions of and corresponding respectively to executing an infinite and reaching a false test having the trees of section in mind section which is the main section of the paper deals with the of dl to dl by adding a divergence to the universe u of states and adding to the al and ry modalities of dl a al modality with its dual a constructed for reasoning about the presence and absence of various important properties of the new system are proved the axiom system p which was proved relatively complete for dl in is augmented with two rules and the resulting p is proved complete for dl thus one can now sa and prove eg a of a program a and formula p meaning a can terminate and whenever it does p holds moreover here is no way of entering an infinite loop section contains a of the concept of total correctness when applied to nondeterministic programs the argument that this becomes an concept unless a strict method of executing the programs is adopted we then carry out a critical investigation of notion of the precondition which is considered to be a basic tool for proving the correctness of nondeterministic programs the notion of has been described in s and in three different ways none of which is constructive and none of which is completely consistent with the others observations in this direction have been made in and but we still feel that a covers this widely used notion which seems to have been introduced to the community with the same strong motivation but with the same lack of underlying semantics as was partial correctness notion w hope to have achieved a of this concept finally in section s we refer to other important work related to the topic of our paper dynamic logic computation trees and failing first we recall the of regular dl described in greater detail in f we assume we are given some universe of states u the elements of which we denote by etc order formulae are assigned truth values in the states of u by the standard methods writing kp when p evaluates to true in f furthermore every regular program a over assignments simple in this paper and tests is regarded as a binary relation over u in the following manner xe y every symbol has the same value in y and j except x which in has the value that the expression e has in d p fl a uu and a are the composition union and reflexive closure of their components respectively we will write ja or a new formation rule is added those of predicate calculus by ap read p as a formula for any program a and formula p the semantics ga a p or equivalently v up aj thus for the dual ap denoted by p iff p or equivalently a pp la with this language many of the properties of programs which relate initial and final states can be stated and like partial correctness total correctness if a is deterministic as well as more sophisticated statements such as the valid a p a a approaches to the dl can be namely constructing axiom systems with the goal of achieving absolute completeness this can be done for dl as work we are doing with ar meyer shows and a variation of method namely constructing finitary axiom systems which are complete relative to arithmetic ie taking as axioms all the valid formulae o first order arithmetic we would like to for the latter the term we here a variant of the axiom system p first appearing in which was proved to be complete in a all valid of first order arithmetic b all of propositional calculus c x where p is d e f a c h invariance ap i convergence where p for some term t stands for p x does not appear in a and n does not appear in px or a we make a remark here and note that rule h can be re by the equivalent induction axiom p a a p and that we have changed the rule of so as to make possible the elimination of the axiom of and neither change our completeness result of were our programs restricted to be deterministic say by replacing u and by some deterministic conditional and iteration programming constructs dl would suffice in this case ap states that everything will be ok the program via its one and only possible path of execution will terminate satisfying p states that if a terminates then p will be satisfied whereas the fact that something goes can b done with etc hence theories of total correctness of deterministic programs are quite easy to construct and understand they are based in most cases on one basic construct corresponding to ap and om etc in we describe a deterministic version of dl and survey a large number of known methods for reasoning about deterministic programs that the underlying principles in this case are few and relatively simple for the more complex case of nondeterministic programs we will formalize the notion of executing a program eu in a given state by first defining lhe tree of a given and a da is a possibly infinite tree each node of which can have only finitely many descendants and is labeled with either a state element of u or the symbol together with an of whether the node is a halt node which we denote with a square a indicates a node j is j a j is where is the unique state such that g identification of roots root is square iff one of component roots is a ta y td ta fl is the tree resulting from the for any state of every halt node of ca f which is labeled with the state j except for the case where t is a single node and the node to which it is being attached has no descendants i which case the tree d used of c the halt nodes of the resulting tree are taken to be just the halt nodes of ie square nodes of ca f are unless they are also square nodes of c ca f is the possibly infinite tree defined recursively as u a a j where a is u with its root made the reader may verify that computation trees have finite at every node in proving this it is helpful to note that if a tree has a leaf that is not a halt node then that leaf is the root this would not be the case if we did not round the root of a in ta from the point of view of our definition we are regarding a as the program u cx u a u ck and not as the program true f u a u u u where i the reason or not associating an node with a false test directly and instead introducing nodes only via is so that failure to satisfy a test does not count as failure if an immediate alternative is provided necessarily via union permits us to retain the definition of if p hn a else as p a u p in view of the convenience of reasoning about tests and union independently it seems to us well worth while to the notion of failure so that it does not make this definition later on the set of paths of ta from the root will be called the set of computation of a and ca we will call the infinite elements of and the finite elements of ca j terminating in nodes labeled failures a divergence corresponds to the presence of a possible infinite computation of a while a failure corresponds to coming across a test evaluating to false and having no immediate alternatives to that do not backtracking these concepts supply the setting and motivation for the following sections dynamic loc in this section we define an extended dl which we will denote by dl it will have the ability to express the absence of in ca by the modality and its dual a taking to mean that there are no and that every possible final state satisfies p in section it will also become evident that dl is powerful enough to express the absence and hence the presence of failures too thus a wide range of properties of nondeterministic programs can be expressed in dl including as we will see in section all the versions of the notion of total correctness the central theorems of this section are an inductive characterization of the fact that a can cannot diverge and the completeness of an axiom system for dl which provides for the first time a complete formal proof method for formulae including assertions about loops and failures a remark seems to be in place before we proceed we are about to add a divergence to the universe u which for lack of a better symbol we denote by j this state should not be with the similar undefined state of say or the difference being that the symbol in these papers stands for a divergence and failure state the and cons of this different approach will be analyzed and arguments for ours will be presented in section define therefore for a given universe u u df uu truth in a is given by defining wp for every formula p ie the set is empty validity in u is however defined to be validity in u to avoid such familiar theorems as pp new denotations for programs are obtained in dl by adding l l to every test and assignment the definitions of union and composition remain unchanged however we take a to be the transitive closure of a with transitions j when there exist states such that vi an alternative definition of the binary relation on u represented by a is that it is the set of all pairs such that f labels some halt node of not together with j whenever ta is infinite or equivalently has an infinite path by lemma and the finite of the nodes of the tree this approach simplifies the definition by making the description of computation trees do all the work now let us the definitions of ap and iw fact that for we could write f although al was defined as a depends on the fact that is the same as p for all j we note that and and consequently ap is no longer the same as vj p for all states j rather we now define iff p or a p iff p or a iff ja a p or v a iff or v vp and we clearly have and li the new modalities are read a and a inspection shows that these four concepts assert about ca that respectively there are no and every state satisfies p every final state satisfies p there exists a state satisfying p and either a divergence state satisfying p note that states the absence of in ca and the existence of at least one various properties of a nondeterministic correctness can now be expressed namely if r a terminating path satisfying q if r then there exists a terminating path and any such a a aq ra a aq path satisfies q or equivalently which we can abbreviate exists if r then there are a terminating path satisfying q no infinite a aq paths and there if r then there are no infinite satisfies q and any if r then no infinite terminating path and any such path satisfies q ra a q paths there exists a or as above we now some of the basic properties of our new modalities lemma for all programs a and p assignment xe and test q the following are valid a a b ap s ap v c d e cl p a a ap f u p ap v a v g al p a fp h ap v i ap a aq j ap v aq k pm all follow quite easily from the definitions omit the proofs n we note the equivalent assertions a a define u df true ie the identity relation and a d an i a rigorous proof of this theorem is given in the appendix section intuitively the right hand side implies that arbitrarily long computation sequences can be found in ra j which must therefore be infinite the left hand side conversely if ta contains an infinite path then f must either contain an infinite path or a halt node corollary i iff n such that at this point we will start about the specific universe of arithmetic n see that for the universe a of arithmetic with uninterpreted function and predicate symbols augmented arithmetic all results of this paper would also hold we can now the results of the previous theorem and corollary as fn en an equivalent but more description of the behavior of the on a is given by the following theorem and corollary the proofs of which we theorem fn a corollary k ax false v ax corollary states that a divergence in a is due either to being able to run a for as many times as you wish which by lemma is equivalent to being able to run a for ever and this we might term for global reasons or to being able to run a for a certain number of times and then have a itself diverge this for local reasons theorem states that a is if there is a limit on the depth we can go to by doing a and that furthermore a itself does not diverge in the process we recall augmented first augmented dl the fact mentioned in that order arithmetic is expressive for we extend that result to theorem first order arithmetic is expressive for dl ie for every dl formula p there exists a formula f of first order arithmetic such that bn proof use induction on the structure of formulae and programs via the result in and theorem n we make a remark here which concerns the algorithmic logic of the group of researchers by they employ an operator or which is to be equivalent to although allows only programs which are deterministic we can admit this operator into dl allowing the formula fp for any program a and formula p with the above semantics and call the resulting logic we then have is expressive for dl proof again induction is employed this time the key fact is corollary which is as in dl iff f a a in where stands for the formula equivalent to which exists by the inductive hypothesis in an been complete axiomatization of has we would like to here and pose an important open problem pointed out to us by mj fischer concerning the expressive power of dl is it the case that for every p there exists a q such that b pq we strongly conjecture that the answer to this question is no ie that dl is strictly stronger than dl in expressive power meyer has shown that if array assignments of the form fx y are allowed then the answer is ye ie dl is no more expressive than dl however the proof in and the manner in which it uses array assignments in dl to make possible expressing the presence of a divergence further us that with simple assignments the answer is nevertheless no another version of this question is in the case of propositional dl pdl see fischer and where we can similarly define pdl it can be shown that pdl strictly more expressive than pdl other related questions and observations can be found in we now augment p to p by adding the following axioms and rules j x k q true l m a true n a po pn where n does not appear in a p divergence the soundness of the axioms follows from the above discussion and the soundness of rules p and can be shown to follow from theorems and respectively we proceed to show what we might call the completeness of each of the last two rules followed by box and completeness theorems for dl and then present our main result for these purposes denote p without rules and p by and without rules h and by fj as in c we will concern ourselves with the proofs of the completeness directions of the theorems only lemma if then there exists a formula of arithmetic pn with free variable n such that the premises of rule and are all valid proof by expressiveness of arithmetic an is expressible as such a pn by theorem noting we observe the trivial validity of the premises of h theorem dl box completeness theorem of arithmetic r and q and program ts for any fn iff proof assume fn which really asserts that both pn and en hold by the dl box completeness theorem of we have we shall show that ff and axiom n will serve to combine the results this follows however by induction on the structure of u using lemma for the application of rule when a is fi from which we obtain fn and then b lemma if then there exists a formula p of arithmetic such that the premise of rule p and rp are both valid proof assume we will exhibit here a situation similar to that occurring with the rule of invariance in it was implicitly shown that both and could be taken as invariant satisfying those conditions which guaranteed that the rule could be applied here too both a strongest and a weakest antecedent will be shown to satisfy the requirements of the lemma the latter is simply which trivially satisfies the requirements the former is a little more subtle intuitively what we will construct is the predicate p which is true exactly in those states which lie on an infinite path of computation which started in a state satisfying r by assumption there is at least one such path for every such starting state take p to be an equivalent of a recall that fa iff as first order arithmetic can be shown to be expressive for dl augmented with the operator on programs this equivalent exists ar states that the present state is on a path from r via and makes sure that we are on a path with a possible infinite computation first we observe that and by the assumption also thus rp is valid we are left with having show this can be seen to follow directly from the easily checked ar a false f aa uu a av a and taking u to be ar and v to be to check use the and r taking w to be and to be a e theorem dl completeness for any formulae of arithmetic r and q and program u fn iff ip proof analogous to the previous theorem using lemma lemma for any dl p and q and for any program u if fp pq then a fp b fp ap aq c ip d fp ap aq a is obtained by rule c as is b with c and d are obtained similarly with help of axiom n b theorem dl completeness theorem for any p kn p iff fp p framework of the proof follows in the of our proof of the theorem of which induction on the number n of modalities in p and works with a conjunctive normal form rather than it here we refer the reader to pointing out that theorem above gives us the expressiveness we need and s provide for the justification of the additional parts of the case nl and lemma is needed for the last stage in which fp ma lp map is established a a subsequent paper provides insight as to the pattern by which we obtain complete rules for various modalities applied to a and in the process the analogy between the rules for al and cy and the a and a rules of p thus eg the invariant assertion method of which is captured by the rule of invariance h is seen to fall out easily as a special case of a much observation in the work of this section and of is considerably extended by adding a recursion operator to u and together with inference rules for and the resulting axiom system is shown to be sound and complete the interesting part occurs when the analogue of eg corollary is for total correctness and weakest preconditions let us try to the notion of total correctness of a nondeterministic program u in the sequel we ill argue that this is a concept which is necessarily dependent on the particular notion of execution of a one has in mind we will consider and ca of section since might be an infinite set a feasible execution of a in j cannot in general be carried out on a machine by calculating cal choosing one or some of its elements and to execute them rather what we need is to choose some method of traversing fa which will either eventually lead to a halt node either or good node qr will go on for ever we four possible such methods depth first at each node choose arbitrarily between possibilities and proceed stop when a halt node is reached depth first with backtracking same as if an node is encountered first at each node all possibilities simultaneously stop when a halt node is reached if more than one is reached together choose one arbitrarily first with same as ignore all and in choosing we now observe that assuming the existence of at least one final state if the machine executing a program a in state using these various methods is to reach a final state upon completion without having or failed then ta should to the following table where no means that ca j should be free of elements paths failure ks s divergence no no yes yes thus for example if we choose method we do not mind having in the tree but do not want any infinite paths to be present the importance of the above table is that it illustrates the fact that the notion of total correctness of nondeterministic programs is indeed strongly dependent upon the particular method used saying that a is totally correct with respect to r and q amounts to saying that for any such that br application of the chosen method of execution is guaranteed to lead to a final state j such that pq thus whenever we always want both a final state to exist and every final state to satisfy q furthermore whether we require the absence of andor failures depends upon the execution method used we arrive therefore at the following description of the notion of total correctness of nondeterministic programs the variants of this concept for the four methods being respectively r a a a r a aq a r a a r a where iff ca j has no failures and iff ccr has no dl is simply thus total correctness for method can be expressed in dl as r a we would like to point out at this stage that we are quite satisfied with the adequacy of dl for capturing the notion of total correctness for methods and for the latter it is expressible even in dl one cannot imagine an using first search without ignoring the nodes as in also backtracking has become an integral part of depth first search to the point of people having difficulty in it without as we shall see however notion of weakest precondition is really addressed to method and it is therefore at this concept that we now direct our attention showing quite surprisingly that dl is powerful enough to capture the of too and hence the notion of total correctness for all four methods in s and dijkstra introduced the concept of weakest the condition that characterizes the set of all initial states such that activation will certainly result in a properly terminating leaving the system in a final state satisfying a given postcondition p this condition was defined to be the value of a function p which we will write as satisfying the five conditions dijkstra then introduces and defines its semantics program a specifically are a syntax for by specifying the programs a programming language for each allowed and his definitions empty program df identity prog df p assignment df p composition ap df up if df qi a il il il do df il kl where df n p a a qk il and df v il at this point we should assume that ae are to characterize the notion of ru and that they to give rise to a unique predicate transformer ap this as we shall see and independently in eg and is not the case moreover there seems to be no further definition to fall back on if what we want is to understand what p is really saying ie which states satisfy lhe description is and uses the word activation so leaving unspecified which method of activation is being used the definition of programming language uses and certainly does not define it and thus cannot b of much help we first set out to find something which satisfies a e for regular as inspection shows that c fails for ap and e for example of latter take a to be and pi to be xi this however should not cause because ae are required to hold for the final product satisfying which is to have the always will and the will certainly properties an attempt to take ap to be a ap equivalently a will result in c holding but e still failing same example this observation explains our remark in in which we te be a u true which was made solely on the basis that this construct satisfies the axioms which appeared in s ad without to the later addition e of he reason e fails for al and for that matter fails for a is rooted in what calls unbounded nondeterminism which in this case is a term a can as be viewed as a tree with but can have infinitely many final states by of being able to apply a infinitely often this situation is about by further the absence of we propose to add to our at up df a lemma conditions proof omitted ae are satisfied by up thus it would seem that our task is completed as would indeed be the case if defined to be any predicate transformer satisfying ae we might note here that the of wand our argument wand has shown that if a program is to have the property of allowing only a finite number of possible for every initial state which in our case amounts to then a functional fu u is equivalent to ap a for some such a ae hold for f that is substitute f for a in a e this result is essentially showing that our a a is indeed the greatest predicate transformer satisfying these axioms however the fact is that there is more in description than just the axioms let us take a look at the definition of his language we notice that a does not hold for our definition of ap and neither do the equalities for if and do we might note that contrary to what is in the importance of having eg the property wa p u w p hold should not at all be this property is important for the construction of the weakest precondition of a given p with respect to a given a only if the wi construct is the only thing you have in our case the fact that ap does not the property is irrelevant because ap is defined as the conjunction of two constructs which do namely and constructing ap in a concrete situation would proceed therefore by constructing the two components in the natural way using this property for both these observations call for extra analysis we were to to the third class of members of ca j namely the failures by adding a say l to u despite the fact that axioms do not require this his informal discussion of failure referred to as that failure is considered not to be proper termination if we are to capture what dijkstra had in mind by wp as opposed to what he we will need to include in our of what a binary relation abstraction of a program we can do this as we did for j fl is in the binary relation for a when ta j a failure node we now give a way of expressing in dl the formula la whose truth in j asserts that ta j contains no failure node true lp true a jl a a ja a n turn we need to define the transition predicate which expresses the that if a leads to a state from which has no of eventual success or divergence then a may be such resumption is possible with programs such as where one might execute some number of times try to execute fail immediately and so execute again this is precisely the behavior one would expect in the interpretation of the dl translation of while p do a as p a p an assignment or test tr a t let us define now ap df a a ja lemma conditions ae are satisfied by a p omitted it can be shown that the equalities in definition of the guarded command language above also hold for thus ap exactly expresses wa p namely the weakest correct termination when execution method is adopted now given that fl can be expressed using dl and given that we have completely dl we infer that we have also completely ap so we have given an complete axiomatization of notion of weakest precondition these remarks combined with the of the logic developed in section seem even without any additional up to point to the conclusion that reasoning about programs should be carried out using well defined primitive basic concepts such as ap etc as the building blocks from which other more complex notions can be constructed we are strongly against the approach implicit in work in which the basic construct ru and the properties required of it appear to the simple parts of which it consists we are further against the attempt to define the of a language using a complex dependent in this case notion recently and plotkin unpublished have to great efforts in trying to find the appropriate denotational semantics which would correspond to what essentially is definition using predicate transformers of the semantics of a recursive programming language with the explicit of an if then ee construct in our not only have they not fully solved the problem of up a denotational semantics to a semantics the same process remains to be carried out for the other three execution methods for their solution implicitly assumes the need for both and failures but also the top down viewpoint of having to for defining a language with the aid of by up a suitable ordering on the domain which gives rise to an equivalent denotational definition is to the much bottom up approach the latter consists of first defining the objects states and binary relations and only then introducing the logical and assigning meaning in the manner of at this point the truth of the formulae of the logical language has already been determined and in a and the axioms of definition can then be as theorems this formalizes what happens when a is with those axioms he attempts to verify their agreement with his intuition about the behavior of programs ln contrast and plotkin in this case start from the axioms and assign semantics that are faithful to those axioms work some of the points made in the previous section appear also either explicitly or implicitly in hoare he a a p and a e p allows and ensures for ap and respectively and notes and the notation was interestingly for us since and correspond to and v or e and u respectively not to u and e more significant is his definition of ba which in state asserts the of the members of j and which if we take the of rewriting for our a is or as we would write which should now be viewed in the light of section hoare that ap al does not satisfy the basic axiom for program composition and proceeds to describe explicitly in his logic of traces that condition similar to our which guarantees the of failures and shows that defined as satisfies that too manna uses essentially quantification over states to out a variety of properties of deterministic and programs his pro are functions of states ie aj cu f a totally wrt p in and is written aj a pj note and a wrt p in and written p of a and d is written a and y are not empty and a the last conjunct being in dl without the use of state quantifiers then proceeds to express the above and other properties using here we translate for clarity into our own the primitive and second order quantifiers in particular it is noted perhaps the of this fact that a and that totally correct is a at or a af manna then u with an undefined state and requires that the programs map any state into a subset of thus as is the case with and see below wi is added to the program not only in the presence of a divergence but also in the case of failure and hence differs from dl however has four concepts of correctness analogous and not identical due to the above difference to our modalities correct written a a a p aj pj totally zj mj a pj analogous to ap ap and the double duality of these concepts is proved and other properties are expressed in a second order language using these four as the difference in the use of i comes to the surface in the remark j that is valid for every a a fact which is true in dl however this clean description of the four basic concepts of nondeterministic programs formulated already in and to our attention by n our in the manner in which we have constructed dl in who uses explicit quantification over states we find in essence the remark that a d also t proceeds to describe the which satisfies e as well as definitions of what down to u and this is done as we have by using l to express both and failures respectively in the words of with notation if is infinite then jl and feel free to switch from a relation or as a subset of values of some cartesian product to a function rx from uu to nonempty subsets of uu made total by using as the value for aj in case is empty as this approach eliminates the possibility of using u to branch so an if else is added explicitly to the of course in this setting a because uj enables one to be able to choose either and no have to but on the other hand r then a p wr ap v p also proves that the ordering on programs over u results in wa p being continuous in a a result which it is possible show holds for up too to the part of this work relevant to weakest preconditions differs in an important respect from that of uses u and if then dj as two independent constructs and does not have our notion of tests this eliminates all possibility of failure making task simpler than or ours in another important respect his work ours he states explicitly with the convention that ja l holds iff some computation sequence specified by a does not terminate properly either the computation sequence is infinite or that one of the elementary actions is undefined at some intermediate state interestingly reaches the conclusion as did we independently that it is very helpful to define such that tp for all p what he really does is to restrict his predicates to those that are false in another remark about is his ea which is defined to be true in f iff yl is not in a and thus in this light the observation in that eg ea a amounts to our easily checked equivalence a a see lemma le another paper describing a logic which allows nondeterministic programs and which is supplied with a axiom system is pnueli and e in which the nondeterministic assignment can be used to simulate u and however although al p and ap can essentially be expressed and by the completeness theorem proved as well as certain combinations of them no mechanism is provided for reasoning about and hence only total correctness for method can be captured appendix we give here a rigorous proof of theorem an interesting aspect of the proof is the way in which it makes use of a dl version of lemma while the reader may have been by our informal justification of theorem the apparent difficulty of proving it carefully suggests that the intuitively obvious in this case needs to be with unless one is to accept it as axiomatic the theorem asserts that a can reach if and only if for any number of iterations or a either a terminating state is reached or a divergence is encountered along the way the only if part should be obvious but the if part appears to depend on lemma and the fact ie if a doesnt diverge then a can reach only finitely many states which is true of our particular nondeterministic programming language but not true of such assignments as n since we can state an extended version of lemma in dynamic logic we can increase the of the proof of by using this extended version first we need a notion of independent programs we say that a and b treated as binary relations are independent when i a a order independence and ii a fall and with information independence first condition implies that for every computation there is a computation and similarly with the second condition asserts that if we know what state a to then we know what state a to in the process ie the information can be from the transition information so that cannot information supplied by a second we need a generalization of the notion of there exist infinitely many we use to mean that p holds in all but less than i of the states reachable by a hence means that only finitely many of the states accessible via a can fail to satisfy p so if holds in stat then there are only finitely many satisfying ie a has only finitely many transitions possible from this state extended let a l be independent programs then proof to show that the formula holds in an arbitrarily chosen state suppose then that and let v a then since v must be infinite now let u is the universe of states be a function assigning to each element of v an element such that and the construction of v ensures that such an j exists for every f since a for each fv property ii of independent programs ensures f is finally let w a property i of independent programs ensures that a can be for every f j and so the of f ensures so that w must be infinite too but only finitely many distinct states may appear in the first coordinate of w since hence some value of the first coordinate must appear infinitely often in w hence but j so e it is possible to the second of to z but we do not us this fact here there is also a more general statement of the that for other besides co but we do not need this either in addition to the of lemma we need iff proof we prove by induction on n when no the result follows trivially if we now take as our induction hypothesis the result to be proved we get v a u for this part of the proof we express for all n as true so that we can the whole argument within dynamic logic we take n to be a program setting n to a nondeterministically chosen natural number so that n expresses vn clearly we have the argument assumes that a does not itself use n in any way n n n v v now if holds then so does and we are done otherwise if does not hold ie holds then we must have a n a lemma li a a n infinitely many natural numbers true n mn an am thus we have n a but this is of the form so applying lemma lk we get acknowledgments the early stages of our about nondeterminism which finally led to the formulation of dl were strongly by numerous discussions with who has also on various parts of the paper supplied the idea behind the rule of w dijkstra pointed out an error in a previous version of section we have received valuable feedback from r meyer references semantics and termination of nondeterministic recursive programs n automata languages and programming edinburgh s recursive programs as predicate transformers proc conf on formal specifications of programming constructs st aug s k and r t strong verification of programs ieee trans software engineering se t sept r rm program proving as hand simulation with a induction ifip s dijkstra e w guarded commands and formal derivation of programs cacm no s dijkstra e w a discipline of prenticehall fischer mj and rl propositional modal logic of programs proc th ann acm symp on theory of computing may c the application to systems stanford science department report cs of theorem proving university computer d completeness in logics of programs submitted for publication d on the of regular deterministic programs a unified survey submitted for publication d complete axiomatization of properties of programs submitted for publication c d ar meyer and vr pratt and completeness in logics of programs proc th ann acm symp on theory of computing may d a pnueli and j a complete axiomatic system for proving about recursive programs proc th ann acm symp on theory of computing may ce description and theoretical analysis using of a language for proving theorems and manipulating models in a robot mit al lab tr hoare car some properties of nondeterministic computations the univ f logical rules of natural reasoning about programs in automata languages and cd s and r edinburgh university press manna z second order mathematical theory of computation proc nd ann acm symp on theory of computing s manna z and a pnueli axiomatic approach to total correctness of programs acts informatica s manna z and r better than always program correctness proc nd int engineering oct is sometimes assertions in proving conf on software meyer ar equivalence of dl dl and for regular programs with array assignments unpublished report august rc programs computer uk an approach to the semantics of parallel science dept university of edinburgh pratt vr considerations wr hoare logic th ieee symposium on foundations of computer science oct j wp predicate transformer recursion and termination i r publication n a formalized algorithmic sci sci math s languages vol no wand m a characterization or weakest preconditions wang a an axiomatic basis for proving total correctness of programs bit wa augmented transition networks for natural language analysis report no cs to the nsf aiken computation laboratory university cambridge 