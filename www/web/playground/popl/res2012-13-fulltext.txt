constraints as control ali school of computer and communication sciences ic institute of technology abstract we present an extension of scala that supports constraint programming over bounded and unbounded domains the resulting language kaplan provides the benefits of constraint programming while preserving the existing features of scala kaplan constraint and imperative programming by using constraints as an advanced control structure the developers use the monadic for construct to iterate over the solutions of constraints or branch on the existence of a solution the constructs we introduce have simple semantics that can be understood as explicit enumeration of values but are implemented more efficiently using symbolic reasoning kaplan programs can manipulate constraints at runtime with the combined benefits of typesafe syntax trees and firstclass functions the language of constraints is a functional subset of scala supporting arbitrary recursive function definitions over algebraic data types sets maps and integers our implementation runs on a platform combining a constraint solver with a standard virtual machine for constraint solving we use an algorithm that handles recursive function definitions through fair function unrolling and builds upon the art smt solver z we evaluate kaplan on examples ranging from enumeration of data structures to execution of declarative specifications we found kaplan promising because it is expressive supporting a range of problem domains while enabling execution of programs that do not rely on constraint programming categories and subject descriptors d programming languages language constructs and features general terms design languages keywords constraint programming satisfiability modulo theories executable specifications scala embedded domainspecific languages nondeterminism introduction modern programming languages incorporate advances in memory safety type systems and modularity however the sequential control in widely used systems remains largely unchanged compared to some of the imperative and was supported by the national science foundation grant permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm functional language designs although this simplicity has advantages in terms of compilation it prevents languages from the abstraction level used in software design in design we often a conjunction of multiple orthogonal requirements that we need to meet simultaneously when multiple requirements each of them needs to be a partial specification of possible executions otherwise the conjunction would be the to use partial constraints leads to nondeterministic specification constructs examples include guarded commands languages intermediate verification languages temporal logic of actions as well as models in proof coq and in contrast to specification languages most executable languages have difficulty in implementing a conjunction of programs their sequential commands specify the set of possible behaviors the idea of logic programming is to allow programs that are nondeterministic and specify relations predicates between values the original from a restricted form of resolution as the execution mechanisms which uses unification of logical variables ranging over finite trees functional logic programming extends logic programming with the narrowing technique and with benefits of functional programming constraint logic programming clp and later of prolog extend logic programming with the ability to perform constraint solving not only over trees but also over numerical domains these hold great to raise the abstraction level of software they are related to program synthesis research which can be viewed as a compilation mechanism for declarative specifications we believe that key preventing use of nondeterministic declarative programming constructs include · the difficulty of solving declarative constraints and · the difficulty of these constructs into existing languages and platforms we next briefly outline the approach that our system uses to meet these challenges efficient with existing platforms in this paper we present kaplan a system that supports constraint programming on top of the scala language we address the difficulty of into existing platforms by choosing not to modify the semantics of the core scala language but instead use the flexibility of in scala because present a syntax for monads in scala this aspect of our approach is related to using nondeterminism monads in haskell an important difference is that our starting language is not purely functional but can have side effects our solution is therefore to identify a functional for constraints and use it locally for declarative programming within the full scala language which has features of objectoriented imperative and functional languages the declarative control that we explore is based on describing iterations as a search process the iteration ranges are specified as the set of solutions to constraints our constraints are declared using firstclass functions and familiar combinators such as from a language point of view the integration is because users need to learn any new notation one approach to implementation of nondeterministic languages is to implement a virtual machine that supports backtracking such as abstract machine for prolog or the java model checker and its extensions unfortunately such an approach is costly in terms of both performance and engineering effort we propose instead to any need for backtracking into a that iterates over solution spaces in addition we allow constraint programming in code outside of loops in such cases logical variables and a constraint store help ensure that a program can find a solution without backtracking over the host imperative program keeping backtracking within a specialized constraint solver efficient solving of declarative constraints the first implementations of declarative algorithmic advances of modern sat solvers the advances in sat led to a paradigm shift in solving combinatorial problems where it often to constraint solving tasks to implementations instead of relying on a programmer to a search strategy by the developments of sat solvers a more expressive technology as the field of satisfiability modulo theories smt with a number of efficient implementations available smt techniques combine sat solvers with decision procedures and their combination methods that were and remain motivated by program verification tasks our aim is to the progress in constraint solvers by an smt solver as a part of the runtime of a programming language whereas the developers of prolog were by the theorem proving technology of their time resolution for firstorder logic we aim to explore the potential of smt the fact that smt solvers were developed to model programming language constructs makes them a particularly appropriate choice however the original motivation for smt solvers was program verification whereas we aim to use them as an execution mechanism for declarative constraints many logical theories are supported by modern solvers including algebraic data types uninterpreted functions linear arithmetic and arrays nonetheless we believe that constraint solving can reach its full potential only if users can define their own classes of constraints we therefore choose to work with a solver for a rich logic in which users can define their own recursive functions and recursive data types we thus performance and decidability for greater expressive power and flexibility contributions this paper makes a concrete and implemented proposal for constraint programming into an underlying stateful language through several individual contributions · firstclass constraints which can be generated at runtime and which carry type and information the constraints can use unrestricted operations on booleans including negation as well as builtin and userdefined recursive operations on integers sets maps and trees · a programming model for constraint programming based on creating and over a stream of solutions of a constraint using explicit control constructs our programming model unlike most solutions with virtual machines has no for the code that does not use constraint solving · logical variables of numeric and symbolic types that constraint solving steps often substantially reducing the size of the search space · the use of fair function unrolling and smt solving technology to provide expressive power and efficiency of solving in many domains of interest · implementation of the system kaplan is available from · evaluation of the system on examples from several domains such as executing specified data structure operations software testing and construction of functions of a given template and a given specification paper outline the rest of this paper is organized as follows the next section presents features of kaplan through an extensive set of examples section presents in more detail the language that we use to describe constraints section gives the semantics of key kaplan constructs section main implementation aspects of kaplan we present further evaluation and illustrate use cases of kaplan in section we finally review the remaining related work and conclude examples and features we present some of the features of kaplan through examples the simpler examples can be tried out directly in a scala provided that it is with the kaplan throughout the paper we assume basic with scala but explain more advanced concepts and constructs as needed firstclass constraints val c x int y int x y x y this first command declares a constraint with two free variables note that the representation of the constraint is a lambda term the only difference between a declaration of a constraint and an anonymous function is the type of the expression as an alternative to explicitly the value to be of a constraint type one can also append to the function literal a method call c so the following declaration is identical to the previous one val c x int y int x y x y c the type of c is in this case determined by type inference and this second way is generally in kaplan constraints are in fact extensions in the objectoriented sense of functions and can thus be evaluated given some values for their argument variables scala c result false scala c result true as is common in lambda calculus the names given to the bound variables play no role the constraint x int x is equivalent to the constraint y int y one should think of constraints being defined over typed de bruijn indices rather than named variables constraints can be for a single solution or for a stream of solutions by calling appropriate methods scala result scala result nonempty iterator the solve method computes a single solution to the constraint while returns an iterator over all solutions the iterator computes and returns solutions on demand as a result of the iterator in the a search for the first solution is when the set of solutions is finite one can compute it for instance as follows scala result list the most general way to iterate over solutions is using a constraints are firstclass members of kaplan and can be created and manipulated as such the following function for instance generates constraints describing an integer within bounds if the second argument is true the bounds are given by m m else by m def int boolean true val basis x int x m basis x int x m else x int x in this example is a call to a method defined as part of constraint classes and which expects as argument a constraint of the same arity and with the same types of parameters as the receiver this ensures that constraints can only be combined when the number and the types of their de bruijn indices are compatible note that thanks to type inference we need not explicitly state that the two anonymous functions represent constraints we can now use the function bounded to produce constraints scala bounded result list scala bounded result list another convenient constraint combinator is the product method which combines two constraints into a new one whose solution set is the cartesian product of the original two scala bounded true product result list constructing constraints using combinators is a very concise way to solve general problems for instance consider the problem of solving a sat instance defined in a way similar to the standard format where the input val p seq seq represents the problem x ¬x ¬x x x x ¬x ¬x the following function defines a solver for such problems def val id val i m mid find note that in this case we used the find method on the final constraint rather than solve they provide the same functionality but find returns its result in an option type where none corresponds to an constraint while solve an exception if the constraint has no solution another observation is that we use here a constraint over a single variable of map type to encode a constraint over an unknown number of boolean variables we found this to be a convenient pattern when the more syntax of anonymous functions with explicit variable naming does not apply because all variables are of the same type the approach works in our typesafe framework we can now solve sat problems scala result true false false false scala seq seq result none ordering solutions as illustrated by some of the previous examples the method generates solutions in no particular order this corresponds to the intuition that it the unordered set of solutions to a constraint similarly the semantics of calls to solve or find are simply that if a value is produced then it is an element of that solution set two invocations of solve on the same constraint may or may not result in the same solution it is sometimes desirable though to enumerate solutions in a defined order to this end kaplan constraints support two methods and these methods take as argument an objective function just like constraints objective functions are represented using an anonymous function in this case one that returns an integer the and methods ensure that the de bruijn indices types match those of the constraint from the users point of view these functions are typed as consider the problem given a maximum weight and a set of items each with an associated value and weight find a subset of the items for which the sum of values is maximal while the sum of weights is less or equal to the maximum the following code produces and solves an instance of the problem where the solution is represented as a map from the item indices to booleans indicating which should be def weights max int def val vi pair m v else i val val val answer x int x solve we briefly explain the code a solution to a instance is a map indicating a choice of which objects should be the function builds from a list of integers an integer term parameterized by a choice map and representing a sum of values the map defines whether each element in the list or not to the sum we use this function twice to produce the two terms that given a choice of items encode the total value and the weight respectively observe that we build the final constraint using a function composition we start the construction of the constraint as x int x max and compose it with the weight term to produce the constraint that the weight should not the maximum function composition is a general and typesafe way to build constraints from smaller terms as demonstrated the relationship from an implementation point of view between constraints and terms is explained in more details in section in this example we can now find optimal choices for instances of the problem scala val list scala val weights list scala val max int scala weights max result map false true true true true userdefined functions and datatypes an important feature of kaplan is the ability to perform constraint solving in the presence of userdefined functions and data types consider the following functions which compute for a × matrix a c b d represented as a b c d its and whether it is respectively spec def int b int c int d int int ad bc spec def int b int c int d int boolean val dt b c d dt dt the spec annotation indicates that the user to use the functions as part of constraints and the kaplan compiler enforces that such functions are written in the subset of scala supported within constraints see section we can now characterize matrices with small elements as def int val b false b product b product b product b this function also illustrates the use of postconditions written in scala as anonymous functions in an ensuring clause in this case the postcondition states that the result of size can never be negative such annotations can help the constraint solver discard parts of the search space kaplan uses the verification system to prove at compile time that the annotations are valid so that it can then rely on them at runtime for constraint solving we can similarly define recursive functions that compute whether a tree contains sorted keys or has the right coloring properties in the interest of space we omit the complete definitions spec def tree boolean spec def tree boolean spec def tree spec def tree min int max int boolean we expect that what these functions compute is clear from their name with them we can for instance count the number of trees with a given number of elements scala to yield t tree i i result list more advanced applications of data structure enumeration are presented in section including generation for sorted list and tree the language of constraints supported in kaplan is very expressive for that reason one cannot expect that any constraint will be solvable as an example given the definition valid in kaplan the after indicates to the scala compiler that it should apply an conversion to produce an anonymous function and ultimately a constraint from the definition we can use these new definitions to generate matrices scala result list perhaps more interestingly the spec functions can be mutually recursive as an example consider the following declarative definition of prime numbers spec def int j int boolean from j j from j spec def int boolean i i val int xint which we can subsequently enumerate spec def int y int int else x y it would be to expect the system to find a solution to the constraint val x int y int z int b int b the search algorithm at the core of kaplan is a procedure if a solution exists then that solution will be found eventually if there are no solutions the procedure can discover this fact and stop or loop forever the solve find and methods all take a parameter describing the timeout strategy that parameter is optional so by default no timeout is used because it is also implicit a timeout strategy can be defined for an entire scope by a single definition that the scala compiler then automatically inserts at each call site scala result list kaplan users can also define their own recursive data types also known as algebraic data types the following code declares two such types for trees spec abstract class color spec case class black extends color spec case class red extends color spec abstract class tree spec case class color l tree v int r tree extends tree spec case class leaf extends tree algebraic data types are best manipulated using recursive functions and patternmatching kaplan supports such function definitions spec def tree int tree match case leaf case node l r result implicit val timeout given the above declarations the following attempt to last theorem results in an exception after second scala result no solution after seconds at at logical variables all the examples so far have illustrated eager solution enumeration where solving constraints immediately produces concrete values while this by itself is a convenient facility much of the power of constraint programming in general and of kaplan in our case comes from the ability to produce logical variables which represent the of a solution logical variables in turn can be used to control the execution flow of the program in novel ways we start by describing some of their basic properties more advanced examples of programming with logical variables follow in kaplan logical variables are always produced as the result of solving a constraint this is done by calling or instead of solve find or respectively consider the constraint we defined earlier val c x int y int x y x y c we produce logical variables representing a solution as follows scala val xy result ll notice that the result is not a pair of integers as in the case of solve but a pair of objects of type representing the of integers the question mark indicates that the value has not yet been fixed logical variables in kaplan have semantics meaning that a given logical variable will always represent the same concrete value even when it is copied or passed as an argument to a function the identity of a logical variable is determined by the identity of the instance of the l class the value of a logical variable is fixed as soon as it is which can be done with the value method scala result scala result ll note that even though the y can at this point only hold the value the solver has not necessarily detected that the solution is unique and thus still considers the value not to be fixed a value needs not always be done explicitly the kaplan library defines two implicit conversions between concrete and logical values implicit def lt t lvalue implicit def t lt new the first one simply the value whenever a function expects a concrete value and receives a logical variable the second one converts a concrete value into a specialized representation of a logical variable it is used to provide a common representation for concrete and logical values because kaplan is built as a layer over scala and most code must execute as usual we cannot to treat every value as logical instead users decide which function can handle logical values by using l types in their signature because concrete values can be lifted to logical status such functions work with standard and logical variables logical variables created through this lifting mechanism are treated and do not add any complexity to the solving process imperative constraint programming scala being a language users can alternate between different programming depending on their and on the task at hand the same is true for kaplan while eager solution enumeration is best used within functional style logical variables can be used rather naturally in an imperative style thanks to novel control constructs the kaplan library defines the branching construct it is similar in nature to ifthenelse except for an important difference rather than strictly evaluating the branching condition blocks check whether the condition is feasible and if so constrain the logical variables in the environment so that their values satisfy the branching constraint if the condition contains no logical variable or only logical variables that have already been fixed then behaves exactly like ifthenelse as an example consider the classical that consists in finding distinct values for the letters representing in the following addition such that the sum is valid s end e m o we now present a solution in kaplan written in an imperative style val x int val letters this second line uses patternmatching syntax to achieve two things at once the letter variables are bound to independent lazy representations of a solution to the trivial constraint and the variable letters is bound to the sequence of all letter variables at this point we have unconstrained integer logical variables we can add constraints letters l if this loop terminates without any error then at the end of it the variables each represent a number between and calling is equivalent to otherwise error just like is conceptually at least equivalent to else error more details are given in section we further constrain the letters representing m we can now perform symbolic arithmetic using the existing and new logical variables we define a new variable for the sum of each line and constrain it to the expected value val s e n d val m o r e val total m o n e y at this point the value of the letters is still not fixed however kaplan ensures that all variables admit solutions satisfying the constraints finally we check for a solution to the using one last block scala assuming total value otherwise has no solution result solution list we mentioned that is conceptually close to ifthenelse and in fact equivalent in the absence of logical variables one important difference is that the construct is while else is equivalent to else the same transformation cannot be applied to blocks indeed the semantics are that the control will attempt to satisfy the branching condition so whether the positive or negative condition is tested has an impact on the rest of the execution section discusses the implementation of blocks in terms of int t boolean t t t t t t t t t t t t t t t t abstract class c c t case class cn d extends e c t dt et figure inductive definition of types where set and map are the types defined in the package constraint in this section we describe the subset of scala in which we can specify constraints in kaplan and which we call is an extension of the language supported by the available verification system since it is a subset of scala the language is executable and deterministic language data types figure presents an inductive definition of the data types supported in an important feature is the ability to define recursive algebraic data types in scala these types are defined using a hierarchy of special case classes algebraic data types are typically manipulated with patternmatching as shown in some of the examples in section a current limitation is that these userdefined types cannot take type parameters the map type represents finite immutable maps which can thus be viewed as partial functions because it supports unbounded data types and arbitrary recursive functions the constraint language is itself this can be viewed both as an advantage and an on one hand this expressive power guarantees that just about any constraint is expressible but on the other hand standard incompleteness theorems predict that some constraints cannot be shown to have no solutions in practice we have found that constraints that come up in programming tasks such as the ones presented in this paper and in the context of functional software verification as opposed to hard ones are handled well expressions and function definitions expressions can contain all standard arithmetic operators map applications and updates set operators and membership tests function applications of userdefined or anonymous functions and constructor and selectors from userdefined data types expression can also contain to factor out common subexpressions indeed a scala block val x e val xn en e is to be understood as let x e in in let xn en in e expressions can contain patternmatching on userdefined data types any can be bound to a variable and used accordingly on the righthand side of patterns furthermore patterns can contain arbitrary guards at compiletime kaplan relies on to prove that patternmatching expressions are exhaustive and thus rules out any possibility of a runtime match error in spec functions this check goes beyond the capabilities of the standard scala compiler in that it takes into account the path conditions leading to the match expression a function body is defined by a single expression whose free variables are the arguments of the function functions can be annotated with a postcondition which can in some cases help the runtime constraint solver these postconditions are proved at compiletime just like the patternmatching expressions kaplan can thus be used purely as a verification system and therefore strictly subsumes solver kaplan invokes core solving procedure both at compiletime to validate postconditions and prove that patternmatching expressions are exhaustive and at runtime to find solutions to constraints the procedure is based on a refinement loop that expands function definitions in a fair way to guarantee that no valid solution is ever ignored one can think of this search procedure as a form of bounded modelchecking for functional programs we have found that in practice it is fast in finding counterexamples the details of the procedure are presented in conceptually is the only solver used in the implementation of kaplan because it is built as a layer on top of z though we will sometimes refer to z directly when we discuss implementation details in section in particular in the absence of userdefined recursive functions behaves exactly as z semantics in this section we present an overview of the semantic aspects of kaplan through operational semantic rules shown in figure all features of kaplan can be implemented in terms of the two constructs find and as well as conversions between concrete values and logical variables denoted by l section describes how to use the host language scala to reduce other constructs including solve to this core a state consists of a triple expr µ where expr is the expression under evaluation µ encodes the part of the state that is proper to scala and is a constraint store a constraint store is conceptually a formula whose free variables correspond to all logical variables used since the beginning of the computation the host rule captures the intuition that in the absence of invocations to the constraint solver kaplan behaves exactly like scala we assume the existence of a transition relation h describing the execution of normal scala code and which is lifted to kaplan through the host rule as one would expect applying such transitions leaves the constraint store unchanged the rules and describe the possible results of an invocation of find the simplest form of constraint solving we use xx to denote a constraint that ranges over the variables x and that does not refer to logical variables by m we denote a map from variables to constants the condition m denotes that m is a valid model of ie a mapping of variables x of to constants such that x mx holds examining the rules for find and we note that find has no impact and no dependency on the constraint store which is consistent with its eager semantics the rules and for are analogous but with crucial differences logical variables can be present in the constraints to solve which we therefore denote xx l and the rule does not produce concrete values but rather fresh logical variables the lift rule applies whenever a constant value needs to be used in place of a logical variable conceptually it adds to the constraint store a new logical variable whose value is immediately constrained to be the constant finally the value rule specifies how concrete values can be extracted from a satisfying assignment t µ h t µ host t µ t µ m µ µ m µ none µ m x lf lf fresh in xx µ µ x lf m x lf lf fresh in xx µ none µ m value lvalue µ ml µ l ml c is a constant lf fresh in lift µ lf µ lf c figure smallstep semantics of constructs model for the constraint store observe that when the rule applies the value of the logical variable is then fixed for the rest of the program execution by the added equality to this ensures semantics in any execution trace all applications of the value rule for a given logical variable l will produce the same value a different value would the premise that m is a valid model for the store we now show that execution never gets stuck in one of the rules because we are examining the behavior of our constructs taking a constraint solver as a parameter we ignore termination properties of the constraint solver and assume that the outcome of the constraint solver call denoted becomes immediately available to test the applicability of a rule theorem suppose the constraint store is satisfiable in the initial state and that the h relation is total then the transition relation given by figure is also total proof the case of host is clear from the hypothesis that h is total for evaluations of find we observe that the rules and have complementary premises and therefore one of them necessarily applies similarly for and are complementary regardless of the value of lift has no precondition so it remains to show that value cannot get stuck ie that it cannot be the case that there is no model m for the constraint store using the assumption that in the initial state the constraint store is satisfiable it is sufficient to show that no transition will make it unsatisfiable observe that only three rules affect the constraint store value lift and the addition of the equality lf c in lift clearly does not affect satisfiability because lf is fresh similarly the addition of l ml in value preserves the model m by definition finally is guarded by a satisfiability check on precisely the next state of the store so the model obtained in the premise is a valid model for the next state the proof suggests an implementation strategy preserve at all times the constraint store a satisfying assignment when is applied cache the model m obtained from the satisfiability check when lift applies augment the model with the appropriate value for lf finally to apply value use m from the cache it is not hard to see that this strategy is a valid refinement of the presented rules and it is in fact the strategy we have implemented in kaplan as explained in the next section implementation we implemented our extension to scala as a combination of a runtime library and a compiler both implemented in scala in this section we present the implementation aspect of these parts along with the interaction with the underlying smt solver z runtime library firstclass constraints in kaplan firstclass constraints are implemented as a hierarchy of term classes as shown in figure the base term class represents a lambda expression and is parameterized by its argument types and return type a constraint is simply a term instance where the return type is instantiated as boolean we define subclasses of term for each arity generating them automatically as it is the case for the tuple and function definitions in the scala library the base class defines methods common to terms of all such as the solve find and methods for constraints we ensure that these methods are only applicable when the return type is boolean by it using an implicit parameter we use the same technique to guarantee that term instances are combined in a fully type safe way we use the c method to trigger an implicit conversion from lambda expressions to term instances each term subclass extends the corresponding function class in scala and uses the original scala code for the lambda expression to define function application these classes define optimization methods and to obtain optimization constraints the implementation of the optimization procedures is discussed later in this section the creation of terms from scala lambda expressions relies on compiletime transformations the transformations are implemented in a for the scala compiler we describe how the compiletime transformations work in section logical variables in kaplan logical variables are instances of the l class which is parameterized by the type of the symbolic value that it we define classes that extend the iterator of scala and that enumerate tuples of l values we discuss the implementation of logical variables in section the construct we can define the construct naturally at the library level in kaplan it down to checking the satisfiability of a constraint of arity and can therefore be implemented in terms of figure shows the code for this construct in kaplan the assuming block creates an assuming instance we rely on the implicit conversion mechanism abstract class self def r boolean def r boolean t new def r boolean def r boolean this class extends with class extends with class extends with def other implicit r boolean def other implicit r boolean def unary implicit r boolean def def def def def implicit r boolean def implicit r boolean def implicit r boolean type type constraint type figure term class hierarchy of scala for implementing the construct if the optional otherwise block is not defined the type checking phase will insert a call to which will trigger a conversion from the assuming instance to the value it there exists a difference in the treatment of the optional second part of the builtin ifthenelse construct and our library extension for without an optional else block an if block is always as unit this is built in in the scala compiler we cannot achieve the same effect with without making deep changes to the compiler so in our case an assuming block will throw an exception at runtime if the following three conditions occur the assuming test fails no otherwise block is defined and an expression of a type different from unit is required scala compiler the compiletime transformations of kaplan programs include the following def a val v match case some case none none new final class def a a match case none case tr implicit def a match case tr case none throw new block not defined figure implementation of in terms of extracting userdefined specification functions and algebraic data types generating methods to allow conversion between values of these data types and their representation in our solver transforming implicit calls to conversion methods in order to instantiate term instances these transformations are implemented as a compiler that a compiler phase that follows the type checking phase functions and classes that carry the spec annotation are expected to be in the constraint presented in section alternatively developers can group these specification functions and data types in annotated scala objects instead of annotating each of them these specifications are extracted during compilation to obtain a representation that we use in solving in addition method definitions are generated and inserted into the code in order to convert between these types and their representation we rely on the scala compiler to signal to us the locations where a function literal needs to be lifted to a constraint literal the type checking phase which runs before ours does so by surrounding such function literals by a call to an implicit conversion function these functions are defined in the kaplan library but have no implementation they simply serve as a guide to indicate to the type checker that the conversion is legal the effect of compiling code written for kaplan without the kaplan is thus that all constraint manipulation operations result in a runtime exception implementation of the core solving algorithms our implementation the smt solver z through its extension in the following we refer simply to z as the algorithms we cover in this section would remain the same if we used z alone what we gain by using is the additional expressive power of recursive functions within constraints we now describe the interactions with the solver that allow us to put into practice features such as enumeration minimization and logical variables solution enumeration find and are used to implement and respectively through the use of an iterator def tm solve match case sat m model m v tm pivot v lo null hi v while lo null hi lo solve tm pivot match case sat m model m if lo null pivot pivot pivot × hi pivot else lv tm pivot lv pivot lv hi pivot case pivot pivot hi pivot lo pivot return sat model case return null figure of the solving algorithm with minimization we invoke our base satisfiability procedure via calls to solve the iterator maintains a constraint at all times starting with the original one each time a new solution is required the iterator updates the constraint by adding to it the negation of the previous solution thus ensuring that all following solutions will be different to make this process efficient kaplan relies on the incremental reasoning capabilities of z and thus to avoid solving the entire constraint each time the implementation of is conceptually identical with the difference that it returns logical variables instead of concrete values these logical variables are constrained in the store to be for an enumeration using to terminate must therefore prove that the constraint has finitely many solutions optimization constraints our procedure for optimizing a constraint with respect to an objective function can be seen as a generalization of binary search over the range of values that the objective can take let us consider the case of minimization the procedure is analogous the for the algorithm can be seen in figure it starts by to find a satisfying assignment for the constraint it then repeatedly looks for a model in which the objective is smaller than the last satisfying value by exponentially increasing the difference until a lower bound is found it further reduces the interval until the optimal value for the objective is found the procedure maintains the invariants that lo is always less than any satisfying assignment to tm and there always exists a satisfying assignment to tm which is less than hi ordered enumeration having defined the solving procedure that a given term we can now compose it with solution enumeration to obtain ordered enumeration we present in figure we use for clarity but it is not hard to see that it can be implemented using only standard scala along with find or def tm match case sat m vm tm tm vm tm vm tm case return figure of the ordered enumeration algorithm a recursive algorithm that will enumerate solutions to ordered by the value of tm which should be in this we use to get an iterator of all values satisfying the given predicate and to iterators handling logical variables we use a global context to keep track of the constraints associated with logical variables given a logical variable l and the constraint cl associated with it we create a guard a boolean literal gl denoting the liveness of the logical variable ie whether its value has not been fixed yet throughout the execution we maintain in the global context the set of guards that are still upon creation of the variable l we add gl to the set of variables and we assert cl guarded by the disjunction of all the guards in the set g defined as the set containing gl and the guards associated with all the logical variables that appear in cl g cl gg the reason for considering the guards associated with the other logical variables is to ensure the single value semantics of these consider the following simple example that illustrates the situation for x x int x x val y y int y assuming x first block assuming y second block in each iteration of the outer if the first block is entered we do not want to enter the second one as this would violate the single value semantics for the variable x since the constraint y x will be enforced as long as either x or y has not been fixed the conflicting situation is correctly avoided in the terminology of section gl denotes whether the value rule has been used for l true means it has not cl is the constraint on which was applied to introduce l into as part of lf and the logical variables represented by the set of guards g are those that to the constraint the l variables in note that using individual guards for logical variables is not required by the semantics but rather is an optimization that allows us to reduce the size of the constraint store when some values become known when the value vl of the variable l is set we remove gl from the set of guards and we assert the following l vl when all of the literals a constraint cl are removed from the set the formula gg g cl that was becomes trivially true and the constraint can be discarded by z another source of optimization is that we the method of the l instances such that even if their value is never fixed their guard is removed from the set of variables when they are being considered for garbage collection by the jvm this example first examples matrices sat solving prime numbers all trees up to nodes time s figure evaluation results for the examples presented in section is again not strictly speaking required by the semantics but helps reducing the overhead of tracking all logical variables invocations of the solver we summarize this section by presenting a list of all the places where an invocation of the solver occurs · calls to find as they search for a solution · calls to as they check whether a satisfying assignment exists for logical variables · calls to the method of the iterators returned by calls to and which are then translated into calls to find and respectively and · evaluation of the constraint of assuming blocks as they indirectly invoke the solver by invoking on the constraint note that as the proof in section suggested calls to the value method of logical variables do not trigger a solver invocation advanced usage scenarios and evaluation in this section we present an experimental evaluation of our constraint programming system by considering a number of examples as a first overview of the performance of our implementation we present the running times for the examples that were introduced in section the results of our evaluation can be seen in figure we observe that most problems are solved almost with the exception of the tree enumeration we discuss the difficulty of data structures satisfying an invariant in the subsequent examples data structures for testing one use of the construct consists in data structures that satisfy given invariants this is a problem that has been studied previously and was motivated by subsequent work presents a language with nondeterministic choice operators that can be used for linked data structures we describe our experience in using kaplan to enumerate functional data structures to find input values that violate function contracts we consider a functional specification of trees we enumerate solutions to function preconditions and check whether the postconditions hold as in we enumerate the data structures while bounding the range of values than can be stored in nodes a tree is a binary search tree characterized by the following additional properties each node is either red or black all leaves are black both children of every red node are black and every simple path from the root to any leaf contains the same number of black nodes the first method we consider is balance which defines one of the cases to duplicate one of the subtrees and another while the tree this results in the postcondition of the add method as the result tree does not have the expected content in this case an example the postcondition is found after trees our test list size time s figure evaluation results for declarative last method consists of trees that satisfy the precondition of add and calling the method in the body of the loop we then consider the case where the add method has a missing precondition namely that the tree must be in this case the precondition to a method that is called within add fails and we find a value using a similar after four trees in seconds we argue that a random generation approach would be in such data structures that satisfy complex invariants while the results using constraint solving is not as fast as the specialized solving in we should keep in mind that this is an experiment in using a generalpurpose constraint solving engine the generality of kaplan is in contrast to previously proposed solutions for data structure enumeration which rely on specialized techniques for linked heap data structures or even techniques specialized to a particular data structure in the light of the generality of our technique and the overall difficulty of the problem we consider these to be good results executable specifications as another application of implicit computation we now explore examples that consist of the execution of declarative specifications instead of explicit computation execution of specifications is the approach taken in plan b in which specifications are used as a mechanism upon contract violations consider for instance a function that computes the last element of a given list we can define this function by stating that the input list is equal to some list with the list that has only the element that we are looking for def list int val elem e int zs list nil elem as a more elaborate example consider adding an element to or removing an element from a tree the explicit insertion and removal have to consider multiple cases in order to keep the invariants that trees should satisfy and are known to be to implement on the other hand these methods can be stated in a declarative manner using functions that check if a given tree is indeed a tree along with functions computing the content of the tree as a set def int tree tree tree t tree def int tree tree tree t tree the performance of the above methods is presented in figure we also show the results for the similar case of inserting into and removing from a sorted list note that we essentially the same running times for the problem of sorting a list by for a sorted list of the same content as a given list the above examples show that it is possible to replace the explicit computation for a method by its purely declarative specification even for sophisticated contracts such as the ones on trees the declarative variants are notably slower than the imperative implementations but it is likely to rely on these executable specifications instead of simply when the imperative version violates the contract size list add list remove add remove figure evaluation results for declarative add and remove for trees and for sorted lists size is the size of the structure without the element all times are in seconds as a final example let us consider the implicit computation that gives the integer square root i of a positive integer i this is stated as following def int int res int res res res i res res our implementation can handle numbers as large as of performing under seconds in all cases counterexample inductive synthesis counterexample inductive synthesis is a method for effectively solving constraints using smt solvers such constraints are particularly important for program synthesis identified as the class of synthesis problems in the counterexample approach for this problem was successfully applied to software synthesis in the algorithm for combinatorial using sat solvers this technique was later applied with an smt solver as the satisfiability engine to synthesize code fragments the technique starts by choosing some initial set of values for the universally quantified variables then solving the constraint for the existentially quantified variables if the values for the existentially quantified variables work for all values of the universally quantified variables a solution has been found otherwise there is a counterexample which is some valuation of the universally quantified variables this counterexample is added to the set of values for universally quantified variables and the procedure is repeated until a solution is found this synthesis loop can be expressed in our system using firstclass constraints as an example we consider the following are there integers a and b such that for every integer x a · x b · x in kaplan we can describe the approach as in figure when executed the program finds correct values for a and b in two iterations of the loop the output of the program is initial x candidate parameters a b counterexample for x candidate parameters a b proved the example generalizes to arbitrary constraints which in this example are and keeping the same simple structure note that we here explicitly constructed stronger firstclass constraints we can instead use logical variables and incrementally augment the constraint store var continue true val x int def int a int b int a x b x def int b int x int a x b x var while continue match case b parameters a a b b match case none continue false case for x ce case none prove property continue false figure counterexample inductive synthesis in kaplan list size time in kaplan s time in curry s figure evaluation results for functional last method comparison to other systems providing a fair comparison of running times of kaplan against systems is difficult because kaplan covers many areas for which specialized tools have been developed we do not expect to match performance of each of these specialized systems at the same time there is no single system that subsumes kaplan this section illustrates how other tools can solve some of the problems we presented in this paper and solved using kaplan the running times should not be taken as a statement of the relative of the systems but rather as a guide to understanding key differences of the underlying constraint solving techniques last element of the list we first compare the performance of kaplan and curry on computing the last element of a list both in a declarative way as presented in section and as a functional method in curry the declarative version can be expressed as last xs ys x xs x where free the performance of the curry implementation the performance of kaplan that we reported in figure running under seconds in lists of size up to however in kaplan we also have the freedom of writing the constraint directly as a functional program in such style curry performs at about the same speed as for a definition so kaplan curry on longer lists figure shows the evaluation results for this case it is of course the scala compiler and the java virtual machine that take credit for the good performance of the functional implementation to the credit of kaplan is simply that it does not lose any of this underlying efficiency this basic consequence of kaplan design is very important from a practical point of view in principle a static analysis could be used to recognize among logical constraints special classes that do not require constraint solving consider for example mode analysis of however this approach clearly requires significant compilation effort to merely recover the performance of a functional or imperative code whereas in kaplan it follows by construction generating data structures with complex invariants we now report on our experience in comparing kaplan with for generating trees results were similar for sorted lists is a tool for producing test cases using random test generation similar to for haskell we implemented basic generators for lists and trees using generator combinators in the problem with random generation is that for many classes of properties the probability of a random structure satisfying it may tend to zero as the structure size grows making test cases for larger structures to see this in practice consider first our own performance figure shows that kaplan takes seconds in total to generate all trees of size n containing elements to n for all n from to we therefore defined a basic generator that with equal probability generates an empty or a nonempty tree we ran it for seconds generating trees although of all of them were that is because were in fact empty of the rest had size one size two and there were no trees of larger size in this experiment we gave both kaplan and only the constraints without any additional insight which makes the comparison fair users could write better generators but they could similarly write better kaplan checkers like kaplan supports a full of intermediate approaches where one puts more attention into either writing better generators to increase the ratio of valid or into manually the implicit computation to reduce the search space constraint satisfaction problems tools for constraint solving and optimization over finite domains have developed somewhat independently of smt and the related our experience suggests that for problems of size over finite domains the two yield comparable results a full experimental comparison between the state of the art of these two is beyond the scope of this paper note that we could incorporate into kaplan solvers from either class as long as they support our domains of interest including for example algebraic data types related work existing languages functional logic programming the functional programming and logic programming into a single language functional logic languages such as curry benefit from efficient demanddriven term reduction strategies proper to functional languages as well as nondeterministic operations of logic languages by using a technique called narrowing a combination of term reduction and variable instantiation instantiation of logic variables occur in constructive steps only to computation when a reduction needs their values the performance of nondeterministic computations depends on the evaluation strategy which are formalized using definitional trees applications using functional logic languages include programming of graphical and web user interfaces as well as providing highlevel for accessing and manipulating databases our work can be seen as the practical experiment of building from existing components a system close in functionality to curry we by extending an existing language while preserving its execution model rather than starting from as such we lose the of a total integration of for instance users of kaplan need to specify which functions can handle logical variables on the other hand such a separation of features comes with benefits we can readily use the full power of z and the verification system for constraint solving and the execution efficiency of the java virtual machine for regular code implementations of functional logic languages on the other hand must typically focus on efficiently executing either the logical or the functional components of the code the language and the associated programming system is another combination of multiple with applications in functional concurrent and logic programming in particular supports a form of logical variables and logic programming is enabled through unification one limitation is that one cannot perform arithmetic operations with logical variables which we have demonstrated in several of our examples because unification only applies to constructor terms some of the earlier efforts to integrate constraint and imperative programming in the languages and this line of research put on designing novel ways to define constraints to programming for instance the integration of constraints with objects programmers can define instance constraints that relate various members of an object and constraints can be just like mutable variables constraints are also associated to a once or always specifying intuitively the scope in which they can affect variables kaplan currently does not support constraints over mutable data types and could benefit from the integration of such features the integration of constraints as firstclass members of the language is in kaplan than in any of the languages discussed above for example in curry programmers can define constraints as functions that return the special type success which is not identical to boolean however such functions or rather predicates in curry can only be built from equality predicates and cannot be combined freely while conjunction and disjunction are valid combinators negation for instance is not in kaplan on the other hand any predicate expressed in can be used as a constraint and terms of other types can also be manipulated and composed freely another distinguishing feature of kaplan is the native support for many theories integers sets maps data types that comes from using and z as the underlying constraint solver language design monadic constraint programming constraint programming into purely functional languages by using monads to define solvers the authors define monadic search trees corresponding to a base search that can be transformed by the use of search transformers in a composable fashion to increase performance our system differs from this work in its use of smt solvers for search and a more flexible way of constraints with imperative programming code synthesis techniques have been proposed to turn implicit declarations into explicit code the main limitation of that approach is the requirement that the theory should be decidable we have shown that using a powerful undecidable logic for constraints can be compiletime techniques such as should be combined with the runtime approach of constraint solving the work on uniform reduction to arithmetic proposes a language for specifying constraints it uses symbolic execution to encode problems into arithmetic and invokes one of the underlying and sat solvers the system allows for the comparison of different solvers on examples involving solution enumeration and functional equivalence checking the use of symbolic values in conditional statements and array indexing is not permitted because it uses native enumeration capability of solvers such as it can be faster than our system on some of the benchmarks does not support unbounded domains we are aware of no techniques to enumerate solutions for unbounded domains more efficiently than in kaplan smt as a programming platform the language introduces the idea of using an smt solver to check subtyping relations between refinement types in all types are defined as logical predicates and subtyping thus consists of proving an implication between two such predicates the authors show that an number of common types including for instance algebraic data types can be encoded using this formalism in this context generating values satisfying a predicate is as the type problem and the authors introduce the expression t to that end it is evaluated by invoking z at runtime and is thus conceptually comparable to our find construct but without support for recursive function unfolding we have previously found that recursive function unfolding works better as a mechanism for satisfiability checking than using quantified axiomatization of recursive functions in general we believe that our examples are substantially more complex than the with in the context of the library is our earlier effort to integrate invocations to z into a programming language because it is implemented purely as a library we were then not able to integrate userdefined recursive functions and data types into constraints so the main application is to provide an embedded domainspecific language to access the constraint language of z but not to extend it a similar approach has been taken by others to invoke the smt solver from haskell applications of declarative programming one approach in using specifications for software reliability is data structure repair where the goal is to recover from data structures by transforming states that are erroneous with respect to integrity constraints into valid ones performing local heuristic search uses method contracts instead of data structure integrity constraints to be able to support rich behavioral specifications while the primary goal is to perform runtime recovery of data structures recent work extends the technique for debugging purposes by abstracting concrete repair actions to program statements performing the same actions data structure repair differs from our system in that it can perform local search to modify existing states while we do not currently do so we do not expect that a generalpurpose constraint solving such as ours can immediately compare with these techniques the idea to use specifications as a mechanism as in one of our application examples was adopted in similarly to our setting dynamic contract checking is applied and upon violations specifications can be executed the technique ignores the erroneous state and computes output values for methods given concrete input values and the method contract the implementation uses a relational logic similar to for specifications and the model a related tight integration between java and the engine is presented in in both cases due to the finite bound on the search space a satisfying answer may not always be found which makes the techniques incomplete we have shown that executing declarative specifications is possible in our setting we expect that a constraint solver such as the one in will ultimately be better suited than an approach based on due to the presence of unbounded or large data types such as integers and recursive structures conclusion we presented kaplan an extension of the scala language that constraint programming while preserving the existing functional and objectoriented features of scala the behavior and performance of kaplan is identical to scala in the absence of declarative constraint solving kaplan constraints as firstclass objects in scala and logical variables for solving constraints it allows for solving optimization problems as well as solutions in a order kaplan is implemented as a combination of a compiler and a runtime library and allows users to express constraints in a powerful and expressive logic kaplan relies on a procedure for satisfiability modulo recursive functions to solve these constraints we evaluated our system by considering applications such as solution enumeration execution of declarative specifications generation for and counterexample inductive synthesis as well as numerous smaller yet expressive we observed that our model for introducing nondeterminism using well with scala based on our experience with the z smt solver and the verification system in constraint programming we found that a number of features if supported by solvers could directly bring benefits to constraint programming these include support for enumeration of theory models and solving constraints while a given term overall we believe there is great potential in extending standard programming languages with constraint solving capabilities many interesting problems are left open both in language design and in constraint solving a system such as kaplan that tools from both domains is likely to benefit from progress made in each of them acknowledgments we thank for an interesting discussion on the status of the curry programming language we thank and de for their help in using z and for his help with the scala compiler we thank and the anonymous reviewers for their feedback references h abstract machine a reconstruction mit press s definitional trees in pages ­ s and m functional logic programming cacm ­ k r apt and m constraint logic programming using cambridge university press k r apt j v and a an imperative language that supports declarative programming toplas ­ rj back and j von wright refinement calculus springerverlag t ball d f r and l j white state generation and automated class testing test c and c in cav volume of lncs g m a d gordon c and d e semantic subtyping with an smt solver in icfp pages ­ a y and d kozen a law for logic with a fixedpoint operator inf control october c s and d automated testing based on java predicates in proc international symposium on software testing and analysis pages ­ july b m and m highlevel database programming in curry in pages ­ k and j hughes a lightweight tool for random testing of haskell programs in icfp pages ­ a h and m v last steps towards an prolog in pages ­ r and k r m leino a typed procedural language for checking objectoriented programs technical report microsoft research march b and m c rinard automatic detection and repair of errors in data structures in oopsla pages ­ d g nelson and j b simplify a theorem prover for program checking j acm ­ e w dijkstra guarded commands and formal derivation of programs acm ­ b and l de the smt solver http b and s a tool for complex data structures in pages ­ s fischer o and c purely functional lazy nondeterministic programming in icfp volume pages ­ h g r a and c fast decision procedures in cav pages ­ i p c and i a fast scalable constraint solver in european conference on artificial intelligence pages ­ press m t v s v and d test generation through programming in in pages ­ m and p a constraint imperative programming language in techniques and applications of artificial intelligence s gulwani s a and r synthesis of programs in pldi pages ­ m construction of web user interfaces in pages ­ m and c declarative programming of user interfaces in pages ­ d structuring z specifications with views acm transactions on software engineering and methodology october d a lightweight object modelling notation acm trans ­ j and jl constraint logic programming in popl j c a program verifier phd thesis a s v and p scala to the power of z integrating smt and programming system description in pages ­ r a and d linear resolution with selection function ­ v m r and p complete functional synthesis in pldi pages ­ l lamport specifying systems the language and tools for hardware and software g b and a a constraint imperative programming language in constraint programming pages ­ springerverlag m z j h and s program debugging using data structure repair in pages ­ z manna and r a deductive approach to program synthesis acm trans program lang syst ­ doi f and p uniform reduction to arithmetic in pages ­ e michael curry an integrated functional logic language a d k and d unifying execution of imperative and declarative code in pages ­ c morgan programming from specifications nd ed prenticehall inc l de and n z an efficient smt solver in tacas g nelson techniques for program verification technical report xerox palo alto research center g nelson and d c fast decision procedures based on congruence closure journal of the acm jacm ­ doi n p r s g and g towards a standard cp modelling language principles and practice of constraint programming pages ­ r user guide m odersky contracts in scala in international conference on runtime verification springer lncs m odersky l and b programming in scala a guide press d z and p j mode analysis of in acm sigplan workshop on principles and practice of declarative programming l c t et al theorem prover a pnueli and r on the synthesis of a reactive module in popl a and j programming with and nondeterministic functions in pages ­ h e d and t d back on executable specifications in ecoop pages ­ t p j and p wadler monadic constraint programming j program ­ j p m and k a a new search algorithm for satisfiability in pages ­ a l r s a and v a combinatorial for finite programs in p m and v decision procedures for algebraic data types with abstractions in acm sigplan popl p a s and v satisfiability modulo recursive programs in static analysis symposium sas g constraint propagation models techniques implementation phd thesis university the coq development team inria logical project the coq proof assistant e and d a relational model in tools and algorithms for construction and analysis of systems tacas p van logic programming in with in r n and s data structure repair using in ecoop pages ­ l c f m w and s efficient conflict driven learning in boolean satisfiability solver in pages ­ 