an interprocedural data flow analysis algorithm jeffrey m computer science division university of california berkeley berkeley california abstract a new interprocedural data flow analysis algo rithm is presented and analyzed the algorithm associates with each procedure in a program mation about which variables may be modified which may be used and which are possibly preserved by a call on the procedure and all of it the algorithm is sufficiently powerful to be used on recursive programs and to deal with the sharing of variables which arises through reference the algorithm is unique in that it can com all of this information in a single pass not requiring a to compute calling relation or sharing patterns a lower bound for the computational complexity of data flow information is derived and the algorithm is shown to be asymptotically optimal the algorithm has been implemented and it is practical for use even on quite large programs introduction a great deal of recent research has been to developing algorithms for global flow analysis these methods generally assume that the semantics of individual program statements are available the purpose of global flow analysis is to determine what information is available at specific program statements by propagating the semantics of dual statements through the program in a manner which reflects the control structure in practical applications of global flow analysis such as pro gram optimization verification and documentation subroutine calls appear among program statements the semantic effects of subroutine calls are not generally available traditionally have treated calls as black boxes which terminate the propagation of tion the aim of interprocedural data flow analysis is to summarize the semantic effects with subroutine calls global flow analysis to more effectively propagate mation through programs we will the study of interprocedural data flow analysis with an example code sequence x yz w u v yz research by national grant science foundation whether yz can be considered a common sion depends on the information that can not modify the values of y and z this allows the information is available to be propagated through the call on there are a wide variety of applications for interprocedural data flow analysis some of which are discussed in interprocedural information that is used at the point of call of a subroutine has been called data flow information with each function call a summary of the variables that may be modified that may be read and that are preserved will be useful for intraprocedural analysis precise definitions for these three data flow problems will appear in the section on notation and problem definition there are three fundamental difficulties with summary information in order to summarize a procedure examined if p calls another p its procedure body is q then the flow analysis of p requires a summary of q in nonrecursive programs there is some ordering in which procedures can be examined which has the pro that called subroutines are always analyzed in advance of the procedures which call them this ordering has been called the reverse invocation order by allen in the case of recursive programs there is no ordering with this property thus an interprocedural data flow analysis algo rithm which is to be used on recursive programs must include some method of this the second fundamental problem that an inter procedural data flow analysis algorithm must with arises in programming languages which allow name or reference parameters since these mechanisms introduce storage sharing among variables called aliases the determination of which variables may be modified by a statement is nontrivial suppose that r is a reference parameter in a procedure p which contains r u v as a statement the summary information for p must reflect the fact that any variable potentially shared with r may be modified it is fairly obvious that sharing can be analyzed by a over the program if a list of variables which are shared with r is available the processing of the above statement is no longer in order to perform the data flow analysis in a single pass over the program this strategy is since there all the aliases of r a particular statement is no reason to believe that will have been exposed before which modifies r is pro another difficulty associated with summary information for recursive programs is in the correct treatment of variables it is under that separately declared variables are dis even if their coincide but there is a more problem recursive invocations of a procedure p have separate copies called op ps local variables high quality summary data flow information for a procedure q will not include the possibility that q may modify a variable local to p if the which may be modified is not the same as the at the point of call the algorithm to be presented in this paper is sufficiently powerful to collect summary data flow information for recursive programs it can be used on programs with reference parameters and will deal with different of variables local to recursive procedures the data flow analysis technique described is strictly one pass in nature and can be implemented in the first parsing pass of a compiler an implementation is possible which bit vec tor operations which are available as word opera tions on most hardware the running time of the algorithm is approximately the same as the running time for transitive closure which is shown to be a lower bound for the problem under reasonable assumptions the algorithm simplifies in a natural way for use in languages with naming structures less general than algol or for use on programs that do not use recursion before on any further study of interprocedural data flow analysis it must be made clear at what stage of an optimizing compiler this information is interprocedural data flow information is used to determine that particular optimizing transformations do not affect the correctness of the program thus it is necessary first to compute the data flow information and then to apply specific optimization in the case of recursive programs an entire pass over the program may be necessary to expose the data flow tion for these reasons an optimizing compiler should first compute summary data flow information in a pass and then attempt to find optimizing transformations in subsequent passes summary of previous work the concepts of interprocedural data flow analysis have been developing for about years the principal algorithms for computing summary information are due to allen and rosen each of the algorithms uses a different computational strategy in addition to this difference each algorithm com somewhat different information technique is only suitable for computing information but does so for the complete language method is usable for computing and but is suited for use on recursive programs method is the most highly capable of computing arbitrary flow high degree of precision even in complex sharing patterns sophisticated problems with a programs with these techniques span a of tional and expected quality of computed information which technique is most appropriate for a particular application will depend on the value placed on the quality of information com the present technique is computationally at least as simple as the of the algorithms which it it does not produce information as precise as and so will not be suitable for the most of applications tion it does however attempt to as far as possible the precision of calculated information within the constraints of computational efficiency the interprocedural data flow analysis technique of which the author is aware was developed by thomas his paper published in deals with the issue of side effects of statements thus the major of the work is directed toward determining the patterns under which variables share storage included n this analysis are language features such as call by reference parameters pointer vari ables possibly with offsets and on conditions his techniques are suitable for determining the side effects of procedure call statements summary information and for this reason are within the scope of interprocedural data flow analysis method works essentially as fol each procedure is into a bit vector in which speaking a bit represents the information whether the variable corresponding to its position is modified in the procedure bit vectors for procedures are merged into one another in the invocation order a procedure is not processed if possible until all procedures which it invokes are processed then procedures are processed in the invocation order reverse of above to account for aliasing effects if sion is detected in the program the above steps are iterated until the bits method is the most similar to the techniques presented in this paper we will use a similar representation of tion but will be able to achieve substantially better results in the computation of modifies information in addition we will use this kind of representation to compute arbitrary data flow prob which would not have been possible within the conceptual framework available to although method only requires a single pass over the program it is not suitable for com arbitrary interprocedural data flow tion the interprocedural data flow analysis algo rithm developed by allen is the most widely used originally the algorithm was limited to nonrecursive programs for which there is guaranteed to be a reverse invocation order each procedure is to global flow analysis which determines its data flow properties given the known data flow information statement associated with each allen and schwartz have extended this basic algorithm to handle recursive programs the essential idea is that a procedure p which calls another procedure q can be analyzed before q if one is to make worst case assumptions about the data flow impact of q the information can be refined by p after a better tion for q has been computed does not discuss the problem of of variables in recursive pro grams her techniques do not naturally handle sharing of variables because the order in which procedures are examined is an order in which bind at calling sites are always discovered after the called procedure has been analyzed the which the calling information can be used to collect sharing information which allows method to base its actions on the most general sharing pattern for each given vari able other major work in interprocedural analysis has been done by rosen method works on recursive programs data flow his and produces very precise information even in cases in which the sharing patterns of variables vary on the context unfortunately his method is probably slow and complicated for all but the most of applications the basic idea exploited by rosen is that when analyzing using global flow analysis a procedure p with a call on a q the information impact of q can be in a which summaries p that is the o p is m with n for called in p analyzing a program yields a set of which can be solved to obtain useful flow information sharing is handled by allowing formulas to be parametric in some sense in a sharing pattern when an equation is used to summarize information at a point of call the particular at point of call are used to refine the formula of variables can be kept apart by renaming variables in a they are back into the procedure which created them the technique used by rosen to solve the simultaneous equations is a bit reduction strategy in which maximal information is at first assumed the equations are substituted into each other until the information which is decreasing he proves that the information thus obtained is correct a characteristic of this method is that the iteration must be fully carried out because partial solutions are incorrect until complete rosen proposes that the equations may be simplified in advance by using various symbolic execution strategies on the pro gram notation and problem definition the approach taken to computing summary data flow information by this author is that the process is essentially one of computing relations over the domain of procedures is a relation for example between procedures and the variables possibly modified as a summary effect of their invocation the interprocedural data flow relations are by composition and tive closure of other relations which are easy to construct from the source program these easy to construct relations relations are referred since they are constructed to as direct directly from the program without considering rela tions which represent summary data flow information are referred to as summary relations the manner of presentation of the techniques will be to define various relations the notions of correctness and precision will then be supplied for summary relations formulas will show how to compute summary relations from direct relations the correctness of the summary relations will be verified based on the definitions of the direct relations and the computational formula specified it will remain to show that the direct relations can be computed to satisfy their definitions easily this can be accomplished by an implementation of the data flow techniques which is only very briefly sketched in this paper tional this data then it will be convenient to introduce some conventions which will be used throughout paper a formal definition of the summary flow information that we wish to compute will be presented we are considering the summary data flow prob lem for programs in algollike static naming structure languages a is understood to be reasonably well formed ie there is no code subroutines are called explicitly at sites which are visible rather than being by the existence of some a variable is a declared entity whose storage may be associated with subroutine entry that is if a procedure is called recursively a particular variable may be associated with several storage locations each such location is called an of the variable def let be the set of procedures in a program to be analyzed for the exam assume that p q r and s are members of pp def let be the set of variables in the program for the examples assume that r u v w x y and z are members of vv separately declared variables are distinct even if their def a binary relation is a set of or pairs in with standard notation for relations a and b t a is the closure of a a is the transitive closure of a a b is the composition of a and b a is the set of pairs not in a a and b is the set of pairs in both a and b a or b is the set of pairs in either a or b is the of a that is aa g a iff aa g and aa g a is written with a a a or in a def let be a relation defined pp x pp a pair pq is in call if p contains a call on procedure on pro q def let be a relation defined on pp x pp a pair pq is in if procedure p contains a call on pro q on all paths of execution for which p terminates normally that is a call on p must always be followed by a call on q before p returns to its calling site the notion of in contrast to which distinguishes from call is important to careful a relation which contains information only expresses the possibility that the action suggested by the relation name will occur in the executing program for example pq g call states the pos that p may call q in contrast to this information is appropriate when a about the executing program is intended if pq g then the call on q must be executed as a of p in the case of normal termination of p for which summary data flow information is mean may information is tive sense the fact definite information call q the fact that that p really will call for extracting important usually used in the that pq c call that p will not directly pq s call does not imply q and so is of limited use information def let be a relation defined on pp x vv a pair px is in if procedure p contains a statement which modifies the value of variable x may information def let be a relation defined on pp x vv a pair px is in if procedure p contains a use of the variable x may information def let be a relation de on pp x vv a pair px is in if procedure p does not preserve the value of variable x on any path of execution for which p terminates normally that is x must be set by an invocation of p must information all of the above relations are direct in the sense that they contain information about effects of procedures ignoring indirect effects due to sub calls the remaining relations to be defined con summary information about the effects of pro and associated def let and be relations defined on pp x vv which are the summary information that we wish to calculate if px g mod then procedure p and any of p will not modify the value of the variable x if px s use then p and any not use the variable procedure of p will x if px g pre then returns the variable have been assigned before p x will mod use and may information calculate preserves tion so we define relation pre are relations which contain it will be more convenient to information as must an additional summary data flow def let be a relation defined on pp x vv a pair px g implies that before p returns the variable x will have been assigned is sim pre the above definition of use is slightly from what is calculated in summary data flow analysis under this definition if a variable is read it is considered a use of the variable traditionally it would only have been considered a if the value read from the variable could have been the value at the point of call obviously if a pair px s use then the value of x is also not used as a summary effect thus use can be substituted for traditional uses information in any application having made the definition this way however prevents certain pairs from being eliminated from use consider the case in which a variable must be assigned before each program read action on it by these definitions there is no way to say that the variable is used but not its value it is understood that summary information must be correct with respect to any particular point of call of a procedure the summary data flow rela tions are defined on pp x vv where vv is the set of of variables at the point of call the following example illustrates why this interpretation of summary information is critical f declare x q p x q assigned by p it is wrong within q to conclude that p x at its call since the of x which is at this site is different from the assigned by the call on p the relations defined above introduced in later sections table and several to be are summarized in interprocedural data flow analysis is the process of computing the summary data flow relations we must be somewhat careful in specifying what is expected of an interprocedural data flow analysis technique because the t ions of the relations do not trivial and useless solutions several evaluation criteria of data flow analysis techniques will be necessary def calling we say a that a summary data flow is correct for a procedure p if re for may information there is no instance of the following three conditions occurring simultaneously for any vari able x i x is at the calling site ii px c a iii the call on p may have the summary effect a on the of x at the time of call for must information there is no instance of the following three conditions occurring simultaneously for any vari able x i x is at the calling site ii px ga iii the call on p may fail to have the summary effect a on the of x which was address able at the time of the call def every we say that a summary data flow a is correct if it is correct calling site in the program we wish to define the precision of a relation to capture the concept of the amount of definite information available in particular for may information the the relation the more effects are known not tions have a natural partial sion we define precision between related order to be possible rela ordering by set to be a meaningful com elements in the partial def we say flow relation er correctly relation if that a correct summary data is more than calculated version sf that for may information precise relation the pairs of the relation the more is a subset of less precise for must information precise relation is of the pairs of the relation the more a superset less pre the notion of correct does not the trivial solutions of all pairs for may information and no pairs for must information these solutions are correct but are usually too to be use it is too a criterion to ask for the most precise solution for a summary data flow rela tion since the determination of this will be in general def we say that a summary relation to execution if is for may information it is the most precise information ble assuming that all executed code is and that all the vari ables in the program are for must information it is the most precise information possible assuming that any path of execution through procedures is possible and that all vari ables in the program are the condition able to pairwise removes a distinct vari case in several relation call mod use pre scope affect table domain program independent pp x pp pp x pp pp x vv pp x vv pp x vv pp f vv pp x vv pp x vv pp x vv pp x vv pp x vv vv x vv direct direct direct direct direct summary summary summary summary program program direct independent independent may must may may must may may may must may proofs and will instance be explained in the first such the part of the definition to con execution is somewhat different for may and must relations clearly if all paths through a procedure are executable the must condition then all executed code is executable the may condition the converse is not true consider this procedure p declare w comment w is local assignments its value lw if w o then x if w o then y so that the cant affect ul else y u else x v v even assuming that all executed code is executable it would still be possible to con that neither x nor y is preserved by p by symbolically merging the then and else parts of the conditional statements we wish however to con must information precise up to symbolic without requiring this kind of analysis ultimately what is required of an data flow analysis algorithm is that it produce provable correct relations which are sufficiently precise when a technique is precise up to symbolic execution we may be that the information produced is of very high quality specific results of testing the tech developed here will be included in properties of mod use and pre the algorithm which will be presented computes mod and use as may information but will compute as must information to obtain pre the complement of is calculated this section will partially justify the use of a different tech for computing pre there is a means of com pre directly using a variation of the algo rithm presented here an account of this appears in although mod ad pre are both may information the manner in which they are collected differs consider code x u y v the first statement statement modifies x and the second modifies y the mod information for the two statements together is the union of the mation for each statement they modify both x and y the first statement may preserve all variables except x the second may preserve all variables except y the pre information for the two state ments together is the intersection of the preserves information for each statement they ma preserve all variables except x and y in this is summarized now consider code which is executed if then x u else y v in this case the union of the may information for the internal statements is the information for the entire statement for both mod and pre in this is summarized yy mod pre for purposes of this paper it must suffice to say that the algorithm presented has a hidden assumption that the information composition func tion for code is union this requirement with the of being must information all forms of must tion require intersection among statements py calculating mod and use no sharing for simplicity in this section we assume that there is no mechanism such as call by reference parameters for introducing sharing among vari ables formulas which use call and to calculate mod and use are presented a series of formulas will be presented which late summary data flow relations to of precision in order to distinguish the com relations we will write for example to be the mod relation as calculated by formula only the formulas for mod are since the arguments in both cases are the same correct obtain formulas for mod and use are easy to mod call use call claim is correct justification since mod is may tion we must justify the absence of any pair px missing from the computed relation suppose that p call x this says that p and all procedures from p directly or indirectly do not contain a statement which modifies x from this we conclude that p in summary does not modify x although the above formulas are correct they are extremely conservative in their treatment of variables if any of x may be modified by a of p then p x is calculated if the of x which is modified by the must be different from the one at the point of call of p then the pair px could have been eliminated from mod increasing the precision of the information refined formulas will be obtained for mod and use by including algol scoping rules in the the techniques presented can be modified to accommodate languages with less general static naming structure def the level of is the static depth at which the procedure is defined declarations which occur any where within a procedure will be with the procedure invocation er than with begin block entry the level of variable is the same as the level of the procedure to which it is lo cal this differs somewhat from algol terminology global vari ables are at level o the lowest naming level when comparing levels it will usually be to refer to lower levels as outer and higher as inner levels def let scope be a relation defined on pp x vv a pair px is in scope iff the level of x is strictly lower than the level of p that is x is declared at a outer level from p scope is weaker than an since it is possible that is not within that using scope rather relation does not data flow information relation p scope x even though x p it is shown in than an the calculated summary the following lemma will formulas involving be used repeatedly scoping rules in lemma when computing summary data flow information a call direct or indirect on a level n procedure p and all of its can affect variables at the original point of call only at levels o n proof p and its may be able to address variables at levels which n but the variables at these levels will be new and are not at the original calling site under the rules of static scoping when a procedure is called the variables which are in the called pro are a subset not necessarily proper of those at the cal site plus new of local variables in the body of p the levels o n contain variables at the original calling site and level n contains new of local vari ables for p by applying the previous observation inductively of p direct subset or indirect can only affect a of the variables in p plus new of local variables which were not at the calling site note that the above lemma is false of reference parameters in the presence formulas and produce summary data flow information which is more refined than that pro by formulas and mod call and scope use call and scope claim is correct justification omitted see formulas and reflect the observation that actions on local variables never affect sum data flow information these equations are sufficiently powerful to process programs in languages which do not allow the nesting of naming levels except to distinguish and for such languages the relations computed are pre up to symbolic execution a fact that will follow as a corollary to a more general statement which is proven later in this section c and are languages which enforce this naming limitation a series of examples which illustrate program skeletons will be useful in developing intuition as to the precision of various formulas used in summary data flow relations we begin with two examples for which formulas and are more precise than formulas and for all the examples the reader is to assume that subroutine calls are executed so that nonterminating recursion is avoided p declare x x is modified p example the call important on p does not modify the of x at the point of call case of direct recursion this is the f declare x r x is i fi l example p modified here too p in a later since x and scope x discussion is this local example to will p fig formulas information tion for the and fail to produce data flow which is precise up to symbolic following example q declare x q r r p x is modified example the call on p within q can not modify the currently of x as a consequence of the scoping lemma into formula p call q q call r r and scope x shows that p x we generalize example to produce these formulas from this mod call and scope use call and scope formula produces information for example which is completely precise since p scope x it produces the same information as formula on example unfortunately it fails to be as pre as formula on example before develop ing formulas which are completely precise on all of these examples we to prove the correctness of the third set of formulas claim is correct justification omitted see the desirable properties can be combined of all of these for mod call use call and scope and scope and and scope these formulas produce precise data flow information for all of the above examples claim is correct justification omitted see although it is possible to construct examples which formulas and are not precise symbolic execution these formulas are the for use in practice formula to be completely precise on this ple for up to ones fails exam rq declare x p so is modified r p q the call on p within able x the call q can not the on s but address p call r r and and p scope x x so p x completely characterizing the effects of ing rules on mod and use information will result in formulas for them which are computationally less efficient it will be convenient to introduce some notation for this characterization def a call chain is an ordered of procedures which are pairwise call relation thus p call result of p call q q call r call s results in as chain sequence in the s as a r and a call def level call call level let the call chain level be of the outermost procedure in chain in the example above chain level is p level r level s the the the q def let be a pp x matrix of integers where rows and columns are selected by procedure names is the maximum call chain level for all call chains from p to q calculating mod and use can be accomplished these formulas with mod px for some q g pp p call q q x and level x use px for some q g pp p call q q x and level x the intuition which the use of the maximum chain level in the formulas is that one may only be certain that some pair px is absent from the computed mod if the call chains which result in the modification of x all involve the call of a procedure at a level x if a call chain of maximum at least as low as level contains a procedure at a level as low as x then all other call chains must also claim is correct proof suppose that p x for a contradiction assume that p does modify the x from some point of call since p can modify x there is some call chain c beginning with p and ending with the procedure q which directly modifies x the call chain el of c by the de of the tion by q of the same of x which is at the call of p is only possible if level x call chain level of c by the scoping lemma thus the level of x and all three conditions of formula are satisfied a contradiction claim formula symbolic execution mod precisely up to proof we must show that the elimination of any pair px from in an incorrect summary relation results ing that all paths of conditional tion are executable suppose that p x look at any calling site for p we know that there is some call chain beginning with p and ending with a procedure q which modifies some tion of x since all paths of condition al execution are executable we may as that p calls q through a call chain of maximal level since the level of this call chain the level of x we know that no of x is created between the time p is called and the time q modifies some of x we also know that the variables ad at the level of x from the cal site are the same as the variables at that level from q or in particular not only is x at the calling site of p but it is the same of x which is modified by q we have proven that eliminating px from produces incorrect in formation if the of x were not distinct from all other variables it might be possible that at the calling site x on the run time but is not because a more local corollary for languages like allow the nesting of procedures precise up to symbolic execution which formula do not is proof all call chains in such languages have a call chain level of scope selects effects on global level o vari ables it follows that all calculated pairs satisfy the three conditions of formula having studied formulas for mod and use which are precise up to symbolic execution we are in a position to that formulas and should be good heuristic methods here once again are those formulas mod call use call and scope and scope and scope and scope we will claim the same as without proof that formula is mod px i for some q c pp p call q q x and level x p level q thus formula differs from the chain level cal only in cases in which pq p level q what this equation says is that if the level chain innermost from p to q must go through some procedure less nested than either p or q then formula fails to be as precise as formula this is a somewhat condition which one can expect to arise in practice this matter has been studied and the results are presented in calculating no sharing it is possible to obtain formulas for from and it turns out that the calculation of this summary data flow information involves very different tions than those which applied to mod and use an account of these methods appears in sharing mod and use the information introduction gram which statement task of collecting summary is made somewhat more difficult of reference parameters into is to be analyzed a simple like data flow by the the x u can affect variables other than effects happen in for future reference x these aliasing ways which we name variable has the same ll i rq declare x i formal i r is modified l i px l effect r modifying a reference parameter results in the modification of the actual parameter bound to it in this example we must determine that p mod x rq declare x formal r x is modified cp rx effect modification of a variable may result of reference parameters must be in the p mod r in this section on the mod relation all the reasoning information we will study sharing effects it should be understood that applies equally well to use the relation that will enable us h compute summary data flow information in the presence of sharing is def let affect be a relation defined on vv x vv a pair rx is in affect iff formal reference parameter r is directly bound to actual parameter x at some point of call a formula for mod can now be obtained from formula which will be correct in the presence of reference parameters mod call affect intuitively effects are for by affect and effects are computed by to aid in the correctness proof of formula and for subsequent formulas in this section we use a lemma which requires the intro of a few new terms def let x r affect x be called the set of which may be aliased to r formulas are to be consistent with thus formulas through do not appear in this paper def let r called the aliased to x x formals which r be may be the lemma will attempt to formalize a rather simple idea which is best understood by looking at a series of diagrams consider nodes of these graphs to represent variables and directed arcs to represent in the affect relation a reverse arrow represents in the relation x here we see a graph which is induced by a program in which formal reference parameters r and u are bound to actual parameter x if both r and u are bound to x simultaneously modifying r modifies r x and u the proof of the lemma contains an example of a program in which this occurs xv this graph parameter parameter the same modifying represents a program in which formal r takes either x or y as its actual there is no way to bind both x and y to of formal parameter r hence x can not result in the modification of y its set of and sets of formals of these able may be modified modification of r a variable r may variables which are no other as effect modify in the the proof the first effects the examples which illustrate and effects prove most of sentence of this lemma the example shows that formals of can be modified through sharing preference formal r is modified px formal r u p modifies r this modifies of r since at the of p within r u is a modified by the call on p x an actual calling site of x u is what remains to prove is that no other kinds of effects can arise through ing in particular it must be shown that no other of formals can be modified that is if r affect x and r affect u that modifying x will not modify u at the moment that the program modifies the value of x it may be bound to some in of the reference parameter r this of r can not be bound to x because the of r is associated with a call of the procedure to which it is a formal parameter since x affected r this call must have had actual parameter x not u the aliasing lemma relates to formula in that affect has the impact of widening the modification of a variable first to its set of and then widening this to the sets of formals for these in a diagram modifying r results in the computation of the pos modifications of all the nodes in the region claim mod is correct justification follows from aliasing ma and the proof of formula lem combining aliasing effects and scoping con is necessary for practical tions it will turn out that the formulas derived are quite uniform in but the correct ness arguments are quite different at each step of increasing complexity analogous to formulas and for this reason combining scoping and aliasing considerations will be done in stages which parallel the previous presentation of ing the notion of scope must be because in the presence of reference parameters the tion of a local variable formal parameter may have global effects see for instance the tion of effects def let be a relation defined on pp x vv which will generalize scope a pair px is in iff the level of x is strictly less than the level of p or x is a formal reference parameter of some recent work has in an improved method for combining aliasing and scoping con it is similar in spirit to the technique presented here requires about the same amount of computation and results in more precise information it is however consider more complex to present and the intuitive notions here procedure this differs from scope in that if parameter the pairs px are for all procedures p x is a reference automatically in the first of the formulas which will scoping considerations and sharing effects combine follows mod call and affect claim mod is correct justification omitted see formula next equation is analogous formula to formula the mod call and affect claim mod is correct justification omitted see combining languages that parameters formulas and produces the formula for use on programs in allow algol scoping and reference mod call and and affect claim mod is correct justification omitted see implementation one of the major advantages for the interprocedural data flow analysis algorithm described in this paper is its strictly one pass nature the idea behind the single pass tation is that call and affect are easily con from the program before any information is available in particular since the order in which procedures are examined is it is not necessary to construct a call graph in advance of performing intraprocedural information it is also unnecessary to analyze the possible sharing relationships in advance since they have no effect on any of the direct relations complexity the computational complexity of the straight forward a bit vector implementation for this algo rithm is quadratic in vv implementing the algorithm on a machine with operations on words of fixed size results in an algorithm of complexity in this section it will be shown that tions this algorithm for tion under certain is asymptotically summary reasonable the best data flow we will consider programs with no sharing and no recursion in order to rule out trivial summary information no information we assume that on a program with no loops no no local variables and no an algo rithm information which is completely pre the described has this property for both may and must information under these assumptions it will be shown that computing sum information is asymptotically as complex as computing reflexive closure it is well known that the asymptotic complex ity of computing reflexive transitive closure is the same as the complexity of boolean matrix using a standard matrix tation for relations the algorithm presented can be made to run asymptotically as quickly as boolean matrix multiplication and transitive closure plus the time necessary to scan the program once since the program scan is for any algorithm it will be argued that at least in theory the algorithm presented is the pos the first observation necessary for the tion to transitive closure is that the tional complexity of computing the reflexive closure of a cycle free graph is the same as the complexity for arbitrary graphs the reader may find a proof of this fact in the proof of theorem in aho hopcroft and unman although they do not state this fact let m be an matrix for some acyclic graph the computation of transitive closure of m m can be embedded in any of the summary data flow problems we will produce a non recursive program with the property that mod for the program is an interpretation m the program consists of procedures pi which are of the fol form r pi xi is modified l call every procedure pj for which it is quite obvious that pi mod x iff the program is nonrecursive the graph represented by m is acyclic suppose that m is an matrix the program constructed has n so the complexity of computing mod expressed in is at least as great as the complexity to a constant of computing factor m expressed in n up it is particularly interesting to note that processing procedures in nonrecursive programs using the reverse order allen does not the computational complexity of the sum data flow problem having shown that data flow information in the no sharing and nonrecursive case is as complex as computing reflexive transitive closure it follows that the sharing and recursive cases are at least as complex conclusion an implementation written in pascal for this algorithm exists for pascal programs and it appears to be quite to use in the most general of terms the data flow analysis of a or small program up to procedures and variables will take about one third of the time it takes to compile the program using the standard translator the implementation was run on the pascal compiler which is a program with about lines of code procedures and vari ables performing the interprocedural data flow analysis for mod use and pre took somewhat less time than it takes to compile the compiler the space required was about o bit words the use of interprocedural data flow analysis in an optimizing compiler at these costs seems practical in a system which is to gen program or automatic tion these costs are quite small compared to the surrounding system the experience with this algo rithm shows that interprocedural data flow analysis is well within what should be con practical for use in programming language systems aho v hopcroft jeffrey d design addisonwesley reading mass john e and unman computer allen f e interprocedural data flow analysis proceedings north holland co amsterdam allen f e and schwartz j t determining the data relationships in a collection of pro unpublished detailed summary compiler for pascal jeffrey m a practical data flow algorithm and phd berkeley in on interprocedural its applications of california graham l usually linear journal of the and wegman mark a fast and thm for global flow analysis vo no jan david construction new york matthew s and jeffrey b ideas on the design of a for part i overview and analysis computer science technical report tr university of college park august matthew s and unman jeffrey d analysis of a simple algorithm for global flow problems conference record m jk w principles programming la boston mass october user notes and pascal manual and report springer verlag lecture in computer science no berlin david b data flow presence of procedure calls rc thomas j watson research york november analysis in the research center peter language january lg revised algol report on the algo communications of the m c reference manual bell hill new rosen k data flow analysis for recursive programs research thomas j watson research center heights new york january this report is by rosen k high level data flow analysis part classical structured program ming research rc thomas j watson research center heights new york august rosen k high level data flow analysis part escapes and jumps research rc thomas j watson research center heights new york december rosen k data flow analysis for pro languages ibm thomas j watson research center heights new york t c side effects optimizing compiler proceedings ifip ence north holland amsterdam in a tarjan robert e directed graphs stanford ence department technical palo alto ca november solving path problems on university computer sci report william a et al a basic language for implementation of system software for the carnegie mellon university computer science department report 