on the linear ranking problem for integer loops m the academic college university of abstract in this paper we study the complexity of the linear ranking problem given a loop described by linear constraints over a finite set of integer variables is there a linear ranking function for this loop while existence of such a function implies termination this problem is not equivalent to termination when the variables range over the or reals the linear ranking problem is known to be decidable however when they range over the integers whether for or loops the complexity of the linear ranking problem has not yet been determined we show that it is however we point out some special cases of importance of complexity we also present complete algorithms for synthesizing linear ranking functions both for the general case and the special cases categories and subject descriptors f analysis of algorithms and problem complexity general f logics and meanings of programs specifying and verifying and reasoning about programs general terms verification theory keywords ranking functions termination linear constraints introduction termination analysis has received a considerable attention and several powerful tools for the automatic termination analysis of different programming languages and computational models exist much of the recent development in termination analysis has from techniques that deal with one loop at a time where a loop is specified by a loop guard and a loop body very often these loops are abstracted so that the state of the program during the loop is represented by a finite set of integer variables the loop guard is a conjunction of linear inequalities and the body modifies the variables in an affine linear way as in the following example while x x x x do x x x x x where tagged variables represent the values at the completion of an iteration when the variables are modified so that they are not permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm affine linear functions of the old ones the effect is sometimes captured or approximated by means of linear constraints eg the c language loop while xy y do xx which involves integer division can be represented by linear constraints as follows since x is always positive while x x x do x x x x x x linear constraints might also be used to model changes to data structures the variables representing a size abstraction such as length of lists depth of trees etc for a precise definition of the loop representations we consider see sec they also include loops where alternative paths in the loop body are represented a standard technique to prove the termination of a loop is to find a ranking function such a function maps a program state a valuation of the variables into an element of some wellfounded ordered set such that the value in the appropriate order whenever the loop completes an iteration since descent in a wellfounded set cannot be infinite this proves that the loop must terminate this definition of ranking function is very general in practice researchers have often limited themselves to a convenient and tractable form of ranking function so that an algorithm to find the there is be found a frequently used class of ranking functions is based on affine linear functions in this case we a function x xn ax · · · a with the as a codomain such that i x¯ for any valuation x¯ that satisfies the loop guard and ii x¯ x¯ for any transition that starts in x¯ and continues in x¯ this automatically induces the ranking function f x¯ x¯ if x¯ satisfies the loop guard and otherwise with the nonnegative as a codomain but ordered wrt a b iff a b which is wellfounded for simplicity we call itself a linear ranking function instead of referring to f an algorithm to find a linear ranking function using linear programming lp was found by multiple researchers in different places and times and in some alternative versions since lp has a polynomial time complexity most of these methods yield polynomialtime algorithms generally speaking they are based on the fact that lp can precisely decide whether a given inequality is implied by a set of other inequalities and can even be used to generate any implied inequality after all conditions i and ii above are inequalities that should be implied by the constraints that define the loop guard and body this approach can in a certain sense be sound and complete soundness means that it produces a correct linear ranking function if it succeeds completeness means that if a linear ranking function exists it will succeed in other words there are no false a completeness claim appears in some of the references and we found it several times in our it has a false that the linear ranking problem for linear constraint loops with integer variables was completely solved and classified as polynomial time the in the is the fact that these solutions are only complete when the variables range over the which means that the linear ranking function has to its requirements for any rational valuation of the variables that satisfies the loop guard but this may lead to a false negative if the variables are in fact integers the reader may turn to the two loops above and note that both of them do not terminate over the at all for the first consider x x for the second x and x but they have linear ranking functions valid for all integer valuations which we derive in sec this observation has led us to investigate the linear rank ing problem for and linear constraint loops we present several fundamental new results on this problem we have that this problem is indeed harder in the integer setting proving it to be as a decision problem even for loops that only manipulate integers in a finite range on a positive note this shows that there is a complete solution even if we give such a solution both to the decision problem and to the synthesis problem the of the completeness proof and the corresponding synthesis algorithm is that we rely on the generator representation of the transition poly defined by the loop constraints we provide sufficient and necessary conditions for the existence of a linear ranking function that use the vertices and of this representation another positive for the reader is that some special cases of importance do have a solution be cause they reduce with no effort or with a polynomialtime com to the rational case we present several such cases which include among others loops in which the body is a sequence of linear affine updates with integer coefficients as in loop above and the condition is defined by either an extended form of differ ence constraints a restricted form of two variables per inequality constraints or a cone constraints where the free constant is zero some cases in which the body involves linear constraints are also presented all the algorithms presented in this paper have been im and can be tried out online see sec our results should be of interest to all users of linear rank ing functions and in fact their uses go beyond termination proofs for example they have been used to provide an upper bound on the number of iterations of a loop in program complexity sis and to automatically computations we remark that in termination analysis the distinction between in and has already been considered both regarding generation and the very decidability of the termination problem all these works left the case open interestingly our results provide an insight on how to make the solution proposed by et al complete see sec this paper is organized as follows sec gives definitions and background information regarding linear constraint loops linear ranking functions and the mathematical notions involved sec proves that the decision problem denoted is complete and also presents an synthesis algorithm sec discusses cases sec describes a prototype implementation sec related work sec concludes in this section we recall some results on integer polyhedra on which we will rely define the kind of loops we are interested in and formally define the linear ranking function problem integer polyhedra we recall some useful definitions and properties which can all be found in a rational convex polyhedron p qn polyhedron for short is the set of solutions of a set of inequalities ax b namely p x qn ax b where a is a rational matrix of n columns and m rows x qn and b qm are column vectors of n and m rational values respectively we say that p is specified by ax b the set of directions of a polyhedron p specified by ax b is the set rp y qn ay for a given polyhedron p qn we let ip be p zn ie the set of integer points of p the integer hull of p commonly denoted by pi is defined as the convex hull of ip ie every rational point of pi is a convex combination of integer points it is known that pi is also a polyhedron an integer polyhedron is a polyhedron p such that p pi we also say that p is integral polyhedra also have a generator representation in terms of vertices and written as p xm yt this means that x p iff x m i ai t j bj for some ai bj where m i ai note that y yt are the directions of p ie y rp iff y t j bj · yj for some rational bj when p is integral there is a generator representation in which all xi and yj are integer complexity of algorithms on polyhedra is measured in this paper by running time on a conventional computational model equivalent to a turing machine as a function of the of the input following sec we define the of an integer x as x the of an vector a as a n n i ai and the of an inequality a · x c as c a for a polyhedron p qn defined by ax b we let p b be the of ax b which we can take as the sum of the sizes of the inequalities the size denoted by p f is the smallest number n such that p may be described by some ax b where each inequality in ax b in bits clearly p f p b the vertex size denoted by p v is the smallest number n such that p has a generator representation in which each of xi and yj in bits the size of a vector is as above for integer polyhedra we restrict the generators to be integer the following theorems may be found in th p and cor ab p respectively theorem let p be a rational polyhedron in qn then p v n p f and p f n p v theorem let p be a rational polyhedron in qn then pi v n p f and pi f n p f loops a loop for short over n variables x xn has the form while bx b do a x x c where x x and x x are column vectors and for some p q b a b qp c qq the constraint bx b is called the loop condition the loop guard and the other constraint is called the update the update is called deterministic if for a given x satisfying the loop condition there is at most one x satisfying the update constraint the update is called linear if it can be rewritten as x a x c for a matrix a and vector c of appropriate dimensions we say that the loop is a rational loop if x and x range over qn and that it is an integer loop if they range over zn we say that there is a transition from a state x qn to a state x qn if x satisfies the condition and x and x satisfy the update a transition can be seen as a point x x qn where its first n components correspond to x and its last n components to x for ease of notation we denote such points by x x x the set of all transitions x qn will be denoted as a rule by q the transition polyhedron q is specified by a x c where a b a c b c note that we may assume that q does not include the origin for if it includes it the loop is clearly nonterminating this condition is easy to check hence q is not a cone ie m in the generator representation the polyhedron defined by the loop condition bx b will be denoted by c the condition polyhedron a loop mlc for short differs by having alternative loop conditions and updates which are in principle chosen nondeterministically though the constraints may enforce a deterministic choice loop k i bi ai x x ci this means that the ith update can be applied if the ith condition is satisfied following the notation of loops the transitions of an mlc loop are specified by the transition polyhedra q qk where each qi is specified by ai x ci the polyhedron defined by the condition bi is denoted by ci for simplifying the presentation often we write loops with ex equalities and inequalities instead of the matrix tion we also might refer to loops by their corresponding transition polyhedra or the sets of inequalities that define these polyhedra linear ranking functions a linear function qn q is of the form x · x where n q is a row vector and q for ease of notation we sometimes refer to a linear function using the row vector qn next we define when a linear function is a linear ranking function lrf for short for a given rational or integer mlc loop definition given an mlc loop with q qk as transition polyhedra and a linear function x · x we say that is a lrf for q qk iff the following hold for any rational point x x qi · x · x x and we say that it is a lrf for iq iff hold for any integer point x x intuitively and requires that x and xx respectively for rational loops this must hold for all rational transitions and for integer loops it must hold for all integer transitions clearly the existence of a lrf implies termination of the loop note that in def we require to decrease at least by where in the literature this is sometimes replaced by it is easy to verify that these definitions are equivalent definition the decision problem existence of a lrf is defined by instance an mlc loop question does there exist a lrf for this loop the decision problem is denoted by and for rational and integer loops respectively it is known that is in this paper we focus on the general case is in this section we show that the problem is it is already for loops we also show that can be synthesized in deterministic exponential time this section is organized as follows in sec we show that is in sec we show that it is in for loops and in sec for mlc loops finally in sec we describe an algorithm for synthesizing we prove in a strong form a number problem a problem whose instance is a matrix of integers prob is strongly hard for a complexity class if there are polynomial reductions from all problems in that class to prob such that the values of all numbers created by the reduction are bounded by the input assuming strongly nphard or problems cannot even have algorithms theorem the problem is strongly even for deterministic loops proof the problem of deciding whether a polyhedron given by bx b contains no integer point is a wellknown problem an easy reduction from sat may be found in we reduce this problem to given b and b we construct the following integer loop while b i i x z b do x z x where x x z z are integer variables and i is an identity matrix of size m × m suppose bx b has an integer solution x then the loop does not terminate when starting from this x and z set to since the guard is satisfied and the update does not change the values thus it does not have any ranking function let along a lrf next suppose bx b does not have an integer solution then for any initial state for which the loop guard is enabled it must hold that z · · · for otherwise z must be in which case the constraint bx iz b has no integer solution since the updated vector z is set to the guard will not be enabled in the next state hence the loop terminates after one iteration clearly z · · · z · · · so we conclude that z · · · is a lrf note that in the above reduction we rely on the of whether a given polyhedron is empty this problem is even for bounded polyhedra due to the reduction from sat in which variables are bounded by and this means that even for loops that only manipulate integers in a rather small range the problem is the parameter responsible for the exponential behavior in this case is the number of variables inclusion in for loops to prove that is in we show that the complement of the problem of of a lrf is in np that is has a witness in what follows we assume as input an loop with a transition polyhedron q qn the input is given as the set of linear inequalities a x c that define q the proof follows the following lines we show that there is no lrf for iq iff there is a witness that consists of two sets of integer points x iq and y such that a certain set of inequalities ws xy has no solution over the and we show that if there is a witness then there is one with polynomial in the input to make sense of the following definitions think of a vector qn as a candidate lrf that we may want to verify or in our case to eliminate definition we say that x x x iq is a witness against qn if it fails to satisfy at least one of con and the set of against by x is denoted by w x definition we say that y y y is a component of a witness against n q if it fails to satisfy at least one of · y y the set of against by y is denoted by wh y the meaning of the witness of def is quite straightforward let us intuitively explain the meaning of an suppose that x is a point in qi and y is a of qi then a lrf has to satisfy for any integer point of the form x a · y with a letting a grow to we see that implies the inequality similarly implies definition the set of qn and against respectively by x iq and y is defined as ws xy w x wh y x x y y lemma let x iq and y if ws xy qn then there is no lrf for iq proof let ws xy qn for any qn we prove that x · x is not a lrf if w x for some x x then the conclusion is clear since conditions do not hold otherwise suppose that wh y for y y thus y fails to satisfy one of conditions next we show that in such case there must exists z iq that fails either or case suppose is not satisfied that is · y choose an arbitrary x x x iq and assume that x since otherwise fails and is not a lrf note that for any integer a the integer point z x a · y is a transition in iq and z z z x x we choose a as an integer sufficiently large so that a · · y x now z · x a · y x a · · y x x so fails on z iq and thus cannot be a lrf case suppose is not satisfied that is · y y choose an arbitrary x x x iq and assume that x x since otherwise fails and is not a lrf define z as above but now choosing a sufficiently large to make a · · y y x x now z z · x a · y x a · y x x a · · y y x x x x so fails on z iq and thus cannot be a lrf note that the condition ws xy qn is equivalent to saying that the conjunction of inequalities for all x x and inequalities for all y y has no rational solution we denote this set of inequalities by ws xy note that the variables in ws xy are n which range over q and thus the test that it has no solution can be done in polynomial time since it is an lp problem over the example consider the following integer loop while x do x x x x x let x t iq and y t then ws x y is a conjunction of the inequalities the first two inequalities correspond to applying to x and the other ones to applying to y it is easy to verify that is not satisfiable thus ws x y q and the loop does not have a lrf this is a classical loop for which there is no lrf lemma provides a sufficient condition for the of lrf the next lemma shows that this condition is necessary in particular it shows that if there is no lrf for iq then the vertices and of qi serve as x and y of lemma lemma let the integer hull of the transition polyhedron q be qi yt if there is no lrf for iq then ws x yt qn proof we prove the suppose that ws x yt n q then there is n q that for all xi and for all yj we claim that x · x is a lrf for iq to see this let x x x be an arbitrary point of iq then x m i ai · xi t j bj · yj for some ai bj where m i ai now we show that x and satisfy which means that is a lrf for iq mt · x ai · · xi bj · · yj i j mt ai · · xi bj · · yj i j mt · x x ai · · xi xi bj · · yj yj i j note that the solutions of ws x yt in lemma define the set of all for iq see sec example consider again the loop of ex and recall that it does not have a lrf the generator representation of qi is qi y y where x t y t y t and y t then ws x y y y is a conjunction of the following inequalities the inequalities in the leftmost column correspond to applying to x and those in the other columns to applying to y y and y respectively it is easy to verify that is not satisfiable thus ws x y y y q corollary there is no lrf for iq iff there are two sets x iq and y such that ws xy qn the next lemma concerns the of the witness lemma if there exists a witness for the of lrf for iq there exists one with x iq and y such that x y n and the of x y is polynomial in the of the input proof recall that by lemma if iq has no lrf then ws x yt qn or equivalently ws x yt has no solution a corollary of lemma p states that if a set of inequalities over qn has no solution there is a subset of at most n inequalities that has no solution since the set of inequalities ws x yt is over qn there is a subset of at most n inequalities that has no solution this subset involves at most n integer points out of x xm and y yt because every inequality in ws x yt is defined by either one xi or yi see ­ let these points be xy then xy n and ws xy has no solution ie ws xy qn now we show that x y may be chosen to have polynomial in the size of the input recall that the input is the set of inequalities a x b that define q and its is q b recall that the points of x y in lemma come from the generator representation and that there is a generator representation in which each can fit in qi v bits thus the of x y may be bounded by n · qi v by th since the dimension of q is n n · qi v n · · n · q f n · q b which is polynomial in the of the input example consider ws x y y y of ex it is easy to see that the inequalities and are enough for n inequalities since n these inequalities correspond to x and y and thus they form a witness for the of lrf theorem for loops proof we show that the complement of has a witness the witness is a listing of sets x and y of at most n elements and has a polynomial specifically a bounded as in lemma verifying a witness consists of the following steps step verify that each x x is in iq which can be done by verifying a x c and that each y y is in which can be done by verifying a y this is done in polynomialtime note that according to lemma it is not necessary to check that x and y come from a particular generator representation step verify that ws xy qn this can be done by checking that ws xy has no solutions which can be done in polynomialtime since it is an lp problem over qn inclusion in for mlc loops in this section we consider the inclusion in for mlc loops for this we assume an input mlc loop with transition polyhedra q qk where each qi is specified by ai x ci the proof follows the structure of the case the main difference is that points of the witness x y may come from different transition polyhedra namely x x · · · xk and y y · · · yk where each xi and yi we rewrite lemmas and cor and th in terms of such witnesses the proofs are the same unless stated otherwise lemma let x x · · · xk and y y · · · yk where xi and yi if ws xy qn then there is no lrf for iq lemma for i k let be the integer hull of qi and define x x · · · xk and y y · · · yk if there is no lrf for iq then ws xy qn proof the proof follows that of lemma we pick qn ws xy and show that x · x is a lrf for each this is accomplished by performing the same calculation however referring to xi and yi when proving that is a lrf for corollary there is no lrf for iq iff there are two sets x x · · and y y · · where xi and yi such that ws xy qn lemma if there exists a witness for the of lrf for iq then there exists one with x x · · · xk and y y · · · yk where xi and yi such that x y n and the of x y is polynomial in the of the input theorem proof the difference from that of th is that the witness is given as xx · · and y y · · thus the verifier should use the appropriate set of inequalities to check that each x xi is in and that each y yi is in example consider the following integer mlc loop loop x x x x x x x x x x it is a classical mlc loop for which there is no lrf the integer hull of the corresponding transition polyhedra are qi y y y qi y where x t x t y t y t y t y t y t and y t let us first consider each path separately we get ws x y y y ws x y y y both and are satisfiable in fact their solutions define the corresponding for each path when considered separately for the mlc loop we have that ws x x y y is the conjunction of the inequalities in and which is not satisfiable thus while each path has a lrf the mlc loop does not note that the inequalities and are enough to get of thus xx and y y is a witness and consists of less than n points n in this case synthesizing a linear ranking function although the existence of a lrf suffices for proving termination generating a complete representation of the lrf is important in some contexts for instance complexity analysis where a lrf provides an upper bound on the number of iterations that a loop can perform in this section we give a complete algorithm that generates for mlc loops given by transition polyhedra q qk the following lemma is directly implied by lemmas and lemma for i k let the integer hull of qi be and define x x · · and y y · · · yk then x · x is a lrf for iq iff is a solution for ws xy the following algorithm is clearly implied compute the generator representation for each construct ws xy and use lp to find a solution for ws xy example consider again loop from sec the integer hull of the transition polyhedron is qi x y where x t x t y t and y t then ws x x y y is the conjunction of the following inequalities we eliminated clearly redundant inequalities which is satisfiable for and and therefore f x x x x is a lrf recall that this loop does not terminate when the variables range over q eg for x and x see fig a let us consider now loop from sec the integer hull of the transition polyhedron is qi x x x x x y where x t x t x t x t x t x t y t and y t then the set of inequalities ws x x y y is the conjunction of the following inequalities we eliminated clearly redundant inequalities which is satisfiable for and and therefore f x x x is a lrf recall that this loop too does not terminate when the variables range over q eg for x and x see fig c if we consider both loops and as two paths in an mlc loop then to synthesize we use the conjunction of the in equalities in and in this case and is a solution but and is not therefore f x x x x is a lrf for both paths and thus for the mlc loop but not f x x x given our results one cannot expect a polynomialtime algorithm indeed constructing the generator representation of the integer hull of a polyhedron from the corresponding set of inequalities ai x ci may require exponential number of generators itself may be exponential their on the other hand is polynomial by th this is interesting since it yields corollary given an mlc loop with transition poly q qk where each qi is specified by ai x ci if there is a lrf for iq there is one whose is polynomial in the of ai x ci namely in qi b proof as in the last section we bound the of each of the generators of by v n · qi f n · qi b for an appropriate i this means that the of each equation in ws xy having one of the forms or is at most n · qi b let p be the polyhedron defined by ws xy then p f n · qi b if ws xy has a solution then any vertex of p is such a solution and yields a lrf using th together with the above bound for p f and the fact that the dimension of p is n we conclude that there is a generator representation for p in which the p v of the vertices is bounded as follows p v · p f qi b i this also bounds the of the corresponding lrf we conclude this section by noting that the algorithm induced by lemma works also for if we consider qi instead of this can be easily proven by the proofs of lemmas and for the case of qi instead of we did not develop this line since the main use of these lemmas is proving the for this however has an interesting consequence is still even if the input loop is given in the generator representations form instead of the constraints form practically implementations of polyhedra that use of the double description method such as the polyhedra library in which both the generators and constraint representations are kept at the same time can use the algorithm of lemma when it seems better than algorithms that use the constraints representation special cases in in this section we discuss cases in which the problem is we start by a basic observation when the transition polyhedron of an loop is integral the and problems are equivalent a very similar statement appears in lemma lemma let q be a transition polyhedron of a given loop and let be a linear function if q is integral then is a lrf for q iff is a lrf for iq proof let q be integral suppose that is a lrf for q then it is also a lrf for iq since iq q suppose that is a lrf for iq it thus satisfies of def for any integer point in q however by definition of an integer polyhedron every rational point in q is a convex combination of integer points from iq this proves that satisfies conditions for any rational point as well to see this choose an arbitrary rational point x x x q it can be written as x ai · xi where ai ai and xi iq thus x x x ai ai and x · ai · xi ai · · xi x x · ai · xi · ai · xi ai · · xi xi the above lemma provides an alternative complete procedure for namely compute a constraint representation of its integer hull qi and solve note that computing the integer hull might require exponential time and might also result in a polyhedron with an exponentially big description this means that the above procedure is exponential in general but this concern is if the transition polyhedron is integral to begin with and in special cases where it is known that computing the integer hull is easy formally we call a class of polyhedra easy if computing its integer hull can be done in polynomial time x x x x x x x x x x x x x x x x x x x x x a x b x x x c figure the polyhedra associated with three of our examples to two dimensions dashed lines are added when computing the integer hull dotted areas represent the integer hull gray areas are rational points eliminated when computing the integer hull example consider again loop of sec the transition polyhedron is not integral computing its integer hull adds the inequalities x x and x x see fig c applying on this loop does not find a lrf since it does not terminate when the variables range over q however applying it on the integer hull finds the lrf f x x x corollary the problem is for loops in which the transition polyhedron q is guaranteed to be integral this also applies to any easy class of polyhedra namely a class where the integer hull is proof immediate from lemma and the fact that is corollary the problem is for loops in which the condition polyhedron c is guaranteed to be integral or belongs to an easy class and the update is linear with integer coefficients proof we show that in such case the transition polyhedron q is in fact integral and thus cor applies let c be integral and the update be x a x c where the entries of a and c are integer let x x x q that is x c and x a x c since c is integral x is a convex combination of some integer points ie x ai · xi where ai ai and xi ic hence x a ai · xi c ai · a xi c and x x x ai · xi ai · a xi c ai · xi a xi c now note that xi a are integer points from iq which implies that x is a convex combination of integer points in q hence q is integral and suggest looking for classes of loops where we can easily that q is integral or that its integer hull can be computed in polynomial time in what follows we address such cases sec discusses special cases in which the transition or condition polyhedron is integral by construction sec shows that for certain cases of per inequality constraints the integer hull can be computed in a polynomial time sec discusses the case of relations sec shows that for some cases is even strongly polynomial and sec extends the results to mlc loops loops specified by integer polyhedra there are some wellknown examples of polyhedra that are known to be integral due to some structural property this gives us classes of loops where is in the examples below are all from where the proofs of the lemmas can be found lemma for any rational matrix b the cone x bx is an integer polyhedron corollary the problem is for loops of the form while bx do x a x c where the entries in a and c are integer recall that a matrix a is totally if each of a is in ± in particular the entries of such matrix are from ± lemma for any totally matrix a and integer vector b the polyhedron p x ax b is integral for brevity if a polyhedron p is specified by ax b in which a is a totally matrix and b an integer vector we say that p is totally corollary the problem is for loops in which the transition polyhedron q is totally or the condition polyhedron c is totally and the update is linear with integer coefficients as a example difference bound constraints are defined by totally matrices such constraints have the form x y d with d q constraints of the form d can also be in the integer case we can always d to d and thus get an integer polyhedron it might be worth that checking if a matrix is totally can be done in polynomial time th p per inequality constraints in this section we consider cases in which the input loop involves per inequality constraints tvpi for brevity ie inequalities of the form ax by d with a b d q clearly polyhedra defined by such inequalities are not guaranteed to be integral see for example fig b showed that for polyhedra which are specified by tvpi constraints by definition the integer hull can be computed in om log where m is the number of inequalities and is the magnitude of the largest definition let t be a set of tvpi constraints we say that t is a product of independent tvpi constraints for brevity if it can be partitioned into t tn such that each ti is ie involves at most two variables and each distinct ti and tj do not share variables lemma the integer hull of constraints can be computed in polynomial time proof according to sec p a polyhedron p is integral iff each of its has an integer point a face of p is obtained by some inequalities to equalities such that the resulting polyhedron in not empty over the clearly if t and t are two sets of inequalities that do not share variables and their have integer points then all of t t have integer points thus t t is integral partitioning t into independent t tn and checking that each is can done in polynomial time computing the integer hull of each ti can be done in polynomial time using method the above approach can easily be generalized given any polyhedron we first decompose it into independent sets of inequalities in polynomial time these are the connected components of an obvious graph and then check if each set is covered by one of the special cases for which the integer hull can be efficiently computed corollary the problem is for loops in which the transition polyhedron q is or the condition polyhedron c is and the update is linear with integer coefficients example consider the following loop as an example for case of cor while x x do x x x x x x applying does not find a lrf since the loop does not terminate when the variables range over q eg for x and x the transition polyhedron is not integral however it is since it can be divided into t x x x x x and t x x x it is easy to check that t is already integral computing the integer hull of t adds the inequalities x x and x x see fig c now finds the lrf f x x x example consider the following loop as an example for case of cor while x x x x x do x x x x x x x x applying does not find a lrf since it does not termi over q eg for x x and x the condition polyhedron is not integral but it is since the constraints can be divided into t x x x x and t x it is easily seen that t is already integral computing the integer hull of t adds x see fig b now finds the lrf f x x x x x note that the update in this loop involves constraints which are not tvpi relations tvpi constraints in which the coefficients are from ± have received considerable attention in the area of program analysis such constraints are called relations a particular interest was in developing efficient algorithms for checking ability of such relations as well as inferring all implied inequalities for variables ranging either over q or over z over q this is done by computing the transitive closure of the relation which basically adds inequalities that result from the addition of two existing inequalities and possibly scaling to ob coefficients of ± eg starting from the set of inequalities x x x x we add x or after scaling x over z this is done by computing the tight closure which in addition to transitivity is closed also under tight this operation replaces ax by d by ax by d for example x yields x the tight closure can be computed in polynomial time since the eliminates some points it is to expect that it actually computes the integer hull it is easy to show that this is true for relations but it is false already in three dimensions as we show in the following example example consider the following loop while x x x x x x do x x x x x x note that the transition polyhedron is but not integral applying does not find a lrf since the loop does not terminate over q eg for x x and x computing the tight closure does not change the transition or condition polyhedron and thus it is of no help in finding the lrf in order to obtain the integer hull of the transition or condition polyhedron we should add x x x which is not an inequality having done so finds the lrf f x x x x x x although it is not guaranteed that the tight closure of an relation corresponds to its integer hull in practice it does in many cases thus since it can be computed in polynomial time we suggest computing it before applying on loops that involve such relations the above example shows that this does not give us a complete polynomialtime algorithm for over relations example consider the following loop while xx x x x x x x do x x x x x x x x the condition polyhedron is but not integral moreover it is not does not find a lrf indeed the loop fails to terminate for x x x computing the tight closure of the condition adds x and x which results in the integer hull now finds the lrf f x x x x x a polynomialtime algorithm for computing the integer hull of relations is unfortunately out by examples of such relations whose integer have exponentially many theorem there is no polynomialtime algorithm for computing the integer hull of general relations proof we build an relation o such that the minimum number of inequalities required to describe its integer hull oi is not polynomial in the number of inequalities in o for a complete graph kn v e we let p be defined by the set of inequalities xe e e ve xe v v here every edge e e has a corresponding variable xe and the notation v e means that v is a vertex of edge e note that p is not it is wellknown that pi the matching of kn has at least n n sec p and thus any set of inequalities that defines pi must have at least the same number of inequalities now let o be defined by xe e e xe xe v e v e which includes n n · n inequalities it is easy to see that the integer solutions of p and o are the same and thus pi oi this means that any set of inequalities that define oi must have at least n n inequalities therefore any algorithm that computes such a representation must add at least n n n n · n inequalities to o which is super polynomial in the size of o the tight closure of o does not yield its integer hull it only adds xe for each xe note that the above theorem does not rule out a polynomialtime algorithm for for loops in which the transition polyhedron q is or where the condition polyhedron is and the update is linear with integer coefficients it just rules out an algorithm that is based on computing the integer hull of the polyhedra however the proof of sec could be also carried out by a reduction from sat that produces an loop where the condition is and the update is linear with integer at least for this class there is no polynomial solution this reduction can be found in the technical report strongly polynomial cases polynomialtime algorithms for inherit their complexity from that of lp while it is known that lp can be solved by a polynomialtime algorithm it is an open problem whether it has a strongly polynomial algorithm such an algorithm should perform a number of elementary arithmetic operations polynomial in the dimensions of the input matrix instead of its which accounts for the size of the matrix entries and such operations should be performed on numbers of size which is polynomial to the input however there are some cases for which lp is known to have a strongly polynomial algorithm we first use these cases to define classes of loops for which has a strongly polynomial algorithm which we then use to show that has a strongly polynomial algorithm for some corresponding classes of loops our results are based on the following result by from p theorem there exists an algorithm which solves a given rational lp problem · x ax b with at most p elementary arithmetic operations on numbers of size bounded by b c for some polynomial p note that the number of arithmetic operations required by the lp algorithm only depends on the of a clearly if we restrict the lp problem to cases in which the of the entries of a is bounded by a constant then depends only on its dimensions and we get a strongly polynomial time algorithm in particular we can state the following corollary there exists a strongly polynomial algorithm to solve an lp problem · x ax b where the entries of a are ± ± we can use this to show that can sometimes be implemented with strongly polynomial complexity to do this we use the formulation of the procedure slightly modified to require that the lrf decreases at least by instead of by some theorem given an loop with a transition polyhedron q qn specified by a x c let a a a where each a and a has n columns and m rows and let µ be row vectors of different m rational variables each a lrf for q exists iff there is a rational solution to the following set of constraints µ t a µ · a t b µ · a t c · a a t d · c e theorem the problem is decidable in strongly polynomial time for loops specified by a x c where the coefficients of a are from ± proof first observe that in th when the matrix a has only entries from ± then all coefficients in the constraints d are from ± ± moreover the number of inequalities and variables in is polynomial in the dimensions of a now let us modify the procedure such that instead of testing for feasibility of the constraints we consider the minimization of · c under the other constraints clearly this answers the same question since e is feasible iff the minimization problem is unbounded or the minimum is negative this the problem to the form required by cor and yields our result corollary the is decidable in strongly polynomial time for loops specified by a x c that are covered by any of the special cases of and and the entries of a are from ± proof in the cases of sec the transition polyhedron is guaranteed to be integral in the case of sec the integer hull can be computed using procedure which is strongly polynomial in this case since the entries of a are from ± this can be done also using the tight closure of dimensional and the tvpi constraints that we add when computing the integer hull have coefficients from ± and the number of such constraints is bounded by the number of the original inequalities thus by th we can apply a strongly polynomialtime algorithm for loops recall that a linear function is a lrf for an mlc loop with transition polyhedra q qk iff it is a lrf for each qi thus if we have the set of for each qi we can simply take the intersection and obtain the set of for q qk in the procedure the set of solutions for the inequalities defines the set of for the corresponding loop as follows lemma given an loop with a transition polyhedron q specified by a x c let µ a c be the conjunction of then x · x is a lrf for q iff µ a c has a solution such that and the following lemma shows how to compute using the above lemma the intersection of sets of for several transition polyhedra and thus obtain the set of for a given mlc loop a very similar statement appears in lemma lemma given an mlc loop with transition polyhedra q qk each specified by ai x ci let i ai ci be the constraints for the ith path and be n rational variables then there is a lrf for q qk iff the following is feasible over the k i ai ci i · ai · ci i moreover the values of in the solutions of define the set of all for q qk proof immediate by lemma noting that for each i the con i ai ci use different and i while are the same for all i corollary the problem for mlc loops is proof the size of the set of inequalities is polynomial in the size of the input mlc loop and checking if it has a rational solution can be done in polynomial time corollary the problem for mlc loops is when each path corresponds to one of the special cases for loops discussed in and proof immediate since if the transition polyhedra are integral and are equivalent example consider an mlc loop with the following two paths loop of sec and the loop of ex applying as in lemma does not find a lrf since both paths do not terminate when the variables range over q if we first compute the integer hull of both paths finds the lrf f x x x x note that the integer hull of the first path is computable in polynomialtime since the condition is and the update is linear with integer coefficients that of the second path is also computable in polynomialtime as in ex prototype implementation the different algorithms presented in this paper both for the general case and the special cases have been implemented the tool receives as input an mlc loop in constraints representation and allows applying or it can be tried out via where all examples of this paper are also available the implementation includes the algorithms of lemmas and by default it uses the second one since the first one requires generating the generator representation of the transition polyhedron which is exponential computing the integer hull of a polyhedron in the case of is done by first its set of inequalities into independent sets and then computing the integer hull of each set separately each set of inequalities is first matched against one of the cases of and if this matching fails it computes the integer hull using algorithm as explained by et al note that this algorithm supports only bounded polyhedra the integer hull of an unbounded polyhedron is computed by considering a corresponding bounded one th p in addition for relations it gives the possibility of computing the tight closure instead of the integer hull as we have seen in sec when this option is used completeness of is not guaranteed the polyhedra library is used for converting between generator and constraints representations solving mixed lp problems etc related work there are several works that directly address the problem for or mlc loops in all these works the underlying techniques allow synthesizing and not only deciding if one exists the common observation to all these works is that can be done by inferring the implied inequalities of a given polyhedron the transition polyhedron of the loop in particular inequalities like conditions and of def that define a lrf regarding completeness all these methods are complete for but not for they can also be used to approximate by the loop such that its variables range over q instead of z thus completeness all these methods have a corresponding algorithm exceptions in this line of research are the work of et al and cook et al that directly address the problem for mlc loops and van considered mlc loops with variables ranging over n these are abstractions of loops from logic programs the loops were in fact relaxed from n to q before a lrf however this is not explicitly mentioned the main observation is that the duality theorem of lp p can be used to infer inequalities that are implied by the transition polyhedron the authors also mention that this was observed before by in the context of solving queries completeness was not addressed in this work and the complexity was mentioned but not formally addressed later and formally proved that the techniques of and van provide a complete method for also for the case of mlc loops they pointed out the incompleteness for probably the most popular work on the synthesis of is the one of podelski and rybalchenko they also observed the need for deriving inequalities implied by the transition polyhedron but instead of using the duality theorem of lp they used the affine form of lemma p completeness was and the statement did not make it clear that the method is complete for but not for this was however in the phd thesis of rybalchenko et al proved that the methods of and van and podelski and rybalchenko are actually equivalent ie they compute the same set of they also showed that the method of podelski and rybalchenko can potentially be more efficient since it requires solving rational constraints systems with fewer variables and constraints the of a solution based on lemma that we know of are by and in the context of termination analysis and by in the context of automatic parallelization of computations and did not claim that the problem can be solved in polynomial time and indeed their implementation seems to have exponential complexity since they use generators and despite the similarity of the underlying theory to that of completeness was however it was not explicitly mentioned that the variables range over q and not z described scheduling of computations that can be described by recursive equations an abstraction to a form similar to an mlc loop allowed to compute a socalled schedule which is essentially a ranking function but used backwards since the computations at the bottom of the recursion tree are to be completed first cook et al observed that the based solution is complete for when the input mlc loop is specified by integer polyhedra they also mention that any polyhedron can be converted to an integer one and that this might increase its size exponentially unlike our work they do not address cases or the complexity of in fact the main issue in that work is the synthesis of ranking functions for relations et al directly addressed the problem for mlc loops and stated that the methods of and and podelski and rybalchenko are not complete for their technique is based on the observation that if there is a lrf then there exists one in which each i has a value in the interval and moreover with that are power of using this observation they recursively search for the coefficients starting from a region defined by a in which each i is in the interval given a the algorithm first checks if one of its defines a lrf in which case it stops otherwise the region is either if it can be verified that it contains no solution or divided into smaller regions for recursive search testing if a region should be is done by checking the satisfiability of a possibly exponential in the number of variables number of presburger formulas the algorithm will find a lrf if exists but it might not terminate if no lrf exists to make it practical it is parametrized by the search depth thus completeness it is interesting to note that the parameter in their algorithm actually bounds the of the lrf coefficients our cor shows that it is possible to bound this depth that their algorithm into a complete one though still exponential et al studied the synthesis of for loops with constraints ie of the form xi xj c where c and monotonicity constraints ie of the form x y c where x and y are variables or variables and c in both cases the variables ranged over n for constraints they proved that the loop terminates iff a lrf exists moreover such function has the form i · xi with i for the case of monotonicity constraints they proved that the loop terminates iff a lrf exists for the balanced version of the loop and has the form i · xi with i ± intuitively a balanced loop includes xi xj c iff it includes xi xj c they showed how to balance the loop while preserving its termination behavior recently et al presented similar results for loops defined by relations et al extended the work of and and in they considered loops with polynomial transitions and the synthesis of polynomial ranking functions where the notion of ranking functions was also relaxed to functions that eventually decrease cousot used relaxation for inferring possibly nonlinear ranking functions in the linear case relaxation is similar to the affine form of lemma alias et al again the based solution for or rather it from the former work by but this time for termination and cost analysis like they construct however they do it for programs with an arbitrary controlflow graph and they prove completeness of their procedure their goal was to use these functions to derive cost bounds like a bound on the worstcase number of transitions in terms of the initial state this bound is when it can be found a polynomial whose degree is at most the dimension of the codomain of the ranking function alias et als construction produces a function of minimum dimension they too have relaxed the problem from integers to and failed to state that their completeness results depend on this relaxation decidability and complexity of termination in general not necessarily with of and mlc loops has been studied for different classes of constraints for loops proved that the problem is decidable when the update is linear and the variables range over r proved that this holds also for q and for the case it holds for z both considered universal termination also in both cases they allow the use of strict inequalities in the condition et al showed that the termination of loops is at least and that the problem is undecidable for some extensions that introduce a simple form of and also for loops in which the use of a single is allowed see these works for references to additional results on the decidability of termination in other types of loops remarks we have studied the linear ranking problem for and linear constraint loops and observed the difference between the problem where variables range over the and the problem where variables only take integer values in practice the latter is more common but the complexity of the problem has not been studied before the common approach has been to relax the problem to the where complete polynomialtime decision procedures have been known we have that is a harder problem proving it to be on a positive note this shows that there is a complete solution even if we further showed that some special cases of importance do have a solution the latter results arise from a proof that for integer polyhedra and are equivalent interestingly this is not the case for termination in general for example the transition polyhedron of the loop while x do x x is integral the loop terminates when the variables range over z but does not terminate when they range over q specifically for x note that this loop does not have a lrf over the integers a more general notion of ranking function applies to an controlflow graph with transitions specified by source and target nodes as well as linear constraints on the values of variables in this setting one to associate a possibly different affine function with each node so that on a transition from to we have x x such functions can be found by lp a procedure complete over the using a simple extension of the solution for the loops we have discussed the consider regarding the complexity of the corresponding problem over integers are essentially the same as those we have presented and we to use the simpler model for presentation in all examples that we have discussed in this paper when a loop has a lrf over z but not over q then the loop did not terminate over q this is however not the case in general a counterexample can be constructed by combining ie executing simultaneously the loop of ex and loop of sec in the context of complexity cost analysis there is a special interest in that decrease at least by in each iteration since they bound the number of iterations of a given loop in order to get tight bounds even if q has a lrf it might be to compute one for iq to see this let us add x to the condition of loop in sec then both q and iq have for iq the most tight one under the requirement to decrease by at least is fx x x x while for q it is fx x x x hence a better bound is obtained using iq the same observation applies to loop parallelization the functions value gives the schedules depth of the computation tree and a lower value is acknowledgments we thank for a helpful discussion the work of was in part by the eu project and the projects and references e p s g and d design and implementation of a cost and termination analyzer for java bytecode in f s de m m s and w p de editors formal methods for components and objects volume of lncs pages ­ springer e p s and g upper bounds in static cost analysis j reasoning ­ c alias a p and l program termination and complexity bounds of flowchart programs in r cousot and m editors static analysis symposium sas volume of lncs pages ­ springer r p m hill and e an improved tight closure algorithm for integer constraints in f d and l d editors verification model checking and abstract interpretation volume of lncs pages ­ springer r p m hill and e the polyhedra library toward a complete set of numerical abstractions for the analysis and verification of hardware and software systems sci comput program ­ r f a and e a new look at the automatic synthesis of linear ranking functions inf comput ­ a m termination with difference constraints acm trans program lang syst a m and s on the linear ranking problem for integer loops abs a m s and a n on the termination of integer loops in v and a rybalchenko editors verification model checking and abstract interpretation volume of lncs pages ­ springer m r and f deciding conditional termination in c flanagan and b editors tools and algorithms for the construction and analysis of systems tacas volume of lncs pages ­ springer l and s verification of constraint abstractions of counter systems in v and a rybalchenko editors verification model checking and abstract interpretation volume of lncs pages ­ springer a r z manna and h b linear ranking with reachability in k and s k rajamani editors computer aided verification cav volume of lncs pages ­ springer a r z manna and h b termination analysis of integer linear loops in m abadi and l de editors concurrency theory concur volume of lncs pages ­ springer a r z manna and h b the principle in l g f l c and m editors international colloquium on automata languages and programming icalp volume of lncs pages ­ springer a r z manna and h b termination of polynomial programs in r cousot editor verification model checking and abstract interpretation volume of lncs pages ­ springer m termination of integer linear programs in t ball and r b jones editors computer aided verification cav volume of lncs pages ­ springer m m j p s and w termination analysis of logic programs through combination of typebased acm trans program lang syst p j j m and a integer polyhedra for program analysis in a v and y editors algorithmic aspects in information and management volume of lncs pages ­ springer m v and p j testing for termination with monotonicity constraints in m and g gupta editors international conference on logic programming volume of lncs pages ­ springer m and h synthesis of linear ranking functions in t and w yi editors tools and algorithms for the construction and analysis of systems tacas volume of lncs pages ­ springer b cook a podelski and a rybalchenko termination proofs for systems code in m i and t ball editors programming language design and implementation pldi pages ­ acm b cook d p and c m ranking function synthesis for relations in j and r majumdar editors tools and algorithms for the construction and analysis of systems th international conference tacas volume of lncs pages ­ springer p cousot proving program invariance and termination by parametric abstraction relaxation and programming in r cousot editor verification model checking and abstract interpretation volume of lncs pages ­ a understanding loops the influence of the decomposition of and in formal methods and models for pages ­ ieee computer society p some efficient solutions to the affine scheduling problem i time international journal of parallel programming ­ m r and d s johnson computers and wh and co new york j r p and s automated termination proofs with in v van editor rewriting techniques and applications volume of lncs pages ­ springer m e and the complexity of the integer hull phd thesis school of operations research and engineering cornell university w computing integer siam j comput ­ w and p j a unit two variable per inequality integer constraint solver for constraint logic programming in computer science conference pages ­ r m among combinatorial problems in r e and j w editors complexity of computer computations pages ­ press new york r m and c h on linear of combinatorial optimization problems in symp on foundations of computer science pages ­ ieee computer society jl constraints in symposium on principles of database systems pages ­ acm press c s lee n d jones and a m the principle for program termination in c and d editors symposium on principles of programming languages popl pages ­ n and y sagiv automatic termination analysis of prolog programs in l editor international conference on logic programming pages ­ mit press f and a recurrence with affine level mappings is decidable for ­ a the abstract domain higherorder and symbolic computation ­ mar a podelski and a rybalchenko a complete method for the synthesis of linear ranking functions in b and g editors verification model checking and abstract interpretation volume of lncs pages ­ springer p z transitive closure of integer addition constraints in v and j c editors symposium on abstraction and approximation a rybalchenko temporal verification with transition invariants phd thesis des a theory of linear and integer programming john and sons new york k and a v termination detection in logic programs using argument sizes in d j editor symposium on principles of database systems pages ­ acm press f f and a termination analyzer for java bytecode based on acm trans program lang syst va a strongly polynomial algorithm to solve combinatorial linear programs operations research ­ a termination of linear programs in r and d editors computer aided verification cav volume of lncs pages ­ springer 