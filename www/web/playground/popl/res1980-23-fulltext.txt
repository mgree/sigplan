an daniel david p friedman s university abstract this paper proposes the and control of parallel processes within data structures the advantage of embedding the contention within data ls that the contention it self thereby becomes an object which can be handled by the program at a level above the actions of the processes them this means that an behavior never precisely by the programmer or by the input may be shared in the same way that an argument to a function is shared by every use of the corresponding parameter an ability which is of particular importance to programming introduction this paper proposes the and control of parallel processes examples within requiring data structures such control arise in systems programming and have been handled by suited to the programming style a typical construct in is programming problems whose solutions require such control include interrupt handlers merging of input streams and the problem the advantage of embedding the research reported was supported in part by the national science found ation under grants and ao permission to copy without fee all or part of of or are copies the to prior machinery to copy cm requires a fee and or specific permission contention within the data structure is that the contention itself becomes an object which can be handled by the pro gram at a level above the actions of the processes themselves this means that an behavior never specified by the programmer or by the input may be shared ln the same way that an argument to a procedure is shared by every use of the corresponding parameter an ability which is of particular import to programming gives a history and arguments this approach this paper is in four parts a brief section the traditional record handling primitives of lisp is followed by a section which refines and defines one new primitive the constructor and the generalization of list struct which may be built with it the next we present a section of examples a stream merge an interrupt handler and a scheduler for a operating system finally we relate to other approaches primitives a of elements is denoted by enclosing the elements in brackets se k q a sequence evaluates to the of the values of those elements in the order like evaluation of sequences are used both as data structures and to multiple arguments as a single unit for function a function application is indicated by a infix between a function and its single argument this convention is illustrated the following definitions of several lisp primitives take k above acm el car k cdr s e el e ek e null atoms car i then el in the a modern perspective for the constructor function is essential the first two lines of table the difference between tional whose arguments are and our whose arguments are or difference arises the from the independence the two axioms y x and y y contents determined construction time construction time construction time permutation determined construction time construction time time contents evaluated construction time time table record constructors under this semantics the expression which specifies any element or any suffix of a sequence is not evaluated until that part value is accessed or that fs the content of any newly constructed sequence and thus any argument in an argument sequence is e indicates expression diverges evaluation that the evaluation of e does not terminate if not e then e of e terminates or con the value operational semantics necessary to this is available this allows the conditional i to be defined as an function without about tion of irrelevant arguments like which is undefined above under this y for any x an y rather than use conventions to define other functions we shall new functions from old ones using a pattern equivalent to a prototype tion id tbe id tb than thus but car null because evaluation of the second argument evaluation of the third multisets the function is because the order of arguments need not matter for commutative with like ok true false and zero are for disjunction conjunction and integer product respect let us concentrate upon the structure of the argument a like a sequence is composed of k elements but whose order is not upon construction are used of the m el e cl like a sequence a multiset evaluates to a list of the evaluations of elements but unless it is those elements are never evaluated if it is completely then its value itself as one of the permutations of the evaluations of its elements instances where one or more elements yield divergent evaluations a complete are of particular interest we develop an operational semantics for and extended to multisets which requires that the of any set be the evaluation of one of its elements if such an element exists and that the be the multiset with that such an interpretation evaluations of elements set proceed together element will require that within a with behavior this semantics results from the desired the form car null with no change to the definition of either sequential or symmetric disjunction l is obtained merely changing the argument structure oa by just as semantics obtained simply by the semantics obtained by defining multiset constructor for sequences may be defining the primitive for multisets may be semantics for the let m et e ek then m e el e ek m null y ae the properties of the new are summarized in the last line of table as in our perspective on contents are determined at construction time but not evaluated until the struct is the y for all xy difference is that of the permutation of a structure using on is until it is the permutation of a structure built is precisely that of its construction the existence of two const questions of their in built struct such a a generalization of both a sequence and a multiset is called a whose leaves are associated with the constructor its name in order to explain the definition we shall refine it from of a multiset because once itself as a list is introduced through ambiguity operator evaluation of y yields the value of x when y yields the value of y when x and either one of the two values when both x and y an alternative example is to semantics for r for this particular adopt conditional expressions consider y each of is evaluated once under the scheme which we have already associated with this results in a which is because the choices may be inconsistent with respect to one another we would not want one to choose its second alternative while the other chose its first for example x never appear in the resulting list this problem is eliminated if we have only one instance of making a single choice for instance of in order to make this step we must define the primitive b whenever a b b whenever a it is necessary that in both its parameters l be strict then y y cdr y this definition yields the desired consistency but it does not evaluation of its arguments as did the preceding we do not want evaluation of x or y to proceed until later when the multiset is the solution requires what appears to be an identity function to prevent evaluation of until the multiset is actually y y examples the preceding definition provides a data structure whose content is specified when it is constructed but whose order depends on the convergence of tions which were only specified then such computations might be of unknown to the programmer or they might be simple computations dependent on external events occur in an order in the example below we are dealing with a multiset of sequences each sequence is to be treated as a stream which should be ignored until its first element has every element of this set would converge like any data structure under a delayed evaluation scheme unless we every sequence using k the appropriate of the content of multisets depends on the structure and convergence desired of its elements but ft allows the selection of complex results based on simple convergence this then is the essential use of the which violates callbyneed protocol and sequential evaluation of lts arguments in order to demonstrate the facility of programming with the new constructor we present an operation in an applicative style since the is isolated into the data structure the program is rather simple the problem is that of a multiset m sf s sk of sequences sl into one sequence in this example the argument is much like a matrix except that we allow for arbitrary bounds ie the number of rows and the number of elements in each row may be unbounded in which case the first two of are id m id cdr cdr m lie the four of the two in if both were then would append all the rows of m in the order they are presented in m if the first row of m is unbounded then that row is copied when the const are as in the definition of the effect s to the various rows of m so the order of each one is but elements from other rows may be in the final result if both constructors were the effect would be to allow any of all the elements of the array as an ordering in the result in the case that the first constructor were and the second were con a would result but elements in the result restricted to rows only up through the first one in m if we had port number i as to take a i l i i then the merge would produce a sequence of ordered pairs as the product of an handler the final example is a particular kind of process scheduler which takes as its two arguments a sequence of expressions and an integer time and returns as its value a list of those expressions still not completely evaluated which do not converge after that amount of time this problem can be expanded to a more complete scheduler which also returns a second result the list of values which converge within the time two functions are the takes the original expressions and it multiset necessary sequence into a of id ele a second function s which is its implementation like that of cannot be optimized it not behave as intended its purpose is to delay its convergence by an amount of time tional to its integer argument like an interval an argument twice as large will cause it to delay about twice as long upon convergence its value is a value assumed to be different from those of the scheduled expressions l then then the solution to our scheduler problem may be defined as time where d then bk relation to other work there have been many other attempts to introduce intermediate behavior in a controlled way into programming languages and models of computation the operator implements in determinate behavior results are not necessarily its failing is that there is no way of knowing which argument was chosen andor the one in order to resume its tation later others have developed variations on eg developed a function which allowed for with a finite number of choices and and introduced choice and runtime choice introduced an into the data flow approach which produces a tagged merge of streams the arbiter is similar to the interrupt handler given earlier but since it is as a hardware primitive it may only have a finite number of input streams using the arbiter an system and have developed an unordered structure called a bag but a bag contains only elements making it for our purposes we have all in data structures where the pro may ignore it after he has his multiset a significant of the applicative style to this development is the experience with an applicative which allows the introduction of behavior as a trivial in style a good programmer follows a few simple rules dont compute the same thing twice never build the same structure twice etc the use of the second rule is applied when a good programmer a reference to a shared structure rather than copying it the point here is that the of data structures has precisely the same pro gramming practice which is required of properly controlled in an applicative programming language so that the makes sense references j can programming from the von be style a functional style and its algebra of programs comm acm august w h technique reading massachusetts addisonwesley j b first version of data flow language in b cd berlin springer j b a language for structured concurrency in and o language j h and d a eds berlin springer d p friedman and d s cons should not evaluate its arguments in automata and s and r milner eds edinburgh edinburgh press d p friedman and d s a note on conditional expressions comm acm november d p friedman and d s applicative technical report no computer science department university d p friedman and d s an approach to fair applicative in computation g kahn cd berlin springer d t good r m and j principles of proving concurrent programs in acm symp on o p and j h morris jr a lazy evaluator red kd acm symp on m c b hennessy and e a nondeterminism symp on mechanisms and acm o r m denotational models for parallel programs with in operators in e j cd amsterdam northholland p r for operating a data flow language systems programming am sigplan notices september p j a correspondence between algol and lambda notation comm acm february i j a basis for a theory of computation in and p and d eds amsterdam northholland j p w d j t p and m e lisp cambridge massachusetts mit press z manna o new york chapter j correct and optimal implementation of recursion i a simple programming language comp sys sci june c and o phd dissertation oxford r j and k n about programs artificial intelligence fall s a functional o phd dissertation mit 