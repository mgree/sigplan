defining attacks department of computer science and engineering university of abstract this paper shows that existing definitions of attacks eg attacks are the make it possible for to existing mechanisms by inputs that are not recognized as such the also make it possible for inputs to be treated as attacks after describing these in conventional definitions of attacks this paper proposes a new definition which is based on whether the symbols input to an application get used as values in the applications output because values are already fully evaluated they cannot be considered code when injected this simple new definition of attacks avoids the problems of existing definitions improves our understanding of how and when such attacks occur and enables us to evaluate the effectiveness of mechanisms for such attacks categories and subject descriptors c computer communication networks and protection d programming languages formal definitions and general terms security languages algorithms introduction as the of web applications has increased so have reports of attacks against them ­ the most commonly reported type of attack involves code into a program output by an application as in attacks standard examples of attacks include an attacker entering the following strings as input to an application · or to make the application output the program select balance from where password or symbols are those the attacker has injected into the output program this sql program always returns the from the table even though an password is supplied because the subexpression is true making the entire where clause true and the command comments out the final to make the program syntactically valid in this case the attacker has injected the code symbols or and into the output program · exit to make the application output the program select balance from where in this case the attacker has injected the code symbols exit into the output permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm program to a attack against the remote database these attacks are commonly referred to as attacks or attacks or just ias but here we use the more specific term attacks on outputs ciaos to distinguish these attacks which require code to be injected into an applications output from more general notions of which require code to be injected only into memory used by an application eg much research has focused on mechanisms for ciaos and a few efforts have been made to define ciaos however as section discusses existing definitions are based on the that ciaos occur whenever an applications input the syntactic structure of its output program ciaos with changes to syntactic structures causes existing definitions to be neither sound nor complete some ciaos are not recognized as ciaos false and some are recognized as ciaos false positives the false allow to existing mechanisms for preventing ciaos without a satisfactory definition of ciaos we cant effectively develop or analyze mechanisms for them preventing ciaos in general requires understanding exactly how and when they succeed as sun the art of expresses it if you know but not the for every you will also a this is a paper about knowing the it defines precise under which ciaos can be said to occur defining ciaos requires two first we must define which symbols in applications output programs constitute code second we must define when symbols have been injected into output programs the primary contribution and of this paper lies in the first of these the second can be with wellknown but techniques of taint tracking for the first this paper defines code significantly differently from previous of code being symbols code here refers to symbols that do not form values ie fully evaluated terms this paper that ciaos occur when at least one symbol injected into an output program is used outside of a value to keep the definitions general this paper tries to abstract as much as possible from underlying languages programs and system architectures although the definitions will require a few technical assumptions about the languages of applications output programs such as that they have a welldefined set of values this papers definitions are not limited to sql or other popular programming languages the new definition of ciaos applies equally well to other attacks eg and attacks similarly the only assumption we make of applications is that inputs can be correctly tracked through them so we know which symbols in their outputs have been injected summary of contributions and this paper demonstrates problems in the conventional definition of ciaos in section the problems make existing mechanisms neither sound nor ciaos are considered while some are considered attacks after discussing previous work the paper presents in sections ­ a new definition of ciaos that avoids these problems ultimately a definition of ciaos has two important highlevel uses first a definition of ciaos enables us to precisely determine whether applications exhibit ciaos we put the new definition to this first use by the new definitions improved ability to determine whether applications exhibit ciaos primarily in section second a definition of ciaos enables us to analyze the effectiveness of mechanisms at ciaos we put the new definition to this second use by analyzing the effectiveness of several classes of mechanisms for detecting ciaos in section more specifically several properties of ciaos become apparent by considering the new definitions · defining ciaos as occurring when symbols get injected into output programs improves our ability to recognize attacks we illustrate the improvements in an version of sql called sql sql sections ­ · ciaos can be classified as or depending on how applications propagate untrusted inputs into output programs section · a class of attacks related to ciaos exists which we call attacks the definition of these attacks takes into account control dependencies ignored by mechanisms section · surprisingly every application that always copies some untrusted input into an sql output program is to ciaos section this result implies that sound static mechanisms for detecting ciaos must all such applications conservatively out a large class of applications in practice the proof of this result in section is constructive the proof defines inputs that will successfully attack any application that copies some untrusted input into the output program although the proof is to sql the proof techniques are general and applicable to other languages · similarly applications that always copy some untrusted input into an sql output program are to attacks section · neither static nor analysis of applications can precisely detect ciaos section · precisely detecting ciaos requires mechanisms under reasonable assumptions such mechanisms can detect ciaos in output programs of size n in on time and space however there are that make it difficult to implement such mechanisms in practice sections ­ after presenting these results in sections ­ section concludes related work ciaos are considered to occur whenever an applications input the intended syntactic structure of its output program and call this a principle in other works on detecting sql injection indeed this definition has appeared in many documents ­ although a few papers define ciaos in other ways eg ciaos occur exactly when keywords or operators get injected including used to form string values in sql or when injected strings span multiple tokens the conventional definition dominates the literature however the conventional definition of ciaos has inherent problems some ciaos do not alter the syntactic structures of output programs while some do to illustrate these problems sections and discuss the conventional definitions of ciaos used by and as far as were aware these are the only existing formal definitions of ciaos ciaos in considers the intended syntactic structure of an output program to be any parse tree in which each injected input is the complete derivation of one terminal or nonterminal for example parsing the output program select balance from where password or produces a parse tree in which the injected symbols or are not the complete sequence of leaves for a single terminal or nonterminal ancestor therefore this ciao however some of what considers intended ie structures are actually attacks for example parsing the output program select balance from where produces a tree in which the input symbols exit are the complete sequence of leaves for a single nonterminal ancestor hence does not recognize this ciao as an attack similarly an output program of the form where be recognized as an attack despite the injection of a operator which may allow an attacker to efficiently extract the value of the global variable by performing a binary search over its range although allows policy to specify a set of terminal and nonterminal ancestors that inputs may derive could inputs derived as and comparison how an would know exactly which ancestors to allow derivations from moreover may wish to sometimes allow and sometimes inputs to derive from particular terminals and nonterminals as illustrated in section which is impossible in conversely some of what considers ie attack structures are actually not attacks for example an application might input two strings a file name f and a file extension e and them to generate the program select from properties where although the user has injected no code flags this output as a ciao because the users inputs are not complete sequences of leaves for a single terminal or nonterminal ancestor in this case the immediate ancestor of the users inputs would assuming a typical grammar be a string literal but neither of the users inputs form a complete string missing the dot and symbols the papers describe other problems with definitions ciaos in considers the intended syntactic structure of an output program generated by running application a on input i to be whatever syntactic structure is present in the output of a on input here vr is a valid representation function that converts any input i into an input i known to be valid ie and cause a to follow the same controlflow path as it would on input i begins by assuming this vr function exists while that it does not in this basic case all major sql implementations we are familiar with allow statements to call functions including functions defines a ciao to occur when as output on input i has a different syntactic structure from as output on input besides the of function vr there are some problems with this definition of ciaos first the definition is circular ciaos are defined in terms of vr which itself is assumed to output inputs ie the definition of ciaos relies on the definition of vr which relies on the definition of ciaos second the definition assumes that multiple valid syntactic structures cannot exist for example suppose and application a on input outputs select from t where name in ab while a on input executes in the same way to output select from t where name in both of these outputs are valid sql programs yet the programs have different syntactic structures a list versus a list and neither a ciao in no case has code been injected only values which take no steps dynamically have been injected would classify the input of as an attack in this case to deal with the of function vr attempts to approximate vr by defining to be when i is an integer and ai when i is a string where ai is a sequence of as having the same length as i a concrete definition of vr the circularity problem in basic definition of ciaos but it doesnt resolve the second problem described in the previous that multiple valid syntactic structures may exist moreover approximation of vr creates new problems · the approximation assumes a string of as or a could never be attack inputs an application could an input a or into an output program as part of a function call field selection or even keyword eg and all of which could be ciaos for example suppose an application outputs a constant string its input and then outputs parentheses on input exit it outputs the program would not recognize this ciao because the application outputs on input which has the same syntactic structure as the output the problem here is that is actually an attack input for this application · the approximation may also cause inputs to be detected as attacks for example suppose an application outputs select from t where on input true and follows the same controlflow path to output select from t where on input because these two output programs have different syntactic structures a boolean literal versus a variable identifier would flag the input true as an attack even though the user has injected no code · the approximation can also break applications as discussed in to illustrate this problem lets consider the application then else cannot in general operate on this application because it evaluates applications on both actual i and candidate inputs while following the controlflow path required to evaluate the actual input in this case whenever the applications actual input is greater than one will try to evaluate input on the candidate input which causes the application to halt with a error despite there being no errors in absence it could be argued that the example applications in the above would be in practice but limiting the definition of ciaos to common applications us to define what makes an application common so we can test whether a given application is common enough for the definition of ciaos to apply even then one say anything about ciaos in applications summary ciaos cannot be said to occur when an applications output program has an syntactic structure · ciaos can occur without the syntactic structure of output programs eg by exit or global in or exit in · can occur while the syntactic structure of output programs eg by file name f and extension e in or true in partitioning program symbols into code and this section begins building a new definition of ciaos because ciaos occur when code symbols get injected into output programs the question of which symbols constitute code is key to defining ciaos this section addresses that question and defines how to separate code from the discussion is limited to the context of ciaos in other contexts it makes sense to consider entire output programs as code overview of partitioning technique lets begin by defining what is not code rather than what is this paper considers to be the closed values in a programming language values are valid but operationally irreducible terms ie normal forms values can be thought of as the fully evaluated computations in a programming language typically including string and integer literals pointers objects lists and tuples of other values etc values are closed when they contain no free variables open values have free variables eg a tuple value like x and variables are open values closed values are fully evaluated dynamically passive constructs which by themselves cause no dynamic computation to occur on the other hand because and open values are not part of these passive terms they are used to help specify dynamically active computation and therefore constitute code in the case of open values the dynamic activity specified by a free variable is a substitution operation which a term for the free variable at runtime symbols that only form closed values into an output program therefore cannot be considered a irreducible dynamically passive terms ie will have been introduced ciaos occur when untrusted inputs get used outside of closed values in output programs formal assumptions and definitions an application to ciaos outputs programs in some language l eg sql having finite alphabet l eg the set of characters an output program which we call an is a finite sequence of l symbols that form an element of l definition for all languages l with alphabet l ie l l an is an element of l additional definitions will rely on the following assumptions and notational conventions · the length of program p is denoted as p so when p n where each is a program symbol in l we have p n · the ith symbol in program p is denoted as pi · welldefined functions exist for computing free variables in all languages under consideration function f v lp l h takes an p n a low symbol number l n and a high symbol number h ln and returns the set of variables that are free in the shortest term in p that contains all of the symbols lh · welldefined functions also exist for testing whether terms are values in all languages under consideration predicate v l h is true iff the shortest term that contains the to symbols in p is a value when the output language l is clear from context well omit it as a subscript on f v l and v all functions we now formalize section s intuition of program symbols we use the predicate n cv to indicate whether symbols in an form a value n cv is true for an p and low and high numbers l and h iff the shortest term containing the to symbols in p is a closed value definition for all languages l predicate n cv p l h over l × p × lp is true iff f v p l h and v l h code symbols are those that cannot possibly be part of any value when pi is code where p is an output program we write i definition for all p n and position numbers i p i is true iff for all low and high numbers l i and h ip cv p l h example separation of code from the remainder of this section illustrates definition in the context of sql sql an language inspired by the sql minimum grammar figure presents syntax which makes several assumptions · full sql programs are valid statements · operators in sql have standard precedence and associativity · a set of andor functions exists and sql expressions ie can invoke these functions with the id syntax where id is an identifier in this case a function name such function calls are possible in typical sql implementations · similarly a set of andor standard variables exists and variable identifiers are valid sql expressions · comments in sql begin with and continue to the first · string literals in sql have the same escape sequence as string literals in full sql ie a double represents a single also as in full sql directions are irrelevant in sql though we use directed in this paper for clarity values in sql are the last six terms listed in figure for category expr ie from int literal to null intuitively the values in a typed programming language are normally all the fully evaluated terms of each type in the language sql has types for integers int strings having a given size literal booleans bool and having a given precision literal so its values are the fully evaluated terms of each of these types including integer literals string literals the true and false keywords and floatingpoint literals finally null is a fully evaluated term of any type also a value given that values in sql are exactly the last six terms listed as in figure definitions and imply that i holds iff after parsing program p pi is not part of a nonterminal as one of these six kinds of symbols statement create table id id type list delete from id w option drop table id insert into id select s list from id w option id type list id type id type list id type type int char int literal bool float int literal w option where expr expr expr op expr not expr expr expr is null id id int literal str literal true false float literal null op or and values e list select s list from id w option e list expr e list expr s list i list i list id i list id figure syntax of sql are those in closed values all others are code this definition also works when partitioning and comment symbols no symbol involved in or comments can possibly be within a value all values in sql are single tokens so and comment symbols are code a few observations about this definition of code in sql · parsing is necessary to determine whether a symbol is code for example an integer literal is code when used in a type specification but when used as an expression · conventional definitions of ciaos are incompatible with the definition of code in sql for example there exists no set of terminals and nonterminals in figure that exactly derive symbols may contain code and even int literals may be code depending on the context hence our definition of code is with · code and cant be partitioned by considering to be literals some literals are code eg an integer in a type and other are not eg an integer expression although all eg a create keyword are code in sql languages with more sophisticated values eg lists may have symbols eg between elements of a list value · code and also cant be partitioned by considering code to be keywords and operators some keywords are code eg create and others are not eg true some symbols that are neither keywords nor operators are code eg ids and others are not eg literals next lets consider several example output programs beginning with the examples from sections and to see how the new definitions partition injected symbols it may also be reasonable to partition symbols typically and comments into code and in other ways for example one might consider symbols code iff their existence affects the sequence of tokens in the output program this paper and et al xu et al yes yes yes no yes yes no yes yes yes no yes no no yes no no no no no no no yes yes yes no no no yes no no no yes yes yes yes no no no no no no no yes yes yes yes no no no no no no no no figure a comparison of definitions for partitioning code and column numbers refer to the example output programs in section row names indicate partitioning techniques and cells specify whether any of the symbols are considered code select balance from where password or the injected or and and spaces are code so a ciao has occurred select balance from where exit all the injected symbols are code so a ciao has occurred where the injected is code so a ciao has occurred select from properties where no injected symbols are code so a ciao has not occurred all the injected symbols are code so a ciao has occurred again all the injected symbols are code so a ciao has occurred select from t where no injected symbols are code so a ciao has not occurred select from t where an open expression which causes a substitution operation to be performed at runtime was injected so a ciao has occurred select from t where again an open expression which causes a substitution operation to be performed at runtime was injected so a ciao has occurred create table t name char all the injected symbols are code so a ciao has occurred select from t where no injected symbols are code so a ciao has not occurred in all of these cases the partitioning avoids the problems with conventional ciao definitions described in section and matches our intuition about which program symbols are code and consequently cause a ciao if injected figure compares this papers partitioning of the example output programs above with the used in previous work the only scenarios in which we believe previous definitions would be over this papers definitions are when the assumptions made by this papers definitions cannot be satisfied easily that is when its difficult to define the set of closed values in the language definition of ciaos defining ciaos requires of code and injection at this point code has been defined it is time to consider what it means for an attacker to symbols into an output program intuitively injected symbols are the ones that propagate from an untrusted input source to the output program a ciao occurs when at least one untrusted input symbol propagates into and gets used as code in an output program to know when input symbols have propagated possibly through copy operations to output programs one could taint all untrusted inputs to applications and have those applications propagate through copy operations section will consider propagating through other operations as well then output programs could be tested to determine whether any of their symbols are used as code tracking to determine which symbols derive from untrusted inputs is a technique eg formal assumptions and definitions as in earlier sections will represent symbols ie those injected from untrusted sources as a if some element of is already then all in this paper may need to be replaced with some other annotation not present on any symbol then for all languages l with alphabet let l denote the same language but with alphabet where contains and versions of every symbol in thus the output language l contains exactly those programs in l except that programs in l can have symbols in any way the following three definitions formalize these ideas definition for all alphabets the alphabet is definition for all alphabets and symbols the predicate is true iff definition for all languages l with alphabet the output language l with alphabet is n n l i n ii ii given a regular application which outputs a application which outputs is constructed by ensuring all the following all symbols input to the application from untrusted sources are marked propagate through all operations that copy or output symbols besides symbols from untrusted sources and copying and already symbols there are no other ways to introduce symbols are to the application they have no effect on its execution the only assumption this paper makes of applications is that they can be about as applications these four rules at last ciaos can be defined as occurring whenever an injected ie symbol in an applications output is used as code definition a ciao occurs exactly when a application outputs p n such that i n i discussion of the ciao definition there are several points of discussion related to definition syntactic versus semantic analysis contrary to previous work definition does not limit ciao detection to syntactic analysis although testing whether sequences of program symbols denote closed values typically requires only syntactic analysis eg values are defined syntactically for sql in section such testing could require analysis for example semantic analysis may be required to determine whether the output programs date and balance exhibit ciaos in languages with used in both and expressions expected ciaos although ciaos often constitute malicious use of an application some application programmers expect ciaos to occur and dont consider them malicious for example · a translator between programming languages may input an expression like xy and output a program containing the same expression or some code like with the symbol having been injected this is not a problem and authors of would typically not consider ciaos on their · tools like provide interfaces for remote users to enter programs and then have those programs output for other systems to execute · applications may check inputs before them as code in output programs such as the application then else raise or the application math then else raise programmers of these applications may not consider ciaos of checked inputs to be malicious though it may nonetheless be desirable to detect ciaos in such programs for example to prevent the latter application from we believe that whether an act is malicious or an attack or against a programmers or is the only we can examine is the programmers code but that code may not capture the programmers definition therefore does not depend on factors like programmers ciaos are defined as occurring whenever an application untrusted input into the code of an output program regardless of whether the application programmer would consider the ciaos malicious to make an analogy to memory safety there are mechanisms to prevent violations eg type checkers however some violations are not and may be fully intended by programmers for example a programmer with knowledge of how integers and are encoded may find that writing an arbitrary float value to memory does exactly what she wants very efficiently as another example one of the difficulties encountered by safe c projects is that some violations are actually and optimizations definitions of violations dont as far as were aware take into account programmer mechanisms for preventing violations programmer and prevent all violations regardless of whether a programmer considers some particular violation malicious analogously definition unlike the conventional definitions of ciaos used by previous work the questions of whether output programs are intended or malicious definition just focuses on detecting whether code has been injected into output programs injection attacks some injection attacks on output programs are not attacks on output programs for instance consider the output program select balance from where password true here a type error will occur assuming that password is not of boolean type potentially causing failures although this output program contains symbols that may have been injected with malicious those symbols are part of a closed value and are therefore not used as code because code has not been injected the output program does not exhibit a ciao according to definition function values functions are firstclass values in many languages and it may seem to allow arbitrary closed function values to be injected into output programs however a function value is dynamically passive a function value only when upon by applying the function hence a function value does not constitute a ciao but a function application does assuming the injected application is not within some other closed value such as an outer lambda term and secondorder attacks definition has no problem with attacks alternate encodings allow to mask injected code for example by instead of a direct command definition detects such attacks because the injected function calls are recognized as code definition also detects secondorder injection attacks where an attacker stores some code in a database that an application later and into its output as long as the database input to the application is considered untrusted or as a more precise alternative the database could store flags indicating which of its entries symbols are defining injection finally definition injection as meaning that symbols have been directly copied from input to output for example loading a symbol from memory into a register would taint that registers value but adding two integers involves no direct copying and therefore produces an result thus definition does not consider ciaos to occur when applications output programs whose code symbols are versions of untrusted ie manipulation prevents the input symbols from being considered injected intuitively an application like may input a from an untrusted user and then output the program in this case it seems to say that the user injected the given that the user never entered a and the application produced the by transforming its input if anything the application and user have to produce the that output one could consider this example of a more general class of attacks ciaos ciaos following this of thought leads us to define ciaos in exactly the same way as regular ciaos which will also be called ciaos except that for ciaos we taint propagation to occur on all data operations not just copies and outputs that is for any data dependency in which the value of a symbol depends on the value of at least one symbol must also be in the example above we would taint the produced by adding a with an as a better example consider the application which outputs exit after exit definition does not consider this exit input to be a ciao because with the output is just exit with no symbols however the exit input is a ciao because with the out put is exit note that every ciao is also a ciao in many cases such as the application above it may be helpful to detect and prevent ciaos in other cases may be expected so system may not find it helpful for them to be and similar to expected ciaos discussed above for example an application for online might hash an input number to obtain a number g and then output a program like select from group g where assuming g is obtained through operations on the untrusted input this application a ciao but the application programmers and system would likely not consider this ciao malicious attacks taint propagation further one might consider to propagate even through control dependencies to illustrate lets consider the following application which is semantically equivalent to the application and performs what calls a conditional copy are more input symbols input symbol case a break case b break this application is to and ciaos because there are no data dependencies between input and output symbol output is a constant into the application source code on the other hand the semantically equivalent application is to and ciaos because it directly copies input symbols into the output these are reasonable consequences of only dealing with attacks ciaos only occur when code symbols in output programs directly depend on untrusted input still it may be desirable to prevent applications from as the application above does and more generally to prevent untrusted inputs from at all even indirectly through control dependencies with the code symbols an application outputs to do so we propose studying attacks on outputs the application above is to because its input can interfere with the code symbols that get output an application is to whenever inputs in untrusted symbols can cause the application to output programs in code symbols in other words applications to must when given the same trusted inputs always output programs containing the same code symbols definition a occurs exactly when application a on trusted and untrusted input sequences t and u outputs p there exists another untrusted input sequence u such that a on t and u a outputs p b the subsequence of code symbols in p is not equal to the subsequence of code symbols in p the application above is to ciaos but to it also is possible for applications to be to but to ciaos for example the application if input then else output a ciao on input but cannot exhibit a because there is no way to change the subsequence of code symbols in the output program by changing the untrusted input although it may sometimes be desirable to detect the strictness with which defined causes many reasonable applications which are free of ciaos to exhibit for example an application could accept some untrusted input indicating which to output an account balance in if the desired is not the default the application might output some code to multiply the balance by a conversion rate this application neither nor ciaos because the code symbols it outputs eg the multiplication symbol are not on the input however this application does exhibit because the input affects through a control dependency the code that gets output ie whether or not a multiplication gets included in the output program hence this example application illustrates that like copy and ciaos may be expected and not considered malicious for some applications implications of the definition of ciaos analyzing the previous sections definitions provides insight into the of ciao and as well as various mechanisms effectiveness at ciaos of ciao and been to find that any application that always copies some untrusted input into its sql output is to a ciao at runtime theorem formalizes this result it states that if an application always includes an untrusted input im in its output without even that input and the same application has some input v vn for which it outputs a valid sql program then there exists a way to construct the untrusted input am such that the applications output will contain an injected code symbol the proof is constructive it shows how to code into any such application using a detailed case analysis of the kind of value the untrusted input vm gets injected into although the proof is to sql the proof techniques are general theorem for all nary functions a and nary functions a and a if i in ai in a i im im i im im in where m n and v vn vm sql av vn sql then a an aa an sql and aa an a ciao proof by assumption v vn av vn sql first if av vn a ciao then simply set a an to v vn on the other hand if av vn does not exhibit a ciao then by the definition of ciaos vm must be a substring of a value because vm is not empty and appears in the output of av vn note that changing the untrusted vm input to am without changing any of the other n inputs will cause a to output a v vm vm v vm vm vn that is the same output program but with am instead of vm we will show that no matter the type of the value that vm is a substring of there exists an am that will cause av vm am vm vn to exhibit a ciao but still remain valid · case str literal am if the first character of vm is not an or is the first of a double escape sequence then global vm else global vm examples becomes f global name becomes global becomes global let sm denote the string literal that vm is a substring of if vm does not start sm which could happen if vm begins with the first of a escape sequence then the string literal must have been started earlier as av vn sql in this case our construction of am terminates the string literal that has been started inserts a code symbol the concatenation operator a global variable another code symbol and then begins a second string literal if vm terminated sm then this new string literal will also be terminated by vm if vm did not terminate sm then it must have been terminated later again because av vn sql as a result this second string literal will also be terminated later on the other hand if vm did start sm or is the second of a escape sequence then our construction creates an empty string literal or the escape sequence and terminates the literal and a global variable and then another second string literal started by vm again we know that this second string literal will be terminated either by vm or the characters following it for the same reasons as earlier thus our construction of am causes sm when am has been substituted for vm to be parsed as s global s where s and s are both valid string literals note that expr op expr is a valid expr and as long as global is of type string s global s will be of the same type as sm as any expr can by replaced by another expr of the same type the program will remain valid after the substitution of am for vm as am contains a code symbol ie concatenation operators as well as a ciao is · case int literal float literal am examples becomes exit e becomes e exit this construction works for similar reasons as the string literal case above in addition to the multiplication code symbols this construction also has a function call · case true false null let denote the keyword that vm is a substring of hence can be written as where and are in sql if has a boolean type then let op be or and let su b be global otherwise let op be and let su b be exit if has an integer or float type or global otherwise then let am op su b op examples false becomes false or global or false null becomes null exit null by assumption vm is a substring of a keyword we assumed earlier that av vn sql so must be a valid keyword we also know that in av vn vm is by and followed by we construct am such that it the identifier or keyword started by the existing inserts a code symbol depending on the type of an attack then inserts another code symbol and begins a new identifier or keyword to be finished by the existing as a result where originally the program used as an expr the modified program uses op su b op furthermore the type of the expr remains unchanged as if has a boolean type then op will be or and a boolean ord with a boolean is a boolean if has a float or integer type then op will be the arithmetic operator which will return either a float or an integer type if has a string type then the operator denotes concatenation and two with each other form a string note that the only keyword that is a value and can have a type of int float or string is null as it can assume any type note that a ciao has already occurred when null is used in expr is null because null is only a value when parsed as an entire expr furthermore any application that copies untrusted input into the sql output program is either to or can be made to output an invalid program again the proof is constructive it shows how to create an untrusted input that changes the sequence of code symbols in or the output program theorem for all nary functions a and nary functions a and a if i in ai in a i im im i im im in where m n and v vn vm sql av vn sql then a either a or can be made to produce an invalid sql program proof observe that every symbol in an sql program is either part of a value or not if vm contains a symbol recognized as part of a value then the input can be modified in the manner described in the proof of theorem and the sequence of code symbols will be modified by definition a a on the other hand if vm contains a code symbol then a different symbol can be provided if the sql program is still valid then a has occurred as the sequence of code symbols has changed if changing the code symbol made the program invalid then the second condition of the implication is satisfied given that applications commonly copy some untrusted input into the output theorems ­ show that to ciaos and are limitations of static and mechanisms to detect ciaos determining whether an application is to ciaos requires knowing which input symbols propagate to the output program this makes it undecidable to precisely detect both and ciaos using static code analysis or analysis theorem there exists an application a which inputs a string of symbols over alphabet and outputs such that it is undecidable when given only an input string s and a eg encoding of a to determine whether a a or ciao on s proof let a be an application that inputs a string s executes subprogram p and then outputs s if s equals but otherwise outputs just this a outputs programs in any language having integers and addition also a a and ciao iff its subprogram p halts and its input s is statically determining whether a a ciao on input therefore reduces to the halting problem theorem there exists an application a which inputs a string of symbols over alphabet and outputs such that it is impossible when given only an input string s and the trusted taint untrusted inputs trusted inputs application possibly ciaos output program taint information trusted ciao all symbols used as some symbols used as code no ciao detected may execute output program ciao is detected raise exception figure overview of a mechanism trusted components are ability ie an oracle to predict the output of a on any input to determine whether a a or ciao on s in other words there exist observationally equivalent applications a and a and a string s such that as a ciao but a s does not exhibit a ciao proof let a be the application and a the application from section recall from section that a and a are observationally equivalent a is to ciaos eg on an input like and a is to ciaos theorems ­ are interesting because they rule out certain classes of mechanisms from being able to precisely detect ciaos some of the mechanisms out were previously thought to precisely detect ciaos an example is mechanism in which untrusted inputs get by special characters and output symbols are considered iff by those characters although previous work showed that mechanism is theorems ­ are more general in that they rule out entire classes of mechanisms from being able to precisely detect ciaos of course theorems ­ dont rule out static analysis and mechanisms as being useful for ciaos although such mechanisms cant detect ciaos precisely they can detect ciaos conservatively ie soundly but not completely with runtime overhead while avoiding the many practical to monitoring dynamically some of which are described in section however sound static mechanisms for detecting ciaos must be so conservative as to reject a large class of common applications which may limit their recall that theorem showed that all applications that copy some untrusted input into an output program can be made to exhibit a ciao at runtime hence sound static mechanisms for detecting ciaos must reject all of this large class of common applications similarly theorem implies that sound static mechanisms must reject all such applications as well related work on techniques for detecting ciaos appear to be consistent with this result none seem to allow applications to copy untrusted input into output programs having a formal definition of ciaos makes it possible to prove that this characteristic is for all sound static mechanisms design of mechanisms for precisely detecting and preventing ciaos theorems ­ prove that precisely detecting ciaos requires a dynamic mechanism a highlevel design of such a mechanism follows straightforwardly from the definitions in sections ­ a dynamic mechanism can precisely detect and prevent ciaos by · all symbols input to an application a from untrusted sources · tracking one taint bit per symbol · propagating through exactly as copy and output operations for ciaos or all data operations for ciaos · as output programs and · execution of output programs that contain at least one symbol used outside a value ie as code figure illustrates such a mechanism theorem assuming a mechanism m performs these operations on an application that outputs programs in a language with decidable f v and value v al functions it is decidable for m to precisely detect and prevent ciaos proof immediate by definition and the definitions of ciaos and mechanism m given above algorithm directly implements this generic design of dynamic mechanisms for preventing ciaos the algorithm relies on auxiliary functions for adding taint tracking to applications that untrusted inputs are calculating the set of free variables in a sequence of program symbols and deciding whether program symbols constitute a value each of the three nested for loops in algorithm executes on times where n denotes the size of the output program hence if we ignore the of the f v and v al functions which are dependent on the language the toplevel for loop of algorithm runs in on time assuming that the f v and v al functions run in time linear in their input size then the toplevel for loop of algorithm runs in on time the space required by the toplevel for loop of algorithm consists of the i low and high counters each of size n the flag of size o and whatever space is required to invoke and execute the f v and v al functions assuming that invoking and executing the f v and v al functions uses space linear in their input size then the toplevel for loop of algorithm uses on space optimized mechanism algorithm can be optimized to run in on time and space under the assumption that the language has an lrk grammar in which every closed value matches some syntactic category eg in sql every algorithm basic mechanism input application a and inputs t u trusted untrusted ensure as output is executed iff it doesnt exhibit a ciao a output a t for i to output do if then true for low to i do for high i to output do if low high and low high then false end if end for end for if then throw end if end if end for closed value matches the expr category when languages satisfy this assumption algorithm s toplevel for loop can be replaced with a parse of the applications output program when reducing a r of a production to a nonterminal n the parser sets an attribute for n and on all symbols represented by r except for any symbols represented by nonterminals in r for which has been symbols have already had their erased after running this parser all in closed values will have been erased so a ciao is detected if and only if some symbol remains in the output program algorithm presents for this optimized mechanism the algorithm relies on auxiliary functions for adding taint tracking to applications that untrusted inputs are output programs and parsing output programs theorem the block of algorithm runs in on time and space proof the portion of algorithm runs in on time and space where again n is the size of the applications output program a standard parse of the output program without the additional actions performed on reductions runs in on time and space the total number of symbols reduced to nonterminals during the parse is on because the total number of symbols reduced to nonterminals during the parse is on all the reduction actions in algorithm ie n n begin etc occur in on total time and space the for loop in algorithm s in block also runs in on time and space so algorithm s entire in block uses linear time and space in addition to the time and space used to clear to determine the total time and space used by operations observe that is always initially invoked in algorithm s in block on symbols matching a nonterminal n such that n during execution may call itself recursively only on nonterminals with false attributes because parsing is bottomup then pointers to algorithm optimized mechanism for applications whose language has an lrk grammar in which every closed value matches some syntactic category input application a and inputs t u trusted untrusted ensure as output is executed iff it doesnt exhibit a ciao a output a t let function p pn for i to n do current if current is a terminal then for j to do false end for else if then end if if i n then clear if any n ext for j to n do false end for end if end for end function end let in tokens run output on recognition of token t do position of first symbol of t in output tend position of last symbol of t in output end on end run run tokens on reducing by production n s s sn where is a closed value do n true of pointers to s sn n begin n end end on on reducing by production n s s sn where is not a closed value do n false n children list of pointers to n begin n end end on end run for i to output do if then throw end if end for end in the same symbol may never be passed as arguments to more than once and every taint may be at most once technically this result also relies on the facts that attributes are constant once set can only be by and when called on pointers to symbols can only clear at positions to also observe that ignoring recursive calls each run of executes in time proportional to the number of pointers to nonterminals passed as arguments plus the number of then because pointers to the same symbol may never be passed as arguments to more than once the total number of nonterminals in the parse tree is on every taint may be at most once and each run of executes in time proportional to the number of pointers to nonterminals passed as arguments plus the number of we have that the total time and therefore space used by all operations is on hence algorithm s entire block uses on time and space as required to monitoring in practice many mechanisms and frameworks exist for ciaos eg none separate code from the way this paper has but one framework which has not yet been released implements for x applications the functionality our definitions require hence it appears possible to use to precisely detect and ciaos in x applications by ensuring that all operations in section s list are performed even with powerful frameworks like there are several to ensuring that mechanisms the four constraints listed in section this subsection briefly summarizes these most of which are discussed in greater length elsewhere eg the first of the four constraints in section requires all symbols input to the application from untrusted sources to be untrusted inputs may come from many sources eg http get and post requests server variables or a database and all these untrusted sources may be difficult and error hence following and one might instead use positive ie tracking which symbols derive from trusted sources often just the string literals in an application it would be straightforward to this papers definition of ciaos to use positive rather than negative ciaos would occur when some code symbol in an output program is not the second and third of the four constraints require that propagate through exactly copy and output operations for ciaos or all data operations for ciaos because a taint bit must be tracked for every input symbol the mechanism must operate with fine which previous work has found to induce high runtime overhead eg many of of overhead in addition monitoring typically requires executing applications in modified runtime environments which limits and propagating through output operations so output programs can be and checked prior to being executed may be difficult it may be hard to enumerate all the ways an application can output programs eg to files remote hosts or standard output if an applications outputs can a mechanism the mechanism is unsound applications might also mechanisms by executing external eg native code the last of the four constraints requires to be transparent this ensures that taint tracking does not affect application behaviors mechanisms should only modify application behaviors when attacks are detected in which case the behavior must be modified to prevent injected code from being output to be transparent mechanisms have to from applications hence cannot use techniques to track eg the brackets are visible to applications another important to ensuring in practice is that runtime mechanisms generally induce overhead on application performance and this overhead may make applications behave differently perfect may therefore be difficult or impossible to achieve for applications in practice summary this paper has defined attacks on outputs the definition simply considers ciaos to occur when untrusted inputs get used as or open values in output programs this definition avoids problems with conventional ciao definitions which sometimes consider ciaos to be and vice versa the new definition of ciaos has been used to · distinguish between ciaos ciaos and based on whether propagate through copy data or all data and control dependencies · prove that a large class of applications ie those that always copy some untrusted input to the output program are inherently to ciaos and so sound static mechanisms must these applications from executing · prove that precisely detecting ciaos requires dynamic mechanisms the generic design of such mechanisms follows immediately from the definition of ciaos under reasonable assumptions these mechanisms can be optimized to detect ciaos in output programs in on time and space nonetheless due to their on taint tracking many implementation of precise mechanisms in practice hence the new definition of ciaos has been used to analyze precisely when they occur how they can be and how efficiently they can be we hope these results can serve as a foundation for improving the effectiveness of future mechanisms acknowledgments we are to the anonymous reviewers of this paper who provided many valuable comments this research was supported by nsf grants and references c advanced sql injection in sql server applications white paper next generation security software s p p and v n preventing sql injection attacks using dynamic candidate evaluations in proceedings of the acm conference on computer and communications security pages ­ p p and v n dynamic candidate evaluations for automatic of sql injection attacks acm trans inf syst ­ m e and e preventing injection attacks with syntax science of computer programming ­ july g b w and p a g using parse tree validation to prevent sql injection attacks in sem proceedings of the th international workshop on software engineering and pages ­ j clause w li and a a generic dynamic taint analysis framework in proceedings of the acm international symposium on software testing and analysis pages ­ j m s g c necula and w in the real world sigplan notices ­ may w a and p web applications using positive and evaluation ieee trans ­ w g j and a a classification of attacks and in proceedings of the ieee international symposium on secure software engineering march r and m injection attacks with computational theory july in black usa t j g morrisett d m w j and y wang a safe of c in proceedings of the general track of the usenix annual technical conference pages ­ berkeley ca usa usenix association n c and e a static analysis tool for detecting web application short paper in proceedings of the ieee symposium on security and privacy pages ­ a p j k and m d automatic creation of sql injection and attacks in proceedings of the international conference on software engineering may k and d sql in a chapter d e knuth on the translation of languages from left to right information and control ­ p j the mechanical evaluation of expressions computer journal ­ z t and m automated code injection for web applications in proceedings of the conference on theory of security and applications microsoft sql minimum grammar microsoft create function http top most software errors the corporation document version top most software errors the corporation document version top most software errors the corporation document version g c necula j m s and w typesafe of software acm trans program lang syst ­ may j and d x dynamic taint analysis for automatic detection analysis and signature generation of exploits on software in proceedings of the network and distributed system security symposium a s d j and d automatically web applications using precise in proceedings of the ifip international information security conference pages ­ g second order code injection attacks technical report software oracle how to write an oracle white paper december url page oracle create function syntax for userdefined functions oracle create function php t and c v against injection attacks through contextsensitive string evaluation in proceedings of recent advances in detection g d plotkin callbyname callbyvalue and the calculus theoretical computer science ­ e j schwartz t and d all you ever to know about dynamic taint analysis and forward symbolic execution but might have been to ask in proceedings of the ieee symposium on security and privacy may z su and g the essence of command injection attacks in web applications in proceedings of the rd acm sigplansigact symposium on principles of programming languages pages ­ o m s j m and o effective taint analysis of web applications in proceedings of the acm sigplan conference on programming language design and implementation pages ­ s the art of the project translated by g and z su sound and precise analysis of web applications for injection in proceedings of the acm sigplan conference on programming language design and implementation june w xu s and r policy enforcement a practical approach to a wide range of attacks in proceedings of the th usenix security symposium y p f w s and t code injection on arm in proceedings of the acm conference on computer and communications security pages ­ x and z wang a static analysis tool for detecting web application injection for program in international conference on and information system security pages ­ may 