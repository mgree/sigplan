abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints cousot france bp introduction a program denotes computations in some universe of objects abstract interpretation of programs in using that denotation to describe in another universe of abstract objects so that the results of abstract execution give some information on the actual computations an intuitive example is the rule which we from of the text may be understood to denote computations on the abstract universe where the se of arithmetic operators is defined by the rule of the abstract execution e ­ ­ proves that ­ is a negative number abstract tation is concerned by a particular underlying structure of the usual universe of computations the sign in our example it gives a summary of some of the actual executions of a program in general this summary is simple to obtain but eg ­ ­ f despite its in complete results abstract interpretation allows the programmer or the compiler to answer tions not need full of program executions or which an answer eg partial correctness proofs of programs ring the termination problems type checking pro gram optimizations which are not carried in the absence of about their feasibility section describes the syntax and mathematical semantics of a simple flowchart language scott and this mathematical semantics is used in section to built a more abstract model of the semantics of programs in that it ignores the sequencing of control flow this model is taken to be the most concrete of the abstract interpretations of programs section gives the formal definition of the abstract interpretations of a program de no au this work was supported by grants and under abstract program properties are modeled by a semilattice elementary pro gram constructs are locally interpreted by order preserving functions which are used to associate a system of recursive equations with a program the program global properties are then defined as one of the extreme fixpoints of that system the abstraction process is defined in section it is shown that the program properties obtained by an abstract interpretation of a program are with those obtained by a more refined of that program in particular an interpretation may be shown to be consistent with the formal semantics of the language levels of abstraction are formalized by showing that con abstract interpretations form a lattice section section gives a constructive of abstract properties of programs based on constructive definitions of fixpoints it shows that various classical algorithms such as compute program properties as limits of finite sequences section introduces finite fixpoint approximation methods to be used when are infinite cousot they are shown to be consistent with the abstraction process practical examples the various sections the conclusion points out that abstract interpretation of programs is a unified approach to program analysis techniques syntax and semantics of programs we will use finite representation as a language of syntax of a a program is built from a set nodes each has successor and predecessor nodes nodes node ne we note the cardinality sl so that s we sometimes denote x of a set s use s to the node subsets entries assignments tests and exits partition the set nodes ­ an entry node n c entries and one successor l has no and an node n c assignments has one predecessor and one successor and l let expr be the distinct syntactic categories of and expressions an assignment node n the value of the right expres sion to the left identifier expr id assignments assignments expr a test node successors the true and respectively denoted has a predecessor and two i and false successor nodes are and tests nodes i vn c tests let b the syntactic expressions each test boolean expression category of node n contains a test tests a node n c has one and more than one predecessor and immediate nodes of a nodes n e node are not m e q an exit node n has one predecessor and no and the set arcs of edges of a program is a subset nodes defined by arcs nm i n e nodes m which may be equivalently defined by arcs nm i m c nodes and n c of we will assume is connected that the directed graph nodes arcs we will use the following functions origin end arcs nodes arcs nodes i arcs nodes i mn i va arcs a i m e i m q tests arcs n tests arcs n v f true j i false semantics of this section a simple mathematical seman tics of programs in the style of scott and if s is obtained a set we denote s the complete by s ts to the ordering l for all lattice it and x q s semantic ce which is false and domain values is a complete the sum of the lattice bool some other primitive domains environments identifiers env are used to hold to their values values the bindings of we assume that the meaning of expr c expr in the environment by val e so that a expr env values an expression e c env is given in particular function val val the projection in domain env val i of the has the the state set states consists all information configurations during computations states arcs x env of the set of that can occur a state vs s c states consists in a control and an environment s such e states s state that we use a continuous conditional function l if b then e e else ez to denote e ­ if e c env v c values x c then e ay x v y the state transition function state a next state we consider programs states states defines for deterministic each let n be case n in e be within nl tests e i e exits s e each partial function to a continuous total domain s by fl if the partial function f on a set s is extended function on the j ft t and is undefined at x let nv be the bottom function on env such that vx e lvalues let be the subset of initial states i m c entries ­ a computation sequence with initial state is is the sequence s n where f is the identity f fn function and the initial to final state transition states states function is the minimal fixpoint of the functional af o f therefore where f d d y denotes the least lf fixpoint of o f static semantics of programs the constructive or operational semantics of pro grams defined in section considers the sequence in which states occur during execution the remark of is that to prove static properties of programs it is often sufficient to consider the sets of states associated with each program point hence we define the context cq at some program point q c arcs of a program p to be the set of all environments which may be associated to q in all the possible computation sequences of p cq c contexts e nv cq e i in is c i the context vector cv associates a context of the program points of a program to each cv e arcs contexts n is c i qe according to the semantics of programs text associated to arc r is related at arcs q adjacent to r the to the tion of the state the equation transition from the function we can prove where cv arcs x contexts is defined by cv case in entries nu assignments u tests u u q we define arcs states kr ks s env to be since the equation be valid for each a cv is a solution tem of forward cv must the sys where cv is defined by ar cv is a complete lattice with such that u cv lr u r union u is order preserving for the ordering which is defined by of vr arcs hence it is known that has fixpoints however it is t to exhibit examples which show that these fixpoints are not always unique fortunately it can be shown that cv is included in any solution to the system of tions x cv s shows that this cv as the least fixpoint of by thus cv can de d cv aq or e i n i is c i qe d cv the concrete context vector cv is such that program point q c arcs of the program p for any u q contains at least which may be associated of p the environments e to q during any is i qe e e q contains only the environments e which may be associated to q an execution of p e c i q is e i cv is merely a static summary of the possible tions of the program however our definitions d or d of cv cannot be at compile time since the of cv consists in fact in running the program for possible input data in practice compilers may consider states which can never occur during program execution eg some compilers consider that any program may always per form a division by zero although this is not the case for most programs hence compilers may use abstract contexts satisfying a but not which therefore correctly approximate the concrete contexts we considered until now abstract interpretation of programs formal definition an abstract interpretation program p is a tuple i o s t l int where the x t we set of abstract contexts is a complete with ordering s x y this implies that has a suppose also to have an l this implies that is in fact a complete but we need only one of the two join and meet the set of context vectors is defined by arcs whatever cv cv c may be we define cv t cv ar cv cv r e arcs zt l can be shown lattice the function int arcs x to be a com defines the interpretation of basic instructions if cq i q e is the set of input con of node n then the output context on exit arc r of n r is equal to c int is to be ya arcs cv e cv cv cv the local interpretation which is defined a system of equations of elementary by int is used with the program program to associate we define t it is easy to show that kr w int is cv hence it has fixpoints therefore the context vector resulting from the abstract inter i of program p which defines the global properties of p may be chosen to be one of the extreme solutions to the system of equations cv of interpretations the restriction that must be a complete semilattice is not since mac showed that any ordered set s can be in a complete lattice so that inclusion is together with all greatest lower bounds and lowest upper bounds existing in s hence in practice the set of abstract contexts will be a lattice which can be considered as a join u or a meet n thus giving rise to two dual abstract interpretations it is a pure that in most examples see the n or u operator represents the effect of path the real need for th operator is to define completeness which ensures int to have extreme fixpoints see the result of an abstract interpretation was defined as a solution to forward equations the output contexts on exit arcs of node n are defined as a function of the input contexts on entry arcs of node n one can as well consider a system of backward equations a context may be related to its both systems may also be combined finally we usually consider a maximal or solution to the system of equations by agreement ordering maximal s defined and minimal are related to the by x s y x u y y x o y x however examples such as manna and show that the suitable tion may be between the extreme these choices give rise abstract interpretations to the following types of u u n u n n ul examples u n uses n uses uses both u and static semantics the static tion is an abstract programs we defined interpretation in sec contexts u env where u env vectors to t s t data fw analysis data flow ullman analysis problems may be formalized of programs see references as abstract in available expressions give a classical example an expression is available on arc r if whenever control reaches r the value of the expression has been previously computed and since the last of the expression no argument of the ex has had its value changed let be the set of expressions program available p abstract expressions contexts will represented g false be sets of by boolean in a is clearly a complete boolean lattice the interpretation of basic nodes is defined by let bv n case n ln within ae false assignments u tests he u or and nothing is available on entry e is available on arc r exit the expression e is generated of n e is available modify arguments of e arcs an expression of node n if either by n or for all p and n does not the available solution of the system expressions are determined for ordering ae false of equations by the ae true v the determination of available expressions dominators intervals requires a forward sys tem of equations some global flow problems the live variables and very expressions require propagating information backward through the program graph they are examples of backward systems of equations our formal definition of abstract interpretations has the completeness property since the model the existence of a particular solution to the system of equations and therefore defines at least some global property of the program it must also have the consistency property that is define only correct properties of programs one can distinguish between syntactic and semantic abstract interpretations of a program syntactic interpretations are proved to be correct by to the program syntax eg the algorithm for finding available expressions is justified by on paths of the program graph by contrast semantic abstract interpretations must be proved to be consistent with the formal semantics of the language eg constant propagation consistent abstract interpretations an abstract t y interpretation of a program is consistent with a con interpretation i t l int if the context vector resulting from t is a approximation of context vector cv from the more refined this may be defined by establishing a o abstraction between concrete and context vectors and and requiring c v and in words contain one the abstract the concrete cv cv context vector must at least one but not only the concrete iff d d we note arcs d and b and id ar we will suppose a and y to satisfy the following hypothesis a j y a and y are yz ay x c x intuitively hypothesis is necessary because context inclusion that is property comparison must be preserved by the abstraction or process requires that concretization introduces no loss of information it implies that a is and y is injective introduces the idea of approximation the abstraction uc of a concrete context c may introduce some loss of information so that when again we may get a larger context c note that it is easy properties corresponding to for a and instead of the global the following local abstract interpretations hypothesis we will hypothesis on the concrete of primitive language use and cons and da x c arcs x ct ax aa x these two hypothesis are in fact l in the following ie the idea of abstract concrete computations equivalent lemma schema simulation of suppose we want to compute the concrete output text co associated with arc a resulting from input contexts as well approximate c co i this c we can in the abstract universe and get cl c to contain at least co that requires is co s ca on the co that we do not require c to contain is c co is not lt most we will say that i is a refinement of or that is an abstraction of i denoted i g a y if and only if there exist a and y satisfying sis to note that i a y imposes a local consistency of the interpretations i and at the level of language constructs theorems t and t of appendix then prove which defines the global consistency of i and at the program level in particular if we take contexts u env any abstract interpretation of ss ss a y is consistent tics of p which implies i p consistent with with the q e arcs let be the result of gn o is i e q as previously will not in the the abstract interpretations general be powerful enough to establish example deductive of contexts will be predicates such pred over the program variables which are the free variables in abstract interpretation is then as x xl x the the pred ld s false where condition defines strongest post pv case n in p be xc x values or tests can p and not assignments let p be x be e be within v of the program are defined by the least fixpoint of least for ordering so that an any other correct the deductive semantics is easily validated by pro that ss s a where contexts ec pred and xc x ex y pred contexts x e the main rules by ya point is to showing arcs pv justify proof e pv see hoare and in particular shows clearly that the proof can be done only when considering realizable contexts and grams involving clean basic constructs eg nontermination errors sharing between identifiers once s u ids the deductive semantics which will never has been proved gives a valid permit a false we know that proof theorem to be q c arcs nz o let is pv be the e result of ids i qe is ue the lattice of the relation s comparing the levels of of two interpretations is a is reflexive i s where i the identify function abstraction since ax x it is transitive i yi i imply i al o y o yi the relation u on by i u i is an equivalence abstract relation interpretations i and i i we have defined i u is an isomorphism between the algebras i and i the proof gives process some insight ­ u i in the abstraction ­ i and sr if i yi let al be the equivalence relation on i properly speaking on the set of abstract contexts of by x ay vx e i each equivalence class cx x g ii x has a least upper bound which is yx hence the projection al i of al on is a bijection from the set yi of of the equivalence classes on i let us show now that under the hypothesis i s ul al i and u yi u is bi and a yi are hence x e x x al x e i unique e such that x likewise x c yi x c y i x therefore dx e i x q yi x yi o thus ix y i is a ie i f i yi yi yi is a bijection between i and hence al is a bijection between i and i which is trivially an algebraic morphism al is its in ct yl is and x qed let i be the set of abstract interpretations of a program if equivalent interpretations are the becomes a partial or in particular with a subset of on contexts we can restrict i to be set of which abstract ss is then a orderings which s isomorphic with the lattice of equivalence relations example let p be a program with a single integer variable the generalization be integers the is obvious environments will value of the variable contexts are sets of integers the set of values at some program point a context s may be abstracted by a closed as when s is infinite bounds will eventually be or ya b xl a s x s b the abstract are then cousot interval the contexts a further abstraction may be b if a b then a b then ­ else f fi yn a then n n y the abstract y contexts are then yf m co this interpretation may be abstracted comparable abstractions by two is used by for constant might be used to apply the rules interpretations may be abstracted by propagation of both t lr which may be used to check that any vertex in the program graph is reachable from the entry nodes finally the most abstract interpretation is the upper bound of ax y i t i i a c i where t is the relation which is always true we have a of i which is r abstract of programs the system of equations cv rt cv resulting from an interpretation i tl int of a program p may be solved by el m me eg tarjan other one can use an iterative algorithm which computes kleene s sequence l of appendix cv c until c tc do c c correctness if int is to be a complete morphism ie infinitely distributive over then cv is the least fixpoint of fit eg since in a of length any distributive function is a complete morphism under the weaker assumption that int is continuous the limit cv of sequence can also be shown to be fixpoint of fit eg since in a any function is con finally if int is only to be cv is an approximation of the least fixpoint g and ullman termination the abstract evaluation terminates iff sequence is finite this may be the case because is finite eg or a finite type checking in algol subset only is to be for any particular program eg type length in algol m the length or may be of finite of any strictly increasing chain is bounded by m or may satisfy the chain condition every strictly increasing chain is finite although not bounded a lattice may have infinite chains although int is chosen so that sequences are finite finally an infinite sequence may k arbitrarily to get a lower bound of its limit some induction principle or heuristics used to pass to the limit and manna or approximate may be it cousot efficiency in practice efficient versions of the ce are used these consist in a symbolic execution of the program which propagates information along paths of the program until a of order of information propagation may lead to optimal algorithms for specific tions references in tarjan performance analysis of programs the performance of programs may be analyzed by for each program point the final value of an counter which is each time control goes through that point let be the lattice lr of positive real augmented by the upper bound m with natural ordering s the abstract r p s interpretation o cw may be used to derive the mean values of the using law of of flow cv let ne within case n in i unique u assignments tests case r in entry node z true true the main difficulty is to obtain the probability true of taking the true path at a n suppose the values of these can be determined from hypothesis on the in put data for fixed probabilities the function is ly continuous although it is not a since m then max z ip z cc and max ni q ni q ia the least sequence infinite fixpoint the length of kr is the limit of sequence is in general let p be the program begin l ko to l end the number n of by the minimal solution to the equation n n which is co limit of o i let p be the program begin while t do i end the number n of times is given by the minimal solution to the equation n i q n where q is the of t to be true n may be determined by the limit of sequence q q which is an infinite q series its sum is i this abstract interpretation leads linear equations sequence the iterative method for coefficients to a system corresponds numerical of to fixpoints approximation methods when the extreme fixpoints of the system of tions established for an abstract interpretation i of a program p cannot be computed in finitely many steps they can be approximated a more abs interpretation i s may be used for that purpose eg it is often ter to make approximations in i for example by the convergence of sequences finite iterative and approximation of the least fixpoint starting from a lower bound let i l t int be an tation of p when the least of m is unreachable we look for an upper of since according to the correctness cv z and implies cv s y increasing approximation sequence let at be such that vn c a c and z c every infinite sequence v is not strictly increasing the approximation defined sequence by so sn is so s nl if else fi sn s then n we now prove that m finite such that let m be the least natural finite such that sm s from that of the number eventually in k e m we know sk by sk x sk since sk that sk and sk sk always besides true we can state sk k sk u sk and therefore we conclude moreover implies s k i ys that m is finite m qed let be the least fixpoint great lower bound of the that x of set of hence it is x e at the such dx at since sm sml we have g sm sm is a correct x x sv and therefore of z of sequence when satisfies the one can choose to be int and approximation sequence ce and the related methods chain therefore condition the widening in increasing approximation se of in is to construct the approximate interpretation global we now indicate a way by local modifications to int let q r c we to q is dependent to r if and only if say that on the the context context associated eg in a forward system of equations the context associated to q may only depend on the contexts associated with the immediate arcs of q in the system of equations fine a cycle to be a sequence cv we de qn of arcs such that vi c n depends on and ql depends on qn eg in a interpretation a cycle corresponds to a loop in the program in any infinite strictly increasing cv since arcs is finite there is some arc q for tw the sequence qq never q must be long to a cycle or the contexts associated to q depend on the contexts associated to some other arc r which itself belongs to a cycle the sequence of contexts associated to any arc of that cycle never in order to avoid this we introduce ­ the binary by operation v called widening defined v x c c c c cv c every infinite of the form s where co abstract increasing sequence so co n n cn are contexts is not strictly ­ the set of widening arcs which is one of the minimal sets of arcs such that any cycle q of the ql c contains system of equations at least a widening arc c qi e eg in a forward interpretation on a reducible program graph may be chosen to be the set of exit arcs of the nodes which are interval on irreducible graphs an arbitrary choice has to be made so that any loop of the program goes through a widening arc the approximate arcs x defined by q cv if q e q v fl cv then cv as before we define at aq cv now we have to show that satisfies the requirements this definition of at and let us consider a sequence so we show that increasing that is to say this n o sequence is trivially for no so induction step suppose the for n g m let us prove that result to for the be true s ml z m s mq e arcs if q c s mq if q then sml sml o q then sml sml sml sm s sml since s and int is order preserving moreover we get s sm and therefore q finally sml sml qed an infinite sequence s o n cannot be strictly increasing since there would exist some widening arc q for which the se never would we now prove that is implies n sn sn z to say that s q act q sn q c arcs sn see if q c v we have sn sn sn by if now q we must show sn sn sn sn q s which is true from sn sn by qed example bounds of integer variables in a pascal program operating should ensure that arrays by indices within bounds for use the lattice obvious example i i of section on arrays the are only that purpose one can let us take an cl i c c let us to the note a the example b where system of is a s b the equations predicate corresponding o co cl ii cc m i c c n m val arithmetic eg are treated i j k using an ik j naturally extended to include the case of the emp ty interval similarly tests are treated using an interval logic since there exist infinite sequences eg o true do x x sequence hence for the program we must use the results will x o while an approximation be somewhat but runtime subscript tests may be inserted in the absence of let us define the widening v of intervals by i is the null element of v ri j v rk i i fi t j then j v satisfies to i the requirements of according the system of equations is modified by c c v cl u c the corresponding approximation sequence ci cl for i e o c c v cl u c v l ii u v ii c c n ­ ii n cc i ii c c v cl u c ui ii u c c c n ­ n is c cc i c note cl uc stop on that path ln ml c exit stop l the final context note that the eg c on each arc is marked results are approximate by a star ones in this example the widening is a very which introduces a great loss of information however it can be seen in the trace that tests behave like filters furthermore for pascal like languages one can first use the bounds given in the declaration of x before widening to infinite limits finite iterative and approximation of the least starting from an upper bound the per bound fit is order approximation sm sequence leads to an of the least fixpoint moreover sm since preserving this implies that s mt s x mm if s is not a fixpoint of int and the above seen sequence is finite eg the lattice satisfies the chain condition its limit is a better approximation of than sm when the sequence is infinite or one can among other solutions approximate its init decreasing approximation sequence at step n in the sm sequence we have in order to the convergence we should ne int next find an approximation sm d cv but not knowing d such that cv this is ry weak since d be chosen that is to say less than or non com with the fact that is e greatest lower bound set of x e such that tx choice x gives a correctness of d when is unknown criterion for we must have the td on the contrary to not provide an efficient this characterization construction of d does decreasing sequence in front of these difficulties we will by choosing d such that n d enforce con however decreasing bound on we sequence n not by an arbitrary the upper let at be such that c e c c tc tc v every infinite ly decreasing sequence c is not the is recursively decreasing defined sequence by s s s sn if sn n el se s then fi n s n let us now prove is a finite terms are greater t that the strictly than decreasing the least decreasing chain fixpoint which of let p be infinite the least such that natural number eventually s s trivially p p from if p then s s therefore then applying we have but implies s s s s sg hence for the induction step k p we have let us suppose that for since fit is order preserving we have sl since implies s we have si s g by recurrence on k the result moreover implies that is true for p is finite k p of se when satisfies tion one can choose the final result s ter or equal to th the chain to be in which case is a fixpoint least fixpoint of t the limit of s fixpoint the is an of fit sequence upper bound s f the in by analogy operation of with we define in order to built a by local modifications now the narrowing possible construction to int a x c e c every infinite sequence of the form s co s ac for strictly o ci cn decreasing so s a abstract the arcs x is defined by and cv if q c then a q r ll cv cv aq cv this definition of trivially satisfies the requirement since cv with cv implies q cv e as if q th that z a cv cv z ct otherwise cv q cv hence cv the proof of very similar tion termination requirement to the one outlined for in is bounds of integer variables let us come back equations was to example the system of ci rl c c u c c c n the approximation approximate c c c c c sequence led to the let us define the narrowing a of intervals by i is the null element of a i j a k i then lf j m then k else l else i k fi k thus narrowing just makes no improvement the requirements of system of equations infinite on finite bounds according is modified by bounds and it satisfies to the c c a cl u c the approximation sequence is c c a cl u c u c al i o c c n c o n stop on that path oi o n oi o exit on that improved this is example so that not the the approximate solution the least fixpoint is case in general has been reached but dual approximation methods the lattice may be as follows when x y we have noted x ge y the sequence is different from since it ensures that the successive from s remain in the partition xl x so limit s is greater p than lfp t lfp and are the least and greatest fixpoints of fit the and sequences converge toward lfp and respectively these limits are reached when int is continuous is infinite we have pro to use an approximation sequence to approximate fp its limit may be some fixpoint fp s j lfp or some s such m that s m and it is clear that the se when starting from i leads to an upper bound of the least fixpoint of fit and the sequence from t leads to an upper bound of the greatest fix point the and methods are not dual therefore when considering their and we get a means to both extreme fixpoints of fit any of the methods may yields a fixpoint fp which is not the fixpoint of interest none of these methods lfp or can prove fp to reach or therefore a fix point improvement method is necessary it is our that such a method could be designed only when considering that a richer structure ie for particular applications furthermore in the sequences the term of rank n is computed only as a function of the term of rank n hence these are steps methods one can as well imagine to use bound steps methods where the term of rank n is computed as a function of the terms of rank n n in this last case the sequences may be used to compute the first k terms after k steps more about the program would be available to rate the convergence so that the definition of and could be more refined finally measure result contexts going into the with nu analysis methods it is clear that some is necessary to control the accuracy of the its definition would certainly also some additional properties of the abstract it is our that most program analysis may be understood as abstract tions of programs let us point out global data flow analysis in optimizing compilers and schwartz ullman type verification type discovery cousot program testing symbolic evaluation of programs et al program performance analysis formalization of program semantics hoare and manna and gram correctness verification park of discovery of inductive invariants and manna proofs of program termination sites program transformation there is a fundamental between all these ap program analysis techniques a new interpretation is given to the program text which allows to built an often implicit system of equations the problem is either to verify that a solution provided by the user is correct or to discover or approximate such a solution the mathematical model we studied in this paper is certainly the weakest which is necessary to unify these techniques and therefore should be of very general scope it can be considerably for particular applications so that more powerful results may be obtained we wish to thank m we were very the typing for us for dis to have f do lattice rev theory ed math col cousot static determination of dynamic of programs programming symp paris lecture notes in comp sc to appear april cousot static determination of generalized type for publication sept of dynamic unions submitted assigning meanings to programs proc symp in math vol mathematical aspects of computer science j schwartz ri cd finite state modelling in program development proc int conf on reliable soft et al actor induction and ation conf rec of the first acm symp on principles of programming oct languages boston hoare an axiomatic basis for computer gramming comm acm oct hoare and formal ming theories languages consistent and complementary of the semantics of acts inf ­ and ullman frameworks monotone data flow analysis tr cs lab princeton univ affine relationships a program acts inf and manna logical comm acm april among ­ analysis variables of of programs unified approach to global program optimization conf rec of the first acm symp on principles of programming languages boston oct kleene introduction new york to van surface properties guage constructs int improving programs g france of programming symp on proving huet and g kahn and eds mac partially math ordered sets trans manna and programs tech stanford a new approach rep u to recursive comp sc and des program ming symp paris lecture notes in comp sc to checking of operand bit ­ types in algol park fixpoint induction and proofs of program properties machine intelligence and d eds edinburgh b u press schwartz language dec automatic of very data structure choice in a high level comm acm scott the lattice of flow diagrams semantics of programming languages verlag lecture notes in math e cd vol symp on scott and towards a for computer languages oxford u comp lab mathematical tech se calculating properties of programs by valuations on specific models proc acm conf on proving assertions about programs sigplan notices des variables int symp on pro and improving programs g huet and g kahn eds france eliminating track programs proc on automata languages july from of the third int and programming sites proving phd u may that th computer programs comp sc terminate stanford tarjan graphs stanford solving tech u path problems rep cs on directed comp sc tarjan analysis stanford iterative tech u algorithms for rep cs global comp flow sc a lattice and its applications theoretical fixpoint journal theorem of math type determination level languages se new york u oct for very inst high of math ullman u data of march flow analysis comp property extraction property sets ieee trans vol no sept tech rep sc lab princeton in wellfounded on soft verifying program oct performance we note l with l l s t l partial ordering these definitions a complete s t and are given in note l is a complete lattice proof in p we take f is f is or f is monotone to be and mean yx x yl x s y fx fx hi let f be an the complete semilattice in itself function from l u t m let be an the complete semilattice in itself function from ll the fixpoints lattice with of f form a complete g l such that g x e l a x s fx b l x c l a fx s x this result is note that form a we note and fixpoints of y proved in the fixpoints of f of l the greatest and not least h let a and be such that h h h h h h ci y u is order preserving x c l x xf l h h hi hi h h and x l and es fy l h h proof e c ay y y fy by x y in h from h from h h and ty xl x fx ctx fx ax h f order in hi transitivity h h in h preserving qed since hi equivalent and h are proved we choose by l to be h h or h l let f l l be an from the semilattice l u s lin it self l and g respectively the least and greatest fixpoints of f then x e l g u fx x g z x the dual pp xc l of this result by duality is in park l n fx x s x h imply that the greatest points g and of f and are related ag and g y proof the existence of g and is stated by ll ag ag yz g qed trivially since h l h h g fg u z transitive replacing g f a y h h h respectively by k n s f y a h h h in the above proof we get the dual theorem t hl fi h h imply that the least fixpoints l and l of f and are related by yl k according to subset x l is led directed if every finite subset of x has an upper bound in the sense of s belonging to x an obvious example of a directed sub set is a chain a tion f d d is called continuous ever x c l is directed then if q x tx e x h let f be a continuous function from l u s t the itself let be a continuous function from the com semilattice u z in itself n we note x and f x l h implies that f has a least point it which is the limit u fl i of the sequence fl fn the proof is easy proof of the first to adapt recursion from theorem pp ­ 