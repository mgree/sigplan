the programs a system for and manna stanford artificial intelligence laboratory stanford university stanford california and department of applied mathematics institute of science abstract a modifying already existing than ones an attempt is made to formulate of program a program that one result can be transformed into a new program that uses to achieve a different goal for example a that uses the binary search to two numbers may be modified to calculate the of a number a manner am debugging is considered as a special case of if a program wrong results it must be achieve he intended the application of p to concrete is also viewed from be pm of modification techniques me approach in a running cm r methods illustrated with several ex that have been performed by it introduction a more of his effort at the of that have already been written than at of new even when iii of a new program he m programs and basic programming pt that have been incorporated into other programming has focused on the ot of but ii of this shows how to pi ii mm when a new problem n this we to latter aspect of programming in of an automatic am development the of i al iii lhc ability to ail analogy two of those of a that has already and those of the that we to l ct is then used as the basis for tt tile pt to meet the new specifications as a m by nature error must be co i pl s an case pi oi our approach the properties of an p are compared the and a that transforms the incorrect into a correct one the human programmer does have the ability to learn from past abstract program are often a convenient form knowledge they may basic techniques and strategies such as the paradigm or the binary search technique the application of these to programming tasks may be ed the framework of modification a schema achieves some abstract goal m modified instantiated to achieve a concrete goal on the basis of a comparison of the abstract specifications of the schema with the concrete specifications of the desired program the use of analogy m problem in general and theorem in is discussed by the of an existing to solve a somewhat was as a powerful approach by manna ci and i and were to of generalizing and he robot they the compilation of a of program has been by their use n context of program synthesis has been discussed by and manna next the basic aspects of our approach to an with the aid of several relatively examples subtle of the techniques are illustrated in the third section the methods described are tc and have been implemented m all examples of that we present ran successfully on our system a sample run may be found m the appendix il are expressed in a in of an ­ tl e variables an input the set of legal input the is expected to work for program on is given a known correct program with its and the specification for a new program of the two a transformation is applied to given even if the pro ram not exactly the it can as basis for constructing the desired new program global in app to program presented in this we transformations which occurrences of a symbol throughout a program are affected such are global in contrast with local transformations which only to a particular of a as a yn example consider will its output specification the until y o if s ay assert y y repeat follow ins then ay else y fi given an array which m nonempty i n is when this program terminates lo will contain the of the values of the nl array elements an n this output specification is formally expressed in the final statement assert to the array rather the we compare specification with the assert and note that since a where a m equal to the array a each element assert a io thus a a transforms the given specification into applying this transformation to the program affects only the conditional assignment ay if ay s ay then ay else fi which ay if ay s ay then ay else ay fi it is the array a to the lefthand an assignment therefore both sides of the assignment are by and since the test ay s ay is equivalent to ay s ay we obtain the statement ay if ay s ay then else ay fi yielding a that computes the maximum note that the array a no longer appears m the program only the original a is actually used case program may be considered as a special case of a program which computes wrong results must be modified to compute the desired correct results if we know what he bad program actually does then we may compare that with the specifications of what it should do and modify the incorrect program accordingly as an example consider a program intended to compute the integer z of the nonnegative number c that is c should lie between the of the integers z and zl assert z c z z c n where n is the set of natural numbers the given program is z s t o loop until c s z t zl repeat st t assert z c z z c n lt the integer of c this program assert s c z z c n n is the set of positive this follows from the fact t z and s z l the cause of the bug was the exchange of the initial values of z and s the assertion with the actual assertion we note that may from the latter by replacing z z c with cl c c to the test cs becomes cl applying transformation statements only the exit s or equivalently c s s the z statements two other z becomes zl and the z zl becomes zl these however are illegal as an expression not appear on the left hand an assignment instead the expression zl is given the initial value by zo and the value of the expression is to by the legal assignment z zl wc have the z s t o o loop until c s s s t e repeat st program t assert z s c z cn note that this program is not exactly programmer ­ we that he values of z and s ­ it m nevertheless correct what the the in the examples only input andor output variables were it can be shown that such transformations ­ an input variable is by a function of input variables or an output variable by a of output variables ­ always preserve the of a program with respect to its specifications however it desirable a function constant in case the transformation is no longer guaranteed to in a program example we may wish to construct maximum of a nonempty array ­ the z n ­ given the program a to the output specification m z y al loop until y n y yl z g ay repeat assert z for finding the the transformations max and o suggest themselves though in this case these transformations yields a correct program such transformations of a function symbol or constant do not necessarily preserve were the function min not explicitly in the program cg if statement if ay z then z ay fi were substituted for the assignment z then the proposed clearly not work transformation become max would thus in order to prove the correctness of a invariant are commonly are which express relationships between the different variables manipulated by the program they relate to specific points in the program and are meant to hold the values of the variables whenever control passes the corresponding when an tion has been to be consistent with the ­ ie the assertion holds for the current values of the variables each time control passes through the point to which the assertion is then it m to be all assertions annotating our example programs are indeed invariant in particular the output associated with the point of termination is invariant lf final values of the variables satisfy the a loop to the of an iterative loop m invariant if it when the loop n first entered and remains true subsequent control passes the beginning of the the is an output in the former case and a invariant in the latter a program then may be considered correct if the output invariant that the output is true the above program with its loop assertion z y ao loop assert z until y n y y z repeat ty assert z is recently invariant generation techniques have been developed and implemented see e and and and manna they allow for the automatic discovery of which may then be used to prove the correctness or of the program our system many of those generation techniques as well as several ones assertions are essential in our to debugging too as it is necessary to have an idea of what the actually does before it can be global transformations are applied to all assertions as well as to the using these transformed assertions verification conditions for the new may be obtained if they hold then the new is correct sometimes a verification condition that turns out not to hold may nevertheless suggest additional which do succeed a segment can be synthesized that establish the condition for example the of a loop might bc synthesized if the for the current s false returning to our example after of the s max and o to the program we obtain z y al loop assert z until y n y yl z ly repeat assert z using the new correctness of this may straightforwardly be shown max program az one important application of our program modification techniques is of to obtain a m version of some programming strategy and contains abstract predicate function and constant symbols in terms of which its inputoutput relation is this abstract specification may then be matched a given concrete specification and an instantiation that when to the schema the desired concrete in instantiating a schema the schema is transformed into a program after an analogy between the abstract specifications of the and the given concrete specifications is constructed not all instantiation yield correct therefore a schema is by a set of ­ derived from verification conditions which must be before the schema may be employed when satisfied these guarantee the correctness of the new program as an illustration program schema z y k j loop assert until y n y y if then repeat assert y ci z fi here means vi c iu s and is the set of integers schema will achieve relation pi z for each integer i from j to n the for this and constants schema to be must be satisfied j k and n the by the predicate following three p function f a y a y a jn a n i z fhe first the loop invariant n initialized the second s to guarantee that lf the invariant execution of the then they hold after and the last condition term the position or value of the of an array or of functions domain for that matter are instant of this fo example say we to achieve the output x in order to find the maximum x of the array ai on our modification we compare on s x with the schemas specification z j be o z be x and pu v be tu s v the transformed preconditions then are rn k n o i x a a n i s the first by letting fu v be lu since the last is true y k be lo the ai x and by of being applying j k o ai o x au and po v v we c correct x y lo loop assert ai s x y c i until y n y y if x ly then x ay repeat assert ai on s x fi using sometimes a program or a schema only achieves some of the conjuncts of the output specification in such a case it is possible that the program can be to all the desired conjuncts by achieving the missing at the and maintaining them until the code that will achieve the additional conjuncts ing what has already been by the ­ could be and at the end as all of the need for extension consider the case it is desired that the above also find the position z in the of the x we can extend the above program to achieve x lz by maintaining that relation as an the of the program initially we want x lz so we set z e o when the then path is executed we want x c ay az and assign z that path is not taken x is unchanged and the relation remains true thus when the program terminates the desired relation x lz hold the extended program m x y z ai o o o loop assert ai s x y k x until y n y y if x ly then x z ly y repeat assert x x az fi ill in this section we demonstrate stages in the evolution of one pl we with a program containing a logical error and then find and apply alternative an abstract version which represents an important search method embedded in the m then applied and adapted to two other problems each in turn is modified to apply to a new task the examples are in figure they their motivation to and dijkstra our modification system has successfully performed the modification steps debugging and instantiation in these examples sometimes to the users in theorem proving an annotated trace of the first example may be found m the appendix annotation i ng good real division abstraction b i nary search schema ion i division extension integer division figure the evolution of a of examples through example bad real to good real the problem of the z of two real a and b where o s a b within a specified c e in other words the specification is c and the output is z s c a ab ze or s a a a ln order the problem to be nontrivial we must assume that no general real division operator is though division by two m the given program is bad real division program assert z y o oe loop until y s e if zy a then y y repeat z zy fi the tion contains the input input a b and e are assumed to satisfy but example a b and e which satisfy input yield z o which does not satisfy the for the the second conjunct of the output specification the bug is caused by the of the two statements within the loop before we can this program we must know something about what it actually does for this purpose we annotate the am with loop and output recall that for a to be a loop invariant it be true upon entry into the loop and must remain true after each execution of the y we begin with the then path of the statement and note that path m taken when a thus after z to zy we have bz s a since bz s a is true initially when z o and o s a and n when the conditional test m false the value of z is not changed it invariant throughout loop execution we have derived then the loop the then path is not taken when a b zy in that case y is divided in half and z is unchanged yielding a b zy at the end of the current iteration it turns out that the path preserves this and that it holds upon since a k by o a b thus we have the additional invariant a these two loop invariant along wh the exit relation y s e imply that upon termination of the program the output hold a a j ze note that the desired a b ze is not implied the annotated program ­ with that correctly express what the does do ­ is annotated bad real division program z y o oe loop assert bz s a a until y s e if b y s a then z zy y y repeat assert bz a a b ze fi we now have the task of finding a transformation correction transforms the actual output invariant into the desired lj z aa a and then it to the whole annotated program statements and assertions we would to modify the in such a manner as to transform the strong a b ze into the desired specification a a b a at the same time we must preserve the correctness of the other of he j z a unchanged the most obvious correction i to replace all occurrences of e in the program there n only one affected statement the ext test y e with e correction y e by y s e debugging modifications are possible we may replace b with b and z with alternatively we might replace a with a and z with z and either b or a yields a conditional test equivalent to zy s a z into two statements the initialization becomes the illegal assignment z o but the equivalent original assignment z o may be substituted the assignment z zy of the then branch becomes z zy or z zy no other statements are affected by either of the two thus they both yield correction lh conditional with if b zy s a then z zy fi each of these possible involved one of the input variables e a and b must however be careful when transforming input variables since the transformation should be applied to the input assertion as well possibly changing the range of legal inputs thereby in this case the transformations we have are all the specification o e is equivalent to o e and therefore e has no effect on the range since in fact the condition a b rather than ab is strong enough to imply the loop invariants b by b or a by a still yields a program correct for inputs satisfying a b as is desired our after correction annotated with appropriately invariant assertions is all b have been replaced by j and all z by and the expressions have been assert oe z y o loop assert bz a a until y e if s a then z e zy y y repeat assert bz s a a fi this may be optimized by the y before good real division program assert oe z y loop assert bz a until y s e a y y if b zy s a then z zy repeat assert bz s a a fi note that this is the same as the the two statements bad program an version of the correct real is ion has just been obtained binary search schema y c j k loop assert pz ry y y if then z zy fi repeat assert p i this schema s an attempt to capture the technique of binary search the division program it is obtained from that by abstracting predicates that appear in the assertions a pu b l and c the o j and k the four the predicates p q and r and constants j and k to guarantee correctness they correspond to the conditions of the initialization path path and the path n preconditions for binary search schema l pj a a ry i what we have is a schema for a binary a with an output specification pz a clearly the p and r which appear in the schema must be that is available in the target language they must be replaced by equivalent predicates for the to an executable program similarly the constants j and k must be given or their values set prior to their assignment to the variables z and y search o real as indicated the our modification system is the instantiation and adaptation of program to specific problems to illustrate how the binary search schema that we have just seen may be used we consider the computation of that we are given the task of constructing that the z of the real number d od l then is o d c and the output specification ix a program c c the input in order to match this output specification with that of our schema pz a we let the constant e be the constant expression d zd as z d and obtain the transformations po e u and c d condition zy we must still satisfy we need zy conditions j and k s l and such that a ve thus c e s c and hold when we let s j v c and k w lc an would cc o s f have been to take c for k since for to be satisfied we need a predicate r such zy s z a ry zd s z by it follows that r should imply zd zy and we let ry d y this also c since both d and lc are negative the instantiated schema is assert o d c z y c lc loop assert j s z zy until d s y y y if s zy then z zy repeat fi assert c z zd s jc p involves the function itself the conditional test is not primitive and must be replaced can be by c the relation zy c ic zy o zy for provided that zy is nonnegative is in fact an invariant initially the then path y is first and then to z so the zy is unchanged and if the then path is not taken y is increased by it since negative by of the loop assertion zy s j s z have real program assert o d c z y c lc loop assert j s z zy s o s zy until d s y y y if c s zy then z q zy fi repeat assert d s z zd s to in this example we shall how the above real may be modified to construct a program that approximates z of two real numbers a and b where o s a b a e e we begin by comparing the output we ze ab a for the program we had zd dc a z z ions d e and f s ab the latter we can use ab ab of the two the exit test d s y becomes ey and the test c s zy becomes s and zy program are nonnegative a s ij zy since a b thus we have the transformed z y ab lab loop assert ab s zy until e s y y y if a j zy then repeat assert ab s z ze s ab ab o zy z zy fi it s expressions involving appear in the the loop can be in another manner since ab we can the relation ab o ab we zy for which s z by z to o zy ab by we initialize y to since that we program real division program assert z y loop assert ab i z zy y y if a then repeat assert ab z ze s ab ab o zy z zy fi search for we return search schema preconditions pj a a y ze s c z y j k loop assert pz until ry y y if then z zy repeat assert pz fi and how it may be to the computation of integer this extension the synthesis of a n which have not been completely in our system consequently this example is more than the previous one we would to construct a program z of a nonnegative integer should be the largest whose square thus the input specification is that finds the integer c iii words z is not greater than c cn and the is s c a c n zn of this schema pz a suggests output specification with that pu and e in be uc c cu z le we have the of our z clearly zy to satisfy s c c zy c zy we let a ry c zl ry he zy we are left with and a c z in order to satisfy the we form the goal achieve j s c c jk this goal may consecutive ones achieve s c achieve c jk since c s to be nonnegative we can solve the by j f o if z is ck to o for the second we need now achieve written program is assert c n achieve yk c kz loop assert z s c c zy until zy s zi y y if zy repeat s c then z zy fi assert zz s c c achieve z cn assert s c c z n at wc have a to z c n either we execute the loop then z to satisfy the z c n preserving the z s c and c y m wc lt the loop z n first and then preserve technique preserving computation this is in fact the of by y the latter should also be a assuming that z and y are yl exit test s zi be replaced by y s since and the only operator to y is so under the assumption that y is an integer we need only test for y it order for y to remain in n while it m repeatedly until it equals we must have y so w that k c n and accordingly add the to c k note that with k c n the termination clearly holds s z thus far we have the partially written assert zo cn achieve yk c kz k c n loop assert z sc c zy z c n y c n until y y y if zy s c then z e zy fi repeat assert z c c z r n the achieve c k kz k c n must now be synthesized we would first attempt to achieve this cm at a time first might easily be achieved by k c the second could easily be by k though each itself both together m more sol lit ions in conflict each other is by since these two this goal choosing first to k c n by k ° and then to keep it true while executing satisfied a loop until the conjunct c k is also k with each iteration will preserve the invariant k n while making towards the exit test c kz lhe reasoning is as follows we know that k should bc since initially k and ultimately me want o s wc k we wish k for some natural number n to k it follows that the n also increases k the by wc the assert c n z k o loop assert k n until c k kk repeat yk last y k is ii file all of k the with e have the integer be y integer program c n z y o loop assert y c n until c yz yy repeat loop assert z s c c zy until y y y z n y n if repeat s c then z zy fi assert z s c c zl z c n to hardware division we to construct a to compute the q and remainder r of two integers must satisfy the output specification a and b the or a ah qr or equivalently a given the specification a a q n n is the set of positive integers we could develop this program from our binary search in the same manner as we constructed the integer program instead however we will demonstrate how to transform the just constructed integer program directly into the integer division as for the division example we compare the desired with those of the program z ca c or zd and obtain the transformations z q a and c in addition ab we will have to achieve n r ab q applying these transformations the exit test of the first loop c y becomes ab y since both ab and y are positive this the conditional equivalently m the same as ab y or test s c becomes s a a by similarly s ab or thus we have the program f y loop assert y c n until a by yy repeat loop assert assert q s ab ab q c n y c n until y y y if b s a then q e fi repeat q s ab ab ql q c n attention must be to the input specification by the transformation c to the input of the integer program the input for this program however that the only fact needed oc for the construction of the program was its input specification cn was restrictive a the transformation to o s c yields z ab now since this is implied by the input a c n a bc n the above program is correct for any legal values of a and b to achieve the output specification r sb q we extend the above program to keep that relation true so whenever q is updated it m necessary to update r accordingly when q is initialized to o r ab o a when q is to r becomes ab have assert a n b c n q y r a loop assert y n r until a by yy repeat loop assert assert q ab ab q c n y c n r until y y y if s a then q r fi repeat q s ab ah q q c n r note that the conditional test a is equivalent to by s aj q or by s r the expression by involves multiplication appears times so a new variable u is introduced to always equal by substituting u for all occurrences of by and updating u whenever the value of y is changed we obtain hardware integer division assert a n b c n q y r j a b loop assert y c n r until a u y u y u repeat u by loop assert assert q ab ab q c n y c n r until y u by y u y lj if u s r then q r ru fi repeat q ab ab ql q c n r ab q this then m the desired hardware integer program its only operations are addition comparison and all of which binary computers the between the extension and optimization steps it his example in both cases a relation was added and kept at all points of the program as a final note we wish to out that most of the previous examples would have from we thank richard constructive comments discussions and research was supported in part by the advanced research projects of the department of under contract by the of scientific research of the states force under cant and grant from the states science computer time was provided by the artificial stanford research n and z manna july on proc symp on proving and france pp dijkstra a nj of prentice r e pe and nj robot v no pp zs sl a model and proc intl conf on software a ca pp sm and b mar ieee trans on software se i no a engineering v sm and z manna v logical of manna z rj and iz synthesis artificial v no pp gj aug a oj phd thesis cambridge mass also as a of acquisition new n jan a class oj j v no pp bm mar a lisp manual tech note i a intelligence center stanford research institute park ca the following is a trace of example the debugging of the real program as executed by out modification system steps and expressions differ somewhat from the example as in the previous section the trace has been and annotated to its false leads that the system followed are also included the procedure modify a program to achieve a new here it s used to real this is the annotated bad given assert and o a lt a times b lt o e setq z o setq y loop assert times b z a lt a times b z times y until y e if times b z y a then setq z z y fi y div y repeat assert z a b lt dv a times b add z e by under which invariant specification an input assertion containing the conditions the hold and fol by output we that the program achieve the assert z div a b lt a b z e the inputs defined by the assert and o a lt a b lt o e note that this specification of the program differs from the input assertion the system by the function match to compare the output invariant with the desired output specification match and and z div a b lt a times z div a b lt a b t add z z e e the first s of both are the same nd the system compares tile second it notices that if the times b could be transformed into b and z into z then the whole conjunct would transform as so it calls the function which the transformation b becomes div b for times b transform times b b transform b div b and for z transform z z result t z times z thus we have found transform b b times z but first tl e system must this first z a b result times z a b to the and prove that the con remains true e implies times z a b z a b be the system looks for additional possible since is commutative an attempt s also made to all z e with ali e z this with transform b div b yields transform b b z l z times e however this set of transformations s since there s no way to transform the variable z into the constant expression times e in its search for alternative transformations system also finds equivalent of e q and times b z a lt a add times b z times b z a lt a times b z times times b e b e them yields transform e e the the the system now s the function of the two transformations and in each assert o a lt a times b lt o e setq z o setq y loop and times b z a lt a times b z times y until lt y e f times b z y a then setq z add z y fl setq y div y repeat assert z a b lt div a times b z e transform b b times z which transforms constants is now called and b s replaced by b lv b transforms a variable variable z becomes times z in this case the times z this may expressions from the lefthand of the is used to times z to all to z setq z o result setq z l id o and setq z z y setq z times z y the transformed program s and o a lt a times b lt o e setq z div o se y loop assert and times times z a lt a times b times z times y until y e if times b t is z y a then z div times z y fi setq y y assert times z a b lt a t b add times z e statements l iv are now replaced by executable ones v as part of a step the have been they include by where possible thus the system obtains its first assert o a lt a times b lt o e setq zi setq y loop assert times b times z a lt a times div b times z times y until y e if times w b all t z y a z u m z y fi setq y v y repeat assert and times z a iv b lt a times b times z e assertion lt must be proved that the transformed s led by the input input ie implies o a lt a l o e o a lt a times b lt o e and it does since times div b is equal to b the second possible transformation is now led assert o a lt a times b lt o e setq z o setq y loop assert and b z a lt a times b z times y until y e f z y a sq z z y fi setq y y repeat z a b lt div a times b add z e div e after a second assert o a lt a times b lt o setq z o setq y loop assert and times b z a lt a b add z times y until y e if times b z y a then setq z z y fl setq y dv y repeat z a b lt a times z div e lt must be shown that the transformed s led by tl c input on i o a lt a b lt o e o a lt a times b lt o e which s indeed true since ab ls by ab and oe is to oe 