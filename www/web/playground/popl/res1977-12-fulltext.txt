implementation of an array bound checker department of computer science university pittsburgh pa and department of information science university of introduction this paper describes a system which checks correctness of array accesses automatically with out any inductive assertions or human interaction for each array access in program a condition that the subscript is greater than or equal to the lower bound and a condition that the subscript is smaller than or equal to the upper bound are checked and the results indicating within the bound out of bound or are produced it can check programs at about lines per ten seconds and it shows linear time complexity behavior it has been long discussed whether program verification will ever become practical the main argument against program verification is that it is very hard for a programmer to write assertions about programs even if he can supply enough assertions he must have some knowledge about logic in order to prove the lemmas or verification conditions obtained from the verifier however there are some assertions about programs which must always be true no matter what the programs do and yet which cannot be for all cases these assertions include integer values do not overflow array subscripts are range pointers do not fall off nil cells are w this research was supported in part by the research projects contracts by the force of scientific research c and in part by the university of computation center the views are those of the authors not if they are still uninitialized variables are not used pointed to since these conditions cannot be completely checked many compilers produce dynamic checking code so that if the condition fails then the program terminates with proper these dynamic checking code sometimes take up much computation time it is better to have some checking so that of data will not occur but it is still very that the computation stops because of error moreover these errors can be traced back to some other errors in the program if we can find out whether these conditions will be met or not actually running the program we can benefit both by being able to generate efficient code and by being able to produce more by careful of errors in the programs similar techniques can equivalent be used to subexpressions detect or redundant statements to do more elaborate code movement optimization the system we have constructed runs fast to b used as a of a the system first creates logical assertions immediately before array elements such that these assertions must be true whenever the control passes the assertion in order for t access to be these assertions are proved using similar techniques as inductive assertion methods if an array element inside a loop or after a loop a loop invariant is synthesized a theorem prover was created which has the decision capabilities for a subset of arithmetic formulas we can use this prover to prove some valid formulas but we can also use it to generalize formulas so that w can more general loop invariants theoretical considerations on automatic synthesis of loop invariants been taken into and i complete formula for loop invariants was obtained we reduced the problem of loop invariant synthesis to the computation of this formula this new approach of the synthesis of loop invariant will probably give more basis for the automatic generation of loop invariants in general purpose theoretical basis the correctness of array accesses can be stated within the theoretical framework of the weak correctness of programs that is we only have to show that the assertions placed immediately before the array element stating that the subscript expressions are within the defined bounds of the array hold whenever control of the program comes to the assertions the major problem for making an automatic verifier which does not require any assertions by programmers is that the system must loop invariants some research has been toward the generation of loop invariants o a common characteristic of all the research is that the method depends on heuristics that is the system proposes some assertion as the loop invariant and let the prover decide if the program is provable from the loop invariant the difficulty is that if it does not work it is hard to see whether the program is not correct or the heuristics are wrong what we will do here instead is to obtain a complete formula for loop invariants just like series expansion of functions wi give a complete description of the function even though they are not usually and infinite chain of approximations we obtain an infinite chain of approximations to the general loop invariant from this formula furthermore prove is not a correct loop invariant which which is always true to the top of the loop exit condition if the assertion we want to assertion wo cannot a is true at entry to the loop and whenever control comes and finally which implies the so what we can hope to obtain is a formula which is a loop invariant if and only if the assertion is correct this precondition here is that formula is similar to of dijkstra what we are only concerned the weakest is different about weak correctness the formula is while c do s q c o q and wi c o for i stands for weakest precondition the definitions of the weakest precondition q is that if s is executed in the state satisfying q then q is always true termination of s and no weaker condition satisfies such a condition for assignment and conditional statements are the same as those of the weakest precondition it is easy to see that if while c do s q is true at entry to the program then while c do s q is always true whenever control comes back to the beginning of the loop this is because while c do s q a c s while c do s q it is easy to see that while c do s q a c q whenever the while terminates q is true at exit if and only if while c do s q is true at entry thus this is the desired formula note that no heuristics are involved in out the loop invariant the problem is reduced to computing this formula and we can claim that sq is the jth approximation in a sense that it may be a loop invariant and if j st approximation is a loop invariant then jth approximation is certainly a loop invariant we will a procedure for checking whether jth approximation is a loop invariant or not let lj stand for sq the jth approximation to the loop invariant certainly lj a c o q iii order to establish that lj to be a loop invariant we have to show lj is true at entry and also lj a c o lj but so c o w q that is lj a c is equivalent to so all we have to prove is to prove these two equations there is a nice thing about this method and that is we can use all the results of computation up to j st approximation to compute the jth approximation the reason is if was failed to be proved then we can use this as an assumption for the next step and also we can back substitute this formula around the loop and we can obtain this fact suggests an iterative method of weak correctness of programs without loop invariant because of this iterative nature we call it the induction iteration method induction iteration method step i c q step try to prove from if it is true the program is correct and the proof is done step we have to see if is true at entry to the loop this through the program segment before the while statement if it can be shown to be false at entry the program is not correct and done if it cannot be shown to be true the algorithm halts indicating step we will use to prove next step so we will create then we will create wi from by the formula c the step i il go to step end of algorithm this iteration may never particularly if the program is not correct we may very well not terminate if we implement this algorithm therefore we have to put a bound on the number of iterations which determines the limitation of the system we have to note here that the size of conditions cr the size of grows more than linear to the size of the program s the reason more than anything else is that because of the rule b do s else sr b b the condition more than in the size each time it is through statement since it is conditional that the performance of a theorem prover is exponential to the size of formula it is very important to keep the size of the condition to be constant if wc want to make a system works in linear time for this reason w have developed a theorem prover which not only proves but also simplifies logical expressions and modified the semantic rules these practical considerations will be discussed in the next two theorem prover the synthesis of loop invariant is on a ground but we need to create a powerful theorem prover to make a practical system the domain we are particularly interested in is an integer domain and formulas we have to prove is inequality relations with only universally quantified variables before we prove these formulas all the arithmetic expressions and relations are converted to normal forms normal forms of arithmetic expressions and relations have been discussed in many verification literature as we have discussed in section the main source of the exponential explosion in most of the comes from the of conditions to be proved the theoretical limitations at least for the time being us to create a theorem prover which behaves better than exponential time complexity this suggests that instead of efforts in creating algorithms to reduce the speed of theorem prover by a constant factor w should our efforts in creating simplification and generalization methods which limit the growth of conditions even though the size of the programs grow since w are representing arithmetic expressions in normal forms the size of expressions do not grow very by substitution of assignment statement the problems are created by conditional statements the detail of algorithms are discussed in the next section in this section we will discuss about powerful theorem prover which are used to simplify conditions the basic algorithm of the theorem prover is linear solver which is based on the proved this is shown to be true when first enters the loop to see this is true when substituted around the loop we compute back o k o ta o div this is easily shown assumptions to be true from the low o and low high as you can see the prover not only simplifies generalizes the approximations enable proofs in many cases generalization by the the problem but also of loop invariants to system the system configuration is straight forward closely following the implementation suggested by the previous two sections only simplification not discussed is the treatment of conditional statements extraction of local conditions a program is scanned once in the order they are presented as a text whenever an array element ae is found conditions a e and e are created as the conditions of the innermost statement containing the array element we call these as bound assertions if the statement is an assignment statement or a conditional statement the condition must be true immediately before the statement if the statement is a while statement the condition must be true at entry and for each subsequent iteration of the loop semantic treatment of statements each bound assertion created for an array access is transformed as it is through the statements according to the semantic definitions of the statements these assertions are at the same time simplified using normalization and th prover the process terminates either when there are no in front the condition is proved to be true or false or it a while statement since wo cannot iterate on a while statement we return the result u if we fail to prove or within a certain number of iterations the semantic definitions in principle the weakest of statements are precondition rules but vj use some conditions as we transform statement lists if we have a statement list s s and p is the assertion to prove after s then we precondition of p over s if this precondition is or false or we terminate the process and return the corresponding otherwise we compute the precondition of over s p and return that as the result assignment statement variable if we have an assignment to a simple x fy tb en we return f y x p substitute e x p is an expression obtained from p by substituting all the occurrences of x by e if the statement is an assignment to an array element fy is returned where from a by substituting then a ef y is an array obtained element by fy if in the case of the ifthenelse statement if c then s else s wc compute both the precondition of p over s p and the precondition of p over s if any one of them is false or the process terminates immediately with the corresponding result as the result of if p and p are both true then return true if p is true then we compute c wi by the theorem prover and return the generalized formula if is true then we compute c lp by the theorem prover and return the generalized formula otherwise we compute c i p a c by the theorem prover and return the conjunction of generalized formula namely next if the statement if it is of the form is statement if c then s then we compute precondition of p over the statement s p if p is false or we terminate the computation and return the as the value of if p is true we return the method of linear programming this class of prover is quite for array bound checking array subscripts are in many cases linear expressions the prover generally proceeds to of a set of linear suppose o o o is the set w are going to show unsatisfiable that is xe o n xe o o is false the prover selects x to be the variable eliminated from the set then we classify this set three subsets that the coefficients of all the inequalities in the set are positive the coefficients of all the inequalities in the second set are negative and each in the third set does not contain x we add each member of the first set and each member of the second set such that terms of x will we may have to multiply each inequality by some constant to if any one of them produces a y formula the proof is successful and the process we replace the set by the union of the newly created set and tl e third subset of the original set in this case o ee o are the result of eliminating x the procedure is iterated until we m all the variables and obtain false statement in which case the set is unsatisfiable and otherwise satisfiable suppose the set is satisfiable and the result of elimination is a linear e o then e o is the equation which is just sufficient to give t y e o s in a sense the most general assumption at this moment the system proposes e to be the of the lemma and tries to this instead if there are several inequalities then each of them is in turn chosen to be the generalized lemma powerful we will illustrate by an example th me techniques are how var a of t u low high while high do begin middle low high div if k then high middle else low end algorithm this is an essential part of a binary search which will he proved in section one of the condition we have to show is here that middle at then what we first try to is w wo aq high o div or after simplification high j since this is not provable we try to see if this is when control first enters the loop we wo though two statements and we true at now w is formulated as wl low f high o div low a c low div a div k div high div or wl low a div k a high z a low high div k a though at by the while body wo w is a high a k o a a low high a div k wo the latter conjunct is w is simplified to high a div k z so wo w is easily shown to be true when control first enters tbe loop but not itself provable therefore we compute w by w around the loop that will not be provable again this iteration many not terminate for some time now let us look at the same example using the generalization by the prover wo is not valid when it is computed the computation is to show the of low high and lo the elimination of high generates z low o and if vm have o vw can show the y we set up low o as the generalization of w lo be value of lc p otherwise vw the generalized value of c p a vc p while statement the semantic definition of a while statement c do s relative to a post condition can be defined in two cases depending on where p comes precondition the first case is that p is created as the of s then p c o p is the first approximation of the loop invariant if p is the precondition of the immediately after the statement in a statement list then c p is the first of the loop invariant let these first approximations to be wo we compute w and if wo is true then we return true as the result of the back substitution wo through otherwise we first the statements preceding the while statement if the result is or false we return it as the result otherwise we create w by the formula c w we generalize wo w by the prover and repeat the similar process creation of assumptions since there are a number of array accesses wc want to use the results of previous proofs so that wo do not have to do similar over and over again for this purpose we have a mechanism for inserting assumptions in the program all the array accesses are scanned in the order they appear in the text as soon as the array bound assertions are proved they are inserted just in front of the statement in which the array access occurs these assumptions are used for proofs of other array bound assertions since the rest of the bound assertions are always created after these assumptions most of the assumptions are effectively used to prove or to simplify back substituted assertions analysis of loops each while statement while c do s a set gf variables of s which may be changed in the course of execution of s is collected if we want to prove wi to be the invariant of this while statement we first see if any of the variables of wi appear in this list of the changed variables lf they do not occur in this list wi will not change by and it is an invariant of the loop if wi is at entry w can the computation to in some cases elimination of variables as we generalize and prove the choice of variables to eliminate is important for various one strategy may be to try to choose a variable which has only one member in the set of positive set or in the negative set this is because we do not to the number of inequalities in this system what we do is to choose which might be changed in the course of the execution of the while body this strategy is useful for generalization because if we can eliminate variables which may be totally from the condition then we can use the strategy described in and we no longer have to the while body to determine the invariance of the condition the been proved bounds the following binary search program has that all the array accesses are within proof required z cpu seconds type of integer procedure var low high integer begin high low while high begin do middle div if then else if key then high middle else low end if key then middle o end there are three accesses of a two within the loop and one outside of the loop we are going to show how the system proves that the array accesses are within the ranges the are not trivial since does not change also there is an integer division and we have to make sure that the right is performed when we expressions we also have to that middle keeps within range even after the end of the execution of while statement the system searches an array element from the of the program it first finds in the statement if then it creates an assertion middle o at location to the correctness of the array access relative to the lower bound of the array a this assertion is and becomes high low div at location this is normalized low o to while since the loop condition condition of the statement is high low o high low o high low o is proposed as the first the loop invariant the theorem it to low o approximation of prover generalizes to show that this control first enters the condition is z it becomes condition is true when while statement this to z at location inductive and it is proved hypothesis for the proof of the is assumed to be true at this is through the loop body since there is a three way branch are created corresponding to each branch a path through branch creates high o this has to be proved hypothesis by the inductive and the loop condition high low o imply at loop high o these two assumptions and clearly high o through done it the second is created by the path location and since no modification is is clearly an invariant through this path the final is created middle o by the path though at and low high o inductive at hypothesis this is again proved from and the loop invariant the to prove that middle upper bound of the array a middle is smaller than the is created and the first approximation the loop invariant at becomes high o to using the generalization high high high the three o low o are hypothesis inductive and are the same as by the inductive can be shown to be true by the hypothesis and the loop invariant o stored at this and at point two assumptions middle middle o are created and within the second array access is proved the bounds using these assumptions to be the third array access is immediately after the loop all we have to do is to show that o middle is true at the loop head every time control passes this location this can be proved similarly the following is the output from the system the structure of the program is essentially maintained and the array elements have modified outputs indicating the results of checking the format is array name check subscript expression check result where check result is any one of i o u i means the subscript is within range o means the subscript is out of range and u means that the system cannot determine either way typical output looks like which means e is greater than or equal to the lower bound of a but it is not clear whether e is less than or equal to the upper bound of a ef is greater than or equal to the lower bound of b but it is greater x than the upper bound of b type of integer procedure var begin high low while high low o do begin middle div if then lo else if o then high else low end if then middle o end time cpu the next example is the tree sort this is to that some of the more difficult arithmetic operations like multiplication by a constant can be properly it is not very difficult for a person to observe that all the array accesses by the subscript j are done correctly since in the inner most loop j is and the loop condition is j n however among the array accesses with subscript i the second and the third array accesses are not trivial even for a human it needs a clear understanding of how this program works and how i and j are used once we know that j i at the loop head we know that since j is increasing so is i is maintained because at the loop head the value of i is m the same as the value of j or greater than j if j n and aj aj of the previous iteration and at that time j is less than or equal to n this is informal human reasoning the array bound checker does not use similar reasoning but it to prove this by systematic inductive iteration and by the prover another thing that is that this program was checked with cpu seconds which is within the usable range especially considering that the system is written in lisp a of t begin k div while ki o do begin i k n copy j i while jn o do begin if o then if then j lj if o then begin i j j i end else j nl end copy k k end k while k o do begin i n k copy j i while jn o do begin if o then if then j lj if o then begin ai i j j i end else j nl end copy end work e work k end time cpu previous has now this next example is almost identical to the program except the conditional been changed from statement if jn then if then j jl to if jn a ji evaluates logical expression in so j may become greater th an n thus the error has been correctly detected this is a valuable information to the programmer var a of t begin k div k o do begin i k n copy j i while jn o do begin if l jn oa o then j lj if l o then begin i j j i end end else j n copy k end k while k o do begin i n k copy j d while o do begin if oa o then j lj if l o then begin i j j i end end else j nl end copy work ah work k end time cpu this final example is taken from lexical analyzer of pascal compiler the program has been modified from the original program by taking out several repeat statements so it is not a correct program from the of lexical analyzer correctness however we have been able to put this program through the checker without any intermediate the input is lines of code including some comments it takes seconds to process the system actually found an error at location whenever buf len the system out error messages but it does not reset therefore the following array element will be out of bound the system cannot check the array access at location because is a global variable this is the kind of examples we need some from the program stating the behavior of global variables and parameters type ct integer end type ct integer st index integer type type type type of st of ct of p g of en r ll of f i en integer fl ci q div if o then q else lq c begin if then begin begin c if buf ion o then error c else input true begin buf index if i en o if buf then ch else begin s ch buf i else c begin j ch ch begin if e then begin cur ion on cfl end integer begin i o begin if begin index a shift i li if then begin k b k vk else k b f sh end on f top tree tree tree p q en ct ct less integer begin if top then begin first true e else begin begin l st st length if then begin true k ord begin if c ct a then else if eq true then first top end else begin ct ct o ct less o l ct o if ol a o then ct if ct then begin p right first if right nil then p else begin p left first if left nil then top left else if o then begin p right len f if top then r else begin p left ii len first p tree if then end end tree begin begin if then error if st then ct index index st left nil right nil k begin length i en ct index en st st ct begin st ct nil input title y input begin en first if then p if first then begin in p end else end p cpu conclusion system there are several can do limitations to what the one class of problems which this system cannot do is to check the correctness of array accesses in a loop if the correctness depends on some data whose values are set before the execution of the loop one good example is a very widely used class of techniques to speed up the sequential search by storing some data at the end of the array so that the comparison loop always terminates the program is var a of t begin key il while key do i end the while loop terminates because a is the same as key and that will make the while condition false using our methods we will not be able to prove this since what we have to prove as the induction step is i a a key i conventional program using logic system have the similar problem that is even though a loop does not modify some portion of the data we have to declare these properties as the loop invariant the first author this problem and has generally called it a frame problem of inductive assertion method terminology from similar problems in artificial intelligence the solution to this problem is to extend the rules for loops so that properties of data can influence the proofs inside the statements and after the while statements using notation the new rule is pv pv a a a a while do where x is a set of variables which do not change their values within v is a set of variables which may change their values and v is a set of totally new variables corresponding to v the correctness and im of this and other frame problem free for various syntax constructs are discussed in and we can use this technique to prove the previously problem of linear search we failed to prove i a key i at the loop head but if we replace i by and w to the f wo obtain a key o and which is now a valid statement we can show the correctness a an array obtained from replacing a by key for here a by the second problem is that the capabilities of the system are not good enough for many problems ultimately we must ask the user to give some assertions or on failure the system to indicate the reason for the failure and ask the of the user we can say about the same thing for procedure and function calls and their definitions when we are checking procedure definitions in the program just as we treat main programs however if we come to the of the procedure body we can do two things either we say that the conditions cannot be determined and report to the programmer the reason of or try to check that these conditions are true at each calling occurrence we can also use induction iteration method to synthesize entry conditions for recursive programs currently we take the former approach but eventually we either have to ask programmers to put in a number of entry and exit assertions and also ty to check all calling occurrences to see if the conditions are right the development and the availability of this kind of system will change programming language design just as verification and formal semantics have created a great effects on the programming language design we think we will see a great number of features which security and reliability will be put into programming systems so that these properties can be checked at compile time and create more reliable programs without the runtime efficiency because the time complexity is good and the size of a program it can handle is quite substantial we that the production version of system soon will he available to the public and verification be directly the computing community the first author is for discussions with goto paul morris and the references cousot p r cousot static verification of dynamic type properties of variables research report u s m g e w guarded commands formal derivation of programs comm acm august pp and sm b a synthesizer of inductive assertions ieee trans of software engineering vol se no march pp sm z manna a logical analysis of programs comm acm april pp jc a program verifier phd thesis dept of comp university september sci j p j some problems from of artificial intelligence machine intelligence pp the n automatic of programs with complex data structures thesis dept of comp sci stanford university february n iteration induction in preparation method n frame problems in preparation in logic the synthesis comm acm b of loop predicates z pp 