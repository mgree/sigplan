data types parameters and type checking alan j demers james department of computer science cornell university new york l introduction in statically typed programming languages each variable and expression in a program is assigned a unique type and the program is checked to ensure that the arguments in each application are with the corresponding parameters the rules by which this is must be carefully considered for modern languages that allow the programmer to define his own data types and allow parametrized types or types as parameters such languages include clu liskov and russell types as parameters and even a form of of signatures our method defines a cal l where signatures are to the types of reynolds each identifier and expression is given a signature and applications are when argument and parameter signatures are equivalent under a simple set of signature transformation rules below we present the signature calculus of russell we also present a semantic justification of this calculus and specify the language con necessary for us to justify our purely static approach to typechecking demers these features increase the expres al w of types russell power of the languages but also increase difficulty of typechecking them the the treatment of typechecking described in this paper is used in the russell programming in this paper we describe a treatment of language described in demers the type typechecking that makes it possible to do com structure of russell is based on a novel view of static checking with a general the meaning of a data type presented in ation mechanism allowing parameterized types demers and described as follows a or or specific permission this work supported by national science foundation grant acm data type is a set of named operations that pro an interpretation of the values of a single universal value space common to all types for the purposes of this paper the important of this definition is that it allows us to treat data types as values in complete analogy with procedure and function values in conventional languages the treatment of data as values leads to a in the mechanism of russell the russell gives a meaning for the value of any identifier or expression including types and variables vari ables are treated essentially as reference values thus any construction in the language may be parameterized with respect to any of its free identifiers even type identifiers using a straightforward callbyvalue semantics the benefits of this type completeness as a language design principle are discussed in the other paper in this proceedings by the authors here we are concerned solely with its implications for typechecking in addition following of we treat declaration and as semantically equivalent thus the language has only a single straightforward semantic mechanism callbyvalue parameter of new names passing for in particular the is not necessary to treat type declarations and type parameters as special aa must be done done in and clu finally we note that every value in a russell program either is treated as an operation ie a procedure function or type or else is interpreted by the operations of some type thus the set of primitive combining forms in russell is extremely small consisting of those forms needed to interpret operation values selection of a com of a type and ion of a procedure or function to a list of argument values the purpose to typechecking depends on view of what a data type is if types are viewed a of values as in pascal or as sets of values and operations as in morris or the algebras of goguen an attempt to apply an operation to a value of the wrong type produces an erroneous result ie a thus typechecking is con an essentially redundant way of at compiletime that a program will produce an error when executed in our view of data types however all types share a single universal value space any value may be interpreted as belonging to any type or even as being a type thus a application does not necessarily generate an error it simply produces a spurious result by its argument note that this view reflects the situation in a typical language implementation on a machine values are represented as untyped sequences of bits and can be partitioned into sets only by introducing explicit fields with the overhead in time and in this frame work static typechecking takes on a more tial role it is in order to guarantee that values produced by one type will not be by operations of another type in practice there is not much difference between these points of view for simple languages when static typechecking is sufficient to that no application will be the representations of values of dis types need not be distinct eg most pascal implementations will represent both and integer values in a single word however our view of types that no matter how the type of a language becomes it must still be possible to do all typechecking statically since no additional information will be available at run time to facilitate it ms in checking m ds in a programming language that provides only a finite set of builtin the typechecking rules can be specified frequently these rules are with coercion rules and runtime consistency checks the rules are an example flexible type definition and parametrized type mechanisms however make it essential that a programming language design be based on a clear understanding of the meaning of data types and typechecking the use of data type definitions that the set of types with which the typechecker must deal is no longer finite thus the typechecking rules cannot be an exhaustive list of special cases instead the rules must show how the result of any type constructor in the language behaves with respect to existing builtin or userdefined types that this is not straightforward is seen in the between the typechecking rules of languages in the complexity of the rules and in the difficulty of providing semantic for them below we describe several checking in which this problem aspects of type is apparent two basic problems arise a types that are semantically equivalent but have distinct denotations and b type denotations whose mean ing depends on runtime argument values the treatment of types as values and the principle of correspondence suggest a solution to a which appears briefly in demers and will be discussed here problem b greatly only our syntactic motivated described treatment of typechecking it also the scope and import rules of russell and justified later in this paper consider a program like the following which a new type is declared to be an existing type in to t integer t integer in let x wt y wt x y in russell syntax or syntactic types thus t and tr are types x is a variable of type t and y is a variable of type t whether this program is considered legal depends on whether types t and t with identical definitions are considered equivalent by the typechecking rules and give report answers to this question says nothing at all while the pascal by the principle of correspondence the above program in russell is equivalent to one in which the type declarations are replaced by parameters ill x y h p integer integer a typechecking system based on as used in may or may not declare the above program correct however if the call p integer real is added then the program as a whole must be con though it is whether it is the body of p or the call which is invalid our to treat type parameters uni with other kinds of parameters leads us to conclude that the body of p is invalid since we can typecheck and give the meaning of an ordinary procedure independent of any calls of the pro we must be able to do the same for a polymorphic procedure this requirement a interpretation of polymorphism and to a set of typechecking rules in which distinct type names are never treated as equivalent parameterized types introduce a second kind of problem in which identical type expressions may denote different types because of a change in the value of some variable the usual interpretation of equivalence for two applications of a parameterized type like is that corresponding argument must be equal thus the assignment x y where the types of x and y are ey and is legal only when na and nb have the same value for arbitrary expressions it is clearly able whether this will always or ever be the case thus that the runtime values of type arguments be equal makes static typechecking of such an assignment impossible further arise if as in russell the programmer can the meaning of equality for any type conventional approaches to this problem either that arguments to parametrized types be manifest constants or defer typechecking to run time in such cases each approach has its draw limiting type arguments to manifest con restricts the programs that can be written this ia a major problem in pascal how ever as was argued in section our view of types runtime typechecking thus we have been led to language restrictions in the form of scope and import rules described below to ensure that identical type expressions denote equivalent types without that all type be manifest constants in this section we present the typechecking rules of russell to escape the undecidability problems described above russell type checking rules avoid the use of runtime values of expressions without that all type ments be manifest constants instead the rules are applied to uninterpreted type expressions as purely syntactic forms each identifier in a russell program ie given a similar to a of reynolds the signatures of expressions are determined from the signatures of their components by a set of purely syntactic composition rules finally each procedure or function application is checked to ensure that corresponding are equivalent argument and parameter under a simple calculus signatures of ture transformation rules described below to justify the claim that our typechecking rules are sufficient to prevent of values the syntactic transformations of the signature calculus must be provably w also the language must be constrained to guarantee that identical type expressions in the same scope which would be equivalent under the signature calculus are semantically equivalent in russell a simple import rule discussed below is sufficient expressions to guarantee are equivalent that identical type in russell each identifier and expression in a program is given a syntactic type or a signature may describe a variable a value type or an operation procedure function or signature w in this context i i a ie any expression that has signature according to the signature composition rules described below in particular the may contain free identifiers subject to the import rule described below for example are valid w stack and yz stack and distinct nm integer mn integer signatures the signature of a procedure or function gives an identifier and signature for each ter plus a signature for the result if there is one in russell functions may produce results having any signature including variables func tions or data types since we view a type as a set of operations the signature of a type is sim a collection of operation signatures with an identifier naming each component operation bound identifier or which and a the com may use as a type denotation meaning the type in which the component i signature q id the need for an identifier associated with each parameter of a procedure or function arises because a parameter name may appear free in the signature of other parameters or the result for example a polymorphic function might have ture tt x yl t where the type of the second parameter and of the result depend on the first argument a similar technique is used in the polymorphic lambda cal of reynolds where a version of the above signature would be written at tt the rules for composing signatures of site expressions are completely natural if one in mind that they deal with signatures as syntactic objects and not as values as above there are two primitive forms of composition in russell of a type and of a component of a function to a list of argument values c t ions consider selection of the fn component of a type t where t is some arbitrarily complex type denotation with signature f sig the signature of the selection t f is obtained by textual substitution of the type denotation t for the local name t in the signature of the f component for example it s ig it if integer has signature then integer has signature i integer w integer selection illustrates the importance of local names in type signatures if another type t has the signature as integer the signature of t is this allows operations selected from t to be to t values rather than to integers the composition rule for function application also involves textual substitution of denotations for bound identifiers consider an application ak where f is an arbitrarily complex with signature denotation the result signature is obtained by textual of argument for corresponding parameter identifiers in the result part of the signature of f i al ak i i pi s pk thus an application of the form where f has signature d would have signature integer at no type is involved here the result signature of a application is a welldefined syntactic object which may itself contain applications of course xi a calculus to typecheck a russell program we must guarantee that the signatures of the arguments and parameters match in function or procedure tions every parameter in a russell program has an explicit signature and every argument can be given a signature using the composition rules described above thus the russell typechecking rules operate by transforming and comparing tures note that since types themselves have values and signatures type parameters require no special treatment typechecking an application proceeds in two steps ex of parameter signatures by ment denotations and of argument and parameter signatures the application ie legal iff each argument signature matches the corresponding expanded parameter signature consider an application where p has signature s ak q and the arguments have signatures first the parameter signatures are expanded by textual substitution corresponding parameter of arguments for identifiers thus the the i th expanded parameter is i al i i pi ak s pk signature expansion is used so that the parameter signatures may be modified to reflect the among the arguments of a particular call of an operation for example if g has sig nature integer x tn then the expanded parameter signatures matching the call would be used in q integer and h argument and parameter are said to il iff the argument signature can be transformed to the parameter signature using a small set of syn tactic transformations the calculus the signature calculus rules are a re n m ing the local name on a type ture or the parameter names in a procedure or function signature may be uniformly replaced by any new identifier thus for example the signature matches the signature sig the substitutions i i sig are necessary because x and y may appear free in the signatures and sig b ord in two type signatures match if the signatures include all the same component names and components have matching signatures for example the ture matches yet t if sig matches sig t and sig matches sig c rw be simplified an argument type signature may by eliminating some of its operations thus the argument signature can be reduced by a to l this rule is the means of data type definitions required in russell all the above rules are straightforward easily explained and can obviously be shown to be it is important to note the absence of any transformation rule for variable or value signatures to match two variable or value signatures must be identical there are no transformations based on knowledge of the behavior of particular types this rule has the advantage of simplicity especially when with the type rules of pp or the type subsumption syntactic satisfaction and implicit rules of pp above we described an approach typechecking based on the manipulation to static of type expressions as syntactic objects clearly such an approach can only work if language constraints exist to ensure that identical type expressions always denote semantically equivalent type values at the same time these constraints must not be so restrictive as to prevent eg the computation of arguments to parameterized types a formal definition of semantically equivalent type values requires a semantics for the language this is currently in preparation demers b however we can ensure the correctness of our type checking rules in a way that is largely independent of the details of the formal semantics by that the meanings of russell programs be invariant under certain syntactic tions our approach to is described below the scope and import rules of russell have been designed to guarantee that denotations have the subst tion let d be any denotation described appearing as follows in a legal russell program and let d be a ie neither d nor any of the free identifiers of d has w signature define the m of d to be the smallest enclosing scope in which all free of d are bound this has the form kc c ill the substitution p property demands that an equivalent program results if all occurrences of d are replaced by a new identifier bound to the value of d id informally this rule requires that evaluations of identical denotations must produce semantically identical values and must be free of observable sideeffects note that a consequence of this rule is that russell pro grams like the lambda calculus have the church property in particular terminating pro grams cannot distinguish between callbyvalue and callbyname in russell the substitution achieved by enforcing the following property rules is the builtin types have the substitution property this constraint affects the signatures as well as the meanings of certain builtin types for example the signature for the operation is ti integer this signature would be as it can easily be used to write denotations that do not have substitution property using any semantics for example p p p p the in this case is to introduce a type heap analogous to an untyped collection and require a heap variable as the first argument of a dereferencing operation with this change has signature tic heap integer w integer and cannot be embedded in a tion as was done in the example above no identifier may be in a scope in which it is accessible this rule is necessary to avoid capture of free identifiers of the signature of an argument when that argument is passed to an operation declared in an outer scope for example it such clearly incorrect programs as m p t t y yet q which without the unique visibility considered legal rule would be no free identifier in an operation ie procedure function or type denotation may have signature this rule simply ensures that all operation denotations are this is the most restrictive of the three rules as it prevents procedures from or modifying global variables and applications like array n integer where n is a variable the rule does not how ever prevent obtaining the effect of the above application it is simply necessary to introduce a new identifier n and bind it to the current value of m vn n h array vn integer in our discussion of typechecking we have made a careful distinction between signatures and data types data types are sets of operations and have values signatures are purely constructs used by the typechecker and do not have values in particular an operation ture like is not a type thus t is not a legal signature variables and there are no it is difficult to see how variables could be introduced directly into the russell typechecking framework for example suppose we to produce a type f that interpreted values as functions the operation of the value of an f variable would have signature f nontrivial application of this function would be an operation denotation since the result ia a function that imported a variable the argument and thus would violate the import rule it is possible to add to russell using the constructor sig be any operation signature then is a type with signature sig new hi i yl i in w i out a sig for example the type ff is similar to the type f shown above to violate the import rule the key difference is that the operation of fr yields aa f rather than a function to obtain a function value it is to apply the out function direct conversion of an f variable to a function by position of and out eg x still violates the import rule however in most cases the same effect can be achieved by first binding the value of the variable to a new and then applying the out function k vx x h vx since vx signature ft the import and typechecking is rule is the constructor allows in russell programs type declaration for example the recursive t u x is wellbehaved at an example of an expression of this type is the following identity function clearly correct f t f can be applied to itself way eg in a type from this f example we can conclude that with our view of data types and application typechecking are the fundamental to prevent goal of of values can be achieved even if is allowed the ability to define new data types and to produce objects of arbitrarily complex kinds by of typechecking greatly increase the difficulty in this paper we investigate the problems of typechecking in the presence of these features and present an approach that allows static typechecking in the presence of completely general type definition and ation present mechanisms are simple the typechecking rules and most importantly we are based on the ground of a semantic of data types thus a basic test of the correctness of the russell design has been to guarantee that the typechecking rules are to prevent any combination of language features from being used to a value the obligation to prove this property of the language makes it to look for a few general mechanisms rather than a large number of features z references demers demers a j types as values encapsulation r a h pp and polymorphism proceedings g data typechecking x demers demers a russell department and j report tr revised computer cornell university report on science september demers a and j as a language principle pro pr es d pr uo s iu m demers a and j a formal tics for russell in preparation seman goguen goguen an initial tion j heights ja and eg algebra approach to the correctness and implementation of data types report rc ibm watson research center ny languages pj the mq next programming liskov liskov son and in alan craig clu h w russell abstraction august morris morris james nn m ua h types are not annual principles ti s s q pp sets reynolds reynolds structure john towards a theory colloquium q of type paris interference d pp john syntactic pr fifth control annual of w a cd an informal definition of department of com science university 