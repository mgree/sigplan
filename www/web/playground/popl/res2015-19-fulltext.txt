a c static analyzer inria leroy inria and u and u david and popl consist complete well easy to abstract this paper reports on the design and soundness proof using the coq proof assistant of a static analyzer based on abstract interpretation for most of the c language recursion and dynamic allocation establishes the absence of runtime errors in the analyzed programs it a modular architecture that supports the extensible combination of multiple abstract domains both relational and with the compcert c compiler so that not only the soundness of the analysis results is guaranteed with mathematical but also the fact that these guarantees carry over to the compiled code categories and subject descriptors d software engineering checkers correctness proofs f logics and meanings of programs specifying and verifying and reasoning about verification keywords static analysis abstract interpretation soundness proofs proof introduction verification tools are used during the development and validation of critical software these tools provide guarantees that are always independent from those obtained by more conventional means such as testing and code review often stronger and sometimes to obtain rigorous testing can be very expensive verification tools are based on a variety of techniques such as static analysis model checking deductive program proof and combinations the guarantees they provide range from basic memory safety to full functional correctness in this paper we focus on static for lowlevel languages that establish the absence of runtime errors such as array accesses null pointer dereference and arithmetic exceptions these basic publication to acm acm that this contribution was or by an or of a national as such the a right to or this article or to allow others to do so for purposes only popl january ­ copyright is held by the publication to acm acm properties are essential both for safety and security among the various verification techniques static analysis is perhaps the one that best to large existing code bases with minimal from the programmer static can be used in two different ways as sophisticated bug discovering potential programming errors that are hard to find by testing or as specialized program establishing that a given safety or security property holds with high for the analysis must be precise too many false alarms the tool for this purpose but no guarantee is nor expected that all bugs of a certain class will be found for program verification in contrast soundness of the analysis is if the analyzer reports no alarms it must be the case that the program is free of the class of runtime errors tracked by the analyzer in particular all possible execution paths through the program must be for to use a static analyzer as a verification tool and obtain certification credit in such as or common criteria security evidence of soundness of the analyzer must therefore be provided to the complexity of static and of their input data programs written in big programming languages rigorous testing of a static analyzer is very difficult even if the analyzer is built on such as abstract interpretation the possibility of an implementation bug remains the alternative we investigate in this paper is deductive formal verification of a static analyzer we apply program proof mechanized with the coq proof assistant to the implementation of a static analyzer in order to prove its soundness with respect to the dynamic semantics of the analyzed language our analyzer called is based on abstract interpretation handles most of the c language with the exception of recursion and dynamic memory allocation combines several abstract domains both integer intervals and floatingpoint intervals pointsto sets and relational convex polyhedra symbolic equalities and is entirely proved to be sound using the coq proof assistant moreover is connected to the compcert c compiler ensuring that the safety guarantees established by carry over to the compiled code soundness proofs of verification tools is not a new idea it has been applied at large scale to java typechecking and bytecode verification proofcarrying code and verification condition generators for languages among other projects the formal verification of static based on dataflow analysis or abstract interpretation is less developed as detailed in section earlier work in this area either compcert compiler source c clight cminor cminor · · · control abstract interpreter ok alarms state state abstraction numbers × z int × × convex polyhedra symbolic equalities nr r nr r integer fp integer intervals figure modular architecture of the static analyzer focuses on simple static analyses dataflow analyses no widening domains only or on such as imp compared with this earlier work on verified static is a quantitative jump the source language analyzed most of c is much more complex and the static analysis technique used combination of several abstract domains including relational domains is much more sophisticated this paper reports on the design and coq verification of the static analyzer in addition to the the quantitative jump mentioned above we emphasize as a contribution the modular architecture of the analyzer and its verification including interfaces for the various components that makes it easy to connect new abstract domains to as well as to reuse domains in other projects the full coq development is available at the paper is organized as follows section presents the general architecture of the analyzer the next five sections give more details on the source language § the abstract interpreter § the state and memory abstraction § the numerical abstract domains § and how multiple domains communicate § we finish by some notes on the coq development § preliminary experimental results § discussion of related work § and conclusions and § architecture of the analyzer the general architecture of the analyzer is depicted in figure it is inspired by that of e and is structured in three layers at the top the abstract interpreter that infers abstract states at every program point and checks for potential runtime errors raising alarms along the way the abstract interpreter operates over the cminor intermediate language described in section this language is the second intermediate language in the compcert compilation pipeline the analyzer the compcert frontend to produce cminor from the source c code the semantics preservation theorem of compcert guarantees that any safety property established on the cminor intermediate language carries over to the assembly code generated by compcert combining this theorem with the soundness theorem for we obtain that any cminor program that passes analysis without raising an to assembly code that is free of runtime errors the ve abstract interpreter proceeds by fixpoint iteration that follows the structure of the cminor program section gives more details on this abstract interpreter and its soundness proof the middle layer of is an abstract domain for execution states tracking the values of program variables the contents of memory locations and the chain of function calls this state abstract domain is described in section it is a parameter of the abstract interpreter and has a welldefined interface in terms of abstract operations provided and their specifications outlined below this makes it possible to experiment with several state domains of various precision even though we currently have only one implementation of the state domain concerning values that arise during program execution the domain tracks pointer values itself via pointsto analysis but the tracking of numerical values to a numerical domain bottom layer at the bottom layer of the numerical abstract domain is itself an extensible combination of several domains some are such as intervals and and track properties of the integer or floatingpoint value of a single program variable or memory cell others are relational such as convex polyhedra and symbolic equalities and track relations between the values of several variables or cells two domain transformers perform adaptation over domains the nr r transformer gives a relational interface to a domain and the z int transformer handles the overflow and behaviors that occur when mathematical integers type z and their arithmetic operations are replaced by machine integers vectors and their arithmetic section describes these abstract domains and their verification section explains how they are combined and how they can exchange information during analysis supporting such a modular composition of abstract domains requires that they to welldefined interfaces figure shows one of the three major interfaces used in slightly simplified the one for machine relational domains that acts as between the numerical domains and the state domain all interfaces are presented as type classes a machine relational domain consists of a type t equipped with a semilattice structure a decidable ordering a top element a join operation that returns an upper bound of its arguments but not necessarily the least upper bound and a operation used to the convergence of fixpoint iteration with widening there is no bottom element in domains instead when we need to represent we use the type t that adds a generic bot element to the domain t the three most important operations are assign and assume the x a operation removes all information associated with the variable x in state a simulating a nondeterministic assignment to x the type var of variables is another parameter of the class it can be instantiated by program variables or as the state abstract domain does by abstract memory cells the assign x e a operation updates a to reflect the assignment of expression e to variable x numerical expressions e are built upon variables and constants using the arithmetic logical and comparison operators of cminor they are similar to cminor expressions except that they do not feature memory loads and that intervals can occur instead of numerical constants capturing some amount of nondeterminism when analyzing assignments it is crucial that the numerical domains receive a numerical expression as close as possible to the righthand side of the assignment typically the same expression modulo the replacement of memory loads by variables representing the memory cells accessed then each domain can treat it to the best of its for example on treating x y z an interval domain will simply set x to the sum of the intervals associated with y class t var type type t t bool top t join t t t t t t var t t assign var var t t assume var bool t t var t bool var t t forall x y x y true x y forall x x top forall x y x y join x y forall x n ab ab upd x n x ab forall x e n ab ab n e upd x n assign x e ab forall e ab b ab b e assume e b ab forall e ab ab e ab true e false e ab i ab i e i e ab figure the interface for machine relational domains slightly simplified and z while a polyhedral domain will record the two inequalities x y z x y z finally assume e b a refines the abstract state a to reflect the fact that expression e evaluates to the truth value b either true or false it is used when analyzing conditional statements if switch to keep track of the value of the expression two query operations are provided to help the abstract interpreter detect potential runtime errors and raise alarms appropriately e a returns true if e is guaranteed to evaluate safely and false if it can cause a runtime error such as a division by zero when evaluated in a concrete state matching a and int e a returns the set of possible integer values for the expression e that can be from the information in abstract state a the interface in figure also specifies the soundness conditions for the abstract operations above the specification uses a concretization function that maps abstract states a to sets of concrete environments var num val mapping variables to values here values are the tagged union of bit integers bit integers and floatingpoint numbers ieee binary format that is the numerical types by cminor as in coq the type t of sets of ts is encoded as t prop so that is really a predicate relating abstract states and concrete environments the specification does not use a full galois connection a c because the abstraction function is problematic in a constructive logic such as first it is not a computable function as soon as the type c of concrete things is infinite second for some domains is not well defined the lack of an abstraction function changes the style of specification of abstract operators focusing the specification on soundness conditions and us from the obligation to prove relative optimality for example the specification of in style would be x a x v a v values instead in only style we state soundness as v a x v x a condition correct in figure we could also state relative optimality using only a v a x v a x a a however we to proofs of soundness only leaving relative optimality optional the other two major interfaces of are similar in spirit to what is described above with the following differences the interface for ideal numerical relational domains not to machine numbers but to the sum of mathematical integers type z and fp numbers it also supports communication channels between domains as described in section the interface for abstract execution states that between the abstract interpreter and the state domain uses full cminor expressions including memory loads adds abstract operations to handle memory stores and to push and pop function calls in a call context and to cminor memory states and local variable environments section the cminor language cminor is the second intermediate language in the compcert compilation pipeline immediately preceding cminor the entry language of the compcert described in cminor is structured in functions statements and expressions expressions e t x e load e statements s skip t e store e e t ee en s s if e s else s loop s block s exit n ls goto l return return e reading a temporary variable address of a variable constants arithmetic operations memory load with size assignment memory store with size function call sequence conditional infinite loop terminate n enclosing blocks define label l jump to label l function return for example in the domain of linear rational inequalities the set of pairs x y x y has no best approximation as a polyhedron functions f name pi vars local variables ti temporary variables s function body a program is composed of function definitions and global variable declarations variables are of two kinds their address can be taken with the operator and temporary not in memory expressions have no side effects assignments memory stores and function calls are statements the arithmetic logical comparison and conversion operators are roughly those of c but without overloading for example distinct operators are provided for integer multiplication and fp division likewise there are no implicit casts all conversions between numerical types are explicit statements offer both structured control and goto with labels c loops as well as break and continue statements are encoded as infinite loops with a exit n that jumps to the end of the n th enclosing block the first passes of compcert perform the following transformations to produce cminor from c sources first side effects are outside of expressions and temporaries are introduced to hold their values for example z fx gy becomes t fx t gy z t t this transformation effectively one evaluation order among the several orders allowed in c second local variables of scalar types whose addresses are never taken are out of memory and turned into temporaries third all behaviors are made explicit operator overloading is resolved implicit conversions are and array and struct accesses become load and store operations with explicit address computations fourth and last c loops are encoded using block and exit as outlined in the dynamic semantics of cminor is given in smallstep style as a transition relation c c between configurations c the optional label is an observable event possibly produced by the transition such as accessing a variable a typical configuration c a statement s under consideration a continuation k that describes what to do when s terminates eg move to the right part of a sequence iterate a loop once more or return from current function and a dynamic state mapping temporaries to their values local and global variables to their addresses and memory cells to their contents the continuation k encodes both a context where does s occur in the function and a call stack the chain of pending function calls some transition rules actually perform computations eg an assignment others are rules that change s and k to focus on the next computation the transition rules for cminor are omitted from this paper but those for cminor given in section the difference between cminor and cminor is that every cminor function has exactly one variable called the stack data block while a cminor function has zero one or several variables bound to logically separated memory blocks the abstract interpreter exploring all execution paths of a program during static analysis can be achieved in two ways the control flow graph cfg approach and the structural approach in the cfg approach a control flow graph is built with program points as nodes and edges carrying elementary commands assignments tests the transfer function t for the analysis is defined for elementary commands the analyzer then sets up a system of ap t c ap where p c p is a cfg edge with ap the abstract states associated to every program point p this system is then solved by global fixpoint iteration over the whole cfg in contrast the structural approach applies to languages with structured control and compound statements such as if and loops there the transfer function t is defined over basic as well as compound statements given the abstract state a before the execution of statement s it returns t s a the abstract state after the execution of s for sequences we have t s s a t s t s a for loops t takes a local fixpoint of the transfer function for the loop body since cminor is a mostly structured language only goto statements are the abstract interpreter for cminor follows the structural approach this the need to define program points for cminor a nontrivial task moreover structural abstract interpreters use less memory than ones maintaining only a few different abstract states at any time instead of one per program point however the transfer function for our abstract interpreter is more involved than usual because control can enter and leave a cminor statement in several ways the statement s can be entered normally at the beginning or via a goto that branches to one of the labels defined in s likewise s can terminate either normally by running to the end or by executing a return exit or goto statement consequently the transfer function is of the form t s ai al ao ar ae ag where ai input is the abstract state at the beginning of s ao output is the abstract state after s terminates normally ar return is the state if it returns and ae exits maps exit numbers to the corresponding abstract states the goto statements are handled by two maps from labels to abstract states al labels and ag the first representing the states that can flow to a label defined in s the second representing the states at goto statements executed by s figure from the definition of t and shows all these components in action the loop case computes a with widening and narrowing starting at and at most times the iterator is defined as f a n narrow f a f a f a n if n if a f a otherwise a if n narrow f a n narrow f f a n if a f a a otherwise each iteration of uses the widening operator provided by the abstract domain to speed up convergence once a is found f is iterated up to times in the hope of finding a smaller in both widening and narrowing iterations we use n to coq that the above are terminating and to limit analysis time we did not attempt to prove termination of iteration with widening it would require difficult proofs over the widening operators of all our abstract domains for no gain in soundness alternatively we could the computation of a candidate a to an untrusted iterator written in caml then check a f a in a verified coq function this would cost one more invocation of the f function and it is how the caml implementation could be made more efficient than the function above written and verified in coq t x e ai al assign x e ai t s s ai al ao ar ar ae ae ag ag where ao ar ae ag t s ai al ao ar ae ag t s ao al t s else s ai al t s assume e true ai al t s assume e false ai al t loop s ai al ar ae ag where ao ar ae ag xo xr xe t s ai xo al t exit n ai al n if n n then ai else t block s ai al ao ae ar n ag where ao ar ae ag t s ai al t goto l ai al l if l l then ai else t l s ai al t s ai all al figure representative cases of the cminor abstract interpreter the abstract interpreter can loops on the the n first iterations of the loop are analyzed independently in sequence the remaining iterations are analyzed with a fixpoint this delays widening and precision the unrolling factor n is currently given by an annotation in the source code in addition to the analysis of loop statements a is computed for every cminor function to analyze goto statements this iteration ensures that the abstract states at goto statements are consistent with those assumed at the corresponding labeled statements in other words if s is the body of a function and t s ai al ao ar ae ag is its analysis the analysis iterates until all for every label l when this condition holds the abstraction of the function maps entry state ai to exit state ao ar corresponding to the two ways a cminor function can return explicitly or by reaching the end of the function body concerning functions the abstract interpreter the body of a function at every call site effectively unrolling the function definition on demand we use again to limit the depth of function unrolling moreover since the state abstract domain does not handle recursion it raises an if a recursive call can occur the abstract interpreter is written in monadic style so that alarms can be reported during analysis we use a monad when an is raised it is collected in the log but analysis continues this is better than at the first like an error monad would do often widening reaches a state that causes an but the subsequent narrowing steps cause this to go away the soundness proof for the abstract interpreter is to the complexity of the cminor language to keep the proof we break it in two parts the definition and soundness proof of a suitable hoare logic for cminor and a proof that the abstract interpreter infers hoare triples that are valid in this logic we first explain the approach in a simplified case that of the subset of cminor without goto exit and return in this subset statements can only be entered at the beginning and at the end and the transfer function is of the form t s a a intuitively we expect this transfer function to be sound if for any statement s and initial abstract state a such that the analysis t s a raises no the execution of s started in any concrete state a does not go wrong and if it terminates in state then t s a the way we prove this property is first to show that if the analysis t s a raises no alarms then the weak hoare triple a s t s a can be derived in an appropriate program logic then we show that this program logic is sound with respect to the operational semantics of the language if p s q can be derived in the logic then the execution of s started in a state satisfying p does not go wrong and if it terminates it does so on a state satisfying q the approach outlined above extends to the whole cminor language but not without cminor statements can terminate in multiple ways normally or on an exit return or goto statement they can also be entered in two ways at the beginning of the statement or via a goto to a label defined within consequently our program logic for cminor hoare of the form p pl s q qr qe where p is the precondition if s is entered normally the precondition if s is entered by a goto l q the postcondition if s terminates normally the postcondition if s terminates by a return of value v the postcondition if s terminates by and the postcondition if s terminates by goto l we omit the rules of this program logic from this paper as they are similar to those of the program logics for cminor and clight by appel and without the separation logic aspects theorem soundness of the abstract interpreter assume that the analysis t s ai al returns ao ar ae ag without raising an then the ai al s ao ar ae ag is derivable in the cminor program logic it remains to show the soundness of the program logic with respect to the smallstep semantics of cminor taking from the work of appel et al on stepindexed semantics we say that a configuration s k is safe for n steps if no sequence of at most n transitions starting from s k a runtime error it either performs n transitions or reaches a final configuration after n n transitions we say that a continuation k is safe for n steps with respect to the postconditions q qr qe if q skip k safe for n steps qr v k safe for n steps qe i k safe for n steps l goto l k safe for n steps we can then state and prove soundness of the cminor program logic as follows theorem soundness of the program logic assume that the p pl s q qr qe is derivable in the program logic further assume that k is safe for n steps with respect to q qr qe if satisfies p then s k is safe for n steps moreover if satisfies pl l and l is the label of s of s in continuation k extending k then s k is safe for n steps the state abstract domain the state abstraction in tracks values contained both in memory and in temporary variables each value is attached to an abstract memory cell or cell for short representing one unit of storage either a temporary variable or a scalar part of a local or global variable a scalar part is either the whole variable if it is of scalar type or an element of scalar type in this variable eg a field in a structure an element in an array therefore a cell is given by the kind and the name of the variable it belongs to the name of the function in which this variable is declared unless it is global and an offset and a value size unless it is a temporary variable cells c t the temporary t in function f x slice of size at offset in the local variable x of function f slice of size at offset in the global variable x the state abstract domain with three specific abstract domains an abstract value tp pt nm is a triple in types × pointsto × num first type information is tracked for every memory cell in order to when possible the behavior of cminor operators for example addition of integer or pointer values has various behaviors depending on the actual types of its arguments adding two integers yields an integer adding an integer to a pointer yields a pointer in the same block and adding two pointers is undefined therefore raises an in addition this type information is used to prove that values are not undefined for instance when loaded from the memory then a pointsto graph associates to each memory cell a set of memory blocks the cell may point to a cell whose content is not a pointer may be associated with any set finally we track properties of the numbers contained in cells the abstract state domain is parameterized by a relational numerical abstract domain following the interface from figure cells act as variables for this numerical domain which therefore abstracts environments mapping cells to numbers the number associated with a cell is its content if it is of numerical type or if it contains a pointer the byte offset part of this pointer a relational numerical abstract domain requires special care because we must it with rich numerical commands as we now illustrate consider the following cminor assignment occurring in a function f s s t here s and i are temporary variables ie the memory cell related to s is and t is a global variable of array type type analysis computes that t is a pointer whereas s and i are integers pointsto analysis infers that s and i do not point to any block but t definitely points to the block of t in order to the relational numerical domain with the assignment we must transform the t expression into its corresponding cells we query the pointsto domain to determine which memory blocks may be accessed during this load yielding the block of t we also query the numerical domain to obtain the possible values of that is the byte offsets that may be accessed during the load assume this query returns the set we then approximate the load expression by the two cells and send the numerical domain the two assignments and finally take the join of the two new numerical abstract states thus obtained for a memory store store el er we perform a similar technique and generate a set cl of p cells that may be modified during this store and a set er of numerical expressions that capture the concrete value computed by expression er when p we can perform a strong update that the previous value of the cell cl otherwise we must perform a weak conservative update and assume that any cell in cl clp may still hold its old value after the update concretization the types and pointsto domains to functions from cells to values whereas the numerical domain to purely numerical values to combine them into one concretization the last one is lifted using an agreement relation tp parameterized by the types information ensuring that types and numerical values agree and that values bound by match the numerical values bound by in particular if the value c is a pointer the number c is the byte offset part of this pointer more precisely a function from cells to values is in the concretization of an abstract value tp pt nm iff it is in the concretization tp of the types domain tp it is in the concretization pt of the pointsto domain which means that for every cell c that contains a pointer value with a block pointer b then b and in the concretization nm of the numerical domain there exists a concrete mapping from cells to numerical values that with tp pt nm nm tp finally a function from cells to values can be related to a cminor execution state call stack and memory state the call stack determines a mapping from temp cells to values and from local and global cells to memory locations and the memory state gives values to these locations interprocedural analysis to analyze a function call such as where f is an expression the function is first resolved then the abstract state at function entry is and finally the function body is recursively analyzed from this state there the analysis of return statements will compute the abstract state after the call and assignment to x function resolution uses pointsto information to compute a set of functions that expression f may point to the push frame operation of the state abstract domain performs the assignments corresponding to argument passing arguments are evaluated in the context of the caller and then assigned to local variables of the callee since local variables are identified by their names and the functions they belong to the call chain is as an abstract stack in addition to be able to distinguish local from global variables in expressions the set of variables local to each function is in this abstract stack the pop frame operation is used when analyzing return e statements the expression e is analyzed in the callee context and assigned to a temporary in the caller context then pop frame simulates the of local variables on function exit this consists in the information associated to them as well as pointers that may point to them as an illustration consider the following program int p return p int int x int t fx return t when analyzing the call to the function f the argument expression is processed and the local variable p of f is assigned in the three abstract domains in particular p is assigned to the constant zero the value of its offset in the numerical domain and to the block in the pointsto domain therefore the return expression of f is known to access exactly one cell about which information can be in the various domains this information is then assigned back to the temporary t of main progress verification at the same time we transform abstract states we perform to prove that every cminor expression evaluates safely without blocking in its evaluation context in particular we check that every load and store is performed within bounds and with the correct alignment we also check that every deallocation of local variables at function returns is performed on valid pointers as well as various other side conditions eg function pointers must have a null offset the numerical abstract domains intervals and the first numerical domains verified in are domains of intervals x a b and x mod n p they abstract numbers consisting of the union of mathematical integers type z and floatingpoint fp numbers binary format treating both kinds of numbers at once the analysis of conversions between integers and fp numbers analyzing mathematical exact integers instead of machine integers greatly simplifies the implementation and proof of abstract integer operations in contrast there is no benefit in analyzing fp numbers using a more mathematical type such as fp operations with behave well with respect to fp ordering and abstract operations that use are costly integer intervals integer intervals are either a b with a b z or for we do not represent the intervals a nor b the implementation of arithmetic and comparison operators over integer intervals is standard with comparisons returning of we go to great lengths however to derive tight intervals for logical operations and or not the widening operator does not jump immediately to but first tries to replace the upper bound by the next higher number in a list of zero and some of and likewise replacing the lower bound by the next lower threshold the implementation and soundness proof build on library which defines z from first principles essentially as lists of bits no untrusted big integer library is involved floatingpoint intervals likewise fp intervals are either a b where a and b are but possibly infinite fp numbers or belongs in but not in a b interval analysis for fp arithmetic is complicated by the various special fp numbers signed but remains surprisingly close to reasoning over real numbers ieee specifies fp arithmetic operations as compute the exact result as a real then round it to a representable fp number for example addition of two finite fp numbers x y is defined as x y x y where is one of the modes defined in ieee all these modes are monotonic functions therefore if x a b and y c d x y x y a c b d a c b d this property provides tight bounds for and other fp operations provided the mode is known statically this is the case for cminor which specifies round to to even and gives no way for the program to dynamically change the mode likewise and unlike c cminor specifies exactly the precision used by fp operations and the places where conversions between occur therefore the fp interval domain does not need to account for precision and possible double the implementation and proof of the fp interval domain build on the library which provides specifications and implementations of fp arithmetic in terms of mathematical integers and reals integer the congruence domain abstracts integers as pairs n m of a m and a constant n representing all integers equal to n modulo m n m x z k x n km the case m corresponds to the case m is meaningful and corresponds to constant propagation n n tracking constants this way enables more precise analysis of and this domain of is crucial to analyze the safety of memory accesses that they are properly aligned from to relational domains the domains of intervals and share a common interface specifying a type t of abstract values a concretization to the union of z integers and functions to abstract constants and functions to perform forward and backward analysis of cminor operators the following from the interface gives the of the forward and backward functions t t t t t op x x op x op op x x res res op x res x op the forward functions compute an abstraction of the result given abstractions for the arguments of the operator the backward functions take abstractions for the result and the arguments and produce possibly better approximations for the arguments for example the backward analysis of with result produces for the first argument and for the second one a generic domain transformer turns any domain satisfying this interface into a relational domain abstract environments are implemented as sparse finite maps from variables to non abstract values mappings from a variable to are left implicit to make abstract environments smaller the assign x e a operation of the relational domain first computes an abstract value a for expression e looking up abstract values ay for variables y occurring in e and using the forward operators provided by the domain the result is the updated abstract environment ax a the assume e b a operation of the relational domain abstractly evaluates e in reverse starting with an expected abstract result that is the constant if b is true and the constant otherwise the expected abstract result is propagated to the leaves of e using the backward operators of the domain when a variable y in e the abstract value of y is refined giving a ay ay this simple construction makes it easy to add other domains and combine them with relational domains convex polyhedra to exercise the interface for relational numerical domains includes a relational domain of convex polyhedra it builds on the library of et al which implements all required operations over convex polyhedra represented as conjunctions of linear inequalities with rational coefficients is implemented in caml using rational arithmetic and therefore cannot be trusted however every operation produces a certificate that can easily be checked by a validator written and proved sound in coq for example the join operation applied to p p returns not only a polyhedron p but also certificates proving that the system of p p ¬p is unsatisfiable therefore any concrete state p p is also in p establishing the soundness of join this is currently the only instance of verified validation a in while simpler abstract domains can be verified directly with reasonable proof effort verified validation is a perfect match for this domain avoiding proofs of difficult algorithms and enabling efficient implementations of costly polyhedral computations symbolic equalities the relational domain of symbolic equalities records equalities x ec between a variable x and a conditional expression ec as well as facts ec true or ec false about the boolean value of an expression conditional expressions ec extend numerical expressions e with zero one or several ifthenelse selectors in position ec e ec ec ec on its own this domain provides no numerical information that can be used to prove absence of runtime errors combined with other numerical domains via the communication mechanism of section symbolic equalities enable these other domains to analyze assume operations more precisely a typical example comes from the way compcert cs boolean operators and the pass that side effects outside of expressions transforms these operators into assignments to temporary boolean variables for example if fx y z s becomes in cminor t fx if t t y z else t if t s the symbolic equality domain infers t t y z at the second if assuming t true in s adds no information in the interval and polyhedra domains this fact these domains can query the domain of equalities obtain the symbolic equality over t above and learn that y z and t a set of equalities x ec and facts ec b to all concrete environments that validate these equations facts x ec x eval ec ec b facts b eval ec a new equation is added by assign and a new fact is added by assume all equations and facts involving variable x are removed when doing assign or over x we do not track previous values of assigned variables the way value numbering analyses do likewise we do not treat equalities between variables x y the operation in this domain is the join between two abstract states this is where conditional expressions are inferred computing optimal least upper bounds between sets of symbolic equalities is known to be difficult so we for an overapproximation equations and facts that occur in both abstract states using syntactic equality for comparison are kept if one state contains an equality x ec and a fact ec true and the other state contains x ec and ec false the equality x ec ec ec is added to the state all other equalities and facts are discarded widening is similar to join except that new conditional expressions are not inferred handling machine integers numerical domains such as intervals and polyhedra are well understood as abstractions of unbounded mathematical integers however most integer types in programming languages are bounded with arithmetic treated either as runtime errors or by around and taking the result modulo the range of the type in cminor integer arithmetic is defined modulo n with n or n depending on the operation moreover cminor does not distinguish between signed and unsigned integer types both are just n bit vectors some integer operations such as division or comparisons come in two one that its arguments as unsigned integers and the other as signed integers but other integer operations such as addition and multiplication are presented as a single operator that handles signed and unsigned arguments all these of integer arithmetic static analysis for specific abstract domains such as intervals and ad hoc approaches are known such as intervals wrapped intervals or reduced product of two intervals of z tracking signed and unsigned interpretations respectively these approaches are difficult to extend to other domains especially relational domains in we use a more generic construction that transforms any relational domain over mathematical integers z into a relational domain over n bits machine integers with arithmetic we first outline the construction on a simple example consider the familiar domain of intervals over z with concretization l h x z l x h to adapt this domain to the analysis of bit machine integers type int we keep the same abstract values l h with l h z but them to machine integers as follows ml h b int n z n l h b n mod in other words the mathematical integers in l h that is l l h h are modulo into bit vectors all arithmetic operations that are compatible with equality modulo can be analyzed using the standard abstract operations over for example bit addition add is such that add b b b b mod if it is know that x we analyze add x like we would analyze x addition in z obtaining this interval to three bit vectors with unsigned interpretation and with signed interpretation an overflow occurred in the unsigned view but the arithmetic tracks it correctly the same technique of analyzing machine operations as if they were exact works for addition and operations and or not without loss of precision and also for multiplication and left shift possibly with loss of precision other arithmetic operations such as division right shifts and comparisons are not compatible with equality modulo these are exactly the operations that must come in two unsigned and signed at the machine level for example but even though mod to analyze these operations we first try to reduce the intervals for their arguments to the interval l h expected by the operation for an unsigned operation and for a signed operation to this end we just add an appropriate multiple of to the original interval this operation does not change its m concretization the example above add x viewed as a signed integer can be reduced to the interval add x by therefore the signed comparison le s add x can be analyzed as le s add x true if we need to view add x as an unsigned bit integer the best interval we can give is therefore the unsigned comparison le u add x is analyzed as le u add x in the signed comparison case the unsigned overflow during the computation of add x is and does not the precision of the analysis in the unsigned comparison case the overflow is serious and makes the result of the comparison on the example of intervals above our construction is very close to wrapped intervals however our construction generalizes to any relational domain that satisfies the interface for ideal numerical domains such domains abstract ideal environments var z float where variables range over mathematical integers not machine integers consider such a domain with abstract states a and concretization function we now build a domain that abstracts machine environments m var where variables are or bit machine integers with arithmetic we keep the same type a of abstract states but interpret them as sets of machine environments via ma m a v mv v the agreement relation between a machine number and an ideal number is defined as b int n z iff b n mod b int n z iff b n mod f float f float iff f f the abstract operations and over the machine domain are defined in terms of those of the under ideal domain after translation of the numerical expressions involved x e a assign x ea a e b a assume ea b a x a x a the translation of expressions inserts just enough so that the ideal transformed expression ea evaluates to an ideal number that matches up to the relation the value of e as a machine number variables and constants translate to themselves arithmetic operators that are compatible with the relation such as integer addition and and all fp operations translate other arithmetic operators have their arguments reduced in range as explained below xa x add e ea ea ea le u e ea ea le s e ea ea ea the purpose of e l h where l h is an interval of width n is to reduce the values of e modulo n so that they fit the interval l h to this end it uses a get e a operation of the ideal numerical domain that returns a variation interval of e from this interval it determines the number q of of n that must be from e to bring it back to the interval l h this is not always possible in which cases l h is returned as the reduced expression remember that numerical expressions in are nondeterministic and use intervals as constants e l h let l h get e a in if h l n then l h else let q l ln in if h qn h then e qn else l h the translation of expressions is sound in the following sense lemma assume m ma a and mx x for all variables x then for all machine expressions e vm m e v v eval ea vm v it follows that the and operations of the transformed domain are sound communication between domains several abstract domains are used in order to keep track of different kinds of properties for example we need interval information to check that array accesses are within bounds we use a congruence domain to check alignment of memory accesses a domain of symbolic equalities helps us dealing with boolean expressions all those domains need to communicate for example only the interval domain is able to infer numerical information for all operators including operators division and fp operations however all other domains may need to use this information another example is the symbolic equalities domain if the condition of a test is just a variable another domain can substitute the variable with a boolean expression provided by this symbolic domain in order to refine their abstract states the classic approach to combining two abstract domains and make them exchange information is the reduced product implementations of reduced products tend to be specific to the two domains being combined and are difficult to scale to the combination of n domains reduced products are therefore not a good match for the modular architecture of instead we use a system of communications based on channels inspired by that of e we define an input channel as follows record type var var option var an input channel is a record of functions each function corresponds to a specific kind of query returns an interval of variation for an expression while returns an expression that evaluates to the same value as the variable it is called on this type of channels is meant to be extended when needed for example one could add a query for a linear approximation of an expression which could be by a domain and used by linear relational domains like abstract states channels have a concretization function intuitively an environment var z float is in the concretization of a channel if all answers to queries are valid in record chan prop e e e x e x some e e x channels are used by domains when they need information from another domain when an operation of a domain receives as argument an abstract value it also receives a channel corresponding to ain ain × × figure communication channels between abstract operators left single operator right composition of two operators from different domains the same concrete environments channel in figure each transfer function that returns a new abstract value also returns a channel that other domains can query to obtain information on the state after the execution of the transfer function finally yet another channel is provided as extra argument to each transfer function this channel will provide information on the state after the execution of transfer functions from other domains only abstract domains having already computed these function can answer these queries in other words the domain operation produces by information already present in with information of its own for example the assign transfer function which corresponds in the concrete to an assignment of an expression to a variable has the following type assign var var t t the first and second arguments are the assigned variable and expression the third argument is a pair representing the initial states an abstract value and the channel the fourth argument is the channel representing the current information about the final state after the assignment if no contradiction is found assign returns the final abstract state and the channel the specification of assign is as follows x e ab chan n n e ab upd x n chan upd x n assign x e ab chan here we extend to pairs of abstract values and channels taking x y x y and using coq type classes this specification of assign is analogous to the one in figure the difference is that we add an hypothesis stating that the two channels given as parameters are correct with respect to initial and final states respectively moreover we demand that the returned channel be correct with respect to the final state an implementation of such a specification has to create a channel for each query the implementation can choose to forward it to the channel received as its fourth parameter effectively forwarding it to another domain or to answer it using its own information or to do both and combine the information for example an interval domain will answer queries but not queries forwarding the latter to other domains this interface for transfer functions such as assign makes it easy to combine two domains and have them communicate provides a generic combinator as in figure that takes two abstract domains over ideal numerical environments and returns a product domain where information coming from both domains is stored and where the two domains can communicate via channels the definition of assign for the product is the following assign v e chan let a b ab in computation on the first component assign v e a chan let chan in computation on the second component using the new input channel assign v e b chan let chan in chan the implemented here is depicted in figure right part as shown there the channel passed to the second abstract domain is the channel generated by the first abstract domain this enables the second abstract domain to query the first one using this product construction we can build trees nested products of domains as depicted in figure the input to the z int domain transformer described in section is such a combination of numerical domains abstract states of this combination are pairs of on the one hand nested pairs of abstract states from the individual numerical domains and on the other hand a channel the channel is not only used when calling abstract transfer functions but also directly in order to get numerical information such as variation intervals when the z int domain transformer calls a transfer function it simply passes as initial channel a top channel whose concretization contains all concrete environments assign x e v in chan top one final technical difficulty is comparison between abstract states such as the subsumption test used during computation in the upper layers abstract states nested pairs of abstract values plus a channel therefore it seems necessary to compare two channels or at least one channel and one abstract state however channels being records of functions comparison is not decidable our solution is to maintain the invariant that channels never contain more information than what is contained in the abstract values they are with that is at the top of the combination of domains when we manipulate a pair ab chan of an abstract value and a channel we will make sure that ab chan holds in order to check whether one such pair ab chan is smaller than another ab chan we only need to check that ab chan ab which is easily decidable thus the type of the comparison function for abstract values is t t bool note that it is useful to provide with a channel for its first argument an abstract domain can then query other domains in order to compare abstract values however the constraint ab chan is too strong for real abstract domains it makes it impossible for a domain to forward a query to another domain instead we use a weaker constraint for every transfer function in the case of assign we prove x e in chan ab chan assign x e in chan ab chan chan ab chan that is the returned channel contains no more information than what is contained in the returned abstract value and the given channel when chan is it follows that ab chan ensuring the soundness of the comparison function the property that limits the amount of information contained in channels is useful beyond the proof of soundness for comparisons it is also a check ensuring that the returned channel only depends on the abstract value and on the channel given as the last argument but not for instance on channels or abstract values interfaces abstract interpreter state abstraction numerical domains domain combinators intervals polyhedra validator symbolic equalities libraries total proofs overall from lines table size of the coq development previously computed this is important for efficiency because if the closures contained in the channel made references to previous channels or abstract values this would make the analyzer keep old abstract values in memory leading to bad memory behavior implementation and the coq development for is about lines and comments an additional lines of caml implement the operations over that are validated a the coq sources split equally between proof scripts on the one hand and algorithms specifications and statements of theorems on the other table shows the relative sizes of the various components of the parts reused from compcert eg syntax and semantics of cminor are not counted the interfaces that provide the of are the of the development is the abstract domains for states and especially for numbers which involve large case analyses and difficult proofs over integer and fp arithmetic the coq proofs are essentially constructive the axiom of middle and the axiom of functional are used in a few places for convenience rather than by however floatingpoint arithmetic is specified using theory of real numbers which relies on classical logic axioms except for the operations over polyhedra the algorithms used by are implemented directly in specification language as function definitions in purely functional style an executable analyzer is obtained by automatic extraction of caml code from these function definitions and those of compcert experimental results we preliminary experiments with the executable cminor static analyzer obtained as described in section we ran the analyzer on a number of small test c programs up to a few lines the purpose was to verify the absence of runtime errors in these programs to exercise further the analyzer we added support for a builtin function to explicitly ask the analyzer to prove invariants that are expressible as c expressions e to model inputs we added support for two other builtin functions any int and any double which nondeterministically return a value of the type they are often coupled to the builtin function to further constrain their results these functions are also used to model library functions whose code is not available or trusted we only consider program executions where the boolean expression b is true when is reached the following describes representative programs that we analyzed the other examples have similar characteristics and lead to comparable observations function integration the example is a small program adapted from a compcert benchmark most of its code is given below double fun id square double f double low double high int n double h x s int i h high low n s for i n x low i i x h s fx return s h int for int i i i double m m int n n n m n return this program repeatedly computes an approximation of the integral of a function between zero and some number greater than one the function in question is from a constant array it various aspects of the analyzer such as function pointers arrays floating point and machine arithmetic numerical simulations two programs of a few lines taken from the compcert benchmark and feature heavy numerical floating point computations and array manipulation cryptographic routines the example performs scalar multiplication it is taken from the cryptography library scalars and group elements are stored in arrays of bytes or unsigned integers many of these arrays are initialized within a loop understanding that such an array is indeed properly initialized at the end of the loop would require a analysis beyond the scope of this paper instead we annotated the program to request full unrolling of these loops during analysis thus preventing fixpoint computations preliminary results on the examples described above was able to prove the absence of runtime errors this is since these examples exercise many aspects of the c language arrays pointer arithmetic function pointers and floatingpoint arithmetic as summarized in the table below analysis times are high section discusses possible directions to speed up the analyzer program size lines lines lines lines time s s s s e processor mo cache go ram related work early work on the mechanized verification of static analyses was in the framework of dataflow analyses this includes and verified java bytecode verifier et als coq formalization of dataflow analysis and the verified dataflow analyses that support optimizations in compcert only abstract domains are considered and there is no widening to the convergence of fixpoint iterations hofmann et al verify a generic fixpoint solver usable in this context the first attempt to abstract interpretation in its full generality is thesis using the coq proof assistant and following the approach based on galois connections he runs into difficulties with abstraction functions being and with the calculation of abstract operators being supported by coq later phd thesis the only presentation of abstract interpretation that we use in widening in fixpoint iterations as well as relational domains are supported but the applications to java static analysis presented in use only domains et al use approach to verify an interval analysis for the rtl intermediate language of compcert and give alternate of this approach respectively in coq and in resulting in abstract interpreters for the imp many of the mentioned above run into serious complications to prove the termination of fixpoint iteration using either integer measures or wellfounded orderings the proof obligations related to termination account for much of the difficulty of constructing modular hierarchies of abstract domains in we termination proofs and to verify partial correctness only the project to in terms of is by et al rather than proving the soundness of a static analyzer they follow a proofcarrying code approach the existing untrusted c static analyzer is instrumented to produce analysis certificates which are checked for correctness by a validator proved correct in coq validation a reduces the overall proof effort to some extent indeed we use it locally in to implement the polyhedral domain however we were to validate the analysis of a whole program by that the resulting certificates would be very large and take too long to check one of the reasons why is that it keeps few abstract states in memory at any given time this may be in light of the very good checking times reported for we note however that implements only one domain integer intervals and that it does not handle a number of c features that handles floatingpoint arithmetic unions in unsigned integer arithmetic pointer comparisons and function pointers conclusions and here is the final theorem in the coq verification theorem forall prog res tr prog res nil semantics prog tr false if the analyzer returns an empty list of alarms as its second result the execution of the program cannot get stuck on a runtime error regardless of the trace of inputs tr given to the program is an experiment but at this stage of the project it already demonstrates the feasibility of formally verifying a realistic static analyzer based on abstract interpretation having to write coq specifications and proofs did not from handling a large source language the subset of c typically used in critical embedded systems nor from supporting multiple nontrivial numerical abstract domains rather this requirement that everything is specified and proved sound us towards a highly modular architecture with interfaces and generic combinators to mix and adapt abstract domains most of these domains and domain combinators can be reused in other tool verification projects some of them also act as reference implementations for advanced techniques for which no implementation was available before such as the combination of abstractions the current analyzer can be extended in many directions first the algorithmic efficiency of the analyzer needs improvement currently can take several to analyze a few lines of c there are numerous sources of which we are currently analyzing one is integer and fp arithmetic built from first principles lists of bits it should be possible to over arithmetic libraries such that more efficient big integer libraries and fp numbers can be used as an alternative another potential source of is the purely functional data structures trees trees used for maps and sets e well despite using similar purely functional data structures but only because their implementations take advantage from physical sharing within and between tree data structures in we already obtained good by preserving sharing between the arguments of join operations going further we could a using general extending on the source language side dynamic memory allocation could probably be handled by extending the memory abstraction so that one abstract memory cell can stand for several concrete memory locations such as all the blocks created by a malloc inside a loop recursion raises challenges both the memory abstraction and the abstract interpreter would require heavy modifications so that they can merge the abstract states from multiple invocations of a recursive function perhaps using call strings in the style of concerning the cminor abstract interpreter precision of the analysis would be improved by unverified heuristics for loop unrolling not relying on annotations the more elegant and powerful method would certainly be provided by a general trace partitioning mechanism also the nested fixpoint iterations arising out of the analysis of nested loops can be costly it should be possible to convergence by starting the inner iterations not at but at the found at the previous outer iteration the starting points could be provided by an external untrusted oracle written in imperative caml the hierarchy of numerical abstractions is set up to accommodate new abstract domains easily high on our wish list is a domain of linear inequalities of the form ± x ± y c are more efficient than convex polyhedra moreover using floatingpoint numbers for the coefficients of their difference bound matrices can infer inequalities involving floatingpoint program variables and not just integer variables such a use of fp arithmetic in a static analyzer is with of numerical and a formal proof of soundness just like convex polyhedra also need expression linearization heuristics to extract more information out of nonlinear expressions acknowledgments this work is supported by de la grant a s d and m developed the library and the verified validator mentioned in section j and a provided advice based on their experience with references a ahmed a w appel c d k n g and d c wang semantic foundations for typed assembly languages acm trans program lang syst a w appel program logics for certified compilers cambridge university press a w appel and s separation logic for smallstep cminor in volume of lncs pages ­ springer a w appel and d a an indexed model of recursive types for foundational proofcarrying code acm trans program lang syst ­ y structural abstract interpretation a formal study using coq in language engineering and rigorous software development school pages ­ springer b p cousot r cousot j l a d and x a static analyzer for large software in pldi pages ­ acm s z and x leroy formal verification of a c compiler frontend in formal methods volume of lncs pages ­ springer s v a and d formal verification of a c value analysis based on abstract interpretation in sas volume of lncs pages ­ springer s and g a unified library for proving floatingpoint algorithms in coq in pages ­ ieee t and d implementing and reasoning about data structures in coq j reasoning ­ d t p d and v extracting a data flow in constructive logic theor comput sci ­ a modular development of certified program with a proof assistant j program ­ s j j ck and k yi a verified validator for an static analyzer p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in popl pages ­ acm p cousot and r cousot systematic design of program analysis frameworks in popl page ­ acm p cousot r cousot j l a and x why does scale up formal methods in system design ­ p cousot r cousot j l a d and x combination of abstractions in the static analyzer in volume of lncs pages ­ springer a d and m efficient generation of correctness certificates for the abstract domain of polyhedra in sas volume of lncs pages ­ springer a and s a frontend for abstract domains in volume of lncs pages ­ springer d j and g the gap automatic verified abstraction of c in volume of lncs pages ­ springer s gulwani a and g c necula join algorithms for the theory of uninterpreted functions in volume of lncs pages ­ springer n and m discovering properties about arrays in simple programs in pldi pages ­ acm p c and b a certified verification condition generator in volume of lncs pages ­ springer m hofmann a and h verifying a local generic solver in coq in sas volume of lncs pages ­ g and t a model for a language virtual machine and compiler acm trans program lang syst ­ x leroy formal verification of a realistic compiler comm acm ­ x leroy a formally verified compiler j automated reasoning ­ a the abstract domain higherorder and symbolic computation ­ a symbolic methods to the precision of numerical abstract domains in volume of lncs pages ­ springer d thesis u paris j a p h and p j program analysis precise integer bounds for lowlevel code in volume of lncs pages ­ springer f nielson h nielson and c principles of program analysis springer t abstract interpretation of annotated commands in volume of lncs pages ­ springer d en extraction java phd thesis u d building certified static by modular construction of wellfounded lattices notes theor comput sci ­ t w reps g and j recovery from lowlevel code in pages ­ acm x and l the trace partitioning abstract domain acm trans program lang syst 