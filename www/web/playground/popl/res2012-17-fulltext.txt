analysis of recursively parallel programs ahmed paris france michael paris france abstract we propose a general formal model of isolated hierarchical parallel computations and identify several fragments to match the concurrency constructs present in realworld programming languages such as and x by associating fundamental formal models vector addition systems with recursive transitions to each fragment we provide a common platform for the relative difficulties of algorithmic reasoning for each case we measure the complexity of deciding for recursive programs and propose algorithms for the decidable cases the which include np and contrast with undecidable for recursive multithreaded programs categories and subject descriptors d verification formal methods f specifying and verifying and reasoning about programs mechanical verification d language concurrent distributed and parallel languages f models of computation parallelism and concurrency general terms algorithms reliability verification keywords concurrency parallelism verification introduction despite the importance of concurrent software eg for designing reactive applications or computation across multiple processor concurrent programming and concurrent program analysis remain challenging the most widely available facility for designing concurrent applications is where concurrently executing sequential threads nondeterministically their accesses to shared memory such nondeterminism leads to which are difficult to and repair to prevent such bugs programmers are with the difficult task of preventing interleavings eg by synchronization without preventing the desired or parallelism is partially supported by the project supported by a from the sciences de paris proofs to technical results are contained in an extended online report permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm the complexity of multithreaded program analysis seems to with the difficulty of multithreaded programming the problem for multithreaded programs is with a finite number of finitestate threads and undecidable with recursive threads current analysis approaches either explore an concurrent semantics by considering relatively few interleavings or explore a semantics via abstraction programming languages have been to avoid the interleavings implicit in program syntax and several such languages have been developed such systems introduce various mechanisms for creating eg fork spawn post and eg join sync concurrent computations and either through programming or ensure through static analyses or runtime systems that parallel computations execute in isolation without interference from others through functional programming message passing or memory access models perhaps back on transactional mechanisms when complete isolation is although few of these systems behave one concurrent computation at a time many are sensitive to the order in which multiple isolated computations are consumed furthermore some allow computations creating an unbounded number of returning to their an unbounded number of handles to computations even without multithreaded interleaving nondeterminism in the order in which an unbounded number of computations are consumed has the potential to make program reasoning complex in this work we investigate key questions on the analysis of programming models specifically we ask to what extent such models simplify program reasoning how those models compare with each other and how to design appropriate analysis algorithms we attempt to answer these questions as follows · we introduce a general parallel programming model on which to express the features found in popular parallel programming languages section · we discover a feature of some existing languages even simple classes of programs with the ability to pass computations both to and from computations have undecidable problems section · we show that the concurrency features present in many realworld programming languages such as x and are captured precisely modulo the possibility of interleaving by various fragments of our model sections and · for fragments corresponding to realworld language features we measure the complexity of computing for programs and provide in most cases asymptotically optimal algorithms sections and our focus on programs without interleaving is a means to complexity for the sake of comparison required since for or multithreaded programs is generally undecidable applying our algorithms in practice may rely on data abstraction and separately ensuring isolation or possible interleavings still our handling of nondeterminism is precise the major distinguishing language features are whether a single or an arbitrary number of computations are for at once and whether the scope of computations is confined generally speaking reasoning for the case of section is less difficult than for the case of section and we demonstrate a range of from np and for various scoping restrictions in sections and despite these worstcase a promising line of work has already demonstrated effective algorithms for problem instances based on simultaneously computing iterative under and and to a fixed point we thus present a classification of concurrency constructs connecting programming language features to fundamental formal models which the sources of concurrent complexity resulting from each feature and provide a platform for comparing the difficulty of formal reasoning in each we hope that these results may be used both to guide the design of program analyses as well as to guide the design and choice of languages appropriate for various programming problems recursively parallel programs we consider a simple concurrent programming model where computations are divided into isolated executing tasks each task executes sequentially while maintaining regions ie containers of handles to other tasks the initial task begins without task handles when a task t creates a child task u t stores the handle to u in one of its regions at which point t and u begin to execute in parallel the task u may then recursively create additional parallel tasks storing their handles in its own regions at some later point when t requires the result computed by u t must await the completion of blocking until u has which point t its handle to u when u does complete the value it returns is combined with the current state of t via a handler in addition to creating and tasks tasks can transfer ownership of their tasks to initially passing to the child a subset of task to their upon finally passing to the parent tasks this model permits concurrent executions each task along with all the tasks it has created execute completely in parallel as tasks can create tasks recursively the total number of concurrently executing tasks has no bound even when the number of handles stored by each task is bounded program syntax let be a set of procedure names a set of values a set of expressions a finite set of region identifiers and a set of handlers the grammar of figure describes our language of recursively parallel programs we leave the syntax of expressions e unspecified though we do contains true and false and contains and the choice operator we in order to concurrent complexity from the exponential factor in the number of program variables we consider a fixed number of variables in each procedure frame this allows us a for in recursive sequential programs p s proc p var l t s s s l e skip assume e if e then s else s while e do s call l p e return e post r p e r d r await r figure the grammar of recursively parallel programs here t is an unspecified type p ranges over procedure names e over expressions r over regions and d over handlers refer to the class of programs restricted to a finite set of values as programs and to the class of programs restricted to at most n n resp region identifiers as resp programs a sequential program is a program without post and await statements each program p declares a sequence of procedures named p pi each p having single parameter l and a toplevel statement denoted sp as statements are built inductively by composition with controlflow statements sp describes the entire body of p the set of program statements s is denoted intuitively a post r p e r d statement stores the handle to a task executing procedure p in the region r besides the procedure argument e the task is passed a subset of the parents task handles in regions r and a handler d the r statement blocks execution until some task whose handle is stored in region r completes at which point its handler is executed similarly the await r statement blocks execution until all tasks whose handles are stored in region r complete at which point all of their handlers are executed in some order we refer to the call return post and await as interprocedural statements and the others as intraprocedural statements and that handlers are only of intraprocedural statements the assume e statement proceeds only when e evaluates to use this statement in subsequent sections to block executions in our encodings of other parallel programming models example the function can be implemented as a recursively parallel program as follows proc fib var n n var sum n if n then return else post r fib n v sum sum v post r fib n v sum sum v await r return sum alternate implementations are possible eg by replacing the await statement by two statements or storing the handles to the recursive calls in separate regions note that in this implementation are not passed to child tasks specifies the empty region sequence nor to parent tasks all handles are consumed by the await statement before returning the programming language we consider is simple yet expressive since the syntax of types and expressions is left free and we lose no generality by considering only a single variable per procedure parallel semantics with unlike recursive sequential programs whose semantics is defined over stacks of procedure frames the semantics of recursively parallel programs is defined over trees of procedure frames intuitively the frame of each task becomes a child of the tasks frame each step of execution proceeds either by making a single intraprocedural step of some frame in the tree creating a new frame by a task or removing a frame by a completed task frames of a completed task are added as children to the completed tasks parent a task s d is a valuation to the variable l along with a statement s to be executed and a handler d here s describes the entire body of a procedure p that remains to be executed and is initially set to ps toplevel statement sp a tree configuration c is a finite unordered tree of vertices and edges and the set of configurations is denoted let denote the set of configuration multisets we represent configurations inductively writing t m for the tree with root whose child subtrees are given by a region valuation m for r the multiset mr specifies the collection of subtrees connected to the root of t m by an the initial region valuation m is defined by mr def for all r the singleton region valuation r c maps r to c and r r to and the union m m of region valuations is defined by the multiset union of each valuation m mr def mr mr for all r the projection m r of a region valuation m to a region sequence r is defined by m rr mr when r occurs in r and m rr otherwise for expressions without program variables we assume the existence of an evaluation function · e such that e for convenience we define e s d def e def e l e as l is the only variable the expression e l has no free variables to reduce and focus on the relevant parts of transition rules in the program semantics we introduce a notion of contexts a configuration context c is a tree with a single labeled leaf vertices and leaves otherwise and edges we write cc for the configuration obtained by substituting a configuration c for the unique labeled leaf of c we use configuration contexts to individual task transitions writing for instance c t m c t m to indicate an intraprocedural transition of the task t similarly a statement context s s si is a led sequence of statements and we write ss for the statement obtained by substituting a statement s for the unique occurrence of as the first symbol of s indicating that s is the statement a context t s d is a task with a statement context s in place of a statement and we write t s to indicate that s is the next statement to be executed in the task ss d finally we write c t s m c t s m to denote a transition of a task executing a statement s and replacing s by s is the skip statement since the current statement s of a task t s does not effect expression evaluation we write et to denote the evaluation et s we say a task t ss d is completed when its statement s is return e in which case we define def dv v e as the set of possible handler statements for t is undefined when t is not completed figure and figure define the transition relation of recursively parallel programs as a set of operational steps on configurations the intraprocedural transitions seq of individual tasks in figure are standard more interesting are the interprocedural transitions of figure which implicitly include a transition c t m c t m whenever t t the rule creates a procedure frame to execute in parallel and links it to the current frame by the given region passing ownership of tasks in the specified region sequence to the frame the rule the result of a single child frame in the given region and applies the handler to update the parent frames local valuation similarly the wait v et m m m r r v sp d m r c t post r p e r d m c t skip m p m r t m m c r m c p s ts m m m r t m m s c r m c p ts await r m m mr c t await r m c t skip m p figure the transition relation for recursively parallel programs with and rules consume the results of every child frame in the given region applying their return handlers in the order they are consumed the semantics of call statements reduces to that of post and an unused region identifier we translate each statement call l p e into the sequence post p e where def l v is the handler which simply writes the entire return value v into the local variable l and denotes an empty sequence of region identifiers a parallel execution of a program p from c to cj is a configuration sequence cc cj where ci ci for i j an initial condition p is a procedure p along with a value a configuration s d m is called p initial when s is the toplevel statement of p a configuration cf is called f final when there exists a context c such that cf c t m and lt f we say a valuation is reachable in p from when there exists an execution of p from some c to cf where c is initial and cf is final problem the problem is to determine given an initial condition of a program p and a valuation whether is reachable in p from sequential semantics with since tasks only exchange values at creation and the order in which tasks make execution steps does not affect computed program values in this section we this fact and focus on a particular execution order in which at any moment only a single task is enabled when the currently enabled task and statement execution to wait for a task t t becomes the task when t completes control returns to its waiting parent at any moment only the tasks along one path in the configuration tree have ever been enabled and all but the last task in are waiting for their child in to complete we encode this execution order into an equivalent operational semantics which essentially transforms recursively parallel programs into sequential programs with an unbounded auxiliary storage device used to store tasks we interpret the and await statements as procedure calls which compute the values returned by tasks skip t skip s seq t s p assume true et t assume e seq t skip p true et t if e then s else s seq t s p false et t if e then s else s seq t s p assign e sl e d seq p d true et t while e do s seq t s while e do s p false et t while e do s seq t skip p figure the intraprocedural transition relation for recursively parallel programs v et m m m r r v sp d m r t post r p e r d m c t skip m c p m r c m t r m c c t skip m p c m r c m t await r m c c t skip await r m p c mr t await r m c t skip m c p returns s t m m c ts m m c p figure the transition relation for recursively parallel programs with we define a frame to be a configuration in the sense of the semantics of section ie a finite unordered tree of vertices and edges here all nodes in the tree are tasks that have yet to take a single step of execution in our semantics a stack configuration c is a sequence of frames representing a procedure activation stack figures and define the sequential transition relation of recursively parallel programs as a set of operational steps on configurations the interprocedural transitions of figure implicitly include a transition t m c t m c whenever t t interesting here are the rules for and await the rule blocks the currently executing frame to obtain the result for a single nondeterministically chosen frame c in the given region by c onto the activation stack similarly the and rules block the currently executing frame to obtain the results for every task in the given region in a order finally the returns applies a completed tasks handler to update the parent frames local valuation the definitions of sequential execution initial and reachable are nearly identical to their parallel counterparts lemma the parallel semantics and the sequential semantics are wrt state reachability ie for all initial conditions of a program p the valuation is reachable in p from by a parallel execution if and only if is reachable in p from by a sequential execution undecidability of with recursively parallel programs allow pending tasks to be passed both from completed tasks and to tasks this capability makes the problem undecidable even for the very simple cases recursive programs with at least one region and for nonrecursive programs with at least two regions essentially when pending tasks can be passed to tasks it becomes possible to construct and manipulate unbounded by keeping a handle to created task after having passed the handle of the created task to the created task we can then show that such unbounded chains of pending tasks can be used to simulate an arbitrary unbounded and ordered storage device definition task passing a program which contains a statement post r p e r d such that r is called the of a program p is the maximum length of a sequence p pi of procedures in p such that each pj contains a statement post r e r d for j i and some r e r and d programs with unbounded are recursive and are otherwise theorem the problem for parallel programs is undecidable for a nonrecursive programs with n and b recursive programs with n the proof of theorem is given by two separate reductions from the emptiness problem for turing machines to programs ie those using statements but not await statements in essence as each can point to an unbounded chain of we can construct an unbounded turing machine tape by using one to store the contents of cells to the left of the tape head and another chain to store the contents of cells to the right of the tape head if only one region is granted but recursion is allowed ie as in b we can still construct the tape using the for the cells right of the tape head while using the unbounded to store the cells left of the head when only one region is granted and recursion is not allowed neither of these reductions work without recursion we can bound the procedure stack and then we can show that machine suffices to encode the single unbounded chain of tasks programs without task passing due to the undecidability result of theorem and our to compare the analysis of parallel programming models we consider unless otherwise specified only programs simplifying program syntax by writing post r p e d when is not allowed region valuations need not store an entire configuration for each task since the tasks initial region valuation is empty as this represents a significant simplification on which our subsequent analysis results rely we here a few key notions post v et m m r v sp d t post r p e d m c t skip m p c wait m r t m r m c t m p c m r t m r m c t await r m p c mr t await r m c t skip m c p return t m s m c p ts m m c figure the transition relation for recursively parallel programs without sequential semantics without a region valuation is a mapping m from regions to multisets of tasks a frame t m is a task t tasks with a region valuation m and a configuration c is a sequence of frames representing a procedure activation stack the transition relation of figures and implicitly include a transition t m c t m c whenever t t the definitions of sequential execution initial and reachable are nearly identical to their parallel and sequential counterparts since pending tasks need not store initial in programs this simpler semantics is equivalent to the previous semantics lemma for all initial conditions programs p the valuation is reachable in p from by a sequential execution with if and only if is reachable in p from by a sequential execution without even with this simplification we do not know whether the problem for recursively parallel programs is decidable in general in the following sections we identify several decidable and in some cases tractable restrictions to the program model which correspond to the concurrency mechanisms found in realworld parallel programming languages recursive vector addition systems with edges fix k n a recursive vector addition system a q of dimension k is a finite set q of states along with a finite set of transitions partitioned into additive transitions q × nk × nk × q recursive transitions q × q × q × q and transitions q × q we write q q qq q when q n n q and when q q q q q q when q q a nonrecursive vector addition system with states is a recursive vector addition system q such that contains only additive transitions an frame q n is a state q q along with a vector n nk and an configuration c q × nk is a nonempty sequence of frames representing a stack of nonrecursive the transition relation for recursive vector addition systems is defined in figure the additive rule updates the top frame q n by the vector n from n adding the vector n to the result and updating the control state to q the call rule pushes on the a new frame q from which the return rule will eventually pop at some point when the control state is q when this happens the vector n of the frame is added to the vector n of the frame below we describe an application of the call resp return rule as a call resp return transition finally the zero rule proceeds only when the frames vector equals an execution of a a from c to cj is a configuration sequence cc cj where ci ci for i j a configuration q n is called when q q and n and a configuration cf is called qf final when cf qf n c for some configuration c and n nk we say a state qf is reachable in a from q when there exists an execution of a from some configuration c to some qf final configuration cf the problem for recursive vector addition systems is to determine whether a given state q is reachable from some q recently et al have proved that in branching vector addition systems very similar formal model to which in this immediately gives us an on computing in without edges though in nonrecursive systems is for the moment we do not know matching upper and lower bounds for lemma the problem for recursive resp nonrecursive vector addition systems without edges is and in resp encoding recursively parallel programs as when the value set of a given program p is taken to be finite the set tasks also becomes finite since there are finitely many statements and handlers occurring in p as multisets are equivalently encoded with a finite number of counters ie one counter per element we can encode each region valuation m by a vector n nk of counters where k × tasks to the correspondence we fix an enumeration cn × tasks k and associate each region valuation m with a vector n such that for all r and t tasks t let ni denote the unit vector of dimension i ie and for j i given a recursively parallel program p without we associate a corresponding recursive vector addition system ap q we define q def tasks tasks and define formally in figure intraprocedural transitions translate directly to additive transitions the call statements are handled by recursive transitions between entry and exit points t and tf of the called procedure the post statements are handled by additive transitions that increment the counter corresponding to a pair the statements are handled in two steps first an additive transition the counter corresponding to pair r t then a recursive transition between entry and exit points t and tf of the corresponding procedure is made applying the handler of tf upon the return here we use an intermediate state t skip t tf q to connect the two transitions in order to the intermediate steps of other transitions the await statements are handled similarly except the await statement must be repeated again upon the return finally a transition allows ap to eventually step past each await statement additive q n n q n c q n n n c call q q n c q q n c return q n q n q c q n n c zero q q q c q c figure the transition relation for recursive vector addition systems to simplify presentation we assume that there is at most one recursive transition from each state ie for all q q q × q we denote by the vector and by and the usual vector addition and operators v et i v sp d t post r p e d ni t skip t await r t skip v et t v sp l vf t call l p e t l vf t seq t p t t i t s t r ni t skip t tf t s i t s t await r ni t skip t tf t s await r figure the transitions of the ap encoding the behavior of a recursively parallel program p notice that ignoring intermediate states t t t q the frames t n of ap correspond directly to frames t m of the given program p given the correspondence between vectors and region valuations this correspondence between frames indeed extends to configurations and ultimately to the problems between ap and p lemma for all programs p without procedures p and values is reachable from p in p if and only if there exist s and d d such that s d is reachable from sp d in ap our analysis algorithms in the following sections use lemma to compute of a program p without by computing on the corresponding ap in general our algorithms compute sets of region valuation vectors tf p def n t tf n ap the execution of a procedure between an entry point t e to denote zero or more way to compute such a function we could systematically replace interprocedural program steps ie of the call and await statements with procedural edges performing their net effect note however that even if the set of tasks is finite the set tf ap of summaries between t and tf need not be finite the ability to compute this set is thus the key to our algorithms in the following sections programs definition single wait a program is a program which does not contain the await statement programs can wait only for a single pending task at any program point many parallel programming constructs can be modeled as programs parallel programming with futures the future annotation of has become a widely adopted parallel programming construct included for example in x and in et al s task parallel library flanagan and felleisen provide a description of its semantics the future construct the procedural program structure for parallelism essentially adding a lazy procedure call which immediately returns control to the caller with a for a value that may not yet have been computed along with an operation for ensuring that a given has been filled in with a computed value syntactically futures add two statements future x p e touch x where x ranges over program variables p and e though it is not necessarily present in the syntax of a source language with futures we assume every use of a variable assigned by a future statement is explicitly by a touch statement semantically the future statement creates a new process in which to execute the given procedure which proceeds to execute in parallel with the all other processes created in this way the touch statement on a variable x blocks execution of the current procedure until the future procedure call which assigned to x completes returning a value with which is copied into x even though each procedure can only spawn a bounded number of parallel one per program is in general no bound on the total number of processes since procedure parallel recursive example the function can be implemented as a parallel algorithm using futures as follows proc fib var n n var x y n if n then return else future x fib n future y fib n touch x touch y return x y as opposed to the usual sequential implementation operating in time on this parallel implementation runs in time on the semantics of futures is readily expressed with programs using the post and statements assuming a region identifier rx and return handler dx for each program variable x we encode future x p e as post rx p e r dx touch x as rx where def x v simply assigns the return value v to the variable x and the vector r contains each ry such that the variable y appears in e parallel programming with et al s model of concurrent programming proposes a mechanism analogous to software version control systems such as and which to naturally and easily sequential code in order to take advantage of multiple computing there each sequentially executing process is referred to as a a can branch into two each to execute in parallel on their own separate copies of data or merge a provided a merge function to the updates to data which each have performed syntactically add two statements x s join x where x ranges over program variables and s semantically the statement creates a new process to execute the given statement which proceeds to execute in parallel with the all other processes created in this way the assignment stores a handle to the in a variable x the join statement on a variable x blocks execution of the current until the whose handle is stored in x completes at that point the current data is updated according to a merge function m × × when v v are resp the initial and final data values of the merged and v is the current data value of the current the current data value is updated to mv v v the semantics of is readily expressed with programs using the post and statements assuming a region identifier rx for each program variable x and a merge function m we encode x s as post rx ps l r d join x as rx where ps is a procedure declared as proc ps var l t var l l s return ll and d v v def l updates the current local valuation based on the initial and final valuations v v and the joining current local valuation stored in l the vector r contains each ry for which the variable y is accessed in s programming with asynchronous procedures asynchronous programs are to build reactive systems such as device drivers web servers and graphical user interfaces with requirements essentially a program is made up of a collection of tasks running and accessing a global store which post other tasks to be run at some later time tasks are initially by an initial procedure and may also be generated by external system events an event loop repeatedly chooses a pending task from its collection to execute to completion adding the tasks it back to the task collection syntactically asynchronous programs add two statements async p e such that is invoked only once as the last statement of the initial procedure semantically the async statement a actually r must in general be chosen nondeterministically as each handle may be either by the parent or its branch procedure call and returns control immediately without waiting for the call to return the statement repeatedly called but not yet and executing them to completion each procedure executes atomically making both synchronous calls as well as an unbounded number of additional asynchronous procedure calls the order in which procedure calls are is chosen nondeterministically we encode asynchronous programs as nondeterministic recursively parallel programs using the post and statements assuming a single region identifier r we encode async p e as post r p e d as while true do r p has toplevel statement s accessing a shared global variable g besides the procedure parameter l we declare p as proc p var l t var g var g g s return gg finally d v v def assume l v l v models the atomic update p performs from an initial shared global valuation v allows us to simulate the communication of a shared global state g which is later to have with v which the asynchronous task had written analysis the absence of await edges in a program p implies the absence of transitions in the corresponding recursive vector addition system ap to compute in p via procedure summarization we must summarize the recursive transitions of ap by additive transitions in a nonrecursive system for the pending tasks returned by reach procedure this is not trivial in general since the space of possibly returned region valuations is infinite in increasing difficulty we three special cases of programs whose analysis problems are simpler than the general case in the simplest case where the number of tasks stored in each region of a procedure frame is limited to one the execution of statements are deterministic when the number of tasks stored in each region is not limited to one nondeterminism arises from the choice of which completed task to pick at each statement see the wait rule of figure this added power makes the problem at least as hard as in vector addition though the precise complexity depends on the scope of pending tasks after examining the case we examine two cases by restricting the scope of task handles before moving to the general case analysis without aliasing many parallel programming languages consume only the computations of tasks in futures for example the touch x statement applies to the return value of a particular last one whose future result was assigned to x similarly in the join x statement applies to the last whose handle was stored in x indeed in the program semantics of each case we are guaranteed that the corresponding region rx contains at most one task handle thus the nondeterminism arising from choosing between tasks in a given region in the wait rule of figure though both futures and allow the following results apply to futures and programs which only pass pending tasks from child to parent definition non aliasing we say a region r is aliased in a region valuation m when mr we say r is aliasing in a program p if there exists a reachable configuration c t m of p in which r is aliased in m a program is a program in which no region is aliasing note that the set of region valuations is finite when the number of program values is the restriction thus allow us immediately to reduce the problem for programs to reachability in a recursive sequential program to compute we consider a sequence aa of finitestate systems iteratively the recursive system ap given from a program p initially a has only the transitions of ap corresponding to intraprocedural and post transitions of p at each step i we add to ai an additive edge an transition t r t s for some t tf tasks such that j t s and n is reachable at tf from t in ai ie n tf ai this aa sequence is guaranteed to reach a fixedpoint ak since the set of region valuation vectors and thus the number of possibly added edges is finite furthermore as each ai is finitestate only finitestate reachability queries are needed to determine the reachable states of ak which are precisely the same reachable states of ap note that the number of region valuations grows exponentially in the number of regions theorem the problem for programs is for a fixed number of regions and in the number of regions analysis definition local scope a program is a program in which tasks only return with empty region valuations ie for all reachable configurations c e m we have m m to solve in programs we compute a sequence aa of nonrecursive vector addition systems iteratively the recursive system ap arising from a program p the initial system a has only the transitions of ap corresponding to intraprocedural and post transitions of p at each step i we add to ai an additive edge an transition t r nj t s for some t tf tasks such that j t s and n tf ai since p is every such n must equal since the number of possibly added edges is polynomial in p the aa sequence is guaranteed to reach in a polynomial number of steps a fixedpoint ak whose reachable states are exactly those of ap the entire procedure is since each reachability query is equivalent to computing in vector addition systems theorem the problem for programs is analysis another relatively simple case of interest is when pending tasks are allowed to leave the scope in which they are but can only be consumed by a particular statically declared task in an enclosing scope this is the case for example in asynchronous programs though here we allow for slightly more generality since tasks can be to multiple regions and arbitrary control in the initial procedure frame is allowed definition global scope a programs is a program in which the and await statements are used only in the initial procedure frame since each procedure p of a program cannot consume tasks the set of tasks by p and procedures along any execution from t to tf is a set described by the of a contextfree language following and majumdar s approach for each t tf tasks we construct a vector addition system at tf characterizing this set of tasks recursively between t and tf then we use each at tf as a component of a nonrecursive vector addition system ap representing execution of the initial frame in particular ap contains transitions to and from the component at tf for each t tf tasks t r nj q t skip qf t skip t s for all r such that j t s and q and qf are the initial and final states of at tf we assume each at tf has unique initial and final states distinct from the states of other components at tf in order to transition to the correct state t s upon completion at tf carries an auxiliary t skip in this way for each task t to region r in an execution between t and tf the component at tf does the of the t component of the vector as each of the components at tf are constructed in polynomial time this method constructs ap in polynomial time thus in p is computed by in the nonrecursive vector addition system ap in exponential space the complexity is asymptotically optimal since programs are powerful enough to capture in vector addition systems theorem the problem for programs is the general case of analysis in general the problem for programs is as hard as in recursive vector addition systems without edges theorem the problem for programs is and in et al s proof of membership in relies on a nondeterministically chosen reachability witness without a practical algorithm for the search of said witness here we give a algorithm to compute we consider again a sequence aa of nonrecursive vector addition systems the recursive system ap of a program p initially a has only the transitions of ap corresponding to intraprocedural and post transitions of p at each step i we add to ai an additive edge an transition t r t s for some t tf tasks such that j t s and n tf ai even though the set of possible added additive edges recursive transitions is infinite with careful analysis we can show that this very simple algorithm terminates provided we can bound the n needed to compute in ap it turns out we can bound these the of a word w over an alphabet is the dimension vector of integers counting the number of occurrences of each symbol of in w the image of a language is the set of of its elements edge labels by that the minimal vectors required to reach a target state from any given program location are bounded we adopt an approach based on iteratively applying backward reachability analyses in order to determine for each task t the set of vectors t needed to reach the target state in ap let us first recall some useful basic facts vector addition systems are monotonic wrt the natural ordering on vectors of integers ie if a transition is possible from a vector v it is also possible from any u greater than v the ordering on vectors of integers is a well ie in every sequence of vectors v v there are two indices i j such that vi is less or equal than vj thus every infinite set of vectors has a finite number of a set of vectors is upward closed if whenever it contains v it also contains all vectors greater than v such a set can be characterized by its moreover the set of all predecessors in a vector addition system of an upward closed set of vectors is also upward closed and therefore backward reachability analysis in these systems always terminates starting from an upward closed set we observe that for every task t the set t is upward closed by monotonicity and therefore we need only determine its however since our model is recursive vector addition systems we must solve several queries on a sequence of vector addition systems with more transitions which necessarily we elaborate below first in order to reason backward about executions to the target state consider the nonrecursive system ai obtained by adding return transitions tf t s from every procedure exit point tf tf return e and procedure return point t e occurring in p such that s these extra transitions in ai simulate a return from tf to t all of the pending tasks from a frame at tf to a frame at t s without any contribution from the t ss intraprocedural predecessor t e then define a sequence of functions tasks nk each i mapping each t tasks to the possibly empty set of vectors it such that for any n it a configuration t n is guaranteed to reach the target reachable state in thus t n c is guaranteed to reach the target reachable state in ap for any c each i can be computed in by backward reachability in the nonrecursive vector addition system as explained above since each ai contains at least the transitions of ai the is wrt set inclusion ie more and more configurations can reach the target state ie for all t tasks we have it it since there can be no sequence of sets of vectors over natural numbers by the fact that the ordering on vectors of natural numbers if a the i sequence must after a finite number of steps furthermore since any n it is guaranteed to reach the target state it suffices to consider only vectors n bounded by the of the set it to see why notice that if some n it labels an edge between t and t then every configuration at t is guaranteed to reach the target state since this edge adds the vector guaranteed to reach the target from t additionally any vector greater than a minimal of it is already guaranteed to be present in it since it is upward closed thus we need only consider bounded by the decreasing sequence which shows that the aa sequence after a finite number of steps programs though programs capture many parallel programming constructs they can not express waiting for each and every of an unbounded number of tasks to complete some programming languages require this dual notion expressed here with await definition wait a program is a program which does not contain the statement thus programs can wait only on every pending task in a given region at any program point many parallel programming constructs can be modeled as programs parallel programming in the parallel programming language is an language with an runtime system which is used in a of environments from computations to parallel computations with similarly to futures see section adds a form of procedure call which immediately returns control to the caller instead of an operation to with a particular procedure only provides an operation to with every procedure at such a point the procedures communicate their results back to the caller with procedure in scope of the caller syntactically adds two statements spawn p e p sync where p ranges over procedures e over expressions and p over procedures declared by p var rv t s here s ranges over intraprocedural program statements containing two variables rv corresponding to the value returned from a procedure and l corresponding to the local variable of the procedure semantically the spawn statement creates a new process in which to execute the given procedure which proceeds to execute in parallel with the all other processes created in this way the sync statement blocks execution of the current procedure until each procedure completes and executes its associated the of each procedure execute atomically each procedure can spawn an unbounded number of parallel processes and the order in which the of procedures execute is chosen nondeterministically example the function can be implemented as a parallel algorithm using as follows proc fib var n n var sum n if n then return else spawn fib n spawn fib n sync return sum var i n sum sum i as opposed to the usual sequential implementation operating in time on this parallel implementation runs in time on the semantics of is ready expressed with recursively parallel programs using the post and await statements assuming a region identifier r we encode spawn p e p as post r p e dp sync as await r where dp v def sp executes the toplevel statement of the p with input parameter v parallel programming with asynchronous statements the pair of constructs in x introduces parallelism through executing statements and synchronization blocks essentially an asynchronous statement immediately passes control to a following statement executing itself in parallel a synchronization block executes as any other program block but does not pass control to the following until every asynchronous statement within has completed syntactically this mechanism is expressed with two statements async s finish s where s ranges over program statements semantically the async statement creates a new process to execute the given statement which proceeds to execute in parallel with the all other processes created in this way the finish statement executes the given statement s then blocks execution until every process created within s has completed example the function can be implemented as a parallel algorithm using asynchronous statements as follows proc fib var n n var x y n if n then return else finish async call x fib n async call y fib n return x y as opposed to the usual sequential implementation operating in time on this parallel implementation runs in time on asynchronous statements are readily expressed with nondeterministic recursively parallel programs using the post and await statements let n be the maximum depth of nested finish statements assuming region identifiers r rn we encode async s as post ri ps d finish s as await ri where i is number of enclosing finish statements and ps is a procedure declared as proc ps var l t var l l s return ll and d v v def assume l v l v models the update p performs from an initial local valuation v using the same trick we have used to model asynchronous programs in section we model the sequencing of asynchronous tasks by initially the value v which the asynchronous tasks had written and that value when the handler of a given task is finally run note that although x allows in general asynchronous tasks to their memory accesses our model captures only tasks by assuming either ie disjoint accesses to data or by assuming tasks are properly synchronized to ensure atomicity analysis the presence of await edges implies the presence of transitions in the recursive vector addition system ap corresponding to a program p as we have done for programs we first examine the easier of programs which in the setting corresponds concurrency in the language modulo task interleaving as well as structured parallel programming constructs such as the foreach parallel loop in x and in et al s task parallel library see our extended online report the concurrent behavior of the asynchronous statements section in x does not satisfy the restriction since async statements can include recursive procedure calls which are nested without finish statements there computing is equivalent to determining whether a particular vector is reachable in a nonrecursive vector addition decidable problem which is known to be but for which the only known algorithms are recursive since all parallel languages we have encountered use only a we restrict our attention at present to programs analysis with the restriction executions of each procedure p between entry point t tasks and exit point tf tasks are completely summarized by a boolean indicating whether or not tf is reachable from t however as executions of p may await statements modeled by edges in the recursive vector addition system ap computing this boolean requires determining the reachable program valuations between each pair of consecutive synchronization points ie occurrences of the await statement which in principle requires deciding whether the vector is reachable in a vector addition system describing execution from the program point just after the first await statement to the point just after the second ie when r and r are synchronization points we must determine whether can reach a careful analysis of our reachability problem reveals it does not have the complexity of determining in general due to the special structure of our reachability query we notice that between two synchronization points t and t of p execution proceeds in two phases in the first post statements made by p only increment the vector valuations in the second phase starting when the second await statement is encountered the await statement repeatedly tasks only the vector vector valuations can not be again because of the restriction each consumed task is forbidden from returning addition tasks due to this special structure deciding reachability between t and t reduces to deciding if a particular integer linear program it t has a solution since tasks in the requires using the summaries computed for other procedures we consider a sequence aa of nonrecursive vector addition systems iteratively the recursive system ap initially a has only the transitions of ap corresponding to intraprocedural and post transitions of p at each step i we add to ai one of two edges types one type is an additive edge used to describe a single step of an await transition t await r nj t s await r for some t tf tasks such that j t s and tf ai the second possibility is an additive summary edge an entire of sequence of program transitions between two synchronization points where r r tasks are consecutive synchronization points occurring p and ap the edges are computed using only finitestate reachability between program states using the summary edges while the summary edges are computed by reduction to integer linear programming as the number of possible edges is bounded in the program size the aa sequence is guaranteed to reach a fixedpoint ak in a polynomial number of steps though each step may take time in the worst case to compute solutions to integer linear programs the reachable states of ak are precisely the same reachable states of ap theorem the problem for programs is npcomplete analysis without the restriction each execution of each procedure p between entry point t tasks and exit point tf tasks is summarized by the tasks between the await statement at a synchronization point ts tasks note that ts t if no await statements are and a return statement at the exit point tf since p can make recursive procedure calls between ts and tf and each called procedure can again return pending tasks the possible sets of pending tasks upon ps return at tf is described by the of a contextfree language lt tf it turns out we can describe this image as the set of vectors computed by a vector addition system tf without recursion and edges we use thus computations of tf to summarize the set of possible reached in an execution from t to tf however computing tf is not immediate since between t and the synchronization point ts of the given procedure p may await statements necessarily so when t ts since we use edges to express await statements we also need to summarize execution between synchronization points ie between the procedure entry point and among await statements using only additive edges to further each such summarization requires in turn the summaries tf computed for other procedures we break the circular dependence between procedure summaries and summaries by iteratively computing both in particular we compute a sequence al al of procedure summary vector addition systems along with a sequence aa of vector addition systems such that each ali for i is computed using the transitions of ai and ai for i is computed using the procedure summaries of ail initially al contains only the sets reachable without taking await transitions and a contains only the transitions of ap corresponding to intraprocedural and post transitions of p along with transitions to components al for i ai contains transitions to and from the components ali t tf t await r nj q t skip qf t skip t s await r for each t tf tasks such that j t s and q and qf are the unique initial and final states of ali t tf we assume each component tf has unique initial and final states distinct from the states of other components additionally we each tf with auxiliary state to carry the identity t skip of the invoking task to ensure the proper return of control when tf completes at each step i we add to ai an additive edge the execution between two synchronization points r and r occurring in p such that is reachable in ai from ie ai note that when t await r is a synchronization point occurring in p t skip refers to the program point immediately after the await statement since there are only such edges that can possibly be added we are in recursively parallel programs result complexity general thm undecidable futures thm futures local scope thm global scope thm asynchronous programs general thm for programs without single region local scope thm np general thm decidable async x figure summary of results for computing for recursively parallel programs guaranteed to reach a fixedpoint ak of aa in a polynomial number of steps furthermore the reachable states of ak are precisely the same reachable states of ap however computing t ai at each step is difficult due to the edge in the await statement immediately preceding t this is computationally equivalent to computing reachability of a particular vector in nonrecursive vector addition systems theorem the problem for programs is decidable since practical algorithms to compute is a difficult open problem we remark that it is possible to obtain algorithms to approximate our problem consider for instance the semantics given by transforming each await r statement into while do r though many more behaviors are present in the resulting program since not every task is necessarily consumed during the while loop practical algorithmic solutions are more see section related work formal modeling and verification of multithreaded programs has been studied including but not limited to identifying decidable subclasses and effective and analyses to our knowledge little work has been done in formal modeling and verification of programs written in languages which are free of thread interleaving and s asynchronous programs which out as a special case of our programs is perhaps most similar to our work in this regard practical verification algorithms by combining iterative over and underapproximation and complexity analysis of asynchronous programs have been studied though decidability results of abstract parallel models have been reported and survey of this line of work these works target abstract computation models and do not identify precise and optimal algorithms for realworld parallel programming languages nor do they handle the case where procedures can return unbounded sets of computations to their callers conclusion we have proposed a general model of recursively parallel programs which captures the concurrency constructs in a variety of popular programming languages by the fragments corresponding to various language features we are able to associate corresponding formal models measure the complexity of and provide precise analysis algorithms we hope our complexity measurements may be used to guide the design and choice of concurrent programming languages and program analyses figure summarizes our results acknowledgments we greatly discussions with and peter and the feedback of majumdar ball and the anonymous popl reviewers references p a k b and yk general decidability theorems for systems in lics proc th ieee symposium on logic in computer science pages ­ ieee computer society e allen d v s g l s jr and s the language specification technical report sun inc a and m analysis of recursively parallel programs a and j rewriting models of boolean programs in proc th international conference on term rewriting and applications volume of lncs pages ­ springer a m and t regular symbolic analysis of dynamic networks of pushdown systems in concur proc th international conference on concurrency theory volume of lncs pages ­ springer s a and d concurrent programming with and isolation types in oopsla proc th annual acm sigplan conference on objectoriented programming systems languages and applications pages ­ acm p c v a c a k c von and v sarkar x an objectoriented approach to cluster computing in oopsla proc th annual acm sigplan conference on objectoriented programming systems languages and applications pages ­ acm s m o and r the covering and problems for branching vector addition systems in annual conference on foundations of software technology and theoretical computer science pages ­ j and p complexity of verification for multithreaded programs in popl proc th acm sigplansigact symposium on principles of programming languages pages ­ acm j and a podelski efficient algorithms for pre and post on interprocedural parallel flow graphs in popl proc th acm sigplansigact symposium on principles of programming languages pages ­ acm a and p transition systems everywhere theor comput sci ­ c flanagan and m felleisen the semantics of future and an application j program ­ c flanagan and s qadeer model checking in proc th international workshop on model checking software volume of lncs pages ­ springer p and r majumdar algorithmic verification of asynchronous programs abs g and l v begin expand and check new algorithms for the problem of j comput syst sci ­ s and h construction of abstract state graphs with in cav proc th international conference on computer aided verification volume of lncs pages ­ springer r h jr a language for concurrent symbolic computation acm trans program lang syst ­ t a henzinger r jhala r majumdar and s qadeer abstraction refinement in cav proc th international conference on computer aided verification volume of lncs pages ­ springer r jhala and r majumdar interprocedural analysis of asynchronous programs in popl proc th acm sigplansigact symposium on principles of programming languages pages ­ acm v vs of lock chains characterizing decidability of pairwise for threads communicating via locks in lics proc th annual ieee symposium on logic in computer science pages ­ ieee computer society d kozen lower bounds for natural proof systems in proc th annual symposium on foundations of computer science pages ­ ieee computer society a and t w reps reducing concurrent analysis under a context bound to sequential analysis formal methods in system design ­ j r and r transactional memory morgan e a lee the problem with threads ieee computer ­ d w and s the design of a task parallel library in oopsla proc th annual acm sigplan conference on objectoriented programming systems languages and applications pages ­ acm r j the reachability problem requires exponential space technical report yale university p h s and d s a programming model for deterministic task parallelism in proc acm sigplan workshop on memory systems performance and correctness pages ­ acm c the covering and problems for vector addition systems theor comput sci ­ g contextsensitive analysis is undecidable acm trans program lang syst ­ k h efficient multithreaded computing phd thesis department of engineering and computer science massachusetts institute of technology may t w reps s horwitz and s sagiv precise interprocedural dataflow analysis via graph reachability in popl proc th acm sigplansigact symposium on principles of programming languages pages ­ acm c and t s and deterministic parallelism support and programming model in proc first international workshop on future support for parallel programming k and m model checking multithreaded programs with asynchronous atomic methods in cav proc th international conference on computer aided verification volume of lncs pages ­ springer 