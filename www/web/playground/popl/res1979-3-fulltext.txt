an efficient way to find the side effects of procedure calls and the aliases of variables john p stanford linear california center introduction often when we are analyzing a pro gram for instance to information for optimizing transformations we need to know the effect of executing some element of the program on the programs variables in the simplest case we might want to know what variables might be modified or referenced by the execution of a state ment the presence of procedures and pro calls in a language this analysis in two ways the first and most obvious way is that it is not apparent from looking at a call on a procedure what effect executing that call will have on variables this is determined by the procedures which might be executed as a result of making the call thus the execution of a procedure can have a side effect on variables at the point from ah the procedure is called the second way is that the parameter passing mechanisms associated with proce calls can cause two distinct to refer to the same location at the same time variables in which case we say the the are aliases the most common way this can occur is when a global ble is passed by reference to a parameter of some procedure during the execution of the procedure the global variable and the reference parameter will refer to the same location as a result a tion or reference to one will be a cation or reference to the other the main result of this paper in two methods the first for finding side effects second for of procedure calls and finding the possible aliases the of variables in their basic form these me work was supported states department contract corporation in part by the of energy under and in part by authors present tion california address will find using one pass over the text a program flow side ef defined below and ali they will do this up to symbolic execution for programs which have recursion and refer ence parameters the basic methods can be extended to cover flow sensitive side ef with some ss of precision exits from procedures at the of an ad pass over the program procedure parameters with some restrictions and a number of other features and constructs including dynamic naming structured vari ables and certain kinds of pointer we will discuss flow sensitive side effects here the remaining extensions are covered in the basic method for finding side ef involves solving a flow problem on s graph the graphs nodes correspond to procedures and the edges to calls between procedures associated with each edge is a function which describes how the calling procedures side effect depends on the side effect of the called procedure by solving this problem by any of a number of well known methods used in global flow analysis see we assign to each procedure a generalized side effect for the corresponding procedure the side ef of a call on a procedure can easily be derived from the procedures general side effect the basic method for finding aliases which is completely separate from the side effect calculation involves a single global computation which finds all pairs of possible aliases as explained in sec tion pairs of aliases are either trivial e g x is an alias of x or they derive from another pair of aliases through the action of a call the of the method is a recursive routine which given a pair of variables which are possible aliases finds all the other pairs of possible aliases which are from the original pair and calls it self with these new pairs the routine is started by calling it with all the trivial pairs of aliases as well as requiring only one pass over a programs text regardless of the order of procedures these algorithms tend to be computationally efficient because they take advantage of the lack of of programs for instance the side effect algorithm than a transitive tend to be faster closure such as bar because it takes of the fact that the call graph of a program is usually very con the alias algorithm grows in the number of actual bindings of aliased vari ables and considers only calls and that are actually related to alias pairs the side effects with which we will be concerned are as follows for some statement s perhaps a procedure call is the set of variables whose value may be modified by an execution of s is the set of variables whose value may be or referenced by an execution of s uses is the set of variables value may be by an tion of s before being defined execution of s whose by an le is the set of variables value must be defined by every tion of s for the method presented here an im characteristic of each side effect type is how the side effect of a tion of statements is derived from the el of the collection consider the two statements x and y in figure both are composed of the same statements a and b but x requires b to executed after a and y requires one or the other of a and b to be executed note that and are both the same in other words the variables which may be modified by x or y are just those that may be modified either by a or by b because of this we say that mod is flow use and def however are different the statement y may use whatever variables a use but the statement x requires that a not define the variable to use them similarly is xc defines what either a or b defines but y defines only those that both a and b defines because use and def depend on the flow through a piece of code as well as upon its we say that they are flow i x qb y ab figure composition of side effects the important consequence of this distinction is that for a flow tive side effect the side effect of the whole can be determined by first process ing the whole and later determining the side effects of the parts and taking their union if one of the parts is a call on a procedure which has not yet been scanned then the ability to defer determining the calls side effect is very useful for flow sensitive side effects however this cannot be done if determination of the side effect of a part is to be deferred then flow information about the whole must be so that the contribution of the part to the side effect of the whole can be determined later of flow side effects and aliases given in this pa per yields the most precise results ble under the assumption that any path through a procedure can be taken when the procedure is called and that the path taken is independent of the call which in the procedure sensitive side effects are found with less precision in ways that are discussed below in the following sections we present a model for the kind of programs these me handle and use this model to show that the methods are correct ck structured this section a simple model of a typical block structured program and its execution the model is needed to provide a foundation for pre about aliases and side effects and for proving the methods of finding them the model only those aspects of programs which are needed here for the present we will consider block struc programs with nesting of procedures parameter passing by reference and s calls procedure are of procedures considered in notions of flow through discussed later and procedure parameters a out are a block structured program contains a set of procedures which are as nodes of a rooted tree the root of the tree is called the main procedure the direct descendants of any node are those procedures directly declared in that procedure within each procedure is declared a set of variables each variable either be ing a simple we s ay that or reference param are local to the procedure the variables contained in all the ancestors of proce are to that procedure and the local and global variables of a together are that procedure the visible variables for likewise the procedures directly contained in a given its ancestors are visible to which are procedure or that proce each procedure also contains a number of statements which can modify or refer ence variables and which can call other procedures any which are af by a procedures statements must be visible to that procedure the effect on variables of which lie on some path through a procedure is summarized by a number of immediate side effects procedure these immediate side of the effects the effects of any called proce thus the immediate modification side effect gives the variables modified by contained in proce p statements which call other proce to as call sites two things first they a pro to be called this procedure the called procedure must be visible to the procedure containing the call site the calling procedure second for each ref parameter of the called procedure the call site must an actual pa to be bound to the reference pa this actual parameter must be a variable which procedure is visible to the calling figure program and ing program gives figure model an example shows the of a pascal correspond given introduce which is a which calls the idea of call the notion of sequence of call the procedure sites we can a call chain s each of containing the the term simple variable distinguish them from rather than to structure is used here to reference suggest of program p x y z procedure p var x y begin then x y x y integer procedure pl var yl kr xl integer procedure p var x integer var y if z z then px y xl s s begin pi if x if xl xl yl pz then py s s s begin end s s s figure example pascal program simple x y z calls sl s s parameters x y parameter simple xl calls s yl yl s s parameter x calls s s call site s s s s s s s s called procedure pl pl p p p p pl pl actual y x y z z yl yl y x z binding formal yl yl x y x x x y yl yl figure program for example program next thus the sequence of call sites s sn is a call chain iff for every i lin si calls we the procedure containing that we be able to reach every starting words a call call site via in the main that for every chain s sn a sequence procedure call s there such that sl of calls in other must be is con in the main procedure and s sn this a program a captures the static structure of now we need to look at how such can be executed the key components in the execution of a program are a set of in which procedures execute and a set of lo to which variables are each locations as we can think containing values of these for the variables the set in a tree of structure and is also is con from the executed program as fol we start with an activation in which the main procedure will execute this activation is the root of the tree and within it we local map each variables of the main to a unique procedures location any activation already in the tree is given a descendant activation for every call site that can execute in it a call site can execute in an tion if it is contained in the proce executing in that activation this descendant activation is said to be called by the call site from the original activation and the descendant and all its descendants are said to be the descendants of the original tion due to the call site the proce executed in this new ac is the one called by the call site the mappings for the variables visible to this procedure are con as follows simple local var are mapped to new unique tions reference parameters are mapped to the same location as their actual parameters in the ancestor activation global variables are mapped to the same location as they in the immediate ancestor activation this mapping of global variables does not exactly follow the semantics of block structured languages in fact we should find the static nest activation and use its mappings what we are doing here is exactly equivalent however because ev activation the static nest activation and the newly created figure gives a fragment of the ac tree for the program of figure this tree of can be thought of as a skeleton in which all executions of the associated program could be embedded execution would proceed as follows main start with the procedure in the execution of root activation the every time a call site is executed by some procedure in some activation t the called procedure starts executing in that immediate descendant activation which the call calls tions mapped to by simple all in the new activation are just prior to beginning to procedure mapping y z p cl called by procedure mapping x y z xl yl z s pl t called by procedure mapping y z x yl z s pl t called by mapping y z x y sz p t called by procedure mapping y z x yl z x y s p t called by procedure mapping xn y z x y z x y s p t called by procedure mapping xn y z x y s p part of the activation the example program tree fol tion must map these the same location global this variables is proved to in when a procedure returns from ex in an activation all locations allocated in the activation are and their values lost execution re in the immediate ancestor tion finally when a ing in an activation a variable the cation mapped to by modified or referenced procedure modifies or value in that variable the some ideas that will be in about this model are an activation chain realization and passing of an activation chain is a sequence of each is the di descendant of the previous one we can think of any chain which starts with the activation as being a of the activation record stack during some execution of the program we note that for every activation chain there is a corresponding call chain which is constructed by taking in order the call sites which called each of the the activation chain is said to be a realization of the corresponding call chain we note some easily proved properties of call chains and activation chains each activation chain unique call chain a every call chain is realized by at least one activation chain in any activation t in which a call site s can execute there is a realization of any call chain starting with s whose first activation is a direct descendant of t finally a call site s is said to a variable x to a variable y iff variables x and y are the same variable and are global to the procedure called by s or call site s binds x as an actual parameter to reference parameter y this definition is motivated by the fact that reference parameters and global variables in an activation receive their mappings from the immediate ancestor in other words if call s passes variable x to variable y then in any ac called by s y will map to the same location that x does in that tions immediate ancestor similarly if a variable x maps to the same location in activation k as variable y does in ts im ancestor then the call site which called t must pass y to x aliases the first use of this model precise definition of alias is a more definition two variables are aliases in some activation if the are both mapped to the same location in that activation two variables are possible if there is some activation in which they are aliases the first result about aliases which is proved in is that if two vari ables are possible aliases then for every procedure in which both variables are visible there is some activation for that procedure in which the variables are ali thus the fact that two variables are possible affects every proce in which both variables are visible we call this the principle of of alias although this helps us in applying possible alias information it doesnt tell us how to find it in order to fig out how to find possible aliases we will start by how they arise first we note that if two variables x and y x y are aliases in some then neither can be a simple local variable as these are mapped to unique locations thus they must be either global variables or local reference param if x and y are aliases in some ac this means that the call which created that activation must have passed variables x and y to x and y and x and y must be aliases tor activation in the immediate lx and y could have been the same variable in which case we say the variable self is a trivial alias of it this is a necessary and sufficient condition for two distinct variables to be aliases in an and it forms the basis for a necessary and sufficient con for two distinct variables to be possible aliases two variables x and y x y can be possible aliases iff there is a call site s and possible aliases x and y such that s passes x to x and y to y to establish x and y as possible aliases what we must find is a chain of possible leading to x and y from some x and y are the same ble the following theorem states this fact alias for two variables x and y to be possible it is necessary and sufficient that there exist a sequence of calls sl sn and a sequence of pairs of variables such that xa xn x yn to yi call i passes y and for to xi every i and proof tion chain we will prove by that all pairs of variables in the are possible aliases clearly x and yo being the same variable are pos aliases if and yi are pos aliases then the of alias tells us that there is some tion t for the procedure containing call i in which i and are aliases because si passes i to xi and yi yi the activation called by si from t must map xi and yi to the same location as and thus xi and yi are ble we have some activation t in which x and y map to the same location we can construct the sequence of calls and pairs of variables in a backwards tion from n to in the following way start with xn x and yn y because xn and yn map to the same location in tion t one of the following must hold variables xn and yn are the same variable constructed done in which case we have our chain and are neither n nor yn is a local simple variable of the procedure executing one were in activation t if the fact it map to the same same location as the other would force the first case to be true if the first case does not hold then we take sn to be the call which called t and which n are and to be the variables passed to xn and yn by call sn these variables must to the same tion in the immediate ancestor of thus we can repeat the same argument for xn and yn if we continue back and given in the ancestors of activation t we must come to an activation in which the first case holds and we are done if we did not reach such an activation we would eventually come to the activation for the main local procedure and simple in which u every variable is given this result there is a fairly straightforward way to find all pairs of possible use a recursive proce to do a depth first search of all the chains of pairs of possible aliases starting with the trivial pairs the pro visit which follows does just this procedure visit in variables if are not marked aliases then begin as possible mark as possible aliases for every which passes xy there x to do xy for is a call s that x and y to y end end visit for every variable x do thus visit is and y once it has and y are possible finds that x and y it marks them searches deeper in called with arguments x been established that x aliases if visit have not yet been vis as possible aliases and the chain they are on give loop three xy these in order to implement visit careful consideration to we start by noting that cases for the relationship and xy and the call are as we must its main there are between site s x is bound s and y is y by s as an actual to x bound as an actual by to y and y are a single variable which is global to the procedure s and s binds x as an actual to reference parameter x x and x are a single variable which is global to the procedure called by s and s binds y as an actual to reference parameter y these three following three of the main loop cases give loops as an of visit rise to implementation the for every xy there is a call which and y to y do for which binds x to x for every xy for call which binds calls a procedure global do which there is a x to x and which to which y is for every xy for call which binds calls a procedure global do which there is a y to y and which to which x is three figure shows how visit the program of figure loops would with aliases and side effects before considering the question of how to find the side effects of calls we should consider how this information is to be used as it will have an effect on ex what we want to look for what we often want to do is to determine if the execution of two pieces of code can con in some way consider the following example var ab integer procedure begin p var x integer a b end pa pb we might want to know if there is any ac of procedure p in which an tion of a will modify a location which is referenced by an evaluation of b perhaps we are trying to do com subexpression elimination and a lies on a path between two evaluations of b because locations and are runtime entities we try to answer the question of conflict by associating sets of affected variables with each statement and checking the sets for common members in doing this we must be how ever the set of variables which may be modified by as is ax because of the call pa the set of variables which may be referenced by b is bx because of the call pb if we were to compare these two sets we might con that there is a conflict between a and b this is not correct however for a and b being simple can never refer to the same tion thus there is no activation of p in which a can modify a location refer by b this same problem arises if we replace a with a procedure call which modifies a and b with a proce call which references b what we need is a of the side of a piece of as a call the should include only variables potentially affected in every definition code such definition which are activation from line with alias pair derived via call from alias pair duplicate call on visit xx xx xx xy y xy yy x x x yz yz xx yy xx yy xx s s xx s yl x yy s yy s s s xy s s yy s x s s s figure alias run against program the example while variables to cover every location in ev activation we call such a side ef a direct effect as it indirect side effects due to aliases and define it for modification as follows definition effect met the direct for a statement of variables two criteria modification s denoted which meets side the fol for every activation t in which s can execute and every location which the execution of s can potentially modify in t there is some variable in which maps to location in ac t for every variables x in and every activation t in which s can execute an execution of s in t must potentially modify the location mapped to by x in t in order to establish a potential conflict between two statements we take their is a alias this result direct side effects and see if there variable in one that is a possible of a variable in the other that does find conflicts is stated for in the following theorem the same is shown in the same way or any combination of direct side effects theorem sl and execution conflict s in the given two statements same procedure for an of s and s to conflict in some activation that there it is necessary is a variable and sufficient v in and a variable v in such that vi and v are possible aliases proof if s and s conflict then tion there is an activation t and a such that both sl and sn may modify in t must be by the definition of there some variable v in and variable v in which both map to location in activation t because vi and v map to the same location they are possible aliases and the result follows assume variable vi is in with vi and and variable v is in v being possible aliases by the there is an v both map of activation to the alias we know that t in which v and same location and in which sl and s can execute by the of it follows that both s and s can modify this common location and thus conflict u the just what modify a activation remaining does it location question for mean for a call when executed calls is site to in some when a call activation the called procedures of that site is executed in directly and indirectly will execute in the activation due to some this concept which is talk about only what for side could happen be applied def which talk every execution eg mod ref use to side effects such about what must happen in every environment it as for but t would always be the same as call site in each of these descendant locations may be modified those locations which are not by the time we return are considered that execution to the original activation to have been modified by of the call site those locations which are modified but be returning to the original activation have no effect in that activation and are ignored this leads to the following definition definition a call site cation when executed there is an activation sg modify in activation chain lot if such that s calls tl from t can be modified in and is not allocated in any of tl through tn side effects now that we know just what we are looking for we can try to find a tion for a variable direct modification to be in a c sites side effect f to get a handle on this problem we use two ideas introduced above call chains are used to track down the procedures which might be called indirectly as a result of making a call and passing of variables is used to follow variables which are visible in the calling proce to variables in called procedures we start by generalizing calls to call chains the idea a call chain from single of passing i said to variable x to variable y iff there is a sequence of variables xn such that x y i successive successor step and for every to xi in other i lin words si each call in to the on the call original chain passes a variable one as we noted before if variable x is passed to variable y by call site s then the mapping of y in any activation called by s will in that be the same as the immediate mapping of x ancestor a similar occurs for variables passed by a call chain take tl tn to be an activation chain which call chain s sn if passes a a this tion same ence section will side effect considerations side effect consider explicitly apply the exactly the to the refer variable x to a variable of y in activation y then the is the same as the mapping of x in the immediate ancestor of t this proved by induction given the result a single call for passing variables by it induction and v location is also that for which in tn ancestor of tl to v true and easily shown by if there are variables u v is mapped to the same as u is in the immediate then must pass u this straightforward is stated result gives rise condition for in the next theorem to a fairly which theorem for call site s all variables x chain c the definition of is satisfied by the set of for which there is a call and variable y such that s s c passes x to y and y may be im by sn modified by the procedure called proof first given an activation t and lo cation such that s modifies in t we must show that the set defined by the theorem contains a variable x which maps to in t if we have such an activation and location then there must be an chain such that s calls tl from t and may be modified in tn take c to be the call chain realized by tl tn and y to be the variable which maps to in tn clearly c passes x to y and y may be immediately procedure called by sn modified by the thus the result holds given a variable x in the set defined by the theorem we must show that for every activation t in which s can ex executing s in t may directly mod the location mapped to by x in t if we take the realization t tn of the call chain c such that s calls tl from t we note that the variable the same location in tn y will map to that x maps to in t and in tn that this location may be modified further the location cannot be al located in tl tn as only locations not mapped to in the ancestors of an tion can be allocated in the activation q given this condition all the variables which ry call chain and how do we find meet it finding all the variables passed each to a will be less there is some way them at the same time such a way global flow reverse calls graph of a modifying proce expensive un to find of in fact there is analysis on the program a programs reverse calls graph has a node each procedure in the program and a directed edge from node p to node q for every call in procedure q which calls procedure p thus the reverse of the calls graph a path in edges el en this graph such that is a series of ei is directed towards the node that is directed away from for all i lin the path is said to lead from the node which el is di from and to the node that en is di towards what we use this graph for is to help us assign to each procedure node a side effect from which we can cal the direct side effect of any call on that procedure the direct side effect of any call on a procedure is the set of all variables which are passed by the call to some variable in the procedures side effect in order to find these generalized side effects we construct a ow problem for the reverse calls graph this flow problem involves doing two things to the reverse calls graph the first is to as sign to procedure node the set of immediately modified by that pro this can be thought of as an initial approximation to the side effect the second element is to assign to the edge for a call site s a function for that call site which maps sets of into sets of variables as follows fx i x where x by call site of variables called by s is the variable passed to s and is the set global to or reference the procedure parameters of this is also called things an information problem a global flow problem or a path problem on a directed graph see for a survey of these problems and their solution me looks the most like what is done here shows how the problem can be stated in terms of the formalism of that procedure figure graph and of figure edge shows the reverse functions for the calls program with a function edge we can define any path e associated with each a function fe for as follows e o of en over z the what we want to do is find the meet all paths solution to this flow prob this solution assigns to each node p union of for every path e to node p from any node q we will call the set assigned to node p by this tion and will show that it is in fact the generalized side effect mentioned above the meet over all paths solution to the flow problem of figure is shown in figure in the path variables that the variables following showing this function for to variables corresponding to variables two lemmas we first note that a given path maps in the same way call chain passes this gives us the lemma if there is a call chain which passes variable a set of variables then x is in x to variable y and y which y where fe is the path function s sn for the path corresponding to lemma if variable path function then the call to path x e must x is in for some fe and set of variables chain corresponding x pass x to some variables in both of these lemmas have straight forward induction proofs which are based on establishing the correspondence between calls in the call chain with edge functions in the path function given show that the general called by these side s lemmas we can easily can be calculated from effect of the procedure t can be shown that these func tions are members of a set of functions which is distributive with respect to union and is closed under union and com position this is important from the point of view of solving the global flow analysis problem unfortunately these functions are not fast in the sense of graham and wegman fx fx fx fx fx fx fx x xyz i x e s if y e x then y x xyz i x e if yl e x then x x xyz i x e if x e x then y if y e x then z i x e x if x e x then z x e x if x e x then yl pass sx x xyz i x e if x e x then y if y e x then y x xyz x if yl x then x x xyz i x e if yl e x then z figure flow problem program for the example sl s xyz s xyz s xyz xyz figure solution problem to the flow theorem for of a call site satisfied fs is s the definition by the edge the set function for call s p s and solution to the problem is the is the above procedure meet over global flow called by all paths analysis proof the above two lemmas and the tion of meet over all paths solution es that contains the set of variables immediately modified by p and all variables chain x for which and variable there is a call y such that sl is contained in p sl sn passes x to y and y is immediately modified called by sn given by the and the definition of fs the theorem that satisfies the def of flow sensitive side effects unlike mod and ref the side effects def and use on the flow through a procedure as as the statements in the procedure for this reason the method of this paper cannot find these side effects precisely although it can find a safe ap in order to apply the present we must find summary information flow through each of the procedures program this summary information of a nature that it can be used generalized side effect calculation out the standard solution method about in a must be in the for def for we collect each procedure the following p is the set of variables defined by statements directly contained in p along every path through p the ef of procedures called by p are thus every variable in p will be defined by some statement in p during every execution of p is the set of procedures which must be called during every execution of p it is not required however that the call be via the same call site every time p v is defined for exactly those variables v which are reference pa of procedures called by p contains those variables which will be bound to v by some call from p during every but not necessarily each time execution of p by the same call thus corresponds to in the basic model and and hold the limited flow information that will be used figure gives an example of and for a procedure p the systematic derivation of and global information requires flow analysis on the use of each procedure see also shows the kind of side effect information which is lost because of the limited flow information if pro q defines y for instance then y will be defined along both of the if statement in p and thus p will define y however the saved this fact is not reflected flow information y is not in in q is this method will not in and thus not discover it a difficulty involving two procedure calls exists if p and p both define y in this case y is defined bv p but the fact is because nor p is in var u w x y z integer procedure ql var xl begin integer procedure q begin procedure q var x begin ew integer procedure q begin procedure p var a begin w then begin y end q z begin b integer qx a qx qb end wz al q fx figure example of elements model for def of a second was discussed in section and arises if a and b are aliases reference during ex of p in this case they are both defined by p but only for that call which causes them to be aliases to deal with these problems precisely one must turn to a much more complicated method such as that of rosen given the and we construct a slightly different reverse calls graph and assign different functions to each edge the graph still contains all the programs procedures as nodes but the edges are different there is a single edge from procedure p to pro q iff p is in thus we have the reverse must call graph the initial assignment of sets variables to nodes assigns to node p just as was assigned the function assigned to an from p to q is of each x pq x where is x if x is global to procedure p and is if x is a reference parameter of p is the set of variables which are global to procedure p or reference parameters of p the meet over all paths solution to this problem is found just as before yielding a generalized defines side ef m for any call site s which calls procedure p we can find defs as before by applying the edge function for call s from the calculation to defs this method is based on the fact that def about what must happen every time a call is made thus we look only at what is defined called or bound during every execution of a procedure and gate side effects according to these re the proof of this method which can be found in follows the one for mod using must call chains and the idea that such a n must a variable x to a variable y for the side effect use we use a similar process except that we must col more complex information due to uses dependence on def the summary tion for use is collected in two steps in the programs about defines first step during the text we collect variable uses side effects of calls pass over a information knowing the this in formation is collected flow using analysis the same to find def summary information defs once we have we combine for all call information finished this sites the def information with to get the fol is the set may be referenced of variables by statements which di contained in procedure p with out first being defined by statements in p the effect of called proce is only taken into account for defines is the set of defined by statements containing call is executed this tions due to other procedure variables in the site includes s call sites always proce before s in the the graph we use to find the generalized usage side effect is the same as that used for because what may happen we are initial assignment of variables to node p is and the function associated with the edge for call s is where fs is the edge function used in the calculation meet over all paths solution problem has been found usage side effect is calculated just as is from for call s once the to this flow the direct from where p site s is the procedure called by call the correctness proof of this method is also found in the thing to note here is that once def is known and taken into account use behaves very much like a flow side effect and can thus be handled much like mod the in this calculation all comes from the of def and is re in the and if and were known precisely then the subsequent calculation of would be precise to past work sp and bar and aho and unman ah all give methods of finding the possible aliases of variables using some form of transitive with giving the most accurate results of these is as accurate as the given here although none method is more general covering tures of almost all of the sp gives an for calculating mod which uses calculation in a large bit array more language than the one given here but slower and less precise and does to extend to more complex side such as def or use algorithm iterative the is much not seem effects allen and allen and schwartz give flow analysis a method for which requires interprocedural scanning pro in a particular order reverse in problem order of finding they do aliases not treat or exits the from procedures they assume this is known the ordering of procedures makes this al more difficult to implement and results in less precision in the presence of recursion rosen gives the only method which is precise up to symbolic execution for complex side effects like def and use but the method is much more complicated than the one given here and is probably much slower for and ref and the kinds of language mechanisms considered here it gives no more precise results than the present method at the of a great deal of additional work it may however be capable of handling a range of variable mapping mechanisms t gives a simpler but less precise version of algorithm but does not recognize the possibility of us i ng standard flow analysis techniques also has an extensive discussion of the use of side effect the existence of aliases information neither given rosen nor gives an algorithm for finding aliases and and aho and unman finding the without give ah both present methods side effects which are similar one given here but for languages nesting of procedures neither any that the method can of to be generalized guages techniques or to full block that standard can be applied structured lan flow analysis bar gives a method which is based on forming transitive closures of various relationships the method from a lack the interaction of precision between due to reference the way and scope is handled it also to be much slower for large programs than the present method since its time increases as the of the number of procedures acknowledgments at one time or another f allen j f s b b rosen have made comments about the ideas expressed here or their presentation their help and the help of v is references ah bm bar lm sp aho a v and j d principles of compiler allen f e interprocedural data flow analysis proceedings ifip north holland amsterdam allen f e and schwartz j t determining the data relation in a collection of proce computer science report rc ibm thomas j watson re search center aug j p a method for de the side effects of procedure calls phd thesis stanford university report no stanford linear center aug j a practical procedural data flow analysis al cacm sept graham s l and wegman m a fast and usually linear algorithm for global flow analysis jacm jan m s and j b ideas on the design of a for part i overview and sis computer science technical report tr university of ma college aug park d b data flow analysis in the presence of procedure calls ibm journal of research and m rosen b k for flow analysis computer report watson rc ibm thomas j research center heights march pp rosen b k data flow analysis for procedural languages to appear jacm also computer sci ence report rc ibm thomas j watson research york heights april pp t c side effects in a optimizing com proceedings ence north amsterdam tarjan r e solving path problems on directed graphs report computer science department stanford uni pp unman j d a survey flow analysis techniques of data pro second aug 