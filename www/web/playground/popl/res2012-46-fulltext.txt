a type system for permissions karl robert carnegie mellon university pittsburgh pa usa two new york ny usa abstract in objectoriented programming unique permissions to object references are useful for checking correctness properties such as consistency of typestate and noninterference of concurrency to be usable unique permissions must be for example one must be able to read a unique reference out of a field use it for something and put it back while one can null out the field and later it this paradigm is and requires unnecessary writes potentially cache performance therefore in practice must occur in the type system without requiring memory updates previous systems support with external alias analysis andor explicit programmer management of fractional permissions while these approaches are powerful they are also and difficult for programmers to understand we present an integrated language and type system with unique immutable and shared permissions together with new local permissions that say that a reference may not be stored to the heap our system also includes change permissions such as and that describe how permissions flow in and out of method formal parameters together these features support common patterns of including multiple local permissions from a unique reference and the unique reference when the local permissions go out of scope without any explicit management of in the source language all of fractional permissions is done by the type system under the we present the syntax and static and dynamic semantics of a formal core language and state soundness results we also illustrate the utility and of our design by using it to express several realistic examples categories and subject descriptors d programming languages formal definitions and d programming languages language constructs and features permissions general terms design languages theory verification keywords types permissions uniqueness introduction permissions are annotations on pointer variables that specify how an object may be aliased and which aliases may read or write to the object for example unique indicates an permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright © acm object immutable indicates an object that can be aliased but cannot be and shared indicates an object that may be aliased and can be permission systems have been proposed to address a of software engineering concerns including encapsulation protocol checking safe concurrency security and memory management recently new programming languages have incorporated permissions or related affine types as fundamental parts of the type system in order to permissions in practice programmers must be able to manipulate them effectively one form of manipulation is permission splitting for example converting a unique permission into multiple shared permissions or alternatively into multiple immutable permissions a shared or immutable permission can then be split further into more shared respectively immutable permissions a second important form of manipulation is extracting a permission from a variable field using it and then returning all or part of it to the source for example a method may require an immutable permission to the receiver if we have a unique permission to an object like to call the method on that object and provided the method does not allow an alias to the receiver to escape like to get our unique permission back at the end the permission should not require the original variable which may not even be was originally proposed by however good support for this feature has an open and difficult problem prior typebased systems provided a annotation but they did not support the immutable references that are an essential part of many recent systems a number of systems supported via a program analysis but the program analysis relies on shape analysis which is and difficult for programmers to understand proposed fractional permissions to support splitting and permissions with as a special case but its mathematical fraction abstraction is for programmers to such an extent that the automated tools we know of once again hide the behind an analysis a good facility should have a number of properties it should support a natural programming style eg avoid constructs like replacing field write with a primitive swap operation or a requirement to thread a reference explicitly from one call to the next by the reference each time reasoning abstractions should likewise be natural not it should support from unique immutable and shared variables and fields rules should be local so the programmer can understand them and predict how they operate vs a nonlocal analysis or inference the contribution of this paper is the first approach that meets all of the above properties we provide a type system for a language with permissions that are tracked through local rules our technical approach includes a number of including change permissions that show the incoming and outgoing permissions to a method parameter local permissions that modify shared or immutable permissions to denote that they cannot escape an expressive rule for handling across conditional branches and a way to safely restore permissions to the variable or field from which they were we formalize our type system prove it sound and demonstrate it via a series of examples which can be checked by our prototype implementation we describe the features of the language in the next section section formalizes our type system and gives soundness results we cover additional related work in section and section concludes language features in this section we informally explain the features of our language the next section gives a more formal treatment our language is based on for our purposes is similar to java except · instead of classes uses states this is because has a firstclass notion of typestate which can be used to model object state and transitions between states we dont use typestate in this work but we to the syntax · has a match construct that evaluates an argument and then uses its type to pick which of several cases to execute · has no null value in the surface syntax or semantics instead every object field and variable is initialized to a nonnull object · has a firstclass notion of permissions supporting typestate is one important application of permissions including the novel mechanisms discussed in this work in the rest of this section we first give an overview of the permissions in our language then we explain the mechanisms for creating aliases of variables and fields with consistent permissions then we explain the mechanism of change permissions which allows modular checking of permission flow in and out of methods finally we explain local permissions which provide a way to split a unique permission into several permissions and later them to unique without explicit access permissions permissions are a wellknown way of controlling aliasing in applications such as typestate and concurrency control our permission system is adapted from the access permissions system of an access permission is a tag on an object reference that says how the reference may be used to access the fields of the object it refers to and how aliases of that reference may be created in this work we use the following permissions · a unique permission to object reference o says that this is the only usable copy of o if any alias of o exists then it has permission none the reference may be used to read and write fields of the object o that it points to · a none permission says that the reference may not be used to read or write the object it points to · an immutable permission says that the reference o may be used only for reading and not writing the fields of the object o that it points to further all other usable references to o are guaranteed to be immutable so no aliased reference can be used to write o either available at · a shared permission says that the reference o may be used for reading and writing and there is no restriction on aliases of o so shared is like an ordinary reference in java · a local immutable or local shared permission is like an immutable respectively shared permission except it can only be passed around in local variables and cant be assigned to the heap local permissions are new with this work and are explained further in section if any alias of a unique reference is created then the unique permission must be consumed but it can be to the alias a unique permission is therefore like a linear resource by contrast immutable and shared references may be freely replicated while other access permissions are possible these permissions suffice to illustrate the concepts in this paper further these permissions can express a wide range of computation patterns other permissions could be added to the system without difficulty aliasing variables and fields in contrast to a language like java with unrestricted aliasing a language with access permissions must maintain careful control over how aliases are created we now discuss how our language permissions for aliases of variables and object fields a unique from a variable unique x new s unique y x b unique from one of two variables unique x new s unique y new s unique z match sx sy c taking unique from a variable unique x new s unique y new s unique z x yf z figure examples of variable aliasing aliasing variables in our language the following rules aliasing of local variables our local variables are ie they are assigned to only in their declaration and are declared with explicit permissions so the needed permission is always available on the lefthand side of a variable assignment in typing and assignment we compute all variables and fields such that the value returned by the righthand side of the assignment may be obtained by reading the variable or field because we cant statically resolve which match case will be taken there may be more than one we maintain a typing environment which we call a context with the permission associated with each variable for each possible source variable we make sure there is enough permission in the context to extract the needed permission we use permission splitting rules given formally in the next section to com the permission remaining in the source variables after the extraction and we update the context accordingly at the end of the scope of the variable we restore whatever permission is left in that variable to the source variables for this operation we use permission joining rules which are the reverse of the splitting rules figure shows examples where the definitions of states s and s are as follows state s unique s f new s state s case of s unique s f new s state s case of s here case of is like extends in java and denotes in figure a variable x is declared unique and initialized with a fresh object in line in line variable y is created and takes the unique permission out of x leaving none in x when y goes out of scope in line its unique permission flows back into x figure b is similar except that in line we dont know which variable x or y will be read from at runtime so we take permissions out of both record both as source variables and restore permissions to both at the end of zs scope in line the match statement in lines ­ says to evaluate the selector expression represented as here to an object reference o then evaluate the whole expression to x if the type of o matches s to y if the type of o matches s and to halt if there is no match while this example is simple in general typing match in our language is subtle and requires merging the contexts generated by the different match cases the details are given in section figure c shows an example where the permission read out of x into z is stored into the heap so it cant be returned to x at the end of zs scope a unique from a field unique x new s unique y xf b unique from a variable or field unique x new s unique y new s unique z match sx c taking unique from a field unique x new s unique y new s yf xf figure examples of field aliasing aliasing fields the rules for aliasing of fields are similar to those for aliasing of local variables with two exceptions first a permission out of a field can cause the residual permission to violate the statically declared field permission for example unique out of a field declared unique causes the field to have permission none in this case we say the field is if an object has any fields then we say the object is we must account for the actual permissions when accessing the fields of an object second since fields can be assigned to the reference in the field at the point of permission restore may not be the same reference that the permission from in this case we must be careful not to restore permissions to the wrong reference which would violate soundness fields to address the first issue we store the current permission of each field of each object in the context figure shows examples where s and s are defined as before in figure a line shows the context after taking a unique permission out of xf the notation means that x has unique permission and points to an object with none permission for field f figure b shows how to use the same mechanism from figure to a permission out of either a variable or a field figure c shows an example of taking a unique permission from a field and assigning it to another field to ensure soundness we place three restrictions on field first an object can be via a variable with unique permission but not immutable or shared permission this is so aliases to the object dont become inconsistent our language also allows taking an immutable permission out of a unique field vf given immutable permission to v in this case our type system does not report v as in the context this is sound because once an object is seen with immutable permission it can never become unique again second once an object o stored in variable v is permission to o may not be assigned to another variable or the heap until v is again otherwise we would not be able to track the state of o through vs information in the context for example the following code is not allowed because x is when it is assigned to z unique x new s unique y xf unique z x because x is not third a variable v must be at the point where it goes out of scope in particular method formal parameters must be at the end of a method body that is because the permission stored in v could be back to a different variable that gave its permission to v when v was declared in practice the programmer can with the latter two by carefully the of variables that read permissions from unique fields andor writing fresh objects into the fields to pack the fields at appropriate points while in some cases these writes may not be strictly necessary the requirements do not seem to be in the examples we have studied these restrictions could be relaxed at the cost of additional language complexity for example stating in method signatures which fields of an incoming parameter must be consistent permission restore as an example of the second issue identified above erroneous permission restore consider the following code unique x new s unique y xf xf new s xf xf a permission to xf at the end of ys scope in line would create an alias between xf and xf both with unique permission the problem is that the reference in field xf in line is not the same reference to which permission was taken in line so to it would be wrong to prevent this from the static typing rules maintain an identifier that is updated every time a field goes from to the permission restore occurs only if the identifier at the point of the field access matches the identifier at the point of for example in the code shown above at line where local permissions discussed in section provide an additional way to objects xf is and its permission read into y an identifier i is associated with xf and with y then in line when xf is again xf gets a fresh identifier i in line when y goes out of scope its identifier i does not match the identifier i of the source location xf so permission is not from y into the location thus the identifier mechanism approximates object identity at runtime the approximation is conservative because each assignment is assumed to assign a different object reference even if the same one is actually assigned twice modular checking with change permissions to support modular checking of permission flow across method we introduce a language feature called a change permission change permissions are inspired by and similar to change types in however whereas a change type in says that an object may transition from one state to another to support typestate in our language change permissions specify only that a reference permission changes from a stronger to a weaker permission the object type always further while previous systems can distinguish and consumed permissions at method boundaries change permissions are more flexible because they can record a change to any weaker permission not just none syntactically a change permission looks like where and are permissions change permissions appear on method formal parameters including the implicit parameter this for example a formal parameter can be declared s x where s is a state name this declaration says the caller must ensure that on entry to the method permission is available for the reference o stored in x while the callee must ensure that on exit from the method permission is available for o the permission can also function as a change permission it is shorthand for change permissions naturally support both and uses of unique permissions for example a change permission says that the permission in the parameter value must be unique on entry to the method and the unique permission will be at the end of the method whereas says that a unique permission is taken and not returned for example because it is stored on the heap state cell state cons case of cell immutable data data unique cell next state list unique cell head new cell void data elt unique unique cons new cons with elt unique list list new list data figure list example figure shows an example using written in shorthand form as unique to update a list with unique links line defines a cell state representing an empty list cell lines ­ define a cons cell which is a of cell it has a data field with immutable permission and a next field with unique permission lines and following define the actual list it has a unique cell for its head and a method that accepts an immutable permission in elt and a unique permission in this unique in line represents the change permission associated with this leaves a unique permission in this on exit and returns nothing the comments in lines and show what happens when checking the method body in line this is when the unique permission is taken out of and assigned into in line this is back up when is assigned into lines ­ show how things look from the point of view of a caller of in line list gets a fresh reference with unique permission this unique permission is passed into in line however because of the change permission the permission is on return from the method and list still has unique permission at the end of line note that we could also have the permission by returning a reference from and assigning it back into list but this is and would require assignment into local variables state data immutable data add timestamp this unique list list new list unique data data new data figure publication example figure shows another example this time using a change permission in this example the data class has a method that requires a unique permission to this uses the unique permission to write a time stamp to the object then the object in an immutable state so it can only be read and never written by the rest of the program lines ­ show how this state might be used line creates a fresh data object with unique permission line calls on data changing its permission to immutable line puts the immutable permission into a list notice that since also returns an immutable permission to this we could also have written but using the change permission on variable data makes clear in the client code that the same object is going into and into local permissions an important pattern for access permissions is to divide a unique permission up into several weaker permissions use the weaker permissions for a while and then put all the permissions back together to the original unique doing this requires careful to ensure there are no permissions to the reference other than none at the point where the unique is one way to do this is to use however while powerful are also difficult to use and from modularity problems instead we observe the following · the complexity of solutions arises in large part because they allow permissions to be stored into the heap then taken out of the heap and into unique · a common use of permissions split off from unique is to pass them into methods where they are used in local variables and then returned ie they never go into the heap motivated by these observations we introduce a new kind of permission called a local permission a local permission is des with the keyword local which may modify a shared or immutable permission a local permission a local variable it says that any aliases of the variable created during its lifetime exist only in local variables and are never stored to the heap local permissions are not necessary for unique or none because the permission itself already contains all the information about aliasing to the heap a unique local variable says there is no alias on the heap or anywhere else and a none local variable says it doesnt matter since local permissions exist only in local variables when all the variables that local permissions go out of scope we can the original unique permission local permissions from variables a local permission may be from a variable with unique permission leaving a special permission in the context the permission is used internally for purposes but never appears in the language syntax for example local immutable from a unique variable leaves in the context for that variable this entry says we are local immutable permissions from a unique permission and one alias is again from the same variable increments the counter while joining the counter thus the counter tracks the number of local aliases to the original unique permission when the counter is joining the last local permission unique note that we do this counting only when creating local permissions because in this language immutable or shared permissions are never to unique a local permissions to unique unique x new s local immutable y x immutable local immutable z x immutable immutable b this example does not type check local immutable s s x none local immutable y x immutable y local immutable permission taken here figure local permissions from variables figure a shows an example the counter for x becomes in line when y from it and in line when z from it when z goes out of scope the counter goes back down to and when y goes out of scope x becomes unique again when the counter one as in line we dont to unique yet because there are still aliases notice how the counters in the permissions effectively account for of permissions by counting aliases however these are hidden in the typing and never seen or manipulated by the programmer we must carefully account for local permissions that might escape the current scope otherwise we could not soundly reason that all local permissions are out of scope when the local variables holding them are out of scope figure b shows how we do this in line y takes a local immutable permission from x and line attempts to return the local immutable permission to the caller while the unique permission in x as shown in the signature in line remember that unique x is shorthand for x of course this should not be allowed this example doesnt type check because when y goes out of scope at the end of the method two permissions would have to be and our typing rules dont allow this only a local permission can be with a permission more generally all aliases from a local permission must be before the local permission can be to unique however if the method signature in line said s x then the example would type check because now x have to be to unique to satisfy the parameters change permission state cell int size none state cons case of cell immutable data data unique cell next int size local immutable state list unique cell head new cell int size local immutable unique list list new list data int size figure list size example local permissions from fields our language also allows local permissions from unique fields this is particularly useful when the permission to the object is local otherwise we would need unique permission to the object even to read a unique field of the object and it is well known that this requirement is very restrictive essentially any access to a linear reference must be through a chain of linear references figure shows how this works for a simple example that computes the size of a list with unique references requiring readonly access to the list in line size requires local immutable permission to the list line so local immutable permission is from list as discussed above then put back to unique at the end of the method call inside the size method of list in line this has local immutable permission at the start of the method at the call of local immutable permission is from at that point the context entry for this is saying that this has local immutable permission and points to an object with one local immutable reference from its head field on return from the permissions are put back together to the object the same thing happens in line notice that the ability to local permissions is very useful here without it we would either have to convert the unique to immutable thereby the unique permission to the list to compute its size or we would have to require unique permission to the list for the size computation which is too restrictive one of this mechanism is that it allows multiple local variables that point to the same object to have different information about whether the object is for example consider an object o with a unique field f and two aliases of o x and y where y was created as an alias of x by a local from the unique permission in x this leaves x with the permission local as well which allows us to a local from xf x since the type system does not explicitly track what variables are aliases y remains this is fine because the splitting rules prevent anything other than a local from being out through yf furthermore by the time y leaves scope and x becomes unique again all local aliases to the field f of o must have been returned leaving it unique as well thus it will be safe to a unique permission from xf as allowed by the static rules at runtime we will know that x and y are in fact aliases and do the proper for the permission in field f even when permission are from the field through different aliases more details on this mechanism are given in section formal language in this section we formalize the ideas developed in the previous section we give a syntax static semantics and dynamic semantics for a core language then we state the key soundness results which are proved in our companion technical report syntax figure gives the syntax for the core language a program consists of a number of state declarations s and an expression e to evaluate a state consists of a state name s a parent state s possibly itself and field and method declarations fields f and methods m are declared in the usual way except that field types specify permissions and method parameters specify change permissions fields have expressions the change permission appearing in the method declaration before the method body is the change permission associated with the implicit parameter this the rest of the language features are standard for an objectoriented language the match expression evaluates e to an object reference and compares its runtime state s to the states s named in the cases it executes the first case for which s is a subtype of s with a runtime error if there is no match vf e updates the object in the field vf to the value of e which it also returns as the result of the expression new s creates an object of state s and its fields by running the expressions given in the state definition the sequence expression evaluates each of its subexpressions in order and returns the result of the last one as the value of the whole expression programs states p s e s state s case of s f m fields f t f e methods m t m s x e permissions unique none local immutable shared types t s expressions e let xe in e v vf vf e new s e variables v this x figure core language syntax s f m and x are identifiers static semantics we introduce our static semantics by formalizing the notions of states and permissions we then define the ways that permissions are manipulated and show how the flow of permissions is integrated into the type system states states take the place of standard types in our system figure gives the judgments and rules relating to states p s says a state is valid if it is declared in p p s s says that s is a of s relations are defined by the case of relation from the state definitions and transitivity p s typestate state s case of s f m p p s p s s state s case of s f m p p s s p ss p s s p s s p s s figure valid states and unique local local local n local n none unique local unique unique none figure splitting variable permissions permissions to the set of source permissions we add an additional form needed to track local permissions so they can be back to unique n where n is a natural number the permission appears only in the context for a local variable or field that has had local permissions split from it inside represents the original permission before the first split unique or local represents the kind of local permission immutable or shared and n counts the number of splitting variable permissions the judgment says that if variable v has permission then can be taken out of v leaving in v figure gives the rules for this judgment notice that splits unique into symmetric permissions making it impossible to ever the unique permission in contrast the rules a local permission and leave behind a permission which will be turned back into the original permission when all the local permissions are returned in these rules the count is set to reflect the net gain in local permissions splitting a local from a unique generates a new local so the count starts at from an existing local replaces the original local with a resulting in no net gain in local permissions so the count starts at taking a local from an existing creates a new local and thus increments the count also says we may local out of however we cant get a nonlocal permission out of a local so in conjunction with the field typing rule we cant store local permissions to the heap none local local local unique unique unique local n local figure splitting field permissions unique ¬ figure joining permissions splitting field permissions the judgment says that if variable v has permission and field vf has permission then permission can be taken out of f leaving behind figure gives the rules if the variable permission is unique we can split permissions from the field as if it were a variable possibly the field otherwise we allow splitting in three cases first if the variable permission is not none then we can do any splitting allowed for variables that preserves the original field permission second if the variable permission is then we can take permission out of a unique field vf without the object this is sound because all other references to the object must have permission for the remainder of program execution and so all other accesses will consistently see the field with permission third if the variable permission is local or then we can take a matching local permission out of a field with unique or permission this is sound because all local permissions to the object and to the field must go out of scope before a unique permission to the object can be in the mean time all references to the object and to the field have compatible local or permissions joining permissions the judgment says that permissions and may be to form permission the joining rules given in figure are very simple we just reverse all the variable splitting rules except for which cant be linear context to track permission flow our typing rules use a linear context it is similar to a standard typing environment except that it maps variables to types that include a permission that may change over the course of typing the linear context is defined as follows where i is chosen from an arbitrary set of identifiers v t f i for each variable v in scope stores a type t s and a set containing the state f i of the fields f in the state s a field f i records two pieces of information first indicates the current permission in the field f will only appear in p p v s p v s p v v t p p v v t p p vf i v t f j ij p p vf i v s f i s f s p v s f i p vf i v s f i s f s p v s p vf i figure permissions the predicate is true if no binding for f appears in s f t says that field f is defined in state s with type t in the program p the state of v if is distinct from the declared permission of the field f in the state of v second the object identifier i is used to prevent the of permissions from one object to another object for any v t and field f declared in the state of v if there exists f i then we say the field f of v is otherwise we say the field f of v is by extension if then we say the object pointed to by v or just v is otherwise it is permissions at certain points in the typing permissions flow back into the linear context such as when a variable goes out of scope we restore permissions to a source location list consisting of zero or more elements v vf i each element stores a location to restore to either a variable v or a field vf for fields vf the identifiers i ensure that we restore permissions only to fields that have not been assigned to since the permission was taken out we use a list because match expressions may report different source locations for each case however we do not allow in the list the judgment for permissions is p it says that if we start with context and join permission with the permission in each location in then we get a new context figure gives the rules for this judgment if the next element in the source location list is a variable appearing in the context then we restore the permission to it because we do not check that all of the locations in a source location list remain valid when passed outside of a let scope it is possible that the variable may not be in the context to return to in which case we do nothing when to a field there are several cases to consider if the field is already this means that the permission did not the field left it unchanged or the field was since the permission was so we do nothing if the field is and the merge none v s s v s none v s s v s v s s v s none v s f i s f i v s f i v s s v s none i i v s f i s f i v s f i figure merging contexts in typing match selected rules identifiers in the context and the source location dont match then we also do nothing this occurs when an expression in an inner scope assigns to the field and then later it again meaning the returned permission represents a permission to a different object than is in the field if f is and the identifiers match then there are two cases first if the permission doesnt leave a permission equal to the declared permission for f then we update the state otherwise we pack up the field by removing it from notice we dont consider the case where vf appears in the location list but v doesnt appear in the context why not there are two ways this could happen either vf is returned as the value of the let expression that declares v or vf is returned as the value of a method body where v is this or the method formal parameter in either case v must be after the evaluation of vf rules method in figure and let in figure therefore vf can not appear in the source location list see rule in figure merging contexts each case in a match expression may update the permissions in the context in a different way the merge judgment from figure defines how to combine two contexts into a more general context that can be soundly used to type subsequent expressions regardless of which case is actually executed we provide only the important rules for merging contexts and the rest of the rules are about apart the contexts and comparing elements in summary we use the following rules for merging the two context entries for a variable v if v is in both and then we choose the weaker permission we define to be weaker than if is none or there exists such that if neither permission is weaker than the other then the contexts are inconsistent and typing fails if v is in both contexts then we require it to have the same permission in both and we use the field splitting rules to find the weaker of the two field permissions if the identifier i associated with the field is the same in both contexts then we pass it through but if it is different we generate a fresh identifier this is correct but conservative because it guarantees that no permission restore will occur to the location if v is in only one context then we use the element but we check that the permission for v is weaker than the one otherwise we would have to a permission out of an object which is not allowed in this language expressions permissions are out of the linear context by typing expressions the judgment p e s takes the starting context a needed permission and an expression e that specifies where could be from it produces the state s of the expression an updated context and a source location list that contains all the possible locations in the context that the permission may have been from the exact location is not statically known because which branch of a match expression is executed is determined at runtime figure gives the rules for typing expressions which we now summarize let we use the permission declared for x to type e obtaining state s a context and a source location list then we use the needed permission of the whole expression to type e in the context augmented by the type binding for x this produces an updated context where x is left with permission and a source location list we require that x be because it is going out of scope we restore to the locations that the permission for x may have been from which generates a final context that is returned along with the state and source locations from the body match for a match we type e with a needed permission none yielding some state s and an updated context we the source location lists since returning none is a we ensure that the state s has a common with the state sc named in the case this ensures that sc is a potentially valid state of e using and the needed permission for the entire expression we type e to get the state s and source location list which are reported as the result of the case for a match we recursively check the match with all but the first case then we check the match with the remaining case in isolation using the original context finally we return the the least upper bound of the resulting states the merged contexts and the union of the source location lists from the first case and the remaining cases method invocation we type e in the input context with needed permission yielding a state s and a context next we look up the method named m in state s this gives us the permission required for the argument we use to type e in the context which yields a state s and a context now we check that s to the method parameter state s then we check that needed permission can be extracted from the permission returned by the method we generate the output context by the output permissions specified for the argument and receiver in the method signature to their respective source location lists the outgoing source location list is empty because our system does not track what locations the permissions returned from method calls can come from variables we require that v is because its value may be assigned to another variable or stored on the heap we also check that the existing permission can be split to give the needed is the needed permission for the receiver as determined by the signature of the method m in the state s of the expression e this permission can be determined by a that ignores permissions and just state information for all variables p e s let p e s p x s e s x s p let x e in e s p p none e s sl sc p e s p s p s p s p s s p sc e s invoke p e s p s m s s s m e p s p p e s var v s v s p v s v v s s f s p vf s v s s f s v s f i p vf s vf i v s f i s f s v s f i p vf s vf i v s s f s p e s v s p s s v s p vf e s v s v s f i s f s p e s p s s v s p vf e s new p s p new s s p e s p e s p none e s p e s p e e s figure typing expressions p s s means s is the least state that is a of both s and s s m m means that m is the method named m defined in state s for program p and s f t similarly produces the type t of field f from s in p the predicate holds if is not none immutable local immutable or immutable immutable n means ¬ if i sion and we leave the in the type reported in the outgoing context the source expression list contains only the variable itself field access we start by finding the type of v in the context and then get the defined type of field f in its state s since we are only accessing the field of v we do not update the permission of v however we may need to update the state of f in v if f starts in vs type then there are two cases to handle first if we can take the required permission out of the field and leave the same permission behind then we leave the object the source expression list is empty because no permission needs to be to a field that is second if we need to leave a different residual permission then we the field leaving the residual permission behind we also generate a fresh identifier i and report vf i as the source location list if f is already in v then we split the needed permission from the current field permission and replace the current permission in the field state with the residual permission we report vf i as the source location using the existing identifier i field assignment if vf is then to assign e to it we look in the context to get the permission we need for the field type e check that we have permission to v in the resulting context and check that the states match we also ensure that the permission we need can be split off from the permission needed by the field while the field permission if vf is then we do the same thing but we pack up f at the end in both cases we do not need to return permissions to the source locations of e because left after assigning to vf must be none or symmetric and returning either is a for the same reason the returned source location list is empty object creation and expression sequence these rules are straightforward in notice that we the needed permission only for the last element in the sequence whose value is returned by evaluating the expression we none from the rest of the expressions in the sequence for example if x is unique it is legal to request a unique permission from the expression because unique is only from the last x since returning a none permission is a we can safely discard the source location lists for these expressions toplevel program structure figure gives the rules for typing programs states fields and methods in rule program we type the main expression with a needed permission none because no permission to the result is needed after program execution is complete in rule field we type the expression in the empty environment to ensure that this stored to the heap by a new expression also we require that field types cannot be declared with local permissions permissions are also because they cannot appear in the source this restriction ensures that a local permission is never assigned to the program p s e s sp s p none e s p p p f field t s p s ¬ local p e s p s s p t f e p s p s m state state s case of s f m p f f p f m m p s m p state s case of s f m method p s p s this s x s p e s this s x s p s s p s s m s x e figure programs states fields and methods heap in rule method we check that the return type and parameters are valid we check that the method body types in the context created by binding the method receiver and parameter to their types and that the resulting state is a of the return state we require that the parameter and receiver be in the the output context and also that their permissions in agree with the output permissions given by their change types for simplicity we implicitly overriding andor overloading of fields and methods we also cycles in the inheritance hierarchy and treat the set of states as a forest of trees where a state s is a root if it has itself as a parent dynamic semantics an execution state h e includes a heap h and an expression e heap our model of the heap h is a partial function from object references to object identifiers and from object identifiers to objects the addition of object references provide an additional level of indirection that allows us to explicitly track and reason about different aliases to a single object as in these serve a formal purpose only and are not necessary in an implementation consistent with this indirection the fields of an object df map field names to object references every object reference in domh maps to an object identifier except the special reference null which is used during object initialization h null o o h o h df f o expressions we our expression language to support programs we add object references o as well as the new form as expressions gives computational meaning to splitting a permission of o by creating a new alias to hold the split permission as alias expressions will be substituted for bound variables in let bodies we allow them to appear variables can finally we add a partial let form that keeps track of the scope in which an object reference o is bound e o e let o in e reduction rules we formalize program execution using a small step operational semantics given a program p the reduction rules shown in figure take one execution state to another congruence we specify reduction of subexpressions using an evaluation context e defined below e let xe in e let o in e e e e as usual is a hole that is filled in with the subexpression under evaluation to construct the entire expression being evaluated alias reducing an expression creates a fresh object reference that points to the same object identifier as the original object reference let once the bound expression is reduced to an object reference o we substitute for all occurrences of the bound variable x in the body thus any use of x in the body must create a fresh alias we also keep track of the scope of o by reducing to the partial let form once the body of a partial let has been evaluated to an object reference we remove the scoping annotation match once the selector expression becomes an object reference o we select the first match case if any that is a of the state of o if there is no match then execution gets stuck method invocation once we have object references for the receiver and argument of the method we substitute the method body by let expressions binding the receiver and argument this allows let reduction to handle the substitution and scoping object creation we create a new object identifier o and give its fields the reference null which will be replaced by the proper values after running the expressions we reduce to a sequence expression which each field of the object in turn through a fresh object reference o the final expression in the sequence returns o field access and assignment a field access evaluates to a fresh alias to the object reference the heap associates with the field field assignment replaces the object reference in the field with object reference from evaluating the righthand side it returns a fresh alias of this same reference since we do not use the target of the field read or assignment except to access its field we do not need a new alias to it so we leave the in the target sequence each expression in the sequence is evaluated in order until there are no further expressions at which point the sequence is reduced to the object reference resulting from the reduction of the final expression soundness results in this section we present the main soundness results and supporting definitions for our system our technical report contains the full definitions and proofs typing of dynamic expressions we state and prove soundness in terms of a standard dynamic typing to do this we need rules for typing object references alias expressions and partial lets first we the definition of the linear context to map object references to types we also add entries of the form o to the context which indicate that o returns its permission to the source location when it leaves scope we will also want to be able to return permissions to object references so we extend the definition of source locations to include them o s o o of i p h e h e p h e h e p h ee h ee h ho o o domh h h o o p h h o p h let x o in e h let o in ex h ho o p h let o in o h o o h h ho o p s sj j p s sk p h match o si h ej h h o o o s m s m s x e p h h let in let xo in e h h o o o f o o o o domh h h o o p h h o h h o h h o o o f o h h o o o f o p h o h o state s case of s i si m p o o domh h h o o o p h new s h o p h o h o h ho o p h o e h e figure reduction rules alias o s o s p s o o s o p o s o x dom p x s xf s x s p o s s o s x o x dom p x s xf e s x s p o s e s o s o s o p e s o s o p let o in e s p figure intermediate typing rules the rules for typing partial expressions are found in figure the alias rule says that typing proceeds by typing o like a variable in particular the source location is o a raw object reference o is typed using rule which is also similar to the var rule with two important exceptions first we look in the context to find the return location specified for o this is because we need to maintain the typing after an alias expression steps to an object reference in particular after steps to o typing o should still return o as the source location second the binding for the type of o is removed from the outgoing context to ensure that o is not used later in the program which would break our model of execution where each variable and field is tracked as a separate object reference to type a field read or assignment after an alias has been substituted for the target variable the substitution with a fresh variable x that replaces we give x the type of o from the context when typing the updated expression and then return the resulting outputs with o put back for x in the context and source location list assumes the object reference o is already in the context along with a return location for it after the body is typed the remaining permission to o is to its return location soundness judgments figure shows the soundness judgments for the system p h e s is the toplevel judgment and says that the runtime environment h e is welltyped with respect to a a program p a context and a permission the premises of this judgment are as follows first the context and the heap must map the same set of object references second the incoming context must be able to be partitioned into two distinct parts e to type the expression which produces the outputs of the judgment and f which contains all of the object references stored in fields f in h third three invariants must hold for the context and the heap consistent object permissions consistent object references and distinct fields consistent object permissions the key soundness condition of our system is that for each o the set of references o that point to it must have consistent permissions in this condition captures the meaning of the permissions in our system figure defines this consistency condition the judgment h o forms the list of all the permissions given to object references o that point to o in h the judgment consistent places three requirements on this list if unique appears in the list then it appears only once and all other permissions are none if a n permission appears in the list then the number of local permissions must match the sum of the counts of all permissions in the list and no list may contain both shared and immutable permissions including the local and versions consistent object references object references must also be internally consistent we say that p h o ok if the representation of the object reference o in h is consistent with the type of o in p h e s o o domh o o dom e f p e e s f h distinct fields o domh p h o ok o domh h o consistent p h e s p h o ok f s o s o o o h p s s f of df f sf s f of f sf f p sf sf f f f f p h o ok of s r of s r of h distinct fields o f o h o f o h o dom o o f f h distinct fields figure soundness judgments s f reports the permission for f in if it is recorded there otherwise the declared permission of f in state s the set permissions of the form local and n h o o h h o h o o h o s h o h o consistent none unique consistent l local b m m n ni l i none l b n consistent l local b n none l b consistent figure permission lists and consistent permissions the notation l means that l is a list of permissions with allowed the symbol denotes list concatenation for the representation to be valid we first need the actual states of the object and its fields to be of the states given by the type of o second we do not allow a permission local or n to appear as the permission in a field or as the permission to an object reference that represents a field this maintains our invariant that local permissions never appear in the heap finally we require that any permission that can be from a field f of the state s through o can also be from the permission of the object reference that represents the field in h given the field type of of f in o we say that r of represented by r of if any permission that can be split from of can also be split from r both judgments are formalized in figure distinct fields in order to carry out the typing of a partially evaluated expression we must ensure that no object reference o ever appears both in a field and in the expression being typed or in two different fields in h otherwise typing one location could p p s p p f sp pf p p p p s p s p s s p p p pf p s s f s p s p s s s f s p pf none unique n figure weaker contexts metavariable p consists of v or o and s lists the names of the fields in state s have a nonlocal impact on the permission in the other location that would be difficult to track this invariant is captured formally by the judgment h distinct fields in figure weaker contexts as an expression is evaluated specific paths of execution are chosen reducing the number of possible future execution states consequently the context produced by typing the updated expression gives a more precise view of the states and permissions of locations in the program when compared to the context produced by typing the original expression for instance if from e to e reduces away a match expression then there may be locations that have permissions from them when typing e but not when typing e this leaves more permissions in the resulting context we introduce the weaker relationship between contexts to account for this increase in permissions the judgment p shown in figure states that is weaker than the judgment holds if we can transform into by making specific changes to the state and permission at each location variable or field appearing in both and we allow the type of a location in to be replaced in with a type containing a and a weaker permission none is weaker than any permission otherwise for permission to be weaker than there must exist a single permission that can be from such that the is we also admit the special case where is unique and is a permission this can occur for instance if a field with a permission is in the chosen of a match progress and preservation we use these definitions to state the soundness of our system via standard progress and preservation theorems theorem progress if p h e s then either e o or p h e h e or execution is stuck at a match statement where the matched expression has been evaluated to an object but there is no matching case theorem preservation if p h e s and p h e h e then there exists such that p h e s with p and p s s p r where p r the first condition of preservation requires that the new environment after reduction is still wellformed with the extra restriction that the context generated by typing the old expression e must be weaker than the context produced by typing the updated expression e however this is not strong enough because it does not account for the permissions that were out as a part of typechecking which may be returned to the context later the second condition provides the extra power we need consider the source location list representing all the source locations from which the needed permission was when typing e but that were not used to get when typing e there is potentially more permission at these locations in than in because was not split from them during the typing of e however are we guaranteed that if we restore the permission to these locations in using the judgment defined in figure the resulting context r is still weaker than the second condition of preservation says yes this fact is necessary to prove the weakening condition on from the first condition in some cases such as when is used to reduce a let expression this and other details of the proof of safety are discussed in our technical report related work wadler first introduced the concept of converting a linear unique reference into a nonlinear reference using the let construct other early uniqueness type systems built on his work and added support for as a special annotation such as or while convenient these systems did not support immutable pointers and generally provided weak guarantees multiple pointers could and interfere with one another alias to address this issue using shape analysis to ensure that whenever a unique variable was read all aliases to it were dead or while this approach works well in an analysis tool it is for a type system programmers would have to understand a shape analysis to and fix a type error message the authors of which also uses analysis to support have observed this to be a problem in practice in contrast our system provides a more natural abstraction for reasoning by modeling the flow of permissions through locations in the source proposed fractional permissions as a generalization of that does not require a stack discipline for creating and aliases although have received a lot of attention in the verification community we know of no practical tool support that because programmers find an abstraction instead tools like and provide abstractions including that hide from users but the use of program analysis and theorem provers makes these systems less and more difficult to understand than the type system presented here and later developed a type system that allows unique permissions like our system their system tracks permissions taken out of individual fields using a technique they call however where they use a logic for tracking permissions we use a more linear context to type individual variables one of the authors previously observed the importance of for tracking permissions and presented the first permission type system we are aware of that supports unique and immutable permissions while the technical details are somewhat different the system presented in similar to this system avoids by counting permissions in variable types we propose local permissions to distinguish permissions syntactically as well as none permissions both of which remain implicit in our system additionally supports share permissions match expressions and sequences and our system tracks permissions taken out of individual fields unlike we provide a dynamic semantics and prove our system sound other programming languages have incorporated the ideas of uniqueness and into their type systems but use less flexible or more complicated mechanisms the clean programming language is a functional language with support for unique references however since the language is functional there is no concept of returning permissions to a location as in our system the programming language allows linear unique references to be split into guarded immutable types that are valid in the scope of a key their use of typelevel keys adds notational and algorithmic complexity to the scoping of permissions that we avoid by using our simpler local permissions on the other hand supports adoption a linear permission stored in a field of a nonlinear object can be treated linearly also includes annotations on methods that consume permissions similar to our change permissions however ours are strictly more flexible because in our richer set of permissions we can specify a partial return of a permission eg the language has a feature similar to keys also includes explicit support for through reference counting that is similar to the mechanism that our local permissions however unlike our approach it is exposed to the programmer in the syntax also allows only for permissions stored in local variables field accesses occur via swap which is in contrast we have designed a field mechanism that supports direct field access other recent work on the type system permissions with typestate and uses change types providing some of the expressiveness of our system while this other work can express the publication example from figure it has very limited support for and can only change field values with a swap operation which is for programmers an alternative to is explicitly references from one call to another as supported in alms in this approach the permission is to the reference it is given up when the reference is passed to a function but the function may return the reference again along with a permission this approach is very clear and explicit but it is quite and furthermore results in additional writes when the result reference is to the reference variable overall the system presented in this paper is distinguished by supporting natural programming and reasoning abstractions together with a broad set of permissions including immutable unique and shared as a type system defined by local rules it is easy for programmers to follow and separating permission flow from references makes it more than systems in which references must be explicitly we hope it will serve as a robust foundation for making programming languages such as practical enough for use conclusion and future work we have described a new type system for flexible of unique shared and immutable permissions without explicit as future work we would like to integrate our mechanism with typestate features and gain experience using the type system on larger acknowledgements this material is based upon work supported by the national science foundation under grant foundations of objectoriented languages grant practical typestate verification with reasoning and grant to the computing research association for the project we thank the anonymous reviewers for their helpful feedback references j v and c chambers alias annotations for program understanding in oopsla k automated program verification made symbolic permissions for lightweight automated reasoning in k and j modular typestate checking of aliased objects in oopsla k n e and j practical api protocol checking with access permissions in oopsla b and j confined types in oopsla c r lee and m rinard ownership types for safe pro gramming preventing data races and deadlocks in oopsla j alias unique variables without destructive reads software practice and experience ­ j checking interference with fractional permissions in static analysis symposium j j and w capabilities for sharing a of uniqueness and readonly in ecoop j t and w connecting effects and uniqueness with adoption in popl r and m enforcing highlevel protocols in low level software in pldi r and m for objects in ecoop m and r adoption and focus practical linear types for imperative programming in pldi jy girard linear logic theoretical comp sci ­ d g morrisett t m y wang and j memory management in in pldi d and b copying and on the design of software components trans software engineering ­ may s r leino p and a fractional permissions without the in m g morrisett d and t experience with safe manual in in j islands aliasing protection in objectoriented languages in oopsla r c p a j a and j r the turing language design and definition prenticehall b j p f w and f a powerful sound fast verifier for c and java in formal methods n h towards pointers in ecoop k r j and k a type sys tem for permissions technical report computer science department carnegie mellon university december j j and j flexible alias protection in ecoop springer s e m van and r safe destructive updates through a type system with uniqueness information for graphs in on graph transformations in comp sci volume of lncs springer j a and r practical affine types in popl p wadler linear types can change the world in working conf on programming concepts and methods r r and j gradual typestate in ecoop 