polymorphic functions with settheoretic types part syntax semantics and evaluation xu im luca univ paris paris paris france france state key laboratory of computer science institute of software of sciences de france di informatica di italy abstract this article is the first part of a two series about a calculus with higherorder polymorphic functions recursive types with arrow and product type constructors and settheoretic type connectives union intersection and negation in this first part we define and study the explicitlytyped version of the calculus in which type instantiation is driven by explicit instantiation annotations in particular we define an explicitlytyped calculus with intersection types and an efficient evaluation model for it in the second part presented in a companion paper we define a local type inference system that allows the programmer to omit explicit instantiation annotations and a type reconstruction system that allows the programmer to omit explicit type annotations the work presented in the two provides the theoretical foundations and technical machinery needed to design and implement higherorder polymorphic functional languages for data categories and subject descriptors d programming languages language constructs and keywords types polymorphism xml intersection types introduction the extensible language xml is a current standard format for structured data many recent xml processing languages such as are functional languages however parametric polymorphism an essential feature of such languages is still missing or when present it is in a limited form no higherorder functions no polymorphism for xml types and so on polymorphism for xml has repeatedly been to and discussed in various working groups of standards eg relax ng and higherorder functions have been recently proposed in the wc draft for despite all this interest and a polymorphic type system for xml was still missing for the simple reason that until recently it was a major block to this research ie the definition of a subtyping relation for regular tree types with type variables has been recently lifted by and xu who defined and studied a polymorphic subtyping relation for a type system with recursive product and arrow types and settheoretic type connectives union intersection and negation in this work we present the next logical step of that research that is the definition of a higherorder functional language that takes full advantage of the new capabilities of and system permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm in other words we define and study a calculus with higherorder polymorphic functions and recursive types with union intersection and negation connectives the approach is thus general and as such goes well beyond the simple application to xml processing languages as a matter of facts our motivating example developed all along this paper does not involve xml but looks like a rather classic display of functional programming map map f l case l of x xs f x map f xs even int bool int int even x case x of int x mod x the first function is the classic map function defined in haskell we just used letters to denote type variables the second would be an haskell function were it not for two its type contains type connectives type intersection and type difference and the pattern in the case expression is a type meaning that it matches all values returned by the matched expression that have that type so what does the even function do it checks whether its argument is an integer if it is so it returns whether the integer is even or not otherwise it returns its argument as it received it although even may be considered as bad programming it is a perfect minimal example to illustrate all the aspects of our system the goal of this work is to define a calculus and a type system that can pass three tests the first test is that it can define the two functions above the second harder test is that the type system must be able to verify that these functions have the types declared in their signatures that map has the declared type will come as no in practice in the second part of this work we show that in the absence of a signature given by the programmer the system can a type slightly more precise than this that even was given an intersection type means that it must have all the types that form the intersection so it must be a function that when applied to an integer it returns a boolean and that when applied to an argument of a type that does not contain any integer it returns a result of the same type in other terms even is a polymorphic dynamically bounded overloaded function the third test the one is that the type system must be able to infer the type of the partial application of map to even and the inferred type must be equivalent to the following one map even int bool int int int since map even returns a function that when applied to a list of integers it returns a list of booleans when applied to a list that this type is redundant since the first type of the intersection is an instance eg for int of the third we included it for the sake of the presentation does not contain any integer then it returns a list of the same type actually the same list and when it is applied to a list that may contain some integers eg a list of reals then it returns a list of the same type without the integers but with some booleans instead in the case of reals a list with booleans and reals that are not integers technically speaking the definition of such a calculus and its type system is difficult for two distinct reasons first for the reasons we explain in the next section it demands to define an explicitly typed calculus with intersection types a task that despite many attempts in the last years still a satisfactory definition second even if working with an explicitly typed setting may seem simpler the system needs to solve local type inference namely the problem of checking whether the types of a function and of its argument can be made compatible and if so of inferring the type of their result as we did for the difficulty once more mainly in the presence of the intersection types a term can be given different types either by subsumption the term is into a supertype of its type or by instantiation the term is used as a particular instance of its polymorphic type and it is typed by the intersection of all these types therefore in this setting the problem is not just to find a substitution that the domain type of the function with the type of its argument but rather a set of substitutions that produce instances whose intersections are in the right subtyping relation our map even example should already have given a idea of how difficult this is the presentation of our work is split in two parts accordingly in the first part this paper we show how to solve the problem of defining an explicitlytyped calculus with intersection types and how to efficiently evaluate it in the second part the companion paper we will show how to solve the problem of local type inference for a calculus with intersection types in the next section we outline the various problems we met focusing on those that concern the part of the work presented in this paper and how they were solved problems and overview of the solution the driver of this work is the definition of an xml processing functional language with polymorphic functions that is in particular a polymorphic version of the language in a the essence of is a calculus with pairs explicitlytyped recursive functions and a typecase expression types can be recursively defined and include the arrow and product type constructors and the intersection union and negation type connectives in summary they are the regular trees generated by the following productions t b t t t × t t t t t where b ranges over basic types eg int bool and and respectively denote the empty that types no value and top that types all values types we use possibly indexed metavariables s and t to range over types coinduction accounts for recursive types we use the standard convention that infix connectives have a priority higher than constructors and lower than prefix connectives from a strictly practical viewpoint recursive types products and type connectives are used to encode regular tree types which existing xml while for what concerns expressions the typecase is an abstraction of pattern matching this uses regular expression patterns on types to define powerful and highly optimized capture primitives for xml data we there are different definitions for local type inference here we use it with the meaning of finding the type of an expression in which not all type annotations are specified this is the used in scala where type parameters for polymorphic methods can be omitted in our specific problem we will omit and thus infer the annotations that specify how function and argument types can be made compatible initially focus on the functional core and products and recursive functions since the results presented here can be easily extended to them we show it in the electronic appendix available at though we will freely use them for our examples so we initially consider the following terms e c x ee ii xe et e e where c ranges over constants eg true false which are values of basic types we use bc to denote the basic type of the constant c x ranges over expression variables et e e denotes the typecase expression that evaluates either e or e according to whether the value returned by e if any is of type t or not ii xe is a value of type ii si ti that denotes the function of parameter x and body e in this work we show how to define the polymorphic extension of this calculus which can then be easily extended to a polymorphic functional language for processing xml documents but before let us explain the two of the terms in namely why a typecase expression is included and why we explicitly annotate whole abstractions with an intersection of arrow types rather than just their parameters the reasons for including a typecase in the terms of the calculus are detailed in in short intersection types are used to type overloaded functions and without a typecase only coherent overloading à la can be defined which in our setting for instance the definition of a non function of type also in our system the relation ss tt is in general strict and the functions that are in the difference of these two types are those that distinguish non coherent overloading from coherent one to this difference we need real overloaded functions that execute different code according to the type of their input the need of typecase expressions the need of explicitly typed functions is a direct consequence of the introduction of the typecase because without explicit typing we can run into such as int true a recursively defined constant function that has type int if and only if it does not have type int in order to decide whether the function above is welltyped or not we must explicitly give a type to it for instance the function is welltyped if it is explicitly assigned the type this shows both that functions must be explicitly typed and that specifying not only the type of parameters but also the type of the result is strictly more expressive as more terms can be typed in summary we need to define an explicitly typed language with intersection types this is a difficult problem for which no solution yet there exist only few intersection type systems with explicitly typed terms and none of them is completely satisfactory see section on related work to give an idea of why this is difficult imagine we adopt for functions a notation as and consider the following switch function xt xint true that when applied to an int returns true and returns otherwise intuitively we want to assign to this function the type the type of a function that when applied to an int returns a bool and when applied to a value which is not an int returns an int for the sake of presentation let us say that we are to deduce for the function above the less precise type which is a supertype of the former since if a function maps anything that is not an int into an has type then in particular it maps booleans to integers ie it has also type the problem is to determine which type we should use for t in the switch function above if we use say then under the hypothesis that x the type for the body of the function is so the best type we can give to the switch function is which is far less precise than the intersection type as it does not make any distinction between arguments of type int and those of type bool the solution which was introduced by is to explicitly type by an intersection type whole abstractions instead of just their parameters xint true in doing so we also explicitly define the result type of functions which as we have just seen increases the expressiveness of the calculus thus the general form of abstractions is as stated by the grammar in ii xe such a term is well typed if for all i i from the hypothesis that x has type si it is possible to deduce that e has type ti unfortunately with polymorphic types this simple solution introduced by no longer suffices polymorphic extension the of this work is to allow type variables ranged over by letters to occur in the types in and thus in the types labeling abstractions in it becomes thus possible to define the polymorphic identity function as xx while classic term can be written as the intended meaning of using a type variable such as is that a welltyped abstraction not only has the type specified in its label and by subsumption all its but also all the types obtained by instantiating the type variables occurring in the label so xx has not only type but also for example by subsumption the types the type of all functions which is a supertype of and since every welltyped abstraction is not an integer then contains ie is a supertype of all function types and by instantiation the types etc the use of instantiation in combination with intersection types has consequences for if a term has two distinct types then it has also their intersection type eg xx has type in the monomorphic case a term can have distinct types only by subsumption and thus intersection types are assigned to terms via subsumption but in the polymorphic case this is no longer possible a term can be typed by the intersection of two distinct instances of its polymorphic type which in general are not in any subtyping relation with the latter for instance is neither a subtype of nor vice versa since the subtyping relation must hold for all possible instantiations of and there are infinitely many instances of that are neither a subtype nor a supertype of explicit instantiation concretely if we want to apply the polymorphic identity xx to say then the particular instance obtained by the int denoting the replacement of every occurrence of by int must be used that is we have thus to the type of abstractions before applying them in implicitly typed languages such as ml the is no type is used in terms while in their explicitlytyped counterparts can be seen as a logically meaningful but computationally useless operation as execution takes place on type ie the terms obtained by all type in the presence of typecase expressions however is necessary since the label of a abstraction determines its type testing whether an expression has type say should succeed for the application of to and fail for its application to true this means that in reynolds terminology our terms have an meaning that is to say the semantics of a term depends on its typing if we need to some function then it may be necessary to also its body as by the following though welltyped definition of the identity function if we want to apply this function to say then we have first to it by applying the substitution int however applying the only to the outer does not suffice since the application of to reduces to y which is not welltyped it is not possible to deduce the type for y which is the constant function that always returns although it is the of a welltyped application the solution is to apply the also to the body of the function here what to the body means is straightforward apply the same int to the body this yields a which is well typed in general however the way to perform a of the body of a function is not so straightforward and clearly defined since two different problems may arise i it may be necessary to apply more than a single and ii the of the body may depend on the dynamic type of the actual argument of the function both problems are better known as or are instances of the problem of determining for intersection type systems next we discuss each problem in detail multiple substitutions first of all notice that we may need to functions not only when they are applied but also when they are used as arguments for instance consider a function that expects arguments of type it is clear that we can apply it to the identity function xx since the identity function has type it by an integer and it will return an integer before though we have to the latter by the substitution int yielding as the identity xx has type so it has type and therefore the intersection of the two so we can apply a function that expects an argument of this intersection type to our identity function the problem is now how to xx intuitively we have to apply two distinct typesubstitutions int and bool to the label of the abstraction and replace it by the intersection of the two instances this corresponds to the polymorphic identity from xx into this is the solution adopted by this work where we manipulate sets of typesubstitutions delimited by square brackets the application of such a set eg in the previous example int bool to a type t returns the intersection of all types obtained by applying each substitution in the set to t eg in the example thus the first problem has an easy solution of function bodies the second problem is much harder and concerns the of the body of a function while the naive solution consisting of propagating the application of typesubstitutions to the bodies of functions works for single typesubstitutions in general it fails for sets of typesubstitutions this can be seen by considering the via the set of typesubstitutions int bool of the function in if we apply the naive solution this yields which is not well typed that this term is not well typed is clear if we try applying it to say the application of a function of type to an int should have type int but here it reduces to and there is no way to deduce the intersection type for the constant function y but we can also directly verify that it is not well typed by trying typing the function in this corresponds to prove that under the hypothesis x int the by convention a type variable is introduced by the outermost in which it occurs and this implicitly binds all inner occurrences of the variable for instance all the s in the term are the same while in a term such as the variables in the function are distinct from those in its argument and thus can be converted separately as term has type int and that under the hypothesis x bool this same term has type bool both checks fail because in both cases is illtyped it neither has type when nor has it type when xint this example shows that in order to ensure that yields welltyped terms the of the body must change according to the type of the value the parameter x is bound to more precisely yx should be as when x is of type int and as when x is of type bool an example of this same problem less artificial than our function is given by the classic apply function x which with our polymorphic type annotations is written as f xf x the apply function in has type obtained by instantiating its type annotation by the substitution int int as well as type obtained by the substitution bool bool if we want to this function to another function that expects arguments whose type is the intersections of these two types then we have to it by using the set of typesubstitutions int int bool bool but once more it is easy to verify that the naive solution that consists in propagating the application of the set of typesubstitutions down to the body of the function yields an illtyped expression this second problem is the for the definition of an explicitly typed calculus with intersection types most of the solutions found in the literature rely on the duplication of lambda terms andor typing derivations while other calculi such as that aim at avoiding such duplication obtain it by adding new expressions and new syntax for types see related work in section but none of them is able to produce an explicitlytyped calculus with intersection types as we do by just adding annotations to abstractions our solution here we introduce a new technique that consists in performing a lazy of the bodies this is obtained by abstractions by sets of typesubstitutions for example in order to pass our identity function to a function that expects arguments of type we first it as follows x the new annotation in the outer indicates that the function must be and therefore that we are using the particular instance whose type is the one in the interface ie to which we apply the set of typesubstitutions the will be actually prop to the body of the function at the moment of the reduction only if and when the function is applied is thus lazy however the new annotation is statically used by the type system to check soundness notice that unlike existing solutions we preserve the structure of terms at the of some extra annotation that is propagated during the reduction which is of the importance in a study in this paper we focus on the study of the calculus with these lazy typesubstitutions annotations we avoid the problem of local type inference by defining a calculus with explicit sets of type substitutions expressions will be explicitly annotated with appropriate sets of typesubstitutions polymorphic from a practical point of view however it is important to that at the end these annotations will be to the programmer and as we show in the second part presented in the companion paper all the necessary typesubstitutions will be inferred statically in practice the programmer will program in the language defined by grammar but where the types that annotate s may contain type variables that is the polymorphic version of the problem of inferring explicit sets of typesubstitutions to annotate the polymorphic version of the expressions in is the topic of the second part of this work presented in the companion paper for the time being simply notice that the language defined by and extended with type variables passes our first test as the even function can be defined as follows where st is syntactic sugar for xint x mod x while with the products and recursive functions described in the electronic appendix map is defined as see also discussion in appendix e f nil nil f mf where the type nil tested in the typecase denotes the singleton type that contains just the constant nil and denotes the type that is the least solution of x x nil when by any expression of this language the type infer ence system defined in the companion paper will infer sets of typesubstitutions and insert them into the expression to make it well typed if possible of course for example for the application of the terms defining map to even the inference system of the companion paper infers the following set of typesubstitutions int int int and inserts it between the two terms so that the typesubstitutions apply to the type variables of map yielding the typing in fi as we explain in section later on the compiler will com the expression into an expression of an intermediate language that can be evaluated as efficiently as the monomorphic calculus outline the rest of the presentation proceeds as follows in section we define and study our calculus with explicit typesubstitutions we define its syntax its operational semantics and its type system we prove that the type system is sound and subsumes classic intersection type systems in section we define an algorithm for type inference and prove that it is sound complete and terminating in section we show that the addition of typesubstitutions has in practice no impact on the efficiency of the evaluation since the calculus can be compiled into an intermediate language that executes as efficiently as monomorphic section presents related work and in section we conclude our presentation in the rest of the presentation we will focus on the intuition and try to avoid as many technical details as possible we dot the is and cross the ts in the electronic appendix available online at where all formal definitions and complete proofs of properties can be found nb references in the text starting by letters eg definition a refer to this appendix all these as well as other details can also be found in the third authors phd thesis manuscript contributions the overall contribution of our work is the definition of a core language with i polymorphic higherorder functions for a type system with recursive types and union intersection and negation type connectives ii an efficient evaluation model iii local type inference for application and iv a limited form of type reconstruction the main contribution of this first part of the work is the definition of an explicitlytyped calculus actually a family of calculi with intersection and union and negation types and of its efficient evaluation via the compilation into an intermediate language from a syntactic viewpoint our solution is a minimal extension since it just requires to add annotations to abstractions of the untyped calculus cf section although this problem has been studied for over years no existing solution proposes such a minimal extension which is of importance in a programming study see related works in section the technical contributions are the definition of an explicitly typed calculus with intersection types the proof that it subsumes existing intersection type systems the soundness of its type system the definition of a sound complete and terminating algorithm for type inference which as yields an intersection type proof system satisfying the isomorphism the definition of a compilation technique into an intermediate language that can be evaluated as efficiently as the monomorphic one its extension to the so called and the proof of the adequacy of the compilation local type inference for application and type reconstruction are studied in the second part of this work presented in the companion paper a calculus with explicit typesubstitutions the types of the calculus are those in the grammar to which we add type variables ranged over by and for the sake of presentation of product types in summary types are the regular trees generated by t b t t t t t t and such that every infinite branch contains infinitely many occur of type constructors we use t to denote the set of all types the condition on infinite branches out types such as t t t which does not carry any information about the set denoted by the type or t which cannot represent any set it also ensures that the binary relation t defined by t t ti t t ti t is that is strongly normalizing this gives an induction principle on t that we will use without any further explicit reference to the relation we use to denote the set of type variables occurring in a type t see definition a a type t is said to be ground or closed if and only if is empty the subtyping relation for the types in t is the one defined by and xu for this work it suffices to consider that ground types are interpreted as sets of values nb just values not expressions that have that type and subtyping is set containment ie a ground type s is a subtype of a ground type t if and only if t contains all the values of type s in particular st contains all abstractions that when applied to a value of type s if they return a result then this result is of type t so is the set of all functions and is the set of functions that diverge on all arguments type connectives union intersection negation are interpreted as the corresponding settheoretic operators and subtyping is set containment for what concerns types ie types with variables occurring in them all the reader needs to know for this work is that the subtyping relation of and xu is preserved by typesubstitutions namely if s t then s t for every the converse does not hold in general while it holds for semantic typesubstitutions in convex models see two types are equivalent if they denote the same set of values that is if they are subtype one of each other type equivalence is denoted by an important property of this system we will often use is that every type is equivalent to and can be effectively transformed into a type in disjunctive normal form that is a union of uniform intersections of literals a literal is either an arrow or a basic type or a type variable or their an intersection is uniform if all the literals have the same constructor that is either it is an intersection of arrows type variables and their or it is an intersection of basic types type variables and their in summary a disjunctive normal form is a union of whose form is either bp q or pp nn qp rn q pp nn qp rn when either p or n is not empty we call the variables qs and rs the toplevel variables of the normal form expressions expressions are derived from those of with type variables in types with the addition that sets of explicit type substitutions ranged over by may be applied to terms and abstractions e c x ee ii j jj xe et e e ej jj and with the restriction that the type tested in typecase expressions a abstraction ii j jj xe interface of the function and the the of the function we set we write ii xe for short when the is a singleton containing the empty substitution let e be an expression we use fve and respectively to denote the sets of free expression variables and bound expressions variables of the expression e we use to denote the set of type variables occurring in e see definition a as we assume bound expression variables to be pair distinct and distinct from any free expression variable occur ring in the expressions under consideration we expressions up to the renaming of their bound expression variables in particular when substituting an expression e for a variable y in an expression e see definition a we assume that the bound variables of e are distinct from the bound and free variables of e to avoid captures for example is equivalent to the situation is a bit more complex for type variables as we do not have an explicit binder for them intuitively a type variable can be converted if it is a polymorphic one that is if it can be for example is equivalent to by dec for example ring in the interface of the and the whole expression is equivalent to it if a type variable is instantiated such a bound by variable an outer is called monomorphic for example the following expression is not sound ie it cannot be typed because is bound at the level of the outer abstraction not at level of the inner one consequently in this expression is monomorphic for the inner abstraction but polymorphic for the outer one strictly speaking thus the monomorphic and polymorphic apply to occurrences of variables rather than variables themselves monomorphic type variables cannot be converted is not equivalent to but it is equivalent to note that the scope of polymorphic variables may include some typesubstitutions iii for example is equivalent to finally we have to be careful when performing expression substitutions and typesubstitutions to avoid of polymorphic variable for example substituting zz for y in xx y would lead to an capture of assuming is polymorphic that is not bound by a abstraction placed above these two expressions so we have to convert one of them so that the result of the substitution is for instance xx zz to resume we assume polymorphic variables to be pairwise distinct and distinct from any monomorphic variable in the expres e t tt e t e tt e t ee t ii j jj xe x ej ii jj var x x case e t t t t e s e s et e e s inst e t e t ii j j inter j j ej tj j ej jj tj jj figure static semantics sions under consideration we expressions up to renaming of their polymorphic variables in particular when substituting an expression e for a variable x in an expression e we suppose the polymorphic type variables of e to be distinct from the monomorphic and polymorphic type variables of e thus avoiding captures detailed definitions are given in appendix a in order to define both static and dynamic semantics for the expressions above we need to define the operation which takes an expression e and a set of typesubstitutions and pushes to all outermost abstractions occurring in e and collects and with the sets of typesubstitutions it meets precisely is defined for abstractions and inductively for applications of typesubstitutions as ii k kk j j def j jj k kk j jj def ej jj iii where denotes the pairwise composition of all substitutions of the two sets see definition a it the set of typesubstitutions when e is a variable and it is applied on the remaining expressions see definition a operational semantics the dynamic semantics is given by the following three notions of reduction where v ranges over values that is constants and abstractions applied by a strategy ej jj ej jj ii j jj vt e e ej jp vx ee where in we have p def jj ii v the first rule performs that is it propagates the sets of typesubstitutions down into the of the outermost abstractions the second rule states the semantics of applications this is standard callbyvalue reduction with the difference that the substitution of the argument for the parameter is performed on the body of the function notice that depends on the type of the argument and keeps only those substitutions that make the type of the argument v match at least one of the input types defined in the interface of the function ie the set p which contains all substitutions j such that the argument v has type for some i in i the type system will ensure that p is never empty for instance take the identity function instantiate it as in by both int and bool and substitution finally the third rule checks whether the value returned by the expression in the typecase matches the specified type and selects the branch accordingly the reader may think that defining a functional language in which each reduction must perform an involved op interesting though it may be will result in practice too costly and therefore this is not so in sec tion we show that this reduction can be implemented as as in by a smart definition of closures it is pos to compute in a lazy way and it only in a very specific case for the reduction of the typecase ie to perform a typecase reduction where the value v is a func tion whose interface contains monomorphic type variables and it is the result of the partial application of a polymorphic function while all other reductions for applications can be implemented as plain classic reduction for instance to evaluate the expressions xx above we can completely and perform a of standard reductions that yield the result type system as expected in a calculus with a typecase expression the dynamic semantics depends on the static semantics precisely on the typing of values the static semantics of our calculus is defined in figure the judgments are of the form e t where e is an expression t a type a type environment ie a finite mapping from expression variables to types and a finite set of type variables the latter is the set of all monomorphic type variables that is the variables that occur in the type of some outer abstraction and as such cannot be instantiated it must contain all the type variables occurring in the rules for application and subsumption are standard in the latter the subtyping relation is the one defined in we just omitted the rule for constants which states that c has type bc the rule for abstractions applies each substitution specified in the to each arrow type in the interface adds all the variables occurring in these types to the set of monomorphic type variables and checks whether the function has all the resulting types namely it checks that for every possible input type the body has the corresponding output type to that end it applies each substitution j in the to each input type ti of the interface and checks that under the hypothesis that x has type the function body with the substitution j at issue has type notice that all these checks are performed under the same updated set of monomorphic type variables that is if the test succeeds then the rule infers for the function the type obtained by applying the set of substitutions of the to the type of the interface for example in the case of the instance of the identity function given in the is always empty and the rule checks whether under the hypothesis x int ie x int it is possible to deduce that has type int ie that int and similarly for the substitution bool the type for the function is then int int bool bool the of the body in the premises of the rule is a key mechanism of the type system had we used ej instead of ej in the premises of the rule the expression could not be typed the reason is that ej is more on typing than ej since the well typing of e is necessary to the of the former but not to that of the latter indeed while under the hypothesis x int we just showed that ie is welltyped the term is not for yx does not have type the rule for abstractions also the need for an explicit set for monomorphic type variables while for instance in ml it suffices to consider monomorphic type variables that occur in the image of when checking an arrow of the interface of a function the variables occurring in the other arrows must be considered monomorphic too to type the applications of a set of typesubstitutions to an expression two different rules are used according to whether the set contains one or more than one substitution when a single substitution is specified the rule inst the type according to the specified substitution provided that does not substitute variables in ie dom noted if more than one substitution is specified then the rule inter them by an intersection finally the case rule first infers the type t of the expression whose type is tested then the type of each branch ei is checked only if there is a that the branch can be selected here the use of is subtle but crucial it allows us to existentially quantify over typesubstitutions the branch say e can be selected and therefore its must be checked only if e can return a value that is in t but in order to cover all possible cases we must also consider the case in which the type of e is instantiated as a consequence of an outer application a typical usage pattern followed also by our even function is x xint e e the branch e is selected only if the function is applied to a value of type int that is if the type of x is instantiated to int notice that when typing the body of the function contains only more generally the branch e in et e e can be selected only if e can return a value in t that is to say if there exists a substitution for any type variables even those in such as the intersection of t and t is not empty t is a closed so t t therefore in order to achieve maximum precision the rule case must check e s only if there exists such that tt since t strictly implies that for all substitutions recall that t is a closed type then by the the existence of a substitution such that t implies the latter is equivalent to t t the intersection of t and t is not empty so we slightly the test of selection and check the type of e under the weaker hypothesis tt which ensures that the typing will hold also under the stronger and hypothesis that there exists such that t t the difference only with some specific cases involving types see notice that explicit typesubstitutions are only needed to type applications of polymorphic functions since no such application occurs in the bodies of map and even as defined in section the m and f inside the body of map are abstracted variables and thus have monomorphic types then they can be typed by this system as they are as long as they are not applied one to the other there is no need to infer any set of typesubstitutions so we can already see that our language passes the second test namely that map and even have the types declared in their signatures let us detail just the most interesting case that is the typing of the term even defined in equation even though the typing of the typecase in the term defining map is interesting as well according to the rule we have to check that under the hypothesis xint the expression xint x mod x has type bool and that under the hypothesis x int the same expression has type int so we have two distinct applications of the case rule in one x is of type int thus the check int int fails and therefore only the first branch x mod is type checked the second is since under the hypothesis x int the expression x mod has type bool then so has the whole typecase expression in the other application of case x is of type int so the test int clearly fails and only the second branch is checked the first is since this second branch is x then the whole typecase expression has type int as expected this example shows two important aspects of our typing rules first it shows the importance of to record monomorphic variables since it may contain some variables that do not occur in for instance when typing the first branch of even the type environment contains only x int but is and this to consider as polymorphic if we allowed to instantiate any variable that does not occur in then the term obtained from the even function by replacing the first branch by would be welltyped which is wrong since is monomorphic in the body of even second this example shows why if in some application of the case rule a branch is not checked then the type checking of the whole typecase expression must not necessarily fail the of this branch may be checked under different hypothesis typically when occurring in the body of an overloaded function the reader can refer to section of for a more detailed discussion on this point finally notice that the rule makes the type system dependent on the subtyping relation defined in it is important not to the subtyping relation of our system which denotes semantic subtyping ie settheoretic inclusion of denotations with the one typically used in the type reconstruction systems for ml which stands for type variable instantiation for example in ml we have int int because int int is an instance of but this is not true in our system as the relation must hold for every possible instantiation of thus in particular for equal to bool in the companion paper we define the preorder which includes the type variable instantiation of the preorder typically used for ml so any direct comparison with constraint systems for ml types should focus on rather than and it can be found in the companion paper type soundness subject reduction and progress properties hold for this system theorem subject reduction for every term e and type t if e t and e e then e t theorem progress let e be a welltyped closed term if e is not a value then there exists a term e such that e e the proofs of both theorems though are rather long and technical and can be found in appendix b they allow us to conclude that the type system is sound corollary type soundness let e be a welltyped closed expression that is e t for some t then either e diverges or it returns a value of type t expressing intersection type systems we can now state the first theoretical contribution of our work consider the of our calculus in which typesubstitutions occur only in and without constants and from a programming language point of view it is important to check that during type checking every branch of a given typecase expression is checked ie it can be selected at least once this corresponds to checking the absence of redundant cases in pattern matching we omitted this check since it is not necessary for formal development a x x a e t j a ej jj tj a e t a e s t a ee t · s s jj si j ii j j ii jj a e a t et e a e e s s tt a e a t et e a e e s s a e t a e s a e s a et e e s s tt figure typing algorithm typecase expressions that is e x ee ii j jj xe and whose types are inductively produced by the grammar t t t t t this calculus is closed with respect to reduction as defined by the reduction rule without union and negation types are not needed it an explicitlytyped calculus with intersection types whose expressive power subsumes that of classic intersection type systems without an universal element of course as expressed by the following theorem theorem let denote in the barendregt and system and e be the pure calculus term obtained from e by all types occurring in it if m t then e such that e t and e m therefore this solves a open problem that is the definition of explicit type annotations for terms in in type systems without any further syntactic modification see section on related work for an extensive comparison the proof of theorem is constructive cf appendix b therefore we can decidability results of intersection type systems to our system in particular type reconstruction for the sub calculus is undecidable and this implies the undecidability of type reconstruction for the whole calculus without recursive types with recursive types type reconstruction is trivially decidable since every term can be typed by the recursive type in section we prove that type inference for our system is able the problem of typesubstitutions ie given a term of grammar deciding whether it is possible to add sets of typesubstitutions in it so that it becomes a welltyped term of our calculus is dealt with in the companion paper to compare with existing intersection type systems the calculus in includes neither nor expressions of the form while it is clear that increase the expressive power of the calculus one may whether the same is true for this is not so as expressions are redundant consider the whose terms are e x ee ii j jj xe et e e that is the calculus in which sets of typesubstitutions appear only in consider the embedding of our calculus into this defined as as the identity for variables and as its propagation for all the other expressions then it is easy to prove the following theorem theorem for every welltyped expression e e v e v e v e v and v v meaning that the defined above is equivalent to the full calculus although expressions of the form do not bring any further expressive power they play a crucial role in local type inference which is why we included them in our calculus as we explain in details in the companion paper for local type inference we need to sets of typesubstitutions that are applied to expressions but we must not sets of typesubstitutions that are of expressions the reason is pragmatic and can be shown by considering the following two terms xx and x every functional programmer will agree that the first expression must be considered welltyped while the second must not for the simple reason that the constant function x does not have type indeed in the first case it is possible to apply a set of typesubstitutions that makes the term well typed namely while no such application exists for the second term however if we allowed reconstruction also for then the second term could be made well typed by adding the following typing algorithm the rules in figure do not describe a typing algorithm since they are not syntax directed as the problem is the subsumption rule and the way to go is to eliminate this rule by embedding appropriate checks of the subtyping relation into the rules that need it this results in the system formed by the rules of figure this system is algorithmic as by a in every case at most one rule applies either because of the syntax of the term or because of mutually exclusive side conditions subsumption is no longer present and instead subtype checking has been pushed in all the remaining rules the rule for has been split in three rules plus a fourth rule we omitted that states that when e ie it is the provably expression then the whole typecase expression has type according to whether one or both branches can be selected here the only modification is in the case where both branches can be selected in the rule case in figure the types of the two branches were subsumed to a common type s while returns the least upper bound ie the union of the two types the rule for abstractions a minor modification with respect to the types returned for the body which before were subsumed to the type declared in the interface while now the subtyping relation is explicitly checked the elimination of the subsumption yields a simplification in typing the application of typesubstitutions since in the system of figure without subsumption every premise of an inter rule is the consequence of an inst rule the two rules can thus be merged into a single one yielding the rule see appendix c and in particular theorem c as expected the core of the typing algorithm is the rule for application in the system of figure in order to apply the rule the type of the function had to be subsumed to an arrow type and the type of the argument had to be subsumed to the domain of that arrow type then the codomain of the arrow is taken to type the application in the algorithmic rule this is done by the type · which is formally defined as follows t · s def t su in words if t is the type of the function and s the type of the argument this operator looks for the smallest arrow type larger than t and with domain s and it returns its codomain more precisely when typing ee the rule checks that the type t of e is a functional one ie t it also checks that the type s of e is a subtype of the domain of t denoted by because t is not necessarily an arrow type in general it is equivalent to a disjunctive normal form like the one of equation in section the definition of the domain is not immediate the domain of a function whose type is an intersection of arrows and negation of arrows is the union of the domains of all positive literals for instance the domain of a function of type is int bool since it can be equally applied to integer or boolean arguments while the domain of even as defined in is int int that is int the domain of a union of functional types is the intersection of each domain for instance an expression of type ss tt will return either a function of type ss or a function of type tt so this expression can be applied quantified so the definition of the domain must hold also when their intersection is finally the type returned in is t · s which we recall is the smallest result type that can be obtained by t to an arrow type compatible with s we can prove that for every type t such that t and type s such that s the type t · s exists and can be effectively computed see lemma c the algorithmic system is sound and complete with respect to the type system of figure and satisfies the minimum typing property see appendix c for the proofs theorem soundness if a e t then e t theorem completeness if e t then there exists a type s such that a e s and s t corollary minimum typing if a e t then t e s finally it is quite easy to prove that type inference is decidable it suffices to observe that the algorithmic rules strictly reduce the size of the expressions theorem termination let e be an expression then the type inference algorithm for e terminates this system a further theoretical contribution of our work since with this type system the language defined by grammar the one by grammar and a the one by grammar are intersection type systems that all satisfy the isomorphism since there is a correspondence between terms and proofs of the algorithmic system evaluation in this section we define an efficient execution model for the polymorphic calculus as a conservative extension of the execution model of the monomorphic calculus by efficient we mean that monomorphic expressions will be evaluated as efficiently as in the original runtime in fact even polymorphic expressions will be evaluated as efficiently as well as if type variables were basic monomorphic types despite the fact that the formal re semantics of polymorphic expressions includes a runtime operation the key observation that allows us to define an efficient execution model for the polymorphic calculus is that can be implemented so that the only case in which is computed at runtime will correspond to testing the type of a partial application of a polymorphic function in practice this case is so at least in the xml setting that there is no difference between monomorphic and polymorphic evaluation monomorphic language let us start by the execution model of monomorphic which is a classic evaluation expressions and values are defined as e c x ee e s e e v c e where t denotes an intersection of arrow types s denotes a closed type and e denotes an environment that is a substitution mapping expression variables into values the big step semantics is e m c c e m x e x e m e e m e e e m e v e x v m e v e m ee v case t e m e v v m t e m e v e m e t e e v case f e m e v v m t e m e v e m e t e e v to complete the definition we define the relation v m t that is membership of a monomorphic value to a monomorphic type c m t def bc t e m t def s t where is the subtyping relation of polymorphic language in the naive extension of this semantics to the explicitlytyped polymorphic calculus of section we deal with typesubstitutions as we do for environments that is by storing them in closures this is reflected by the following definition where for brevity we write i to denote the set of typesubstitutions iii e v c c ee i e t e e ei the bigstep semantics is then defined as follows where each ex is evaluated with respect to an environment e determining the current value substitutions and a set of typesubstitutions i i e p c c i e p x e x i e p tj xe tj xe e i i j e p e v i e p ej v i e p e xe e h i e p e v j h k p j j l l v p p e x v p e v i e p ee v case t i e p e v v p t i e p e v i e p e t e e v case f i e p e v v p t i e p e v i e p e t e e v the membership relation v p t for polymorphic values is defined as c p t def bc t sj xe e i p t def si j t where is the subtyping relation of and xu it is not difficult to show that this bigstep semantics is equivalent to the smallstep one of section let be the transformation that maps values of the polymorphic language into corresponding values of the calculus that is c c and sj xe e i si j where e applies to all the values in the range of e let i denote the singleton set containing the empty which is the neutral element of the composition of sets of typesubstitutions then we have theorem let e be a welltyped closed explicitlytyped expression a e t then i p e v e v this implementation has a significant computational burden compared to that of the monomorphic language first of all each application of computes the set p which requires to implement several typesubstitutions and membership tests second each application of computes the composition of two sets of typesubstitutions in the next section we describe a different solution consisting in the compilation of the explicitly typed calculus into an intermediate language so that these computations are as much as possible and are performed only if and when they are really necessary intermediate language the intermediate language into which we compile the explicitlytyped polymorphic language is very similar to the monomorphic version the only difference is that abstractions both in expressions and closures may contain type variables in their interface and have an extra which is a term denoting a set of typesubstitutions e c x ee e t e e v c i t intuitively a comp term corresponds to an application of the composition operator to the sets of type substitutions denoted by and while a t term selects the subset of type substitutions denoted by that are compatible with the fact that the value instantiating x belongs to the domain of t the big step semantics for this intermediate language is e o c c e o x e x e o e e o e e e o e v e x v o e v e o ee v case t e o e v v o t e o e v e o e t e e v case f e o e v v o t e o e v e o e t e e v notice that this semantics is structurally the same as that of the monomorphic language there are only two minor differences i abstractions have an extra which has no impact on efficiency since it corresponds in the implementation to manipulate descriptors with an extra field and ii the corresponding case rules use a slightly different relation o instead of m it is thus easy to see that in terms of steps of reduction the two semantics have the same complexity what changes is the test of the membership relation o rather than m since when the value to be tested is a closure we need to in other words we have to evaluate the expression the function and apply the resulting set of substitutions to the interface of the function formally c o t e o t def def bc t t where the evaluation of the symbolic set of typesubstitutions is inductively defined as i i comp ii j ii e x o notice in the last rule the crucial role by x and e by using an expression variable x in the symbolic representation of typesubstitutions and relying on its interpretation through e we have to typesubstitutions the same benefits that bring to value substitutions just as closures allow value substitutions to be only when a formal parameter is used rather than at the moment of the reduction so our technique allows typesubstitutions to be only when a type vari able is effectively tested rather than at the moment of the reduction it is easy to see that the only case in which the computation of o is more expensive than that of m is when the value whose type is tested is not i the a closure t xe e in is different which from i t is not closed and is only if the closure is the result of a partial application of a function the type t is not closed only if such partial application a polymorphic func tion in conclusion the evaluation of an expression in the language is more expensive than the evaluation of a similar expression of the monomorphic language only if it tests the type of a polymorphic function resulting from the partial application of a polymorphic function the additional overhead is limited only to this particular test and in all the other cases the evaluation is as efficient as in the monomorphic case finally it is important to that this holds true also if we add product types the test of a pair of values in the polymorphic case is as expensive as in the monomorphic case and so is the rest of the evaluation since in the xml setting the of the computation time is spent in testing products since they encode sequences trees and xml el then the overhead by adding polymorphism ie the overhead due to testing the type of a polymorphic partial cation of a polymorphic function is in practice all that remains to do is to define the compilation of the explicitlytyped language into the intermediate language x x ti xe ee ei e t e e e t e e given a closed program e we compile it in the intermediate language as e in practice the compilation will be even simpler since we apply it only to expressions generated by local type inference algorithm described in the companion paper where all s are by i cf discussion at the end of section to be more precise when there exists a substitution such that dom notice that the tests of the subtyping relation for monomorphic and polymorphic types have the same complexity by similar we intend with the same syntax tree but only closed types so the second case of the definition simplifies to t xe t the compilation is adequate theorem let e be a welltyped closed explicitlytyped expression a e t then i p e v o e v with v v where t xe e evaluates all the symbolic expressions and typesubstitutions in the term see by combining theorems and we obtain the adequacy of the compilation corollary let e be a welltyped closed explicitlytyped expression a e t then o e v e v a function is polymorphic if it can be safely applied to arguments of different types the calculus presented supports a of different forms of polymorphism it uses subtype polymorphism a function can be applied to arguments whose types are subtypes of its domain type the combination of intersection types and typecase expressions yields ad hoc polymorphism overloading and finally the use of type variables in function interfaces provides parametric polymorphism polymorphism is interesting when used with bindings instead of the definition of a function every time we need to apply it it is more convenient to define the function once bind it to an expression variable and use the variable every time we need to apply the function in the current system it is possible to combine binding only with the first two kinds of polymorphism different occurrences of a variable bound to a function can be given different types thus be applied to arguments of different types either by subsumption ie by assigning to the variable a supertype of the type of the function it denotes or by intersection elimination ie by assigning to a variable one of the types that form the intersection type of the function it denotes however as it is well known in the languages of the in the current setting it is not possible to combine binding and parametric polymorphism distinct occurrences of a variable cannot be given different types by instantiation ie by assigning to the variable a type which is an instance of the type of the function it denotes in other terms all abstracted variables have monomorphic types with respect to parametric polymorphism which is why in ml is not the solution is well known and consists in introducing let bindings this amounts to defining a new class of expression variables so that variables introduced by a let have polymorphic types that is types that have been generalized at the moment of the definition and can be instantiated in the body of the let to sum up abstracted variables have monomorphic types while variables may have polymorphic types and thus be given different types obtained by instantiation for short we call the former abstracted variables monomorphic expression variables and the latter variables polymorphic expression variables in the explicitlytyped calculi of the previous sections we had just abstracted variables that these variables have monomorphic types is clearly by the fact that operationally xi is equivalent to ie reduces to x clearly this property must not hold for polymorphic type variables since let x yy in xx is intuitively well typed while the same term obtained by ing x with x is not see the extension of the definition of for polymorphic variables later on to enable the definition of polymorphic functions to our we add a let expression to ease the presentation and to that the addition of is a conservative extension of the previous system we syntactically distinguish the current variables ie those abstracted by a from polymorphic variables by the latter ones e · · · x let x e in e reduction is as usual let x v in e is extended by the following definitions xj jj def xj jj let x e jj def let x ej jj jj and the algorithmic typing rule is as expected let a e t a x t let x e in e a t e t type environments now map also polymorphic expression variables into types notice that for a polymorphic expression variable x it is no longer true that not adding to corresponds to generalizing the type of x before typing e as in the gen rule of the algorithm cf as before we assume that polymorphic type variables of a in particular those generalized for are distinct from monomorphic and polymorphic type variables of the context that the occurs in likewise environments now map both monomorphic and poly expression variables into values so that the rules for eval in section are extended with the following ones e x c e x e j i e p x c i e p x e i j i e p e v i e x v p e v i e p let x e in e v to compile we have to extend the intermediate language likewise we will distinguish polymorphic expression variables by them with sets of that apply to that particular occurrence of the variable so we add to the productions of section the following ones e · · · x let x e in e while the bigstep semantics of the new added expressions is e x c e o x c e x t ye e e o x e e o e v e x v o e v e o let x e in e v notice how rule uses the on the variable to construct the closure the final step is the extension of the compiler for the newly added terms x x let x e in e let x e in e as an example the is compiled into let x yy in xx where the substitution that is applied to the leftmost occurrence of x is recorded in the variable and will be used to instantiate the closure associated with x by the environment the rightmost occurrence of x is by i and therefore the value bound to it will not be instantiated theorems and corollary hold also for these extensions see appendix d for the proofs in an actual programming language there will not be any syntactic distinction between the two kinds of expression variables and compilation can be optimized by transforming variables that are to monomorphic values into monomorphic variables so whenever e has a monomorphic type t the should be compiled as let x e in e tt where t is the type for e under the hypothesis that x has type t notice that this optimization is compositional design choices and extensions for the sake of we omitted two key features in the pre recursive functions and pairs recursive functions can be straightforwardly added with minor modifications in particular for it f suffices to associated with the type obtained by applying the to the interface that is f the reader can refer to section in for a discussion on how and why recursion is restricted to functions the extension with product types instead is less but can be mostly done by using existing techniques we add pairs e e and projections ie for i to terms and the product type constructor to types reduction semantics is standard two notions of reduction iv for i plus the usual context reduction rules typing rules are standard as well a pair is typed by the product of the types of its and if e is of type then its ith projection ie has type ti the rule for pairs in the algorithmic system a is the same as in the static semantics while the rules for projections ie become more difficult because the type inferred for e may not be of the form but in general is equivalent to a union of tions of types we already met the latter problem for application where the function type may be different from an arrow and there we checked that the type for the function in an application is a functional type ie a subtype of similarly for products we must check that the type of e is a product type ie a subtype of × if the constraint is satisfied then it is possible to define the type of the projection in a way to the definition of the domain dom for function types using standard techniques of semantic subtyping see section in this is explained in details in appendix c for the semantics of the calculus we made few choices that re strict its generality one of these the use of a callbyvalue tion is directly inherited from and it is required to ensure subject reduction if e is an expression of type then the application xe has type if we use callbyname then this re reduces to e e whose type is larger than the type of the redex although the use of callbyname would not the soundness of the type system expressed in terms of progress we to ensure subject reduction since it greatly simplifies the theoretical development a second choice to restrict to closed types was made by practical considerations using open types in a typecase would have been computationally as it demands to solve at runtime the problem whether for two given types s and t there exists a such that s t we study this problem that we call the problems in the companion paper our choice instead is compatible with the highly op and provably optimal pattern matching compilation tech of we leave for future work the study of on types with monomorphic variables ie those in this does not require dynamic type resolution and would allow the programmer to test capabilities of arguments bound to polymorphic type variables related work we focus on work related to this specific part of our work namely existing explicitlytyped calculi with intersection types and func tional languages to process xml data comparison with work on local type inference and type reconstruction is done in the second part of this work presented in the companion paper to compare the differences between the existing explicitlytyped calculi for intersection type systems we discuss how the term of our in is as terms different typed of the same untyped term are together with an intersection in such systems the function in with int bool is written type checking verifies that both and are well typed separately which generates two very similar typing derivations the proposal of follows the same idea except that a separation is kept between the computational and the logical con of terms a term consists in the association of a marked term and a proof term the marked term is just an untyped term where term variables are marked with integers the proof term encodes the structure of the typing derivation and relates marks to types the example is written in this system as x y in general different occurrences of a same mark can be with different types in the proof term in terms are duplicated as in but the type checking of terms does not generate copies of almost identical proofs the type checking derivation for the term in parallel that the two copies are well typed the duplication of terms and proofs makes the definition of beta reduction and other transformations on terms more in the calculi presented so far because it has to be performed in parallel on all the typed instances that correspond to the same untyped term branching types have been proposed in to this issue the idea is to represent different typing tions for a same term into a compact piece of syntax to this end the branching type which corresponds to a given intersection type t records the branching shape ie the uses of the tion introduction typing rule of the typing derivation correspond ing to t for example the type has only two branches which is represented in by the branching shape j our running example is then written as note that the lambda term itself is not copied and no duplication of proofs happens during type checking either the branches labeled i and j are verified in parallel in the authors propose an expressive refinement type sys tem with intersection union but also a form of dependent types making possible to define eg the type of integer lists of length n written the variable n can be quantified over either uni or existentially using respectively and thanks to this it is possible to consider different instantiations of a type and thus to type our function by different instances of rather than with any type as for int and bool in our example type checking requires type annotations to be able to check that has type the subterm yx has to be annotated this problem is similar to finding appropriate annotations for the function in our language in terms are annotated with a list of typings for example yx can be annotated with a x x which says that if x then yx has type and similarly if x the above annotation a is not sound because when checking that ax has result type one can see that the occurrences of n in a escape their scope they should be bound by the quantifier in the result type to fix this typing environments in annotations are extended with universally quantified variables that can be instantiated at type checking for example yx m nat x means that yx has type assuming x where m can be instantiated with any natural number with this annotation the function can be checked against by instantiating m with respectively n and n it is possible to find a similarity between the annotations of the lists of typings and our annotations ie the combination of interface and although instantiation in the former is much more there is however a fundamental difference between the two systems and it is that does not include a type case because of that annotations need not to be propagated at runtime in they are just used statically to check soundness and then erased at runtime without we could do the same but it is precisely the presence of that our formalism for what concerns xml programming let us polymorphic and the work by in both pattern matching is designed so as not to break polymorphism but both have to give up something higherorder functions for and intersection negation and local type inference in the type of function arguments must be explicitly given furthermore work from the original sin of starting from a subtyping relation that is given by a deduction system this makes the intuition underlying subtyping very difficult to at least for us another taken is the one of which ocaml and type systems in the same language keeping them separated this practical approach yields little theoretical problems but forces a value to be of one kind of type or another preventing the programmer from writing polymorphic xml transformations by et al haskell type classes with regular expression types but has two main first every polymorphic variable must be annotated it is instantiated with an xml type second even without inference of explicit annotations which they do not address their system requires several restrictions to be decidable while our system with explicit typesubstitutions is decidable conclusion the work presented in this and in its companion paper provides the theoretical basis and all the algorithmic tools needed to design and implement polymorphic functional languages for data and more generally for functional languages with recursive types and settheoretic unions intersections and in particular our results the way to the polymorphic extension of and to the definition of a real type system for not just one in which all higherorder functions have type function thanks to local type inference and type reconstruction defined in the second part of this work these languages can have a syntax and semantics very close to those of ocaml or haskell but will include primitives in particular complex patterns to exploit the great expressive power of settheoretic types some problems are still open notably the decidability of inference defined in the second part of this work but these are of theoretical nature and should not have any impact in practice as a matter of facts people program in java and scala even though the decidability of their type systems is still an open question on the practical side the most interesting directions of research is to the efficient compilation of the polymorphic calculus with techniques of static analysis that would perform par tial evaluation of so as to improve the efficiency of typecase of functional values even in the cases in which it is more expensive than in the monomorphic version of acknowledgments this work was partially supported by the project n xu was also partially supported by an of of and by the grant n of the national natural science foundation of references h barendregt m and m a filter lambda model and the completeness of type assignment journal of symbolic logic ­ v g and a an general purpose language in icfp acm press v b and l a typed lambda calculus with intersection types theor comput sci ­ g k and z xu polymorphic functions with settheoretic types part local type inference and type reconstruction unpublished manuscript available at november g and z xu settheoretic foundation of parametric polymorphism and subtyping in icfp j and m m m and b principal type schemes and lambdacalculus semantics in to hb curry on combinatory logic lambdacalculus and formalism academic press j and f pfenning typechecking in popl acm press j et al an xml query language working draft a ocaml in icfp a g and v semantic subtyping dealing with function union intersection and negation types the journal of acm ­ h a and g parametric polymorphism for xml acm toplas ­ l and s à la church inf comput ­ bc pierce types and programming languages mit press f pottier and d the essence of ml type inference in bc pierce editor advanced topics in types and programming languages chapter pages ­ mit press jc reynolds design of the programming language technical report carnegie mellon university jc reynolds what do types mean from to semantics in programming methodology springer s intersection typed lambdacalculus notes theor comput sci ­ m k and m lu adding regular expression types to haskell in lncs n springer j polymorphic regular tree types and patterns in popl pages ­ a r and fa a calculus with polymorphic and flow types j program ­ and c branching types in esop volume of lncs pages ­ springer z xu parametric polymorphism for xml processing languages phd thesis paris available at http 