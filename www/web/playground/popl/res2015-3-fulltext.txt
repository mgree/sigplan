higher inductive types as algebras carnegie mellon university abstract type theory is a new field of mathematics based on the correspondence between constructive type theory and abstract theory we have a powerful between these disciplines we can use geometric intuition to formulate new concepts in type theory and conversely use typetheoretic machinery to verify and often simplify existing mathematical proofs higher inductive types form a crucial part of this new system since they allow us to represent mathematical objects such as and in the type theory we investigate a class of higher inductive types called which generalize wellfounded trees we show that a propositional variant of whose computational behavior is determined up to a higher path is characterized by the universal property of being a algebra as a corollary we get that in the strict form are categories and subject descriptors f mathematical logic and formal languages mathematical logic keywords algebra higher inductive type type theory introduction type theory has recently generated significant interest among type and it deep connections between dependent type theory and the fields of abstract theory higher categories and algebraic topology ­ ­ insights from theory are used to add new concepts to the type theory such as the representation of various geometric objects as higher inductive types conversely type theory is used to formalize and verify existing mathematical proofs using proof such as coq and agda moreover typetheoretic insights often help us discover novel proofs of known results which are simpler than their versions the calculation of the theorem the theorem etc as a formal system is a generalization of intensional type theory with two features motivated by abstract theory axiom permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm and types the in is that types are topological spaces terms are points and proofs of are paths between points the structure of an identity type in is thus far more complex than just consisting of paths despite the definition of y as an inductive type with a single constructor x it is a and perhaps surprising fact that not only does this richer theory admit an interpretation into theory but that many fun concepts and results from mathematics arise naturally as constructions and theorems of for example the unit s is defined as a higher inductive type with a point base and a loop loop based at base it comes with a recursion principle which says that to construct a function f s x it suffices to supply a point x x and a loop based at x the value f base then computes to x such definitional computation rules are convenient to work with but also pose some conceptual difficulties for instance an alternative encoding of the as a higher inductive type sa specifies two points north and two paths from north to called and the recursion principle then says that in order to construct a function f sa x it suffices to supply two points x y x and two paths between them the values f north and f then compute to x and y respectively we have a natural way of relating these two representations via an equivalence in one direction map base to north and loop to in the other direction map both north and to base and map to loop and to the identity path at base unfortunately the types s sa related this way while equivalent do not satisfy the same definitional laws which a compatibility is even more importantly we do not have a way of these notions of a and working with them inside the type theory since we can only talk about definitional equalities on the metalevel in this paper we thus study higher inductive types abstractly as arbitrary types with certain constructors and propositional computation behavior in the case of s for example we say that a type c with constructors b c and l c c satisfies the recursion principle for a if for any other type x point x x and loop based at x there exists a function f c x for which there is a path between f b and x and which satisfies a higher coherence condition we note that we require no change to the underlying type theory the particular higher inductive type s just becomes a specific instance of the abstract definition of a one whose computation rules happen to hold a major advantage of types with propositional computation rules is that we can the definitions and reason about them within the type theory and in particular use proof to verify the results in this respect our work is complementary to which gives an external semantics for a certain class of higher another advantage of computation behavior is the computation laws satisfied by the types s and sa to their propositional counterparts results in two notions of a that are equivalent this in particular means that any type c which is a in one sense is also a in the alternate sense we can thus state and prove results about either of these specifications knowing that the proofs carry over to any particular implementation be it s sa or a third one it further turns out that types with propositional rules tend to keep many of their desirable properties for instance it can be shown that the main result of that the fundamental group of the is the group of integers carries over to the case when both the and the integer types have propositional computational behavior in addition we can now show that higher inductive types are characterized by the universal property of being a algebra this notion was first introduced in where an analogous result was established for the ordinary inductive type of wellfounded trees in the setting an algebra is a type x together with a number of finitary operations f g h which are allowed to act not only on x but also on any higher identity type over x an algebra homomorphism has to preserve all operations up to a higher finally an algebra x is if the type of homomorphisms from x to any other algebra y is our main theorem is stated for a class of higher inductive types which we call they generalize ordinary as well as the higher inductive type s and others we show that the induction principle for is equivalent as a type to this extends the main result of for ordinary inductive types to the important and much more difficult case basic type theory the core of is a dependent type theory with · dependent pair types and dependent function types with the versions a × b and a b to consistent with the presentation in we assume definitional conversion for functions but do not assume it for pairs · a hierarchy of u u u in the style of russell · intensional identity types y also denoted x a y we have the usual formation and introduction rules the elimination and computation rules are below e y ui d x d y p e y ui d x a a da a da ea a these rules are of course applicable in any context we follow the standard convention of it if the type y is we call x and y equal if we do not care about the specific equality witness we often simply say that x a y or if the type a is clear x y a term p x a y will be often called a path and the process of applying the identity elimination rule will be referred to as path induction definitional equality between x y a will be denoted as x y a we emphasize that apart from the identity rules and higher inductive types there are no other rules the behavior of identity types in particular we assert neither any form of nor the identity reflection rule the rest of this section describes the axiom and some key properties of identity types higher inductive types are discussed in section for a of type theory we refer the reader to laws proofs of identity behave much like paths in topological spaces they can be mapped along functions etc below we summarize a few of these properties · for any path p x a y there is a path p y a x and we have · for any paths p x a y and q y a z there is a path p q x a z and we have · associativity of composition for any paths p x a y q y a z and r z a u we have p q r p q r · we have p p and p p for any p x a y · for any p x a y q y a z we have p p p p and p p p q q p · for any type family p a ui and path p x a y there are functions pp p x p y and pp p y p x called the covariant and contravariant respectively we furthermore have x · we p have qp p a qp qp ui and pp paths p x a y q y a z · for any function f a b and path p x a y there is a path p f x b f y and we have x · we have p p and p q p q for any f a b and p x a y q y a z · we have p p for any f a b g b c and p x a y · for a dependent function f and path p x a y there are paths p x by f y and p pb f y bx f x we also have x · all constructs respect propositional equality between functions a between two functions is in a sense a natural transformation definition for f g we define the type f g a ba ga and call it the type of between f and g definition for f a b and g a b we define the type f h g af a b ga and call it the type of heterogeneous between f and g we now introduce some notation that will be needed later · for any f g x y p x x y f g there is a path nat p x p y · for any f x z g y z p x x x q y y y f h g there is a path p q x y p x y levels in general the structure of paths on a type a can be highly nontrivial we can have many distinct cells x y a there can be many distinct cells p q x a y there can be many distinct cells p q ad the hierarchy of levels describes those types which are informally speaking trivial beyond a certain dimension a type a of level n can be characterized by the property that all for m n with the same source and target are equal from this intuitive description we can see that the hierarchy is it is to also of levels and called types and propositions respectively definition a type a ui is called if there exists a point a a such that any other point x a is equal to a a x a type a ui is called a proposition if all its are equal a y thus a type can be seen as having exactly one up to equality a proposition can be seen as having at most one up to equality clearly lemma if a is then a is a proposition the existence of a path between any two points implies more than just lemma if a is a proposition then x a y is for any x y a thus types are in a sense the possible any two points are equal up to a cell which itself is unique up to a cell which itself is unique up to a cell and so on propositions are the ones after spaces we can now easily show corollary for any a and are propositions equivalences a crucial concept in is that of an equivalence between types definition a map f a b is called an equivalence if it has both a left and a right inverse f × h we define a b and call a and b equivalent if the above type is we can prove that a and b are equivalent by constructing functions going back and which compose to identity on both sides this is also a necessary condition lemma two types a and b are equivalent if and only if there exist functions f a b and g b a such that g f and f g we will refer to such functions f and g as forming a and say that f and g are of each other from this we can easily show lemma equivalence of types is an equivalence relation although the type of such functions itself is not equivalent to a b see of we call a and b logically equivalent if there are exist functions f a b g b a it is immediate that if both types are propositions then logical equivalence implies a b for example corollary for any a a × many operations on paths turn out to be equivalences for instance · for any u a x b v b x d w a x c z c x d there is a map i u w z v u v w z defined in the obvious way by induction on v and w this map is an equivalence · for any u a x b v b x d w a x c z c x d there is a map i u w z v w u z v defined in the obvious way by induction on v and w this map is an equivalence structure of path types let us first consider the product type a × b we would like for two pairs c d a × b to be equal precisely when their first and second projections are equal by path induction we can easily construct a function c d c d × c d we can show lemma the map is an equivalence for any c d we will denote the of by for brevity we will often omit the subscripts we have a similar correspondence for dependent pairs however the second projections of c d now lie in different of b and we employ covariant by path induction we can define a map c d c d lemma the map is an equivalence for any c d we will denote the of by we also have an analogous correspondence using a contravariant we would like for two types a b ui to be equal precisely when they are equivalent as before we can easily obtain a function a b a b the axiom now states that this map is an equivalence axiom the map is an equivalence for any a b ui we will denote the of by it follows from that equivalent types are equal and hence they satisfy the same properties lemma for any type family p ui uj and types a b ui with a b we have that p a p b thus in particular p a is precisely when p b is finally two functions f g should be equal precisely when there exists a between them constructing a map f g f g is easy showing that this map is an equivalence or even constructing a map in the opposite direction is much harder and is in fact among the consequences of lemma the map is an equivalence for any f g proof see of we will denote the of by higher inductive types in this section we describe some higher inductive types of interest and use these specific examples as an introduction to the terminology and methodology that will follow in sect an inductive type x can be understood as being freely generated by a collection of constructors in the familiar case of natural numbers we have the two constructors for zero and successor the property of being freely generated can be stated as an induction principle in order to show that a property p n ui holds for all n n it suffices to show that it holds for zero and is preserved by the successor operation as a special case we get the recursion principle in order to define a map f n c is suffices to determine its value at zero and its behavior with respect to successor higher inductive types generalize ordinary inductive types by allowing constructors involving path spaces of x rather than just x itself as the next example shows the the unit s is represented as an inductive type s u with two constructors base s loop base s base as loop base this in particular means that we have further paths such as loop loop loop which is equal to loop we can reason about the using the principle of recursion also called simple elimination for s which tells us that in order to construct a function out of s into a type c it suffices to supply a point c c and a loop s c c c c ui c c s c c c c s s c furthermore the has the expected behavior on the cell constructor base we omit the premises c c c we also have a computation rule for the cell constructor loop cc s this rule by of the previous one we note that in order to record the effect of the on the path loop we use the construct ap since this is a derived notion rather than a primitive one we state the rule as a propositional rather than definitional equality we also have the more general principle of induction also called dependent elimination for s which subsumes recursion instead of a type c ui we now have a type family e s ui where previously we required a point c c we now need a point e finally an obvious generalization of a loop s c c c would be to ask for a loop d e e however this would be incorrect once we have our desired of type its effect on loop is not a loop at e in the but a path from e to e in or its contravariant version the induction principle thus takes the following form e s ui e d e e e d we have the associated computation rules e e ee d the round two we could have alternatively represented the as an inductive type sa u with four constructors as north sa sa north sa north sa north we now have the recursion principle c ui c c d c p c c d c c d p q sa c with the computation rules q c c d c c d p q north c c c c d p q d c and p q the corresponding induction principle is e sa ui u v µ u v u v e u v µ ex with the associated computation rules e u v µ north u e u v µ v and µ as expected the two types are equivalent lemma we have s sa proof sketch from left to right map base to north and loop to from right to left map both north and to base to loop and to using the respective induction principles show that these two mappings compose to identity on both sides and apply lem computation laws by lem the types s and sa are equivalent and hence satisfy the same properties see lem we would thus expect the induction principle for s to carry over to sa and vice versa indeed with a little effort we can show the former lemma the type sa satisfies the induction and computation laws for s with north as the constructor base and as the constructor loop in the other direction though we a the only obvious choice we have is to define both points north and to be base one of the paths and to be loop and the other one the identity path at base this however does not give us the desired induction principle unless the two given points u and v happen to be equal we will not be able to map base to both of them as required by the computation rules this more than just a conceptual problem in mathematics we often have several possible definitions of a given notion all of which are from the point of view of a user having two definitions of a which are not known to be however can be problematic any theorem we establish about or by to sa might no longer hold or even typecheck when using s instead to see this take the second computation law for sa if we attempt to implement sa using the s instead by taking north base loop as in the proof of lem the computation law is no longer welltyped since the lefthand side reduces to a path whereas the right hand side is a path from u to v this is one of the for considering inductive types with propositional computation behavior we now want to investigate types which act like the up to propositional equality in the case of s such a type c ui should come with a point b c and loop l c c c in the case of sa such a type should come with two points n s c and two paths e w n c s we can express this more as follows definition define the type of on a universe ui as bc b b definition define the type of on a universe ui as n s × n s we are now interested in maps between algebras which in a suitable sense preserve the distinguished points and paths ie algebra homomorphisms a homomorphism between two c c p and d d q should be a function f c d for which we have a path f c d furthermore f should also appropriately relate p and q to figure out what this means we observe that if we map p along f we obtain a path p f c f c each of the identical is equal to d via the path thus we now have another path p d d it is reasonable to require that this path be equal to q ie that the following diagram p f c f c likewise a homomorphism between two c a b p q and d c d r s should be a function f c d for which we have paths f a c f b d and for which the following diagrams commute f a c p r f b d f a c q s f b d in other words an s or behaves just like a function constructed by the appropriate recursion with propositional computation laws for points and paths we can express this as follows definition for algebras x y define the type of from x to y by c c p d d q p q definition for algebras x y define the type of from x to y by c a b p q d c d r s p r × q s we note that to be able to form the type of homomorphisms as we just did it is crucial to have the computation laws stated the recursion principle now becomes a property internal to the type theory and can be expressed as saying that there is a homomorphism into any other algebra y definition an algebra x satisfies the principle on a universe uj if for any algebra y there exists a homomorphism from x to y x y x y definition an algebra x satisfies the principle on a universe uj if for any algebra y there exists a homomorphism from x to y x y x y to express the induction principle in a similar fashion we first need to introduce dependent or versions of algebras and algebra homomorphisms definition define the type of on a universe uj over an algebra x by c c p pe e e definition define the type of on a universe uj over an algebra x by c c d p q pe u v × qe u v definition for algebras x y x define the type of from x to y by c c p e e q p q the last component witnesses the diagram pe f c p f c pe e q e definition for algebras x y x define the type of from x to y by c a b p q d c d r s p r × q s the last two components witness the diagrams a p f b pe c r d a q f b pe c s d the induction principle can now be expressed as saying that there is a homomorphism into any algebra y definition an algebra x satisfies the principle on a universe uj if for any algebra y x there exists a homomorphism from x to y x y x y definition an algebra x satisfies the principle on universe uj if for any algebra y x there exists a homomorphism from x to y x y x y relating the two we first note that the notions of and are in fact the same lemma we have a function which is an equivalence proof define the equivalence between and by the c c p c c c p c a b p q c a p q next we note that the notions of and are the same in the following sense lemma for any algebra x we have a function x x x which is an equivalence proof fix algebra c c p define the equivalence between c c p and c c c p by the e e q e e e q e a b r s e a r s the notions of and also coincide lemma for any algebras x y we have x y x y finally the respective versions of and coincide lemma for any algebras x y x we have x y x x y we can now show that is the same as and likewise for induction lemma for any x we have x x x x corollary the s base base loop satisfies the principle on any universe uj corollary the sa north satisfies the principle on any universe uj propositional another example of a higher inductive type is the propositional a ui of a type a ui investigated in in an extensional setting under the name bracket types intuitively a represents the of a which makes all the elements in a equal the need for such a type arises when we wish to hide information having a term a a is very different from having a b a in the latter case we know that the provable failure of a to be that is a term of type a would lead to a contradiction however we do not have a generic way of constructing an of a formally we define a as the higher inductive type generated by a constructor · which projects a given element of a down to a and a constructor which states that a is indeed a proposition · a a sq a y as usual the recursion principle states that given a structure of the same form we have a function out of a which preserves the constructors c uj c a c s x c y c s a c where for each a a we have c s a ca c hence the name propositional see of for other kinds of and for each k l a we have l s c s k c s l we note that we are only able to eliminate into types which are themselves propositions this together with lem implies that the second computation law always holds we have included it nonetheless to illustrate the general pattern to state the induction principle we need to generalize the last hypothesis as before we note that once the desired map f is constructed it will give us a path from k to f l in el for any k l a hence e should already come equipped with such a family of paths except of course we have no way of referring to f k and f l before f is constructed thus we simply require that such a path exists for all points u ek and v el e a uj e q ye u ey v e q where for each a a we have e q a ea ea and for each k l a we have l q k l e q k e q l the second rule again turns out to always hold as we will see the computation laws we point out that the a as defined has its share of behavior for instance as the type n of natural numbers is it follows that n it is not obvious however how to turn itself into a of n since the first computation law to hold more surprising yet is the observation by n in that there exists a map f such that f · this is another somewhat side effect of the definitional computation law for · in light of these issues we follow our methodology for and investigate types which act like the type a up to propositional equality we have the following definition define the type of on a universe uj as a c × a natural definition of an algebra homomorphism between two c c p and d d q is a map f c d together with path families aa f ca da px y qf x f y however the type d is a proposition thus by lem and the fact that a family of types is itself it follows that both of the above types are equivalent to hence we have the simple definition definition for algebras x y define the type of from x to y by c c p d d q c d as before the recursion principle states that there is a homomorphism to any other algebra y definition an algebra x satisfies the recursion principle on a universe uk if for any algebra y there exists a from x to y x y x y based on the rule a natural definition of a algebra over c c p is a family of types e c uk with a function e and path family q ye u v using the fact that c is a proposition we can show however that the above type is equivalent to the condition that e is a family of propositions xc we can thus define definition define the type of on a universe uk over x by c c p × xc analogously to the case a natural definition of a from c c p to e e q is a function f xc ex together with path families aa f ca ea px y qx y f x f y since e is a family of propositions by exactly the same reasoning we get that both of the above types are equivalent to hence we can define definition for algebras x y x define the type of from x to y by c c p e e q xc ex as before the induction principle states that there is a homomorphism to any algebra y definition an algebra x satisfies the a induction principle on a universe uk if for any algebra y to y x there exists a homomorphism from x x y x x y it is now easy to show that induction and recursion for a are in fact equivalent as we will see in the next section this result is an analogue of our main theorem the proof given below for illustrates the basic idea behind the proof of thm we note that since universe levels are the technical restriction that k j does not pose a problem lemma for a ui the following conditions on an algebra x are equivalent · x satisfies the induction principle on the universe uk · x satisfies the recursion principle on the universe uk for k j in other words we have x x provided k j moreover the two types above are propositions proof the fact that the types are propositions is clear the di from right to left is obvious for the other direction fix algebras c c p e e q c c p the total space xc ex uk is a proposition we can thus apply recursion with the projection map a ca ea to get a function f c xc ex a fst f exists as c is a proposition applying second projection and gives us a map x xe f x and we are done as algebras here we consider a class of higher inductive types which we call informally they combine also known as wellfounded trees with a generalized form of ordinary allow proper induction on the level of points but have no constructors on the other hand only provide induction on the point level in the form of two constructors however they allow us to specify an arbitrary number of path constructors between these two points a suitable combination of these two classes of types keeps the of induction and orthogonal which gives us a wellbehaved elimination principle formally given types a c ui a type family b a ui and functions l r c a the wa b c l r ui is the higher inductive type generated by the constructors sup aa ba wa b c l r wa b c l r cell cc c t c s from now on we will write w instead of wa b c l r unless indicated otherwise as in the case of ordinary the type a can be thought of as the type of labels for points and for any a a the type ba represents the arity of the label a ie it is the index type for the arguments of a similarly the type c represents the type of labels for paths between points for any c c the terms lc and rc determine the respective labels of the left and right of the paths labeled by c as can be read off from the type of the constructor cell each label c c determines a family of paths in w one for each pair of terms t bl c w and s br c w an ordinary arises as a in the obvious way by taking a a b b c and letting both l and r be the canonical function from into a we can encode the s by taking a c b l r the sa arises when we take a c b l r other types which can be represented in this form include the interval type hence in particular all the higher sn and of course all ordinary inductive types arising as eg natural numbers lists and so on as an additional example we consider positive integers modulo two let be the inductive type with constructors tt tf ft ff we put a bff c l tt l ff r tf r ft the point labels tt and ff encode the positive integers one and two respectively the unary point label tf represents the function n n and the unary point label ft represents the function n n the path label represents equations of the form tt tf to all odd positive integers the path label represents equations of the form ff ft to all even positive integers come with the expected recursion principle given terms · e uj · e e e · q cc ce ce el c u er c v there is a e q w e the satisfies the computation laws · e q t e a e q t for any a a t ba w and · t s q c e q t e q s for any c c t bl c w s br c w similarly we have an induction principle given terms · e w uj · e b t · q cc cw b t se el c t u er c s v there is an e q the satisfies the computation laws · e q t e a t e q t for any a a t ba w and · t s q c t e q t s e q s for any c c t bl c w s br c w following the pattern we define algebras and homomorphisms definition define the type of on a universe uj by a b c l r type of triples d d p where · d uj · d d d · p cc cd dl c u dr c v as before we will keep the parameters a b c l r implicit if no confusion arises in doing so definition define the type of on a universe uk over x by d d p type of triples e e q where · e d uk · e b t · q cc cd cd b b pc t se el c t u er c s v in order to express the type of homomorphisms between two we again need to use propositional instead of definitional equality definition for x and y define the type of from x to y by d d p e e q type of triples f where · f de · f da t ea f t · cc cd pc t s l c t qc f t f s r c s c t s witnesses the diagram f dl c t f dr c s el c f t tf s er c f s definition for x and y x define the type of from x to y by d d p e e q type of triples f where · f · f da t ea t f t · cc cd pc t s l c t qc t s f t f s r c s c t s witnesses the diagram f dl c t f dr c s el c t f t tf s er c s f s the recursion and induction principles are defined as usual definition an algebra x satisfies the recursion principle on a universe uk if for any algebra y there exists a from x to y x y x y definition an algebra x satisfies the induction principle on a universe uk if for any algebra y x there exists a from x to y x y x x y we will also need the following uniqueness properties which state that any two homomorphisms into any algebra y are equal definition an algebra x satisfies the recursion uniqueness principle on a universe uk if for any other algebra y the type of from x to y is a proposition x y x y definition an algebra x satisfies the induction uniqueness principle on a universe uk if for any algebra y x the type of from x to y is a proposition x y x x y we now define the key concept of which translates the notion of existence plus uniqueness into the typetheoretic setting as definition an algebra x is on a universe uk if for any other algebra y the type of from x to y is x y x y lemma for any x we have x x × x main result our main result establishes the equivalence between the universal property of being and the satisfaction of the induction principle theorem for a c ui b a ui l r c a the following conditions on an algebra x a b c l r are equivalent · x satisfies the induction principle on the universe uk · x is on the universe uk for k j in other words we have x x provided k j moreover the two types above are propositions by lem is equivalent to the principles of recursion plus recursion uniqueness the uniqueness condition is necessary since in general the recursion principle does not fully determine an inductive type the recursion principle for the for example is also satisfied by the disjoint union of two before we proceed to the proof of the general case we look at the analogue of the main theorem for propositional we can define as expected definition an algebra x is on a universe uk if for any other algebra y the type of from x to y is x y x y since we operate in the setting of propositions we do not have to formulate an analogous uniqueness condition which is uniquely satisfied and hence redundant instead we have lemma for any x we have x x thus lem is the analogue of our main result for proof outline a crucial step of the proof is the characterization of the path space µ between two µ x y in a more explicit form for simplicity we only consider the case here we recall that a homomorphism between two algebras d d p e e q is a triple f where f c d is a function between the carrier types specifies the behavior of f on the cells ie the value of f da t and specifies the behavior of f on the cells ie the value of pc t s using the characterization of paths between tuples together with function the path space f g between two homomorphisms should be equivalent to a type of triples where f g is a relating the two underlying mappings and relate to resp to in an appropriate way we will call such a triple a the recursion uniqueness condition on an algebra x can then be equivalently expressed as saying that for any algebra y and homomorphisms µ from x to y there exists a between µ and we point out that this uniqueness condition can itself be understood as a certain form of induction a very specific one the existence of a between any two homomorphisms f g in particular guarantees the existence of a dependent function xx f x gx the the behavior of on the cells ie the value of da t is specified by the term which thus serves as a witness for the first computation rule finally the behavior of on the cells ie the value of t s is specified by the term which hence serves as a witness for the second computation rule we observe the same pattern in the case of propositional homomorphisms between are just maps between the carrier types hence there are no computation rules to of a cell between f and g would just be a xx f x gx the the existence of such is of course a point since we work with propositions we can thus see why the full induction principle for gives us the latter essentially amounts to the recursion principle plus a specific form of induction both of which are implied by the general induction principle the part of the proof is showing the converse ie that the general induction principle can be from we are now ready to give the formal definition of a there is an analogous definition of a which uses the versions of and homomorphisms and for which we refer the reader to definition for algebras x y and homomorphisms µ x y we define the type of between µ and by d d p e e q f g type of triples where · f g · da t a t t a t · asserts the commutativity of the diagram in fig for any c c t bl c d s br c d a t witnesses the diagram f da t da t t a t a t ea f t ea g t t we will often leave the algebra arguments to a implicit remark although the diagram in fig does not explicitly mention the term t s it nevertheless specifies its value uniquely since this term is expressible using nat pc t s lemma for algebras x y and homomorphisms µ x y the path space µ is equivalent to the type of between µ and µ µ the proof of the main result now consists of the following steps show that the induction principle implies the recursion principle that is for any x we have x x show that the induction principle implies both uniqueness conditions that is for any x we have x x x x show that the recursion plus recursion uniqueness principles imply the induction principle that is for any x we have x × x x using lem we thus obtain a logical equivalence between x and x it remains to show that both of these types are propositions the latter is a proposition by lem to show that x is a proposition it is sufficient to do so under the assumption that it is since x satisfies the induction principle by the second step it satisfies the induction uniqueness principle this means that for any algebra y the type x y is a proposition since a family of propositions is itself a proposition this the proof we now sketch the proof of the crucial part step three fix an algebra d d p and assume that d d p and d d p hold fix any algebra e e q over d d p in order to apply the recursion principle we need to turn this into a algebra e e q the first component is easy the only reasonable choice we have is to put e we note that since d uj e d uk and j k we indeed have uk as needed for the second component we put e a u d a u e a u u the last component we omit for brevity the recursion principle then gives us a homomorphism f where in particular f d we next show that the function f is in fact the identity on d up to a we can do this by both of the functions f and with a homomorphism structure on the algebra d d p by the recursion uniqueness principle it then follows that these homomorphisms are equal and in particular they are equal as maps thus we have a f and the underlying map of our desired homomorphism can be defined as x xe f x this map with a homomorphism structure involves a significant amount of higher path to illustrate some of the issues that arise when dealing with higher paths we show the proof of step one fix an algebra d d p and assume that d d p holds fix any other algebra e e q in order to apply the induction principle we need to turn this into a algebra e e q the first two components are easy put e x e and e a t u ea u for the last component we note that the between any two of a constant type family is constant we can thus define q c t s u v to be the path in fig a the induction principle then gives us a map f d e a path family ac f da t ea f t and for any c c dl c t via l c t nat pc t s dr c s via r c s ce t r c s ce s ce t via i c t s ce t r c s ce s via i c t s tf s ce s ce t ce s via qc e t e s figure diagram for the definition of a el c u f dl c t el c u er c v a f dl c t f dr c s b figure l c t f dl c t el c f t f dr c s c t s r c s el c f t tf s er c f s figure t bl c d s br c d a witness c t s for the commutativity of the diagram in fig using path induction we can express equivalently as the path in fig b thus the outer rectangle in the diagram in fig suitable path induction shows that rectangle a hence rectangle b too and we are done we now show how to derive the analogue of our main result for the s the cases of sa and other inductive types as follow the same methodology in the rest of this section we work with a specific wa b c l r u where a c b l r l c t f dl c t el c f t a f dl c t l c s b el c f t tf s f dr c s er c f s r c s figure definition an algebra x is on a universe uk if for any other algebra y the type of from x to y is x y x y lemma we have a function which is an equivalence proof we define the function by the mapping d d p d it is not hard to see that this is an equivalence lemma for any algebra x we have a function x x x which is an equivalence proof fix an algebra d d p we define the function by the mapping e e q e it is not hard to see that this is an equivalence lemma for any algebras x y we have x y x y lemma for any algebras x y x we have x y x x y lemma for any x we have x x x x x x corollary for an algebra x the following conditions are equivalent · x satisfies the induction principle on the universe uj · x is on the universe uj in other words we have x x moreover the two types above are propositions proof we use lem and conclusion we have investigated higher inductive types with propositional computational behavior and shown that they can be equivalently characterized as algebras we have stated and proved this result for propositional and for the socalled which a number of other interesting cases ordinary the unit s the interval type i all and thus all the higher sn the characterization of these individual types as algebras can be easily obtained as a corollary to our main theorem furthermore we can readily apply the method presented here to obtain an analogous result for set and set we conjecture that similar results can be established for other higher inductive types such as group or real numbers following the same methodology we are to formalize the results presented here in the coq proof assistant finally we remark that the entire field of type theory is a subject of research and many questions to higher inductive types and are yet to be two important open problems are finding a unifying schema for general higher inductive types see for progress towards this goal and developing a computational interpretation of partially by the set model acknowledgments thanks to and frank pfenning support for this research was provided by the a e a foundation for science and technology through the carnegie mellon program as well as by the national science foundation under no any and conclusions or expressed in this material are those of the author and do not necessarily reflect the views of the national science foundation references s and a propositions as types journal of logic and computation ­ s and m models of identity types mathematical proceedings of the cambridge society ­ s n and k inductive types in type theory in logic in computer science lics pages ­ ieee computer society m t coquand and s a model of type theory in sets available at coq development team the coq proof assistant reference manual version pl inria available at n and r the identity type weak system theoretical computer science ­ r models of type theory mathematical structures in computer science ­ m hofmann and t the interpretation of type theory in years of constructive type theory volume of oxford logic pages ­ oxford univ press c p and v the model of foundations available as n the map n n is nearly invertible post on the type theory d and g in type theory in certified programs and proofs volume of lncs pages ­ springer d and r harper for dimensional type theory in principles of programming languages popl pages ­ acm d and m calculating the fundamental group of the in type theory in logic in computer science lics pages ­ ieee computer society p weak categories from intensional type theory logical methods in computer science ­ p higher inductive types a of the post on the type theory p and m semantics of higher inductive types available at p an intuitionistic theory of types predicative part in logic colloquium pages ­ northholland p constructive mathematics and computer programming in logic methodology and of science pages ­ northholland u towards a practical programming language based on dependent type theory phd thesis university of technology m type theory vi post on the k higher inductive types as algebras technical report carnegie mellon university available at t into intensional type theory thesis available from the authors web page the foundations program institute for advanced study type theory foundations of mathematics foundations project b van and r types are weak london mathematical society ­ b van and r topological and models of identity types acm v foundations of mathematics talk at the workshop on logic language information and computation m aspects of constructive type theory phd thesis carnegie mellon university 