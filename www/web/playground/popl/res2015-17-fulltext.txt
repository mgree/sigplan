from communicating machines to graphical college london uk university of uk yoshida college london uk complete popl consist well easy to abstract graphical or global graphs are general multiparty session specifications expressive constructs such as merging and joining for representing protocols global graphs can be directly translated into modelling notations such as and this paper presents an algorithm a global graph can be constructed from asynchronous interactions represented by communicating finitestate machines our results include a sound and complete of a subset of safe from which global graphs can be constructed an algorithm to translate to global graphs a time complexity analysis and an implementation of our theory as well as an experimental evaluation categories and subject descriptors d programming languages formal definitions and theory f semantics of programming languages process models keywords multiparty session types choreography communicating finitestate machines global graphs theory of regions introduction context models of interactions among software components from a global point of view have been as a conceptual and practical tool to the complexity of designing and implementing modern applications see eg as noted in besides yielding a global perspective of the coordination of applications supporting the development and verification of single components a global specification can also be so to obtain the local behaviour of components the software engineering methodology associated with is usually a topdown approach to software development life cycle such a methodology to since it allows developers to check components against the corresponding projections of the choreography however approaches do not fully support for example the direction of architectures lacks algorithms to obtain global models when modifying local projections permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright © acm to address this limitation we propose an algorithm to construct from a set of behavioural specifications of components interacting through asynchronous message passing we consider the following two scenarios to the practical applicability of our algorithm · distributed service architectures software as a made available through a public interface that implementation details to be dynamically by and composed the choreography of such systems cannot therefore be designed in advance and has to be established and checked at bindingtime to automatic composition · a problem have to face is the integration of newly developed software with code typically the latter often do not come with a global specification and changes with time therefore it is difficult to how modifications to newly developed components fit within the system relying on a modelling notations used in our algorithm enables a bidirectional topdown and bottomup a can a global viewpoint thus when an choreography either existing components or the global specification may be refined modified can be again so to be compared with the original projections our approach we adopt communicating finitestate machines as suitable behavioural specifications of distributed components from which a choreography can be built are a conceptually simple model based on asynchronous fifo communication and are for properties of distributed systems they are also widely used in tools and can be seen as endpoint specifications we define an algorithm that given a set of yields a choreography expressed as a global graph a graphical model closely related to choreography as a suitable notation for services the system in figure will be the running example to illustrate our approach consists of four each having three buffers to communicate with the other participants that a protocol of a game where alice a sends either to bob b or to c to decide who the game in the former case a the transition the message is put in the fifo buffer ab from a to b and likewise in the latter case if b that is the message is on top of the queue ab and b it by taking the transition then he sends a close to c to her that she has lost c b of her during the game c d that she is after b and c have been of the outcome of the game b sends a signal sig to a while c sends a message msg to a a a a a alice a c c c c c c b b bob b d d figure communicating system a Ñ c c Ñ b a Ñ b b Ñ c close c Ñ d b Ñ a sig c Ñ a msg a Ñ d free figure global graph once the result is sent a d that c is now free and a new round starts the underlying protocol of shows that capture many coordination constructs in a nondeterministically chooses the in b has a sequential behaviour in the parallel behaviour of c is with the interleaving of transition in and threads join and finally the protocol loops understanding the global model of is not easy a much specification is given by the global graph constructed by our algorithm in figure there the choreography of the four components is explicit and it is possible to identify sequentially ordered independent or exclusive interactions for instance from it is evident that interaction a Ñ b must b Ñ c close while interaction c Ñ d is independent of the former two on the other hand a Ñ b and a Ñ c are exclusive ie only one of them may be executed in each round of the game establishing properties of such as is will any sent message be eventually consumed will each participant eventually receive any message she is waiting for is generally undecidable or computationally hard and not immediate even for the simple scenario in figure we give a decidable condition called generalised multiparty compatibility that a set of systems for which the questions above can be decided our algorithm can produce a global graph from any set of generalised multiparty compatible the global graph is constructed through a transformation of the into a safe petri net using the algorithm in the transformation preserves the original which can be by the global graph most of the systems we found in the literature and very few of them do not cf § contributions to the best of our knowledge this is the first work to build graphical from and to the set of from which such can be built our theory is supported by a tool which we evaluated against protocols from the literature recently the construction of syntactic multiparty session types from local specifications has been studied in for a less general framework with no support for lo cal concurrency for instance in figure c can send message while concurrently receiving either or close similarly a can execute input actions and in parallel we argue that for a general form of local concurrency which is in fact supported by threads in many programming languages is crucial for modelling realworld systems in conditions for communicating systems to be safe are given however they do not address the problem of constructing and consider a form of local concurrency more restrictive than ours due to a single receiving buffer per participant we use two queues for each of participants so that a component can concurrently communicate with many other components accessing different fifo queues as eg supported in the tcp protocol suite § § defines generalised multiparty compatibility analyses its complexity proposition and proposition and its soundness theorem § discusses how our condition can be used to suggest to fix systems the construction algorithm its complexity proposition and its completeness theorem are in § the tool and experimental evaluation are in § we conclude and discuss future work in § after discussing more related work in § the full version of this paper include full proofs of our results and benchmark protocols our tool is available online communicating finitestate machines this section definitions and properties of through out the paper we use the following sets and notations fix a finite set p of participants ranged over by p q r s etc and a finite alphabet a the set of channels is c def p q p p and p while act def c t u a is the set of actions ranged over by resp ranged over by is the set of finite words on a resp act also r a y act is the empty word denotes the length of and is the concatenation of and we these notations for words over a definition a communicating finitestate machine is a finite transition system given by a tuple m pq q a q where q is a finite set of states q p q is the initial state and q act q is a set of transitions the transitions of a are labelled by actions label rep the sending of message a from machine s to r and represents the of a by r we write for the language on act accepted by the automaton corresponding to machine m where each state of m is an accepting state a state q p q with no outgoing transition is final q is a sending resp re state if all its outgoing transitions are labelled with sending resp receiving actions and q is a mixed state otherwise a m pq q a q is deterministic if for all states q p q and all actions p act if pq qq pq qq p then q q a m is minimal if there is no machine m with fewer states and transitions than m such that we only consider deterministic and minimal definition communicating systems given a mp qp a pq for each p p p the tuple s is a com system cs a configuration of s is a pair s pq where q with qp p qp and where w with p component q is the control state and qp p qp is the local state of machine mp the initial configuration of s is s pq q with q we fix a machine mp qp a pq for each p p p and let s be the corresponding system definition reachable states and configurations a configuration s pq is reachable from another configuration s pq by transition written or s s if the label is if there is a p a such that either and p s and a qp qp for all p s and b ws r and wp q for all pq sr or and qr q p r and a qp qp for all p r and b r and for all pq sr the reflexive and transitive closure of Ñ is we write sm when for some s sm s ¨ ¨ ¨ sm a sequence of transitions is if no channel of any configuration on the sequence contains more than k messages the set of reachable configurations of s is ts s su the set of s is the largest subset of within which each configuration s can be reached by a execution from s condition b in definition puts a on channel sr while b gets a from channel sr note that for every integer k the set is finite and computable we now recall several definitions about communicating systems s and their configurations s pq we say that s is a deadlock configuration def if w there is r p p such that p r and for every p p p qp is a receiving or final state ie all the buffers are empty there is at least one machine waiting for a message and all the other machines are either in a final or receiving state configuration s is an message configuration if all qp p q are final but w ie there is at least a nonempty buffer and each machine is in a final state finally s is an unspecified configuration def if there exists r pp such that qr is a receiving state and p r implies that and r ie qr is from receiving any message from any of its buffers sometimes a is considered deterministic when pq qq p and pq qq p then a a and q q here we follow a different definition in order to represent branching type constructs definition safe cs system s is safe if for each s p s is not a deadlock an message nor an unspecified configuration the following definitions are new and for § where we a subset of safe cs from which a global graph can be constructed a key point to give our condition for a cs to be safe is to identify sets of concurrent actions below we define an equivalence relation on transitions of a given q q p q let qq def t pq qq p u and define as the smallest equivalence relations that respectively contain the relations and where · pq qq iff r qq q q h · pq qq iff pq qq and for all pq qq p qq qq qq qq where denotes the equivalence class of pq qq wrt intuitively two transitions are related if they refer to the same action upto interleaving example consider the below q q q q q q src pq qq pq qq pq pq qq pq qq pq qq pq pq pq qq pq qq pq qq pq pq the relations in pq hold since both transitions are interleaved with the relation in pq does not hold since the transition between the source of one q and the source of the other q passes through itself the two transitions in pq are sequential rather than concurrent the relation in pq holds but the relation in pq does not because there is pq qq in the equivalence classes of pq qq for which the condition does not hold due to the transition with label src in figure pc cq pc cq since both transitions represent the same action interleaved with in each machine in figure a set of transitions pq qq with the same label forms a equivalence class eg in alice aq pa is a equivalence class labelled by of global graphs synchronous transition system systems amenable to be transformed into global graphs are through their synchronous transition system cf definition where nodes consist of a vector of local states and transitions are labelled by elements in the set of events e def qs qr intuitively an event qr s r aq p e written qr s Ñ r aq for short indicates that machines s and r can ex change message a when they are respectively in state qs and qr in events with the local states of the machines permits to two occurrences of the same communication at two different points in a global graph to single out parallelism at the machine level we introduce an equivalence relation over events that events whose underlying local transitions are equivalent a b c d a b c d pc d c Ñ d pa c a Ñ c pa b a Ñ b a b c d a b c d pa d a Ñ d pa c a Ñ c pa b a Ñ b pc d c Ñ d pc b c Ñ b pc d c Ñ d pb c b Ñ c a b c d a b c d a b c d pc b c Ñ b pb c b Ñ c pc d c Ñ d pb a b Ñ a the transition system of cf figure where events are equivalent if they have the same interaction s Ñ r a a b c d pc a c Ñ a a b c d a b c d pb a b Ñ a pc d c Ñ d a b c d pb a b Ñ a pc a c Ñ a a b c d figure transition graph of and definition the event equivalence is the relation defs x r e e where pq q s Ñ r aq s pq q s Ñ r aq pq qq pq qq p s pq qq pq q q pq q s Ñ pq r aq r qq pq q q q p r aq pq qq pq q q we let res denote the equivalence class of event e example consider the communicating system below q q q q p q q r q q s its synchronous transition system cf definition below is the labelled transition system pq q s Ñ p pq q p Ñ r aq pq q p Ñ r aq pq q s Ñ p we have pq q p Ñ r aq pq q p Ñ r aq and pq q s Ñ p pq q s Ñ p considering equivalent the events on the vertical transitions and those on the ones equivalent allows us to identify a pair of concurrent interactions while still them from other of communications r a and s Ñ p b in our running example cf figure we have pc a c Ñ a pc a c Ñ a since the underlying transitions of a are equivalent ie pa aq pa aq and the underlying transition of c is the same for both events ie pc c we let n n denote vectors of local states and denote the state of p p p in n definition synchronous transition system given a system s let n def tq pq q p def pn e nq pn q pn q e s Ñ r aq and e def te dn n p n pn e nq p u e the synchronous transition system of s is pn n e where n q is the initial state and n res n pn e nq p we fix a set e of representative elements of each equivalence class ie e e and e p e de p e e p res and write n e n for n res n when e p res x e sequences of events are ranged over by and we extend the notation on in definition to eg if e ¨ ¨ ¨ ek n nk iff n n nk represents all the possible synchronous executions of system s and each transition is labelled by an event e taken upto equivalence so to distinguish different occurrences of a same communication while preserving the parallelism of local machines the synchronous transition system for our running example is given in figure definition projections the projection of an event e onto participant p denoted by is defined as follows qr s Ñ r if s p if r p otherwise projection is defined on sequences of events in the obvious way the projection of pn n e on participant p written is the automaton pq q a q where q n q n and q act y tu q is st pn nq p n e n generalised multiparty compatibility we introduce generalised multiparty compatibility as a sound and complete condition for constructing global graphs we fix a system s with pn n e essentially relies on two conditions cf definition for each machine each trace and each choice are represented in and branching property definition whenever there is a choice in a unique machine takes the decision and each of the other participants is either made aware of which branch was chosen or not involved in the choice guarantees that contains enough information to decide safety properties of any asynchronous execution of s and the branching property ensures that if a branching in represents a choice then this choice is wellformed for a language l hd returns the first actions of l if any hd def t d p ¨ p lu hd def tu given n p n let be the transition system where the initial state n is replaced by n we write n pq for that is n pq is the language obtained by setting the initial node of to n and then this new transition system onto p definition system s is representable if n pq and q p qp dn p n q pq t u hd n for all p p p condition in definition is needed to ensure that each trace of each machine is represented in while condition is necessary to ensure that every choice in each machine is represented in proposition given a system s checking whether s satisfies the condition is computable in time with n qp ppp ppp in the worst case the time complexity of checking the rep of s is exponential this is solely due to the lan guage equivalence check condition in definition between each machine and its projection from however as observed in in practice algorithms for language equivalence behave very efficiently in addition we can remove some states from the projection of eg those that are on chains of transitions only while preserving its language thus reducing the n we give a few auxiliary definitions before the branching property for n n p n we define n n iff n n and for all paths n n nk n in such that n nk are pairwise distinct n for all h k intuitively n n holds if n is reachable from n and no simple path from n to n goes through n note that is not a preorder in general the last nodes reachable from n p n with e e p e are e eq def pn nq dn p n i p t u n n ni n p n n n j p t u pn n q if pn nq p e eq then ni is a successor i of a node n on a path from n whose successors are either not able to both e and e or not related to n example consider the synchronous transition system below pq q s Ñ r xq n pq q s Ñ r aq pq q s Ñ r n pq q s Ñ r aq pq q s Ñ r n n pq q s Ñ r xq if q q and q q we have pq q pq q r in this case both branches on a and b from nodes n and n are considered equivalent they are only interleaved with the exchange of message x however if the edge from n to n is removed and q q and q q then pq q r aq pq q s Ñ r in this case the two branches are not equivalent since one of them prevents x to be ever ex changed in our running example cf figure we have b c pa b a Ñ b pa c a Ñ c b c pa b c recall that pa c pa c ie the pair of events can be from both pa b c and pa b c for an event e qr s Ñ r aq p e let s Ñ r a and define a dependency relation e e on events e e aq intuitively e and e are related if there exists a dependency relation between the two interactions from the point of view of the receiver we define a relation ee in if there is a relation between e and e in ie ee in pe e ee in q ee in e e if e ¨ otherwise also iff ¨ e ¨ ¨ e ¨ p r p pe qq r ee in which checks whether there is a dependency between two interactions on a path if these interactions do appear in below we give the second condition for which ensures that each global choice is made by exactly one participant and that all the other participants are either made aware of the choice or not involved by the choice definition branching property system s has the branching property if for all n p n and for all e e p e such that n n and n n then we have that either there is n p n such that n n and n n or for each pn nq p e eq letting def hd ¨ p lt ps ni pq with i p t u and p pp conditions a b and c below hold a p p p either i lp x lp tu and p lp p lp or ii dn p n n n n n pe ¨ pe ¨ b unique selector ds p p ls x ls h p ls y ls c no race r p p lr x lr h p lr p lr i j p t u ni Ñ r ai ei ¨ i s j Ñ r a definition ensures that every branching either is the concurrent execution of two events or for each participant p ai if p does not terminates before n then the first actions of p in two different branches are disjoint or p is not involved in the choice ie the branches merge before p does any action b there is a unique participant s making the decision and c for each participant r involved in the choice there cannot be a race condition between the messages that r can receive the no race condition notably ensures that in any asynchronous execution of s if a machine has more than one nonempty buffers then it can read from them in any order interleaving is possible note that if a machine r receives all its messages from a same sender then there is a relation between all its actions in system case of definition applies to all branching nodes except n pa b c and n pa b c in figure for which case applies for e pa b b and e pa c a Ñ c we have e eq e eq b c pa b c hence case a holds for n iff it holds for n following a we check that every participant satisfies either ai or · a executes different sending actions in both branches and · b executes different receiving actions and · c executes different receiving actions and hence case ai applies to a b and c while case applies to d since there is a node n pa b c such that d does not execute any action on either path from n to n through nodes pa b c and pa b c respectively also condition b is satisfied since a is the unique sender that executes different actions in both branches e and e condition c is satisfied for b and c due to the existence of dependency chains from to and vice versa and from to and vice versa for instance the dependency chain prevents c to delay the of close sent by b until she can receive message sent by a c must send a message msg to a before she can receive the outcome of a new round of the game finally note that e eq ensures that checking the branch ing between e and e at node n is delayed until the interaction c Ñ d does not interfere with the choice hence the behaviours of c and d are checked only once they have the message proposition given a system s checking whether s satisfies the branching property is computable in o ´ r ¯ time checking the branching property is factorial in the size of because it requires the enumeration of paths of cf c of definition we remark that the above is a rather approximation obtained under worst case assumptions of the typical structure of our experiments show good cf § finally we observe that is generally much smaller than eg the transition system of s where each queue may contain at most one message definition generalised multiparty compatibility a system s is generalised multiparty compatible if it is representable and has the branching property example we show the between the and branching conditions by unsafe systems satisfying only one of the properties consider the following machines acc acc a acc acc acc b acc acc acc c c c system s pa b cq with d d is not safe whenever the lefthand side branch of a and the righthand side branch of b are taken in a same execution s will reach an message configuration where messages x and y are never consumed in fact s is not because there is a branching node from which b can execute as first actions either or and there is no dependency between the of a and that of d with d d in the lefthand side branch ie thus the branching property does not hold system s pa b cq with d d is not safe as before whenever the lefthand side branch of a and the righthand side branch of b are taken in a same execution this system reaches an message configuration these two branches are not mutually exclusive since c can receive c then send d this system is not since there is no node in such that actions and are the first actions executed by c hence the con does not hold system s pa b cq with d d is safe and is in s the lefthand side branch of a and the righthand side branch of b are always mutually exclusive while in s and s they are only mutually exclusive in synchronous executions we remark that systems s and s may be easily changed so that they are safe in any execution but not safe in a k bounded execution this may be done by making a and b exchange k messages eg by replacing every resp transitions in a resp b by a sequence of k transitions resp for i k theorem soundness if s is then it is safe no message deadlock and unspecified configurations theorem says that no asynchronous execution of s will result in an message deadlock or unspecified configurations relying on every transition and branching in each machine is represented in the proof shows that for each branching node n the function e eq allows enough branches to be verified against the branching property then it shows that any sent message is eventually received and that a machine in a receiving state eventually receives a message it expected by definition example the unsafe system below has the branching property and condition of definition but not condition this system can reach an message configuration where messages x and y are never received a abc abc b c d this example illustrates the importance of condition of definition to ensure safety in the ts of this system isomorphic to machine a the branches corresponding to and of machine d are not checked against each other for the branching property communicating systems when a system is not our algorithm can be used to suggest different ways of transforming it so to validate the condition by definition we first note proposition if s satisfies all but in definition then the system consisting of the projections of is this means that in such a case a new safe system may be automatically obtained from the projections of ts for instance system s in example is not because in definition does not hold however the system corresponding to the projections of is exactly system s which is in case the projections of do not provide a alternative then the language equivalence check allows to which transitions or paths of each machine are not represented in similarly local states and transitions it can be out according to condition in definition for instance in example we can all transitions over x and y as well as the states where they are enabled when the branching property definition is violated then our analysis permits to give precise information on where the problem occurs first we can give the vector of local states and the two branching events for which the problem occurs as well as a execution that leads to the configuration · if the condition a is violated then we can list the machines for which the condition is not satisfied if a machine has a first same receiving action in both branches then it may be by simply renaming some messages these can be automatically suggested while checking for the branching property if the condition fails because a machine terminates in one branch but not in the other then we can suggest to add a new label and a transition to the final state in the terminated branch as well as a dual transition in a sending machine · if condition b is violated we can the set of machines sending messages at this branching node a solution may be found by identifying the selecting machine and add communications from this machine to the others · if condition c is violated then we can for each machine the condition on which messages a race condition may occur and suggest to add an message between the two corresponding actions note that since are specification or abstraction of programs it is generally not desirable to automatically repair systems indeed some may not be reflected easily in the def build check def def petri net step net step net step graph step figure workflow of the construction global graph def program or might have side effects in the corresponding implementation analogously to concurrent programming where automatic are not generally even if some deadlocks may be detected automatically at run or compile time building global graphs in § we construct the synchronous transition system of a communicating system s and check whether it is we now describe the construction algorithm and its properties figure the workflow of the transformations the algorithm to construct a global graph g from a synchronous transition system consists of the following steps we apply the algorithm of et al to derive a petri net n from we transform n so that its initial marking consists of exactly one place we join transitions whenever possible so to make explicit join and fork points of the workflow we transform the net of into a graph finally we the graph of unnecessary so to obtain a global graph for the sake of the presentation and because the transformations are rather mechanical we explain them through our running example the formal definitions of the transformations and additional results are given in appendix b for it is enough for the reader to know that the algorithm in et al is based on the theory of regions and transforms a transition system into a safe and extended labelled petri net whose reachability graph is bisimilar to the original transition system basically this algorithm transforms events of into transitions of n while the places are built out of regions ie sets of states having a uniform behaviour wrt events we assume in this section that each is free ie n n p n n n n n the algorithm of is applicable on a free since every event e p e has an occurrence in by construction and every state n is reachable from n as stated in lemma below the petri net obtained from in figure is given in figure left lemma if s is and pn n e then n p n n n in step we transform a petri net obtained from algorithm into a petri net whose initial marking consists of exactly one place this allows us to construct a global graph that has a unique starting point in our running example the petri net on the left of figure is transformed by adding a fresh place p initially in if an event e then any transition labelled by e is a hence we can easily lift the free assumption by each into two pointed transitions in and them once the global graph is constructed p p a b a Ñ b p a c a Ñ c c d c Ñ d p b c b Ñ c close c b c Ñ b p p p b a b Ñ a sig p c a c Ñ a msg p a d a Ñ d free p t p p t p a b a Ñ b p a c a Ñ c c d c Ñ d p b c b Ñ c close c b c Ñ b p p t p p b a b Ñ a sig c a c Ñ a msg p p a d a Ñ d free p t p t p p a b a Ñ b p a c a Ñ c p c d c Ñ d b c b Ñ c close c b c Ñ b p p t p b a b Ñ a sig p p c a c Ñ a msg p a d a Ñ d free figure derived net left net after transformations middle and graph right marked and a fresh transition t connected to places p and p this simple transformation is not illustrated in figure in step a transformation ensures that parallel are used as much as possible in the graph instead of choice and parallel in fact the transformation joins sets of places that have the same or to the number of choice the petri net in the middle of figure is the net obtained from the lefthand side net after applying step and in the second transformation we add i t and p so to join p and p which have the same ie t and the transition with label pa d a Ñ d and ii we add t and p so to join p and p which have the same ie the transitions with labels pc b c Ñ b and pb c b Ñ c both t and t are transitions let « be the weak bisimilarity relation on reachability graphs ie « is the bisimilarity upto transitions cf appendix a lemma let n be the petri net obtained after step let n resp n be obtained by applying step resp to n resp n if ti is the reachability graph of ni for i then t « t « t we now define global graphs a superclass of the generalised global types of that allows each gate to be connected to more than two predecessors or successors definition global graph a global graph over p and a is a labelled graph xv a y with set of v set of edges a v v and labelling function from v to t u y ra s r pp a p au such that q is a singleton and for each v p v if is of the form s Ñ r a then v has unique incoming and unique outgoing edges and if p t u v has at least one incoming and one outgoing edge while v has no outgoing edges if label s Ñ r a represents an interaction where s sends a message a to r a vertex with label represents the source of the global graph represents the termination of a branch or of a thread indicates or joining threads and marks corresponding to branch or merge points or to entry points of loops in step a graph is obtained from the petri net obtained after step via a transformation which consists in creating a vertex in the global graph for each place transition and element of the flow relation then these are connected via a source vertex is connected to a vertex without predecessor a sink vertex is connected to any vertex without successors while transitions resp places are connected to a gate resp gate if they have more than one predecessors or successors finally each component of the graph is connected by merging ports corresponding to elements of the flow relation the graph for figure is given in figure right a global graph is obtained from a graph by removing all unnecessary nodes ie former places and transitions such as p and t in figure and events into interactions e is replaced by eg the graph in figure becomes the global graph in figure proposition steps to are computable in polynomial time in the size of n we give the main result regarding the construction of a global graph from in theorem below we the relationship between the machines from which a global graph is constructed and its projections a global graph g can be done in two ways i g can be transformed into a petri net whose reachability graph may be similarly to the projection of cf definition or ii g can be transformed into an automaton whose states are the nodes of g and each transition is labelled by ps Ñ r if the source state corresponds to a vertex with label s Ñ r a and by otherwise in order to recover local concurrency we take the parallel composition of the automata resulting of the projection of each successor of a gate finally the resulting automaton is wrt language equivalence q pp q q free figure projection of onto a we write for the projection of g onto p and give the formal definition in as an example figure shows the projection of cf figure onto a theorem completeness given a system s let g be the global graph built from s and let pn n e q if is free ie n n p n n n n n then s is isomorphic to the system made of the projection of g the proof of theorem cf relies on the fact that each machine is preserved during the construction ie the projection of onto each p is language equivalent with mp the net obtained from via the algorithm in is bisimilar to each transformation preserves weak bisimilarity with the derived net cf lemma and the transformation to a global graph is sound since the net is extended free choice implementation and experimental evaluation in order to the applicability of our work and to estimate the effectiveness of checking for the condition as well as constructing a global graph we have developed a prototype tool supporting our theory the tool implemented in haskell takes as input a textual representation of a communicating system s then builds on which the condition and branching property are concurrently checked for using hkc to check for language equivalence then the tool constructs a global graph from relying on to derive a petri net from and to global graphs table the results of experiments on a few realworld protocols mainly taken from the literature for each protocol the table reports the number of machines the number of nodes and transitions in whether it the condition the size of the constructed global graph and the time it takes to check the condition and its global graph executions were on a intel i cpu with gb of ram on most of the protocols the execution takes only a few seconds to generate larger interesting examples we tested systems consisting of the parallel composition of two protocols eg running example is the parallel composition of two instances of the running example graphical representations of these protocols are in observe that in general the size of the constructed global graph ie the number of vertices is significantly smaller than the size of see running example for instance we note that it is slightly more expensive to check the running example and the protocols this is due to the fact that each of these protocols features at least one participant for which checking condition c of definition is not trivial because they receive information about a choice from different participants eg in on the other hand checking the alternating bit protocol is more time due to larger equivalence classes s p n g time s running example running example alternating bit alternating bit alternating bit alternating bit v v system system filter filter system v system v table experiment results p is the number of machines n resp is the number of nodes resp transitions in and g is the number of vertices in g related work session types in the context of multiparty session types first suggested a construction of a global protocol from a set of local session types up to asynchronous subtyping a typing system which infers a global type from a set of session types is given in recursive constructions are restricted in this work due to an inherently typing system and multithreaded participants are not supported ie in terms of this means that mixed states are not allowed example consider the system of three machines below machine s chooses to either continue interacting with machine r sending cont or r that it wants to terminate sending end before collecting some information from machine p collect s r p global graph s Ñ r cont s Ñ r end p Ñ s collect this system is not accepted by the typing system in because machine p is not involved in the recursion cf rules and in in the authors study the synthesis of global types from basic that is deterministic each state is either sending or receiving and directed for each state its outgoing transitions are all labelled by an action sending to or receiving from the same participant basic do not allow to model general concurrency at the local level since a machine cannot have mixed states note that machines a b and c in figure are not directed the present work covers a much larger set of global protocols than we support mixed and states hence multithreaded participants are allowed recursive protocols are no longer restricted by a syntax oriented formalism and explicit control points may be constructed the first translation from generalised global types into was given in where only sound properties were presented the generalised global types of are strictly included in systems definition the complete of global graphs and a construction algorithm were left as open problems this paper solves these problems other recent works ­ study the relationship between global and local specifications but do not consider the problem of building global specifications from local ones namely in systems are shown to preserve some reachability properties regardless the communication being asynchronous or synchronous essentially systems are if their synchronous behaviour is equivalent to their asynchronous behaviour considering send actions only in the authors the problem of determining whether a choreography is essentially a choreography is if it is possible to build a distributed system that exactly as the choreography specifies in their work take the form of conversation protocols that are finite state machines specifying the sequence of interactions a conversation protocol is to a global graph but without explicit construct for concurrent interactions ie concurrent interactions must be specified by interleaving them we observe that both and conditions require strong properties on message ordering in comparison the condition requires i the existence of a synchronous execution that all paths in each machine and ii that each machine is either made aware every time a choice occurs or is not involved in the choice in addition a subtle difference between our machines and the machines in is that each of the latter machines has a unique buffer from which it can receive messages namely their model is not suitable to reason about a cs as the interleaving of several multiparty sessions where each participant has different receiving buffers in each session in particular their model cannot be used to represent programs which communicate via communications such as tcp connections between pairs of participants we discuss a few examples that illustrate the main differences between the two communication models example consider the system below s r p in our model machine r receives messages from s and p from two different buffers therefore this system is safe since machine r is always able to read message a and then consume b regardless of the order in which the messages from s and p arrive in a model where machine r has only one fifo buffer to receive both messages from s and p machine r will end up in an unspecified configuration if message b reaches the queue before a the system above is not since its synchronous execution differs from its asynchronous execution considering send actions only its choreography is not observe that the system pa b cq from example is unsafe in our communication model but safe in where it is in that model safety follows from the fact that machine b would have only one buffer hence if a chooses the lefthand side branch message a will be in bs queue before thus b must execute its lefthand side branch while if a chooses the righthand side branch d will appear on bs queue first and the latter will then execute its righthand side branch finally note that the system resp choreography in example is not resp either due to the race between the send actions from machines s and p automata the term synthesis of has been used to describe the reduction of cs to a more and decidable model eg with partial order approaches see for a summary of recent results the of the term synthesis in this context is to identify a system of that a protocol described by an incomplete specification such as in these approaches do not yield a global specification as instead achieved by our algorithm in addition our approach enables the verification of properties in for instance the closed synthesis of can be reduced to the construction from a regular language l of a machine satisfying certain conditions related to buffer and words in a tool chain is given to an ie a message from a set of finitestate machines communicating this is transformed into a diagram via a petri net transformation based on the work gives an algorithm to compose several services each service is presented as an automaton and a set of automata are composed by a parallel product the composite automaton is then transformed into a petri net using in both works no result regarding safety or preservation of the behaviour of the original machines is given the work studies whether message sequence imply unspecified scenarios where are implemented by concurrent automata but do not necessarily feature communications it gives conditions on for their implementation to be and are if no other may be from them it does not attempt to give an exhaustive global view of a distributed system but focuses on identifying its possible conclusions future work we have given a complete algorithm one can build a global graph choreography from any generalised multiparty compatible system systems form a new class of communicating systems and we have proved that any system in this class is safe and there exist efficient algorithms to check our work effectively uses the theory of regions a gap between a set of distributed behaviours represented by and graphical session types while a scalable implementation for our framework since the original machines can be by the constructed global graph by theorem we can use our framework to develop a software development life cycle based on a specification written as a choreography is onto a set of local models which will then be refined against their implementations such an approach can also be used to existing distributed systems we are currently with the zero project which proposes a platform to leakage across the various phases of the software development updating global scenarios against local models plays an important role in different stages of software life cycle in this architecture our framework applies naturally to this platform which notably uses choreography specifications and tools we also plan to investigate a relaxed version of the condition which would allow to build global graphs whose projections are equivalent to the original system upto asynchronous communication acknowledgments we thank for initial discussions on this work and the team at for their this work is partially supported by uk projects and and by eu fp projects under grant and and cost action ic behavioural types for reliable software systems references process model and notation architecture zero full version of this paper r k and m inference of message sequence ieee trans software ­ e and p theory of regions in petri nets volume of lncs pages ­ springer c j and s synthesis of for strategies and ­ s and t choreography via in pages ­ acm s t and m for verification of communicating systems in volume of lncs springer s t and m deciding choreography realizability in popl pages ­ acm f and d checking nfa equivalence with bisimulations up to congruence in popl pages ­ acm d and p on communicating finitestate machines jacm ­ a h and f testing service composition in proceedings of the th symposium on software engineering g m and l on global types and multiparty session g and a verification of programs with communication ic ­ w w w web services choreography description language version j m l and a deriving petri nets for finite transition systems ieee trans computers ­ p and n yoshida multiparty session types meet communicating automata in esop volume of lncs pages ­ springer pm and n yoshida multiparty compatibility in communicating automata and synthesis of global session types in icalp volume of lncs pages ­ m g and m counterexample synthesis of monitors for realizability enforcement in volume of lncs pages ­ s and t realizability analysis for interactions using projections in pages ­ acm k honda n yoshida and m multiparty asynchronous session types in popl pages ­ acm j and e from local session types in concur volume of lncs pages ­ springer r a and a weak bisimulation for probabilistic automata theor comput sci ­ s m and m t synthesis of from service in volume of pages ­ d n yoshida and k honda global principal typing in partially commutative asynchronous sessions in esop volume of lncs pages ­ springer m k n and m a synthesizing distributed finitestate systems from in concur volume of lncs pages ­ springer a analysis of communicating automata in volume of lncs pages ­ springer g l and m describing and reasoning on web services using process algebra in pages ­ ieee computer society y wang a and r on the optimal petri net representation for service composition in pages ­ ieee computer society d m and r e protocol specifications and component acm trans program lang syst ­ a equivalences between petri nets we give the formal definitions of the reachability graph of a petri net and which are used in section definition a reachability graph given n pp t f mq we say that a transition t p t is enabled at marking m if all its input places are marked an enabled transition t may producing a new marking m with one less token in each input place and one more token in each output place we write m t Ñ m if m is reachable from m by t and write for the reflexive transitive closure of Ñ the reachability graph of n is the transition system pm m e such that m tm m mu · Ñ q mq m m pm m mu where if the label of t is and return the label e of t otherwise and · e te e mq e u let m m iff pm e mq and m e ñ m iff with e the notion of weak bisimulation between two transition systems is given in definition a adapted from definition a weak bisimulation let t pm m e be a transition system a weak bisimulation on t is an equivalence relation b m m st for all pm mq p b the following holds · m m implies that there is m such that m e ñ m and pm mq p b and · m e Ñ m implies that there is m such that m e ñ m and pm mq p b two states m and m are called weakly bisimilar on t written m m iff pm mq p b for some weak bisimulation b two transition systems ti mi ei i p t u such that m x m h are weakly bisimilar written t « t if given · m m y m y and e e y e · t pm m e Ñ y Ñ mq pm m m holds b from petri nets to global graphs in this section we give the detailed transformations omitted in section the algorithm to construct a global graph g from a synchronous transition system consists of the following steps using the algorithm of et al we derive a petri net n from we transform n so that its initial marking consists of exactly one place transformation b below we join transitions whenever possible so to make joins and explicit transformation b below we transform the net of into a graph transformation b below finally we the graph of any unnecessary so to obtain a global graph transformation b below definition b labelled net a labelled petri net or net n is a pp t f mq with p a set of places ranged over by p t a set of transitions ranged over by t f pp t q y pt pq the flow relation and m the initial marking each transition t p t is labelled with an event e p e or marker the latter representing a transition we let x range over elements of p y t as usual x resp x is the resp of x a net is called safe if for all reachable markings no more than one token can appear in each place in which case the reachable markings including m are sets of places a net is extended if p p p t p t p f pt pq f in the second step we transform a petri net obtained from algorithm into a petri net whose initial marking consists of exactly one place this allows us to construct a global graph that has a unique starting point source transformation b net given a labelled petri net n pp t f mq the net of n is n pp y t y f such that p r p t r t is labelled by and f f y y proposition b transformation b is computable in linear time in the size of m we can now state the following result the soundness of transformation b lemma b if t is the reachability graph of the petri net n obtained from via the algorithm in and t is the reach ability graph of the petri net obtained after applying transformation b then t « t next transformation b ensures that parallel are used as much as possible in the graph instead of choice and parallel in fact transformation b joins sets of places having the same or to decrease the number of choice transformation b net the net of n pp t f mq is a net n pp t f mq such that the following transformations are applied repeatedly for all maximal x p st x and p p p x p p p p and t t with p r p and t r t and labelled by also chosen p p x f p p t q y pp t y u x q y f z x for all maximal x p st x and p p p x p p p p p y and t t y with p r p and t r t and labelled by also chosen p p x f pt p q y pt p u pq y px tt y f z x note that the definition of f does not depend on the choice of p proposition b transformation b is computable in polynomial time in the size of n since we are working with safe nets we have the result below lemma b if t resp t is the reachability graph of the petri net n obtained after transformation b resp transformation b then t « t definition b graph composition let ni ti fi mi q with i p t u be two nets and gi ai two graphs such that vi pi y ti y fi i p t u the composition of g and g denoted by g z g is a graph xv a y defined as · v tv p v v p f v r vu y tv p v v p f v r vu · a q xv v q y dv p fi pv p ai pv p a j i j p t uu intuitively the composition of the graphs consists of the union of the two sets of except flow elements and pt pq if they appear in both v and v and the union of the two sets of arcs between in v and each pair of arcs of the form pv px or xq is replaced by a single arc pv transformation b graph the graph of n pp t f is a tuple xv a y such that v yf is a labelling function such that v if v p p y f or v p t labelled by and p e y t u otherwise and a is given by z where given x p p y t def def x px xq px xq x xq x xq x x px xq px xq x px px if x h if x if x tx if x h if x if x tx with k if x p p and if x p t the graph of figure is given in figure right observe that all the of the form px xq corresponding to an element of the flow relation are removed as part of the graph composition definition b proposition b transformation b is computable in polynomial time in the size of n we define the final transformation which up a graph by removing unnecessary and arcs transformation b a global graph g xv a y is obtained from a graph xp y t y f a y by applying the following transformation replace each pair of transition px pq pp xq p a by px xq p a replace each pair of transition pt xq p a with t labelled by by px xq p a and label each t which is la by qr s Ñ r aq in n by s Ñ r a proposition b transformation b is computable in polynomial time in the size of n 