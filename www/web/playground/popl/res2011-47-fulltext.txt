modular instruction selection using a typebased tiling of lowlevel intermediate code ramsey department of computer science university department of computer science university abstract we present a novel variation on the standard technique of selecting instructions by tiling an tree typical compilers use a different set of tiles for every target machine by analyzing a formal model of computation we have developed a single set of tiles that is while the expressive power of machine code using this we reduce the number of required from one per machine to one per family eg register architecture or stack architecture because the is the part of the instruction selector that is most difficult to reason about our technique makes it possible to an instruction selector with significantly less effort than standard techniques effort is further reduced by applying an earlier result which generates the implementation of our automatically from a declarative description of instructions semantics our design has the additional benefit of enabling modular reasoning about three aspects of code generation that are not typically separated the semantics of the compilers intermediate representation the semantics of the target instruction set and the techniques needed to generate good target code categories and subject descriptors d processors code generation d processors compilers general terms algorithms theory introduction since compilers were first written researchers have toward the goal of implementing n programming languages on m target machines with only on m work instead of the on × m work required to write a compiler for each language on each machine strong et al this goal has led to years of work on compilers and at the current state of the art the major on × m component of a compiler is the instruction selector which maps intermediate code to machine code we have developed a new way of selecting instructions which reduces n to the number of compiler and reduces m to the number of families supported our implementation supports one compiler infrastructure and two families register machines and stack machines permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm our compiler infrastructure is built on c an abstraction that an optimizing code generator so it can be reused with multiple source languages and multiple target machines peyton jones ramsey and ramsey and peyton jones c multiple source languages by providing two main interfaces the c language is a target language for front ends the c runtime interface is an api which gives the runtime system access to the states of suspended computations c is not a universal intermediate language or a intermediate language a defined compiler and runtime system and rather c compilation techniques that are well understood but expensive to implement such techniques include instruction selection register allocation implementation of procedure calling conventions instruction scheduling scalar optimizations and loop optimizations to a variety of source languages the c language is very expressive the implementation of a code generator for presents an challenge ensuring that the code generator accepts all valid input programs is harder than usual and the compiler writers job of mapping the language to code is than usual in this paper we present a new for computation which helps address both problems our work makes these contributions · we have developed a new variation on a standard model of computation register transfers by formalizing and analyzing register transfers we have found a way of register transfers into tiles where a tile represents a simple operation such as a load or a arithmetic operation section the decomposition is the same for every target machine and is implemented once · by contrast with current techniques which require a compiler writer to show that tiling is correct and complete for each new target machine our techniques require the compiler writer to show correctness and completeness just once per family we argue informally that our tiling algorithm is correct and complete for the family of register machines section · we show that the syntax and type structure of register transfers which are almost trivially simple nevertheless provide enough structure around which to design an instruction selector · finally our design enables modular reasoning about a code generator that quality code in particular we knowledge of the compilers intermediate code from knowledge of the target machine simplifying the task of the instruction selector to the point where most of the work can be done automatically and ramsey n a i figure ir for n ai n a i tiling for x n n m · · · add · a add · a i tiling for i our tiling for register machines figure multiple of the tree from figure background the problem we solve is the mapping from a compilers lowlevel intermediate code to target machine instructions instruction selection for a compiler that generates code for more than one target instruction selection should be easily related work instruction selection by tiling instruction selection is usually treated as a tiling problem for each target machine the compiler writer defines a set of tiles where each tile maps a tree of the compilers intermediate code an ir tree to an effective address or to one or more machine instructions using the tiles the instruction selector covers the tree so that the root of one tile is a leaf of another tile and so on such a covering is called a tiling traversal of a tiling produces a sequence of instructions that implements the tree figure shows an ir tree created by the compiler fraser and from the c assignment n ai where i is an unsigned integer n is a signed integer and a is a pointer to an array of signed integers if you are not familiar with ir suffix p or u indicates the result is a pointer or an unsigned integer assumes that all variables are in memory so a use of a variable is an node above an formal parameter or local variable node a later pass may convert some combinations to reg the example tree also includes constants operations add and an assignment in a typical compiler each target machine requires its own unique set of tiles or figure shows of the tree in figure using three different the lefthand tiling uses x the middle tiling uses the righthand tiling uses our which works for both x and as well as other typical register machines such as arm and our tiling instead of ir shows the ir used by our quick c compiler the tree is the same but the nodes are labeled differently in particular · labels a fetch from a variable given a there is often more than one way to tile a particular tree the way is computed by a tiling algorithm of which there are two common families bottomup rewriting and maximal bottomup rewriting often called or computes an optimal tiling a bottomup uses dynamic programming and it is usually built using a generator the compiler writer defines the tiles using a domainspecific language and the generator uses the tiles to build a bottomup tree and graham aho and fraser and fraser and maximal is a greedy tiling algorithm that works by topdown patternmatching on the ir tree appel the tiling may not be optimal but the algorithm is easy to implement by hand our compiler uses maximal is surprisingly complicated to the writing an instruction selector for a new machine seems simple just define a tile for each machine instruction but the task is more complicated than it seems · a tile does not describe an instructions semantics a tile might map a small ir tree to a machine instruction that implements the tree but it is not safe to assume that the instruction performs only the computation described by the ir tree for example it is common to have a tile that maps an addition operation to a machine instruction that performs not only the addition but also an extra assignment to a register to use such an instruction the compiler writer must reason about whether the extra assignments are safe · having one tile for each machine instruction may not be sufficient to generate code the instruction selector must be able to tile any ir tree consequently it is not possible to define a set of tiles without reasoning about what ir trees can be covered by the tiles for example on a bit machine there is no instruction that loads a bit immediate constant into a register if the contains only one tile for each machine instruction the compiler will not be able to generate code for an ir tree that loads an immediate constant the problem is an instance of a general problem to make sure that every ir tree can be covered the compiler writer must define tiles that map to sequences of machine instructions not just single instructions to discover these tiles its not enough to think about the instruction set the compiler writer has to think about the instruction set and about the structure of ir about what ir trees can occur during compilation · having one tile for each ir node may not be sufficient to generate good code to generate efficient code you might need multiple tiles that can cover the same ir tree using different machine instructions the x tiling on the left of figure shows two examples in which an addition is using something other than the obvious add instruction the small tile implementing · · · uses the x load effective address instruction which has a small binary encoding and which doesnt affect condition codes as another example the largest tile which performs a left shift an add and a fetch uses the indexed addressing mode to do the addition in the x addressing unit this instruction not only has a small binary encoding but also up an integer unit for some other computation parallelism these complications arise because the standard approach to instruction selection mapping ir fragments to machine instructions modular reasoning a compiler writer must reason about interactions among the compilers ir the target instruction set and the optimizer such reasoning requires broad worse for each new machine new tiles requires that similar reasoning be repeated using somewhat different but equally broad a modular approach to instruction selection to reduce the effort required to write a code generator for a new target machine we have developed a new modular approach to instruction selection our approach concerns about the compiler from concerns about the machine and concerns about lowlevel optimization we separate these concerns by the compiler in two ways we optimize code after translating ir to machine instructions and we divide tiling into separate and components related work optimizing machine codes to separate the concerns of choosing machine instructions and generating efficient code we adapt the approach developed by and fraser in this approach the compiler writer maps ir trees to machine code represented using lists also called rtls section rtls are later improved by an optimizer the optimizer is but it improves the program under the constraint that each rtl represents a single machine instruction the machine invariant the machine invariant is enforced by a predicate called the optimizing rtls does not rule out other optimizations that operate on ir trees or on even higherlevel representations but has shown that many optimizations which are typically performed on ir are better performed on rtls where they help generate particularly efficient code and to ensure that the compiler efficient machine instructions the optimizer includes a optimizer because the optimizer translates the machine code into efficient machine code this way of a compiler is sometimes called instruction selection by optimization and the optimizer is sometimes called the instruction selector this organization is used not only in compiler but also in gcc in and original design the mapping from lowlevel ir to rtls satisfying the machine invariant is done by a component called the code the is so named because it maps a typical ir tree to a long sequence of simple rtls expanding the code and fraser note that code are simple and easy to to implement to add a new machine compiler writers are to and modify the for a similar machine but since machines and have become more complex and having an for each combination of source language and target machine creates problems when bugs are discovered there is not a single point of truth about how to do the translation in our adaptation of the design the code is split into three parts · a part maps the compilers lowlevel ir to rtls that respect only the word size and byte order of the target the machine invariant · the described in this paper expands these rtls to rtls that to the shapes described in section below · a implementation which can be generated automatically and ramsey computes a representation of each shape using rtls that represent machine rtls that respect the machine invariant we changed and original design in a way we took a single component and split it into three this change although has a big impact the number of components that have to be maintained from n × m to n m and the m components can be generated automatically from declarative descriptions of the semantics a big of approach is that for producing efficient machine code is isolated in the optimizer the is responsible not for performance but only for mapping ir trees to simple machine instructions the of our output can be seen in figure compared to locally optimal quick c uses tiles instead of five this code is improved by the optimizer modularity through tiling of rtls body of work shows that we can build an compiler by first generating machine code then improving it but even when we dont need to generate good machine code writing a traditional still requires that we reason simultaneously about the semantics of machine instructions and about the compilers intermediate representation in this paper we show a novel alternative which supports modular reasoning · lowlevel ir may be translated to almost any welltyped rtls unlike earlier compilers which require that all rtls satisfy the machine invariant our compiler requires only that rtls respect the byte order and word size of the target machine this the front end from having to reason about the target instruction set · provided there is a rtls support optimization the reasoning about optimization from reasoning about the instruction set and ramsey show how to generate a from a description of instructions semantics · rtls are no matter what the source language if the source code can be compiled to a lowlevel intermediate representation that representation can easily be translated into rtls reasoning about the source language is therefore confined to the front end which rtls · part of our strategy of is to avoid highlevel types instead we use a type system that treats values only as bit vectors or booleans much as the hardware does section this simple type system leads us to the of our design a single that can be reused for any register machine section and a tiling algorithm that reduces controlflow graphs to that section · a compiler writer can reuse our and tiling algorithm unchanged for any register machine for each new target machine all the compiler writer has to do is implement our using machine instructions our tiles are simple enough that this process can be automated by using a generator and ramsey our is almost while not suitable for any machine it is suitable for any machine that provides roughly registers we have defined another for stack machines but it has been used only to generate code for the x floatingpoint unit using our modular approach it is significantly easier to add a new target machine because the doesnt change you dont have to design tiles and you know our will cover any ir tree even if you dont use our generator our experience shows that it is easy to implement the by hand finally our modular approach does not affect the code ultimately generated by the compiler like any other compiler our compiler generates code if and only if the optimizer used after instruction selection is of high quality using intermediate forms to improve modularity is standard practice examples include the java virtual machine and and llvm and some of these intermediate forms are very close to machine instructions our is not that the intermediate form is or lowlevel rather it is that · as described below the intermediate form is derived in a way from the type system of a metalanguage used to describe instructions semantics ramsey and · as described by and ramsey the intermediate form eliminates the need for the compiler writer to specify how each tile is implemented by machine implementations can be discovered automatically by heuristic search below we present the ideas that lead to our design we explain rtls section we discuss their static semantics section we analyze their types section we show how types suggest tiles section and we present a tiling algorithm section lists and controlflow graphs lists rtls provide a simple but precise representation of the effects of machine instructions a list denotes a function from machine states to machine states a machine state is represented as a collection of storage spaces each of which we with a letter for example on the popular x architecture we write m for memory r for generalpurpose registers f for floatingpoint registers x for registers and c for control registers including flags and the instruction pointer each storage space is divided into cells a cell is the smallest natural unit with which the hardware reads and writes the storage on the x for example the cell size is bits for memory bits for generalpurpose registers and bits for floatingpoint registers access to a register like al or ah is treated as access to an internal slice of a full cell like eax after program variables have been mapped to machine locations rtls are represented using the syntax shown in figure · a list is a list of guarded effects each effect represents the transfer of a value into a storage location ie an assignment the transfer occurs only if the guard an expression evaluates to true t effects in a list take place simultaneously as in statement an rtl represents a single change of state for example an rtl can represent a swap instruction without introducing temporaries · a location may be a single cell or an aggregate of consecutive cells within a storage space for example four bit bytes may be to form a location holding a bit word as in which specifies a word starting at address addr in an aggregate byte order is explicit some storage spaces stand for temporary registers or temporaries eventually the register allocator replaces temporaries with hardware registers and ramsey § · values are computed by expressions that have no side effects an expression may be a compiletime constant kw t or f a constant l a fetch from a location lw or an application of an rtl operator to a list of expressions a order or id c cell width of storage space e g expression guard g controlflow graph k literal integer or bit vector l location l label rtl operator type w width in bits rtl g effect g effect effect l w e l e kw t f l lw e en g rtl g g l goto e lt g lf figure syntax of rtls and controlflow graphs rtls are themselves composed into controlflow graphs g whose syntax is also shown in figure code includes the empty graph a single rtl or a sequence of graphs control flow is represented using labels and branches we take one with the syntax instead of writing l g we write the l g for conditional branches we use the nonstandard notation lt g lf which means the same as if g then goto lt else goto lf this notation makes the inference rules in section easier to read as part of instruction selection each conditional and branch in a controlflow graph is associated with a machine instruction which is represented by an rtl that assigns to the program counter pc for example a conditional branch is represented by an assignment like r pc l for computational instructions the pc is updated implicitly as formally specified elsewhere ramsey and a controlflow graph can represent any code from a single statement all the way up to an entire procedure body for example on a bit machine the c statement n ai could be translated to a flow graph consisting of the rtl n where bits × bits bits in contrast to rtls used in some earlier work cs rtls have a precise semantics independent of any particular machine the details are not relevant to the contribution of this paper but you can imagine the simplest possible denotational semantics · a syntactic location l denotes a function from a machine state to a hardware location holding a bit vector the location may be a single cell or a sequence of cells in a storage space · a syntactic expression e denotes a function from a machine state to a value which is either a boolean or a bit vector · a syntactic effect or a syntactic rtl denotes a function from a machine state to another machine state if two effects in the same rtl the same cell the parallel composition of those effects denotes the constant wrong function denotations are strict so if a computation goes wrong it wrong · an rtl operator denotes a pure function on values as usual the dynamic semantics describes the observable effects of a program these effects must be preserved by the tiling algorithm just as by any other instruction selector the algorithm however is inspired not by the dynamic semantics but by the static semantics n w n bits n loc bool a width variable a literal width the width of an address on the target machine a value that is n bits wide a location containing an value a boolean condition is a wellformed type n n bits n n loc wn w bits wn w loc bool n n i × × n figure types and rules static semantics of rtls our rtls are typed but not as as typed intermediate languages or assembly languages our type system tells us how wide something many bits are in a value or a location and whether an expression computes a bit vector or a boolean our type system is inspired by system f girard but it is both extended and restricted · our system is extended by allowing a type to be quantified over an integer the integer is a width and tells how many bits are in a value or in a location · our system is restricted in ways that might you of the hindleymilner system milner the only polymorphic types are type schemes and only rtl operators which are named and bound in the environment may have polymorphic types at each use a type scheme is fully instantiated so the type of any term in the rtl language from figure is always monomorphic types and rules are shown in figure rules for typing operators locations and expressions are shown in figure the side condition ws s says that storage space s is indexed by an an address or register number that is ws bits wide if s refers to main memory then s by giving two distinct rules for literal constants k we emphasize a design decision unlike many other intermediate representations our rtls do not distinguish signed integers unsigned integers floatingpoint numbers and pointers in this paper we k is an integer and we show two side conditions under which an integer k can be said to fit in w bits in our implementation a compiletime constant k has an abstract type and the side conditions are imposed by the operations used to create values of this type the important part of the type system is the specialization of rtl operators as shown in the judgment form op in this judgment represents the collection of operators defined in the c language specification ramsey peyton jones and this collection represents a union machine it includes any operator we think might be used to describe a machine instruction on a current or future target for example the collection includes which returns the number of bits in a word this operator is native to intel architectures on other machines we use algebraic laws to rewrite it as a composition of other operators much in the spirit of about all the operators we ever their us to our new tiling for code generation l e ws bits ws s c w w loc e ws bits ws s a big little c w w loc e k w kw w bits w k w kw w bits l l w loc lw w bits op × × n ei i e en op operator can be instantiated at type dom op op n op n w figure typing rules for locations and selected expressions rtl operators by type although the c language specification lists rtl operators floatingpoint operators and integer and operators these operators have only distinct types table before how these types help classify rtls section below we put the types into just groups · a standard value operator takes some bit vectors of reasonable width and returns a result of that width the width is typically the width of one word on the target machine these operators are summarized in the first two rows of table binary operators include addition and signed and unsigned division and remainder boolean operations and and shifts unary operators include complement negation population count and floatingpoint absolute value and negation · a value operator takes some bit vectors of reasonable width but also takes an argument or returns a result of another width such operators require special treatment during tiling most floatingpoint operators are value operators because in addition to their ordinary operands they take a bit mode the other value operators are extended which double the width of their operands operators like and operators such as carry add with carry and add with · a operator or a bit vector the integer operators are sign extension sx zero extension zx and extraction of bits conversions between integers and floatingpoint values and between floatingpoint values of different sizes ff are also operators operators help formalize machine instructions such as loads that convert values between representations of different sizes · a comparison operator takes two bit vectors and returns a boolean comparison operators include the usual integer and floatingpoint comparisons · a boolean operator takes one or more booleans and returns a boolean the boolean operators are and not these groups provide a starting point from which to classify rtls from graphs to tiles via types before how groups of operators influence the design of our we consider how to tile an arbitrary controlflow graph using a small set of tiles as explained in section below our tiling algorithm reduces every controlflow graph to a composition of graphs in which each node is either a single assignment an branch or a conditional branch on the results of a comparison operator but even a single assignment or branch can contain an arbitrarily large expression on the righthand side to tile these nodes we use a restricted subset of graphs where the restrictions are motivated by common properties of register machines section we then build on the groups of operators identified above to classify the restricted graphs and to identify tiles using a new idea we call shape section restricting graphs in the we would like as few graphs as possible to be tiles because the fewer tiles there are and the simpler the tiles are the easier it is to implement the but enough graphs need to be tiles to cover any single assignment or branch in particular because every rtl operator can appear in either an assignment or a branch we need at least one tile for every rtl operator we have designed our around a fundamental assumption about register machines if the target machine can compute operator then the machine can apply to arguments in registers and it can place the result in a register or if the result is boolean it can use the result to determine control flow we get our tiles by restricting the graphs and rtls from figure · a graph must be a single rtl a label goto l goto t or a conditional branch · an rtl must have exactly one assignment and its guard must be the literal t · if a graph or rtl refers to a memory location the locations address must be stored in a register a memory location is one in which the actual location can be computed at run time or at link time a register is a location that must be encoded in the instruction word at compile time · the arguments of an rtl operator must be in locations and except for operators those locations must be registers because putting a value into a register can be expensive we also permit that a argument may be a compiletime constant any single assignment or branch can be using these restricted graphs for example leaving and byte order implicit r r r × can be reduced to this sequence of tiles t t r × t r r t the reduction introduces fresh temporaries t and t to hold the values of subexpressions of the original rtl using types to give shapes to tiles the restrictions above still permit the formation of more than tiles to simplify both the explanation and the implementation of our we group tiles into equivalence classes we call shapes we except procedure calls not otherwise covered in this paper which both capture and update the program counter requiring two assignments type of operator number of operators nn bits × n bits n bits nn bits n bits nn bits × n bits × bits n bits nn bits × n bits × bits bits nn bits × n bits × bits n bits nn bits × bits n bits nn bits × n bits n bits nn bits bits n mn bits m bits n mn bits × bits m bits nn bits × n bits bool bool × bool bool bool bool sample add com carry round down sx ff eq not table types of selected rtl operators t m k l r rm rt any temporary or hardware register any hardware memory space any literal integer bit vector or other compiletime constant any label or other constant an rtl value operator a hardware register a floatingpoint mode a value like a carry bit in all or part of a register any rtl comparison operator table notational conventions for metavariables a shape is characterized by a controlflow graph in which locations literals and operators may be represented by the metavariables in table shapes for a register machine which are inspired both by our restrictions on graphs and rtls and by our of rtl operators by type are shown in figure the graphs with these shapes constitute our we have also defined shapes for stack machines such as the x floatingpoint unit these shapes are sketched in appendix a to simplify the presentation we omit nonlocal control constructs such as call and return we also omit some shapes that involve or a narrow result instead of storing it in a narrow location like a tile is a controlflow graph that can be obtained by substituting for metavariables in the tiles shape we replace the metavariable if any with an actual rtl operator of an appropriate type and we replace metavariables r and t by hardware registers or temporaries appropriate to the context in which they appear for example given the shape t tt we get a tile by using in place of and by using temporaries that stand for generalpurpose registers as another example the store tile might require an address or integer register for temporary t but should support any register t as the value to be stored tiling through a interface each shape in figure is labeled with a name the names identify functions in our interface which a implementation of every tile our instruction selector works as follows · the expects an input controlflow graph in which each node contains a welltyped rtl moreover the rtls in an input graph may contain only trivially true guards the cannot express nontrivial guards nontrivial boolean standard and value operators t tt t t t tt rm a binary operation a unary operation a binary floatingpoint operation t t rm a unary floatingpoint operation or conversion t tt a value operation like add with carry tt a operation like carry t t an extended multiply operation operators t load signed t load unsigned mt store data movement most tiles transfer exactly one word mt t t mt store load mt mt block copy any number of bytes t t t move t t k or t l li load immediate constant control flow including comparison operators goto l b branch goto t br branch register lt t t lf lf bc branch conditional figure shapes of tiles for a register machine expressions g appear only in conditional branches lt g lf if a target machine supports guarded assignments instructions the proper rtls can be found by standard optimizations after instruction selection · the covers each input graph with tiles for each tile the identifies the shape then calls the function in the interface which implements that shape the passes arguments which correspond to the metavariables shown in figure metavariables typically identify locations and an operator the function returns a controlflow graph that implements the tile this graph may contain rtls with nontrivial guards for example to get a controlflow graph implementing the tile r r t the would call r add r t the function would return a small controlflow graph probably containing one rtl representing an add instruction in the example the in add is the list of with which the polymorphic operator add is instantiated · the produces an output controlflow graph in which each node contains a welltyped rtl that is representable by a single instruction on the target machine the interface also associates each operator with a context which tells the what registers and temporaries may be operands or results of that operator implementation of the functions in the interface must be implemented for every target machine each function corresponds to a shape and must implement all tiles of that shape the implementation of a tile may have side effects not called for in the interface but these effects must be limited to cant be named by any to compiler temporaries the of the which registers are registers it is not difficult to implement a by hand but we have developed an algorithm for automatically generating a from a declarative machine description and ramsey although the problem is undecidable in principle our generator produces complete for the x and arm specification of a our takes as input a controlflow graph g and returns a new graph g which has the same observable effect as g but which is composed entirely of rtls that represent machine instructions as shown in the example tiling in section rtls in g may have side effects on locations not mentioned in g we therefore write the tiling transformation using the judgment form l gg which states that executing controlflow graph g has the same effect as executing graph g except that g may also any location in the set l as shorthand we say that g implements g graph g and set l satisfy important properties g is made from tiles l contains all the locations assigned by g which we write and includes any locations in l that are not in must be registers or compiler temporaries which cannot be observed by a program so that g and g have the same observable effect these properties are established by reasoning we represent calls to the interface by a very similar judgment g l m g says that graph g implements graph g and moreover every rtl in g is implementable by a single instruction on the target machine m the l m relation is significant for another reason judgment g l m g appears only when g is a tile the satisfies two properties · soundness if g l g then g is equivalent to g modulo assignments to locations in l · machine invariant if g l g then g contains only rtls implementable on the target machine these properties follow by inspection of the rules the would satisfy a third property · completeness if g is composed of welltyped rtls that use operators only at the word size of the target machine then there exist a g and an l such that g l g like most compiler writers we dont prove that our code generator is complete instead we follow typical best we reason informally about the completeness of the and we that reasoning with tests one advantage of our approach is that we have to do the reasoning just once and the results apply to any register machine the current state of the art is that the completeness of an instruction selector must be established once per target machine the restriction on of integer and operators can be relaxed to permit values smaller than a machine word and ramsey par g l l e i l l g l e · · · ln en l l l l g g l e · · · ln en l t fresh g t e l e · · · ln en l t l g l e · · · ln en seq l l g g l g g l l l g g g g figure rules to eliminate parallel assignments and sequences techniques for proving completeness would represent a significant advance over the state of practice an even greater advance would be to formalize the idea of family and to prove completeness for an entire family both problems are beyond the scope of this paper the rest of this section presents rules for the tiling transformation although and byte order play a role in the tiling they the of the algorithm so we omit them except when they are crucial this treatment is consistent with the treatment of and byte order in the c language itself a infers when possible so they are needed in surface syntax are also inferred in our machine descriptions ramsey and similarly byte order is fixed for each storage space and so is inferred from the space reducing graphs to rtls a single assignment can be covered by tiles whose shapes are given in figure but as noted in section an rtl can contain more than one assignment to be able to express the semantics of machine instructions rtls must be able to express parallel assignments in c we have chosen to make that expressive power available to front ends our compiler must therefore handle parallel assignments one way to handle a parallel assignment is to present it to the if the rtl is accepted it satisfies the machine invariant and it need not be if the does not accept a parallel assignment we use the rules in figure rule par takes a parallel assignment extracts a single assignment l e and executes it before the remaining assignments this transformation preserves semantics only if an important side condition holds for all i the value of ei does not depend on the contents of l the rule uses the slightly stronger condition l where writing between two sets means they are disjoint the stronger condition requires in addition that graph g which computes l e does not reuse temporaries that appear free in ei there is an additional side condition that graph g does not change the value of l because parallel composition of assignments is associative and commutative rule par can be applied to a parallel assignment as long as some location li can be changed without the value of any other expression e j j i otherwise all assignments have cyclic data dependencies and we apply the rule which breaks a cycle by introducing a fresh temporary finally the seq rule shows that graphs in a sequence are independently this rule expresses a standard technique additional locations modified by g beyond what g modifies may not affect values computed in g and similarly g may not any observable locations modified by g rules for value operators to tile a single assignment of a value operator figure we use the first group of shapes in figure the rule is representative its task is to tile the assignment t e e the first step is to allocate fresh temporaries to hold the values of e and e and to tile those rtls recursively producing graphs g and g the side condition l ensures that graph g does not any location on which the value of e depends then the judgment g l m t tt calls the interface to get a implementation of the binary operator the result of the tiling is the sequence g g g all of the rules in figure work along similar lines but a few are in rules through we use to indicate values that is values that the same width as a register for example in the rule expression e denotes an ieee floatingpoint mode rm which is only two bits wide the temporary t means something a little different t stands for a standard register containing the value of e in its least significant two bits in the rules carries and are treated similarly our does some extra work not shown in the rules it keeps track of whether the high bits of register t are zero are copies of bit or are unknown our uses this information to tile and operations more efficiently the last rule in figure is the rule which handles operators an extended multiply takes two operands of equal width and produces a result of twice that width in hardware that result is expected to be split over two registers as enforced by the interface in the judgment g l m tt in c however it is not possible to express an assignment of a single result to a register pair so in a welltyped rtl the assignment must be to memory the addresses of the most and least significant words and depend on byte order rules for tiling operators to tile a single assignment of a operator we use the second group of shapes in figure we show rules for integer operators only there are similar rules for changing the sizes of floatingpoint values and for converting between integer and floating point our intermediate language uses integer operators in two contexts when bytes or etc between registers and memory figure and when small values between hardware registers and ordinary registers figure both groups of rules use the same techniques when a value from a narrow location to a wide location the value must be or when a value from a wide location to a narrow location only the least significant n bits are both groups of rules allocate fresh temporaries to hold the values of subexpressions which are recursively rules for tiles to tile a single assignment figure we use the third group of shapes in figure rules store and load tt fresh nn bits × n bits n bits l g t e l g t e l l g m t tt g g g l ll t e e t fresh ll nn bits n bits g t e g m t t l l g g t e fresh nn bits × n bits × bits n bits g l t e l g t e g l t e l g m t l l l lll g g g g t e e e tt fresh nn bits × bits n bits l g t e g l t e l l g m t tt l ll g g g t e e fresh l nn bits × n bits × bit n bits g t e l g t e g l t e l g m t l l l lll g g g g t e e e fresh nn bits × n bits × bit bit l g t e l g t e g l t e l g m t l l l lll g g g g t e e fresh nn bits × n bits × bit bit l g t e l g t e g l t e l g m t l l l lll g g g g t e e fresh nn bits × n bits n bits l g t e l g t e l g m tt l g e n e n l l l l lll g g g g me e e figure tiling rules for standard and value operators l g t e t fresh l g m t l l g g t l me l g t e t fresh l g m t l l g g t l me tt fresh l g t e l l g t e l g m mt l l l g g g me figure rules registers memory l g m t l g t l g m t l g t t fresh ll g t e g m r l l g g r figure rules registers small registers transfer words between registers and memory rule copies data from one memory location to another and it is not limited to a single word a block copy can move any number of bytes where a byte is the cell size of the memory space rule moves a word between registers rule li loads a compiletime constant into a register and rule loads a constant into a register finally rule accounts for hardware restrictions on registers and operators for example if the result of an integer computation e is placed in a floatingpoint register t the introduces a fresh integer temporary t to hold the result of the integer computation use of rule reduces the burden on the of the although the implementation must include a tile for every rtl operator see for example rules and it is sufficient that for each rtl operator there is some set of registers in which the can place the operands and there is some set of registers in which the can expect the result it is not necessary to implement so many tiles that the result of any operator can be placed into any register our interface includes a mapping from each rtl operator into a data structure which identifies what kinds of registers or temporaries may be used as arguments and results for that operator tiling control flow to tile control flow figure we use the final group of shapes in figure as with sequential control flow in figure the rules in figure express standard techniques for example if the target of an branch is known statically store tt fresh l l g t e l g t e l g m mt t l l l g g g me e load l g t e t fresh l g m t mt l l g g t me l me tt fresh l g t e l me l g t e l me l g m mt mt l l l g g g me me l g m t t l g t t li l g m t k l g t k l g m t l l g t l t fresh ll g t e g m t t l l g g t e figure tiling rules for data movement l g m goto l l g goto l l t fresh g t e l g m goto t l l g g goto e compare tt fresh nn bits × n bits bool l g t e l g l t e l g m lt t t l l l g g g lt e e lf lf figure rules for tiling control flow we use the goto l tile otherwise we use the to put the address into a fresh temporary t then use the goto t tile which typically corresponds to a branch register instruction the interesting rule in figure is the compare rule it applies only when the condition is a comparison but in general a condition can be any boolean expression if we look at the last block of table on page we see that a boolean expression can be produced not only by comparison operators but also by boolean constants or operators the rules in figure show how to reduce any conditional branch to a controlflow graph in which every branch is either or is on the results of a comparison these rules formalize standard techniques used when true l g m goto lt l g lt t lf false l g m goto lf l g lt f lf not l g lf e lt l g lt note lf l fresh l g l e lf l g lt e lf l l l g l g lt e lf l fresh l g lt e l l g lt e lf l l l g l g lt e lf figure rules to eliminate boolean operators ing boolean expressions in a controlflow context by considering every rtl operator whose return type is bool we can be that these rules are complete we have formulated the compare rule in a way which over the fact that a node in a controlflow graph must be reduced to a sequence of machine instructions the compare rule shows an controlflow graph in which the true and false labels lt and lf are treated but the bc shape in figure does not treat the labels when the condition is not true the shape through to the successor instruction the judgment g l m lt t t lf actually provides two tiles one of which is chosen when the flow graph is the graph may be either as lt t t l l goto lf where l is fresh or as lf t l l goto lt where l is again fresh each of these uses a tile of the bc shape and a tile of the b branch shape the basic blocks of a controlflow graph are using a reverse depthfirst traversal which in most cases allows the to drop the fresh label l and the branch informal argument about completeness our addresses a different problem from the instruction selectors found in most compilers most problems start with a known source language and an intermediate code to that language and all programs in the source language must be compiled but c is not a source language it is a lowlevel target language for compilers it lowlevel intermediate codes used in compilers but it is not to any particular source language rather it is to express consensus on floatingpoint computation integer computation and words of any width our problem starts with an unknown source language which to a subset of c which we must tile to machine instructions we do not expect to compile all welltyped c programs for example a program that uses bit bytes and bit arithmetic may be well typed but we cannot compile it we compile only code that respects the size byte order and word size of the target machine for example code intended to run on the should use bit cells bytes in memory loads and stores and bit rtl operators code intended to run on a should use bit cells words in memory bit loads and stores and bit rtl operators with integer and operations we are more flexible a compiler pass called the converts narrow operations to operations at the word size of the target machine for example the can translate bit code to bit code while sign extensions and zero extensions and ramsey if a controlflow graph g contains only welltyped rtls which use the proper memory size byte order and word size and which have trivial guards our reduces g to tiles and to machine instructions we argue by structural induction over the graph section shows how sequences and parallel assignments are reduced to individual graphs and single assignments section shows how a controlflow graph containing a nontrivial guard is reduced to tiles the most complex part of the induction is over assignments given only value operators and data movement our rules cover all the type schemes of all the c operators a new rtl operator can easily be added without changing the provided the operator has the same type as an existing rtl operator in all cases the side conditions on l can be satisfied by choosing a combination of fresh temporaries and registers the difficult part of the argument lies with operators we believe that our is complete for c programs in which values are or to at most the word size and low bits are extracted from words not from larger values unfortunately these restrictions rule out cases of practical interest for example on the it can be necessary to convert a floatingpoint number to a bit integer then transfer the most and least significant words of that integer to two bit integer registers this case is supported by the quick c compiler but we do not have a general algorithm for translating operators when operands or results are larger than one word so the tiling rules for this case are omitted from this paper discussion our main result is a and tiling algorithm that can be used with any register machine the and algorithm are implemented in our quick c compiler as are a similar and algorithm for stack machines experimental results are good although they reflect the of quick cs optimizer our generated code code generated by or by gcc with optimization turned off but it is not as good as code generated by gcc with optimization turned on details of these results have already been published and ramsey our results together with and that standard scalar and loop optimizations can be implemented in a compiler very similar to quick c indicate that our could be used in a optimizing compiler our approach to instruction selection is built around two ideas · instead of designing a new for every target machine design a single that is reused for every machine in a big family · let the design of the follow from a formal model of computation rtls which expresses the consensus common to the family these ideas make it possible to reduce the work required to add support for new target machines the consensus common to the family of register machines includes flat memory addressing a word size and byte order and groups of registers these features are expected to be found in all possible targets and in those aspects our design is a classic intersection machine but our design also supports a rich and extensible set of computational operators and in that aspect our design is a classic union machine we establish the correctness and completeness of the tiling algorithm just once per family instead of once per target machine while about completeness can be difficult the work we do per show that our is implemented correctly and trivially easy the reduction in overall work represents a significant advance over prior art to illustrate the work we conclude by discussing how you might create an infrastructure add new languages add new target machines and add new optimizations and how our techniques together with those of and fraser will help you separate concerns to create an infrastructure you will define representations of rtls and controlflow graphs and you will define an interface that allows a front end to create controlflow graphs you will specify a interface for our if you wish to generate code for the x floatingpoint unit or for some other stack machine you will also specify an interface for a perhaps like the one in appendix a you will implement the and if you choose to generate components from declarative machine descriptions ramsey and you will implement a generator and a generator that understand your representation of rtls and ramsey to add a new language you will build a front end that translates your language to lowlevel imperative intermediate code for example if your language includes firstclass nested functions you will write a front end that performs closure conversion defunctionalization or some other translation to firstorder code your primary concern will be the semantics of your language but you will also need a of computation and your front end will need to generate code that matches the word size and byte order of the target machine you will be from all other details of the target machines instruction set to add a new target machine you will need to implement a and our for that machine you can do this by hand or you can generate a and an implementation of the from a declarative machine description your primary concern will be to know what instructions are useful and what their semantics are you will be from details of optimization and from the front end if your infrastructure generates the and the implementation of our you will also be from the details of your compilers intermediate representation and from the details of writing the and implementing the you may be able to reuse a machine description written by else to add an optimization you will write a transformation on rtls most likely your primary concern will be to implement a code one that can improve almost any rtl and so will be effective on many target machines but you may instead be concerned with implementing a transformation which is intended to be effective only on particular machines for example a transformation either way you will be from irrelevant details of the architecture the will ensure that your optimization preserves the machine invariant and is safe to run on any machine this plan of building an infrastructure and then adding to it incrementally which we have done with quick c does not require from established ways of doing things and it is not limited to a particular source language intermediate tation or target machine indeed our design can be thought of as a of a compiler and yet as with many good ideas in software design changes yield significant benefits our design front end from back end and ir from target machine to a degree not achieved in previous compilers when combined with automatic generation of components our plan offers a uniquely way of building quality compilers acknowledgments carefully the tiling rules improve the presentation the anonymous provided feedback about the presentation and the work in particular as review showed depth insight and attention to detail the work was by a grant from intel corporation and by nsf and references v aho and w k october code generation using tree matching and dynamic programming acm transactions on programming languages and systems ­ andrew w appel modern compiler implementation cambridge university press cambridge uk available in three c java and ml e and w july a portable global optimizer and proceedings of the acm sigplan conference on programming language design and implementation in sigplan notices ­ e and w march the advantages of global optimization in programming languages and system architectures lncs volume pages ­ springer verlag g g april automatic derivation of code generators from machine descriptions acm transactions on programming languages and systems ­ e october proposal for an communications of the acm ­ w and christopher w fraser october code selection through object code optimization acm transactions on programming languages and systems ­ and ramsey march converting intermediate code to assembly code using declarative machine descriptions in th international conference on compiler construction cc lncs volume pages ­ and ramsey january automatically generating back ends using declarative machine descriptions in proceedings of the th acm symposium on the principles of programming languages pages ­ christopher w fraser and david r a c compiler design and implementation christopher w fraser david r and a september engineering a simple efficient generator acm letters on programming languages and systems ­ christopher w fraser robert r and a april optimal instruction selection and tree parsing sigplan notices ­ girard the system f of variable types years later theoretical computer science ­ and llvm a compilation framework for program analysis transformation in proceedings of the international symposium on code generation and optimization pages ­ tim and frank java virtual machine specification addisonwesley second edition robin milner december a theory of type polymorphism in programming journal of computer and system sciences ­ and l graham january optimal code generation for expression trees an application of theory in conference record of the th annual acm symposium on principles of programming languages pages ­ simon l peyton jones ramsey and september c a portable assembly language that supports garbage collection in international conference on principles and practice of declarative programming lncs volume pages ­ springer verlag a june simple and efficient table generation proceedings of the acm sigplan conference on programming language design and implementation in sigplan notices ­ ramsey and march a approach to binary translation of delayed branches acm transactions on programming languages and systems ­ ramsey and w june machine descriptions to build tools for embedded systems in acm sigplan workshop on languages compilers and tools for embedded systems lncs volume pages ­ springer verlag ramsey simon peyton jones and february the c language specification version see ramsey and simon l peyton jones may a single intermediate language that supports multiple implementations of exceptions proceedings of the acm sigplan conference on programming language design and implementation in sigplan notices ­ and ramsey april widening integer arithmetic in th international conference on compiler construction cc lncs volume pages ­ j strong j h a j r and t the problem of programming communication with changing machines a proposed solution part communications of the acm ­ s addisonwesley a shapes of tiles for a stack machine these shapes are used in our for the x floatingpoint unit the stack pointer is st and the stack grows downward standard and value operators f st f st f st f st f st st st f st f st rm rm f st f st f st rm st st rm operators mt f st st st store pop f st mt st st push mt f st rm st st store pop rm f st mt rm st st push rm data movement most tiles transfer exactly one word mt f st st st f st mt st st f st k st st store pop push f st k st st control flow including comparison operators lt f st f st lf lf bc stack 