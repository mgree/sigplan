a typedirected abstraction refinement approach to higherorder model checking j university of oxford robin p university of oxford ch university of oxford abstract the model checking problem for higherorder recursion schemes has become a widely studied object in connection with the automatic verification of higherorder programs the problem is hard despite considerable progress in recent years no decision procedures have been demonstrated to scale beyond recursion schemes that more than a few rewrite rules we present a new polynomial time algorithm based on a novel type directed form of abstraction refinement in which behaviours of a scheme are distinguished by the abstraction according to the intersection types that they the properties that they satisfy unlike other intersection type approaches our algorithm reasons both about acceptance by the property automaton and acceptance by its dual simultaneously in order to minimize the amount of work done by on the solution to a problem instance from both sides we have constructed a prototype implementation of the algorithm and an extensive body of evidence to demonstrate that the algorithm readily to recursion schemes of several rules well beyond the capabilities of current higherorder model checkers categories and subject descriptors f d keywords higherorder model checking intersection types abstraction refinement introduction higherorder model checking or the model checking problem for trees generated by higherorder recursion schemes hors is a widely studied decision problem in connection with the theory and practice of the verification of higherorder programs since hors are simultaneously very expressive wellbehaved and able to accurately model higherorder control flow they are an target for algorithmic verification procedures for functional programs indeed in a precise sense hors are the higherorder analogue of boolean programs which have a very successful role in the verification of first order imperative programs permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm it is for these reasons and despite the worstcase complexity of the problem that several algorithms have recently been developed with the aim of solving the higherorder model checking problem for many practical instances however the state of this effort is well by the authors of the model checker can handle a few lines of hors generated from various program verification problems it is however not scalable enough to support automated verification of or of lines of code thus obtaining a better higherorder model checker is a challenge in the field our main contribution is a new algorithm for higherorder model checking and a large body of evidence to show that it well to hors consisting of several rules in contrast the largest instances considered in the literature to date are of the order of several rules by way of an example the order benchmark g of kobayashi which consists of rules can be processed by our prototype implementation in less than one our algorithm which the hors model checking problem with respect to alternating trivial tree automata has been designed to be scalable since the inherent worstcase complexity of hors model checking is extreme to have any at all of solving nontrivial instances one has to work in the that those instances that are met in practice are not hence it is essential to ensure that only work that is relevant to deciding the particular instance at hand is actually computed to help achieve this goal our algorithm is designed in the abstraction refinement paradigm initially a relatively but approximation to the problem is processed and as much as possible detail is only added by successive iterations where the problem instance it moreover it can be shown that our algorithm is polynomial time in the size of the scheme the parameters that are fixed are the order and arity of the scheme and the size of the tree automaton our algorithm exploits the of higherorder model checking as an intersection type inference problem representing the state of knowledge about the behaviours of the recursion scheme as a pair of type environments called the context which assigns intersection types to the nonterminals of the scheme as the algorithm the number of types and hence state of knowledge in the environments increases until after some finite number of iterations there will be enough type information to decide the property one way or the other furthermore this limit context will form a certificate of the decision that is independently by intersection type checking complete for recursion schemes of order n in order to gain more information and thus the context each iteration consists of constructing a sound abstraction of the configuration graph of the scheme since recursion schemes have no facility to the data that they operate over the behaviours of the scheme arise from the complex interactions between higherorder functions hence we have designed this abstraction around a traditional cfa but with an important in our abstraction parameters to function calls are distinguished according to the intersection types that they in other words according to the properties that they satisfy this is in turn a function of the context and hence as the algorithm and the size of the context increases so the abstractions become more precise as they are able to distinguish more instances of function calls such an abstract configuration graph is a concise but approximate representation of all the possible reduction sequences of the scheme through its analysis the algorithm can classify certain behaviours that can be seen to generate trees that are accepted by the property automaton and certain other behaviours that can be seen to generate trees that are rejected by the property automaton from the former it is able to extract new acceptance types and from the latter new types and both are added to the context ready to proceed with the next iteration indeed a key feature of the algorithm and a among intersection type based decision procedures is that it uses types to reason both about property automaton acceptance and simultaneously we have implemented the algorithm in a tool and evaluated its performance over the several problem instances that are now either recorded in the literature or which have from verification tools for higherorder programs these instances range from a few of rules to several and from first order schemes up to fifth order and a few beyond the results show very clearly that is sometimes a little slower than other model checkers on examples up to around one rules its great strength is in solving examples of many of rules where it performs consistently better than other model checkers and several of rules which are typically instances that it alone can solve outline the rest of the article is structured as follows in section we fix notation and preliminary definitions in section we give an informal outline of the algorithm by means of an example in section the algorithm is defined formally in section we discuss our prototype implementation and present a digest of the empirical evaluation and associated analysis in section we discuss related work all proofs of claims in the text are to the appendix of the long version of this work which also includes a run of the algorithm on a second example instance and a full of the empirical evaluation we assume throughout a set f g h f of function symbols and a disjoint set x y z v of variables labelled trees let a be a set without restriction an tree is a partial function t n a whose domain is prefix closed in case the set a is that is each symbol a a has a specified arity n then the tree t can be said to be just if whenever t w a and n then w · i iff i n simple kinds the simple kinds over the kind of trees o denoted s are formed by the grammar o as these are nothing more than the simple types over the base type o but we prefer to use the word kind to avoid conflict with intersection type later usual we use parentheses to the structure of such expressions observing that the arrow associates to the right the arity and order of a simple kind are natural numbers defined as usual if a simple kind has order and hence has arity we say that it is ground raw terms let a b c be a set of atomic constants the set of raw terms over denoted s t u v tf v is defined by the grammar s t x f c s t the free variables of a term t denoted is just the set of variables that occur in t a term t with empty is called closed and the set of all closed terms is denoted tf we denote the set of closed terms which moreover contain no occurrences of function symbols by t in case the atomic constants are said to be kinded we assert that there is an associated function kind which maps each constant c to a firstorder kind in s kinded terms a kind environment is a finite partial function from v f to s a kind judgement is an expression of the form t we omit the standard definition of kind assignment to terms ie simple type assignment recursion schemes a higherorder recursion scheme hors g is a tuple n r s in which · the alphabet of terminal symbols a b c is a finite set of firstorder kinded constants · the alphabet of nonterminal symbols f g h n is a finite set of kinded function symbols disjoint from we will sometimes view n as a kind environment mapping nonterminals f n to their kinds · the rewrite rules r a function mapping each nonterminal symbol f of kind · · · n o to an expression x · · · xn t such that x · · · xn n t o is a provable assignment of kinds to terms we will often write f x xn t r as an equation f x xn t · the start symbol s n is a nonterminal symbol of kind o each recursion scheme is assigned an order which is given by the maximum order of the kind of its nonterminal symbols recursion schemes have a simple notion of reduction which is defined as the contextual closure of the following rule rf x · · · xn t f s · · · sn for the purposes of model checking we are interested in the trees generated by the scheme the value tree of a scheme g denoted is the possibly infinite term tree obtained by reducing the start symbol ad to account for the possibility of infinite recursion the value tree is defined as follows first introduce a new symbol of zero arity into and consider the least of that asserts a for all a next for each closed term t of ground type define t recursively by i f s · · · sn and ii a s · · · sn a s · · · sn this mapping sends each term to tree in the complete partial order of labelled trees which are ordered by letting t t just if for all t t finally we set t s t example consider the firstorder scheme over terminal symbols a o o o b o o and c o in which the nonterminal symbols s o and f o o are defined by the equations s fc f x a x f b x by reducing ad the start symbol s generates an infinite a b and tree a prefix of which is depicted on the right this tree has no labelled nodes since every redex contraction produces a new terminal symbol in head position a ca ba cb b c positive boolean formulae given a finite set x the positive boolean formulas over x denoted bx are defined by the grammar t f x given a positive boolean formula an assignment is a finite subset s of x an assignment s is said to be a satisfying assignment for written s when assigning t to elements of s and f to elements of x s makes true alternating tree automata an alternating tree automaton a is a tuple q q f in which is a finite set of constants q q is a finite set of states the transition function is a function in · × q the initial state is q q and the accepting states f are either all of q or empty in case f q we say that the has a trivial acceptance condition otherwise f and we say that it has a acceptance condition more often than not we will simply introduce a given automaton as a trivial or a automaton and omit the final component furthermore when specifying particular automata we will clauses of the transition function whose image is f given a and labelled tree t a run tree of a on t is a × tree r satisfying apt r q apt for all w n if rw w q then there is some set s that satisfies q t w and for all i q s there exists some j n such that rw · j w · i q we say that a run tree r is accepting just if on every infinite branch of r there is some state q f which occurs infinitely often the language of an a la is the set of and labelled trees t for which there exists an accepting on t we define the complement of a denoted ac by the standard de morgan dual construction which ensures that note the dual of an with a trivial acceptance condition is an with a acceptance condition example consider the over the states q q q and q in which the transition function is defined by the following clauses q a q q q q b q q c t q a q q q q b q this accepts those trees that q q have an infinite spine and of every two consecutive branches off the spine at least q one is required to be labelled by an even number of b nodes terminated by a c a prefix of the run q tree over the tree generated by the scheme in example is depicted q to the right q higherorder model checking we define a as the a augmented with extra transitions so as to accept the symbol from every state the checking problem for hors is given a hors g and an a to determine the truth of the assertion la intersection types in what follows fix an a we consider intersection types as is usual in the higherorder model checking literature we make a distinction between strict types and intersection types the terminology from van the intersection types over a denoted ia are defined simultaneously with the strict types over a by the following grammar strict types q intersection types n i i in which q q and n we will use and to denote strict and intersection types respectively when we are about whether a particular expression is either a strict type or an tion type we will say it is simply a type and denote it by when no confusion can arise we will typically write for the empty in an intersection containing two elements infix as and an intersection of the singleton set containing simply as given an intersection n i i we will often identify with its set of conjuncts n writing assertions such as and with the obvious interpretation finally we shall have no about constructing the intersection of intersection types since this can be given naturally as the intersection of the union over their respective strict conjuncts intersection subtyping there is a natural subtype preorder on intersection types which was first explicitly considered by barendregt and in we shall use the following variant defined inductively by the following clauses q q if and then for all i n n j j i if for all i n i then n j j if and then intersection type environment an intersection type environment is a finite partial function from f v to ia we will often view type environments as total functions assigning f whenever f dom we will write for the operation sometimes called type environment multiplication which is just the pointwise combination of environments defined by f f f and write just if there is some and we will write x for the restriction of to only those typings whose subject lies in x finally we also extend the subtype relation to environments pointwise writing just if dom dom and for all dom intersection type assignment an intersection type judgement is an expression of the form t with a strict type whose derivations are defined inductively by the system in figure note that in that system we use the notation si to denote the set q i q s given a type environment and a term t we define the set of all strict types to t under by tt t the type system is induced by the property automaton a which features in the premise to the rule this rule acts to give a meaning to intersection types that can be thought of as follows each base type q is the type of all terms t that generate via infinite x n i i x i f n i i f i s q c c s · · · sn q s t st figure assignment of types to terms reduction trees that are accepted by the automaton from state q an intersection such as q q is the type of all terms that generate trees that are accepted both from state q and from state q finally an arrow such as q q q is the type of those terms which when applied to a term that generates a tree accepted from q and q will as an application generate a tree accepted from state q in this work we will be concerned both with type assignment in the intersection type system induced by property automaton a and type assignment in the intersection type system induced by the dual of this automaton ac hence whenever needed we will try to which notion of type assignment we are referring to by annotating the notation with a or ac intersection refinement types the intersection refinement types over q are those types for which there is some kind such that refines is provable in the system of kind assignment below the strict refinement types over q are defined as the obvious restriction of this system we lift the refinement relation to environments by writing just if for all f there is a typing f and type environment consistency we say that an intersection type environment is just if for each typing f such that f there is a possibly infinite witness rooted at f and built according to the following system rf x xn t x x n t q g g f · · · n q f ··· n f n f n i i similarly we say that an intersection type environment is just if for each typing f there is a strictly finite witness built from the above system the next theorem follows from kobayashi and theorem fix a scheme g and a i la iff there exists g n and q s ii iff there exists g n and q s type directed abstraction refinement the starting point for the algorithm is the of the trivial automaton model checking problem for recursion schemes given in theorem our algorithm tries to prove a q o i i n n i i figure assignment of kinds to types la and b simultaneously by iteratively constructing two type environments and which are possible witnesses to a and b respectively since an invariant of the algorithm is that is always g and is always g it follows that at most one of the two environments can prove the type assignment s q in fact upon termination exactly one of the two will do so since the two type systems a and ac share the same underlying set of types let us call an intersection type an acceptance type when we regard it as part of the system a and let us call it a type when we regard it as part of the system ac the algorithm starts with which is trivially on each iteration new type assignments are in which will be added to one or the other of the environments the way that these new types are inferred is by on each iteration constructing and an auxiliary structure called the ab configuration graph as its name suggests this graph is an abstraction and the precision of the abstraction is a function of the size of the type environments and the more precise the abstraction the more useful the type information that can be de by it hence starting from the empty context c the abstraction refinement cycle continues as follows in iteration i with context ci i i the abstract configuration graph is constructed two subgraphs are then out called the accepting and regions these regions are the parts of the graph from which it is possible to obtain consistent ac typings and typings respectively types are then extracted from the regions and added to context ci to form a strictly larger context ci i i if one of these two environments can already type s q then the algorithm terminates otherwise the cycle and since ci is strictly larger the abstract configuration graph constructed in iteration i will be strictly more precise and new type information will be de since there are only finitely many intersection refinement types associated with a given scheme one of the environments will be eventually become saturated and thus witness the corresponding assertion a or b the configuration graph of a model checking problem instance was introduced by kobayashi and in it is a kind of product construction pairing up the reduction relation of the scheme and the transition function of the property automaton and it takes the shape of a rooted directed graph since we are solving the alternating trivial automaton model checking problem for sion schemes the configuration graphs that we are interested in are something in between the simple ones of which are to deterministic trivial automaton properties and the much more complicated ones of which are appropriate to alternating par ity automaton properties moreover we shall not be interested in the configuration graphs themselves which are in general infinite but rather in finite abstractions bindings y y y d b y d s q f d q a y b d f b y q y q b d q f b y q y q b d q b y q d q b y q f b y q figure an abstract configuration graph consider the following model checking instance consisting of recursion scheme g over the terminal symbols a and d and a trivial automaton a s fd f x a x b d f b x b z b z dd q d t q a q q q as described above the algorithm begins with the initial context c consisting of and in order to infer new type assignments it constructs the abstract configuration graph which is given in full in figure the construction of the graph starts at the root which is a vertex labelled s q every vertex of the graph is either labelled by a pair t q of a ground kind term and a state called a configuration or by a finite set of such configurations if there is a vertex t q in a graph then it should be read as neither a t q nor ac t q is provable hence the starting point for the graph is the fact that s q is not provable in the shape of the successors of a vertex if it has any depend upon whether the vertex is a configuration or a set and in case of the former the syntactic class of which its head symbol is a member in this case the root of the graph is a configuration and its head symbol is s which is a nonterminal hence the term part of this configuration is a redex in such cases the vertex has at most one successor and that successor represents the contraction of the redex the contraction of the redex s is f d and because neither a f d q nor ac f d q is provable it has a successor which is labelled by f d q since this vertex is of the same form it also has a single successor which represents the contraction of the redex however the situation is more complicated because this redex involves parameters it is along such edges that the abstraction happens rather than substituting actual parameters for formals in the successor formals are substituted by special variables which are used by the abstraction to represent sets of terms so we create a new variable y and make a note y d that one of the possible instantiations of y is d in this way we are always able to recover the real contraction a d b d f b d from the abstract one ay b d f b y by rewriting occurrences of the variables y using the bindings y d this ensures we are building a sound abstraction in the sense of all the behaviours of the original this kind of abstraction is in essence a traditional control flow analysis but here we go one step further which is critical in order to obtain completeness the extra step that we take is to record the acceptance type and type of the new variable y the acceptance type respectively type of y is just the intersection of types to the term that it has been introduced to represent in other words ta d respectively d the types of such variables will later determine when new variables should be created in order to represent actual parameters as y was here or if variables created previously should be reused the frontier of our construction so far consists of a terminal configuration the successors of a configuration of the form a s · · · sn q depend upon the satisfying assignments to q a for each satisfying assignment s there is one successor which is the set of configurations si q i q s in this case q a is satisfied just if the first argument of a is accepted from q the second argument is accepted from q and the third argument is accepted from q consequently the set is y q b d q f b y q such a set t q tn qn should be read as there is some i such that a ti qi is not provable the successors of the set are those configurations t q in the set which are not provable in either or so let us now consider the frontier configuration f b y q since it is a nonterminal configuration if it has a successor then the successor abstractly represents the contraction in the same way as before however since the actual parameter b y has the same acceptance type and type as the previous one that we considered d and is the same kind we will not create a new variable to represent b y but we will reuse the variable y that we used to represent actual parameter d so the abstract contraction is the term a y b d f b y and we form a loop in the graph to ensure the abstraction remains sound we note that another possible instantiation of y is b y but observe that this merging of vertices resulting from y has caused some loss of information now the term ay b d f b y represents many different concrete instances including some that are not possible in the original problem such as a d b d f b b d which results from rewriting the leftmost occurrence of y to d and the rightmost occurrence to b d the actual parameters d and b y have become because according to the current context c they have the same acceptance and types in this way types direct the abstraction and refinement will occur because type information in the context increases by contrast the vertex b d q has an actual parameter whose acceptance and types are nontrivial the terminal d has acceptance type q and type d q we have not yet created a new variable with those types so we do so now assigning the new variable y the acceptance type q and the type q we record that d is a possible instantiation of y and label the successor b y q following the same method this new vertex has itself as successor we to note that y is a possible instance of y but such trivial will make no difference to the outcome so we will omit it for brevity let us now consider the frontier vertex y q which is vari able at variable configurations the consequences of the abstraction are a vertex of the form y s · · · sn q has a successor t s · · · sn q for each binding y t for reasons that we have already discussed its child b y q has itself as a successor its other child is the vertex d q whose contraction is d q however because ac d q we do not add vertex d q to the graph and so d q has no successors we say that d q is a leaf this completes the construction of the abstract configuration graph we now consider any leaves in the graph leaves are configurations f s · · · sn q for which the correspond ing type assignment f s · · · sn q is not provable in either nor yet the type assignment associated with the contraction is provable in this points directly to a in the context in our example ac d q is provable so d is a tree rejected by a and d reduces to d in one step yet ac d q is not provable the environment to type d q since d generates a tree that is rejected by a but it doesnt hence we have discovered a new type assignment the vertices that we classify as representing typing assignments that to have been provable under the environment are called the region and from this region new types are extracted where the region is roughly speaking all the vertices that definitely can reach leaves the accepting region is all the vertices that definitely cannot reach leaves new acceptance types are extracted from the accepting region in this case the region is the single vertex d q and the accepting region is all the b configurations type extraction from the regions follows a similar approach to that defined in briefly a type is assigned to each prefix s of the term component of each vertex s t · · · tn q in the accepting region the type assigned to s is constructed by recursively computing the type assigned to t by considering all the ways in which t is used within the region the vertices where t is itself a prefix recursively computing the type assigned to the prefix st and then the arrow the base case is where the entire term component of the pair considered as a trivial prefix of itself is assigned the type q the region is handled similarly but care must be taken to only consider uses of t in vertices that are strictly closer to the leaves so that a well argument can be given in the end the type assignments to prefixes that are themselves nonterminal symbols are extracted and added to the appropriate environments in this case there is only one vertex in the region so its only prefix is assigned the type d q there are three vertices in the accepting region of which the prefix b of b d q is assigned acceptance type q q since d is known to have type q prefix b of b y is assigned type q since there are no uses of y in the region and for the same reason prefix b of b y is assigned the type q the new context is therefore c b q q q d q since the new context neither types s q as accepting nor as the process but this time with more type information so more of the parameters to calls will be distinguished in the second iteration the region is the entire graph consequently s q is added to the environment and the algorithm terminates correctly that the input is a an abstraction refinement algorithm we now present the algorithm formally we first give the definition of the key construction the abstract configuration graph we then describe how from the graph one can out the accepting and regions and the notion of type extraction appropriate to each finally we show how graph construction and type extraction come together to form a single iteration and we present the algorithm as the of this process assumption for the rest of this section assume a recursion scheme g n r s and an alternating trivial automaton a q q by an we will refer to the type system induced by a simply as a and the type system induced by ac simply as ac construction of abstraction the abstraction is based on a traditional cfa in the sense of reduction using an abstract environment an important on the usual formulation is that here every variable in the environment is associated with a kind and a pair of intersection types typed variables the main mechanism for abstraction will be a set of typed variables by means of an abstract environment to be described each variable represents the set of terms that can be obtained from it by repeated substitution each variable has three pieces of associated type information an acceptance type a type and a kind an essential part of the algorithm is in ensuring that type information is invariant across the abstraction ie if a variable abstracts a set of terms then every term in the set shares the same acceptance type type and kind as the variable according to the current context definition let us say that a kind is an argument kind just if there is some binding f · · · n o n and some i such that i let var be a bijection mapping the finite set of all triples of the form a r consisting of kinded types a and r where is an argument kind to a finite set of term variables y v given such a variable y y we will write ay for the first component of vary ry for the second and for the third type context the algorithm is ultimately concerned with constructing a pair of type environments such that is and we will of as the acceptance type environment and as the type environment furthermore we that every such pair of environments which we shall call a type context the basic assumptions we have made about the typed variables ie the type information contained in a and r as defined in definition but viewed as type environments for the typed variables is also contained in and respectively definition a type context c is a pair of intersection type environments for which the following conditions hold i n k ii n k iii for all y y y ay and y ry abstract configurations as mentioned in the previous section the abstraction itself is a finite representation of the possibly infinite configuration graph as defined by in this concrete configuration graph the configurations are pairs of a closed term a of the start symbol of the scheme and a state of the automaton and the edges that connect them must respect the constraints of both the reduction relation of the scheme and of the transition function of the automaton a configuration t q can be read as an assertion the tree generated by t is accepted by a from state q in the abstract configuration graph defined configurations are still pairs of term and state but now the term is abstract which in our setting means that it can contain free occurrences of typed variables definition an abstract configuration is a pair t q in which n y y t o is a term and q q is a state we say that a term s is a prefix of a term t just if t has the form s t · · · tn for some n n a configuration prefix is a pair c s in which c is a configuration of shape t q and s is a prefix of t abstract typability the central idea of the algorithm is that the type bindings contained in the context constitute a concise summary of all the information that has been about the scheme and its as far as acceptance by the property automaton is concerned we will use the type context to whether the assertions represented by configurations are true or not based on the following simple notion of typability definition let c be a type context and let t q be an abstract configuration we say that t q is just if a t q we say that t q is just if ac t q we say that t q is just if it is neither nor c rejected until the very last iteration of the algorithm the configuration s q which is the root of the abstract configuration graph will be to all the associated contexts c but after the last iteration enough type information will have been to the final context c in order that s q will be seen to be either c accepting or c abstract configuration graph the vertices of the abstract configuration graph are either abstract configurations or finite sets of abstract configurations viewed as an assertion a vertex which is a finite set of configurations s q sn qn should be interpreted ie as requiring that for each i n si generates a tree that is accepted from state qi definition an abstract configuration graph a is a tuple v e b in which v e is a directed graph and b is a set of mappings from variables y y to terms t ty n each vertex v v is either i an abstract configuration or ii a finite set of abstract configurations and edges e v × v are given a typing context c the abstract configuration graph of c denoted is the abstract configuration graph vc ec bc defined inductively by the system in figure the set b of bindings acts as the abstract environment for the purposes of defining the abstraction we consider motivation of each of the rules of the inductive definition in turn first the rule g defines the root of the graph the premise ensures that if we already know that s generates a tree that is either accepted from q or rejected from q then we need not do any state space exploration this kind of premise is common to many of the rules to ensure that work is not done in fact one can state an invariant about the abstract typability of the vertices in any abstract configuration graph lemma let c be a context for each configuration c vc c is in case s q were or the graph would be empty and the sequence of contexts will rule g simulates the contraction of a redex but it does so in an abstract way to apply the rule requires that a configuration f s · · · sn q containing a redex occurs in the graph the consequence is that an abstraction of the contraction of that redex is added as a new configuration however it is abstract because rather than substituting actual parameters for formals typed variables are substituted for the formals these typed variables must be appropriate for the that they abstract hence there is the constraint that if yi abstracts actual parameter si then it had better be that yi var si this ensures that type information is invariant across the abstraction in the following sense proposition let c be a type context for all y t bc and y t to properly define the abstraction in terms of the new variable yi a binding is added to bc with the effect that yi si consequently we may think that si is in the set of terms abstracted by yi rule g simulates a transition of the automaton on reading a terminal symbol if there is a terminal configuration a s · · · sn q in the graph then its children all of the possible satisfying assignments to q a expressed as g whenever all the following are true i s q is then all the following are also true · s q vc g whenever all the following are true i f s · · · sn q vc ii rf x · · · xn t iii n f · · · n o iv · · · q is v for each i n yi var si i then all the following are also true · · · · q vc · f s · · · sn q · · · q ec · for each i n yi si bc g whenever all the following are true i a s · · · sn q vc ii s q a iii for all i q s si q is not then all the following are also true · si q i q s vc · a s · · · sn q si q i q s ec g whenever all the following are true i s q sn qn vc ii i n iii si qi is not then all the following are also true · si qi vc · s q sn qn si qi ec g whenever all the following are true i y s · · · sn q vc ii y t bc then all the following are also true · t s · · · sn q vc · y s · · · sn q t s · · · sn q ec figure abstract configuration graph construction sets of configurations that each vertex that is a set of configurations should be thought of the children of a s · · · sn q taken as a whole should be thought of ­ a s · · · sn generates a tree accepted from state q just if all the configurations contained in some child satisfying assignment are shown to be accepted rule g simply set vertices into their constituent configurations therefore the children of a set vertex should be thought of finally rule g the on the abstraction by considering the case when a typed variable is in head position in a configuration in this case the binding set is and a node is added for each binding to the appropriate variable we will think of the children of such a vertex for y s · · · sn to generate a tree accepted from state q it had better be that every term that it abstracts generates a tree accepted from state q due to the abstraction at the point of contraction in g and the limited substitution only in head position in g is necessarily a finite construction in fact we can go further lemma let c be a type context then the size of vc is bounded by a polynomial function of the size of the scheme classification of leaves let us consider for a moment the leaves of for some type context c it follows from the definition that the leaves all have a particular form every leaf is a configuration by a nonterminal symbol ie a redex moreover each such redex if using rule g would yield a new configuration which is already known to be either or it is for this reason that such configurations are leaves g does not apply because the fourth premise would be violated definition given a type context c the leaves ie those vertices that have no children of can be classified into two sets accepting leaves these leaves are configurations of the form f s · · · sn q where rf x xn t for each i n there is a typed variable yi such that and a t y x yn xn q leaves these leaves are configurations of the form f s · · · sn q where rf x xn t for each i n there is a typed variable yi such that si and ac t y x yn xn q note that a leaf is not itself by lemma since it is in the graph it is necessarily but its is similarly accepting leaves are not themselves but the of an accepting leaf is lemma let c be a context every leaf in is accepting or the region region of the construction of an from a given type context c is a method for the type context by constructing the graph it is possible to see where the information in the type context is and the main tools for identifying and are the regions and region type extraction respectively consider a leaf v of the form f s · · · sn q by definition the contraction of this configuration using g would yield a configuration q which is already in other words the tree generated by any term of the form such that ti yi for each i is sure to be rejected from state q assuming that is this follows because necessarily ac q proposition one such sequence of ti are the actual parameters of the term component of the leaf we started with v hence because we know that the of the term part of v generates a tree that is rejected from state q necessarily the term part of v itself generates a tree that is rejected from state q so we have identified that v should be classified as but is not currently through analogous reasoning and the conjunctive and disjunctive interpretations of the child relation in the graph it is possible to identify other such vertices which are necessarily the collection of all such is called the region definition given a context c we define a subset vc of the vertices of called the region inductively r if c is a leaf then c r if s q sn qn vc and there exists j n and sj qj then s q sn qn r if f s · · · sn q t q ec and t q then f s · · · sn q r if as · · · sn q vc and for every v as · · · sn q v ec implies v then a s · · · sn q r if y s · · · sn q vc and for all y t bc t s · · · sn q then y s · · · sn q unless it is the final iteration of the algorithm the region will always be nonempty the fact that an absence of leaves is an absence of counterexamples in the abstraction is later in lemma type extraction the vertices in the region are those configurations that we have identified by constructing which should be classified by the context as but are not ­ each is necessarily since it belongs to the graph so the region represents a in the context to it from the region we will extract new type information to be added to the context ready for the next iteration definition let c be a typing context and v a witness to the membership of v in is a proof tree t rooted at the statement v and constructed according to the rules r ­ r we describe an assignment of type environments mt to proof trees t inductively on the shape of the proof m if the proof is by r then v is a configuration of the form f s · · · sn q and we set mt to be the single binding f ts · · · q m if the proof is by r then v is a set s q sn qn and for some j n there is an immediate t of sj qj we set mt mt m if the proof is by r then v is a configuration of the form f s · · · sn q and necessarily there is an immediate t of t q we take for mt the environment mt augmented by the binding f t mt s · · · t mt sn q m if the proof is by r then v is of the form a s · · · sn q with a set w of children for each w w there is a tw we set mt w w m if the proof is by r then v is a configuration of the form y s · · · sn q and necessarily for each y t bc there is an immediate tt of t s · · · sn q let us write simply as notation for the environment given by y t bc we take for mt the environment y t · · · t q finally we define a type environment whose domain is a subset of and which is extracted from by mt f c with witness t so the types are extracted in an inductive fashion starting from the leaves of each witness with the environment and working back adding new types along with way it is this that ensures that the types that are extracted are all correct lemma let c be a type context if is in ac then is in ac furthermore whenever the region is nonempty then new type information will be extracted taken together with lemma the following result is the key measure of progress in the algorithm lemma let c be a type context and have some leaf then the accepting region region of acceptance in a similar way the accepting region serves to identify those configurations that should be classified as accepting by the type context but which are not the rules by which vertices can be inferred to be accepting are all to those that define the region except for the case of nodes which are conjunctive in both regions and indeed the construction is coinductive definition given a typing context c we define a subset vc of the vertices of called the accepting region by a if f s · · · sn q with successor t q vc then t q a if a s · · · sn q then there is some s such that s q a and si q i q s a if s q sm qm then for all i m sm qm a if y s · · · sn q then for all y t bc t s · · · sn q a if c is a leaf in vc then c is an accepting leaf however unlike the case for region there is no similar guarantee of on iterations it is possible that on any given iteration the accepting region may be empty in contrast the absence of leaves and hence emptiness of the region leads to termination lemma let c be a type context and have no leaves then thus in particular will contain the root and so s q will be added to the accepting environment termination acceptance type extraction to extract new type information from the accepting region we follow the approach of kobayashi and in which types are assigned to prefixes of configurations recursively based on the kind of the prefix definition let c be a type context to each prefix c s of each configuration c we assign a strict type s which is defined inductively over the structure of the kind of s i if s is of base kind necessarily c is of the form s q and set s q ii if s is of arrow kind necessarily c is of the form st · · · tn q let w be the set of accepting region configurations with prefix t set s t s t c w we define a type environment whose domain is a subset of and which is extracted from by c · f the acceptance types extracted in this way are all correct lemma let c be a context if is then also is fixed point construction abstraction refinement finally we are in a position to describe the overall abstraction refinement loop starting from a context c that contains only the type assumptions on typed variables used by the abstraction on each iteration the algorithm analyses the given context say ci by constructing it then identifies in ci by constructing regions and attempts to repair those by extracting new environments eventually the type s q will be extracted from one of the regions and the algorithm will terminate definition recall a and r in definition the algorithm consists of constructing an eventually stable sequence of type contexts as follows c a r ck k k k k with limit say c then if q s answer yes and otherwise answer no since the initial environments and are trivially in a and in ac respectively and since every extension of these environments by and preserves this property it follows that the limit of the sequence also the property and hence can be upon to decide the model checking problem furthermore since progress is guaranteed by lemma and lemma and the size of environment is bounded by the number of types we can state the following correctness theorem theorem for any g a the algorithm terminates and · answer yes implies la · answer no implies la furthermore since each is in the worst case polynomial in the size of the scheme but in general in the order of the scheme and the amount of work involved in computing the the regions and type extraction is polynomial in the size of the scheme it follows that each iteration of the algorithm takes in the worst case an amount of time polynomial in the size of the scheme since the number of iterations is bounded by the number of types which is also polynomial in the size of the scheme it follows that the algorithm as a whole is polynomial in the size of the scheme assuming its order and arity and the size of the automaton are taken to be fixed implementation and evaluation we have implemented the algorithm in a prototype tool called which is written in f and available to from implementation to ensure efficiency we have taken a number of decisions about how to code specific aspects of the algorithm which from the presentation rather than constructing them as part of we build the maps a and r adding bindings as they are needed by applications of rule g further the implementation uses a flow analysis with increased accuracy distinguishing between instances of arguments using not just the triple of acceptance type type and kind but additionally the formal parameter benchmark rules ord dec a ­ a ­ a ­ ­ ­ table benchmarks of category benchmark rules ord dec exp a ­ ­ ­ ­ ­ exp a ­ ­ ­ ­ ­ exp a ­ ­ ­ ­ exp a ­ ­ ­ ­ exp a ­ ­ ­ exp a ­ ­ ­ ­ exp a ­ ­ ­ ­ exp a ­ ­ ­ ­ ­ table benchmarks of category benchmark rules ord dec map r fold left a fold right a forall eq pair a forall a r r search a map filter a a a fold fun list a a table benchmarks of category and the state component of the calling configuration since intersection type checking is frequently invoked as part of the decision procedure we aim to ensure it is done as efficiently as possible hence we omit subtype checking and hash cons the intersection types finally rather than compute all possible trees for any given vertex v we take one representative which is a function of the construction of the region evaluation we have evaluated the tool on the large collection of recursion scheme model checking instances found online and in the related literature the full listing of results is available in the appendix of the long version of this paper here we aim to present a very small representative sample in order to describe the general we have a number of benchmarks from three categories which are displayed in tables and respectively the benchmarks were run on an intel machine with gb of ram and running at limiting the runtime of each tool on each benchmark to in all cases the columns are respectively the name of the benchmark the number of rules equations the order of the scheme whether the tree is accepted a or rejected r by the property automaton the remaining columns list the time taken by each tool from start to finish which is either given in seconds or marked ­ in case the tool ran out of resources note that this does not affect the soundness or completeness of the decision procedure category the first category consists of model checking instances that have from ocaml verification problems via the predicate abstraction tool although can solve many complex examples the scalability of a full predicate abstraction tool for higherorder programs is still an open topic of research consequently the problem instances derived from this tool are exclusively quite small and mostly less than rules generates a extension of recursion schemes called which are currently only supported by and our tool can typically solve each of these instances in less than seconds but this is already roughly an order of magnitude slower than however the overhead by jit compilation on is a major factor when compiled of time on windows the time taken by to solve these instances is typically less than seconds although usually still slower than as the benchmarks become slightly larger towards the bottom of the table the time taken by starts to behind the time taken by which is the start of a general in the data to follow category the second category consists of instances arising from a tool for performing exact flow analysis these examples are significantly larger than those of category and indeed form some of the largest instances on which hors model checkers have been evaluated in the literature as of the time of writing although they have fewer than rules each due to the nature of the verification algorithm that produces them they have high order and very high maximum arity with being order with arity functions consequently many of the tools have difficulty but among those that are able to solve these instances the observed in the category examples can be seen to continue category the final category consists of instances of a family of schemes due to kobayashi this family of instances was designed to be difficult for bounded model checking style algorithms such as the hybrid algorithm of simultaneously being a good of the scalability of linear time algorithm as implemented in although these schemes are not real in the sense of arising from program analysis problems they seem a good measure of scalability since they generate trees and hence use the full power of higherorder schemes their certificates are proportional to the number of rules and they can push the model checkers much further since the family contains much larger schemes than can be produced by current verification tools the first half of the table shows instances which are generated with order schemes and the second half shows instances with order schemes the size of the schemes roughly within each half by row as expected does a good job at solving even relatively large examples at order though it has some difficulty at does even better and in contrast to the other tools can be seen to solve these examples in time which is roughly linear in the number of rules analysis the good performance of our algorithm at scale must be attributed to the abstraction refinement approach that we have adopted since recursion schemes cannot the trees that they create their interesting behaviours are exclusively due to control flow arising from complex uses of higherorder functions hence a abstraction in combination with a property directed refinement works well since this abstraction is particularly well suited to some of the essential structure of higherorder control flow and the refinement ensures that particular limitations of the cfa with respect to specific problem instances can be for a good example of this is in the category examples whose very regular structure is determined by the analysis quickly and hence all are solved in exactly iterations independent of the number of rules or the order of the scheme however although the refinement will eventually for these particular limitations of the cfa it is possible to construct instances in which the number of iterations required is large with respect to the characteristics of the instance although such examples do not seem to occur in the of instances drawn from the higherorder model checking literature and associated verification tools we have been able to construct very small and simple schemes which exhibit this bad behaviour the examples in table are based on a family of boolean programs defined in each of these instances is first order and consists of a few rules but the property automaton is strictly alternating we record the number of iterations and the time in seconds taken by and an extension in the remaining columns benchmark t t t t t rules time table bad behaviour time each example tn consists of roughly n functions which make exponentially many calls to each other in sequence so that function f calls function f twice function f calls function f twice and so on however what makes the examples expose bad behaviour in is not the number of calls which is smaller than the number of calls made by the examples in category but the fact that each call is made once with a term that will eventually evaluate to true and once with a term that will eventually evaluate to false and that of the property depends upon distinguishing between the two on iteration i the flow analysis is only able to distinguish between the true and false variants of the calls made to functions f j for j n i every iterations enough new information has been discovered in order to distinguish one more level of function calls and hence each tn is solved after roughly n iterations this analysis suggests that not enough type information is being from the at each iteration and indeed by extending our implementation with heuristics for extracting more types we have solved these examples more quickly our extension labelled in the table exploits the incremental nature of the algorithm by this we mean the following characteristics i the algorithm makes progress on each iteration in the sense of extracting new types even if the number of types extracted is perhaps smaller than one would like ii on each iteration the provenance of the context is not important only the fact that it environments that are consistent and respectively iii the larger the context for a given iteration the more accurate the analysis of that iteration our extension consists of in a separate thread running in parallel with the main algorithm taking the that has most recently been computed and based on the relationships between the vertices making at possible new types in general the may be incorrect in the sense of leading to the creation of an environment which is so the new environments are first according to the rules of if they typecheck the new types are then added into the context at the and the process can be repeated this extension appears to work well to solve the examples in table the time taken to process t down from almost to under one however it seems to scale well to where the possible number of types from which to guess is much larger consequently we do not consider this a satisfactory solution and leave to future work a proper treatment of this problem and that of the closely related area of how best to extract counterexample traces related work higherorder model checking algorithms by the tool the first practical algorithms model check hors with respect to trivial automata using intersection types as a finite representation of an infinite transition system they start from the assignment of the automaton initial state to the start nonterminal s and compute the in the form of type information required to deduce of the error configurations in the types of nonterminals are first extracted from a finitely reachable part of the infinite configuration graph the type environment is then expanded and used as an overapproximation of a greatest fixpoint of is similar to in that it implements a forward algorithm based on intersection types however in contrast extracts types from a finite abstraction of the configuration graph another major difference is that each iteration of refines two type environments one is potentially a certificate of automaton acceptance and the other of automaton very fast for hors of up to a few rules the runtime of is nonetheless in the size of the input hors the first in the size of hors algorithm is which consists simply of two fixpoint constructions the key is a reading of the intersection types a pair of expansion relations modelling the moves of the two players of an game the tool is also based on game semantics the algorithm variable profiles but represented as intersection types from the traversals over the hors being recently et al have introduced an algorithm based on pushdown automata which are with implemented in the tool given an input tree automaton the algorithm uses a of the saturation algorithm for pushdown automata to compute the of the final error configurations and checks if it includes the start state thus information is propagated in the backward direction closely related are algorithms and though based on saturation of hors rather than they may be viewed as fixpoint computation of a function over type environments to the computation these algorithms benefit from a forward flow analysis which some irrelevant type bindings abstraction refinement counterexampleguided abstraction refinement cegar was introduced by clarke et al for symbolic model checking the cegar loop was first applied to higherorder model checking by and and by kobayashi et al the former addresses the undecidable problem of verifying safety properties of patternmatching recursion schemes using patterns to abstract properties the latter is used in conjunction with predicate abstraction to verify simplytyped functional programs generated from infinite data domains such as integers in contrast builds more accurate finite abstractions of the configuration graph of the hors being from which potential certificates of acceptance and of are derived typebased flow analysis flow analyses were first applied to untyped languages et al introduced a typedirected flow analysis for the predicative subset of system f which can types to programs more precisely our algorithm uses an intersection type system for describing automaton definable properties and necessarily works in a situation in which not all type information is known in contrast uses more standard typing system f and starts from a situation in which all types are known thus their analysis is comparable to a single iteration of our algorithm where the associated context already contains all the possible correct type information the property of types which is put forward by the authors as a measure of the of a cfa for a typed language is for us actually an essential technical requirement in order to extract new valid type information and considered a type inference for objectoriented programs like our algorithm not all type information is known at the start and they compute types iteratively based on a flow analysis however within a single iteration they do not distinguish based on type information instead they distinguish based on discovered in the previous iteration a problem with their approach of distinguishing calls is that there may be infinitely many counterexamples which are being distinguished one at a time because of possible nontermination their method cannot handle recursion in general acknowledgments we are to kobayashi matthew and christopher for providing their tools and a large number of examples for in section the first author was supported in this work by a research grant from college oxford references t ball and s k rajamani a symbolic model checker for boolean programs in volume of lncs pages ­ springer h barendregt m and m a filter lambda model and the completeness of type assignment journal of symbolic logic ­ c h and n kobayashi model checking of higherorder recursion schemes in csl volume of pages ­ c h a m and o a saturation method for pushdown systems in icalp volume of lecture notes in computer science pages ­ springer c h a m and o a approach to verifying higherorder programs in icfp pages ­ acm e m clarke o s y lu and h counterexampleguided abstraction refinement in cav pages ­ springerverlag m and m an extension of the basic functionality theory for the lambdacalculus journal of formal logic ­ m a s ch l and o pushdown automata and recursion schemes in lics pages ­ ieee computer society s s and a k wright typedirected flow analysis for typed intermediate languages in sas volume of lecture notes in computer science pages ­ springer n d jones flow analysis of lambda expressions in icalp volume of lncs pages ­ springer n kobayashi types and higherorder recursion schemes for verification of higherorder programs in popl pages ­ acm n kobayashi modelchecking higherorder functions in pages ­ acm n kobayashi a practical linear time algorithm for trivial automata model checking of higherorder recursion schemes in volume of lecture notes in computer science pages ­ springer n kobayashi and ch l a type system equivalent to the modal model checking of higherorder recursion schemes in lics pages ­ ieee computer society n kobayashi and ch l complexity of model checking recursion schemes for fragments of the modal logical methods in computer science n kobayashi n and h higherorder tree transducers and recursion schemes for program verification in popl pages ­ n kobayashi r and h predicate abstraction and cegar for higherorder model checking in pldi pages ­ acm d e and p e alternating automata on infinite trees theoretical science r p ch l and s j a algorithm for higherorder model checking in icfp pages ­ acm ch l on modelchecking trees generated by higherorder recursion schemes in lics pages ­ ieee comp ch l models of higherorder computation recursion schemes and pushdown automata in pages ­ ch l and s j verifying higherorder functional programs with patternmatching algebraic data types in popl pages ­ acm j and a a precise concrete type inference for objectoriented languages in oopsla pages ­ acm s j r p and ch l a typedirected abstraction refinement approach to higherorder model checking long version r h and n kobayashi towards a scalable software model checker for higherorder programs in pages ­ acm y t and n kobayashi exact flow analysis by higherorder model checking in volume of lncs pages ­ springer s van strict intersection types for the lambda calculus acm computing 