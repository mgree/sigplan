is on the temporal logic of programs lamport computer science laboratory international introduction pnueli has recently introduced the idea of using temporal logic as the logical basis for proving correctness properties of concurrent programs this has permitted an elegant unifying formulation of previous proof methods in this paper we attempt to the logical foundations of the application of temporal logic to concurrent programs in doing so we will also the relation between concurrency and nondeterminism and identify some problems for further research in this paper we consider logics containing the temporal operators or and eventually or we define the semantics of such a temporal logic in terms of an underlying model that abstracts the fundamental concepts common to almost all the models of computation which have been used we are concerned mainly with the semantics of temporal logic and will not discuss in any detail the actual rules for theorems we will describe two different temporal logics for reasoning about a computational model the same formulas appear in both logics but they are interpreted differently the two interpretations correspond to two different ways or time as a branching set of possibilities or as a single linear sequence of actual events the temporal concepts of and never always not are equivalent in the theory of linear time but not in the theory of branching time hence our title we will argue that the logic of linear time is better for reasoning about concurrent programs and the logic of branching time is better for reasoning about nondeterministic programs the work reported national science foundation was by the under grant no to of work or are or or copies the to prior a is by permission of machinery requires a fee to copy and or specific permission acm the logic of linear time was used by pnueli in while the logic of branching time seems to be the one used by most computer for reasoning about temporal concepts we found this to cause some confusion among our so one of our goals ha been to the formal foundations of work the following gives an intuitive discussion of and section formally define the of the two temporal logics in section we prove that the two temporal logics are not equivalent and discuss their differences problems of validity section discusses and completeness for the the logics in section we show that there are some important properties of the computational model that cannot be expressed with the temporal operators and and define more general operators an introduction to temporal logic assertions the wellformed formulas of temporal logic are called assertions the set of assertions is obtained in the obvious way from a set of atomic symbols with the negation called atomic usual logical operators a v and the unary temporal operators together and u and thus if p q and r are atomic predicates then is an assertion assertions that of the temporal operators predicates in this section do not contain either u or are called ue give an intuitive description of how these temporal logic assertions are to be understood as statements about some system formal semantics are treated in the next section a predicate p represents a simple declarative statement about the state of the system it is interpreted to mean p is true an assertion represents a statement about the system which may refer to its state both now and in the future the assertion u a represents the statement that a is true now and will always be true in the future we define the to be consistent program correctness in logic terms with their use which differs and in the field from their of use the assertion a represents a is true now or will become future false after again true we read u and as the statement that true in the it could then become as or or the dual never become o to the operator u is defined by since u a states that a will true we can read o as if it is not the case that a is never true can we conclude that a must eventually become true in other words is the same as never the answer depends upon ones of the nature of time in a nondeterministic system the present does not determine a unique future but rather a perhaps infinite set of possible futures there are two different ways of these possible futures the theories of and linear tim e ln the branching time theory all of the possible futures are equally real and must be considered the assertion that a statement is or always true means that it is true now and will remain true during all possible futures a statement is true if it is true now or else during every possible future it will be true at some time statement is not always true if there is possible future in which it becomes true this does not mean that it becomes true during possible future as required true for it to be hence and or are not equivalent in branching time in the theory of linear time at each instant there is only one future that will actually occur all assertions are interpreted as statements about that one real future the assertion that a statement is true means that it is true now and will remain true during the one real future similarly it is true if it is true now or will become true at some time during the real future since only the one real future is considered any statement either is true or else it is true hence is equivalent to never in the linear time theory properties a he now indicate how temporal logic is used to express properties of a program particularly properties of a concurrent program we have found that there are two fundamental types of properties one wants to prove of a program which assert that something bad never happens and liveness which assert that something good must eventually for a sequential program partial correctness is an example of a safety property it asserts that the program never halts with the wrong answer termination is a liveness property it asserts that the program must eventually halt to state a safety property we need a predicate which represents the statement that the system is in an acceptable state the property that something the assertion bad never happens is expressed u good we do not assume by any special starting state sn the initial conditions must be explicitly specified letting be the predicate proper initial is expressed which means state our by the following that the system desired safety assertion is in a property init a good safety properties can be expressed using only the concept of always but one needs the additional concept of in order to express liveness properties manna and introduced the temporal operator which they called for deterministic sequential programs in we introduced the operator read for concurrent programs lt can be defined in terms of by a liveness property is of the form something which should happen eventually does to express it formally we need a predicate which expresses the statement that the system is in a state in which something should happen and a predicate done which expresses the statement that the required event has the liveness property is then expressed by the assertion done where is defined by as before we want this property always to hold if the system is started in a proper initial state the desired liveness property is then formally expressed by the assertion init u done where init is as above because we are not assuming any initial states properties about the system must be stated in the form init it might seem more convenient to specify the starting states as part of the system instead of always writing the initial predicate however in proving correctness properties one must often reason about the behavior of the program when started in other states we have found it easier to write an explicit initial predicate in our assertions than to introduce initial states and have to keep track of what initial state is being assumed when safety and liveness properties seem adequate to describe the desired behavior of most complete programs however one sometimes needs to express more complicated concepts when proving these properties one such concept is that of something u p represents the statement the assertion that property p is true infinitely often examples of statement requiring even more complex combinations of temporal operators can be found in the work of pnueli j the semantics models the assertions of temporal logic are defined as combinations of atomic predicates logical connective and the temporal operators el and to define semantics of temporal we must formally define how these assertions are to be interpreted as statements about an underlying model the type of model we is quite general and includes almost all formal models of program execution that we of the one exception is the model implicitly used in however our class of models is restrictive enough so we can avoid many of the difficulties discussed in which more general theories of temporal logic we define a state to be a function on the set of atomic predicates to see why such a function represents what we think of as a state recall that an atomic predicate is an uninterpreted characters symbol for example the string ot for a program having of a variable a a state x can in which a has the value true false be interpreted as one if xa xa false etc thus the state of the program is defined b the truth or of each atomic predicate since any predicate is a logical combination of atomic predicates there is a natural way to define a state x to be a function on predicates for example for any atomic predicates p and l we define xp a q to equal xp a xq the generalization to arbitrary logical combinations should be obvious a l m is a pair s z where s is a set of states and is a set of sequences of states satisfying property e below the set of states can be thought of as the set of all states of a program ie all possible combinations of values of variables and program values a sequence so s s in represents an execution that starts in state so performs the first program step to reach state s performs the next program step state s tc the only if the sequence represents all possible execution is finite executions terminates the of the starting in any possible state to reach if and set z program the one assumption we make about a model expressed formally by property e below is that the future behavior depends only upon the current state and not upon how that state was reached before formally some notation stating this property we introduce for any element s of we write sl s where the si are elements of s lf s is a finite sequence so s so sn for some n then we define sm to equal sn for all mn intuitively si represents the finite the state sequence of the program at so sn represents i an execution in state state sn in n which the at all program at time later times it is still n in if s is a sequence of length greater than one then we define s to equal s s the sequence obtained by deleting the if s is of length one defined to equal s the equality first then element s is si i holds integers for all i sequences s and nonnegative he can now state our condition must satisfy as follows which the set this condition means that state s its subsequent after the behavior by how that state was reached program is not reaches affected we now define for any element some more notation x in s we let for later use x denote the set of all sequences in which begin with x so if s define is the sequence sn to be the so s sequence more precisely for define sn inductively any sequence by so s then we sn s in z we sn sn for n in almost all models of programs one defines a relation next on pairs of states where y next x means that starting in state x and executing one program step can put the program into state y for a nondeterministic program there may be several possible next states y in some models of programs the set of possible executions is the set of all sequences of states so s such that il next si this set z satisfies property e in concurrent programs the next state relation is usually defined in terms of arbitrarily choosing an active process and executing one step of that process however some restriction is often placed on how that choice can be made in order to guarantee some sort of fair scheduling of process execution the following are three possible scheduling requirements eventual fairness a process cannot remain without ever being chosen active forever strong eventual fairness a process cannot be active without ever being chosen infinitely often there is an integer function of the state cannot be active for without being chosen of processes then scheduling n which may be a such that a process n consecutive steps if n is the number this is one can then define the set z to consist all sequences of states so sl such that i i next si for all i and ii appropriate scheduling of the above three requirement scheduling holds for requirements resulting set z satisfies property e of i the each the of the assertions the semantics of a temporal logic system are specified by defining how a temporal logic assertion is to be interpreted as a statement about an underlying model this is done in two ways one for the logic of branching time and one for the logic of linear time branching time in the logic of branching time an assertion a represents a statement about the current hence we interpret a as a on states we let the branching interpretation of an assertion a in the state function model m s defined be the mapping m b s true false inductively as follows if a is an atomic any state x predicate then for ax xa recall that a state is function predicates by definition a on atomic if a is the logical combination of simpler assertions then its interpretation is defined in the obvious way in terms of the interpretations of its components for example we have s cx v dx for any the left temporal right operation x in s note that side of s an logic formulas the side is the ordinary on truth values the v on operator on one on the logical interpretations of da and a defined as interpretation follows of in terms of a where x is element of s recall the definition given by are the any of e v ax a since all predicates operators assertions are logical connective this defines m ab obtained from atomic and the temporal for any assertion a we say that the assertion logic of branching time written is true have for all x in s a is in the if ax in other words we ma ax using the definition oa z oa obtains the following from one easily o comparing this with we see that the interpretations of a and oa in general are not equal the former involves a universal quantification over all possible futures and the latter involves an existential quantification for any assertion a it is easy to find models in which one of the assertions oa and a is valid and the other is not this formalizes our previous observation that eventually means eventually in every possible future while not future means eventually in some possible hence and are not equivalent in the branching time theory a every state deterministic state x y in there this system is one is at most one case x consists in which for possible next of a single element quantification deterministic branching deterministic future is so universal and existential over it are the same and not are equivalent hence for a system in fact the theories of time and linear time are equivalent for a system since the only impossible the single real one linear time in the temporal logic of linear time an assertion represents a statement about the actual current we let assertion mapping a and future behavior of the the linear time a in the model m s i true false hence of an be the defined inductively as follows lf a is an atomic any state x predicate then for xa if the combination of simpler assertions then its interpretation is defined in the obvious way in terms of the interpretations of its components for example z cx for any x in s v dx for any assertion interpretations of oa defined as follows where element sn of s recall given by the a x is definition the are any of z v an we say that logic of linear true for every words we have an assertion a is in the time written ma if as is sequence s in in other ma s v se using the definition oa z oa it follows easily from and that a oa for any assertion a hence assertion a z oa is mso is the same the theory of linear time the linear time for every model as never in expressiveness we now consider branching and linear the expressiveness time temporal of the ie what statements expressed by statements expressible about the underlying models can be assertions in these logics not all about an underlying model are for example the statement that a model satisfies described in either of our the fairness condition section is not expressible two temporal logics in in this section we compare the expressiveness of the temporal logic systems of branching time and linear time we prove that neither is more expressive than the other each can express things that the other cannot we also argue that the expressive power of the logic of branching time indicates that it is better for reasoning about nondeterministic programs while the logic of linear time is better for reasoning about concurrent programs to discuss formally the expressive power of our temporal logics we must define what it means for an assertion of the branching time logic to have the same meaning as an assertion of the linear time logic we can do this because we have defined the semantics of both temporal logics in terms of the same underlying models we make the following obvious definition an assertion a in a logic x is to an assertion b in a logic y if either a and b are both in their respective logics or if neither one is in other words a and b are if mb for a single model m is not an interesting concept because any assertion is to one of the trivial assertions or we can define to equal p v p and false to equal for some atomic predicate p in other words every assertion is simply true or false for a particular model the interesting concepts of equivalence are ones in which the two assertions are equivalent for some class of models the strongest form of equivalence is when two assertions are equivalent for all models he therefore say that two assertions are equivalent if they are for all models m for example any predicate p in branching time logic is strongly u p in linear time equivalent to the assertion logic to prove this note that for a model ms z p is in branching time logic sp if and is true only up if is in linear time logic if and if v se z v n is true and property e implies that these two conditions are equivalent strong equivalence implies that the two assertions have the same meaning regardless of the meaning of their atomic predicates it is natural to define a weaker one in which two assertions form of equivalence are the same for a particular meaning of their atomic predicates for example we might be interested only in models for which atomic predicates such as a can be interpreted as statements about a program variable named so that the truth of ta l implies the truth of la o this means that we want to restrict ourselves to a particular set of states for a set of states s we define an assertion in one logic to be to an assertion in another logic if the two assertions are for every model m having s set of states strong equivalence obviously implies results we different strictly express now show that the two temporal logics have expressive and that neither is more expressive than the other each can statements that the other cannot we do this by showing that for any nontrivial set of states s there is an assertion in each logic that is not to other logic note that this than proving the equivalent assertion any assertion is a stronger of any in the result strongly we say that a predicate p is trivially true for a set of states s if xp true for all x ins trivially false is similarly defined a predicate is said to be trivial for a set of states if it is trivially true or false our results following two theorems are contained in the theorem a nontrivial op in logic for any set of states s if p is predicate for s then the assertion the branching time logic is not to any assertion in the linear time proof we first define two models u s and m u s with the given set of states since p is nontrivial there are states p and q in s such that pp true and qp false let z consist of all infinite sequences of the form from q qq q the elements x p p p with x different together with the sequence let be the set containing all of together with the sequence q pp from definition of these branching expression equations of o models and and it is easy to see that for mi op is the both in time logic is true if and only if the following from this we see that op is m valid but it is not ml valid however is a subset of and it is an immediate consequence of the definition of for the linear time logic equation that any assertion which is for one model must be for a model having fewer execution sequences any linear time assertion that is must therefore be hence is no assertion logic which is of the branching time logic of the to the assertion d time op theorem for any set s of states a nontrivial predicate then the assertion of the linear time logic is not assertion of the branching time logic if p is to any proof such that and m sequences let pp denote pp equals the set of all states true let m u s u s where consists of which end with an infinite sequence p all of elements sequences of pp to verify all in pp consists of all containing since p is from but is not an infinite not trivially that the number true assertion in the of elements it is easy is linear time logic now let a be any assertion that when m is either of the models tl ax s ye s ay lie first r show m ax ax v d pe pp ap by of section show that d to prove s we have to v yes ay this follows easily both models for contains a sequence from the observation that any states x and y of the form x y in zx to prove it follows must show that for both models from that we z ax v v the right side implies the left side because both models every sequence in x contains in x and some element of pp the left side implies the right side because in both models contains the sequence this completes both models x p p p the proof for every of and p in pp for let x be any element of s if q is a predicate then qx has the same truth value in both models if a is any assertion such that ax has the same truth value for both models then i since holds in both models must also have the same truth value for both models and ii since holds for both models ax must also have the same truth value from for both models predicates using any assertion is built up only ordinary logical operators simple and the temporal operators induction argument shows and so a that for any assertion a ax has the same truth values for both models x it follows for the branching that any assertion if and since this is true for any state from the definition of time logic of section a of branching time only if it is logic is however the assertion and np of not linear time logic hence it is is not logic ii to any assertion in branching time nondeterminism versus in almost all formal models of concurrent processing a concurrent system is represented by a nondeterministic sequential one the concurrent execution of two operations that takes place in the real system appears in the model as the nondeterminism of which one occurs first this use of nondeterminism to model concurrency has caused some confusion since the type of nondeterminism involved is conceptually quite different from the nondeterminism studied in automata theory and in the theory of nondeterministic algorithms nondeterminism in automata theory a nondeterministic machine is thought of as one that simultaneously all possibilities the machine is considered to complete its computation successfully if one of these possibilities succeeds this has led to the study of nondeterministic algorithms implemented by concurrently executing all possibilities and the entire computation if one succeeds the theory of branching time is appropriate for reasoning about this type of if h is a predicate which represents the statement that the machine has reached a successful completion then the assertion oh in the logic of branching time states that some computation will succeed theorem i shows that this cannot be expressed in the temporal logic of linear time so there is no choice about which type of temporal logic is appropriate here pratt has developed the elegant formalism of dynamic for discussing nondeterminism of this kind to express his system in terms of our model we must divide the set of halting states those with no possible next states into two classes failed states and successful states let h be the predicate that is true only for successful states the dynamic logic assertion corresponds to the temporal logic assertion p for the model defined by the program a and pratt extended the original dynamic logic to the system dl in order to consider algorithms for which all the possible lead to terminating computations from our point of view we see that an extension was needed because this new type of termination temporal cannot be expressed operator u but requires with only the the additional operator all the formulas of dl can be obtained by adding formulas of the form to the original dynamic logic of this formula can be expressed in the branching time logic defined by the program a as h the meaning of termination for nondeterministic programs is discussed at length in dynamic logic only allows one to reason about the states before and after program execution in pratt extended dynamic logic to process logic which allows reasoning about the states entered during execution process logic is a form of branching time temporal logic concurrency our view of concurrent programs is that the nondeterminism represents different possibilities only one which actually occurs this suggests that the linear time logic should be more appropriate for reasoning about concurrent programs is not a provable property we will give what we feel to be strong arguments that this is indeed the case recall that the two basic properties one proves about concurrent programs safety and liveness are expressed by the assertions and it can be shown that each of those assertions in the linear time logic is strongly equivalent to the identical assertion in the branching time logic hence both logics can express the required correctness properties the of linear time logic itself only in the attempt to prove these properties the correctness of a concurrent program usually depends upon the fairness properties assumed for scheduling the execution of operations in different processes one type of fairness that is often assumed is the strong eventual fairness condition described in section this condition can be expressed in the temporal logic of linear time by the assertion o active v chosen where active and chosen represent appropriate predicates lt follows from theorem that this cannot be expressed in the logic of branching time ie this assertion is not to any branching time assertion for a nontrivial set of states s if it were then it would have to be equivalent for the subset of states in which chosen is trivially false theorem for p active this strongly suggests that the linear time logic is more appropriate than the branching time logic another argument in of the linear time logic comes from our experience in proving liveness properties of concurrent programs we find ourselves using the following type of reasoning to prove that p eventually becomes true we show that if p is always the program execution then will cause p bo become true cannot remain false forever eventually become true false during the program hence p so it must this reasoning is based upon the hypothesis that either p is eventually true or it is always false in other words it assumes an axiom of the form p v clp in the linear time theory this assertion is for all models m however it is easy to construct a model for which the assertion is not in the branching time logic so this reasoning cannot be used in branching time logic the logic of linear time corresponds to the way one to reason informally about concurrent program execution we have therefore found it easy to use the linear time logic to formalize the proof techniques described in and we do not know if it is always possible to prove the same properties of concurrent by reasoning within the branching time logic however our experience has us that even if it is possible the resulting proofs will not be as simple and natural as the ones using the linear time logic it might be argued that system powerful enough to branching and linear time logics be constructed however that upon the notion that a system is the better it is one should have a both the such systems can approach is based the more expressive we could get a very expressive system by simply reasoning about the underlying models however one uses temporal logic to hide the irrelevant details of the models the ideal logic would be one in which we could express all the relevant properties of the models and none of the irrelevant ones we have not considered temporal logics having an explicit instant operator such as the one studied in because we feel that they are too expressive since what is relevant depends upon the application different logics should be better for different applications we believe that the temporal logic of linear time as generalized in section has precisely the expressiveness that one needs for reasoning about concurrent programs the theorems of logic an assertion is in a temporal logic if its interpretation is true for the model m we are also interested in assertions whose interpretations are true for more than just a single model we define an assertion a to be valid if it is for all models m we say that a is for a set s of states if it is for every model m having s as its set of states a strongly valid assertion is one that is true for any interpretation of its atomic predicates for example it is easy to check that the following assertion is strongly valid for the logics of both branching and linear time this assertion is a true statement about any model regardless of how the atomic predicates p and q are interpreted in that model strongly valid assertions are the of temporal logic now consider u la l the assertion u ao where a o and a if are atomic formulas this assertion is not valid for all models since there are models having states in which a ill is true and is false however such models are of no interest if we are trying to reason about a program variable named in this case we are interested in where s is the set of possible program states the above assertion will be for such a set s of states in both the branching and linear time theories deductive thus far we have discussed the validity of temporal logic assertions but have said nothing about proving things a temporal logic deductive system consists of a formal method for deriving theorems we write fa to denote that the assertion a is a theorem of a deductive system a deductive system generally collection of axioms assertions to be theorems and a collection rules for deriving theorems from for example the following might consists of a that are assumed of inference other theorems be taken as a temporal logic axiom linear time logic in either a branching or in this formula a and b are formal parameters that represent any assertion it may be viewed either as an infinite set of axioms one for each choice of the assertions a and b or else as a single axiom in which case there must be a rule of inference that permits one to obtain new theorems by substituting arbitrary assertions for a and b in l the following is an example of an inference rule then aa note that this is not the same as which is not a valid theorem rule rule of modal logic a da is the a deductive system is said to be valid if all its theorems are valid if every valid assertion it is said to be is a theorem there are three types of validity that are of interest strong validity and they lead to three classes of theorems theorems true for all models theorems true for all models with a specific set of states and theorems true for a model representing a particular program a strongly valid assertion is one that is trivially true in the sense that its truth does not depend in any way upon the model under consideration we therefore call such an assertion a a temporal logic deductive system should be able to prove such trivial theorems so it should contain a of axioms and rules of inference for proving for example it might contain the axiom and the rule of inference we now consider the deductive axioms system formed and inference by this rules of for deriving a deductive system is called jj if all of its prove that a system must prove that each each inference rule this is a straightforward theorems are is valid axiom is a and can generate only task to one that a deductive system is said to be if every is a theorem finding a complete logical system is more difficult than finding a valid one in and give axioms and inference rules that are sufficient to prove every for the logics b and k which are closely related to our temporal logics of branching time and time respectively lt should be possible to adapt their axioms and inference rules to obtain ones that are sufficient to ensure completeness for temporal logic systems of branching and linear time scope however such of this paper an exercise is beyond the q formulas an assertion its atomic predicates implied by the set s is one that is true when are given the meanings of states to prove theorems a deductive system must be able to prove and it must also be able to derive theorems about predicates the following theorem shows that this is sufficient because any assertion can be derived from a and an predicate questions of validity and completeness are reduced to the corresponding questions for and for predicates to see that the following theorem does what we claim observe that by using the valid inference rule substitution and b from fa and a b we can deduce fa from p and up a for the logics of both branching and linear time if s is a set of states and a is an predicate assertion p such then that there exists an u p a is strongly valid w appearing arguments let pi pn in the assertion function f by letting be the predicates a of an define a n boolean equal true if and only if there is a state x in s such that ai for all i such a function can always be expressed arguments we fp pn as a logical can then where the combination of define p to latter expression its be is the predicate expression arguments necessarily obtained in the of f as a logical note that for in s obvious way combination any state from the of its x not xp x es v i this clearly implies that p is to complete the proof we must show that assertion u p a is for all models the m we prove this for the linear time logic the proof for the branching time logic is very similar and is omitted it follows from the definitions of section that for any model m and any sequence of states s dp as s v n as for any model m s define s z by letting a new model m xe s xp and z se for all n it follows easily from and that the assertion dp a is if and only if it is moreover this assertion is if and only if the following is true als hence we need only prove such a completeness result is by pnueli in however he based his temporal logic of linear time on the time plus the identification logic b of branching of and o so it is difficult to evaluate his claim let s s be any mapping such that for every u x pi for all i it follows from that such a mapping we extend to be a mapping on sequences obvious way so that sn exists in the we next define a model m s original state space by s atomic predicates since the in the assertion to verify that for all s e where letting pi are a s is our the only it is easy s as since equality proof a is and of the it is imply of hence u p a for any this our model to prove theorems that are valid only for an individual model there must be some way to prove properties of that model for a temporal logic of programs this means a way of proving properties of a particular program in practice one begins with certain elementary theorems about a program and then them to prove more complex theorems for example consider the following portion of a sequential program without we should about this label be able to program deduce the following theorem i control at given this type of elementary theorem the axioms and es for deriving state valid theorems may be used complex theorems about the specific to deduce program and more a deductive system for proving properties of programs must therefore have a method for these elementary properties such a method provides a formal definition of the semantics of a programming language for concurrent programs we believe that the only types of elementary properties that are needed are safety properties and liveness properties safety properties the usual upon the denotes method of following induction the state program it and this program is the safety properties relation where for a model defined by for any predicate p if xp a then mt p observe that the hypothesis is a statement about the model and the conclusion asserts the validity of a temporal logic assertion thus it leads to an inference rule for temporal logic theorems from theorems about the underlying model this induction principle is the basis of all the inductive methods that have been proposed for proving safety properties of programs starting from original inductive assertion method for proving partial correctness to prove the safety property of section one proves three theorems i init p ii p up and iii j p good for some suitable predicate p the first and last of these are theorems about predicates and are usually easy to prove the difficult part of constructing a proof is choosing the appropriate predicate p so that ii can be proved from the induction principle to apply this induction principle we need a formal method of proving theorems about the models next relation this requires developing a formal semantics of the safety properties of the programming language we have recently developed a method of doing this for concurrent programs which is described in it is based upon a method for proving formulas of the form p w q where p and statement q are predicates and w is a program this formula is interpreted to mean that if execution is anywhere inside t in a state such that p is true then p will true while control remains in t and q will be true if and when w terminates we can then the induction principle as follows for any predicate if p if p p then up liveness properties general methods for elementary liveness properties have not yet been developed liveness properties for programs written in the simple flowchart language used in e and can be proved by introducing following axiom for each flowchart box of each process b control on arc leading into box control leading on one of the arcs from box these axioms describe a system satisfying the eventual fairness properties described in section in these simple flowchart programs a process is always active so weak and strong eventual fairness are equivalent waiting is represented by a loop more sophisticated axioms are needed for concurrent programs written in languages with explicit synchronization primitives for example consider programs using a semaphore s there are several types of liveness assumptions we can make for semaphore operations a common assumption is that if the value of the semaphore s becomes positive infinitely often then every process waiting on a ps operation must eventually complete that operation this is a strong eventual fairness assumption it can be expressed in linear time logic by adding the following axiom for each occurrence of a semaphore operation ps control at the ps operation n control after the ps operation now consider a weaker form of semaphore which simply guarantees that if s becomes positive then eventually some pending ps operation must be executed this is weaker because it allows an individual process to wait forever if other processes are repeatedly executing ps operations to express the liveness property of such a semaphore one must introduce a single complicated axiom that depends upon all the ps operations of the entire program further specification work of ie needed liveness in the properties formal for synchronization primitives one can of course define these primitives in terms of flowchart programs the semantics of the language on the semantics of flowchart programs however this does not solve the practical problem of proving the global liveness properties that are achieved by these primitives it merely pushes the problem back one level completeness we now consider the question of completeness the ability of a deductive system to prove all valid assertions about individual programs we cannot in general expect this type of completeness since we can construct an assertion which states that the given program halts instead one can try to construct a deductive system for a result analogous to theorem of section holds any assertion that is valid for a given program can be from a and a valid theorem about predicates if the system were complete any incompleteness would then be due to an incompleteness predicates completeness in the system for this concept was introduced by reasoning about of cook for sequential programs such completeness results have been obtained for particular types of assertions for example and and have shown that proving a valid safety property can be reduced to the problem of proving valid theorems about predicates however proof requires the addition of variables to tbe program while and result requires the use of nonrecursive predicates apt lj has shown that this is if dummy variables are not allowed other than for describing the state of program control then nonrecursive predicates are required certain relative completeness results for liveness properties have also been obtained for models with no fair scheduling requirements and showed that if the set of predicates is rich enough then the problem of proving certain types of simple liveness properties can be reduced to the problem of proving valid predicates they considered programs written in a flowchart language in which a waiting condition can be added to delay the execution of an operation pnueli has proved a similar result for more general liveness properties of simple flowchart programs although of interest the most power lost such relative completeness they do not answer what important question is by using temporal logic results are we feel to be any deductive instead of reasoning tl be logic proving say that directly a deductive and let theorems tl is about the underlying model let system for linear time temporal ml be a deductive system for about the model m z s we complete relative to ml if for every assertion a if as is provable in ml then a is provable in tl a similar definition can be made for a branching time temporal logic no deductive power is lost by using the temporal logic system tl instead of reasoning directly about the model with ml if and only if tl is complete relative to ml if we are allowed to introduce dummy variables for reasoning about programs then for any ml we can construct a temporal logic deductive system tl which is complete relative to ml this is done by adding a variable of the that records a complete execution any reasoning in ml about execution sequences can be in tl by about the value of this dummy variable this approach was used in introducing such a dummy variable obviously the whole purpose of using temporal logic since it us back to reasoning directly about the model given a system ml for reasoning about program execution sequences we would like to find a temporal logic deductive system tl that does not use dummy variables and is complete relative to ml we that this is not always possible for example if a program uses a short term fairness scheduling discipline then the set of execution sequences important scheduling property would that satisfy cannot an be expressed in our temporal logics so reasoning about the model should enable one to prove properties that cannot be proved with a temporal logic deductive system however we conjecture that one can construct such a relatively complete temporal logic deductive system for a useful class of programs and an interesting class of systems ml we regard the study of this type of relative completeness to be a useful area for further research long as thus far we have restricted the discussion to temporal logics that use only the temporal operators and eventually we now show that these operators cannot express certain important properties of concurrent programs and briefly describe a more general operator we consider only the linear time theory since we are concerned with describing properties of concurrent programs more general operators can also be defined for the branching time theory in the linear time theory is equivalent to o which is equivalent consider only the single to so we have to temporal operator n the assertion ub represents the statement that b is can generalize true in the single real future this to an assertion we which asserts that b is true ias long as the assertion a remains true a u b is defined formally by extending the meaning the interpretation of defined in section as follows a d o n a temporal logic using assertions constructed with the operator u will be a called a generalized temporal logic and the logic we have been discussing up to now will be called ordinary temporal logic it is easy to check the strong validity of the following equivalence which shows that the generalized temporal logic is at least as expressive as the ordinary one true n b s u b the following theorem shows that the generalized logic is actually more expressive than the ordinary one theorem any set of states s j if p q and r are any predicates such that none of the three predicates p aq a r q p a q a r is trivially false for s then the assertion p q u r is not to any ordinary temporal logic formula proof the idea is the same as for the proofs in section we construct s z and m s distinguished by any ordinary two models m which cannot be temporal logic formula such that the assertion p valid for one model and false for the a b and be states ap a q a r q and cp q a other such r is let that a q a r are true let consist of the following three infinite sequences sl ab c sb ca s and let z consist sequences stl u a c of the following b at c b three infinite s b a c b a c st c b a c ba it is easy to verify that but is not we now prove that any assertion using unary predicates logical connective operator u cannot be valid for invalid for the other to do this for any such assertion a and each constructed and the one model and we show that i z the proof is by induction it is obviously true f a is a predicate since the first element of the sequence is the same as the first element of the sequence it is easy to see that if holds for a collection of assertions a then it holds for any logical combination of those assertions to complete the proof we need only show that if holds for all i then a but this conclude follows easily from o that any ordinary linear from we time assertion a that is must also be the proof assertions of the form a u b can be used to express a more general class of safety properties one such property is which can be expressed as follows if process p requests service process q does then process q cannot be before process p this is not a liveness property since it does not state that any process eventually does get it is expressed formally by the assertion n u where the predicates following meanings are defined to have the p is waiting waiting for for service service and q is neither nor being p is waiting for service q is not being the expresses only the above theorem a property unary operator shows that this assertion that cannot be expressed with a one can define u as follows a dual o tc the operator a u b this makes u and o in the same a and v are the assertion the statement that b eventually ao b becomes it becomes true before a does equivalent to the following ob a b n a we have thus far need for the operator o sense that represents true and this is assertion found no conclusion temporal logic provides a very convenient language for stating and proving properties of concurrent programs and we believe that it will also provide an important logical foundation for the semantics of concurrent programs the linear time temporal logic originally used by pnueli in is very imple involving the addition of the single temporal operator u to ordinary logic it allows one to hide many irrelevant concepts that appear in the ordinary computational models used to describe concurrent programs we believe that when generalized expressing concurrent as in section it is adequate for all the relevant properties of but more experience is needed can be certain of this we still do not know if a temporal all of the relevant logic deductive system properties that could can prove be proved directly from the models we have found that when informally about such concepts as most computer adopt the branching time theory this seem is and to one reason for our interest in branching time logic branching time logic is important for studying nondeterministic programs and comparing the two types of temporal logic has us to understand better the relationship between concurrency and nondeterminism acknowledgments we wish to thank meyer for their critical comments on an of this paper we also discussions with and david earlier version from numerous references r apt recursive assertions parallel october and a cook soundness and completeness an axiom system for program verification february of l and n consistent proof rules for the total correctness programs proceedings of th annual found of comp sci ieee october and complete of parallel symp on r w assigning meanings to programs proc symposium on applied math vol math pp n and a pnueli cyclic programs proceedings international conference on ieee pp a proof method of the parallel processing for d completeness results for temporal logic s the future and y fragment of i d and v r pratt nondeterminism in logics of programs proceedings of a symposium on principles of programming languages january david on the total correctness nondeterministic programs rc ibm watson research center to appear theoretical science of tj in l lamport proving the correctness of programs trans q software engineering zs march l programs lamport csl the hoare logic international of concurrent october l lamport correctness of qq programming a new approach to programs proving the i z manna and r sometimes better than february s comm acm s axiomatic techniques m parallel phd th cornell university august s technique for and d parallel an axiomatic proof programs aa informatica a pnueli the temporal logic of programs th annual symposium on the foundations of computer science ieee november v r of computer pratt logic science considerations on th symposium on foundations ieee october vr pratt process logic preliminary report proc th ann acm symp on principles programming languages acm january pp oo of n springerverlag and a new york 