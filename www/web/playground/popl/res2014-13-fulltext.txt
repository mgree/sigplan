proofs that count university of podelski university of abstract counting arguments are among the most basic proof methods in mathematics within the field of formal verification they are useful for reasoning about programs with infinite control such as programs with an unbounded number of threads or concurrent programs with recursive procedures while counting arguments are common in informal proofs of such programs there are no fully automated techniques to construct counting arguments the key questions involved in counting arguments are how to decide what should be counted and how to decide when a counting argument is valid in this paper we present a technique for automatically constructing and checking counting arguments which includes novel solutions to these questions categories and subject descriptors d verification correctness proofs f logics and meanings of programs specifying verifying and reasoning about programs general terms languages verification keywords concurrency verification static analysis introduction a counting argument in the context of formal methods is a program proof that makes use of one or more counters which are not part of the program itself but which are useful for abstracting program behaviour for example it may be useful to refer to the number of threads that have access to a shared resource or the number of times a recursive procedure has been called despite the of counting arguments in proofs the problem of constructing such arguments automatically is little explored this paper presents one such approach the main challenge of constructing counting arguments automatically is that we must design an algorithm which can choose what to count this is a task that when carried out by seems to require the question of whether machines are capable of simulating this type of is a challenging problem in formal verification it is also a fundamental one counters may be viewed as a class of auxiliary variables la in the sense that they remember useful information about the program history that can be used in a formal argument the problem of choosing what to count can be viewed as permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright © acm one of the wellknown and yet prob lem of auxiliary variable synthesis this paper presents a strategy for automatically constructing counting arguments for program verification this strategy is outlined in figure the input to our algorithm is a program p and a specification prepost the algorithm can be viewed as a kind of language inference algorithm the program p is treated as a black box we can sample traces from p but we may not its internal structure so effectively we identify p with a language of traces the goal of our algorithm is to learn a counting proof a for p a counting proof consists of a counting automaton a which determines a language of traces and an annotation which is a proof that all traces in the language of a satisfy the specification prepost if our algorithm can learn a counting proof a such that a all the traces from p then p is correct with respect to the specification prepost the algorithm in figure operates as follows we start by a constructing a counting proof a for set of sample traces tr we then b check if every program trace in p is recognized by the counting automaton a if the check succeeds the algorithm has learned a counting proof for p if it fails it produces a counterexample a program trace that is not recognized by a we then c check whether satisfies the specification prepost if not we are done is a counterexample which shows that p is incorrect if yes then d we add to the set of sample traces tr and repeat note that in the first iteration since initially tr is empty the language of a is empty so is any program trace d add to tr yes c does satisfy pre post no p is incorrect program p correctness specification pre post tr a construct a counting proof ha i from tr no counterexample b does a accept all traces of p yes p is correct figure counting proof inference before we explain counting proofs further we remark on the important distinction between discovery and synthesis of auxiliary variables and counters in particular counter discovery is essentially a technique the goal is to expose existing counters in a program which are relevant for a proof for example discovery of relevant program counters for proofs as in counter synthesis is a technique the goal is to discover new counters which are useful for a proof which do not necessarily correspond to anything in the program this paper addresses the latter problem this is the motivation behind our model of program correctness by treating the p as a language of traces we are forced to synthesize counting ar from our interest in counter synthesis from the fact that the internal control structure of p may be very counter synthesis gives a strategy for constructing proofs for p that avoids reasoning about its control and data simultaneously we will explain counting proofs and our proof inference algorithm by way of an example consider the program that t consists of an arbitrary number of threads whose control flow graph is to s assumes t the right the global integer variables s and t are initially the task is to automatically construct a proof that the error error location error is unreachable ie the program satisfies the spec s t false the task is complicated by the fact that the simple program has a complex control structure since it must retain the control location for every thread of which there are many we begin by sampling an error trace from this program say t t s assumes t a correctness proof for is a sequence of intermediate assertions shown below in figure a this proof can be generalized to a proof for a whole language of program traces this is done by constructing a finite automaton annotated with a proof with one state for each distinct assertion as in figure b it is easy to see that any trace accepted by this automaton satisfies the given specification t a s t t s t t s s t s f s t s t t s t t s f b figure proof for the sample trace unfortunately this automaton does not accept every trace of the program we could continue by sampling a new trace for instance t t t s assumes t but it is already clear that this strategy is to fail there is no regular language which contains all the program traces and which does not contain incorrect traces our solution to this problem is to the right this counting proof consists of a counting automaton a a kind of restricted counter kt s q machine with an annotation mapping the states of a to assertions the counting automaton a is a finite automaton equipped with a counter denoted k initially false q nop each transition of the automaton is equipped with an action for k which may be inc increment the counter dec but block unless the counter is block unless the counter is or nop do nothing the annotation associates with each state of this automaton a formula over the program variables and the counter variable k this annotation is inductive in the sense that each transition is associated with a valid hoare triple for example k t s t k k t s k t s s k k t s k t s false a trace is accepted by a if it labels a path from q the initial state to q the final state and none of the counter actions block every trace which is accepted by a is associated with a sequence of intermediate assertions which prove its correctness this sequence is obtained from the accepting run of a by taking for each position in the run the assertion at the current state with k replaced by its current value for example the proof for the trace above is as follows t s t s t t q k inc q k inc t s t s f s q k dec q k q k this counting proof works not only for the trace but for every trace of the program that is the proof is enough to show that error is unreachable the key to this proof is the use of the counter variable k which intuitively counts the number of t statements in of s statements along a trace using this auxiliary counter allows us to make a simple argument for the correctness of this program there are two algorithmic problems associated with our proof inference strategy how to construct a counting proof for a set of sample traces figure a and how to prove that a counting proof all program traces figure b the essential idea for our solution to is to encode the proof construction problem as an smt query our encoding requires us to specify the size of the candidate proof to find eg the number of states that may be used and will always succeed if a proof of that size exists the main insight behind our proof construction procedure is that by looking for small proofs we can force an smt solver to synthesize nontrivial counting arguments for example we can force an smt solver to discover the need to count the number of t statements in of s statements in the proof above completely automatically simply by for a proof with states our solution to is based on the observation that counting automata can be converted into a kind of labelled petri nets to enable our language inclusion checking procedure we use control flow nets as our program model a control flow net is a hybrid of a control flow graph and a petri net as in a control flow graph a transition is labelled with an imperative program statement over infinite data domains as in a petri net tokens can be used to model infinite control such as parametrized concurrency once we have modelled a program with a control flow net problem reduces to a petri net language inclusion problem which is known to be decidable motivating example we will formalize the verification problem for an motivated example through a control flow net and then present a counting proof figure a presents a simplified version of the device driver code similar to the one that appears in the program consists of an arbitrary number of work threads which all execute add and one stop thread which executes stop the global variables are the integer variable initially and the boolean flags and initially false we want to show that the statement never fails which means that no configuration is reachable where one of the work threads is still working after the stop thread has ex add atomic enter do work here assert atomic exit true stop true atomic close true true a add a enter a a exit stop s true s close s q k nop q k q false a a s true s b q q k k k c figure a device driver code b control flow net for the initial marking is as shown no token other than on a and on s the final markings are those where at least a has at least one token c counting proof the statement true the correctness relies on the atomicity of the three statements enter exit and close the bug detected in the version from has been fixed by making enter atomic control flow net the control flow net in figure b models that an arbitrary number of work threads and one stop threads run in parallel to model the fact that many work threads can be active simultaneously the initial add transition enter puts a token back on a so that enter remains enabled just as if yet another work thread was the number of tokens on ai models the number of work threads in the corresponding control location there is always one token in stop half of the net since there is only one stop thread a final marking is any marking where there is at least one token on the error location a each sequence of transitions a sequence of the net that reaches such a final marking corresponds to a thread interleaving that violates the assertion the goal is to prove that the corresponding sequence of statements is infeasible has the postcondition false counting proof the counting automaton in figure c is a finite state automaton augmented with a counter k transitions are labelled by letters of the alphabet of program statements and corresponding counter actions the same letters are used to label the transitions in the control flow net the counting proof consists of this automaton and the inductive annotation which maps the automaton states to assertions blue terms in the figure intuitively at any moment while reading a trace ie a sequence of statements the value of the counter k records by how much the enter transitions the exit transitions initially by the automaton states q q records what statements of the stop thread have appeared so far in sequence none recorded by q true transition from q into q close transition from q into q transition from q into q the automaton state q is reached if the statement of the work thread has appeared or the statement enter of the work thread has appeared after the statement true of the stop thread has appeared it is easy to see that the annotation is inductive initially the flags and have the value false is and k is and thus the assertion for the initial state q is satisfied one can check that for every transition the corresponding hoare triple holds the check of the trace inclusion between a control flow net and a counter automaton is decidable as we will show in section to obtain an intuition why the inclusion here holds consider the informal invariants s q s q s q s s q and a a k the annotation of the final state q with the assertion false means that every trace accepted by the counter automaton has postcondition false since every trace of the control flow net is accepted by the counter automaton this means that the execution of the statement is never feasible ie the statement never fails which is what we to show proofs that count one of the key contributions of this paper is a new formalism for proving program correctness which we call counting proofs a counting proof consists of a counting automaton and an inductive annotation the automaton defines a set of traces and determines what to count by associating counter actions to transitions in the automaton the inductive annotation is a correctness proof for the counting automaton which shows that every trace accepted by the automaton satisfies a given specification thus we may prove the correctness of a program p by a counting proof such that all traces of p belong to the counting automaton associated with the proof in this section we give a formal definition of our notion of counting proof first we define some terminology for our program model we fix a possibly infinite set s of memory states usually defined as valuations assigning values to a finite set of global and local variables a set of program statements and a semantic function · which each program statement as a relation between memory states a trace is a sequence of statements ie a word in intuitively we will think of a program as a set of traces this allows us to abstract away from the control structure of the program which may be complicated we fix a set of program assertions which is denoted as well as an entailment relation s × for s s and s indicates that the assertion holds in state s a prepost specification for p consists of a pair prepost indicating a precondition and postcondition in the following it will frequently be convenient to consider program assertions over an extended vocabulary that includes a fresh set of variable symbols v depending on the application at hand such a variable symbol may be interpreted as the values of some counter variables or as the number of tokens on a place of a petri net section the set of such extended program assertions will be denoted v for a statement and assertions we use the typical hoare notation to denote that for every s s such that s and s s we have s we extend this notation to sequences of statements in the obvious way counting proofs we may now introduce the definition of counting proofs we start by defining counting automata which are finite automata augmented with zero or more counter variables which can be and tested definition counting automaton a deterministic counting automaton is a tuple a q n q k where q is a finite set of states n n is the dimension of the automaton ie the number of counters used by the automaton q q is an initial state k nn is an initial vector q nn is a mapping that takes each state to an closed set of final accepting vectors and q × q × is a partial function which maps state program statement pairs to pairs consisting of a successor state and an action for each counter where act inc dec nop note that since is partial not every state is associated with a transition for each program statement remark a special case of particular interest is when the acceptance condition of a counting automaton a q n q k is specified by a set of final states f q rather than a mapping from states to sets of final vectors this case is by setting q n n for every final state q f and q for every state q f this special case is used frequently in this paper and in diagrams of counting automata we will use double to denote final states we also remark that nondeterministic finite automata are a case of counting automata where the dimension of the counting automaton is note that n is a singleton set and so for any state q the only choices for q are n and ie dimensional counting automata always fall into the case described above where the acceptance condition is determined by a set of final states we now introduce some additional terminology for counting au let a q n q k be a counting automaton a configuration of a consists of a pair q k where q q is a state and k n n is a valuation for each counter the initial is q k and any configuration q k where k q is a final configuration we lift to a partial transition function on configurations as follows q k k kn c q k k kn recall that a set of vectors v is closed if for all v v and all v such that v v we have v v if q k k kn q n and each ki is defined as ki ki ki ki if i inc if i dec ki if i nop ki if i ki undefined otherwise we lift to a partial transition function on statement sequences in the obvious way a trace w is accepted by a if q k w is a final configuration the set of all traces accepted by a is denoted la we may now move on to our definition of an inductive annotation in essence an inductive annotation is a proof definition annotation let a q n q k be a counting automaton let k k kn be a set of distinguished variable symbols an annotation is a map q k we say is inductive if for all q q q and k k nn such that q k q k the hoare triple qk q k holds where for an assertion and vector k k kn n n k denotes the formula obtained by replacing each ki with the corresponding element ki of the vector k finally we may define a counting proof as a pair consisting of a counting automaton and an inductive annotation for it definition counting proof a counting proof is a pair a consisting of a counting automaton a q n q k and an inductive annotation for a we say that a satisfies a given specification prepost if the following two conditions hold i pre qk ii for all q q and all q we have post we now justify using counting proofs as proof objects recall that our use of counting proofs is the following informal proof rule suppose that p is a program a is a counting proof which satisfies the specification prepost and that every trace of p is accepted by a then p satisfies the specification prepost for this proof rule to be sound we must show that every trace in la satisfies the specification prepost with this goal in mind we first prove a lemma lemma let a q n q k be a counting automaton and let be an inductive annotation for a let if q q k k are such that q k q k then the following hoare triple holds qk q k proof by induction on the base case is empty is trivial the induction step follows from definition and the sequential composition rule for hoare logic we may now state the main result of this section a soundness theorem which our proof rule theorem let a be a counting proof with a q n q k and let pre and post be assertions such that a satisfies prepost then for any la satisfies the hoare triple pre post proof follows from lemma definition the definition of la and the consequence rule of hoare logic constructing counting proofs we now consider the problem of automatically synthesizing a counting proof which that a given finite set of traces tr is correct with respect to a given specification prepost our algorithm for constructing counting proofs is divided into two parts the first part is a decision procedure which determines whether a counting proof of a given size exists for a given set of traces and specification here size should be understood informally the second part is a search procedure which repeatedly calls the decision procedure on different candidate sizes until a proof is found and attempts to find the smallest proof possible we start by describing the decision procedure and then discuss the search procedure the idea behind our proof construction procedure is to encode the proof construction problem as a formula and use an smt solver to find a model for from any such model we may extract a counting proof a which satisfies prepost and such that tr la since the goal is to develop a decision procedure for proof construction we must limit the program statement language and the language of program assertions to a decidable logic a convex linear real formula is a conjunction of a finite number of linear inequalities over a set of real variables with real coefficients the number of inequalities appearing in a convex linear real formula will be called the size of and denoted in this section we fix a set of traces tr and a prepost specification prepost we will assume that pre and post are convex linear real formulae and that every program statement can be expressed as a convex linear real formula for simplicity we will also assume that tr consists of a single trace · · · the generalization to multiple traces is straightforward let a be a counting proof with a q n q k the size of a is determined by four numbers the number of states q the dimension of a n the size of the assertions used in the annotation q qq the number of minimal final vectors v v qv v qq our decision procedure will take four additional parameters as input q n k m n corresponding in order to the four components of counting proof size described above the idea behind this algorithm is to construct a qf formula which is satisfiable iff there exists a counting proof a such that a accepts a satisfies prepost q n k and m for presentation purposes we assume that n m and that we are searching for a proof with k q with one atom per state but that q is arbitrary the generalization of the quantifierfree nonlinear real arithmetic formulae with uninterpreted function symbols construction to arbitrary values of the parameters n m and k is straightforward the construction of the qf formula follows automaton constraints without loss of generality we may construct a counting proof with state space q q recall that the transition function of a dimensional counting automaton over the state space q is a partial function q × q × act where act inc dec nop is a set of counter actions for our encoding we introduce for each a pair of uninterpreted function symbols q q q act we now encode the constraint that the counting automaton accepts the trace we introduce a set of integer variables q q k k the interpretation of these variables is that after reading the prefix · · · i of the trace the state of the counter automaton is qi and the value of the counter is ki q and k represent the initial state and initial value of the counter this interpretation is encoded by the following constraints state i qi qi i counter k ki ki qi i where if inc incr if dec otherwise the preceding constraints ensure that labels a path through the counting automaton and that at each step along this path ki is updated appropriately another constraint is required for to be accepted by the counting automaton which is that none of the transitions that label the accepting path may block recall that the dec and counter actions block when the counter is this nonblocking condition is enforced by the following constraint block i qi dec ki i the last requirement to ensure that is accepted by the counting automaton is that we must synthesize an closed set of final vectors for the state q for the case of dimensional counting automata an closed set is completely determined by a single natural number which is the lower bound on the set thus we introduce an integer variable and create a constraint that the value of the counter after reading is greater than or equal to accept k collecting these constraints we have a state counter block accept models of a correspond to dimensional counting automata which accepts the trace annotation constraints we now consider the constraints used to construct the inductive annotation of the counting automaton we use a technique to synthesize linear invariants as described in fix a set of program variables x x xx for each program variable xi we introduce an uninterpreted function symbol of sort q r we also introduce two additional uninterpreted function symbols ck c of sort q r for a given state q q q will be the of xi will be the of k cq will be the constant in the linear inequality assigned to q that is for q q the annotation at q will be x q · xi · k cq i for any statement we use tf to denote the transition formula of which is a formula over the variables x xx and their copies x xx that represents the meaning of the statement for a counter machine action act we use tf to denote the transition formula corresponding to defined below as tf k k k k k k k k k k if inc if dec if if nop we may now define the consecution constraints which ensure that the annotation is inductive we define a consecution constraint for each i as follows i k k x x qi where denotes the formula obtained from by replacing each variable xi with its copy xi and k with k the last annotation constraints ensure that the counting proof satisfies the specification prepost init k final k k post the annotation constraints defined in this section all feature uni quantification however all the formulae defined in this sec tion belong to a class of formulae for which the universal can be replaced by existential quantifiers by applying lemma see for details we will use i init and final to denote the corresponding transformed formulae finally we collect the annotation constraints into a single for init final i i counting proof extraction we the automaton and annotation constraints to arrive at a formula whose models correspond to counting proofs a suppose that m is a model of for a term term we use to denote the interpretation of term in the model m a counting proof can be constructed as follows q q q qm k km q k k if q otherwise q qm qm if iq qi i undefined otherwise x q qm · xi · k i the following proposition states that our encoding is in a sense complete proposition let tr be a finite set of traces such that each command is expressible as a convex linear real formula and let prepost be a convex linear real specification let n q k m n the problem of determining whether there exists a counting proof a that satisfies the specification prepost such that tr la and such that q n k and m is decidable searching for small counting proofs the decision procedure presented in the preceding section suggests a simple algorithm for constructing a counting proof suppose we are given a set of traces tr and a specification prepost first we check whether some tr violates the specification prepost this can be accomplished with an smt query if such a exists we are done no proof exists otherwise enumerate the space of parameters n q k m n applying the decision procedure described in the previous section until a counting proof is found the termination of this simple algorithm relies on the following observation observation let tr be a set of traces and let prepost be a specification such that for each tr pre post then there is a counting proof a which satisfies prepost and which accepts every trace in tr the intuition behind this observation is that we can always find a counting proof where the counting automaton is dimensional ie a counting automaton that does not use counters and like a prefix tree the existence of an inductive annotation for such an automaton is a consequence of lemma while this observation is enough to prove termination of our proof synthesis procedure it is not very satisfying it says that in the worst case we can always construct a counting proof that does not in fact count the key insight behind our counting proof synthesis procedure is that we can constrain the parameters given to the decision problem to force an smt solver to discover a nontrivial counting argument for example consider the sample trace from section setting q k n m we can force the smt to synthesize a nontrivial counter simply because there is no dimensional counting proof for these traces that only uses states so by of the fact that our decision procedure will find a state proof if one exists it must find a proof that uses a nontrivial counting argument in the remainder of this section we present a refinement on the simple algorithm discussed above which a particular way of the parameter space the intuition behind this refinement is that we want to synthesize a counting proof that the sum of the number of states q and the number of assertions k our aim in presenting this algorithm is not to present a practical proof construction procedure but rather a theoretical algorithm capable of synthesizing proofs that are in a sense optimal in practice one would expect a method for exploring the this algorithm can be adapted to minimize any objective function which is strictly increasing in q and k parameter space which cannot necessarily guarantee optimality would be more effective observation yields a upper bound on the sum of the number of states and atoms used in a counting proof for a given set of traces tr of · tr since we have an upper bound on q k the parameter space q k n × n can be efficiently using binary search the termination of this algorithm relies on the following proposition proposition let tr be a finite set of traces prepost be a specification and z n the problem of determining whether there exists a counting proof a that satisfies prepost such that tr la and such that z is decidable this proposition is not trivial because even though the size of implies finitely many choices for q and k the space for the remaining parameters n and m is infinite and cannot be the following two lemmas imply that we may place a finite upper bound on n and m once tr and q are fixed lemma let a q n q k be a counting automaton and let tr be a finite set of traces which are accepted by a there exists a mapping q nn such that the counting proof a with a q n q k satisfies tr and tr la proof intuitively we define to be the closure of the set of configurations that result from reading the traces in tr formally for any q q define q k n n tr k k q k q k lemma let a be a counting proof with a q n q k there exists a counting proof a such that a the same language as a and a has dimension at most dom where dom indicates the cardinality of the domain of the partial transition function proof suppose that n dom by the principle there exists distinct counters s t n which agree on all their actions that is for any q q if q n then s t without loss of generality we can assume that s and t letting k kn k we define k k without loss of generality we may assume that we construct an counting automaton a q n q k and an inductive annotation as follows · k k kn where k kn k · for any q such that q q n we define q q n · for any q q we define q k k kn k kn q · for any q q we define q kk k q the quantifier k can be eliminated to yield a convex linear real formula the proof of proposition follows easily from the preceding two we conclude this section with an algorithm the search procedure described above in this algorithm we use constraints to denote the formula constructed in the previous section and to denote the counting proof extracted from a model of a formula input tr pre post such that for all tr pre post output a counting proof a which satisfies prepost and with tr la min max · tr m tr binary search for minimal proof while max min do mid max min q mid k n tr tr pre post n q k m search for proof of size q k while is unsatisfiable and q do k q k q n pre post n q k m end if is satisfiable then a max mid end min mid end return a algorithm counting proof construction control flow nets in the preceding we have considered the control structure of a program to be a black box in order to implement the algorithm outlined in figure we need an effective procedure for checking whether a given counting automaton accepts all the traces of a given program in this section we introduce control flow nets an expressive program model that features infinite control but for which the inclusion check is decidable section we begin by introducing some notions from petri net theory which form the basis of control flow nets definition petri net structure a petri net structure is a tuple n p t e where p is a finite set of places t is a finite set of transitions and e p × t t × p is an relation connecting places to transitions and we now recall some standard definitions for petri nets let n p t e be a petri net structure given a transition t t we define its and as the set of places with arcs to t p p t e p t p e a marking of n is a map m p n given a marking m and a transition t t we say that t is enabled in m if for all p mp we write m t m to denote that t is enabled in m and that for all p m p mp p p for markings m m we write m m if for all p mp m p a set of markings m is closed if for all m m and all m such that m m we have m m any closed set of markings can be represented by its set of minimal elements which is always finite we may now introduce our program model control flow nets control flow nets are programs which have petri nets as control structures we may think of them as an infinite analogue of control flow graphs just as a control flow graph is a finite automaton labelled by program statements a control flow net is a petri net structure with transitions labelled by program statements a slightly feature although not without is that we also include acceptance conditions for control flow nets ­ this enables us to view control flow nets as language recognition devices formally definition control flow net a control flow net is a tuple p p t e m f where p t e is a petri net structure t is an injective map which labels transitions with program statements m is an initial marking and f is an closed set of final markings control flow nets are a very expressive program model for example figure b a control flow net for a concurrent program with arbitrarily many threads with their foundations on petri nets modelling concurrency is a particularly strong for control flow nets but they can also be useful for representing other control features for example figure a control flow net where tokens are used to count the number of stack frames in a recursive program in view of our strategy for counting proof synthesis we conclude this section with a definition of the traces and correctness of a control flow net definition correctness a trace of a control flow net p p t e m f is a sequence of statements n such that there exists transitions t tn where t tn n and markings m mn where mn f such that m t m t · · · tn mn the set of all traces of p is denoted lp given a pair prepost the control flow net p is correct if all of its traces are correct ie if the hoare triple pre post holds for all lp proof checking a counting proof a which satisfies a specification prepost represents a set of correct behaviours which are correct with respect to that specification if every trace of a given program p is represented by a this implies that p is correct thus in order to check a counting proof we must check the inclusion of the language of traces of a control flow net p inside the language of a counting automaton in this section we prove that this check is decidable and give a characterization of the computational complexity of proof checking first we state our decidability result the essence of the proof of this theorem is that counting proof checking can be reduced to petri net reachability which is known to be decidable theorem let p p t e m f be a control flow net and let a q n q k be a counting automaton the problem of checking the inclusion lp la is decidable this result still holds even if we relax the accepting sets for control flow nets andor counting automata to be rather than closed proof the proof proceeds by reduction to an inclusion problem for petri net languages a problem known to be reducible to petri net reachability it is sufficient to show that for any counting automaton we may construct a control flow net which the same language which is a deterministic petri net by construction from the point of view of language recognition control flow nets are equivalent to labelled petri nets in it is show that deterministic petri net languages are closed under and in it is shown that the problem of checking the inclusion of an petri net language in a deterministic petri net language is decidable an example the construction of a control flow net from a counting automaton in the figure below which the control flow net associated with the counting automaton for the example in section note that in this picture the transition labelled represents three parallel transitions one for each letter in t s assumes t in the rest of this proof we make the construction formal q assumes t t s q k let a q n q k be a counting automaton we define a control flow net pa p t e m f as follows the places of pa are defined to be the disjoint union of the set of states of a and a set of n distinguished counter places p pn p q p pn the transitions correspond to points in the domain of t q q × q is defined we define the relation e indirectly by defining the and of every transition let q t and suppose that q q n then we may define · q q pi i dec i q · q pi i inc i we define a map from configurations of a to markings of pa for a given configuration q k kn we define q k kn p ki if p q if p pi otherwise we define the initial marking m to be q k and we define the closed set of final markings f by taking the image of the accepting configurations of a under the labelling function is defined by q it is easy to prove that this mapping from configurations of a to markings of pa is an isomorphism when restricted to the reachable configurations of a and the reachable markings of pa it is clear to see that q k q k iff q k q k which completes the proof of equivalence there is a slight technical difference the labelling function for labelled petri nets is not required to be injective we will in fact ignore the restriction in our construction complexity of proof checking the decidability of this language inclusion problem is of fundamental importance because it calling counting proofs proofs a desirable result would be that checking proofs is not only decidable but efficiently so theorem relies on a reduction to petri net reachability this problem is at least but the best known upper bound for its complexity is so a natural question is can we do better than reducing to petri net reachability the following theorem states that we can not in general petri net reachability and counting proof checking are equivalent from the perspective of computational complexity theorem the petri net reachability problem is inter reducible with the counting proof checking problem proof one direction of the proof is given in the proof of theorem it is easy to prove that the reduction to reachability is for the other direction we give a reduction from the problem to proof checking this implies the result due to lemma in in fact states a slightly weaker result that reachability is recursively reducible to however it is easy to see that the reduction from the proof of is consider a petri net g p t e a marking m of g and a place p p given an initial marking m we say that a place p is if there exists a marking m which is reachable from m and such that m p we reduce the problem of checking of p to counting proof checking by constructing a control flow net p and a counting automaton a such that a accepts all the traces of p iff p is we suppose that is a new transition which does not belong to t we take p p t e m f where t t is an arbitrary injective labelling and f is the set of all markings p e and m are as above intuitively p is just g extended with a do nothing transition which can always we define a counting automaton a q n q k from g as follows define n p and let place n p be a bijection the initial vector is defined to be k k kn where for each i ki the transition function is defined for any c such that there is some t t with t c by q c where for each i dec i inc nop q i if if if otherwise we also add another transition to for the distinguished do nothing transition except that instead of doing nothing we check that p is nonzero with one exception we define q q n i nop if p otherwise last we define by q k kn n n m we define an annotation for a that is trivially inductive by taking q true we have that a is a counting proof it is easy to see that the control flow net p and the counting automaton a act exactly the same except at markings where p can but a cannot such a marking is reachable from m in p and a iff p is zero reachable m in g thus the proof while the decision problem for proof checking has high computational complexity from the of the correctness of a program we may be satisfied with a faster procedure for example acceleration has proved to be an effective technique in practice for petri net reachability we also note a recent result by if a given marking of a petri net is not reachable there exists a inductive invariant for the petri net this allows for the possibility of using wellknown reachability algorithms for sequential integer programs eg to be used for counting proof checking completeness we now show the relative completeness of our counting proof method when programs are modelled as control flow nets first we observe that proving that a control flow net p satisfies a given specification prepost is equivalent to proving that a particular program p satisfies prepost the program is a sequential program with extra variables which are used to represent a marking we then show that any inductive assertion for p can be trivially transformed into a counting proof the relative completeness of counting proofs thus follows from the relative completeness of the inductive assertion method we now formalize this argument let p p t e m f be a control flow net a configuration of p is a pair m s where m is a marking and s s is a memory state the program p is a transition system where the state space is the set of configurations of p and the transition relation is m s m s t tm t m and s s t a assertion is a formula in p assertions over an extended vocabulary that includes an additional variable symbol p of sort n for each place p p a configuration m s of p can be viewed as a structure for this vocabulary in the sense by interpreting each new variable symbol p as mp for assertions and a transition t t we write t if for all configurations m s and m s such that m s and m s t m s we have m s definition let p p t e m f be a control flow net and let prepost be a specification a global inductive assertion is a assertion for which the following hold · pre m · f post · for all t t t where m is a formula defining the initial marking m and f is a formula defining the set of final markings f theorem let p p t e m f be a control flow net and let prepost be a specification if there exists a global inductive proof that p satisfies the specification prepost then there exists a counting proof proof let p p t e m f be a control flow net and let prepost be a specification suppose that is a global inductive assertion for p that proves that p satisfies the specification pre post we construct a counting automaton a that is equivalent to p as in the proof of theorem consider the formula obtained by replacing each place variable p with its associated counter variable ki it is easy to check that a q is a counting proof that proves that p satisfies the specification prepost discussion through examples in this section we use examples to have a more discussion about a few points about the counting proofs framework these points include · control flow nets are a very general mechanism for representing programs with infinite control no matter what the source of of the control may be section · the structure of counting proof is in some sense independent of the control flow structure of the original program section · control flow nets encode a verification problem that is they represent an integration of the control flow of the program and the correctness property an adequate representation of program and property by a control flow net may not exist and if it does it may be difficult to build section tree traversal example on the right is a recursive preorder tree traversal routine we will give two implementations of this if node null return program one a sequential recursive program and the other a parallel recursive program to illustrate two important features of the counting proofs framework first control flow nets are a very general for representing programs with infinite control and second counting proofs are in some sense independent of the control flow structure of the original program we will use two different implementations of the generic template from above i a sequential recursive implementation and ii a parallel and recursive implementation to demonstrate the generality of the control flow nets and the independence of count ing proofs structure from that of the program we diverge slightly from the presentation of counting proofs and control flow nets from the preceding sections by using an acceptance condition based on linear arithmetic formulae rather than closed sets ie the set of accepting vectors of a counting proof and the set of accept ing markings of a control flow net can be described by a qf formula rather than just an closed set as noted in sec tion proof checking is decidable for this class and in fact the more general class of sets it is easy to see that the proof synthesis procedure from section can be adapted to this more general setting as well recursive traverse we first look at a variation of the code above which is a sequential recursive program to demonstrate how recursive programs which have trace languages can be modelled using control flow nets it is known that petri net languages are incomparable with context free languages however they do properly include and the inclusion is proper the set of bounded context free languages which is the most general class for which decidability results have been proved figure includes a simplified implementation of traverse which abstracts away the heap manipulation operations but keeps the relevant control information we introduce two global counters to count the number of leaves and internal nodes that are visited by the traverse routine if nodes and leaves are initially p p call traverse p leaves p nodes p nodes return call traverse p p traverse if leaves return else nodes traverse traverse return main traverse nodes p p return from traverse p call traverse p return from traverse figure sequential traverse code and control flow net the control flow net accepts when a token is at p and there are no other tokens set to then after traverse is finished for any binary tree the property leaves nodes is true figure also illustrates the control flow net for this program a call statement is modelled by two transitions a call transition and a return from call transition the call adds a token at the place p the entry location of traverse to trigger another execution of the method body however the current execution is blocked from note the incoming edge from place p to the return from call statement until a return token is provided through p the erroneous traces and therefore those in the language of the control flow net are those that put a token at place p ie when the assertion is violated and all other places contain zero tokens the latter ensures that the all executions of all pending frames of traverse are completed before the property is checked to hold the control flow model allows several partial executions of different frames to and the property does not hold until they all finish proof of correctness for traverse the proof of the correctness call return return of the recursive traverse appears on the right k nodes leaves q it is a counting automaton with an nodes nop additional counter variable k which k nodes leaves leaves nodes q counts the differ ence between nodes and leaves note that the initial value of this counter is rather than as we have seen in previous examples when traverse returns to the main procedure and we check the assertion condition count and proceed to error location ie we execute nodes we move to the state q and stop reading additional statements the automaton accepts when the final value of the counter k is which implies that k nodes leaves the assumption leaves nodes p p call traverse p leaves p nodes p nodes return fork traverse p p traverse if leaves return else nodes fork traverse traverse join return main traverse nodes p p call traverse p return from traverse p join figure parallel traverse code and control flow net the control flow net accepts when a token is at p and there are no other tokens recursive and parallel traverse figure presents a variation of the traverse implementation from figure in which the two recursive calls to traverse are executed in parallel by a new thread for one of them this program is both concurrent and recursive with both unbounded recursion and unbounded parallelism which puts it in a class of very difficult programs to verify the control flow net for the parallel version is also depicted in figure note that the join statement expects a token provided after the completion of the execution of the thread to continue as with return from call in the recursive case a fact is that the proof of correctness of this version of traverse is still the same proof that was presented in the previous section for the recursive version with the minor addition of the join action to the set of actions call return return from that are labelling the self loop on q despite the fact that the two programs have substantially different control flow structure the counting arguments for the correctness of their set of traces are the same this is due to the fact that the proof is constructed based on a set of program traces and independent of the control structure basically in both cases the same counting argument applies for the correctness of program traces it is a rather interesting feature to be able to reuse a proof of correctness when a program is changed for example for performance reasons as is the case when we traverse algorithm our approach assumes that the alphabet of program statements is finite if an unbounded number of threads execute a program over local variables we need an infinite alphabet of statements each program statement that a local variable must be copies for each thread however our approach may still be applicable by using a symmetry argument this section gives an example of such an argument we consider a wellknown mutual exclusion protocol for an unbounded number of processes namely the algorithm at each instant a counter t contains the value for the next available and a service counter s contains the number of already clients a client can acquire a by setting its own local number m to the current value of the counter t after which t is by to reflect the available for the next client t when a local number m is equal to or smaller than the service number s the client can enter the critical section s when this exits the critical section the service number s is by s the program consists of an arbitrary number of threads which each execute the same code to the right idle wait m t s s the variables s and t are global initially s t the variable m is local to each thread the mutual exclusion property is that at most one thread can be at or equivalently while some thread t is still at another thread t cannot enter interestingly it does not seem possible to encode the tion problem for mutual exclusion by a control flow net even after using a symmetry argument instead of mutual exclusion we will consider a stronger correctness property ie a property that im mutual exclusion if a thread t has a after another thread t then t cannot enter while t is still at wait or for brevity we refer to this property as first come first serve our encoding of the property relies on the notion of minimal error traces consider an error trace which violates we call minimal if no proper prefix of already violates to prove correctness it is sufficient to show that every minimal error trace is infeasible we can decompose every minimal error trace as follows we mark a statement by the thread that executes it t mt t mt t where t s does not occur in in or in that is every minimal error trace contains in order the request of t the request of t and at the last position the enter of t and thread t may or may not enter after its request but if it does it cannot not exit in the setting above the thread t is the bad thread we now use a symmetry argument without loss of generality we may assume that the bad thread is thread the reason that this is no loss of generality is due to the symmetry of for any minimal error trace where the bad thread is some thread other than thread we may simply swap that thread and thread and arrive at another minimal error trace one where the bad thread is thread thanks to this symmetry it is sufficient to show that all such distinguished minimal error traces are infeasible we the alphabet of program statements by the local variables of every environment thread ie a thread other than thread the statement m t of an environment thread becomes t which is semantically the same as t and likewise s becomes assume s which is semantically the same as it is sufficient to show that every distinguished minimal error trace over the finite alphabet of program statements is infeasible since local variables can only make more traces feasible the set of traces of the control flow net in figure a contains all distinguished minimal error traces over the finite alphabet of program statements it contains also some ones the transitions and places are in three columns the left most column corresponds to environment threads that acquire their before thread the second column corresponds to the distinguished thread and the last column corresponds to environment threads that acquire their after thread p t p m t p assume s p t p s p assume kt s q k m s assume q s p p false q a b figure a control flow net the set of final markings is defined by p p p b counting proof counting proof of the counting automaton shown in figure has three states the initial state is q its only final state is q the initial value of the counter k is while in state q the automaton counts the request statements and the exit statements of environment threads it does not count enter statements while in state q it counts the exit statements of environment threads it counts neither request statements nor enter statements the request statement of the distinguished thread leads from q to q the enter statement of the distinguished thread leads from q to q if the operation succeeds ie if k proof checking we use this example to our intuition that proving the inclusion of the language of a control flow net in the language of p p k p q p q p q k a counting automaton often involves a set of very simple invariants the formula to the right is a linear arithmetic formula which relates configurations of the con flow net with configurations of the counting proof two con are related if they satisfy the formula to the right the control flow net configuration is used to interpret p variables and the counting automaton configuration is used to interpret k and the q variables the value of q is or one may check that this re is a kind of simulation whenever the control flow net may take a step the counting automaton may take a corresponding step or the control flow net is in a dead configuration that cannot reach a final marking moreover the initial and final configurations of the control flow net and counting automaton are related thus this for shows that the traces of the control flow net are accepted by the counting automaton related work extensive research has been done about verification of parameterized systems apt and kozen argued that with little capabilities granted to individual processes the verification problem becomes undecidable there has since been a great deal of study of of subclasses of parameterized systems there is a good survey that covers a lot of the existing techniques for verification of parameterized systems we emphasize here that our goal is not to verify parameterized distributed protocols but programs and therefore we do not mention a lot of related work that is focused on the of verifying these protocols deductive techniques we are aware of two proof systems that are applicable to parameterized systems a parameterized type proof system in which if the assertions and the auxiliary variables are provided by the user as annotations then the proof checking is done mostly automatically and the qed system that is based on the reduction by inferring atomic blocks which works independently of how many threads are running in parallel both of these systems need partial or total annotations to prove programs correct techniques there are techniques based on induction on the number of processes that rely on finding an abstraction and approximation of network invariants the method of invariants automatically generates inductive assertions for the verification of safety properties of parameterized systems first the symmetry of parameterized systems is exploited to guess a universally quantified assertion that the set of reachable states then a small model theorem establishes when the assertions over parameterized systems can be model checked on small instantiations whose size depend on the system and the assertions to derive the validity over any instantiation this method is limited however to systems with finite data and the application of it in some contexts is far from trivial regular model checking the idea which was introduced in is to represent the set of reachable states of a parameterized system using a regular language processes are assumed to be finitestate to give rise to a finite alphabet alphabet letters correspond to processes states transducers are used to approximate through acceleration the transitive closure of transition relation and hence compute all reachable configurations of the systems a lot of research has been done in improving the problem of computing the meta transitions including techniques based on acceleration transitive closure and widening and even going beyond regular languages in the restriction that processes need to be finite state in all these extensions the focus of this line of research has been on the verification of protocols and hence they often have much richer input languages than the one we use in this paper that are beyond our scope of parameterized programs eg the use of existentially or universally quantified guards which is not normally found in software systems techniques in a system of n processes communicating through shared variables is abstracted by mapping the state systems into tuples where each dimension having the values or many corresponds to the number of processes at a given local state and additional dimensions are used to capture the value of global variables finitely many possibilities the resulting finitestate system was then verified by model checking finitestate verification in this and other counter abstraction techniques a concrete state is counter abstracted by counting the number of processes in each local state limiting the counter to at most counter abstraction is simple to apply and when applicable works well its is that it is only applicable to systems where each process has a small number of individual local states more recently in symbolic techniques are used to overcome this problem and allow verification processes with larger number of local states a new form of counter abstraction is discussed in using parametric interval abstraction that verification of distributed algorithms there is a class of techniques that are not strictly counter abstraction in the above sense since the resulting abstract system is not finite but have a similar since they use the same counters but in and consider a parameterized system of processes that communicate and show how to verify properties they achieve this by encoding the problem as a petri net safety property and using tree construction similar techniques have been applied to verification of multithreaded c and java programs in all these instances processes are abstracted into finitestate processes and the only source of remains the existence of many of these finitestate processes in a cegar algorithm for parameterized systems is presented the program model in this paper is very similar to ours although the technique proposed in is focused on proving safety for petri net programs where the data variables are integers the reachability algorithm employed by is a fairly standard backward algorithm the insight of this paper is that the well used for this algorithm can be refined using counter examples the authors do not approach the problem of automatically synthesizing auxiliary variables in it is shown how to represent a parameterized system of finitestate processes in the decidable logic ie the current state of the system is modelled as a fixed number of finite subsets of natural numbers and the transitions of processes are described in formulae later in they extend the method using a combination of theorem proving and the algorithmic techniques from so that each process can have an unbounded state space the theorem proving side helps prove a simulation relation between the original system and a socalled system which is restricted enough to be expressible and within the original framework from the problem of proving data structure invariants for programs with many threads is in and aims to exploit in their proofs which restricts the ways in which threadlocal variables may be for the practical gain of a faster analysis additional can be captured using the technique of in which a universally quantified environment assertion is used to keep track of relationships between a distinguished thread and all other threads is another technique that like variable in the of speed unlike and is designed to compute numerical invariants rather than data structure invariants the conditions that need to be satisfied by the abstraction are restrictive enough that as an example the example discussed here cannot be handled by the method the technique of trace abstraction has previously been discussed in and in there the sets of traces of sequential programs respectively concurrent programs were abstracted by regular languages the issue of auxiliary variable synthesis was not investigated in that work although it is potentially interesting also for sequential and concurrent programs detection there is a strong by empirical evidence that parameterized systems often a small model property this has given rise to a collection of techniques for verification of parameterized concurrent systems more precisely analyzing a small number of processes the socalled points and their interactions is sufficient to determine the reachability of any bad states in parameterized boolean programs more specifically the result of predicate abstraction of de vice drivers are analyzed the technique in is complete with respect to boolean programs note that this does not carry over to the original c programs while the one in is even incomplete for boolean programs more recently in communication protocols are the focus and an abstraction scheme is used that attempts to detect the points dynamically during the verification procedure to stop the search here also the processes are assumed to be finite state conclusion in this paper we introduced counting proofs a new system for proving safety properties for programs with infinite control we believe that counting proofs have independent interest outside of the software verification algorithm presented here for example we believe it may have applications to analysis of systems where the proof checking problem cannot be done but we may be able to make other guarantees eg testing coverage another potential direction for future work is application is verification where the proof checking problem is undecidable in general but an incomplete can be used for proof checking this paper shows that a particular class of auxiliary variables ­ counters ­ can be synthesized automatically a natural question is to ask what other classes of auxiliary variables admit synthesis procedures another question is whether basic ideas introduced in this paper can be applied to auxiliary variable synthesis in other proof systems such as the problem of auxiliary variable synthesis is largely and this paper takes a step in the direction references p a a b and m handling global conditions in parameterized system verification in cav pages ­ p a yf chen g f cd and a constrained monotonic abstraction a cegar for parameterized verification in concur pages ­ p a f and l all for the price of few in pages ­ k r apt and d kozen limits for automatic verification of finitestate concurrent systems inf process ­ t a pnueli s j xu and l d parameterized verification with automatically computed inductive assertions in cav pages ­ t ball s and s k rajamani parameterized verification of multithreaded software libraries in tacas pages ­ s a j and l fast acceleration from theory to practice int j tools ­ sept k s y and k abstracting systems to verify parameterized networks in tacas pages ­ k k s and y networks of processes with parameterized state space notes theor comput sci ­ j berdine t r g and m sagiv thread quantification for concurrent shape analysis in cav pages ­ a b m and t regular model checking in cav pages ­ a r model checking without unrolling in pages ­ e m clarke o and m c reasoning about networks with many identical finitestate processes in pages ­ e m clarke o and s parameterized networks using abstraction and regular languages in concur pages ­ m a s and h b linear invariant generation using nonlinear constraint solving in computer aided verification pages ­ g and l v begin towards the automated verification of multithreaded java programs in tacas pages ­ t s qadeer and s a calculus of atomic actions in popl pages ­ a and z verification of parameterized concurrent programs by modular reasoning about data and control in popl pages ­ a z and a podelski inductive data flow graphs in popl pages ­ d and a pnueli beyond regular model checking in pages ­ p r majumdar and b bounded formal methods in system design ­ s m and a p reasoning about systems with many processes j acm ­ a gupta c and a rybalchenko predicate abstraction and refinement for verifying multithreaded programs in popl pages ­ m decidability questions for petri nets phd thesis mit june m j and a podelski refinement of trace abstraction in sas pages ­ l e b h and a a survey of petri net methods for controlled discrete discrete event dynamic systems ­ c n ip and d l verifying systems with replicated components in formal methods in system design ­ a john i u h and j parameterized model checking of distributed algorithms by abstraction in pages ­ a d and t dynamic detection in parameterized concurrent programs in cav pages ­ r m and r e parallel program j comput syst sci ­ y a pnueli e and l d network invariants in action in concur pages ­ s r decidability of reachability in vector addition systems preliminary version in pages ­ r p and k l a structural induction theorem for processes inf comput ­ s la p and g modelchecking parameterized concurrent programs using linear interfaces in cav pages ­ j vector addition system reachability problem a short proof in popl pages ­ d n and p automatic verification of parameterized linear networks of processes in popl pages ­ b d an approach to the verification of compact parallel coordination programs i inf ­ m a unifying model checking approach for safety properties of parameterized systems in cav pages ­ k l lazy abstraction with interpolants in cav pages ­ l p completeness of the system for parameterized parallel programs in page s and d verifying properties of parallel programs an axiomatic approach acm ­ may e closure properties of deterministic petri nets in pages ­ a pnueli and e liveness and acceleration in parameterized verification in cav pages ­ a pnueli s and l d automatic deductive verification with invariants in tacas pages ­ a pnueli j xu and l d liveness with counter abstraction in cav pages ­ s qadeer and d wu keep it simple and sequential in pldi pages ­ m t r r and m sagiv abstract transformers for thread analysis in pages ­ p and b verifying systems with infinite but regular state spaces in cav pages ­ l and a pnueli model checking and abstraction to the aid of parameterized systems a survey comput lang syst struct ­ oct 