probabilistic relational verification for cryptographic implementations fournet benjamin software institute microsoft research inria abstract relational program logics have been used for formal proofs of various cryptographic constructions with an towards scaling these towards security proofs for implementations of distributed systems we present rf a relational extension of f a generalpurpose higherorder stateful programming language with a verification system based on refinement types the distinguishing feature of rf is a relational hoare logic for a higherorder stateful probabilistic language through careful language design we adapt the f typechecker to generate both classic and relational verification conditions and to automatically their proofs using an smt solver thus we are able to benefit from the existing features of f including its abstraction facilities for modular reasoning about program fragments we evaluate rf by programming a series of cryptographic constructions and protocols and by verifying their security properties ranging from information flow to integrity and privacy moreover we validate the design of rf by formalizing in coq a core probabilistic calculus and a relational refinement type system and proving the soundness of the latter against a denotational semantics of the probabilistic calculus categories and subject descriptors d programming languages formal definitions and d software engineering verification keywords program logics probabilistic programming introduction many fundamental notions of security go beyond what is expressible as a property of a single execution of a program for example noninterference the property underlying informationflow security relates the observable behaviors of two program executions the importance to computer security of such this work has been partially supported by the european program permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm properties researchers have developed a range of program analyses and verification tools for proving relations between two or more programs or two or more executions of the same program for instance relational hoare logic generalizes hoare logic to reason about properties of two programs in addition security properties must often account for probabilistic behaviors for instance in cryptography simulation and notions of security are specified in terms of the probability that an adversary in some probabilistic experiment starting from work many logics for reasoning about probabilistic programs have been developed recently these two lines of work have been combined into a relational program logic called for reasoning about probabilistic imperative programs this logic can justify common patterns of probabilistic reasoning about used in cryptographic proofs including observational equivalence equivalence up to failure and arguments forms the of a framework which has been used for verifying the security of encryption and signature schemes modes of operation for and hash function designs in the computational model these advances among others raise the of a new class of secure systems those that are proven secure based on standard computational assumptions such as the existence of functions and whose verification all aspects of the system implementation rf security of cryptographic implementations in an effort to scale logics like towards security proofs of system implementations this article presents a new language called rf building on f a dependently typed of ml f and its predecessor f make use of refinement types to verify implementations scaling to of of lines of code including the layer security standard multiparty sessions extensions protocols and the f typechecker itself rf within f an expressive system of relational refinements to support finegrained reasoning about probabilistic computations through careful language design we are able to use the relational features of rf in smooth conjunction with the existing features of f allowing the large of f code to be about effectively when used in a relational context as such our work the to security verification through relational refinement types instead of a somewhat combination of parametricity and type safety as in f or through detailed interactive proofs as in as a basis for the security of critical pieces of infrastructure such as a reference implementation of technically this paper makes three broad contributions a relational logic for higherorder stateful probabilistic programs we formalize in the coq proof assistant p a lambda calculus with references random sampling and unbounded recursion we develop a relational refinement type system for p and prove it sound with respect to a denotational interpretation of judgments as relations over pairs of probabilistic functions to our best knowledge p is the first relational logic for higherorder stateful probabilistic programs § the design and implementation of rf p forms the basis of the design of rf an extension of f we show how to encode relational refinement types within a new relational state monad we provide a type inference algorithm for in the form of a weakest precondition calculus that computes relational verification conditions proofs of these verification conditions can be automatically by the rf typechecker and the z smt solver § an experimental evaluation of rf we demonstrate the expressiveness of rf through a representative set of examples starting from simple information flow and moving towards more advanced cryptographic models and systems to date we have used rf to automatically verify a total of around lines of code for a variety of relational properties ranging from noninterference to various properties for encryption besides others several examples make essential use of higherorder and stateful features of rf the utility of the p logic for practical security verification § and § the p theory formalized in coq the rf compiler and all the example programs mentioned in this paper are available online from programming with relational refinements we start by describing rf informally through a series of examples beginning with a brief introduction to f itself and then focusing on the main new feature in rf ie relational refinement types from classic to relational refinements f is a callbyvalue higherorder programming language with primitive state and exceptions similar to ml but with a more expressive type system based on dependent refinement types refinement types are written xt where is a logical formula for instance the code fragment below defines a refined type for nonnegative integers then for integers modulo some number p type nat n type mod p n p let p let n mod p typechecking f programs involves logical proof obligations which are to the z smt solver for instance to check that n has type mod p the f typechecker the proof obligation p p which is easily by z type safety means that whenever an expression e with type xt reduces to a value v this value v satisfies the formula x v the type system provides structural subtyping for instance nat is a subtype of int and mod p is a subtype of mod q when p q these subtyping relations are automatically proved and applied by f refinements can be combined with dependent function types written xt t where the formal parameter xt is in scope in the result type t we also use dependent pairs written xt t where the variable x of the first component is in scope in the type t of the second component for instance we may write and typecheck addition modulo as follows where the refinement bind than the arrow val add p p p z x y p let add p x y let s x y in if s p then s else s p f also provides primitive support for programming with state for example one may write let incr i i i by combining refinements with references one can express invariants on the program state eg ref nat is the type of mutable locations that contain nonnegative integers to describe more precise properties of effectful programs f provides more advanced mechanisms including a monadic mode where one can reason about programs using variants of the hoare state monad of et al together with theory for modeling the heap for example one can give incr a specification of the form nat st unit h h i sel h i where st pre t post can be understood as the function type h xt h x h although in f provides primitive support for state that is the type of incr states a trivial precondition on the input heap h and a postcondition indicating that the final heap h differs from h at the location i which is f provides type inference in the form of a higherorder weakest precondition calculus to help ease the burden of writing such precise specifications rf extends f with relational refinements a type can also be with a relational formula placed within double that specifies a joint property on pairs of values relational formulas can independently refer to the left and right values of every program variable in scope using the projections l and r respectively projections extend naturally to arbitrary formulas intuitively for deterministic programs type safety means that whenever we obtain two results vl and vr by evaluating an expression e xt in two contexts that provide welltyped substitutions for es free variables then the formula l x x vr is valid more generally instead of considering two executions of the same program e rf allows proving relations between the results of two programs ie we relate e and e at a refined type using e e t we write e t as a shorthand for e e t we start with a few simple examples take the expression e to be z z we can give e the type x r x meaning that for any pair of substitutions l and r evaluating le yields the same result as evaluating re similarly we have x x x l x r x l z r z stating a simple equivalence between two integer expressions evaluated with the same value for x relational refinements can also be used to describe properties beyond equivalence for example we can express the type of monotonic integer functions as xint l x r x l y r y and the type of integer functions for some metric dist as xint dist l y r y k dist l x r x rf can automatically check by subtyping that a function such as fun x k x is both monotonic and for any k relational refinements are strictly more expressive than plain refinements one can encode any plain refinement as the relational refinement l r that independently specifies left and right properties for instance the type nat above is automatically to l n r n this enables us to mix property refinements and relational refinements in our concrete syntax and to import any f library in relational mode by applying the encoding when programs with specific relational properties in mind one need issue only a single compiler a to switch the verifier to relational mode we that the resulting language rf relational program verification out of the domain of tools applied to small fragments of with interactive proofs to a practical programming language suitable for small to systems implementations information flow relational refinements can be systematically used to give a semantic characterization of noninterference whereas standard typebased information flow to security labels and ad hoc syntactic mechanisms to conservatively determine when the observable outputs of a program may depend on its secret inputs rf can directly verify the corresponding equivalences as illustrated below recall that noninterference means that public results do not depend on if an expression e with base type a that computes over some secret information can be given the type type eq a x r x then its result can be safely published since the execution of e reveals no information about the capturing the intuition from labelled information flow type systems with high and low confidentiality levels we use the type eq a the type of values that are equal on both sides for values also written low a in contrast we use the type a the type of left and right values for values writing hi a as an alias for a as usual low a is a subtype of hi a meaning that public values can be treated as secret but not the converse using these type abbreviations we can write programs such as fun xy x y y and give them information flow types such as hi int low int hi int low int more interestingly we can these types with relational refinements that capture more flexible informationflow policies for example a confidentiality policy for credit numbers all but their last four as specified and implemented below val last int n r n l s r s let last n n tracking leaks via control dependencies implicit flows is a characteristic feature of information flow type systems to illustrate how rf reasons about implicit flows consider the program fun b if b then e else e assuming that b is secret flowinsensitive type systems would conservatively give this program the type hi bool hi a to give this program the more precise type hi bool low a we need to analyze four cases that arise from applying this function twice to arbitrary boolean arguments l b and r b and prove that the results in all cases are the same the four typechecking goals are · a assuming l b r b true · e low a assuming l b r b false · e e low a assuming l b true and r b false and · e a assuming l b false and r b true on the next section our proof rules for relating two values v and v are relatively simple proving v v xt involves first proving v v t which for base types involves simply showing that both v and v have type t and then proving l x r x v v so rf can easily prove for instance fun b if b then else hi bool low int and fun x if x then x else hi int low int even though syntactically those functions branch on values for expressions particularly those that have side effects the problem is more complex our strategy is to adapt the hoare monad st pre t post provided by f to a relational version called where pre t post can be seen as the type shown below pre l h r h xt post l h r h l x r x l h r h this is the type of pairs of functions that when run in a pair of input heaps l h and r h satisfying the place relational precondition predicate pre may diverge but if they both converge yield results l x and r x and output heaps l h and r h that satisfy the place relational postcondition predicate post using the monad and its associated weakest precondition calculus we can type the following program which branches on a value and then performs matching public sideeffects val f int true unit post where post h h h h l xr x hh hh let f x b if b then x else x rf infers a weakest precondition predicate transformer for this program then checks that it is consistent with any programmer supplied annotation the annotation is optional for programs in our example the precondition of f states that it can be run in any pair of heaps while its postcondition ensures that if f is applied twice to the same references in the same heaps then regardless of its boolean argument the resulting heaps are also the same ie the type reveals that f does not leak information despite having sideeffects guarded by a secret boolean more complex programs for example those that may leak information via sideeffects based on aliasing can be verified similarly val g int int true unit post where post h h h h l xl y r xr y sel h l h r y let g x y b if b then x y else y x the type of g states that if x and y are not aliased then the final contents of the reference y are the same thus the expressiveness of rf combined with its ability to use z to proof obligations enables automated reasoning in the style of a relational hoare logic for proving noninterference properties of higherorder stateful programs sampling security and pads we introduce probabilistic relational reasoning in rf using symmetric encryption schemes our goal is to communicate messages between a sender and a receiver without any information about their content from an information flow viewpoint are public whereas are secret for simplicity we assume that messages range over byte arrays with a fixed size n called blocks and we do not consider active and authentication against attacks can be easily added but would our presentation see § for a description of our model for security we assume that the sender and the receiver share a secret key k also a block uniformly at random by calling the primitive function sample we model this assumption by writing a single program where both are within the scope of this key the simplest secure encryption scheme is the pad implemented for instance using to the message p compute c k p to c compute p k c type block length b n let k p k p let k c k c next we explain how to specify and prove that an encryption scheme is secure in cryptography confidentiality is usually stated as against attacks and encoded as a game in which an adversary chooses two receives the encryption of one of them under a fresh key and must guess which of the two was decryption plays no role in this simple game still we may typecheck that it encryption using classical refinements and properties of this game may be coded in rf as follows let b p p let p if b then p else p in sample n p where b is private and p p and the result are public we thus express perfect security with the following type val eq block eq block eq block stating that the encryption of one of the two blocks p or p depending on b does not leak any information about b hence does not help the adversary to the game in fact security from an information flow perspective a simpler formulation is possible instead of reasoning about two messages selected by b we just need to show that the function let p sample n p has the type block eq block this is the best type we can hope for encryption treating the as private and the as public this more compact typing property subsumes the first one to prove secrecy for the pad some probabilistic reasoning is called for indeed operationally calling sample n twice does not usually return the same value however relying on our formal semantics we show that it is to give sample n a more specific relational type that allows us to complete the proof in particular as explained below we can type the call to sample n in a way that depends on the p and give it the type l p l m r p r m from this type rf automatically proves block eq block intuitively this relational refinement is sound as the distribution of the resulting is independent of the in programs that contain sample the interpretation of assertions in the monad becomes probabilistic we formalize this in § but provide some intuition for their meaning here if we can give the type true t q to e e then our logic guarantees that if q is an equivalence relation partitioning t in a set of equivalence classes s and if running e in a heap h reduces to v and e in h reduces to v then for any s s the probability that v s is equal to the probability that v s similar conclusions can be drawn in general for example if q h h x x h h implies p x p x then the validity of the above assertion implies that v v from this interpretation one should be able to see that the relational refinement on the result of sample in rf is not specific to more generally sample can be given a specification to state that any two calls to it return a pair of values related by any given function on its range intuitively relational refinements in rf capture relations between the distribution over values generated by probabilistic programs rather than between values obtained in specific executions the relational typing of sample is valid since applying a function to a value uniformly chosen from a discrete set does not change its distribution to reflect these general properties of uniform sampling our library provides a polymorphic typed variant of sample that takes as additional ghost parameter f a binary predicate on values of type block whose refinement states that it must be an injective function or equivalently a bijection this parameter has kind block block e where e is the kind of ghost refinements in f types in e are erased at runtime in the rf standard library sample is typed as follows type function f a bf a b a b bf a b f a b bb type injective f function f a a b f a b f a b aa val sample f f len f l b r b in our pad example when calling sample n in we instantiate f to b b l p b r p b which is indeed injective in § we describe security proofs of more realistic encryption schemes based on variants of the above typing for sample implicit flows and before our typing rules notably for sample we present a concrete protocol for implemented in rf and we discuss a attack against this protocol recently tag sample nt verify mac verify nt sample kt sharing k nt nt nr nr nt s kt kr exchange data reader sample nr kr verify mac verify nr s kt kr figure basic access control protocol for by and we refer to their work for a detailed discussion this attack is representative of common in cryptographic implementations due to implicit flows in the handling of errors while processing data following the specification for documents all recent european embed tags the basic access control protocol outlined in fig the protocol has two roles a tag and a reader messages using communications the goal of the protocol is to establish a shared session key for accessing data on the each tag has a unique key k the reader derives this key from information obtained by scanning the in there is a of two having the same key because the key is derived from a hash of this information the first samples a bit nt and sends it as a challenge to the reader the reader samples its own nr and some kr then the concatenation of these three values using k concretely the protocol implements authenticated encryption as encryption with a message authentication code mac the and checks the mac to ensure that the message has not been with then compares the received nt with the challenge to that the reader correctly if both checks succeed it generates its own kt them to the concatenation of the two in a different order than before and computes the session key s kt kr the reader then similarly the received checks the mac and computes s the code the tag uses for handling the message of the reader is shown below and provide authenticated encryption and split convert between triples of bit values and their concatenation let tag k nt c match k c with some p let split p in if nt nt then k nr nt sample kt else none the code either produces an message or it returns an error code as written it enables the following attack the attacker any run of the protocol between a target and an reader and records their second message later to test the local presence of this the attacker runs the protocol as the reader the recorded message and the response although the protocol always fails to establish a key the tag returns a if the two are the same and a otherwise return different error messages whereas other european return the same er message but with different although our approach does not directly catch timing attacks those attacks can be conservatively analyzed by treating error codes produced at different code locations as distinct we interpret the above attack as an implicit flow of information from the key used to to the error message indeed if we type the key k as high confidentiality and the nt and the c with eq refinements since they are on a public network relational typechecking fails on the body of tag the result of the decryption is a priori not the same on both sides so the involve proving for instance that when decryption returns some p on the left and none on the right the two resulting expressions are equal which fails on the proof obligation by ensuring that the same error messages are returned in both cases ie by requiring that this case is but this alone is not sufficient for verifying the code the that arise when verifying the nested conditionals require proving under a suitable relational path condition that the encryption on the third line is from the error is false however by several cryptographic assumptions into detailed typing invariants in the protocol implementation we can prove that such problematic never actually arise ie the path conditions these cases are infeasible and we can verify that this code preserves specifically we assume that the encryption is and all specified by typing and that there are no the probability of a is less than q where q is the number of sessions observed by the adversary et al also analyze the protocol using the applied calculus essentially proving in a more abstract symbolic model of cryptography refer to our online for a full listing and further discussion of the specification and implementation of tag formal development we formalize a core of rf in the coq proof assistant by developing p a minimal higherorder language with statically allocated references probabilistic assignments and unbounded recursion the formalization is based on the extension and on the library for distributions overall the formalization over lines of code the libraries the formalization is built in two steps first we consider a simply typed system g e e t for p simple types t are extended to relational refinement types c where one can add relational postconditions to function types this allows us to define a relational type system g e e c that relates a pair of expressions e and e in the type c under the relational context g we then give a denotational semantics for welltyped judgments simple types are given a cpo interpretation t in the standard way judgments g e e t are interpreted as the elements of the form e i where i is any valuation for the context g taking into account that p is a language with references and probabilistic assignments the denotation e i of e is defined as a function from memories equivalently states or heaps to distributions over pairs composed of a memory and an element of t we denote by m t this function space relational types c are interpreted as a binary relation c over m t where t is the simple type derived from c by all refinements this allows us to interpret theorem a valid judgment g e e c by all the pairs of the form e il e ir c for any pair of valuations il ir for the erasure g of g x t g l r g g x t gg xt r ref b l r g g r b g g vi t g g v v g g y b g g y b figure wellformed relational formulas p syntax p is a simply typed calculus with references and probabilistic assignments for simplicity we only consider two forms of probabilistic assignments assigning a uniformly boolean to a boolean variable flip and assigning an integer value uniformly in a nonempty interval i j to an integer variable formally the sets of types contexts values and expressions are given by the following grammars type t b t t g g x t value v u c x vn fun x t e expr e v e v r r v flip let x e in e letrec f x e in e if v then e else e where x ranges over a set var of variables r ranges over a set ref of references and o ranges over a set o of operators whose signature is of the form b × · · · × bn b we assume that b contains the unit type unit along with the types of booleans bool and integers int their associated constructors are · true false and n for n n we implicitly assume that each reference has an ambient base type and write r ref b to denote that r is a reference with base type b the dynamic semantics is defined in the standard way as the compatible closure for a callbyvalue convention of the p typing as usual a typing context is a sequence of bindings x t such that the bound variables are pairwise distinct the typing rules for deriving valid judgments g v v t and g e e t in a simply typed setting are standard and omitted relational refinement types relational assertions are formulas over tagged variables xl or xr and tagged references rl or rr informally tags determine whether the interpretation of x or r will be taken wrt the left or right projection of a relational valuation in order to interface with automated firstorder provers relational assertions are firstorder formulas built from operators in o and predicates taken from a set of predicates that includes at least the equality predicates for all the base types note that tagged variables always occur free in assertions and only logical variables can be bound for instance the relational assertion y int xl y xr y rr is wellformed under any context g such that x int g assuming that r ref int formally relational assertions are defined using a firstorder type system with judgments of the form g g for formulas resp g g v t for values where g resp g is a context for relational variables resp for variables introduced by quantifiers figure shows the typing rules for variables references equality and universal quantification we say that an assertion is wellformed in context g iff g written g refinement types are either relational types denoted by t u v which will be used for relational typing of values or computation types denoted by c used for relational typing of expressions they are defined by the following grammar t u v b x t c c x t where and are relational assertions by convention x is bound in x t c and x t and can be free in c or however the type system enforces that x occurs in c and only if t is a base type in other cases we write t c and t a relational context g is a sequence of bindings x t such that the bound variables are pairwise distinct the refinement type t is a refinement of t under g written g t t if t is the result of all pre and postconditions occurring in t and if any assertion that appears in t is wellformed in g augmented by the local context of in t this relation is extended to relational contexts g g is the smallest relation such that and if g g and g t t then g x t g x t relational typing figure gives a significant subset of the rules that define the relational typing judgments g v v t for values and g e e c for expressions in the figure ex e e stands for e the full set of rules appear in the coq formalization a judgment of the form g e e x t is valid when for any pair of valuations il ir for g and any pair of states m m satisfying the precondition the distributions over values and states obtained by executing e in il m and e in ir m are related by the lifting of the postcondition to distributions the formal notion of lifting a relation to distributions is given below we that although assertions in relational refinements are firstorder formulas that do not mention probabilities the definition of lifting is such that valid typing judgments can be used to prove relations between probability for instance when denotes an equivalence relation on t e e t implies that pre s pre s for any equivalence class s of intuitively observing to which equivalence class the results belong does not help in distinguishing the two expressions as sketched in § we are not limited to simply proving probabilistic equivalences other kinds of probabilistic assertions eg inequalities can also be expressed the rules come in two or rules allow us to relate programs with the same head symbol for instance rules let and app are they work by relating subexpressions pairwise composing pre and postconditions using the implicit order of evaluation rule let this with the postcondition of the expression being the precondition of the body it is not always possible to progress using rules for instance one may want to show that the two expressions if b then v else v and v are related by a suitable postcondition the two expressions having different head symbol no rule can apply rules allow us to overcome this limitation rule which permits to relate an to an arbitrary expression is an example of a rule all the rules come in pairs one variant tagged left where the is done on the left expression and one tagged right where the is on the right instead of showing both cases explicitly we give a general rule sym that transforms any left rule into its right counterpart rules for reference assignment ref which come in two too make use of the ability to write assertions about the resulting memory for example the two expressions r v and r v are related by a postcondition when after replacing all occurrences of rl resp rr with v resp v holds as a precondition so far we only considered rules for expressions by constructions rules for random sampling flip and sample are and require the existence of a bijection f between the support of the two distributions ensuring a correspondence between related values in the case of flip we explicitly give the only two existing from bool to bool p denotational semantics background the denotational semantics of welltyped expressions is based on the monad over sets and its generalization to complete partial orders cpos recall that a cpo is a partial order in which every chain has a the unit interval has a cpo structure wrt the natural order on reals moreover every set can be lifted to a flat cpo by adding a bottom element and the set of functions a b between a set a and a cpo b can be given the structure of a cpo a function between two cpos is monotonic if it is and it is continuous if it is monotonic and preserves given two cpos a and b we let a m b and a c b denote the set of monotonic and continuous functions from a to b respectively by fixed point theorem every continuous function f on a cpo has a least fixed point fix f a discrete over a set x is a continuous functional µ x c c that satisfies axioms of linearity compatibility with inverse and in particular the latter axiom states that the support of µ consisting of all elements x x such that µ x is x denotes the function for x ie xx and xy if x y we let dx be the set of discrete over x dx has the structure of an complete partial order moreover can be given the structure of a monad the unit and composition operators are denoted by unit and bind respectively the relational interpretation of types on an operator · that relations over a × b into relations over da × db the operator is inspired from early works on probabilistic bisimulations and is used in and to interpret relational judgments formally let µ da and µ db then r µ µ iff µ da × b µ µ µ µ r where and are the projections for distributions over pairs ie µ bind µ x y unit x µ bind µ x y unit y a fundamental property of this lifting operator is that given f a c and g b c such that a a b b r a b f a g b then r µ µ implies that µ f µ g ie the expected values of f in µ and g in µ coincide note that events can be viewed as valued functions and in this case expectation coincides with probability interpretation we first provide a interpretation of valid judgments we assume each base type b is interpreted as a flat cpo b and that each constructor c belonging to the base type b is given a denotation bc b we define the set of values as b b and then the set m of states as the set of welltyped mappings from references to values m m ref b r ref b mr b b then we extend the interpretation to functional types by setting t t t c m t where mx m dx × m a valuation i is a function that maps every declaration x t to a value a valuation i is wellformed for g written i g if i maps every declaration x t in g to an element of t g v v b g v v b g v v b gg g g x var g x x gx g x b e e c g g g fun x b e fun x b e x b c g x t e e c g g x c fun g fun x t e fun x t e t c g v v b g g g xb g v v x v vx b g v v t g g g value g v v t r ref b g g v v b g g g xb ref g r v r v x v r r ref b g g g g v v b g e e v g r v e e rl g e e x b c g v v b g e v e v cx v v g e e t c g v v t app g e v e v c g e e x t let g x t e e y u x g let x e in e let x e in e y u gg g e e t g x t e e y u g let x e in e e y u x e f x g f x t u x t e e u letrec g f x t u e e y v g letrec f x e in e letrec f x e in e y v gg g v v bool g e e x t g e e x t g if v then e else e e vl x t if g g g v v bool g e e x t g e e x t g if v then e else e if v then e else e vl vr vl x t flip g g g g f x x or f x ¬x flip flip y bool x y f yx bool e µ e g e e c g e e c sample g g g g xint f n n from ij to ij x y f yx int g e e c · is the operator and sym g e e c figure relational typing rules let i be a valuation and m be a memory the interpretations v i of a value v and e m i of an expression e are defined in figure if i is a wellformed valuation for g and g v v t is derivable then v i t likewise if g e e t is derivable then m e m i m t we now turn to giving a relational interpretation of valid ments a wellformed relational valuation i for g written i g is a pair of wellformed valuations for g if i il ir we write i resp i for il resp ir and ix for we assume given a relational interpretation for formulas written i such that for any formula wellformed under g for any relation valuation i g i is a binary rela tion on m this relation is defined as usual using the val resp memory argument for interpreting variables on the resp references on the figure defines the interpretation of relational types written g t t i and computation types written g c t i wrt a relational valuation i a relational valuation i is wellformed wrt a relational context g written i g if for any context g such that g g and every variable x declared in g ix g gx gx i finally we define the semantic validity of judgments we say that two values v and v are semantically related in t under g written g v v t if g g and g t t and i g v i v i g t t i we say that two expressions e and e are semantically related in c under g written g e e c if g g and g t t and i g m e m i m e m i g c t i the following theorem states that all judgments of the logic are sound wrt their interpretation it implies that typing can be used to verify probabilistic claims thanks to the properties of lifting theorem soundness · if g v v t then g v v t · if g e e c then g e e c ci xi fun x t e i bc ix d m e m i v m i unit v i m ev m i bind e m i f m f v i m let x e in e m i bind e m i d m e m i letrec f x e in e m i bind fix f d m e m i f d r m i unit mr m r e m i bind e m i d m · mr d flip m i bind ub b b m m i bind n n m where f df dx m m m if df figure interpretation of values and expressions technically we prove the soundness of each rule as a lemma directly from the semantics it allows us to fall back to the full generality of coq whenever reasoning outside of the logic is required encoding p in rf we now discuss our language design and implementation there are two key ideas behind our encoding of p in rf first as shown in § we introduce probabilistic computations into f by providing a sample primitive at the appropriate type programmers can instantiate sample at runtime by providing a suitable source of next as discussed in § we adapt the hoare state monad st to a monad for computations with relational pre and postconditions we provide here more details about our encodings in particular the style we adopt to compute relational for the monad and the manner in which we reuse classical specifications representing p types to implement p we begin with a translation of its types into f augmented with a relational state monad to close to p our translation uses a monad which we then adapt to the monad of § like in p postconditions in only relate the output values and heaps not the initial heaps specifically the type pre a post can be interpreted in rf as a function over a primitive heap with the signature shown below pre a post l h r h xa post l x r x l h r h the type translation is on most of ps typing constructs with the interesting cases mainly on the computation types where yt is t yy a monad of predicate transformers for vc generation next to provide type inference for rf rather than writing relational hoare triples in we write specifications using predicate transformers this style is adapted from the dijkstra state monad previously introduced for inferring classical verification conditions for stateful f programs in particular we introduce the relational dijkstra state monad and show its signature below we write polymorphic types implicitly assuming their free type variables are quantified type a wp p wp p a p val return xa a p p l x r x val bind a wp xa b wp x b ph h wp x x h h x l xx r xx wp x p h h h h the type t wp is an abbreviation for the monad that is polymorphic in its postcondition specifically t wp is the type of computation which for any relational postcondition p on ts and heaps the precondition on the input heaps is given by wp p unlike the monad the monad yields a weakest precondition calculus by construction as indicated by the signature of bind when composing computations in the monad we simply compute a precondition for the computation by composing the predicate transformers of each component a slight arises from the need to constrain the formal parameter xa of wp in general wp will have free occurrences of l x and r x we relate these to the result of the first computation using the guard l xx and r xx before composing wp and wp additionally by exploiting the postcondition parametricity of we can recover the expressiveness of a place postcondition relation in the monad that we use in our examples we show the definition of below type pre a post a ph h pre h h x x h h post h h x x h h p x x h h lifting classical specifications to reuse of existing verified f code in rf we provide combinators to lift specifications written with classical predicate transformers into the monad to illustrate our approach we show the rf specifications of primitive operations on same combinators apply to arbitrary verified code type lift wp wp p h h wp x h wp x h p x x h h h h type rd x p h p sel h x h val a a lift rd l x rd r x type w x v p h p upd h x v val a va unit lift w l x l v w r x r v the combinator lift takes two classical predicate transformers wp and wp and them by in effect running them separately on the heaps h and h and relating the results and heaps using the relational postcondition p the types given to dereference and assignment should be are simply the relational of the standard classical weakest precondition rules for these constructs rd and w respectively computing relational we the of f s typechecking algorithm to rf although the relational typing rules of fig generally analyze a pair of programs e e for the most part we are concerned with proving relational properties of multiple executions of a single program thus in the special symmetric case where we are analyzing e e the rules of fig into the standard typing rules for monadic f which is parametric in the choice of monad so it to use is easy the main in computing relational arises when analyzing the of conditional this we implement the rules in the judgment and we attempt to to the symmetric case as soon as we detect that the program fragments are indeed the same for example the rule if allows us to relate if b then e else e e by generating for e e and e e where at least the former can be handled once again by the symmetric rules the rules and of fig are impossible to implement in full permit reasoning about stateful programs after arbitrary reductions of open terms instead these rules are approximated by the rf typechecker for terms that can be given classical predicate transformer specifications in particular when trying to relate e e if we can use the symmetric judgments and type e e t lift wp and e e t lift wp then we type e e at type f f t m d u × m t t g t t i f t f t g c u f f g x t c t u i d d b d d g b b i µ µ m d u × m m m m i m m p µ m µ m µ µ g y u u i where p u m u m u u g u u i m figure interpretation of relational refinement types t lift wp wp in effect by making use of classical predicate transformers on either side we approximate the reduction relation for stateful terms used by and all these measures for handling the asymmetric cases are still incomplete when trying to prove a relation between f v g v in a context g with relational types for f and g that cannot be decomposed into a pair of classical specifications it becomes impossible to complete the derivation in such cases rf false as the vc guarded by a relational path condition nevertheless it may still be possible to the vc if the path condition is infeasible this is the case for example when trying to relate the result of with in the example of § proving using z once a vc has been computed we on an existing encoding of for the classic dijkstra monad within z we rely on a theorem from et al which guarantees that despite the use of higherorder logic when computing once a predicate transformer is applied to a specific firstorder postcondition so long as there is no inherent use of higherorder axioms in the context a firstorder normal form for the vc can always be computed applications table summarizes our experimental evaluation of rf for each program we give the target name in the f distribution the number of lines of code and type annotations comments and the typechecking time in seconds which is mostly dominated by the time spent solving in z all experiments were on a hp z core with gb of ram although the verifier makes use of only one core for lack of space most of these examples are only briefly described with a more detailed discussion of the last two programs counter in § a cryptographic construction and in § a privacy protocol information flow the first five programs provide many information flow examples such as those of § and test cases for rules using several variations of the monad construction of § the program illustrates the verification of the basic access control protocol for presented in § it establishes for the modified protocol that returns the same error message in all failure cases as can be expected the original protocol yields a typechecking error its verification illustrates the use of rules for nested tests see tag in § and also involves modelling symmetric encryption random the program ro provides an implementation of a cryptographic hash function in the random oracle model in this model widely used in applied cryptography the hash function is assumed to be from a uniformly random function thus knowledge of the hash function values on a subset of its domain yields no a priori information about its values outside this subset and protocols that share the hash function with an adversary can treat those values as secret as long as they use disjoint subsets of its domain the purpose of ro is to capture this reasoning pattern in a library that enables typebased verification of protocols in the random oracle model our implementation samples and the random function using a mutable reference holding a table mapping hash queries made by both participants h and adversaries a to verify the program this table carries several invariants including that the tables grow that in every pair of executions the tables agree on the fragments corresponding to queries made by a and that on the fragments corresponding to queries by h the entries are related by an injective function that ensures they have distributions the interface of ro is designed to allow the full use of relational sample on the h fragment and to account for failure events eg returning a value to a that with one that was already provided to h allowing for its modular use in a context that must bound their probability encryption to adaptive and attacks is a standard cryptographic security assumption for public key encryption schemes to verify protocols relying on this assumption we program an ideal stateful functionality for encryption that maintains a log of prior oracle similar to those proposed by fournet et al but with a more convenient relational interface using the f type system with only classic refinements they require that all code that operates on be placed in a separate module that exports as an abstract type using instead relational types for in the style of § we lift this restriction enabling us to verify protocol code that uses encryption without our code is essentially higherorder it simulates ml functors using a dependently typed record of functions authentication exploiting the modularity of our implementation we program and verify a protocol that illustrates a common authentication pattern based on fresh random values or formalizing the intuition that if a a fresh using the public key of b and later a response containing that then the whole response must have been sent by b private authentication further extending and relying on a variant of we implement a protocol for private authentication proposed by abadi and fournet that allows two to one another and to private communications without their presence and identities to third although the protocol has been studied symbolically in the applied pi calculus to our knowledge we provide its first verification in a computational model of cryptography encryption the security of encryption by reduction to the assumption is a classic example of cryptographic proof we verify it in rf building on an axiomatic theory of cyclic groups security up to bad the program illustrates a common pattern to prove refinement formulas of the form bad where is the property we are interested in and bad captures conditions that may cause the program to fail usually with a small probability eg when the adversary a private key to name pure pure st ro counter total loc description information flow with arithmetic information flow inference information flow inference variant information flow with state information flow using rules for protocol hash function encryption authentication protocol private authentication protocol encryption reasoning counter mode using smart protocol table summary of experiments avoid all our specifications with this disjunction we define an variant of the monad where all pre and postconditions and all heap invariants are enforced only as long as a distinguished boolean memory reference is false intuitively this adds an implicit bad to every refinement our encoding proceeds in two steps first we define a p the type of monotonic references r to an whose contents can be updated only when the update condition p holds that is when p is a reflexive transitive binary given two heaps h and h if h is a successor of h then p sel h r sel h r holds we give below the resulting specification of requiring the update condition p as a precondition private type a pa a e ref a val a pa a e a p va h h p sel h l r l v p sel h r r r v unit h h h h h l r l v h r r r v next we define upto bad requires a ensures as an alias for the monad with precondition requires result type a and postcondition ensures unless the reference bad is set to true in the left or right heap in which case both pre and postconditions are trivial type bad b h h sel h l sel h r type upto bool b b heap e a heap a a heap heap e h h requires h h bad bad h h a h h x x h h ensures h h x x h h bad bad h h independently we can compute or bound the probability of bad being set to true for for instance we set bad to true as we detect a between two and bound its probability with q where q is the number of sessions functions and from the pad example § we implement a more useful symmetric encryption scheme based on a block such as or blocks are just byte arrays eg bytes for block take a key and a block and produce a block a common cryptographic security assumption is that the block is a function for a fixed key generated uniformly at random and used only as input to the the is computationally from a uniformly random function from blocks to blocks we first present our sample scheme then formalize the assumption and finally explain how we verify it by relational typing in counter mode the purpose of symmetric encryption modes is to apply the block with a sin short secret in order to many blocks of in counter mode to a sequence of blocks pi we use a sequence of index blocks ii obtained for instance by a counter we independently apply the block to each ii to obtain a mask mi and compute the block ci as pi mi effectively using the masks as pads a practical advantage of this construction is that both encryption and decryption are fully and that the sequence of masks can be the blocks i need not be secret but they must be otherwise from the two p mi and p mi one trivially obtains p p which leaks a full block of information for simplicity we keep the block key implicit writing f for the resulting function we focus on the functions for processing individual blocks rather than lists of blocks and we the public index to every block first assume there is a single that counts using an integer reference and uses to format the integer as a block let n ref let let i n in n n i f i p let i c f i c to enable independent of blocks we can remove the global counter and instead sample a block i for each encryption as follows this random block i is called the initialization vector iv for the encryption let let i sample in i f i p much as for the pad we show that and can be typed as block eq block block the type of functions from private blocks to pairs of public blocks under suitable cryptographic assumptions more general combinations of sampling and can also be used for independent for instance the usual counter mode is as let counter mode block let iv sample in let i ref iv in fun p i f i ps functions to study the security of protocols using a block we program and type it as a random function from blocks to blocks to test our encryption we also implement it concretely by just calling if we can prove the security of a protocol using this ideal implementation then the same protocol using the concrete block is also secure under the assumption with a probability loss bounded by the probability of distinguishing between the two we implement the function f using lazy sampling when called f first looks up for a mask in its log otherwise f samples a fresh mask as for the pad we pass the block p as a ghost parameter and take advantage of sampling to generate a mask with a relational refinement to specifically hide p of course this fails if the mask has already been so we type f for encryption with a precondition that depends on the current log and requires that i does not occur in the log yet we use the same code with a different type for decryption that i occurs in the log val f pre block post where pre h h requires i not in the log yet not in l i domain sel h l log l i r i l i sel h l n and post h h m m h h ensures log extended with mask l p r p m m and ms related by h upd h l log entry l i l p h l log h upd h r log entry r i r p h r log let f p i match assoc i log with some m m unreachable none let m sample p in log entry i p m when using a single counter function typechecking relies on a joint invariant on the counter n and the content of the log that states that all entries in the log have an index block i from some n n it also involves counter and assuming that is injective this enables us to prove that our encryption is secure with no loss in the reduction the advantage of a adversary against our code is the same as the advantage of some adversary against the assumption when using instead a fresh random block function the situation is more complex as there is a nonnull probability that two different sample the same index i our construction is secure as long as no such happen we capture this event using the up to bad approach presented above for a fresh module that detects and sets the bad flag accordingly concretely the probability of having a when sampling q blocks of bytes each is bounded by q by typing we prove that encryption and any program that may use it leaks information only once bad is true thus we prove the concrete security of with a loss of q in the reduction to smart we finally implement and verify the fast protocol of and which involves recursive data structures and the protocol has three roles · a certified that issues private signed finegrained say one reading every · a utility that issues public signed for the same time intervals depending on some public policy and · a user who receives both inputs at the end of the to compute and pay his the two security goals of the protocol are to guarantee integrity of the fee to the utility and privacy of the detailed which otherwise leak much information on the users the protocol relies on and signatures next we explain how we prove perfect privacy entirely by relational typing and computational integrity by reduction to the discrete log problem by typing using we first implement typed parameterized by some multiplicative group of prime order p we outline their interface and review their main security properties type eq public param type opening eq trap l pp l x l o trap r pp r x r o val sample opening pp x val commit pp x elt c commit pp x r let commit pp x r x r let verify pp x r c c x r the public parameters pp consist of the prime p and two distinct group generators g and h possibly chosen by the utility and range over integers modulo p a to x with opening o is a group element c although assumed hard to compute there exists known as the for these parameters such that g h accordingly we use trap pp for specification purposes in refinement formulas but not in the protocol code we use in particular to specify an injective function for randomly sampling the opening o modulo p so that it x the relational refinement type opening in the postcondition of sample records that l x l o r x r o which implies and enables us to type the result of commit as public eq elt intuitively every can be to any x for some o so the itself does not leak any information about x as long as o is randomly and kept secret at the same time given x and o it is computationally hard to open the to any x x can be gx ho and to compute to linear combinations of their without necessarily knowing them these operations are used below to compute the their omitted types show that they preserve eq and opening relational refinements next we show some typed code for each role of the protocol we have abstract predicates and to specify lists of and we rely on a signature scheme to sign a list of to private this scheme is assumed against existential attacks as explained in we express this property using refinements for simplicity we keep the and verification keys implicit type signed elt cs commits pp val sign list pp cs eq val verify signature list elt eq bool signed pp cs the signed predicate above states that the have been computed from it is a precondition for at the and a postcondition of signature verification at the utility it uses a specification function that takes a list of pairs and returns the list of their first projections given xs the function below calls commits a recursive function that maps sample and commit specified above to every element of xs and returns both a list of pairs of and xt ot for the user and a public list of ct for the utility these are then signed yielding a public signature from their eq types we can already conclude that the data passed from the to the utility that is the list of and its signature does not any information about the val int xs xint opening pp x xs list elt eq commits pp cs let pp xs let commits pp xs in cs sign pp cs user given a list of pairs xt ot from the and a list of pt from the utility the user calls make to compute two scalar products the fee t and a fee opening t and pass them to the utility val make list opening pp x list text l ps r ps sp l l ps sp r r ps eq text eq let make pp ps let xr sums ps in xr the relational precondition on the th line sp is a declassification condition capturing the users to the fee computed as the scalar product sp of the detailed and by requiring that the left and right be equal by typing the code of the double scalar product sums we get the same equation for the showing that the fee opening is then also public the result type of make tells us that those two scalars reveal no further information on any leading to the same fee more explicitly we can use the types of the and the user to typecheck a privacy game the adversary chooses a list of and two lists of leading to the same fee obtains the list of its signature the fee and the fee opening computed by the and user code for one of the two each selected at random with probability and attempts to guess which of the two was used typing guarantees that the adversary guess does not depend on the random selection of hence that the guess is correct with probability interestingly this privacy property is and does not rely on any computational assumption utility the utility verifies the signature on the ct uses the pt to compute the product of t hot pt t g ht t and compares it to the computed from the fee x and fee opening o presented by the user unless the user can open a to several values x which can be further reduced to the discrete log problem this that x is the correct to type the verifier code we write classic but nontrivial refinements using ghost scalar products to keep track of its computation val verify list ps list elt seq from the text req from the user bool xs xs xs ps let verify pp ps cs s x r verify signature pp cs s verify commit pp x r pp cs ps related work and conclusions our work semantics of higherorder probabilistic programs relational program verification and cryptographic protocol verification enabling us to verify the security of protocol implementations under computational assumptions by relational typing reasoning about probabilistic programs the semantics of rf is based on the monadic representation of probabilities used in our semantics is confined to discrete for some applications such as and machine learning it is however essential to support continuous distributions higherorder programs over continuous distributions are considered in an alternative approach is to embed probabilistic programming in a general purpose language as done eg by and reif kozen and and were among the first to develop logics for reasoning about probabilistic programs similar logics were later developed by and morgan and more recently by et al provides a formalization of the framework of and morgan in the hol proof assistant all these logics are and do not allow directly proving relations between probabilities relational program verification relational hoare logic was first introduced for a core imperative program to reason about the correctness of program optimizations and information flow properties it was later extended to probabilistic procedural programs with code and used to formally verify security proofs of cryptographic constructions and differential privacy of randomized algorithms relational hoare type theory is an extension of hoare type theory used to reason about advanced information flow policies of higherorder stateful programs with real world data structures does not consider probabilistic computations which are essential to reason about cryptographic protocols is fully formalized as a shallow embedding in the coq proof assistant the formalization is restricted to programs with firstorder store but in principle it could be extended to programs with higherorder store using an axiomatic extension of coq in contrast we formalize in coq a core fragment of rf and rest on the f infrastructure to verify large programs our formalization is restricted to programs with firstorder store as we adopt a deep embedding our formalization could in principle be extended to higherorder store using recent developments in stepindexed semantics beyond and there have been many efforts to develop and sometimes program logics for higherorder stateful programs see for an account of the field relational logics can also be used to reason about continuity naturally numerous program analyses and specialized relational logics enforce properties of programs comparison with is a framework for proving the security of cryptographic constructions in the computational model the core of is a probabilistic relational hoare logic that is able to capture common patterns of reasoning in cryptographic proofs including observational equivalence equivalence up to failure and arguments the relational refinement type system of rf is inspired from but it also concerns of compatibility with f and automation in contrast to rf offers only limited support to carry relational reasoning about structurally different programs and to reason about probabilities of postconditions the latter is achieved in using a probabilistic but hoare logic which has no counterpart in rf as a consequence some cryptographic constructions whose formalization in requires interactive proofs and complex probabilistic arguments cannot be verified in rf on the other hand verification in rf is fully automatic moreover is not primarily designed for building verifying and large systems recent work how can be used to verify c implementations of wellknown cryptographic constructions and through verified compilation derive guarantees about x however this approach does not scale to verifying detailed protocol implementations in contrast rf allows programmers to combine relational and refinements freely so that relational reasoning steps can take advantage of program invariants embedded in refinements this ability of rf is essential to verify system implementations that rely on cryptography protocol verification recent account of the field of protocol verification provides a of existing tools and major most of the literature focuses on verifying protocol specifications or protocol implementations through model alternatives include generating implementations from verified models our work is most closely related to approaches that reason directly about implementations in the symbolic or computational models modular typebased cryptographic verification type systems apply to many notions of security in the context of computational cryptography fournet et al rely on f typed interfaces to encode classic security definitions such as and using a combination of type refinements for and type abstraction for integrity and confidentiality in comparison rf enables both probabilistic and relational reasoning letting us typecheck constructions previously out of reach in their reference implementation of for example the security of several cryptographic constructions is specified by typing but justified by proofs the corresponding code is trusted rather than this is the case eg for the construction in the record layer somewhat similar to our counter mode encryption example in § we intend to carry over their lines of code to rf their detailed classic refinements unchanged and making use of relational typing to verify additional cryptographic libraries conclusions and our work on rf represents a significant first step towards our goal of building software whose security has been verified down to core cryptographic assumptions on the theory side we have shown how to generalize prior probabilistic relational logics to a higherorder language which provides a formal basis for the use of highlevel abstractions in system implementations practically through careful language design our extension of f towards rf the way for carrying out probabilistic relational verification in a manner using refinement types and smt solvers still much remains to be done as immediate next steps we extending our theory to account for dynamic allocation and local state toward improving our tools on the empirical side we plan to port an existing reference implementation of to rf we expect that rf s more flexible idioms better support for type inference and its kernel will ease verification and allow us to push towards obtaining a implementation of the standard with certified security references m abadi and c fournet private authentication theor comput sci ­ m a d gordon and j computational verification of c protocol implementations by symbolic execution in ccs pages ­ acm j b m g and f certified cryptography efficient provably secure machine code from highlevel implementations in ccs acm also appears as report a w appel and d a an indexed model of recursive types for foundational proofcarrying code acm trans program lang syst ­ m t e and m and using the applied pi calculus in pages ­ ieee computer society p and c proofs of randomized algorithms in coq sci comput program ­ g b and s formal certification of cryptographic proofs in popl pages ­ acm g b s and s security proofs for the working in volume of lecture notes in computer science pages ­ springer g b y and s beyond provable security security of in volume of lecture notes in computer science pages ­ springer g b f and s probabilistic relational reasoning for differential privacy in popl pages ­ acm n benton simple relational correctness proofs for static analyses and program transformations in popl pages ­ acm k c fournet and a d gordon modular verification of security protocol code by typing in popl pages ­ acm k c fournet m a and py implementing with verified cryptographic security in sp pages ­ ieee computer society b security protocol verification symbolic and computational models in post volume of lecture notes in computer science pages ­ springer j a d gordon m j and j v measure transformer semantics for bayesian machine learning in esop volume of lecture notes in computer science pages ­ springer d and b from protocol specifications to implementations in pages ­ ieee computer society r l p and a reasoning about probabilistic sequential programs theor comput sci ­ s s gulwani and r continuity and of programs acm ­ t and v a attack against in fc volume of lecture notes in computer science pages ­ springer m r and f b j of comput sec ­ l m de and n z an efficient smt solver in tacas volume of lecture notes in computer science pages ­ springer f a d gordon j and d a a generalpurpose c verifier to prove cryptographic protocols in pages ­ ieee computer society y a and d a probabilistic dynamic logic j comput syst sci ­ c fournet m and py modular cryptographic verification in ccs pages ­ acm j a goguen and j security policies and security models in sp pages ­ ieee computer society g a and e a small scale reflection extension for the coq system technical report rr inria j a and c morgan probabilistic guarded commands mechanized in hol theor comput sci ­ b w yi and k g probabilistic extensions of process algebras in of process algebra pages ­ o and cc embedded probabilistic programming in volume of lecture notes in computer science pages ­ springer d kozen a probabilistic pdl j comput syst sci ­ r t and j a framework for the cryptographic verification of programs in pages ­ ieee computer society j towards a mathematical science of computation in ifip pages ­ a and c morgan abstraction refinement and proof for probabilistic systems in computer science springer a g morrisett a p and l birkedal dependent types for imperative programs in icfp pages ­ acm s park f pfenning and s a probabilistic language based upon sampling functions in popl pages ­ acm t p and secure secret sharing in volume of lecture notes in computer science pages ­ springer n ramsey and a stochastic lambda calculus and monads of probability distributions in popl pages ­ acm j h reif logics for probabilistic programming extended abstract in pages ­ acm b and n a guide to program logics for higherorder store unpublished manuscript a and g smart in pages ­ acm a sabelfeld and a c myers languagebased informationflow security ieee journal on selected areas in communications ­ g a and a dependent types for enforcement of information flow and erasure policies in heterogeneous data structures in pages ­ acm py n c fournet and j chen certified in f with coq in popl pages ­ acm k l birkedal and a state and dependent types in pages ­ springer n j chen c fournet py k and j yang secure distributed programming with types in icfp pages ­ acm n j c j chen and b verifying higherorder programs with the dijkstra monad in pldi pages ­ acm 