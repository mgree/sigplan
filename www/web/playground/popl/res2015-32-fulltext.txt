equations contractions and unique solutions sangiorgi di inria abstract one of the most studied behavioural equivalences is bisimilarity its success is much due to the associated bisimulation proof method which can be further by means of upto bisimulation techniques such as upto context a different proof method is discussed based on unique solution of special forms of called contractions and inspired by milners theorem on unique solution of equations the method is as powerful as the bisimulation proof method and its upto context the definition of contraction can be onto other behavioural equivalences possibly contextual and this enables a coinductive reasoning style on such equivalences either by applying the method based on unique solution of contractions or by appropriate contraction into the bisimulation game the techniques are illustrated on languages an example dealing with higherorder languages is also shown categories and subject descriptors f logics and meaning of programs specifying and verifying and reasoning about of programs f logics and meaning of programs semantics of programming semantics general terms theory keywords bisimulation coinduction equations unique solution contraction introduction bisimilarity is employed to define behavioural equivalences and reason about them in concurrency theory bisimilarity is now widely used also in other areas as well as outside computer science in this paper behavioural equivalences hence also bisimilarity are meant to be weak because they abstract from internal moves of terms as opposed to the strong ones which make no between the internal moves and the external ones ie the interactions with the environment weak equivalences are practically the most relevant ones eg two equal programs may produce the same result with different numbers of evaluation steps permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm in proofs of bisimilarity results the bisimulation proof method has become particularly with the of the method provided by the so called upto techniques among these one of the most powerful ones is upto expansion and con text the derivatives of two terms can be rewritten us ing expansion and bisimilarity and then a common context can be erased forms of bisimulations upto context have been shown to be effective in various fields including process calculi calculi and automata the document for bisimilarity is milners ccs in the milner carefully explains that the bisimulation proof method is not to be the only method for reasoning about bisimilarity indeed various interesting examples in the are handled using other techniques notably unique solution of equations two tuples of processes are bisimilar if they are solutions of the same system of equations this method is important in verification techniques and tools based on algebraic reasoning milners theorem that guarantees unique solutions has how ever limitations the equations must be guarded and sequential that is the variables of the equations may only be used a visible prefix and in the syntax tree only by the sum and prefix operators this limits the expressiveness of the tech since occurrences of other operators above the variables such as parallel composition and restriction in general cannot be removed and its onto other languages eg languages for distributed systems or higherorder languages which usually do not include the sum operator in this paper we propose a refinement of milners technique in which equations are replaced by special called tions intuitively for a behavioural equivalence its contraction is a preorder in which p q holds if p q and in addition q has the possibility of being as efficient as p that is q is capable of simulating p by performing less internal work it is sufficient that q has one efficient path q could also have other paths that are slower than any path in p uniqueness of the solution of a system of contractions is defined as with systems of equations any two solutions must be equivalent with respect to the with equations is in the meaning of solution in the case of contractions the solution is evaluated with respect to the preorder rather than the equivalence if a system of equations has a unique solution then the system of contractions obtained by replacing the tion symbol with the contraction symbol has a unique solution too the converse however is false it may be that only the system of contractions has a unique solution more important the condition that guarantees a unique solution in milners theorem about tions can be relaxed is not required and guarded ness can be replaced by weak that is the variables of the contractions can be any prefix including a prefix representing internal work this is the same constraint in milners unique solution of equations theorem for strong bisimilarity the constraint is unsound for equations on weak bisimilarity we show that milners theorem is not complete for pure equations equations in which recursion is only expressible through the variables of the equations without using the recursion construct of the process language there are bisimilar processes that cannot be solutions to the same system of guarded and sequential pure equations in contrast completeness holds for pure contractions the contraction technique is also computationally complete any bisimulation r can be transformed into an equivalent system of contractions that has the same size of r where the size of a relation is the number of its pairs and the size of a system of contractions is the number of its contractions an analogous result also holds with respect to bisimulation such as bisimulation upto expansion and context the contraction technique is in fact computationally equivalent to the bisimulation upto contraction and context technique a refinement of bisimulation upto expansion and context the contraction technique can be generalised to languages whose syntax is the term algebra derived from some signature and whose semantics is given as an lts in this the condition for contractions becomes a requirement of essentially saying that the processes that replace the variables of a contraction do not contribute to the initial action of the resulting expression the technique can also be onto other equivalences including equivalences such as barbed congruence and equivalences such as contextual equivalence ie may testing and trace equivalence for each equivalence one defines its contraction preorder by controlling the amount of internal work performed finally we show that a contraction preorder can be injected into the bisimulation game that is given an equivalence and its contraction preorder we can define the technique of bisimulation upto and context in the bisimulation game the derivatives of the two processes can be manipulated with and similarly to the that are possible in the standard bisimulation upto expansion and context using the expansion relation and bisimilarity and a common context can then be erased the resulting bisimulation upto and context is sound for this technique allows us to derive results for using the bisimulation proof method the contraction technique cannot however be onto all weak behavioural equivalences for instance it does not work in the setting of trace equivalence two processes are equal if they have the same finite and infinite traces and must testing a discussion on this point is deferred to the section we conclude the paper with an example of application of contractions to a higherorder language which exploits the condition structure of the paper all background material is reported in section contractions and their properties are introduced in section for bisimilarity and the ccs language the extension to languages defined from a generic signature is presented in section the of contractions onto other behavioural equivalences is discussed in sections barbed congruence contextual equivalence trace equivalence and to certain equivalences the injection of contractions into the bisimulation game is described in section the example with higherorder languages is reported in section background ccs we assume an infinite set of names a b and a set of constant identifiers or simply constants for writing recursive processes the special symbol does not occur in the names and in the constants the class of the ccs processes is built from the operators of parallel composition guarded sum restriction and constants and the guard of a sum can be an input an output or a prefix p p p ii pi a p k µ a a where i is a countable indexing set sums are guarded so to ensure that behavioural equivalences and are we write when i is empty and p q for binary sums with the understanding that to fit the above grammar p and q should be sums of terms each constant k has a definition k p we sometimes omit eg writing a b for a b we write p for p by n in a few examples we write µ p as abbreviation for the constant µ p the operational semantics is given by means of an lts and is reported in figure the symmetric version of the two rules for parallel composition has been omitted the immediate derivatives of a process p are the elements of the set p p µ p for some µ we use to range over visible actions ie inputs or outputs some standard notations for transitions is the reflexive and transitive closure of and µ is µ the composition of the three relations moreover p µ p holds if p µ p or µ and p p similarly p µ p holds if p µ p or µ and p p we write p µ np if p can become p after performing n finally p µ holds if there is p with p µ p and similarly for other forms of transitions further notations letters r s range over relations we use infix notation for relations eg p r q means that p q r we use a to denote a tuple with many elements thus the tuple may also be infinite all notations are extended to tuples eg p r q means that pi r qi for each component i of the tuples p and q and cp is the process obtained by replacing each hole of the context c with pi we write rc for the closure of a relation under contexts thus p rc q means that there are a context c and tuples p q with p cp q cq and p r q we use symbol def for abbreviations for instance p def g where g is some expression means that p stands for the expression g in contrast symbol is used for the definition of constants whereas is used for syntactic equality and for equations if is a preorder then is its inverse and conversely bisimilarity and expansion we focus on weak behavioural equivalences which abstract from the number of internal steps performed definition bisimilarity a process relation r is a bisimulation if whenever p r q we have p µ p implies that there is q such that q µ q and p rq the converse of on the actions from q ii pi pi p µ p p q µ p q p a p q a q p q p q p µ p a p µ a p µ a a figure the lts for ccs p µ p k µ p if k p p and q are bisimilar written p q if p r q for some bisimulation r we sometimes call bisimilarity weak bisimilarity to distinguish it from strong bisimilarity obtained by replacing in the above definition the weak answer q µ q with the strong q µ q the bisimulation proof method can be by means of upto techniques one of the most useful auxiliary relations in upto techniques is the expansion relation e this is an asymmetric version of where p e q means that p q but also that q achieves the same as p with no more work ie with no more actions intuitively if p e q we can think of q as being at least as fast as p or more generally we can think that p uses at least as many resources as q definition expansion a process relation r is an expansion if whenever p r q p µ p implies that there is q with q µ q and p r q q µ q implies that there is p with p µ p and p r q p expands q written p e q if p r q for some expansion r relation e is studied ­ using a different terminology ­ by and hennessy they show that e is a tractable preorder and has a complete proof system for finite terms based on a modification of the standard laws for ccs in ccs strong and weak bisimilarity are congruence relations and expansion is a it holds that e and e moreover each inclusion is strict the are obvious for the strictness we have that p p p e p and p e p p p a powerful upto technique is bisimulation upto e and context it combines upto expansion the possibility of rewriting the derivatives of two related processes using e and with upto context the possibility of removing a common context from the derivatives we recall that rc is the context closure of r definition bisimulation upto e and context a process relation r is a bisimulation upto e and context if whenever p r q we have p µ p implies that there is q with q µ q and p rc q the converse of on the actions from q e the occurrence of e on the left of rc cannot be replaced by as this would break the soundness of the technique the technique is sound lemma soundness of bisimulation upto e and context if r is a bisimulation upto e and context then r an example in examples in the paper we sometimes use a version of ccs with value passing this could be translated into pure ccs but having explicit value passing improves readability in a calculus ax p is an input at a in which x is the for the value received whereas a n p is an output at a of the value n and a n is a constant the following example illustrates bisimulation upto e and context and will then be used for comparison with other techniques we wish to implement a server that when by clients at a channel c starts a certain interaction protocol with the client after an auxiliary server a at a here the auxiliary server a is deterministic at every cycle it outputs an integer value which changes with the cycle this change is represented by the successor function for simplicity we consider two implementations of the server the difference between them is that the first server l is lazy and a only after a request from a client has been received in contrast the other server e a so to be then ready in a client l cz ax l r c x z e ax cz e r c x z a n a n a n here r c x z represents the interaction protocol that is started with a client and can be any process it may use the values x and z obtained from the client and the auxiliary server a the interactions produced may actually depend on the values x and z process r c x z may also use channel c and therefore trigger further interactions with the main server in contrast r c x z may not use a ie it may not the auxiliary server we use the bisimulation upto expansion and context technique to prove that the composition of the two servers with a yields bisimilar lazy and eager systems ls n es n def a a n l def a a n e relation r def n es n is a bisimulation upto expansion and context consider a pair ls n es n the two processes have one initial transition the most interesting case is the challenge transition from es n and we only consider this one we have es n a a n cz e r c n z def e process ls n may not produce internal steps hence its only possible answer is ls n ls n we can now perform some algebraic of e first we employ ccs expansion law to out the prefix at c then a structural law to the scope of the restriction at a in which we exploit the property that r c n z may not use a all these laws are valid for strong bisimilarity hence also for expansion we thus obtain e e cz a a n e r c n z cz es n r c n z def e we can act similarly on ls n and in addition also the law a ay p a v q a p q this gives us ls n cz a a n l r c n z cz ls n r c n z def l we have thus obtained two processes e and l in the context closure of r and we are done in the proof the upto techniques allow us to work with a relation that has exactly one pair for each integer specifically upto context avoids us considering processes in parallel with the lazy and eager systems whereas upto expansion allows us to reason only on the normal forms ls n and es n for these systems systems of equations uniqueness of solutions of equations intuitively says that if a context c certain conditions then all processes p that satisfy the equation p cp are bisimilar with each other we need variables to write equations we use letters x y z for these variables and call them equation variables the body of an equation is a ccs expression possibly containing equation variables thus such expressions ranged over by e live in a ccs grammar extended with equation variables definition assume that for each i of a countable indexing set i we have variables xi and expressions ei possibly containing such variables then xi is a system of equations there is one equation for each variable xi we write ep for the expression resulting from e by replacing each variable xi with the process pi assuming p and x have the same length this is syntactic replacement to the substitution of the holes of a context with processes the components of p need not be different from each other as it must be for the variables x if the system has infinitely many equations the tuples p and x are infinite too definition suppose xi is a system of equations · p is a solution of the system of equations for if for each i it holds that pi · the system has a unique solution for if whenever p and q are both solutions for then p q examples of systems with a unique solution for are x a x x a x x b x the unique solution of the system modulo is the constant k a k for any other solution p we have p k the unique solution of modulo are the constants k k with k a k and k b k again for any other pair of solutions p p we have k p and k p examples of systems that do not have unique solution are x x x x x a x all processes are solutions of and examples of solutions for are k and k b for k a k definition a system of equations xi is · guarded if in each ei each occurrence of an equation variable is a visible prefix · sequential if in each ei each occurrence of an equation variable only appears prefixes and sums in other words if the system is sequential then for every expression ei any subexpression of ei in which xj appears apart from xj itself is a sum of terms for instance · x x µ is sequential but not guarded because the prefix for the variable is not visible · x x p is guarded but not sequential · x x a a b a as well as x a x b x are both guarded and sequential theorem unique solution of equations a system of guarded and sequential equations has a unique solution for the proof exploits an invariance property on immediate transitions for guarded and sequential expressions and then extracts a bisimulation upto bisimilarity out of the solutions of the system to see the need of the condition consider the equation from x a a x a where x is guarded but not sequential any processes that does not use a is a solution contractions in theorem the constraints on and especially on limit its applicability further the same definitions and examples discussed for bisimilarity and hence also the same limitations apply to other behavioural equivalences eg contextual equivalence and equivalences one may if the conditions of theorem can be relaxed by simply requiring that each equation be sequentially guarded that is of the form x j j ej where j is a visible action unfortunately uniqueness still fails a counterexample is x a a a x any process p with p a p and p unable to use a is a solution examples are a and a b an equation x a e need not have a unique solution even if we ourselves to processes that may only perform a transitions an example is the equation x a b a a a b x b a here the body of the equation produces an a the first a from x and then all other as any process p with p a p for some p is a solution for instance a or a a or even a contraction the constraints on the theorem can be weak if we move from equations to certain that we call contractions intuitively for a behavioural equivalence its contraction is a preorder in which p q holds if p q and in addition q has the possibility of being at least as efficient as p that is if p can do some work ie some interactions with its environment then q should be able to do the same work at least as quickly as p ie performing no more steps then those performed by p process q however may be nondeterministic and may have other ways of doing the same work and these could be slow ie involving more steps than those performed by p we first explain the idea on the concrete case of bisimilarity definition bisimulation contraction a process relation r is a bisimulation contraction if whenever p r q p µ p implies there is q such that q µ q and p r q q µ q implies there is p such that p µ p and p q bisimilarity contraction written is the union of all bisimulation contractions in the first clause q is required to match p s challenge transition with at most one transition this makes sure that q is capable of p s work at least as efficiently as p in contrast the second clause of definition on the challenges from q entirely ignores efficiency it is the same clause of weak bisimulation the final derivatives are even required to be related by rather than by r bisimilarity contraction is than the expansion relation e of definition clause is the same in the two definitions but in clause expansion uses p µ p rather than p µ p moreover with contraction the final derivatives are simply required to be bisimilar an expansion p e q tells us that q is always more efficient than p whereas the contraction p q just says that q has the possibility of being more efficient than p example we have a a however a a a as well as its converse a a a indeed if p q then p p q the last two relations do not hold with e which explains the strictness of the inclusion e as bisimilarity contraction follows expansion in one direction and bisimilarity in the other clearly separating the two the and congruence for such relations can be combined into a proof for the contraction theorem is a in ccs systems of contractions a system of contractions is defined as a system of equations except that the contraction symbol is used in the place of the equality symbol thus a system of contractions is a set xi where i is an indexing set and expressions ei may contain the contraction variables definition given a behavioural equivalence and its contraction and a system of contractions xi we say that · p is a solution for of the system of contractions if p ep · the system has a unique solution for if whenever p and q are both solutions for then p q when we reason about bisimilarity the contraction symbol is interpreted as the bisimilarity contraction and the equivalence as the bisimilarity thus p solution for of the system of contractions xi means that p ep and the system having a unique solution for means that whenever p and q are both solutions for then p q lemma if a system of equations xi has a unique solution for then also the corresponding system of contractions xi has a unique solution for the lemma holds because any system of equations has at least one solution for strong bisimilarity obtained by interpreting the equations as recursive process definitions a solution for strong bisimilarity is also a solution in the system of contractions moreover any solution of the system of contractions is a solution of the system of equations the converse in contrast is false as we shall see systems of contractions more easily have a unique solution conditions for unique solution of contractions definition a system of contractions xi is weakly guarded if in each ei each occurrence of a contraction variable is a prefix in proofs about contractions we will often unfold the contractions exploiting the of the contraction preorder with the objective of placing processes that are solutions of the contractions a certain number of prefixes suppose p are solutions of a system of contractions xi and consider a context cp then the process obtained from cp by unfolding the contractions once is c ep the process ob by unfolding the contractions twice is c and similarly for the lemma suppose p and q are solutions for of a system of contractions for any context c if cp µ r then there is a context c such that r c p and cq µ c q proof sketch let n be the length of the transition cp µ r the number of strong steps of which it is composed and let c p and c q be the processes obtained from cp and cq by unfolding the definitions of the contractions n times thus in c each hole is at least n prefixes and cannot contribute to an action in the first n transitions we have cp c p and cq c q by the properties of moreover since each hole of the context c is at least n prefixes applying the definition of on the transition cp µ r we infer the existence of c such that c p µ c p r and c q µ c q finally again applying the definition of on cq c q we derive cq µ c q theorem unique solution of contractions for a system of contractions has a unique solution for proof sketch one shows that if p and q are solutions for of a system of contractions then the relation r def r s r cp s cq for some context c is a bisimulation exploiting lemma in comparison to theorem for equations in theorem for contractions the condition is allowing variables that are prefixes most important the condition is removed allowing variables any process constructs example the following contractions have a unique solution for x x x x a a a x a b a a a b x b a we have seen in section and at the beginning of section that the corresponding equations do not have a unique solution the solutions of the contraction are all processes where a process is if it cannot perform visible actions ie if p is the process then there is no p and visible action such that p p the contraction has a unique solution because all processes are bisimilar it is easy to see that an process is solution conversely suppose p is not and let n be the least n such that p n for some then p is not a solution of p p because p needs at least n steps before any visible action and therefore can never be more efficient than p example of solutions for and are a p and a p where p is any solution of and is bisimilar with a remark results such as lemma and theorem also hold if the game in clause of definition of bisimulation contraction is that of strong simulation ie p µ p implies there is q such that q µ q and p r q however the re relation would not be enough to capture expansion ­ a major goal for this paper is understanding existing bisimilarity upto techniques where expansion is important completeness an interesting class of contractions are those in which the body e of each contraction x e does not contain constants in these systems all forms of in the behaviour of processes are captured by recursive calls through the contraction variables we call such systems pure similarly we call pure a system of equations without constants in this section we discuss the expressiveness of pure systems of contractions and equations with constants the question is as the behaviour of any process p is captured by the guarded and sequential equation x p we show that the technique of contractions given by theorem is complete whereas that of guarded and sequential equations given by theorem is not if r is a relation then we can also view r as an ordered sequence of pairs eg assuming some ordering then ri indicates the tuple obtained by the pairs in r on the ith component i theorem completeness suppose r is a bisimulation then there is a system of pure contractions of which r and r are solutions for proof sketch suppose r is a bisimulation we define a system of contractions of which r and r are solutions the variables of the contractions are of the form for p r q and there is one contraction for each pair in r we show how the contraction for a pair p r q is built consider an enumeration of all the transitions from p p pr where r ranges over some countable set ip following the bisimulation game for each r there is qr st q qr and pr r qr similarly on the challenge transitions from q ie q qs for s iq we find processes ps with p ps and ps r qs then the contraction for the pair p q is the contractions in the proof of the theorem are sequential and weakly guarded but not necessarily guarded the assertion of theorem can actually be refined the technique based on contractions is also computationally complete with respect to the bisimulation proof method in the sense that the size of the structures needed and the subsequent amount of checks are comparable the size of a relation is the number of its pairs the size of a system of contractions is the number of contractions the proof of theorem shows that the system of contractions derived from a bisimulation r has the same size as r moreover the work needed to prove that r and r are solutions of the system of contractions is precisely the work needed to check the diagrams of the bisimulation game for r in contrast the method for equations resulting from theorem is not complete for instance there is no system of guarded and sequential pure equations in which one of the solutions is the process k so defined k a k to see this it is useful to express the behaviour of k via the following constants h h hi hi a hi ai i we have ai k hi for each i as by the relation r def k hi which is a bisimulation upto strong bisimilarity now for each n m we have hn hm because assuming n m hm cannot match the transition hn an moreover for each n there is a transition hn hn as a consequence the infinite sequence of transitions h h · · · hn hn · · · go through states that are pairwise an equation of which k is solution should be able to express the same behaviour this is impossible however if the equation is sequential and guarded because the equation variables must be a visible prefix and can only be reached by performing a visible action hence an infinite nesting of internal transitions as in cannot be derived relationship with upto context the completeness of the contraction technique given by theorem including the computational completeness discussed after the theorem remains also with respect to powerful of the bisimulation proof method such as upto context techniques we show that the contraction technique is in fact computationally equivalent to the upto and context technique a refinement of the upto expansion and context of definition the former captures a larger set of relations because bisimilarity contraction is than expansion definition bisimulation upto and context a process relation r is a bisimulation upto and context if whenever p r q we have p µ p implies there is q such that q µ q and p rc q the converse of on the actions from q theorem suppose r is a bisimulation upto and context then there is a system of contractions of the same size as r of which r and r are solutions for conversely suppose p and q are solutions for to the same system of contractions then the relation pi is a bisimulation upto and context the theorem is proved along the lines of theorem remark the definition of contraction was derived by at at obtaining theorems such as and the tions in the theorems do not work with expansion in place of contraction from theorems and we derive corollary soundness of bisimulation upto and context if r is a bisimulation upto and context then r having shown that the techniques of contractions and bisimulation upto and context are equivalent we can derive the soundness of one from the soundness of the other in corollary we took the contraction technique as primitive the complexity of the soundness proofs of the two techniques is similar the main difference is that the expressions in the body of the contractions are weakly guarded whereas the contexts of the upto context bisimulation techniques are not as a consequence in the proofs for the upto context techniques one has to reason about all possible interactions between a context and the processes into it by transition induction and a case analysis on the last rule used to derive a transition with contractions this is avoided exploiting the condition and the unfolding of the contractions example the lazy and eager servers we show a proof of the bisimilarity between the lazy and the eager systems of section using the technique of unique solution of contractions this serves both as an an illustration of the application of the technique and as a comparison with the technique based on the bisimulation proof method employed in the proof of section the proof consists in showing that ls n n and es n n are solutions of the following system of contractions xn cz xn r c n z n we establish that es n n is a solution using the algebraic laws in the proof in section that in can be replaced by es n a a n cz e r c n z cz a a n e r c n z cz es n r c n z we proceed similarly for ls n the contraction is not sequential hence contractions and theorem cannot be replaced by equations and theorem language we have shown the property of unique solution of contractions in ccs we here the theorem to an arbitrary process language using a more abstract condition the serves both to better understand the validity of the theorem and for applicability to languages that unlike ccs do not have an explicit construct for this we consider the case standard in process algebra in which the syntax of the processes is the term algebra generated by some signature and the semantics is given as an lts we call process language any such language we use l to denote a generic process language and lx for its extension with the contraction variables in x we say that l is safe if in l is a congruence relation and its corresponding contraction is a in theorem the weakly guarded hypothesis makes sure that the body of a contraction alone determines the first interaction the body is thus the interaction occurs without contributions from the terms that replace the contraction variables whenever the bodies of the contractions are in this sense the property holds definition contractions an expression e of lx is if for all processes p of l we have · if ep µ r then there is a context c such that r cp and for all q also eq µ cq a system of contractions xi expression ei is is if each theorem in any safe process language l a system of contractions has a unique solution for the proof of the theorem is similar to that of theorem checking the property is often straightforward for instance in the case of the format holds if in the body e of a contraction all variables are an axiom operator that is an operator that as ccs prefix is defined by means of rules in which the set of hypothesis is empty in some cases may be better than the hypothesis even if the calculus has a prefix operator we shall see an example in section with the higherorder calculus where allows us to capture occurrences of the contraction variables within output prefixes barbed congruence we briefly consider the application of the idea of contraction to barbed congruence for various reasons first barbed congruence is a form of behavioural equivalence and it the way to the treatment of other forms of contextual equivalence second we want to show that ­ sometimes ­ the contraction techniques make it possible to work directly with barbed congruence even though it is contextually defined eg the example with higherorder processes in section third the definition of barbed congruence applies to any language with a reduction semantics ie a reduction relation and a or observation predicate as opposed to the lts semantics of the languages in earlier sections thus the definitions and results in this section hold for any algebraic calculus the term algebra over a signature equipped with a reduction semantics that is a reduction relation and a predicate we use rl for referring to a generic such language and for its extension with the contraction variables in x for ccs is and p holds if p for some visible action as usual is the reflexive and transitive closure of and p holds if there is p with p p and p definition barbed bisimulation and congruence a relation r on the processes of rl is a barbed bisimulation if whenever p r q p p implies there is q such that q q and p rq p implies q the converse of and on challenges from q barbed bisimilarity written bar is the union of all barbed bisimulations two processes p and q are barbed congruent written p q if for each context c it holds that cp bar cq remark the definitions of barbed congruence in the ture often make use of a set of predicates we use only one here for simplicity of presentation a variant of barbed congruence is barbed congruence in which the closure under contexts is placed within the definition of the difference between the two variants has no consequences on the results in the paper in the contraction version of barbed bisimilarity we write q q if q q or q q definition barbed contraction barbed congruence contraction a relation r on the processes of rl is a barbed contraction if whenever p r q p p implies there is q such that q q and p rq q q implies there is p such that p p and p bar q p implies q q implies p barbed contraction written bar is the union of all barbed con barbed congruence contraction written c bar relates two processes p and q if for each context c it holds that cp bar c q we the concept of to semantics definition contractions an expression e of is if for all processes p and context c of rl · if r then there is a context c such that r c p and for all q also c q · if then for all q also a system of contractions xi is is each expression ei is barbed congruence and its contraction are by definition fully hence the safety requirement of theorem is not needed in the property of unique solution for barbed congruence the symbols and of definition become and c bar respectively theorem in rl any system of contractions has a unique solution for uniqueness of solution of contractions for equivalences we consider now equivalences we focus on contextual equivalence ie may testing because it is widely studied as the barbed congruence of section so contextual equivalence is contextually defined thus the setting considered is the same an algebraic process language equipped with a reduction semantics we reuse notations and from section intuitively two terms are contextually equivalent when they are equally observable in any context definition contextual equivalence p ctx q holds when cp iff cq for all c the definition of the contextual equivalence contraction uses the predicate p n indicating that a is reached in at most n steps ie p mp for some p with m n definition contextual equivalence contraction p if for all c cp n implies cq n for any n cq implies cp ctx q thus referring to contextual equivalence the symbols and of definition become ctx and ctx theorem a system of contractions has a unique solution for ctx proof sketch suppose p and q are solutions for ctx and consider a context c one shows that cp implies cq suppose cp n one proceeds by induction on n exploiting the properties of the unfolding of contractions corollary in ccs a system of contractions has a unique solution for ctx example the lazy and eager servers contextual equivalence does not have the congruence problems of bisimilarity for that motivated in the presentation of ccs in section the use of guarded sums we can therefore admit the full construct in the grammar for the ccs processes such a flexibility will be useful in this example we the lazy and eager servers in the example of section we modify the auxiliary server a which was by the main server before starting an interaction protocol with a client in section the server was deterministic now it is nondeterministic thus all definitions remain the same except that a always returns an arbitrary integer a nn a n a the system with the lazy main server is now ls def a a l and the system with the eager main server is es def a a e where l and e are as in section the timing difference between ls and es in a is observable under bisimilarity the reason is that an interaction es a a cz e r c n z in which n is received from a is a to using n in the interaction with the next client in contrast ls is unable to make such a its only initial transition is a visible one the difference is however not observable under contextual equivalence we prove ls ctx es using the technique of unique solution of contractions the proof is similar to that with the deterministic auxiliary server and the bisimilarity contraction in section with a further simplification a single contraction is sufficient namely x cz nx r c n z to show that both ls and es are solutions for ctx of this contraction we employ the same laws and algebraic reasoning of section which are sound because bisimilarity implies contextual equivalence an additional laws is required in the proof of es i ri ctx is any prefix the law is actually valid for strong contextual equivalence where two equal processes are required to reach an observable in the same number of steps this is one of the most distinguishing laws of contextual equivalence using the laws we have es a a e ctx a a e r c n z ctx cz na a e r c n z cz r c n z which shows that es is a solution of the contraction the proof that also ls is a solution is simpler the above proof is similar to the proofs with the servers in sections and all these proofs explicitly or implicitly employ upto context reasoning above the common context is cz r c n z a proof that follows the definition of contextual equivalence would be hard due to the quantification on all contexts in ccs contextual equivalence coincides with trace equivalence the equality in the example cannot be proved purely using standard axiom systems for trace equivalence because the systems compared are not finite or finite state are complete only on these systems one could show that es and ls have the same traces by induction on the length of the traces the proof is tedious for instance because r could be any process remark the proof of the equality between es and ls re the essence of the technique based on unique solution of con one some simple algebraic laws to prove that two tuples of terms are solutions of a certain system of contractions from which the equality between the two tuples is derived from the theorem the algebraic laws may have been ob in various ways eg an of the equality for the finite terms in our example we have used laws for bisimilar ity because it implies contextual equivalence plus law law is a wellknown law in of trace equivalence the law can also be easily proved directly in terms of contextual equivalence reasoning by induction on the length on the number of steps needed to reach an observable trace equivalence in this section we briefly consider trace equivalence in ccs and most process algebras trace equivalence is a direct of contextual equivalence in the same way as bisimilarity is for barbed congruence aside from this we look at trace equivalence because it is a behavioural equivalence and inductive we use s to range over traces ie nonempty sequences of visible actions we assume to be in a generic process language l with an lts semantics as in section we write p µ n p if p µ p is derived using n strong transitions ie we have p m µ m p and n m m if s n then we write p s if p p p pn n pn for some processes p pn similarly we write p s m if there are p pn with p m p m p pn n mn pn and m definition two processes p q of l are trace equivalent written p tr q if for each trace s we have p s iff q s two processes p q are in the trace equivalence contraction written p tr q if for each trace s if p s n then q s m for some m n if q s then p s a process language is if tr is a congruence and tr a theorem in any process language l a system of contractions has a unique solution for tr refined forms of trace equivalence exist for instance ready trace equivalence combines traces with the idea of contraction and theorem can be adapted to ready traces by combining the treatment of traces in definition with the treatment of in definitions and of the technique the contraction technique may be applied to any equivalence whose are finitary in the sense that if an observable holds then it can be reached in a finite number of transitions bisimilarity is in this class the are the weak transitions µ each use of µ is finitary because obtained by composing a finite number of strong transitions and µ different uses of µ may have different lengths but each length is finite the same argument holds for the observable of contextual equivalence in all these cases the contraction preorder precisely arises by with such finite measures there are behavioural equivalences however in which the are not finitary for instance an observable may be inherently coinductive as for such as infinite traces and nontermination we illustrate the possible failure of the contraction techniques in these cases using trace equivalence two processes are if they have the same traces including the infinite ones it is how the contraction of trace equivalence should be defined in any case however unique solution would fail even for guarded and sequential contractions as an example consider the processes p def and q def p a a these processes are not trace equivalent however in an trace semantics they both are solutions to the guarded and sequential contraction x a a x the definition of the the contraction for trace equivalence is irrelevant here because the processes have no transitions similar problems arise for must equivalence where nontermination is observable the same counterexample of trace equivalence applies contractions into the bisimulation game an advantage of bisimilarity with respect to other behavioural equivalences is the locality of the required checks related states only have to match each others immediate transitions we can some locality also in other equivalences by introducing the corresponding contraction into a bisimulation upto game we illustrate this possibility with contextual equivalence which is inductive and contextual and therefore from bisimilarity and its local checks since we play the bisimulation game we assume a process language l with an lts semantics on top of which contextual equivalence and reduction semantics is defined as in ccs definition bisimulation upto ctx a relation r on the process language l is a bisimulation upto ctx if whenever p r q we have p µ p implies q µ q and p ctx r ctx q the converse of on the actions from q as in the case of ordinary bisimulation so bisimulation upto ctx may be by combination with further upto techniques for instance in the bisimulation upto ctx and context the requirement p ctx r ctx q on the derivatives of definition becomes p ctx rc ctx q it is sufficient to the most powerful technique upto ctx and context and the results will also hold for the weaker upto ctx we derive soundness from that of the corresponding contraction technique lemma in l suppose r is a bisimulation upto ctx and context then there is a system of contractions of the same size as r of which r and r are solutions for ctx corollary soundness of bisimulation upto ctx and context suppose a relation r on the process language l is a bisimulation upto ctx and context then r ctx we have seen that in the case of bisimilarity the techniques of unique solution of contractions for and of bisimulation upto contraction and context are equivalent for contextual equivalence however the former technique is more powerful the reason is that in the bisimulations upto ctx and context game laws and equalities for ctx are applied only after the derivatives of the processes in the pairs have been chosen for instance the lazy and eager servers of section ls and es cannot be a pair of a bisimulation upto ctx and context for the same reason why they are not bisimilar the challenge transition es a a cz e r c n z cannot be matched by ls in some cases however the can be we show this for the processes ls and es of the server example we relate ls to a contraction es of es obtained by abstracting the initial private communication with the auxiliary server a es ctx na a cz e r c n z def es now the singleton relation ls es is a bisimulation upto ctx and context the processes in the pair initially may only perform an input at c if v is the value received in the input then the transitions are es c v na a e r c n v def es and ls a a cz ax l r c x z c v a a ax l r c x v def ls now we have using algebraic reasoning similar to that in previous examples with the servers and es na a e r c n v ctx r c n v and ls ctx na a l r c x v r c x v this is sufficient upto ctx and context finally having proved es ctx es and es ctx ls we derive es ctx ls by transitivity other behavioural equivalences and their contractions can be injected into the bisimulation up to game along the lines of what done here for contextual equivalence higherorder languages the contraction technique may also be used in higherorder languages such as the calculus and the higherorder calculus we from to produce a general theory of contractions for higherorder languages comparable in power to the bisimulation proof method for these languages we leave this for future work here we simply show that the to a higherorder setting of the most basic contraction techniques those involving a reduction semantics and equivalences can still be useful we illustrate this on the higherorder calculus we consider the higherorder calculus in its simplest form where only processes can be below is the syntax see figure for the reduction semantics p a p q ax p x a p p q we use a b c to range over names and x y z to range over variables we call them language variables to distinguish them from the contraction or equation variables such as x y an input ax p binds the free occurrences of variable x in p similarly a restriction a p binds the free occurrences of name a in p a term is open or closed depending on whether it may or may not have free language variables in any case it may have free names systems of contractions in the higherorder calculus in the definition of barbed congruence and its contraction the only of higherorder languages that has to be taken into account is the distinction between open and closed terms this is dealt with in the expected manner all running terms are to be closed thus the definitions of equivalences and in earlier sections eg barbed congruence and its contraction are meant to be on closed terms the definitions are generalised to open expressions by requiring instantiation of the language variables with all closing substitutions ie substitutions that make the terms closed using in contextual definitions closing contexts rather than closing substitutions would yield the same relations an example the example is about two ways of modeling the replication operator we consider the equality barbed congruence between the terms c a and c b where a def by a m a m for m def ax y x a x and b def by a n a y n for n def ax x a x terms c a and c b send on c processes a and b that can receive a process at b and then this process indeed if p is the process so received assuming a does not occur free in p in one case we obtain the term ap def a m py a m py and in the other case bp def a n a p n and then we have ap p ap p p ap · · · bp p bp p p bp · · · the internal structure of ap and bp is however different a system of contractions that proves c a c b is the following x c y y by z z y z these contractions are and therefore have a unique solution for barbed congruence note that in the first contraction a contraction variable occurs within the initial output prefix thus the contraction is not weakly guarded still the contraction is because a process that replaces the structural congruence the least congruence such that · p q q p p q r p q r p p a a b p b a p a p q a p q if a not free in q the reduction relation p q is the least relation such that ax r a p q q p p p q p q p p a p a p p p p p p p figure the reduction semantics for ho variable and that therefore represents the value in the out put does not contribute to the first action note also that the third contraction is open it has y as a free variable two solutions for c bar the barbed congruence contraction to the above system of three contractions are respectively c a a and a m a m c b b and a n a y n the third process of each solution has y free as its corresponding contraction to prove that these are solutions we need a few simple algebraic laws using the bisimulation proof method the proof of the equality between c a and c b is more with the bisimulation techniques currently available a proof requires an infinite relation even in the case of bisimulation where a form of upto context is available the relation used in for the same example is infinite because intuitively the values a and b have to be stored in an environment and can then be back at any time possibly several times what makes the difference is that contractions here allow us to extract a common context that the prefix for the initial action in contrast in upto context techniques for bisimulation contexts are only removed from the derivatives after an initial prefix further related work milners theorem about unique solution of equations from an of bisimulation on finitestate processes indeed in of behavioural equivalences the corresponding rule plays a key role and is called fixedpoint rule or recursive specification principle see also for trace equivalence the possible shapes of the solutions of systems of equations in connection with conditions on the of the equations is studied by and unique solution of equations has been considered in various settings including languages algebraic power series and pushdown automata see the as well as in coalgebras eg these models however do not have the analogous of internal step around which all the theory of contractions is built in functional languages unique solution of equations is sometimes called unique fixedpoint induction principle see for instance in which the conditions milners conditions of theorem and which studies equations on streams a condition based on the notion of contractive function the word contraction here is to its use in our paper a on bisimulation is upto context techniques have been in a setting and adapted to languages whose lts semantics to the format see for instance which uses a of to the categorical framework the techniques in section the bisimulation proof method and some of its onto equivalences us of techniques for reducing equivalences to bisimilarity for instance trace equivalence on nondeterministic processes can be reduced to bisimilarity on de processes following the powerset construction for automata a similar reduction can be made for testing equivalence these results rely on transformations of transitions systems which modify the nondeterminism and the set of states in such a way that a given equivalence on the original systems corresponds to bisimilarity on the systems in contrast in the techniques of section the transformation of processes is performed dynamically the bisimulation game two processes are manipulated only when necessary ie when their immediate transitions would break the bisimulation game some results have been obtained in csp in which systems of equations have unique solutions provided their least fixed point intuitively obtained by infinite unfolding of the equations does not contain divergent states in csp the semantics has usually a denotational and most important the reference behavioural equivalence failure equivalence is divergent sensitive as mentioned in section currently we do not know how to handle divergence in the theory of contractions as divergence is not a finitary observable we note however that at least in the equivalences considered in the paper unique solution of contractions holds in cases where the infinite unfolding of the contractions would introduce divergence eg the contractions of example as well as the contractions employed in the examples about the lazy and eager servers where divergence may appear if in the interaction protocol with a client the main server is called back conclusions and future work in this paper we have presented operational techniques based on the idea of contraction for proving weak behavioural equivalences that is equivalences that abstract from internal moves we have focused on concurrent languages but the techniques are not meant to be specific to concurrency we have illustrated the techniques with bisimulation the most natural ground of application discussing also completeness we have then shown that the technique of unique solution of contractions can be onto other equivalences with finitary eg contextual equivalence barbed congruence trace equivalence we have also seen that the contraction can be injected into the bisimulation game in the case of bisimulation this leads to a minor improvement of an existing technique namely bisimulation upto expansion and context the case of or contextual equivalences such as contextual equivalence is more interesting we can use the bisimulation proof method with upto context for reasoning on these equivalences combined with algebraic laws for manipulating states whose immediate transitions would break the bisimulation game such techniques allow us implicitly to transfer upto context forms of reasoning originally proposed for labeled and their proof method onto equivalences that are contextual or as for the technique based on equations so the technique based on contractions is meant to be used in combination with algebraic reasoning on terms whose behaviour is not finite or finitestate the recursion on the contraction variables captures the infinite be of terms and the proof that certain processes are solutions is carried out with pure algebraic reasoning in comparison with equations a of unique solution of contractions for an equivalence is that the solutions are not it may be that p is solution and q is not even though p q the proof of completeness of the unique solution of contractions method with respect to the bisimulation proof method uses the sum operator to express the possible initial actions of a process we would like to see how completeness can be in languages in which the sum operator is missing one may consider the introduction of an operator to sum to be used only for writing contractions also we did not completeness in equivalences other than bisimilarity we have related the contraction technique to bisimulation such as upto expansion and context while powerful these are not the only possible it would be interesting to see whether other can be captured using contractions or similar notions we would like to understand on which behavioural equivalences the technique of unique solution of contractions works we mentioned in section that it seems to work if the of the equivalence are finitary more is needed to this point and appropriate conditions in the example with a higherorder language we have applied the most basic contraction techniques those for equivalences the use of other contraction techniques requires further investigation such study may light on the applicability of upto context techniques to higherorder languages our original motivation for studying contractions was to better understand upto context of the bisimulation proof method and their soundness more the goal of the line of work reported is to improve our understanding of bisimilarity and the proof techniques for it including the possibility of the techniques onto other equivalences acknowledgments i have from discussions with luca matthew hennessy david sands and from the comments of the anonymous this work has been partially supported by the project is and the project references s and m hennessy an efficiency preorder for processes informatica ­ t and ma process algebra equational theories of communicating processes cambridge university press c m jan a and jan semantics for concrete process algebra with the priority operator comput j ­ c m and mostly means many solutions theor comput sci ­ b s and ar meyer bisimulation cant be traced journal of the acm ­ f d d and j coinduction up to in a setting proc acm and checking nfa equivalence with bisimulations up to congruence in proc popl pages ­ acm and matthew hennessy testing equivalence as a bisimulation equivalence formal comput ­ r de and r hennessy testing equivalences for processes theoretical computer science ­ rj van the linear time ii in proc concur volume springer k honda and n yoshida on process semantics theoretical computer science ­ john e hopcroft and jeffrey d ullman introduction to automata theory languages and computation addisonwesley boston ma usa g and m representing contractive functions on streams submitted v and m wand small bisimulations for reasoning about higherorder imperative programs in proc popl pages ­ acm simple language equations of the ­ sb relational reasoning about contexts in higherorder operational techniques in semantics pages ­ cambridge university press sb bisimulation in untyped lambda calculus trees and bisimulation up to context notes theor comput sci ­ s l s and d abstract rules and a modular treatment of recursive definitions logical methods in computer science r milner communication and concurrency prentice hall r milner and d sangiorgi barbed bisimulation in proc th icalp volume of lncs springer verlag robin milner a complete for observational congruence of finitestate behaviors inf comput ­ james h morris lambdacalculus models of programming languages phd thesis mit project mac dec ion and algebraic systems and pushdown automata in of weighted automata series pages ­ springer and sound bisimulations for higherorder distributed process calculus in proc volume of lncs pages ­ springer andrew pitts method in advanced topics in bisimulation and coinduction cambridge university press and sangiorgi of the bisimulation proof method in advanced topics in bisimulation and coinduction cambridge university press a complete for trace congruence of finite state behaviors in proc th volume of lncs pages ­ springer a w the theory and practice of concurrency prentice hall a w understanding concurrent systems springer m and jan j m m coinductive proof techniques for language equivalence in proc volume of lncs pages ­ springer david sands computing with contexts a simple approach volume sangiorgi d and milner r the problem of weak bisimulation up to in proc concur volume of lncs springer d sangiorgi locality and in calculi for mobile processes in proc volume of lncs springer d sangiorgi and d walker the calculus a theory of mobile processes cambridge university press sangiorgi kobayashi and bisimulations for higherorder languages acm trans program lang syst 