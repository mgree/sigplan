c concurrency mark scott sarkar peter sewell university of cambridge abstract concurrency in c and c is in systems programming but has long been defined this motivated an shared effort by the standards to specify concurrent behaviour in the next versions of both languages they aim to provide strong guarantees for programs together with new but subtle atomic primitives for concurrent code however the current draft standards while the result of careful are not yet clear and rigorous definitions and substantial problems in their details in this paper we establish a mathematical yet readable semantics for c concurrency we aim to capture the of the current final draft as closely as possible but discuss changes that fix many of its problems we prove that a proposed x implementation of the concurrency primitives is correct with respect to the model and describe our tool for exploring the semantics of examples using code generated from our definitions having already motivated changes to the draft standard this work will aid discussion of any further changes provide a correctness condition for compilers and give a basis for analysis and verification of concurrent c and c programs categories and subject descriptors c multiple data stream architectures parallel processors d concurrent programming parallel programming f specifying and verifying and reasoning about programs general terms documentation languages reliability standardization theory verification keywords relaxed memory models semantics introduction context systems programming of os kernels language etc commonly on concurrency in c or c these languages are defined by standards but those standards have not covered the behaviour of concurrent programs motivating an effort to specify concurrent behaviour in a of c cx ab ba the next c standard cx is expected to follow cx the key issue here is the multiprocessor behaviour induced by hardware and compiler optimisations the design of such a language involves a between and performance choosing a very strong memory model such as se permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm consistency sc lam simplifies reasoning about programs but at the cost of many compiler optimisations and of requiring expensive hardware synchronisation instructions eg the cx design this by providing a relatively strong guarantee for typical application code together with various atomic primitives with weaker semantics for concurrent algorithms application code that does not use atomics and which is with shared state properly protected by locks can rely on sequentially consistent behaviour in an intermediate where one needs concurrent accesses but performance is not critical one can use sc atomics and where performance is critical there are lowlevel atomics it is expected that only a small fraction of code and of programmers will use the latter but that code concurrent data structures os kernel code language gc algorithms etc may have a large effect on system performance lowlevel atomics provide a common abstraction above widely varying underlying hardware x and provide relatively strong tso memory power and arm provide a weak model with barriers arm and provides a weak model with primitives int lowlevel atomics should be efficiently implementable above all of these and prototype implementations have been proposed eg ter the current draft standard covers all of c and is rather large pages but the concurrency specification is mostly contained within three as is usual for specifications it is a document mathematical specifications of relaxed memory models are usually either operational in terms of an abstract machine or operational semantics typically involving explicit buffers etc or axiomatic defining constraints on the relationships between the memory accesses in a complete candidate execution eg with a happensbefore relation over them the draft concurrency standard is in the style of a description of an axiomatic model it introduces various relationships identifying when one thread with another what a visible side effect is and so on we explain these in § and uses them to define a happensbefore relation it is obviously the result of extensive and careful however when one looks more closely it is still rather far from a clear and rigorous definition there are points where the text is places where it does not capture the of its authors points where a literal reading of the text gives a broken semantics several substantial and some open questions moreover the draft is very subtle for example driven by the of the intended hardware targets the happensbefore relation it defines is the bottom line is that given just the draft standard text the basic question for a language definition of what behaviour is allowed for a specific program can be a matter for given previous experience with language and hardware memory models eg for the java memory model sa and for x this should be no language definitions leave much to be desired even for sequential languages for concurrency they almost lead to ambiguity error and confusion instead we need rigorous but readable mathematical semantics with tool support to explore the consequences of the definitions on examples proofs of theoretical results and support for testing implementations interestingly the style of semantics needed is quite different from that for conventional sequential languages as are the tools and theorems contributions in this paper we establish a rigorous semantics for c concurrency described in section and with further examples in section it is precise in and is complete covering essentially all the semantics from the draft standard without significant or abstraction it includes the guarantee of sc behaviour for code locks sc atomics the various of lowlevel atomics and it covers but not allocation and does not address the aspects of c our model builds on the treatment of the guarantee by boehm and ba we have tried to make it as readable as possible using only minimal mathematical machinery mostly just sets relations and firstorder logic with transitive closure and introducing it with a series of examples finally possible it is a faithful representation of the draft standard and of the of its authors as far as we understand them in developing our semantics we identified a number of issues in several of the cx standard discussed these with members of the concurrency and made suggestions for changes these are of various kinds including changes and some open questions we discuss a selection of these in section the standards process for cx is the current version is at the time of writing the final draft leaving a small window for further improvements that for cx is at an earlier stage though the two should be compatible as a theoretical test of our semantics we prove a correctness result § for the proposed prototype x implementation of the c concurrency primitives ter with respect to our memory model we show that any execution of a translated c candidate execution gives behaviour that the c semantics would admit which involves issues about this result establishes some in the model and is a key step towards a verified compilation result about translation of programs experience shows that tool support is needed to work with an axiomatic relaxed memory model to develop an intuition for what behaviour it admits and and to explore the consequences of proposed changes to the definitions at the least such a tool should take an example program perhaps annotated with constraints on the final state or on the values read from memory and find and display all the executions allowed by the model this can be challenging but for c it turns out to be feasible for typical test examples to enumerate the possible witnesses we have therefore built a tool § that considers all the possible witnesses checking each one with code automatically generated from the axiomatic model § the frontend of the tool takes a program in a fragment of c and runs a symbolic operational semantics to calculate possible memory accesses and constraints we have also explored the use of a model generator the tj via the interface bn to find executions more efficiently with less all of the examples in this paper have been checked and their executions drawn using our work provides a basis for improving both standards both by the specific points we raise and by giving a precisely defined checkpoint together with our tool for exploring the behaviour of examples in our model and in variants the c and c language standards are a central interface in computational infrastructure between what a compiler and hardware should im on the one hand and what programmers can rely on on the other clarity is essential for both sides and a precise semantics is a necessary foundation for any reasoning about concurrent c and c programs whether it be by dynamic analysis modelchecking static analysis and abstract interpretation program logics or interactive proof it is also a necessary precondition for work on compositional semantics of such programs cx concurrency as here we describe c concurrency incrementally starting with singlethreaded programs and then adding threads and locks sc atomics and lowlevel atomics relaxed and our model also covers but we omit the details here in this section we do not distinguish between the c draft standard which is the work of the concurrency of and our formal model but in fact there are substantial differences between them we some of these and our for various choices in section our memory model is expressed as a file and the complete model is available online here we give the main definitions automatically and in a few cases from the source the semantics of a program p will be a set of allowed executions x some c programs are to have undefined behaviour meaning that an implementation is unconstrained eg if any execution contains a data race accordingly we define the semantics in two phases first we calculate a set of which are by the operational semantics and are consistent defined in the course of this section then if there is a in that set with a race of some kind the semantics indicates undefined behaviour by giving none otherwise it gives all the in more detail a candidate execution x is a pair where the first component is given by the operational semantics and the second is an existential witness of some further data we introduce the components of both as we go along the toplevel definition of the memory model then is memory model p program let pre executions p consistent execution in if x pre executions reads x races x data races x then none else some pre executions singlethreaded programs we begin with the fragment of the model that deals with singlethreaded programs which serves to introduce the basic concepts and notation we use later as usual for a relaxed memory model different threads can have quite different views of memory so the semantics cannot be expressed in terms of changes to a monolithic memory eg a function from locations to values instead an execution consists of a set of memory actions and various relations over them and the memory model constraints on those for example consider the program on the left below this has only one execution shown on the right there are five actions labelled all by the same thread their thread ids are these are all nonatomic memory reads or writes with their address x or y and value or actions a and b are the writes c and d are the reads of the operands of the operator and e is a write of the result of the evaluations of the arguments to are in c as are arguments to functions meaning that they could be in either order or even overlapping evaluation order is expressed by the sb relation a strict preorder over the actions that here does not order c and d the two reads both read from the same write a indicated by the rf relation x int main int x int y y xx return sb rf y rf sb sb x x sb sb y the set of actions and the relation are given by the operational semantics so are part of the the rf relation is existentially quantified part of the as in general there may be many writes that each read might read from in a semantics the constraint on reads cannot be simply that they read from the most recent write as there is no global linear time instead they are constrained here using a happensbefore relation which in the singlethreaded case coincides with nonatomic reads have to read from a visible side effect a write to the same location that happensbefore the read but is not ie one for which there is no write to the location in happensbefore we define the relation below writing it with an arrow the auxiliary functions is write and is read pick out all actions including atomic actions and but not lock or unlock actions that write or read memory a b a happensbefore b is write a is read b same location a b c a c b is write c same location c b a happensbefore c happensbefore b the constraint on the values read by nonatomic reads is in two parts the map must satisfy a wellformedness condition not shown here saying that reads cannot read from multiple writes that they must be at the same location and have the same value as the write they read from and so on more interestingly it must respect the visible side effects in the following sense consistent reads from mapping b is read b is at non atomic location b if b then b rf b else ¬a a rf b if a read has no visible side effects eg reading an variable there can be no rf edge this is an read and the program is to have undefined behaviour reads b is read b ¬a a rf b a has an if there is a write and another access to the same location on the same thread that are races a b a b same location a b is write a is write b same thread a b ¬a b b a programs with an execution that contains an race ur like the one below have undefined behaviour int main int x int y y x x return rf sb x x sb y ur dummy sb y dummy sb x sb threads data races and locks we now integrate cx threads into the model the following program a thread that writes to x and concurrently writes into y in the original thread x void p p sb int main int x int y px sb thread x y y sb rf px sb return x the thread creation gives rise to edges here a e from actions of the parent thread before the thread creation to edges of the child as we shall see these edges are also incorporated indirectly into happensbefore they are generated by the operational semantics so are another component of an thread creation gives rise to many memory actions for passing function arguments and writing and reading the thread id which examples so for this paper we usually use a more concise parallel composition written int main int x int y x y x return x x dr x sb y this example a data race dr two actions at the same location on different threads not related by happensbefore at least one of which is a write data races a b a b same location a b is write a is write b ¬ same thread a b atomic action a is atomic action b ¬a happensbefore b b happensbefore a if there is a of a program that has a then as with that program has undefined behaviour data races can be by using as usual these give rise to lock and unlock memory actions on the mutex location and a has a relation sc as part of that totally orders such actions a consistent locks predicate checks that lock and unlock actions are appropriately alternating moreover these actions on each mutex create edges from every unlock to every lock that is ordered after it in sc the relation is a derived relation calculated from a candidate execution which contains mutex edges the edges eg from thread creation and other edges that we will come to a b ­ additional synchronisation from thread create etc ­ a b same location a b a actions b actions ­ mutex synchronization ­ is unlock a is lock b a sc b for multithreaded programs with locks but without atomics happensbefore is the transitive closure of the union of the and relations the definition of a visible side effect and the conditions on the relation are unchanged from the singlethreaded case sc atomics for simple concurrent accesses to shared memory that are not protected by locks cx provides sequentially consistent atomics the example from above to use an atomic object x and sc atomic operations we have the following in which the concurrent access to x is not considered a data race and so the program does not have undefined behaviour x int main sb x y int y y x return sb y semantically this is because sc atomic operations are totally ordered by sc and so can be thought of as interleaving with each other in a global their semantics are covered in detail in ba and we will describe their precise integration into happensbefore in the following section of an atomic object is by nonatomic stores to avoid the need for a hardware for every such and those nonatomic stores can race with other actions at the location unless the program has some synchronisation accesses are made with atomic read write and actions that do not race with each other lowlevel atomics sc atomics are expensive to implement on most eg with the suggested implementations for an sc atomic load being lock on x ter and ld bc on power ms the instruction and the may take s of cycles they also provide more synchronisation than needed for many concurrent idioms accordingly cx includes several weaker variants atomic actions are by a memory order mo that specifies how much synchronisation and ordering is required the strongest ordering is required for mo seq actions which is the default as used above and the weakest for mo relaxed actions in between there are mo acquire and mo consume pairs and mo rel with both acquire and release semantics types and relations before giving the semantics of lowlevel atomics we the types and relations of the model there are base types of action ids aid thread ids tid locations l and values v as we have seen already actions can be nonatomic reads or writes or mutex locks or additionally there are atomic reads writes and with a memory order parameter mo and also with an mo parameter we often the thread ids action aid tid v aid tid v aid tid v aid tid v aid tid l vv aid tid l l aid tid u l aid tid nonatomic read nonatomic write atomic read atomic write atomic lock unlock the is read predicate out nonatomic and atomic reads and atomic the is write predicate out nonatomic and atomic writes and atomic locations are subject to a very weak type system each location stores a particular kind of object as determined by a map the atomic actions can only be performed on atomic locations the nonatomic reads and writes can be performed on either atomic or non atomic locations locks and are mutex actions and can only be performed on mutex locations these are enforced among other properties by a well formed threads predicate we the details here the part of a candidate execution x consists of a set of thread ids a set of actions a location typing and three binary relations over its actions sb and dd we have already seen the first two contains the edges imposed by the c evaluation order and contains additional edges from thread creation and thread join among others data dependence will be used for atomics in § these are all relations that are decided by the syntactic structure of the source code and the path of control flow and so the set of possible choices for an can be calculated by the operational semantics without reference to the memory model with reads taking unconstrained values the part of a candidate execution x consists of a further three binary relations over its actions rf sc and modification order mo the rf map is a relation containing edges to read actions from the write actions whose values they take and edges to each lock action from the last unlock of its mutex the sequentially consistent order sc is a total order over all actions that are mo seq and all mutex actions the modification order mo is a total order over all writes at each atomic location leaving writes at different locations and will be used to express coherence conditions these relations are existentially quantified in the definition of memory model and for each by the operational semantics there may be many choices of an that give a consistent execution each of which may or may not have a data race race or read the happensbefore relation along with several others are derived from those in and synchronization an atomic write or is a release if it has the memory order mo release mo rel or mo seq atomic reads or with order mo acquire mo rel or mo seq and with order mo consume are acquire actions pairs of a and a support the following programming idiom here one thread writes some data x perhaps spanning multiple words and then sets a flag y while the other until the flag is set and then reads the data sender x y receiver while y r x the desired guarantee here is that the receiver must see the data writes of the sender in more detail that the receiver cannot see any values of data that those writes in modification order this can be achieved with an atomic store of y annotated mo release and an atomic load of y annotated mo acquire the reads and writes of x can be nonatomic in the model any instance of a that reads from a gives rise to a edge eg as on the left below where the rf edges are x sb y sw y sb x x sb y sw y rf y sb x for such programs in fact for any program without atomics happensbefore is still the transitive closure of the union of the and relations so here a happensbefore d and d is to read from a in this case the with the that it reads from more generally the can with a to the same location that is before the write that it reads from to define this precisely we need to use the modification order of a candidate execution and to introduce the derived notion of a release sequence of writes that follow in some sense a for example in the fragment of an execution on the right above the d with the b by of the fact that d reads from another write to the same location c and b precedes c in the modification order mo for that location the modification order of a candidate execution here b c totally orders all of the write actions on each atomic location in this case y it must also be consistent with happensbefore in the sense below consistent modification order a b a b same location a b l locations of actions case l of atomic let actions at l a location a some l in let writes at l a actions at l is store a is atomic store a is atomic a in strict total order over writes at l actions at l happensbefore at the writes of l is a subset of mo for l happensbefore writes at l let actions at l a location a some l in actions at l in the example the release action b has a release sequence bc a subsequence of modification order on the location of the the release sequence is by the release and can be followed by writes from the same thread or from any thread other writes by other threads break the sequence we represent a release sequence not by the list of actions but by a relation from the head to all the elements as the order is given by modification order in figures we usually the reflexive edge from the head to itself rs element rs head a same thread a rs head is atomic a b is at atomic location b is release b rs element b b c c b rs element c a a if both act on the same location and the release sequence of the release contains the write that the acquire reads from in the example b c rf d so we have b d the definition below covers and thread creation in but the effects of a b ­ additional synchronization from thread create etc ­ a b same location a b a actions b actions ­ mutex synchronization ­ is unlock a is lock b a sc b ­ synchronization ­ is release a is acquire b ¬ same thread a b c a c rf b the modification order and the sc order we saw earlier must also be consistent in the following sense consistent sc order let sc happens before happensbefore all sc actions in let sc mod order all sc actions in strict total order over all sc actions sc sc sc atomic read values the values that can be read by an atomic action depend on happensbefore derived from and we return to the execution fragment shown on the right in the previous subsection showing a transitive reduction of happensbefore that coincides with its constituent orderings x hb y hb y y hb hb x an atomic action must read a write that is in one of its visible sequences of side effects in this case d either reads b or c a visible sequence of side effects of a read is a subsequence of modification order by a visible side effect of the read where the read does not happen before any member of the sequence we represent a visible sequence of side effects not as a list but as a set of actions in the tail of the sequence we are not concerned with their order visible sequence of side effects tail head b c head c ¬b happensbefore c a head a c ¬b happensbefore a we define to be the binary relation relating atomic reads to their sets now including the visible side effects themselves the atomic read must read from a write in one of these sets we can now extend the previous definition of the consistent predicate to be the conjunction of the on nonatomic and atomic actions and a constraint ensuring atomicity consistent reads from mapping b is read b is at non atomic location b if b then b rf b else ¬a a rf b b is read b is at atomic location b if b b b then b b b c c rf b else ¬a a rf b a b rf is atomic b a b a candidate execution is also required to be free of the following four execution fragments this property is called coherence aw x mo bw x rf rf cr x hb dr x aw x hb mo bw x bw x mo rf cw x hb dr x aw x rf mo cr x hb x two reads ordered by happensbefore may not read two writes that are modification ordered in the other direction it is forbidden to read from a write that is by a later write in modification order happensbefore and may not the union of the map happensbefore and must be acyclic finally we restrict sc reads if there is no preceding write in sc order then there is no extra restriction otherwise they must read from the last prior write in sc order from a nonatomic write that follows it in modification order or from any atomic write atomics on with weak memory orders notably power pairs are to implement than sequentially consistent atomics but still significantly more expensive than plain stores and loads for example the proposed power implementation of ld bc involves an ms however power and also arm does guarantee that certain dependencies in an assembly program are and in many cases those suffice making the sequence unnecessary as we understand it this is the motivation for introducing a variant of atomics on a stronger processor eg a tso x or or one where those dependencies are not would be implemented just as enables efficient implementations of algorithms that use pointer for commits of their data eg for example suppose one thread writes some data perhaps spanning multiple words then writes the address of that data to a shared atomic pointer while the other thread reads the shared pointer dereferences it and reads the data sender data p data receiver r p r r data here there is a dependency at the receiver from the read of p to the read of data this can be expressed using a and an atomic load of p annotated mo consume int main int data p data return as we saw in § the semantics of pairs introduced edges and happensbefore includes the transitive closure of and for a version of this example we would have the edges on the left below and hence a happensbefore d data sb sw data data sb data for the key fact is that there is a data dependency dd from c to d as shown on the right the dd edge is provided by the operational semantics and gives rise to a edge which extends data dependency with threadlocal relationships a b a rf b in turn this gives rise to a edge which is the analogue of the edge this involves release sequences as before in the example just the singleton b a d a actions d actions b is release a is consume b e a e rf b b d b d happensbefore finally we can define the complete happensbefore relation to accommodate mo consume and specifically the fact that pairs only introduce happensbefore relations to of the consume not to all actions that are it the definition is in two steps first we define which combines and allowing transitivity with on the left for both and on the right only for let r in r r in any execution this must be acyclic consistent inter thread happens before happensbefore which is thereby also acyclic is then just the union with happensbefore putting it together given a candidate execution x we can now calculate the derived relations § a variant of used in the semantics § § § § § happensbefore § § § § § and § the definition of consistent execution used at the start of section is then simply the conjunction of the predicates we have defined consistent execution well formed threads consistent locks consistent inter thread happens before consistent sc order consistent modification order well formed reads from mapping consistent reads from mapping § § § § § § § § the check on and the of the happensbefore relation are needed only for pairs theorem for an execution with no consume operations the consistent inter thread happens before condition of consistent execution is redundant theorem if a consistent execution has no consume operations happensbefore is transitive the proofs are by case analysis and induction on the size of possible cycles examples we now illustrate the varying strength of the different memory orders by showing the semantics of some classic examples in all cases variants of the examples with sc atomics do not have the behaviour as in our other diagrams to avoid we only show selected edges and we omit the c sources for these examples which are available online store sb here two threads write to separate locations and then each reads from the other location in total store order tso models both can read from before wrt coherence the other write in the same execution in cx this behaviour is allowed if those four actions are relaxed for pairs and for pairs this behaviour is not allowed for the same program using sequentially consistent consistent atomics with nonatomic message passing mp here one thread writes data and then an atomic flag while a second thread for the flag and then reads data the question is whether it is guaranteed to see the data written by the first as we saw in § with a pair it is a pair gives the same guarantee iff there is a dependency between the reads otherwise there is a consistent execution on the left in which there is a data race here the second thread the initial value of x the candidate execution in which the second thread the write x is out as that does not the read and so is not a visible side effect x y sb dr sb y x x rf x sb rf sb y y y sb x the same holds with relaxed flag operations in a variant in which all writes and reads are or relaxed atomics eliminating the race and there are two copies of the reading thread the two reading threads can see the two writes of the writing thread in opposite orders as on the right above consistent with what one might see on power for example load lb in this dual of the sb example the question is whether the two reads can both see the later write of the other thread in the same execution with relaxed atomics this is allowed as on the left x sb y rf sb rf hb x y y x y x but with with dependencies it is not as on the right above because would be cyclic it is not allowed for and sequentially consistent atomics which are stronger than with dependencies because of the cyclic and stronger ordering causality here the first thread writes to x the second reads from that and then wrt writes to y the third reads from that and then wrt reads x the question is whether it is guaranteed to see the first threads write x rf x sb y y sb rf x with relaxed atomics this is not guaranteed as shown above while with it is as the edges in the relation interfere with the required map independent reads of independent writes here the first two threads write to different locations the question is whether the second two threads can see those writes in different orders with relaxed or atomics they can x rf y rf x sb y sb y x from standard to and back we developed the model presented in section by a iterative process building of various of the standard and of boehm and model without lowlevel atomics ba considering the behaviour of examples both by hand and with our tool trying to prove properties of the and discussing issues with members of the concurrency of the c standards to give a of this process and to explain how our differs from the current draft the final draft n of the standard we describe a selection of issues this also serves to bring out the of the standard and the of specification even when carried out with great care we have made suggestions for technical or changes to the draft for many of these points and it seems likely that they will be incorporated we begin with two straightforward issues easily fixed then there are three substantial semantic problems in n where we have proposed solutions finally there is an question that further investigation subsequent in visible sequences of side effects n defines the visible sequence of side effects on an atomic object m with respect to a value computation b of m is a maximal subsequence of side effects in the modification order of m where the first side effect is visible with respect to b and for every subsequent side effect it is not the case that b happens before it however if every element in a happensbefore a read the read should not take the value of the visible side effect following discussion we this without the subsequent additional happensbefore edges there are places where n adds happensbefore relationships explicitly in addition to those from and eg between the invocation of a thread constructor and the function that the thread runs as happensbefore is carefully not closed such edges would not be transitive with eg accordingly we instead add them to the relation for those within our c fragment our operational semantics introduces them into of happensbefore n defines happensbefore making plain that it is not necessarily transitive but does not state whether it is required to be acyclic or whether perhaps a program with a cyclic execution is to have undefined behaviour the lb example of § has a cyclic as shown there but is otherwise a consistent execution after discussion it seems clear that executions with cyclic or equivalently cyclic happensbefore should not be considered so we impose that explicitly coherence requirements the draft standard enforced only two of the four coherence requirements presented in § and in the absence of and the following executions were allowed x sb mo x rf x x x the execution on the left violates by containing a cycle of happensbefore and modification order edges allowed only due to the lack of transitivity of happensbefore the execution on the right violates by having a read from a write the a that is by c actions b and c are shown as sc atomics for furthermore the draft standard refers to the visible sequence of sideeffects uniqueness nevertheless it allows valid executions that have more than one relying on the lack of transitivity of happensbefore as in the execution above these behaviours are surprising and were not intended by the designers sequential consistency for sc atomics the of sequential consistency to the programmer is a central design choice of cx and is stated directly by n memory order seq ensures sequential consistency for a program that is free of data races and uses exclusively memory order seq operations unfortunately n allows the following consistent execution of the sb example with sc atomics writes such as a and b are nonatomic so that they need not be compiled with memory x sb rf y rf y x sc x y we a stronger restriction on the values that may be read by sc atomics stated in § that does provide sequential consistency here overlapping executions and reads in a cx program that gives rise to the relaxed lb example in § the written value might have been concrete in the program source alternatively one might imagine a read the program below has the same execution and here there is no occurrence of in the program source int main int r r x y x r sb r y y rf sb rf x return this would be surprising and in fact would not happen with typical hardware and compilers in the java memory model much of the complexity of the model arises from the to reads which there is essential to prevent of pointers n also attempts to reads with an atomic store shall only store a value that has been computed from constants and program input values by a finite sequence of program evaluations such that each evaluation the values of variables as computed by the last prior assignment in the sequence this seems to be for example two subexpression evaluations in separate threads can overlap eg if they are the arguments of a function call and can contain multiple actions with relaxed atomics there can be consistent executions in which it is impossible to the two into any sequence for example as below where the of x must be between the two reads of x in our we currently do not impose any condition x rf x int main sc x x int y sb y x sb return y correctness of a proposed x implementation the cx memory model has been designed with compilation to the various target architectures in mind and prototype implementations of the atomic primitives have been proposed for example the following table presents an x prototype by ter operation load load seq store store seq seq x implementation mov lock mov lock or mov or mov this is a simple mapping from individual atomic operations to small fragments of assembly code abstracting from the and of compilation of a full c language argument evaluation order object layout control flow etc proposals for the power ms and other architectures follow the same structure although as they have more complex memory models than the x the assembly code for some of the operations is more verifying that these are indeed correct implementations of the model is a crucial part of the design furthermore as they represent the parts of efficient compilers without optimisations they can directly form an important part of a verified c compiler or the design and verification of a compiler with optimisations here we prove a version of the above prototype x implementation ter correct with respect to our semantics following the prototype we ignore lock and unlock operations as well as and joins all of which require significant runtime or operating system support in addition to the x hardware we also ignore sequentially consistent but cover all other we do consider actions implementing them with x and we include nonatomic loads and stores which can map to multiple x loads and stores respectively the prototype mapping is simple and is reasonably so this should be seen as a test of the c memory model in an operational semantics gives meaning to an assembly program by creating an x event structure ex to a set of events and an relation analogous to that orders events according to the program text events can be reads writes or and certain instructions eg create locked sets of events that execute atomically corresponding to there are x execution witnesses xx which a mapping and a memory order which is a partial order over reads and writes that is total on the writes the remainder of the are very different has no concept of release acquire visible side effect etc abstracting out the rest of the compiler to discuss the correctness of the proposed mapping in isolation without on a verification of some particular full compiler we work solely in terms of candidate executions and memory models first we lift the mapping between instructions to a nondeterministic translation action comp from c actions to small x event structures eg relating an atomic action to the events of the corresponding x instruction to define what it means for the mapping to be correct suppose we have a c program p with no undefined behaviour and an which is allowed by its operational semantics we regard an abstract compiler comp as taking such an and giving an x event structure ex the action comp mapping but with some freedom in the resulting x program order we say the mapping is correct if given such an abstract compiler the existence of a valid execution witness for ex implies the existence of a consistent c execution witness for the original actions we prove this by lifting such an x execution witness to a c consistent execution as illustrated below consistent comp comp ex valid execution xx below we show an and ex that could be related by comp the dotted lines indicate some of the x program ordering decisions that the compiler must make but which comp does not constrain cx actions x events x y aw x dr y sb w sb z y po po bw w ew z po po bw w po cr y cw y locked in more detail we use two existentially quantified functions comp and tid comp to the details of a c compilers data layout its mapping of c locations to x addresses and the mapping of c threads to x threads given a c location and value comp produces a finite mapping from x addresses to x values the domain of the finite map is the set of x addresses that corresponds to the c location and the mapping itself indicates how a c value is out across the x addresses a wellformed comp has the following properties it is injective the address calculation cannot depend on the value each c location has an x address different c locations have x address sets and an atomic c location has a single x address although a nonatomic location can have several addresses eg for a object finally the comp relation specifies valid translations applying action comp with a wellformed comp and also how events from different actions relate no single x instruction instance can be used by multiple c actions and the x relation must respect cs the detailed definitions and the proof of the following theorem are available online theorem let p be a c program that has no undefined behaviour suppose also that p contains no sc joins locks or then the x mapping is correct in the sense above that is if actions and are members of the part of a candidate execution resulting from the operational semantics of p then the following holds comp comp tid comp xx comp comp comp tid comp actions valid execution comp a xx consistent execution proof outline xx includes a map and a memory ordering relation that is total on all memory writes to build we lift a c map and modification order from these through comp eg a rf b iff e comp ae comp b e e we create an sc ordering by restricting the xx memory ordering to the events that in sequentially consistent atomics and it using the proof technique from our previous freedom work for we then lift that through comp the proof now proceeds in three steps we first show that if a happensbefore b and there are x events e and e such that e comp a and e comp b then e precedes e in either memory order or program order we have this step in hol hol this property establishes that in some sense has a stronger memory model than c and so any behaviour allowed by the former should be allowed by the latter however things are not quite so straightforward check that is a consistent execution most cases are machine checked in hol some are only many rely upon the property from for example in showing that at a nonatomic location if a rf b then a b we note that if there were a write c to the same location such that a happensbefore c happensbefore b then using the property from there is an x write event in comp c that would come between the events of comp a and comp b in xx thus meaning that they would not be in map the construction of reads from map in some cases some of the properties required for might be false for example in showing that a rf b implies a b we need to show that a happensbefore b even though there is such a relationship at the x level it does not necessarily exist in c in general x executions can establish relations the c model is in but is in hol we support the proof with a translation from to hol that are in c similarly for nonatomic accesses that span multiple x addresses the lifted reads might not be wellformed we show that if one of these violations of arises then the original c program has a data race we find a minimum violation in xx again using techniques from our previous work next we can remove the violation resulting in a consistent for a prefix of the execution then we add the bad action note that it creates a data race and allow the program to complete in any way the details of this part are by proof sequentially consistent atomics the proposal above includes two implementations of sequentially consistent atomic reads and writes one with the x locked instructions and the other with instructions on both the reads and writes however we can prove that it suffices either to place an before every sc read or after every sc write but that it is not necessary to do both in practice placing the after the sc writes is expected to yield higher performance this optimisation is a direct result of using freedom to construct the sc ordering in proving theorem roughly our theorem when executions are not sequentially consistent it uses a pattern called a race involving an data race combined with a write followed on the same thread by a read without a or locked instruction in between if no such pattern exists then an execution xx can be such that each read reads from the most recent preceding write although the of an execution witness xx might contain races and therefore not be by restricting attention to only sc reads and writes we get a subset of the execution that is as long as there is a between each sc read and write on the same thread this subset guarantees the relevant property of sc ordering that if a and b are sequentially consistent atomics and a rf b then a immediately precedes b in sc restricted to that address compiler correctness although we translate executions instead of source code theorem could be applied to full compilers that follow the prototype implementation the following diagram presents the overall correctness property p wf threads consistent execution compiler f g p wf events ex valid execution xx if once we use f we can then apply comp to get the same event set back ie informally e e then theorem ensures that the compiler respects the memory model and so we only need to verify that it respects the operational semantics thus our result applies to compilers that do not away any instructions that comp will produce these restrictions apply to the code generation phase the compiler can perform any valid optimisations before generating x code tool support for exploring the model given a relatively complex axiomatic memory model as we presented in section it is often hard to immediately see the consequences of the axioms or what behaviour they allow for particular programs our tool takes a program in a fragment of cx and the set of its executions allowed by the memory model them the tool has three main components an executable symbolic operational semantics to build the parts of the candidate executions x of a program a search procedure to enumerate the possible for each of those and a checking procedure to calculate the derived relations and predicates of the model for each pair to check whether it is consistent and whether it has data races races or reads of these the checker is the most subtle since the only way to intuitively understand it is to understand the model itself which is what the tool is intended to aid with and thus bugs are hard to catch it also has to be adapted often as the model is developed we therefore use code generation to build the checker directly from our to keep the checker and our model in exact correspondence and reduce the possibility for error the operational semantics our overall semantics is stratified the memory model is expressed as a predicate on the actions and relations of a candidate execution this means we need an operational semantics of an form to generate all such candidates in a setting with a global sc memory the values read by loads can be determined immediately but here for example for a program with a single load in principle we have to generate a large set of executions each with a load event with one of the possible values we make this executable by building a symbolic semantics in which the values in actions can be either concrete values or unification variables shown as v control flow can depend on the values read so the semantics builds a set of these actions and the associated relations together with constraints on the values for each controlflow path of the program for each path the associated constraint is solved at the end those with unsatisfiable constraints indicating unreachable execution paths are discarded the tool is designed to support test examples of the kind we have seen not arbitrary c code these do not usually involve many c features and the constraints required are propositional formulae over equality and inequality constraints over symbolic and concrete values it is not usually important in tests to do more arithmetic reasoning one could imagine using an smt solver if that were needed but for the current constraint language a standard unifier suffices the input program is processed by the parser extended with support for atomics we use gn to generate output we also allow the user to add explicit constraints on the value read by a memory load in a c source program to pick out candidate executions of interest to some of the checks of the model and to the output by actions and edges as an example consider the first program we saw in § there are two possibilities the reads of x either read the same value or different values and hence the operational semantics gives the two candidate executions and constraints below x sb constraint v v x sb constraint true y sb sb y sb sb xv xv y xv xv y later the memory model will rule out the left execution since there is no way to read anything but at x the semantics maintains an environment mapping identifiers to locations for loads the relevant location is found in that and a fresh variable v is generated to represent the value read other constructs typically combine the actions of their subterms and also build the relations etc of as appropriate for example for the if statement the execution path splits and two execution candidates will be generated the one for the true branch has an additional constraint that the value returned by the condition expression is true in the cc sense ie different from and the candidate for the false branch the value to be false there are also additional and edges from the actions in the condition expression to actions in the branch choosing instantiations of existential quantifiers given the part of a finite candidate execution the part is existentially quantified over a finite but potentially large set in the worst case with m reads and n writes all sequentially consistent atomic to the same location and with the same value there might be · m · m n possible choices of an rf and sc relation in practice though tests are much simpler there are typically no more than or writes to any one location so we avoid coding up a sophisticated search procedure in of keeping this part of the code simple for the examples shown here the tool has to check at most a few alternatives and takes less than seconds the most complex example we tested with all sc had cases to try and the overall time taken was about checking code extracted from we use code generation to produce a checker as an ocaml module which can be linked in with the rest of the tool our model is stated in higherorder logic with sets and relations restricted to finite sets the predicates and definitions are almost all directly executable within the domain of the code generation tool which implements finite sets by ocaml lists for a few cases eg importantly transitive closure we had to write a more efficient function and an proof of equivalence the overall checking time per example is on the order of seconds for examples with around actions finite model generation with given the part of a candidate execution the space of possible parts which will lead to valid executions can be explored by tools for model generation we reused the operational semantics above to produce a from a program and then problems to a finite model generator built into bn is a frontend to a model generator for first order logic extended with relations and transitive closure based on a sat solver translates higherorder logic formulae to firstorder formulae within syntax for small programs can easily find some consistent execution or report that none such exists in a few seconds in particular for the example mentioned above takes seconds to report that no execution exists while other examples take around seconds of course can also validate an execution x with both parts and concretely specified but this is significantly slower than running the validator the here is the translation process which is quite involved related work the starting points for this paper were the draft standard itself and the work of boehm and ba who introduced the for the cx overall design and gave a model for nonatomic lock and sc atomic operations without going into lowlevel atomics or in any detail it was expressed in informal mathematics an intermediate point between the of the standard and the definitions of our model the most closely related other work is the extensive line of research on the java memory model jmm sa java imposes very different constraints to c as there it is essential to reads to prevent of pointers and hence security violations to the sequential semantics of c has recently produced an extensive hol model nor and the proposed extension of c concepts there is also a body of research on tool support for memory models notably including among others the of et al which uses for of the jmm and of yang et al which is based on prolog encodings of memory models and included an specification building on our previous experience with the tool for hardware x and power memory models we designed to eliminate the need for of the tool to reflect changes in the model by automatically generating the checker code from the definition we made it practically usable for exploring our and hence rather complex cx model by a variety of features letting us explore the executions of a program in various ways conclusion we have put the semantics of c and c concurrency on a sound following the current final draft standard as far as possible except as we describe in § this should support future improvements to the standard and the development of semantics analysis and reasoning tools for concurrent systems code having done so the obvious question is the extent to which the formal model could be incorporated as a part of a future standard the memory model is subtle but it uses only simple mathematical machinery of various binary relations over a fixed set of concrete actions that can be there is a notational problem one would probably have to translate automatically or by hand the syntax of firstorder logic into natural language to make it sufficiently widely accessible but given that we that the formal model would be than the current for all purposes not only for semantics and analysis acknowledgements this work would not have been possible without discussions with members of the c concurrency and the list including boehm peter paul nelson and us with the tool we from grants and references ab s v and boehm memory models a case for parallel languages and hardware c acm j l s sarkar and p sewell in weak memory models in proc cav arm arm arm architecture reference manual and edition april ba boehm and sv foundations of the c concurrency memory model in proc pldi p editor programming languages c final draft sc n bn and a counterexample generator for higherorder logic based on a relational model in proc cx c p a and e the java memory model operationally in proc esop gn e r and s c north an open graph system and its applications to software engineering ­ code generation from specifications in higherorder logic phd thesis tu hol the hol system int intel a formal specification of intel processor family memory ordering october lam l lamport how to make a multiprocessor computer that correctly executes programs ieee trans comput j w and sv the java memory model in proc popl ms p e and r example power implementation for cc memory model http p e and j what is linux c necula scott and intermediate language and tools for analysis and transformation of c programs in proc cc nor m a formal semantics for c technical report s s sarkar and p sewell a better x memory model in proc s reasoning about the implementation of concurrency abstractions on in proc ecoop power version ibm w the java memory model is concurrency practice and experience sa j s and d on validity of program transformations in the java memory model in ecoop the architecture manual v p sewell s sarkar s f and m o a rigorous and usable programmers model for x c acm ­ s sarkar p sewell f s t t m and j the semantics of multiprocessor machine code in proc popl ter a brief example x implementation for cc memory model list dec tj e and d a relational model in proc tacas e m and j checking axiomatic specifications of memory models in pldi y yang g g and k a framework for axiomatic and executable specifications of memory consistency models in m generic programming with concepts phd thesis university november 