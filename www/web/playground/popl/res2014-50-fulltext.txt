abstract effects and logical relations benton microsoft research cambridge uk martin hofmann germany abstract we give a denotational semantics for a effect system that supports type abstraction in the sense that only visible effects need to be tracked internal modifications such as the of a search tree or lazy can count as pure or read only this purity allows clients of a module to validate soundly more program equivalences than would be possible with previous semantics our semantics uses a novel variant of logical relations that maps types not merely to partial equivalence relations on values as is commonly done but rather to a namely the objects of a establish that values semantic types its morphisms are understood as proofs of semantic equivalence the transition to solves two problems caused by use of existential quantification in kripke logical relations namely failure of and spurious functional dependencies categories and subject descriptors d programming languages language constructs and features ­ dynamic storage management f logic and meanings of programs semantics of programming languages ­ denotational semantics program analysis f logic and meanings of programs studies of program constructs ­ type structure general terms languages theory keywords type and effect systems region analysis logical relations parametricity program transformation introduction the last has significant progress in modelling and reasoning about the combination of effects and higherorder language features firstclass functions modules classes the object of study may be mllike or but the common source of is the way effectful operations may be partially behind higherorder abstractions several problems have been addressed using common techniques that include separation kripke logical relations and one is to models and reasoning principles for establishing contextual a second is to establish equivalence between highlevel and lowlevel permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm code fragments eg for compiler correctness a third is to define logics for showing programs satisfy assertions a fourth which we address here is to study type systems and analyses that can characterize particular classes of behavior such as purity and be used to justify equivalences more effect systems refine conventional types by adding information capturing an upper bound on the effects expressions may have several recent papers have explored the semantics of effect systems with a focus not merely on showing correctness of analyses but on providing a rigorous account of the conditions under which optimizations and are sound an example is the of stateful computations m and n subject to the condition that the sets of storage locations potentially written by m and n are disjoint and that neither potentially reads a location that the other writes we interpretations of types over an model that can justify such equivalences indeed it is the interpretations rather than rules for assigning such types to terms that we regard as primary types provide a common interface language that can be used by clients in modular reasoning about rewrites types can be assigned to particular terms by a of more or less sophisticated inference systems or by deeper semantic reasoning about particular implementations a key notion in reasoning about state is that of separation invariants depending upon mutually disjoint parts of the store intuitively if each function with direct access to a part preserves the corresponding invariant then all the invariants will be preserved by any composition of functions disjointness is understood in terms of sets of heap locations a memory allocator for example guarantees that its own private data structures memory previously out to clients and any block mutually disjoint sets of locations since the introduction of fractional permissions work on separation logic often goes beyond this simple model introducing resources that are combined with a separating conjunction but which are not interpreted as predicates on disjoint locations research on domainspecific or separation logics and type theories aims to allow custom notions of resource to be introduced and combined this paper presents a semantics for effect systems supporting or abstract notions of both effects and separation we have previously interpreted types for stateful computations as binary relations defined via preservation of particular sets of store relations this already provides some abstraction the semantics is extensional so for example a function that reads a reference cell but doesnt produce different results depending on the value read can soundly be counted as pure with for example models of permissions that the concrete semantics such a semantics can also interpret the rule allowing certain effects not to appear in annotations but here we go further generalizing the interpretation of regions to intuitively partial relations this allows for example a lookup function for a set adt to be assigned a effect even though the concrete implementation may involve writes to an internal datastructure moving to pers in this way requires us to the notion of separation allowing types to involve distinct regions whose concrete implementations overlap in memory earlier models of dynamic allocation have used kripke logical relations in which worlds are finite partial between locations with links two computations c c h h × v where h v are sets of partial heaps and values respectively are in the computation relation t a w for world w effect and result type a when h h h h h h w w w h h w h h h h w w v v a w where c h h v and c h h v here a w is the logical relation at the result type and the interpretation of the effect which can be given in various ways eg in terms of binary relations on stores to be preserved the notation h h w means that for each link l l w l domh l domh however generalizing such a logical relation from to pers is surprisingly difficult the problematic part is the existential quantification over world extensions w w this says that c and c are related at world w if there is some future world w allowing for the computations to perform allocations at which the respective final states and values are related this pattern of quantification occurs in many accounts of generativity but the dependence of w on both h and h creates a difficulty when one generalizes from to pers and tries to prove equivalences roughly one has to consider varying the initial heap in which one computation say c is started the existential then one with a different extension that is not at all related even on the side of c where the heap the same to the one with which one started in the case of the fact that h depends only on h not on h allows one to deduce sufficient information about the domain of w from the clause h h w but this breaks down in the more abstract setting to fix this problem we will essentially replace the existential quantifier in the logical relation by appropriate functions explicitly enforcing the correct dependencies in the language of type theory this amounts to replacing the existential with a type a statement like c c t a is no longer just a proposition but we rather have a set of proofs p c c t a and our constructions will explicitly maps proofs to proofs we have previously shown how the formalism of can be used to make such both rigorous and more general that work dealing with a version of pitts and calculus used to solve another problem associated with the use of existential quantification that it fails to preserve of predicates and relations and so with general recursion here we show how that technology to a much richer language and type system motivating examples we will assign types to terms in a fairly conventional untyped metalanguage with higherorder functions and dynamically allocated references to flat data the language is defined formally later on but the following examples of the kind of equivalences and typings we will be able to justify should be let memo be the function x ref in let y ref f in a x then y else let r f a in x a y r r where t t let t in t is sequential composition and is equality on values so memo returns a memoized version of its argument unlike previous models of effects our model the typing memo int int int int saying that if f is observationally pure memo f is too and so can in any program equivalence relying on purity for example a client can deduce the observational equivalence of the programs below purely on the basis of typing memo xx in e memo xx in ye overlapping references let pp implement a bijection z z × z then let r ref in pr pr x y pr in r pn y x y pr in r px n which two abstract integer references onto a single concrete one can be given the type or unit unit int × unit int × int unit × int unit expressing that it allocates in two regions r and r and returns a tuple of functions each of which reads or writes just one region this typing for example writes to the two abstract references set a more realistic example for which we do not give concrete code is a function that generates mutable integer sets calling allocates a new reference cell pointing to a linked list of integers initially empty and returns a triple of functions mem add rem for testing membership of the represented set adding a new integer to the set and removing an integer from the set the implementation of mem searches for its integer argument in the linked list but at the same time the list by removing and just for fun potentially some of the nodes the other operations can potentially perform similar optimizations we can justify the following semantic typing for int unit which expresses that allocates in some possibly fresh region r and returns operations that only read r the first one andor write in r the second and third one even though all three functions may read write and allocate concrete locations thus these functions can in corresponding program equivalences for example mem operations may be and duplicated lazy initialization the following definitions illustrate an form of lazy initialization make ref p then else p p then else p setx p then p ref else p n p then p ref else p n we can introduce a new abstract type for which the following typings can be semantically justified make unit int setx int unit int setx int unit observe that the allocation effects are in the make function even though the physical allocations happen on demand in the set functions note also that semantic reasoning is necessary to justify that these definitions are welltyped at all as a point holds different kinds of value at different times syntax and semantics in this section we define the syntax and denotational semantics of our untyped metalanguage for stateful computations we also give an type system for this language that is parameterized by axioms we omit the standard details of interpreting cbv languages via the metalanguage and of adequacy relating the operationally induced observational equivalence to equality in the model denotational model a is an cpo ie a partial order with of chains a domain is a with a least element recall that f a a is continuous if it is monotone x y f x f y and preserves of chains ie f xi f xi any set is a with the discrete order if x is a set and a a then any f x a is continuous a subset u of a a is admissible if whenever is an chain in a such that ai u for all i then ai u too if f x × a a is continuous and a is a domain then one defines f x with f x a one has f x f x f x and if u a is admissible and f x × u u then f x u too we denote a partial continuous function from set a to set b by f a b we assume two sets l and vb modelling concrete locations and the that can be stored in locations we assume that include integers written for some n z booleans written for b b locations for some l l and tuples of written v vn we assume that it is possible to tell whether a value is of that form and in this case to the components heaps h h are finite maps from l vb the domain of a heap h is domh l we write h for the empty heap if v vb l domh then is the heap that updates l to contain v v yields a pair l h where l l and h h the following properties hold dom domh if l l then v else hl and if v l h then domh domh l and l domh and h l v note that heaps and are discrete we do not here model higherorder store storing objects with nontrivial order such as functions our stores are flat like those of objectoriented languages we define the of values v and the domain of computations c simultaneously as follows c h h × v are partial continuous functions from h to h × v the bottom element being the everywhere undefined function values are defined as either tuples of values or continuous functions from values to computations v vb c v such domain equations can be solved by standard methods syntax the syntax of untyped values and computations is v x c v v v v rec f x t t v let x t in t v v if v then t else t v v v here x ranges over variables and constants c over constant symbols each of which has an associated interpretation c v these include n with n booleans arithmetic operations test functions to tell whether a value is an integer a function a pair or a reference equality test for etc rec f x t defines a recursive function with body e and recursive calls made via f we use xt as syntactic sugar in the case when f f vt finally v reading returns the contents of location v v v writing updates location v with value v and allocating returns a fresh location initialized with v the metatheory is sim by using form in which the only elimination for computations is let though we sometimes nest computations as shorthand for versions in examples the untyped denotational semantics of values v v v and terms t v c is defined in usual way by inductive clauses which we omit here types are given by the grammar unit int bool a × where a ranges over abstract types they will include reference types such as and also types like lists sets and even objects again possibly refined by regions the metavariable represents an effect that is a subset of some fixed set of elementary effects about which we say more later the core typing rules for values and computations are shown in figure the side condition on rule dead requires us to that t terminates for all inputs and heaps satisfying the contracts specified in we assume an ambient set of typing axioms each having the form v where v is a value in the metalanguage and is a type meaning that v is to be of type and that this will be proved manually using the semantics rather than using the typing rules we also assume an ambient set of equality axioms each having the form v v and semantic equality of v and v at type again to be justified manually we assume that whenever v v is an axiom so are v and v the equational theory can be classified in three different categories basic congruence and an extract of the basic and congruence equations are depicted in figure the the also includes all the usual beta and laws and conversions for conditionals as well as for let we will give a se interpretation of typed equality judgments which is sound for observational equivalence as with typings further equations involving effectful tions may be justified semantically in a particular model and added to the theory in particular we can justify the soundness of four equations namely dead duplicated and computation and pure lambda also shown in figure the core theory then allows one to deduce new semantic equalities from already proven ones abstract locations we now define the concept of an abstract location which generalizes physical locations in that it models a portion of the store that can be read from and updated such portion may a fixed set of physical locations or a varying such set as in the case of a linked list with some given root it may also in just a part of a physical location eg the two low order bits of an integer value stored in a physical location furthermore the equality on such abstract location may be than physical equality eg two linked lists might be considered equal when they hold the same set of elements and there may be an invariant eg the linked list should contain integer entries and be neither circular nor aliased with other parts of the heap this then us to model an abstract location as a partial equivalence relation per on heaps together with two more components that describe how modifications of the abstract location interact with the heap as a whole thus next to a per an abstract location also contains a reflexive transitive relation guarantee modelling its evolution by way of modifying actions we will define a notion of when abstract locations are independent generalizing the traditional notion of separation however there is some extra complexity due to the fact that whatever custom notions of equality and separation we introduce we would like them all to interact well with the underlying builtin allocator a true bool false bool n int v a type axiom v x x v v v × vi i v v v v × v v v v f x e rec f x e e e v int e e if v then e else e e x e let x e in e t r t figure core rules for effect typing basic equations extract t tt tt t t tt t t tt vv vv v × v v v × v v v vi vi i f x t t rec f x t rec f x t f x t v rec f x t v rec f x t f v x t t t x y t v v an equality axiom let x v in t let x let y t in t in t let y t in let x t in t vv congruence equations extract v v × vi v i i v v bool t t t t if v then t else t if v then t else t effect based equations t t let x t in t t dead provided t terminates t x x y t y t in t let y t in xt x pure lambda t x y t als let x t in let y t in t let x t in t duplicated t t x y t let x t in let y t in t let y t in let x t in t figure basic congruence and effect based equational theory · l l · l l l l l · hl · hl · h hn · h · hn · a a · a · a dom · h · domh · r h · h r figure action of permutations allocated concrete cell should be independent of any existing abstract locations for example and abstract locations should not be sensitive to the behaviour of the underlying allocator were we working in a language in which the allocator is just another piece of code to be verified we would hope that concrete locations could be treated as a special case of abstract ones but this seems to require a notion of when one notion of location is an abstraction of another and birkedal have taken some steps along such a path instead we here in compatibility with the underlying allocator using nominal ideas following and pitts we write for the group of permutations of l and define an action · of permutations for values stores sets of locations and relation on stores table contains the most important cases note that permutations act differently on sets of locations and on sets relations on heaps in the sequel we call object anything that the permutations act on ie locations values stores etc for example a list of heaps h is in the relation · r iff the list of heaps obtained by the permutation · h is in the relation r we define the set of fixpoints of a permutation as fix l l l for an object x a support of x is a set of locations l such that fix l · x x and pitts show that if an object has a finite support then it has a unique least support which we write it is clear that stores values and finite sets of locations always have a finite support a store relation having a finite support is called finitely supported for example the predicate p on stores that there is a linked list starting at location x has support x note that although a linked list in h that h p may have a large footprint the support still is just x because the internal nodes of such a linked list will be consistently renamed by the permutation action definition abstract location an abstract location l on the chosen set h consists of the following data · a nonempty finitely supported partial equivalence relation per lr on h modelling the semantic equality on the bits of the store that l uses a · a finitely supported transitive relation lg modelling what bits of the store writes to l leave a guarantee condition that is if h h lg then h might arise by writing to l in h and all possible writes are specified by lg subject to the conditions where is a permutation and h lr is shorthand for h h lr if fix then h lr h · h lr if h lr then h h lg if h h lg then h lr and h lr lr lg lg lr that is if h h lr and h h lg then there exists h such that h h lg and h h lr if h lr and h h then h h lr thus lr looks no further than the currently allocated portion of the heap if h lr and h h h lg then hh h lg h h h condition asserts that semantic equality is closed under cation it rules out relations that equality of internal point not to fixed ones which would the support but between h and h conditions and ensure that relies and guarantees in well with future extensions of the heap preserving and being independent of fresh locations we write h l h to denote h h lr h l h to denote h h lg we also use the notation for if is a permutation we define · l · lr · lg it is easy to see that · l is an abstract location and fix · l l furthermore for any and such that one has · l · l this makes the following definition possible definition of abstract locations let l be an ab location and u l be injective then is defined as · l for some extending u we have · l for the separated heaps requirement h h hh h h x nil setx h y nil h this set contains the disjoint unions of any evolution of the linked lists pointed by the concrete locations x and y the following lemma will be helpful for abstract locations and independence lemma if then ll proof let h l and h l let l domh and l domh choose permutations and such that and define the heap h h by h hl · hl if l · l · hl if l · l undefined otherwise thus in particular domh h · l · l from def we know h · h lr we also have h · h h lr by def thus · h h h lr so we can conclude by transitivity the remaining properties are left to the reader definition if l l are independent we form a joint location l l specified as follows · l lr h h h h lr lr and l l and l l · l lg lg lg restricted to l lr for an example consider the following abstract location setx with support x implementing the set example introduced above lemma if l and l are independent abstract locations then the joint location l l is an abstract location h h if h and h contain a linked list starting from x and these lists contain the same set of integers lemma let l and l be independent abstract locations then l lg lg lg l lr h h h h and ll domh fh x hl hl lemma l l l if and only if ll and ll l where fh x is the set of the locations in h reached by the linked list starting from x the rely set specifies that two heaps are equivalent when linked lists denote the same set of integers the guarantee specifies that a write to this abstract location may not change concrete locations not in the linked list note in particular how this example condition def we can one of the two linked lists without in provided we leave the entry point x fixed if one tried to modify our abstract location to relate linked lists with the exact same footprint then property would fail definition separated heap let l l ln be abstract locations a heap h is separated with respect to l l ln written l l ln if for all i n h and for all j i and for any heap h such that h li h we have h lj h and l l ln definition independence abstract locations l l ln are independent written l l ln if h l hn ln then there exists h where l l ln and h li hi for i n the definition of independence implies that by the intersection of the pers yields a product of the individual as the separated heap h as defined above is unique up to with respect to l ln we use the notation h h · · · hn to denote a canonical separated heap returning to the example consider two sets setx and where x and y are the concrete locations where the linked lists implementing respectively setx and start if x and y are different we use coinduction to show setx and are independent using the following set as the coinductive hypothesis definition let be the abstract location as follows r and h h g if and only if h h notice that lemma ll if and only if and ll moreover l l remark motivated by the axioms of separation algebras one might conjecture that is ie that ll ll implies l l however for the above definitions this does not generally hold examples of abstract locations besides abstraction locations for sets of integers used above we illustrate other instances of abstract locations single integer for our simplest example consider an abstract location lx parametric with respect to x as follows h h hx n h x n h h h h and l ll x hl hl two heaps are in its rely relation if the values stored in x are the same and its guarantee is to leave all other concrete locations alone it is also the case that and are independent ie this is by the following coinductive hypothesis to show the condition of heaps with respect to these locations similar to the one used before for the showing the independence of setx and h h hh h hx hy h overlapping references recall the overlapping references example introduced earlier let x be the concrete location encoding a pair of values we define abstract locations and by h h hx a a h x a a a a h h hx a a h x a a a a h h h h and l ll x hx a a hx a a hl hl a a h h h h and l ll x hx a a hx a a hl hl a a the rely of respectively specifies that two heaps h and h are equivalent whenever they both store a pair of values in x and the first projections respectively second projection of these pairs are the same the guarantee of respectively specifies that it keeps all other locations alone and does not change the second projection respectively first projection of the pair stored at location x by using a coinduction hypothesis for separated heaps similar to the ones used above it is straightforward to verify that and are independent although they share the concrete location x lazy initialization recall the lazy initialization example introduced earlier let x be the concrete location used to store the data that is initialized we define the following abstract location parametric on i h h hx x and h x x and hx a a h x a a h ai h h h h and hx hx and hx a a hx a a ll x ai ai hl hl where x is the predicate hx hx a a ha ha the rely specifies that two heaps are equivalent when either x is in the initial uninitialized state in both of them as specified by the predicate initial or x in both heaps points to a pair of references the ith of which also contain the same values the guarantee condition specifies that x in an updated heap is only if it was so before and moreover all locations not used in the rely are left unchanged abstract locations capture the invariants that we will use to build our model the big picture is that types are modelled as functors from a category of worlds into a category of with terms being interpreted as natural transformations worlds will independent abstract locations are augmented with a notion of equality in this section we define the category of more precisely section then explains the structure of the category of worlds and functors while we assume that the reader is familiar with some notions of category theory such as functor natural transformation and cartesian closure we review some basic concepts and notation here we compose morphisms in the usual applicative order thus if f a b and g b c then g f a c a morphism u in a category c is a if ux ux implies x x for all morphisms x x a square xu x u of morphisms is a if whenever xv x v there is unique t such that v ut and v u t a pair of morphisms u u with common domain is a span a pair of morphisms x x with common codomain is a a category has if every can be completed to a square we define the category of as the exact completion of the category of see we recall here the elementary description using the language of dependent types given in an earlier paper et al definition a a consists of a a and for any two x y a a set ax y of proofs that x and y are equal the set of triples x y p p ax y must itself be a and the first and second projections must be continuous furthermore there are continuous functions ra x x and sa x y y ay x and ta x y y × ay z ax z symmetry and transitivity note that no equations between these are imposed in the above definition continuity of a dependent function such as t means the following if and and are chains in a with x y z and pi yi and qi zi are proofs such that xi yi and yi zi are also chains with x y p and y z q then xi zi qi is an chain of proofs by monotonicity of t and its is x z tp q if p ax y we may write p x y or simply x y we also omit appropriate based on types rather than have been used to provide extensional equality in intuitionistic type theory definition a morphism from a to b is an equivalence class of pairs f f f of continuous functions where f a b and f x y y b fx fy two such pairs f g a b are identified if there exists a continuous function µ a ab f a ga morphisms are composed in the obvious way to form the category of in the sequel we tend to omit and subscripts where appropriate thus writing xa for xa or a a or even a a for a a etc we remark that one could also choose not to identify equal morphisms we decided to make the identification because standard concepts like cartesian closure etc then apply directly rather than only holding up to the following is see also proposition the category of is the cartesian product a × b of a b has components a × b and b a b aa a b the ordering is given the underlying of the function space of a b of a b is given by the set of f f of morphisms from a to b ordered component and pointwise given two such elements f f f and g g g a proof µ f g in a b is a continuous function establishing equality of f and g morphisms from a to b as in definition proof the verification of the cartesian product is straightforward the application morphism ap from a b × a to b has components given by ap f f a fa and p fp where µ f g and p a a note that we have fp fa fa and fa ga conversely if h c × a b is a morphism represented by h h we define h c a b by hc f f where fa hc a and fp p we also put hp c c a hp if h h is another representative of h by a proof µ then a witnesses equality of the so constructed abstraction the remaining are direct proposition the category of has proof to construct a of x a b and x a b pick x x and x x and take the low point of the u to be given by u a a p a a a a p x a and then ua a p a a p aa a the ordering is component the morphism u u a is defined by ua a q a and up p p the remaining definitions and are straightforward note however that when proving the uniqueness of to establish the property we make use of the fact that pointwise equal morphisms are identified definition a d has a least element if d has a least element and there is also a least proof d proposition for each d with least element there is a d d d such that the following hold · ap so f is a fixpoint of f · suppose that both d d have least elements and u d d satisfy u let dd g x g d d be the of u dd dd and u d d dd so intuitively x contains pairs f f with f d d f d d and u f f u then g intuitively this means that if u f f u and u then f f proof given f d d construct the least fixpoint of f as fi the from f to the least fixpoint being continuous this defines the first part of ie f fi as for the proof component assume that p f f by repeatedly invoking p we then get a family of proofs pi fi fi using the fact that r is the least proof we can then show by induction on i that this family of proofs is increasing and its satisfies pi f f thus we put pi which again is continuous it is obvious from the construction as a least fixpoint that the required fixpoint equation is indeed satisfied as for the second one pick u d d and assume f d d and f d d and a proof p u f f u now by repeatedly invoking p we get an increasing family of proofs pi u f i f u f whose witnesses f f this establishes the claim worlds and functors we now abstract locations into a category that will in the meanings of types and terms in a functor category seman tics our category is similar to that of finite sets and which has been used in other work the is that objects are now sets of mutually independent abstract locations and morphisms are slightly more complicated in that they allow of abstract locations furthermore locations are into regions allowing one to approximate them statically we begin with some more notational write x u x u or w x u x u w when w for a square with morphisms x u x u we call the common codomain of x and x the of the written w while the common domain of u u the low point of the square is written w a pair of morphisms u u with common domain is a span a pair of morphisms x x with common codomain is a a category has if every can be completed to a square a square w x u x u w with w is minimal if whenever there is another w x u x u w over the same span and with w then there is a unique morphism t w w such that x tx and x tx lemma if a category c has and x u w with w is a minimal then the morphisms x and x are that is if f x gx and f x gx then f g for illustration purposes we notice that the category of finite sets and has and in it every span can be completed to a minimal indeed if u u a and u u a then the of the minimal can be chosen as a a with denoting disjoint union definition category of worlds assume given an infinite set of region names the category of worlds w is defined as follows · an object written w and called a world a finite set of mutually independent abstract locations written and a function tagging each abstract location in w with a region from we write wr for the set of abstract locations in w tagged with r we define · let w and w be two worlds a morphism from w to w is given by an injective function u such that for each l we have u · l cf def and moreover if l wr then u · l w r · we write iw w for the set of morphisms u w w that are settheoretic note that u · l l in this case · the empty world is denoted ie dom for example a morphism between region tags omitted is given by the injective function that simply maps the concrete location x to the concrete location y the abstract locations together in one region represent all the stateful components be they physical locations or more complex data structures that belong to that region static effect annotations possible side effects on any of those components as effects on the region the notion of morphism presented here is the simplest possible one that allows us to justify interesting equivalences there are more general notions of morphism that allow one to justify equivalences relying on representation independence eg ones resulting from replacing by in a program it is also possible to define the category of worlds differently by combining all the abstract locations contained in a given region using the operation a world then becomes a function assigning to each region a single large abstract location possibly the trivial one the presence of a morphism from one world to another then has to imply that the abstract locations attached to a region grow properly ie go from l to an abstract region isomorphic to l l which can be captured by idea of morphisms between store shapes which has later been as lenses in the context of bidirectional synchronization we decided for reasons of space and simplicity against using these more general notions of worlds and morphisms here but plan to discuss them in an extended version of the paper the following is proved just as in the case of finite sets and proposition in the category w all morphisms are w has and all in w can be completed to minimal moreover these and minimal can be chosen in such a way that if one of the two given maps is an inclusion then the one parallel to it is also an inclusion if u w w and x w w then we can find w and u w w and x w w so that w x u x u w is a minimal and if one of u x is an inclusion then the opposite morphism can be chosen as an inclusion as well the world w in the last clause the locations in w and those in w that are not in w intuitively if w a w a b w a b c then w a c functors a functor a from a category of worlds w to the category of as usual for each w w a aw and for each u w w a morphism of au aw aw preserving identities and composition if u w w and a aw we may write ua or even ua for and likewise for proofs in aw note that definition we call a functor a if for every square w x u x u w with w and low point w the diagram below is a in the category of aw f aw e aw aw given our characterization of in the category of prop this condition is equivalent to the existence of a continuous function of type a aw x a a a × aw u a a which amounts to saying that if two values a aw and a aw are equal in a common world w then this can only be the case because there is a value in the intersection world w from which both a and a arise the witness a is unique up to more importantly even two values cannot become equal just because we move to another world even though preservation is not formally needed in the proofs of any of the subsequent results it simplifies the intuition considerably lemma if a is a and u w w and a a aw then there is a continuous function aw ua ua a there is also a continuous function in the other direction just by note that the ordering on worlds and world morphisms is discrete so that continuity only refers to the aw ua ua argument definition morphism of functors if a b are a morphism from a to b is a natural transformation from a to b thus concretely a morphism is an equivalence class of pairs e e e of continuous functions where e bw and e ww x w w a aw aw xa a bw ea two such morphisms e e are equal if there exists a continuous function µ wa e a these morphisms compose in the obvious way and so the and morphisms between them form a category theorem the category of is and has if a b are then a × bw aw × bw and a bw contains pairs f f as follows fu aw bw for each w and u w w if u w w and v w w then fu v aw bw aw bv fu where av bw aw bw aw bw aw bv aw bw aw bw are the obvious composition morphisms a proof in a bw f f f f is a function g that for each u w w yields a proof aw bw fu f u the order on objects and proofs is pointwise as usual moreover if d is a with the property that has a least element w for each w and whenever u w w then uw w then there is a morphism d d d satisfying the same properties as those in prop proof this is a special case of the construction of a functor category with respect to an internal category here the category of worlds viewed as discrete thus internal to the category of one the standard constructions for functors taking care to keep of morphisms distinct as we did in the construction of the function space of the existence of the fixpoint operator does not seem to be known but follows by applying the same method the rather finegrained specification of the fixpoint operator on the level of is needed here so that we can of and f heaps as a we will now heaps with a structure out the separated ones for a particular world and setting equality to be induced by the ambient rely relations definition if w is a world then the sw is defined by sw h h l wh lr and h l wh l h and h otherwise where is the separated heap with respect to the locations in see definition if u w w and h sw then we define hu sw to be · h for some extending u this is welldefined up to in this way s becomes a contravariant functor from the category of worlds to the category of lemma lemma let x u w be a minimal with w let h sw and h sw such that hu h u then there exists a heap h sw unique up to such that hx h and hx h corollary let u w w be a morphism and h sw and h sw there exists h unique up to such that hu h and hu h u where w u u w is a minimal with low point the empty world intuitively h is obtained by the of h according to h heap relations definition a relation r on s consists of a subset rw sw × sw for each w such that if h h rw and u w w then hu h u rw and if p h h and p h h then h h rw as well the elementary effects track reading writing and allocating at the level of regions and are as follows writing within region r reading from within region r and allocating within region r each elementary effect is associated with a set r of relations on s as follows r h h rw l l h r h h rw l hh l h l h h h l h h h rw r h h rw wu iw ww w wr h h h hu h h h lr h h rw thus is the set of relations r for which heaps contain equal in the sense of lr values for all abstract locations in region r a relation r is to preserved by equal writes to any abstract location in r and a relation r is to extensions of the current world provided that they only add abstract locations in region r that the initial contents of these newly allocated locations are equal in the sense of r and that nothing else is changed finally r for a set of effects is defined as follows r r as in our earlier work the key idea is that computations with effect will preserve all the heap relations that are preserved by all the operations allowed by the larger the set of operations the fewer relations need be preserved definition monad let a be a and an effect a ta is defined as follows · objects elements of are pairs c c of partial functions where c sw w × sw × aw and c is as follows if r r and h h rw then cr h h either is undefined and ch and ch are both undefined or else cr h h is defined and then ch and ch are both defined say ch w u h a and ch w u h a in this case cr h h returns a pair x v x v p where w x v x v w such that xu x u furthermore p x a and finally hv hv rw where w and w are low point and of x v x v · proofs proofs only look at the components let c c and c c then a proof in c is a partial continuous function µ such that for a given h sw if is undefined then ch and ch are both undefined if is defined then ch w u h a and ch w u h a are both defined in this case returns a tuple x v x v q satisfying xu xu q x a and hv hv in sw with w and w and low point of x v x v · order the order between computations is given pointwise c c c c if and only if for any h sw we have ch ch which is defined as follows for all h sw if ch is defined so is ch moreover if both ch and ch are defined as ch w u h a and ch w u h a then w w u u h h and a a finally if cr h h and cr h h are defined returning x v x v q and x v x v q then x v x x v v x v and q q · morphism part let x w w be a morphism and c c c we are going to describe the first component of c given h sw write w u h a should this application be undefined so is ch now using complete u x to a minimal square x u u x with u w w where w is the of this now obtain h sw from h by with hu using corollary then h and h note that hu h u by construction using lemma to yield the desired heap h sw we then put ch w u h x a we omit the remaining components and the proof of the following is tedious but straightforward and will be given in an extended version of this paper theorem t is the functor part of an strong monad this theorem means in particular that each t is a monad on the category of ie for each a there are natural transformation a a ta and ta subject to the usual laws and whenever then there is a morphism t a t a which with the monad data in the expected sense illustration assume an initial heap h where hx and hy that is h points to the lists and from concrete locations x and y respectively moreover let ch w u h y and c h w u h z where strictly speaking q q needs to be a tuple with the objects they are proving the equality of hx hy and while hx and we can show that c and c are equal when given h the proof is illustrated by the diagram below where an arrow labeled with denotes an inclusion and an arrow labeled with a mapping eg z y denotes the corresponding renaming u w setx u w setx zy t w setx w setx zy t w setx here it is easy to check that h and h are equal when taken to the world w as the concrete locations x in h and h and y in h and z in h point to lists containing the same set of elements and respectively notice that the abstract locations w and w are not taken into account moreover the value y is also equivalent to z when taken to the world w as the morphism w w z to y while the morphism w w is an inclusion we see here that the use of rather than plain sets or is crucial the proofs in ta are clearly relevant as they explain in what way the abstract locations correspond to each other likewise the elements of ta contain more information that the computation ie the evolution of the heap namely the world extension w will typically contain new abstract locations with new contracts that can be arbitrarily complicated thus it would not be possible to replace ta with a simple logical predicate on actual computations logical relations the structure identified so far allows us to interpret our effect type system and the equational theory in the category of definition type interpretation a type interpretation consists of an assignment of a a to each basic type a given a type interpretation we can then assign a to each type the essential clause being t we also interpret a typing context as the cartesian product over its bindings x lemma let r be a region for world w define wr by removing all locations in r if type does not contain r then for each world w the morphism u wr w where u wr w is the obvious inclusion is an isomorphism definition axiom interpretation an axiom interpretation consists of an element xv empty world for each type axiom v and of an element xv xv for each equality axiom v v given an axiom interpretation and a type interpretation and a welltyped term e we define a morphism e t using the fact that all the typing rules are reflected in the semantics cartesian closure takes care of application and abstraction and variable management the fixpoint morphism takes care of recursive definitions the indexed of t takes care of the rules associated with let and effect propagation lemma fi takes care of the rule if v because of the axiom v then we put v xv constant morphism effects given a set of effects we write r r als r and moreover the set we also introduce the following piece of notation for h h sw h h l l h h h l l h which specifies that the heaps h and h are equivalent on all the abstract locations l in regions associated to read effects in and on the not write locations respectively theorem equational soundness assume an ambient interpretation of types and axioms if e e then the morphisms e and e are equal morphisms proof by induction on derivations the core rules are direct from the structure identified so far the rules are nontrivial however given lemma their proofs follow essentially the same reasoning as in existing literature as for the axiom rule we argue as follows if v v using the axiom v v then we have v xv and v xv and the constant function is continuous and thus establishes the desired equality lemma let e let w x v x v w be a square w w be contexts such that µ x x and c e w and c e w be computations such that µ xc x c let h sw h sw be heaps such that hv h v then ch and c h co terminate moreover if they do terminate and ch w u h a and c h w u h a then the following diagram exists in particular the dashed arrows where the following is satisfied observational equivalence we will now relate semantic equality to observational equivalence so far a trivial model that identifies everything could also have been used to justify our rules doing this however requires a relationship between the interpretation and the computational meanings of raw terms which will be given by a realizability relation definition for each type effect and world w we define v w x w u w w v w x u w v v w x w x xa xa w w q w w q w w q q w w q q for some q and q for all l w we have either hv l and h v l remain equivalent or l equally modified if l then hv l and h v l if als then there exists a morphism c t such that c c and if c wh w u h a then admissible relations w v × w and w c × t w as follows · if c c then c w c c means that for each h sw one has ch defined iff ch defined and if ch h a then · ch w u h a same if fun f v and f f iff whenever u w w ww a f f x then f a w fx · w x x w x for all x dom lemma the relations are indeed admissible and are stable under inclusion that is whenever v x w x and u w w is an inclusion then v x w ux holds the following soundness property of is proved by straightforward induction on typing derivations w w no world extension is needed and ww ww are theorem fundamental lemma assume that the interpretation of types and axioms is chosen such that for all type axioms proof the proof that the values are equal in w follows directly from the definition of computations and effects v one has v xv whenever e and w then e w e w for the item we use the following relation r defined as follows for all worlds w such that u w w h h hu hu l l h hu l h hu l hu otherwise for the worlds w not reachable from w the relation rw is the trivial set notice that r r and it is contravariant the claim then follows directly by using the morphism from w w definition observational equivalence two value expressions v v where v and v are observationally equivalent at type if for all f such that f unit observations it is the case that f v is defined iff f v is defined stands for empty heap and environment the proof of item follows in a similar fashion but we use the it is easy to extend this definition to open terms and computation following relation expressions by closing up with lambda abstractions intuitively h h hu hu hu h and we use a similar relation for showing that h and hu agree on the not written locations observationally equivalent expressions can be replaced by one another in any context without observable behavior to see this one can build observations f from such a context by first for item first we show that wr and wr are equal up to abstracting its hole and then adding at the end a wrapper function renaming for all regions r by using the following relation that tests for some observable feature of the end result rq for some world q failure of the test by nontermination h h h h r rw where r denotes the number of abstract locations colored with r clearly r r as does not contain any allocation effects thus theorem main result if v v then v and v are observationally equivalent the number of locations in w is the same as the locations in w by proof if f is an observation then by the congruence rules we using the w v x w this gives us one direction while the other direction is obtained by the universal property of given this property one can easily construct the function c get f v f v so by theorem we find f v f v thus in particular f v empty world empty heap is defined iff f v is defined now if f v is defined then by theorem and the definition of we can conclude that f v is defined so using theorem again we get that f v is defined applications in this section we give some concrete instantiations of our framework in the form of axioms and their semantic we do so in more detail for the overlapping references example shown in section and in less detail for the other examples overlapping references recall value and type or from sec tion two overlapping references in order to justify the axiom or we have to construct a semantic object or such that or which we will now do given world w we put c c where c and c are defined as follows unit w ch u w w h g g s s where x h that is h is obtained from h by allocating a concrete location x w is the world obtained by extending w with the abstract locations and defined in section where the former is marked with region r and the latter with re r finally g g s s are the corresponding semantic objects that get and set values to the projections of pairs stored in x eg g unit int w is the semantic counter part of the function getting the first projection of the pair stored in x defined in a similar way as we do for note that or in particular requires that the new heap returned by c with the one returned by and more generally we are forced to follow the computational behavior of in we are free though to choose the semantic components such as world extensions and later the object c now is defined as follows assume that r is a heap relation and two heaps h h sw that are related ie h h r moreover assume that ch u w w h g g s s and ch u w w h g g s s where the former allocates x while the latter allocates x note that everything terminates in this example now cr h h returns the w xx xx w where x is mapped to x it is easy to check that h and h are related in r when taken to the low point and that g g s s and g g s s are equal in its note that once this typing has been justified all equations able from it are automatically sound for observational equivalence thus in particular writes to the two overlapping reference com set let w be a world and h sw suppose that h arises from h by allocating a fresh set data structure eg a linked list with entry point x let setx be the abstract location describing this fresh data structure now for any chosen region r we can add setx to r to yield a new world w the function then returns w and a tuple of semantic functions for reading membership removal of which we only sketch reading here if u w w and h sw and i z then the reading function looks up i in the data structure starting at the entry points x in h note that h sw asserts that this data structure exists and is wellformed the returned abstract store h might not be the same as h because internal eg removal of might have occurred but no world extension is needed and h h holds this together with the fact that the outcome only depends on the equivalence class in the sense a readonly typing for reading memoization for the simple memo functional from section we produce just as in the previous example a fresh abstract location l whose specification looks only at the two newly allocated concrete locations say lx ly where the first stores the argument value i and the second the integer value f i where f is the pure function to be the locations l rely specifies that two heaps are equivalent when the values stored in lx and ly are the same h h lr h lx h ly we see in lemma that if a function is semantically pure empty effect then there is a world and function describing its action thus the memo functional may be considered pure state dependent abstract data types although our focus is on equivalences that can be derived from refined typings using our equational rules we are able to justify some of the wellknown examples from the literature on proving equivalences in mllike languages without effect annotations our guarantee conditions here act like the transition system components of the worlds used by ahmed et al example the first example is the classic example consider the following two programs e let x ref in fx f x and e f f intuitively e and e are equivalent as they both return the value although e uses a fresh location to do so we can formally prove the equivalence as follows assign the region where x is allocated as r if f has the type unit unit with effects then e has type unit unit int while e has type unit unit int notice that may contain or or both moreover assume that an abstract location in region r looks at a single concrete location l lr h h hl h l lg h h hl l hl notice that it is correct to assign e a write effect in region r as it writes the value to the location assigned to x for proving the equivalence of e and e assume a world w and a heap h let e wh w w wr u h a and e wh w w u h a we construct a square w w wr w w such that the values a and a are equal in its and h and h are equal in its low point since is in the effects of e we have that a we also have a trivially hence a and a are equal in the of the square w w wr w w similarly h when taken to the low point of the square that is where the locations in wr are the resulting heap is equivalent to h modified example consider now the following variant of the example e let x ref in fx f x f x e f f f the difference is that in the first program x is first assigned and the callback function is used twice interestingly however our solution for the example still works just fine we can prove semantically that the type of the program e has the same type as before in the example where the only writes allowed on the abstract location assigned for x is to write the concrete location to one then the reasoning follows in a similar way callback with lock example we prove the equivalence of the following programs e let b in let x ref in b then b false f x x b true else x e let b in let x ref in b then b false let n x in f x n b true else x both programs produce a pair of functions one that increments the value stored in x and the second that returns the value stored in x they use the boolean reference b as lock in the function in particular once this function is called the value in b is set to false and only after the callback is called and the value in x is is b set again to true however the implementation of the increment function is different while e invokes the callback f and then increments the value in x e in n the value of x before the callback and then uses n to update the value stored in x assume that x and b are allocated in the same location l in the region r we show that these programs are equivalent in the type unit unit unit × unit unit where may contain the effects in particular the location l looks at two concrete locations lb and lx storing x and b lr h h h lb h lx lg h h false h h and true i j true j i l lx hl first notice that indeed the two programs above have the effect the increment of x is allowed by lg as b is initially true to show that the two programs above are equivalent we show that the value stored in x before and after the call back is called remains the same this is the case as even if the callback function has a write effect in the region r ie it cannot change the value of x this is because when the function is called the value stored in b is false meaning that the heap remains the same despite the above the model as presented here does not directly justify equivalences involving representation independence eg that our overlapping references are observationally equivalent to an implementation that really allocates two integer references generalizing world morphisms as discussed after def does allow many such equivalences to be proved though a parametric variant along the lines of that described by would be more powerful still related and future work we have shown logical relations introduced in our previous work can be used to justify nontrivial program equivalences for the first time it was possible to combine program equivalences with hidden invariants allowing modifications that do not count towards the of an effect earlier accounts of program equivalences do not provide such possibilities bisimulation an alternative approach to proving difficult contextual equivalences is to use techniques based on bisimulation while bisimulation has been applied to typed calculi the strength of the method lies in being able to deal with computation rules and fairly simple types and contracts rather than computation rules callbyvalue lambda calculus in our case and types and contracts indeed we believe that something like our abstract locations and the world extensions would also suggest itself in a approach to the equivalences studied here model variables logical relations or rather the sets aw where a is a semantic type bear a relationship with the model variables from design by contract and more generally data refinement the is that we track the semantic behavior of a program part with abstract functions on some abstracted set of data that may contain additional information the model the difference is that we do not focus on particular proof methods or specification but that we provide a general sound semantic model for observational equivalence and program transformation and not merely for functional correctness this is possible by the additional also part of the semantic equality proofs between the elements of the models we also note that our account supports higherorder functions recursion and dynamic allocation separation logic our abstract locations draw upon several ideas from separation logic in particular the conditions on relyguarantee assumptions from we did not need something the frame rule although perhaps the quantification over larger worlds in function spaces plays its role our use of functors is motivated by or rather the to which they are equivalent gives a account the way in which we work with both permutation actions and functors has some but does feel slightly it really to be possible to combine the two structures into one we would like to define a format that allows one to semantic proof obligations in some cases without having to go down to the lowlevel semantic definitions we noted that private transitions serve a similar purpose and might perhaps suggest a possible approach in our case too we would also like to be able to store values with equality which would allow a stratified form of higherorder store unrestricted higherorder store requires circular definitions of worlds which has previously been addressed using for example metric spaces acknowledgments we thank and andrew kennedy for discussions was supported by and references a ahmed d dreyer and a representation independence in popl g v and o in type theory j program ­ n benton l m hofmann and a kennedy relational semantics for program transformations higherorder store in n benton m hofmann and v logical relations for name generation in n benton and ck and compiler correctness in icfp n benton a kennedy l and m hofmann relational semantics for program transformations with dynamic allocation in n benton a kennedy m hofmann and l reading writing and relations in volume of lncs n benton a kennedy and g russell compiling standard ml to java in icfp n benton and b relational reasoning in a nominal semantics for storage in volume of lncs l birkedal a g and d s scott type theory via exact categories in lics l birkedal k and j the solution of recursive equations theor comp sci ­ g typing termination in a higherorder concurrent imperative language inf comput c calcagno p w ohearn and h yang local action and abstract separation logic in lics pages ­ a p j freyd and a a categorical approach to realizability and polymorphic types in lncs y g t m and s h model variables supporting abstraction in design by contract ­ w p de and k data refinement proof theories and their comparison cambridge university press t p and m j abstraction and refinement for local reasoning in volume of lncs d dreyer a ahmed and l birkedal logical stepindexed logical relations logical methods in computer science d dreyer g and l birkedal the impact of higherorder state and control effects on local relational reasoning in proc icfp acm pages ­ j n foster m b j t moore b c pierce and a combinators for bidirectional tree transformations a approach to the view update problem in popl pages ­ m and a m pitts a new approach to abstract syntax with variable binding formal comput ­ d k and j m integrating functional and imperative programming in lisp and functional programming ck and d dreyer a kripke logical relation between ml and assembly in popl ck d dreyer g and v vafeiadis the of bisimulations and kripke logical relations in j field and m editors popl pages ­ acm j b and l birkedal separation logic in esop volume of lncs o and g d plotkin algebraic foundations for optimisations in popl v and m wand small bisimulations for reasoning about higherorder imperative programs in popl n l birkedal and j verifying programs using frame properties in n a d dreyer and d types in icfp r and a auxiliary state for concurrency in popl s mac categories for the working in mathematics springer nd edition sept b meyer applying design by contract ieee computer ­ f a approach to the semantics of programming languages phd thesis a pitts and i operational reasoning for functions with local state in higher order operational techniques in semantics pages ­ cambridge university press a m pitts nominal sets names and symmetry in computer science volume of cambridge in theoretical computer science cambridge university press a m pitts and i d b observable properties of higherorder functions that dynamically create local names or new in volume of lncs j c reynolds separation logic a logic for shared mutable data structures in lics j l birkedal b and h yang nested hoare triples and frame rules for higherorder store logical methods in computer science i names and higherorder functions phd thesis u cambridge e and b c pierce a bisimulation for type abstraction and recursion in popl j and l birkedal a kripke logical relation for program transformations in icfp v vafeiadis and m j parkinson a of relyguarantee and separation logic in concur volume of lncs p wadler and p the of effects and monads acm trans comput log ­ 