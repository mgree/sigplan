a lazy evaluator peter university of upon h morris jr xerox palo alto research center abstract a different way to execute pure lisp programs is presented it delays the evaluation of parameters and list structures without ever having to perform more evaluation steps than the usual method although the central idea can be found in earlier work this paper is of interest since it treats a rather wellknown language and works out an algorithm which avoids full substitution a partial correctness proof using semantics is sketched in a later section i introduction this paper studies a nonstandard method of performing the mechanical evaluation of expressions in a purely applicative one without assignment the intuitive ideas behind this method are two perform an evaluation step only when it is necessary never perform the same step twice it is somewhat surprising that these objectives can be through the use of rather simple data structures and algorithms the following example should serve to the reader with the basic idea integer procedure g if x then else yy an algol programmer who to this procedures speed by choosing whether to declare y a callbyname or a callbyvalue parameter would feel most the value of y is going t o be used either twice or not at all depending on the value of x the lazy evaluation technique this because the evaluation of will proceed as follows substitute pointers ct and to the expressions e and f for the formal parameters x and y evaluate ie reduce to a the contents of a if the result is return otherwise evaluate the contents of fl and replace them with the resulting evaluate the contents of again this takes little time since already a and multiply the results thus a lazy evaluator will perform the work to the second parameter either once or not at all this illustrates the callbyneed mechanism of and and the delay rule of here we shall carry this strategy one small but important step further as suggested in list structures are evaluated incrementally in lisp an argument of cons is not evaluated until and unless it is selected and examined by some later operation thus the statement x is always true even if the evaluation of x or y never terminates this extension is important it allows the possibility for significantly different of programming as the following examples illustrate example i infinite lists the function defined by is quite useful under a lazy integers denotes the infinite list and the expression will evaluate to via the following intermediate steps in a similar way the list defined by l cons l is useful and computable example a leaf comparator the following functions solve a problem by to illustrate the need for if then else if then y else if then else if false else if then r else false in other words tests two to see if their atoms are identical independent of structure this obvious solution uses to eliminate the structure then uses to compare the atoms it would be an slow method under normal because applied to a pair of expressions like a and b it would go to all the work of and even though the answer is false because of the first atoms in each structure differ if a lazy evaluator is used however there is no need to change the solution to one involving because the same computational effect will be achieved automatically suppose location r holds the expression to be evaluated the computation will follow this pattern wo first r is updated with the definition of with actual parameters substituted for formals no now pointers and r to the parameters are substituted into the definition of without any evaluation of the parameters to if then else if then false else if then else false rl the primitive null now forces the lazy evaluator to go to work on the contents of r rl if then nil else rl rl if then t else r h u g e l r h u g e l again the primitive null forces evaluation steps on r r if then else r the primitive atom forces the evaluation of rs r a r since is true rl r since is false to if then false if then else false if we choose to view as a coroutine at this point we would say that it has produced its first u a and its context has been saved in r for later now the contents of t is evaluated in the same way until we have r r r r if then else false the primitive eq forces r lr finally the test is made and the computation terminates with n false notice that and did not enter into any of the computation and that the work done to evaluate the subexpressions in ri and r for the benefit of the null primitive is not repeated when the eq primitive the parameters generalizing from this example we can see that a large class of coroutine applications can be subsumed by this technique a producer coroutine becomes a function that produces a long possibly infinite list and a consumer coroutine becomes the receiver of such a list also notions such as streams and the dynamic lists of pop are subsumed the purpose of these programming constructs is to allow one to describe a sequence of values with a single subprogram yet have them computed on a basis this assumption is built into a lazy evaluator at the most basic level so there is no need to call for it explicitly one the other hand one might ask how to force a more conventional evaluation to occur suppose one to cause the evaluation of fs to proceed computing the s before invoking f one could say instead of fs where if then fs else dont care and if atoms then true else if then else dont care the function finite simply the complete forcing every part of it to be evaluated if it ever terminates force invokes the function on the argument example prime numbers due to p produces a new list from i by removing all of x produces a new list from i by removing any element which is a multiple of a predecessor if xo then else ri then is the infinite list of prime numbers ii a lazy evaluator for lisp in this section we shall describe a language and its implementation in order to the notion of lazy evaluation lisp is a variant of lisp which remains true to the principles of the calculus specifically binding is the only possibility the syntax of expressions in this language is as follows expression variable i quote atom i cons expression expression i car expression i cdr expression i atom expression i eq expression expression i if expression expression expression i expression expression i lambda variable expression i label variable expression i expression empty i variable expression atom any string of letters variable any atom except cons car cdr atom eq if lambda quote label or the variations from the syntax of lisp are the replacement of cond by if the restriction of quote to atoms the restriction of functions to one argument and the of the construct from an internal device the first three restrictions are and the phrase is an extension intuitively el x e y e means el where x e and y e it will greatly simplify the discussion if we assume that the computer memory is of a very if sort each cell is capable of holding any of the forms listed as expressions where addresses are used for any component of type expression in other words if etc are addresses and etc are variables a single memory cell is capable of holding and among items like ¢ cons lambda ao and r ¢ ¢ naturally any real implementation would represent such memory cells with linked lists but the extra pointers would only this discussion the state of a computation is described by a partial memory function g which has the following consistency property if a particular address r occurs as a component anywhere in the memory ie in s range then is defined thus the addresses for which is undefined are the free cells and no cell points at a free one a computation is started by loading the memory with the expression in the obvious way performing transformations for a while and then examining the root cell of the expression as the first step in describing the lazy evaluator we describe a set of reduction rules which transform the memory to produce a new memory each rule changes just a few cells to describe such an function we introduce some notation e u if t then e else in other words the new function differs from the old at just one argument where its value has become e furthermore g et in other words the rightmost pair represents the last change to the memory there are transformation rules c g car and r l cons r o in programming terms the contents of are copied into when convenient we shall with mention of extra references by that ptr car cons implicitly asserts the existence of a t for which the above is true the rule for cdr is similar p cdr cons kt t a a z quote f t o r quote nil ie is simply the property of being e a tt a t h e n q u o t e nil i tn if q u o t e t r n t n l n o pn if q u o t e nil n n t n o thus if is just an alternate form of the usual g n lambda hi n z f u n a r g n i n r the following rule creates a circular structure l given pn label o o the following rule is a sort of incremental substitution operation which allows expressions to down through the memory when the specific list of pairs in a expression is not relevant we use to denote it i f a o f u n a r g n n l n and i for some l i n choose the smallest i i b pro f u n a r g quote a p quote a n c n n t n o l f u n a r g t l f u n a r g n where wl and n are distinct free cells in p d if a is one of cons car cdr atom eq or if then no f u n a r g a n l m p pa n n n i hi f u n a r g n m where hi l are distinct free cells in p rules fc and fd are the only ones which use additional storage although it appears here that the list of pairs is being duplicated in a real implementation which represents a single cell with multiple linked cells it would not be only a pointer to the list would be duplicated notice that rule f does not tell what to do when a lambda or label construct is encountered the following rules give an answer for some cases the first one shows how variables are bound to values in lists and the second shows how recursion is implemented p u what can be said of these rules the reader may whether they work for example one of the authors morris thought that rule g might from the usual capture of free variables problem and was to find it was not the case this issue is taken up in the next section we shall continue with the description of the evaluator note that at most one rule can be applicable to any particular location so the only choices left open to an evaluator are where to perform the next reduction and when to halt the procedure for a lazy evaluator is defined recursively as follows n is the location to be reduced t is the m e m o r y eval returns a new memory if pn quote a then return p if p n cons then return p if p n f u n a r g lambda then return ch if n car then let if l n cons i then let return r else there is an error car applied to c if bn cdr n then let if p l n cons it l then let p return i n else there is an error cdr applied to a atom n then let it ln quote a then return l quote t hi if l n cons then return nil n else there is an error e i f u u eq t then let pl if al a quote then if aj a then return t an else return nil u else there is an error l if if o l then let t i if quote t then let return p if o quote nil then let t return else there is an error fa if ptr f u n a r g n n and then if i is the smallest such that i then let return ir else there is no such i and there is an variable error fb if f u n a r g quote a then return p quote a r · l if r label o then return e v a i r f u n a r g r t rt fc if p f u n a r g or l apply rule fc to return eval fd if r f u n a r g a n then apply rule fd to return g if r rl then let lambda then apply rule g to location r to get return eval else there is an error else there is an error the most subtle aspect of this algorithm about rules c i and fa for example in c the first c o m p o n e n t of the pair is evaluated in before being copied into r this policy the number of paths through the data structure which see the change a conventional evaluator differs from a lazy evaluator in that the parameters of cons are evaluated as soon as they are encountered and the actual parameter of a function call are evaluated before they are bound in terms of the definition of eval this means that the second case is changed to if l qr return t · and the case g is changed to if i then let if o lambda then apply rule g to location i and to get return else there is an error these two changes make certain other invocations of eval unnecessary specifically the case c becomes if car then let i if z cons then return else there is an error car applied to case c changes analogously and case fa becomes i f f u n a r g o n n and o then if i is the smallest such that o i then i else there is no such i and there is an variable error all the other cases remain the same we believe that the lazy evaluator never performs more reduction steps than the conventional one but shall not attempt to prove it here example to illustrate the lazy evaluator we shall perform a full evaluation of the expression from example to get things started it is necessary to embed the expression to be evaluated in a expression with all empty also we shall assume that plus is a primitive operator with the same general characteristics as eq and that are understood to be atoms not all addresses are explicit each pair of parentheses indicates the presence of an address lambda ints label integers lambda i cons plus i apply fc to ct a lambda ints n label integers lambda i cons plus i apply g to a a ints n apply fd to a a car y cdr ints n stack a apply fd to y cdr f u n a r g ints ints stack fc to t o e f u n a r g ints ints fl f u n a r g i n t e g e r s stack e apply l to b f u n a r g lambda i cons plus i i integers return to apply fa e f u n a r g i cons i i integers fl return to apply g i f u n a r g cons i li fl apply fd to cons i i integers fl integers plus i i integers return to t to note cdr stack t again apply fc to r s t integers i integers s plus i i integers stack o apply fa to t t lambda i cons integers plus i integers return to apply g cons integers plus i is integers apply fd to n cons x x i i integers h integers plus i i s integers fl return to t apply c t cons h return to a to note car stack a again stack x apply fd to s s plus i i rp i n t e g e r s fl v f u n a r g i i n t e g e r s fl stack s stack apply fb to return to apply fa to return to s to note plus stack s apply fb to v v return to s apply p s return to x apply fa k return to a apply c a semantic considerations there are several questions one might ask about the transformation rules and evaluator is the final answer independent of the order in which the rules are applied ie does the system have the churchrosser property are there enough rules to allow an answer to be computed in all cases we consider legal is the evaluator complete in the sense that will compute an answer whenever any application of the rules will do so is the evaluator optimal in the sense that it performs the minimum needed steps to compute an answer we believe that the answer to the first three is yes and know that the fourth is not true however they are not very meaningful questions unless we have an independent definition of what an answer is to get one we shall first define the meaning of an expression in terms of semantics and then define an answer as a certain finite amount of information about that meaning an analogous approach for arithmetic would be as follows given the class of arithmetic expressions involving and no variables eg consider the domain of integers ie define a s e m a n t i c f u n c t i o n v m a p p i n g expressions into domain elements v and v in this case the definition of an answer is obvious any computer should reduce its input expression to the possibly signed which has the same value as the original expression the central idea is that the computer does not find the value for the expression but only reduces the input to a more form which has the same value when as in the case of arithmetic there is a unique finitely representable canonical form for any value the distinction between a value and the output expression is not interesting on the other hand here we are dealing with values that can be infinite list structures and functions so the distinction between a value and an answer is real the definition of a semantics for the h calculus has already been carried out by and others see our approach follows but extends it somewhat to introduce the notion of a semantic memory this approach allows us more easily to make the connection between the semantics and the evaluator in particular it allows us to deal with the sharing and sometimes circular data structures more directly the domains a the primitive d o m a i n o f atoms etc d e n o t e atoms c the primitive domain of variables denotes a variable there is no reason why atoms cannot be used as variables but things seem if they are kept distinct r the primitive domain of references addresses it denotes a reference e c a r r r the domain of expressions corresponding to the possibilities listed in section ii in other words car is a m e m b e r o f the fourth part of the disjoint union e denotes an expression m r e the domain of memories each cell of which is capable of holding an expression denotes a memory v a v x v v v the domain of values a value can be an atom a pair of values or a function from a value to a value this domain is the one which requires theory as it contains its own function space furthermore we use version of the disjoint u n i o n operator so that l q u o t e l cons l l and l a m b d a x l all have distinct values with l being the bottom of the whole lattice n c v the domain of environments p denotes an environment s r n v a semantic memory mapping references and environments into values o denotes a semantic memory a semantic memory has addresses just like a conventional one but its cells can hold infinite objects roughly speaking the semantic object that a cell w holds is what one gets by tracing out in the conventional memory the structure of pointers from that cell tile semantic function v in the following to reduce parentheses we shall adopt the convention that means f is applied to a the result is applied to fl etc v maps conventional memories into semantic it is defined recursively by where if e e c then p else if e quote a then a if cons t then ap else if c car then else if cdr then else if atom then if ap e a then t else if c v x v then nil else l else i f e e q t t then if e a a ap e a then if a l p ap then t else nil else l else then if art p t then else if art p nil then else l else if e then else if e lambda then x x else if label t then y hx x else if f u n a r g w i n n then a p l else this definition depends upon several informal semantic operations f o r m s pairs a subscript selects the most are the last four the application of ap to is the function application which required construction to justify since both values in the same domain note that the h is also an informal notion and that the bracket notation is used to define the changed environment p x y is the minimal fixed point operator it happens that mapping a construction into its semantics involves a complete reversal of the list of bindings i it is to compare this function with the eval function of section ii the major difference is that v is quite to deal with completed infinite objects like functions the operation of applying a function to its argument is taken as primitive here while it was done very and by eval this particular way of describing the function the application of the memory function to a single place namely the tw in vs definition u uses only the semantic memory now given the definition of eval it should be clear what an answer is suppose we load the memory with an expression so that the root of the expression occurs in w and we start the lazy evaluator on that location if it ever halts ignoring the possibility of error stops we know that w will contain an expression with one of the three f o r m s quote a cons or thus the answer tells which of the three components of v the value lies in and if it is an atom what atom it is in the other cases nothing more is or computed this fact indicates how we should define the correctness of an evaluator if l then does not halt if a then quote a if is a pair then if is a function then we use the empty environment l in these statements because it is assumed that the expression to be reduced does not contain free variables at the outermost level therefore an environment function is not needed initially soundness for the present we shall content ourselves with a partial correctness that the last three clauses hold if eval halts this can be done by showing that each of the transformation rules leaves the semantic memory unchanged except at newly allocated cells then if the evaluator starts with memory t at location and halts with memory we know that and the last three causes are immediate since the eval function halts only on the three forms in question this method of proof also proves a qualified yes to the first question in this section it doesnt matter in what order the transformations are the argument goes as follows on semantic we know that quote a cons and all denote distinct objects and that atoms that look different are different if we then show that the transformations cannot change the semantic value in a cell we know that all sequences of transformations which produces one of those configurations in a cell must produce the same one the proofs for the various rules are very similar we shall give two rule c suppose tn car wl and cons w w and rule c is applied we shall prove that vt v where t t w first we define the of v by vi l for i so v i vi now a straightforward computation shows that w p i f ww then w wp else r then w tp else ww then p else and if w then p else now it is easy to show that c i and vice versa thus i rule l here the proof is somewhat d i f f e r e n t since it involves comparing a circular data structure with a minimal fixedpoint suppose n o f u n a r g label t n wn and ic f u n a r o wi w n first we claim without proof that v and v are the minimal solutions to the following equations respectively v if then x else u vp vg if ww then else it is simple to show that v satisfies the equation for vt so v c vt the proof in the other direction is more difficult the difficulty seems to be that v involves a loop represented by the y within a loop represented by the definition o f v while vt involves just one loop to overcome this problem we will cut the loop represented by y at the same time we cut the loop represented by v first we claim based on continuity that the following equations are equivalent to the ones above for defining vt l for i if then x else yi l for i yi h f f y i l f v i vi now we prove c vt by induction on i it is true for i so assume it for all ki then by the induction hypothesis i c if then else where f hx x the proof will be complete if we can show c this fact can also be shown by and induction on i assume the result for all c by the induction y iv remarks the two objectives presented at the beginning of the paper can now be g ve more first the general question of when an evaluation step is necessary needs to be initially some external consideration must indicate that a particular locations value must be eg the user would like that value to be then the need to be propagates itself to the descendants of that location according to rules to the semantics of the language these rules were straightforward for the language studied here sometimes they are less so for example changing the semantics of if so that if p x x x even when p is undefined would require evaluation of all three parts of an if clause in any case it appears that performing outermost reductions ie those to the initial source of the need is a good heuristic the reason is that these reductions may make some parts of the structure which are away unnecessary second the notion of same step needs here all that has been achieved through the use of pointers is that the advantages of evaluating an expression earlier have been ii tc twice in an evaluation from entirely different places there is no simple way to avoid its finally a comment on the of semantics we can claim that the lazy evaluator is right because it is correct with respect to the semantics defined in section ii it is obvious that the semantics can be to fit any mechanical evaluation method one chooses one the other hand the use of a semantic model is a great aid in studying the implications of various evaluation rules without involved in too many details section ill of this paper was primarily the work of the second author with significant help from of xerox references and combinatory logic vol north holland et al behavioral semantics of non recursive control structures proceedings la springerverlag lecture notes in computer science no reynolds j r notes on a approach to the theory of computation lecture notes scott d and c toward a mathematical semantics for computer languages proc of the symposium on computers and automata institute of and oxford university computing laboratory j the approach to the mathematical semantics of programming languages course notes at mit project mac j correct and optimal implementations of recursion in a simple programming language journal of computer and system sciences vol no december christopher semantics and of the lambdacalculus phd thesis oxford 