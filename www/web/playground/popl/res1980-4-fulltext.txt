an overview of the programming language paul the abstract the language is intended for the solution of problems in text processing and string manipulation the language consists of a small kernel which supports success directed evaluation control structures recovery caches and a data abstraction mechanism it is shown how this kernel can be extended to support simultaneous pattern matching in arbitrary domains introduction the language has been designed for the solution of problems in text pro and string manipulation consists of a relatively small kernel which has been extended in several directions the kernel supports integers reals strings classes files procedure and operator definitions evaluation control structures recovery caches permission to copy without fee all or part of © or i acm and has been extended arrays sequences tables associative pattern matching string synthesis with of values memories pattern matching has been completely with the expres sion evaluation mechanism it will be shown that the operations in the kernel are sufficient to allow generalization of pat matching in two directions simultaneous pattern matches which mutually affect er can be pattern matching needs no longer to the string domain be res an attempt is made to describe most novel features of and their inclusion in the language a version of the pattern matching sion is discussed in some detail sections are included on related work and issues structures evaluation and control the expression evaluation mechanism of is somewhat and needs attention expressions consist of a or string of operators concatenation like addition ii and operands like the numeric constant the string constant the identifier x or the procedure call some operations can only a value but others can potentially fail if an expres sion fails the evaluation of the expres sion in which that operation occurs is aborted immediately and failure is sig to the construct in which the fail ing expression occurs such a failure is a entity and must be captured at the moment it occurs three cases arise a the syntactically enclosing construct is capable of handling the failure itself this is the case if the failing expres sion e occurs in contexts like then else while e do od e logical fi or operator b the syntactically enclosing construct is not capable of handling the failure it self but is perhaps dynamically en closed in a construct with that ity like e logical value and operator from a procedure in this caller failing way failure can be passed to of the procedure in which expression occurs see below the the c neither of the above two cases applies this results in program termi with the error message ed failure in x the call to the read procedure may fail on end of file this failure will not be detected by the program itself and hence execution of the program will be aborted this expression evaluation scheme was designed to be concise and powerful but at the same time an attempt was made to pro the programmer against or failure is obtained by computing a value signal in the same expression for example in two ways and a failure this al while line do od instead of while not do line if od then fi second by the source of failure and attention on the absence of failure the evaluation of ie success the expression during er if then error bad fi i i input expected where expected has the expected input string as value three sources of failure can be identified here the two read opera tions and the inequality test the pro however is in most cases only in in the fact that the input file does not to his the above formulation makes this more clear than l if then error bad input else l if i ll then error bad input fi fi i i l expected in principle directions this argument since the source works in of failure two may be lost the programmer may be about the actual source of failure it is our experience that this happens and in all cases where the distinction it can be expressed easily protection is achieved by failure this turns out to be a source of runtime errors which always corresponds to or im possible failure conditions a direct consequence of this protection scheme is that one can write assertions ie expres sions which should never fail in a pro gram a runtime error occurs if such an assertion is violated another consequence of this evaluation mechanism is its ability to let a procedure report failure which called it indirectly to any procedure this effect is obtained by to the programming convention that procedures have the form el en if one of the expressions ei fails this failure is passed to the caller of the current procedure if that calling procedure has the same form it will not handle the failure itself but will pass it lowlevel failure on to its caller procedures need not at all and highlevel in this way be aware of procedures can detect the failure and take appropriate measures some programming languages have special facilities for handling exceptions of this kind in they can be handled by the standard expression evaluation mechanism recovery caches for the solution of problems such as parsing languages with contextsensitive or grammars and heuristic searching it is often necessary to attempt a tial solution and to the effects of that attempt if it is not successful many schemes have been proposed for the formula tion of such backtracking algorithms but most involve either opaque control struc tures or provide control over modifications of the program ment ie global variables the recovery cache which was to increase software ity has been adapted to act as a device for monitoring environment modifications in situations recovery caches are used both at the conceptual and at the level a cache consists of name value pairs the name part may refer to simple variables array elements and class components see section when backtracking may be necessary a new cache is created and from that moment on all assignments to variables and inputoutput operations are whenever an assignment is about to be made to a variable whose name does not yet occur in the cache its name and value before the assignment are entered in the cache modifications of inputoutput streams are successful similarly and no if backtracking the attempt is is the information in the cache is dis but in case of failure the tion in the cache is used to restore the environment to the state as it was at the moment that the cache was created since recovery caches may be nested may mean merging the information in the current cache with that in the previous cache in this manner the information in the previous cache is still sufficient to describe all modifications which were made since that cache was created there are two exceptions to these rules inputoutput operations inputoutput stream in many situations it recover these streams on the standard are not is not desired to and in some cases the meaning of such a recovery may be or in these streams can be used to control and monitor the backtracking process in the local variables of the procedure in which the cache was created are not in this way information about the reason of failure can the failure itself at caches the programming are introduced language by the construct level try el e en until ed in a first equivalent approximation to this expression is el eo i i before the evaluation of e ch ei ed starts a new cache is created if the evaluation of this subexpression succeeds the cache is discarded and the whole ex succeeds if the evaluation fails the environment is from the cache and evaluation of is at in the same manner the whole ex fails if none of the sions succeeds completely automatic back tracking is achieved by nested try con this simple scheme is very well suited for the formulation of problems oc in pattern matching as will be seen in section procedures operators and classes the remaining features of the kernel are now summarized procedures have a fixed number of parameters which are passed by value procedures may either fail or return zero or more values hence it is possible to return more then one result value an operator is defined by associating a userdefined operator symbol with a pro with one or two parameters classes structuring tion of the declaration are the only available data mechanism and are a class a class consists of a class name and formal parameters class name is used as name for the tion procedure for objects belonging this class the formal parameters used to provide initial values for object the to are that fields which are either used to store information related to the object eg the real and parts of a com number class object or tion local to the class object the stack pointer in a stack class ob fetch and store access to fields can be controlled completely by fetch and store procedures with each field access procedures the operations objects of this and operators defining that can be performed on class the components of a class are accessed by means of the dot notation the operators which are defined in a class can be used in infix notation the type of the left operand of an operator is used to overloaded operators ie operators which are defined in more than one class one final concept must be introduced before we can turn our attention to some pattern matching advantages of applications one of the string pattern matching languages is that they programmers from the to repeat a current sub string and cursor position in each pattern matching operation in an attempt is made to provide such a facility in general in sequences of the form a sx b sy c the prefix uses s could the construct be out with s do begin end for this purpose that occur inside notation the example all begin with would field references end are au in this read with begin s do a x b y c z end but this is not sufficient for the tions we have in mind where it is not that many procedures operate on the same class object this is illustrated by a set of parsing procedures that operate on one subject string the pascal approach has the that this common class object must be passed as argument to all or must be assigned to a global variable and that all procedure bodies must be by a with construct this problem can be as fol the construct scan s for e declares a completely new variable each time the construct is encountered at run time and assigns the class object s to that new variable all occurrences of fields from the class to which s belongs are now with this new global variable in the same way as is done i n pascal the san construct is more general since it af all expressions and procedures which can be evaluated directly or indirectly from the body of the scan construct in pascal this effect is restricted to the ex which are statically inspired by the scan s using construct in e in the body of the with construct if the scan construct is used in a nested fashion then the previous value of the new global variable is saved and properly on exit from the current scan construct this also applies to the case that the scan con struct is left by means of a return statement a pattern matching extension string pattern matching now we will show how a string pattern matching system can be build on top of the kernel pattern matching is done on a string subject which is indexed by an in cursor for the sake of this sion a very simple system will be defined which only supports the following three functions recognize the string s if s occurs as substring in the subject at the current cursor position then s as value and move the cursor beyond s otherwise report failure breaks recognize a string of characters not occurring in s followed by one ter character which does occur in s if such a string can be found start ing at the current cursor position then that string the ter character as value and move the cursor to the terminating character otherwise report failure recognize a nonempty string of characters all of which must occur in s if such a string occurs as substring in the subject at the current cursor tion then that string as value and move the cursor beyond it other report failure span is added to allow more interesting examples its im will not be shown here the following this pattern class definition implements class begin var cursor subject proc if cursor sizes s then else cursor cursor returns fi s ze subject failure return sizes i s proc breaks var cursor result for do in cursor for c in s do if c subject then result cursor fi od od proc similar to break end class scan string the following starting recognized example with illustrates the letter how can be proc var t i in all examples we assume that letter and have appropriate values note that the normal logical operators and tion hence there l are used for be no backtracking reversal of effects or this concise example form if can be written we use the scan in a more construct proc s scan for i lit a final example may illustrate the use of the value by the pattern matching procedures the problem is to ex all letters from a given string for example abc gives abc proc var result scan for while result result i i do empty statement od in pattern matching and back tracking have been separated completely it as a e that the of pattern matching problems we had previously solved means of implicit backtracking could be solved without backtracking at all this suggests that the close interaction between pattern matching and backtracking as can be found in many languages should be now we will address the question how pattern matching with automatic ing can be obtained consider the expres sion lit ab i in the pattern developed above the alternative is discarded as soon as a subject string starting with ah is encountered the string abc can not be recognized in this way but if we rewrite this expression as try until then the recovery cache mechanism the initial cursor value automatically and tries the second alternative if fails no special attention needs to be given to the cursor it is an ordinary variable which is saved and by the recovery cache mechanism generalized pattern matching in most pattern matching systems there is only one subject string involved in the pattern match this restriction can be re moved without introducing any new concepts as an example will show the following rather artificial problem is to ensure that two strings s and s to the following rules a s is of the form cn where ci is a perhaps empty sequence of characters other than the ter some examples are ab a and r b for a given s s has the form dn and either di ci or di reverse holds acceptable values for s with s equal to are and the following program performs this check s s s scan sl for while c break lit do if not scan s for lit c i lit reverse c then s fi od if i sizes then fails fi each object maintains its own cursor note how the cursor value of s each evaluation of the inner most scan construct this allows the in pattern match to continue where it left of the previous time from the preceding it will be clear that pattern matching as presented here does not depend on the fact that strings are used as the basic unit of recognition one can for example easily imagine pattern matching in an array of strings the cursor must then be re placed by a pair of values to maintain the current position and basic scanning pro like and must be defined it may be expected that a system for the tion of two dimensional like can be defined in a straight forward manner using the primitives from the kernel implementation an implementation of is com and runs under the unix ing system this tion consists of a two pass compiler ten in which transforms source pro grams into a rather abstract machine code this abstract machine code is then executed by an interpreter written in c extensive facilities are provided for program profiling and sym debugging related work is the successor of a language which had the same design goals but the simplicity and generality achieved in both languages were inspired by and from ideas in snobol and sl was also by we had already for several ideas for the integration of pattern matching and expression tion but the solution finally adopted in was by there are important differences most pattern too for matching example in procedures integer values corresponding to the position to which they can move the cursor next the cursor has to be moved explicitly this operation the substring between successive cursor positions as value in all pattern matching pro the recognized substring as value cursor and move the needs cursor ever in this way be manipulated the by the programmer the pattern matching model in is more general since it allows simultaneous pattern matches and pattern unix is a of bell matching in domains other than strings the evaluation model which un detected failure the use of recovery caches and the separation of pattern match ing and backtracking are new design realized and implementation in close of were with references oj b k r information common base computing centre s re ip the snobol program ming language second edition nj re dr an overview of the sl programming language sl project document the university of october re dr reference manual for the program ming language tr the university of br dm the c programming prenticehall p pattern matching in van jc cd col mc for software proceedings i system structure fault of an international in conference on reliable software sig plan notices dm k the unix system of the acm shapiro lg a language for the generation recognition and manipulation of line thesis tr university of 