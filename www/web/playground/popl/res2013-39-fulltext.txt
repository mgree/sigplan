synthesis of models from mutation experiments ali pu university of california berkeley microsoft research cambridge university of abstract executable presents new challenges to formal methods this paper addresses two problems that cell face when developing formally models first we show how to automatically synthesize a concurrent model for cell development given experiments of how particular influence the experiment outcome the problem of synthesis under is unique because may produce nondeterministic outcomes by introducing races between in the cells and the synthesized model must be able to all these outcomes in order to describe the modeled processes in contrast a regular concurrent program is correct if it any outcome allowed by the nondeterministic specification we developed synthesis algorithms and synthesized a model of cell determination of the c a version of this model previously took systems to develop second we address the problem of specifications that arise due to incomplete sets of mutation experiments specifications give rise to distinct models each the same differently addressing the ambiguity of specifications corresponds to analyzing the space of models we develop algorithms for detecting ambiguity in specifications ie whether there exist alternative models that would produce different on some experiment and for removing redundancy from specifications ie computing minimal specifications additionally we develop a modeling language and embed it into scala we describe how this language design and embedding allows us to build an efficient synthesizer for our c case study we infer two observationally equivalent models expressing different hypotheses through different interactions one of these hypotheses was previously unknown to this work was supported in part by nsf grant to the computing research association for the project and by nsf grant permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm categories and subject descriptors f logics and meaning of programs specifying and verifying and reasoning about programs keywords program synthesis specification ambiguity analysis executable introduction can be caused by and networks for example x may be related to the levels of p and r and p may r once the level of p is high levels of r may cause x to avoid the we may want to increase the level of p one way to infer networks is to carry out mutation experiments in which cells are modified to or the activity of a certain leading the cell to exhibit behavior such as cell if by the activity of p the resulting can be attributed to say an increased activity of a known r we can infer from this mutation experiment that p r from many such experimental deduce networks that describe the events leading to specific cell and other behaviors experimental are concerned about the correctness of their models that give a dynamic explanation of how the observed outcomes are produced executable addresses this concern by building executable models that can be verified against performed experiments treating cells as concurrent agents models the fact that cells do not at synchronous verification ensures that a concurrent model is correct for all variations of cell growth by exploring all possible executions of the model unfortunately informal maps of networks common in literature into executable models is because it involves explicitly defining timing delay and strength of how multiple each other in our previous work some of us developed a model of cell specification ie how cells make the decision to develop into a particular cell type in the c this model correctly an unknown interaction however it took several to the details of the model before it was verified against the experimental data whenever new experiments are added or when the model is extended with new components similar are required this paper techniques for synthesizing executable models from experimental observations and prior knowledge two challenges make this synthesis problem interesting first the outcomes of some systems such as of cells are nondeterministic for example in the c system that we study some cause the six observed pre cursor cells to acquire one of two alternative due to races in the communication among cells the desired executable model must be able to all the observed behavior in order to be correct we synthesize concurrent cell models such that for each observable outcome there exists a schedule that leads the model to produce the outcome this requirement makes our synthesis task a new problem which is more complex than what has been previously addressed second the incomplete set of mutation experiments forms only a partial specification because only certain are from the total combinatorial set of possible we cannot be certain that an executable model that verifies against these whether it is synthesized or manually constructed is the explanation of the process this is because there could exist an alternative model that is observationally identical on the current specification but observationally distinct on an additional mutation finding such an additional mutation would ambiguity in the current specification to that we have synthesized a unique model we go beyond synthesis and develop methods for the analysis of the space of models ie models that agree with the specification if observationally distinct models exist we suggest a new mutation that them if no alternative models exist we determine the smallest set of experiments that is sufficient to arrive at the unique model finding such a minimal set is interesting because should decide to the experiments for validation they only need to perform the experiments that suffice to synthesize a unique model finally it is interesting to ask whether there are observationally identical but internally different models such models present networks where the network function is implemented via different interactions these models cannot be distinguished by observing we must say with similar to tracing the program and observe the cell during its development this is a harder experiment but the cost of instrumentation is reduced with the help of formal methods as we can identify which to mark given the internal differences between the observationally identical models we have built an efficient verifier synthesizer and specification ambiguity analyzer that implements algorithms for the analyses described above our synthesizer takes as input the the results observed under and a template structure of the cells and from them it generates a verified model the template of the cell defines the cell components and a superset of their activation allowing to formally state existing knowledge on the system being modeled additionally the of the levels for each component is set a priori what we synthesize is the internal logic and timing of the components ie how their changes in terms of their incoming signals and we therefore the most difficult task of systems modeling to a computation search engine this paper makes the following contributions we designed a domainspecific language for expressing our models using an execution model with restricted called bounded we embed into the scala programming language and build a lightweight synthesizer which is available we describe how to translate programs into formulas in order to solve synthesis and specification analysis problems sections and we formulate the verification problem section and the program synthesis problem section we observe that unlike previous synthesis tasks eg concurrent synthesis or synthesis from examples or invariants which are expressed as formulas with two levels of quantification this problem is expressed as a formula with three levels of quantification which makes it a new kind of problem we develop efficient algorithms for solving this problem that reduce to three communicating sat solvers we develop methods for analyzing the specifications and the space of models section we describe algorithms for determining whether internally or models exist and for finding minimal specifications these algorithms build on our synthesis procedure and can potentially guide new experiments by computing mutation experiments that alternative models we evaluate our framework by describing that it efficiently generates valid models for the c the model a bug in previous modeling an incorrect modeling of a components behavior when it is shows that no distinct models exist even after extending the experiment space to consider for each component in the but two internally different models were synthesized one of which expresses a previously unknown hypothesis and the specification from mutation experiments to a minimal set of four experiments section technical overview this section presents an overview of the program synthesis and specification analysis methods we have developed for modeling systems we describe how typically mutation experiments to infer informal networks discuss how these models can be formalized present our programming language for expressing verifying and synthesizing formal models and outline our synthesis and specification analysis algorithms for programs in this language background on mutation experiments here we give a brief background on mutation experiments in the context of systems the role of these experiments is to understand networks in particular those that control cell these networks are of interest in part because their failure may trigger is a of failure of of growth in order for a normal cell to transform into a cell the which cell growth and must be hence to understand one needs to understand cell there are two common mechanisms for cell a single cell into cells of different types based on the asymmetric of inside the cell and multiple identical cells by mutually communicating with the goal of at we focus on the second mechanism and aim to explain cell by modeling communication the specific goal of is to infer the program that cells execute to agree on their this program executes within one cell division cycle during which a cell its potentially by communicating with other cells one method for inferring this program is to a set of in the cell and observe the resulting changes in the cell development these experiments are particularly because changes resulting from the cell taking a different are observable avoiding the need for the more expensive tracing of temporal levels by the means of tagging cell with from mutation experiments infer interactions namely which are or by the for example et al infers in this of lst lst lst or as well as caused a change namely induction that they function as negative of the due to the change being linked to of the unify such information to create informal models of programs such as the one in figure from this model shows how five cell ac three cells as well as the to determine the of the each contains the same set of components which is composed of let and lin and lst sem let and the edges between these components show the activation vs relationships between them figure an informal diagram of cell specification in a system of three cells these cells to the inductive signal is from the cell and communicate among themselves using the signal ls to decide one of three while these informal models may capture all known interactions among cell components they do not describe the dynamics of the cell such as what race conditions permit the cells to take nondeterministic that have been observed under some due to this lack of dynamic information one cannot be certain that these diagrams accurately describe the cell specification mechanism executable the goal of executable is to create executable models that allow the observation of the dynamic behavior of systems furthermore these models are verified against experimental observations for concurrent discrete models verification say with model checking ensures that all executions of the model agree with the observed outcomes by verifying the program under the nondeterministic interleaving of cell steps we ensure that a program is a faithful model of a cell system where cells may progress at varying another way to model varying cell is to use in stochastic models this nondeterminism takes the form of mod it is challenging to create concurrent models of communication between cells to transform the informal model in figure into an executable model the designer must model levels timing delay or at which with other components and how a behaves when both an and an of the are active we have previously developed a verified model of c cells that model took several to develop this paper methods for automatically synthesizing executable models of concurrent systems nondeterministic experiment outcomes a mutation experiment may produce different outcomes when run repeatedly a correct model must all nondeterministic outcomes of a given mutation experiment we synthesize concurrent cell models that satisfy this requirement by ensuring that each outcome that must be observed is by the model under some interleaving of cell steps for reasons we use a restricted model of concurrency bounded because cells always advance at relatively similar rather than at arbitrary fully asynchronous models are too to the observation in certain mutation experiments is one way to achieve restricted ensuring that between two execution steps of a cell no other cell can take more than two steps because of the requirement to all possible outcomes model synthesis in this setting is a more complex synthesis task than what has been previously addressed in this paper we advance the in solving this new synthesis problem modeling language we have developed a highlevel programming model inspired by diagrams such as the one in figure introduces programming abstractions for cells cell components and interaction between components programs in figure are composed of cells which execute according to a schedule s that to the constraint the schedule is of bounded length the number of steps in the schedule corresponds to the desired of the cell division cycle multiple cells can take simultaneous steps cells are composed of components which model or cell components communicate with other components in the same cell or in other cells communicating components are connected with directed edges which correspond either to activation or relationships components of a cell execute all take one step when the cell is scheduled components have modeled at levels when the component executes it updates its next state based on its current state and the states of its or each component is modeled with an update function l lk l where l are levels and k is the number of components and combined thanks to these abstractions programs are syntactically smaller compared to models expressed in the reactive modules language which was the modeling language used in earlier work as a result we are able to develop efficient synthesis algorithms for programs in example to illustrate we consider the problem of designing a simple distributed protocol in this setting correspond to making probabilistic transitions for of level change in nature however moving nondeterminism from modeling into the scheduler allows models to be deterministic which in turn enables discrete verification techniques system has cells structure cells has components components have update bounded synchronous execution model sequential figure hierarchical organization of programs in the system is composed of cells which in turn are composed of components at each time step components update their discrete state using an update function in terms of their previous state and incoming signals from other components edges between components denote which components can communicate between them cells group together components that always move and they to a restricted form of concurrency environment effects on the system being designed and the specification consists of inputoutput pairs defining the desired behavior for given environments the goal is to design a weak consensus protocol for a system in a system these nodes would be cells and node components would be in the cells two nodes called n and n are to a signal from a node a base bs when the base sends a signal at least one of the must make a decision to take a measurement when a takes a measurement it sends a release message to the other the other not to take a measurement in order to save its power the decision to make a measurement is made on the basis of the strength from the base in normal conditions the that received the stronger signal should take measurement as it is closer to the base and receiving the release message from the other signal the environment may cause the communication between the two to be down must take a measurement if no signal was received from their peer similar to a system of cells at similar we assume that have bounded ie they run under bounded asynchronous schedules an implementation of this protocol is presented in figure figure a presents a hierarchical view of how cell communication is organized and which components each cell contains on the left is the level with three nodes the base node bs contains one component the base node which a constant high h or low l signal to nodes n and n these nodes decide to commit or to by communicating with each other figure b c and d show a graphical representation of update functions for three components in nodes n and n the remaining simpler update functions have been omitted from the figure language extensions for verification to make programs in our language amenable to verification we now introduce component formalize specifications and define a correctness condition for programs we model cell mutation with an adversary who the cell program such that a set of cell components receive semantics typically a cell component is either to be or to at a high level throughout the execution of the program although we also support other mutation types the set of mutation experiments performed in the lab serve as our correctness specification let f be the set of possible outcomes of a mutation experiment for example if a cell can take one of three the outcomes of an experiment with six cells is a from f let m be the set of possible that one can apply on a cell typically all cells involved in an experiment are the set of experiments exp is a subset of m × f where m f exp if the f has been observed on the mutation m with n cell components and three possible per component eg no mutation high level m is exponential in the number of components of the cell as a result do not carry out all having an incomplete set of experiments implies that we have to accommodate partial specifications while the set of experiments exp is a subset of m × f we assume that once a mutation has been carried out the lab has observed all possible outcomes for this mutation by the experiment a sufficient number of times this is a reasonable assumption for systems that have been studied by many independent such as our case study specification in c section without this assumption we would have no upper bound on the specification as any m f pair could potentially be observed in experiments that have not been performed so far the assumption allows us to synthesize with both positive examples outcomes that must be produced by the model for an experiment and negative ones outcomes that must never be observed for an experiment to model such full knowledge for a single mutation our specification is a partial map e m f the domain of e is the set of performed if m dome f em we assume that mutation m cannot result in f the pair m f is a negative example we say that a program p m f is a correct model of e if for each m dome the execution p m may produce each element of em by controlling some aspect of the execution of p namely the schedule that the concurrent execution of cells in the program correctness condition to define a correctness condition we view an program as a function p m s f where m and f are domains of input configurations and while s is the set of schedules to bounded the explicit schedule allows us to formulate a correctness condition e of a program p on a specification e m f which has two parts scheduling a scheduler cannot make the model produce a that is outside the specification ie m s p m s em angelic scheduling an angelic scheduler must be able to produce each in the specification ie m s p m s f the requirement that the model is an underapproximation of the specification while the angelic requirement that it is an overapproximation angelic scheduling adds a layer of difficulty that is handled through the construction of a novel verifier section example the specification for example expressed as a set of experiments is shown in figure the left column shows the environment effects m while the right column shows the desired outcomes f it is interesting to note that we are using the as the environment adversary the describe situations under which the nodes n and n must operate according to the expected outcomes for example the last row describes the situation in which the signal at n is high while the base base l h base l base l h s s s base o base h b base receiver high or low trigger signal from bs bs hl n n base receiver emit receiver delay base base s s emit base emit base c receiver environment may prevent communication a decision base s s base d delay figure a hierarchical view of node connections and of their components the top node is the base and the bottom nodes are distributed which may not communicate with each other due to environment effects b c d graphical representation of update functions for base receiver receiver and delay components in the distributed each state is labeled with its name and the output value that the state maps to base trigger comm n n y cd dc cc nl nl y cd dc cc nl y cd nl y dc n cc nl nl n cc nl n cc nl n cc figure the specification for the distributed protocol example giving required outcomes for nodes n and n under a range of scenarios of base trigger signals and cases of whether the two nodes can communicate between themselves y or not n c commit d signal at n is low and the communication between nodes is down we can think of this mutation as the adversary the signal to n and preventing the communication between the two nodes the outcome c means that a node has committed to taking a measurement while d means that the measurement was to the peer node language extensions for synthesis in order to allow synthesis of update functions in our programs we extend our language such that these can be left unspecified we describe partial programs in and we define the synthesis problem the input to the synthesizer is the specification e and a partial program p to be completed by the synthesizer if feasible into a program p h such that the predicate h e holds a partial program is a program template in which certain fragments are parameterized and need to be supplied by the synthesizer our language allows of cell component behavior and how components communicate because update functions model timing delay and change of we found them to be the part of the model to produce manually by update functions we can indirectly leave unspecified also the connections between components for example if a is whether a p is by a q or a r both q and r can be connected to p if q turns out not to influence p the synthesizer is able to produce an update function for p that the state of q the parameterized update functions are constrained to agree with the activation and semantics specified in the partial program by restricting their structure this is achieved by stating monotonicity invariants on how a input can influence its these invariants are described in section from the user the partial program p encodes assumptions it defines the components in the cells as well as a superset of connections between them it thus the to model particular and states the knowledge of which superset of pairs of communicate partial programs encoding assumptions form the basis for the ambiguity analysis described in section our synthesis problem is to find update functions h that yield a correct model definition synthesis problem for a partial program p to be completed with hole values h into p h the synthesis problem is to find the update functions h that yield a correct model sh h h h a correct model must all observed experiments and this is captured in the correctness condition which is a formula with two levels of quantification this makes the synthesis problem a problem while typical synthesis problems are of the form hole input formulas with more than one level of quantification cannot be off directly to an smt solver because the of smt solvers is only reliable for existential one quantifier formulas one way to problems is to develop a counterexampleguided inductive synthesis algorithm in the classical algorithm an inductive synthesizer produces a program that is correct on a small sample of inputs a verifier then checks this candidate program on remaining inputs to handle the synthesis problem sh we develop a novel algorithm where an inductive synthesizer with two one for each of the two correctness conditions and collects two kinds of counterexamples one from each verifier section example the update functions for example presented in figures b c and d are produced by our synthesizer these update functions control how these components to signals from the base and the peer the synthesizer takes four seconds to generate these update functions intuitively a protocol is simple if you receive a weak signal wait a little while and wait for the release signal from the other if it does not arrive take a measurement still even for this simple protocol designing the update functions manually is not trivial ambiguity analysis assume that a produces an executable model that verifies against all performed experiments now imagine that after he his conclusions from this model another performs a new mutation experiment whose outcome the model as well as the conclusions drawn from it given a new mutation experiment mn a model p becomes invalid if it cannot an outcome observed for mn or if it produces an outcome that has never been observed after performing mn sufficiently many times naturally we are interested in the question of whether one can the validity of a model in the absence of complete experiments in particular under what assumptions can a model be considered the explanation of we view this question as analysis of ambiguity in the specification e and define an alternative model query that answers the question we first introduce aggregate outcomes and specification ambiguity definition aggregate outcome let p be a model and m a mutation the aggregate outcome of p on m denoted p m is the set of outcomes produced by p with m over the set s of all schedules p m p m s s s a specification e is ambiguous for a partial program p that expresses a set of assumptions if we can find two completions p h and p h that on some new experiment of course one of these models would become invalid given the new experiment definition specification ambiguity given a partial program p a specification e is ambiguous denoted p if m m h h h e h e p h m p h m note that m must be a new experiment ie m m dome because the two models must agree with the specification e on all in dome in section we show that the specification for our case study is unambiguous given provided assumptions ie there is no need for more experiments at the desired level of modeling we also show that removing some important experiments indeed makes the specification ambiguous alternative for coordination between cells definition alternative model query given a partial program p stating assumptions and an existing perhaps previously synthesized model p that need not be an instantiation of p the alternative model query finds a mutation m and a new model p h such that p m p hm or shows that no such h and m exist we develop an algorithm to solve this query in section example we now ask whether we can find alternative models for example using the alternative model query suppose we relaxed the specification and do not care about the outcome on the case n l n l we ask our synthesizer to generate models under this relaxed specification such that they differ from the model in example our synthesizer generates an alternative model that has much simpler behavior as it need not be nondeterministic under the row that we ignored the update functions are shown in figure when we ask for a mutation that distinguishes among the models the synthesizer produces the omitted row note that this last query is a special case of the alternative model query such that both input programs are fully specified now consider an experimental scenario where one wants to validate a set of experiments performed in the literature by performing them again is it possible to identify the smallest set of experiments whose replication is sufficient to yield a specification to answer this question we define a minimization query that computes such a minimal set definition minimization query given a specification e the minimization query computes a minimal specification em from e ie p e em p an algorithm that solves the minimization query is presented in section in our case study we show that under our assumptions p one needs to about of experiments this result suggests that computing which experiments to perform might reduce unnecessary laboratory work example we explored the minimization query for example our synthesizer e down to the first three rows of figure as a unambiguous specification this is somewhat surprising but it gives substantial insight into the problem as the user can now understand that the specification of the four cases with lost communication was redundant while the user may have that it was necessary language in this section we present the formal semantics of our language by first defining the language constructs and then giving operational semantics rules for execution the basic construct in is a component we denote the set of all components in a program by comp components are connected via a set of directed edges defined by the relation edges comp × comp edges model channels of communication between cell components for each component c we say a component c is an input component of c if there is an edge c c edges for each c we define the set of input components as c c c edges a component c has a state c that takes values from a finite domain lc each component c is also associated with an update function denoted fc that updates its state c given the current value of its input components the function fc has domain lc × c lc and range lc the update s s ss ¯ ¯ ss s ¯ ¯ cell cells ¯ ¯ ¯ c ¯ c c ¯ ¯ ¯ ¯ ¯ c c c edges fc figure smallstep semantics for program execution runs a schedule by the cells according to each in the schedule with as the base case rule updates the states of cells depending on the current s if a cell is enabled it is advanced by applying the rule conversely if a cell is the rule keeps its state unchanged rule updates the state of a component by invoking the update function on the states of all input component states and its own state base o l base h s s base h a base receiver emit emit s s b receiver s s base base c delay figure update functions generated using the alternative query model to from the model in example under ambiguous specification obtained by removing row of figure function for a component is chosen from a sequence of functions fc fc that describe possible alternative behaviors of that component under different ie the natural and behaviors of the component a cell is a set of components within a cell we have a synchronous execution model ie all components of a cell update their state simultaneously the state of a cell ¯ is defined as the set of states of the components that the cell contains we denote the set of all cells in a program by cells cells forms a partition on all the components in the program a pair of cells cell cell are said to be communicating if there exists a pair of components comp comp connected by an edge in the respective cells the pair cells edges a program the program state ¯ is the set of all cell states in the program the input to a program is a configuration ie a mutation a configuration is a function from components to integers that expresses for each component c the index of the function in fc that should be used as the update function fc the output of a program is defined as the state of components in the final state reached in an execution partial programs the sequence fc of functions associated with component c need not be specified concretely when at least one component function is not concretely specified we say the program is partial typically users will only concretely specify the behaviors under that would not make sense to for example a typical example in the case is the mutation which the function of the component and it to the off state operational semantics figure shows the smallstep semantic rules for program execution here we assume that the program starts in the initial state and that it has already been by a particular update function for each component according to the input configuration the semantics are defined down the program structure the rule executes the program by moving all cells in with a schedule s the rule captures the intuition that each schedule step s partitions the cells into the sets enabled for which and for which rules and describe how cell states are updated for enabled and cells respectively for the cells the state remains unchanged enabled cells are advanced by applying the rule for each component which corresponds to updating the component state by reading the state of connected neighbors and using the components update function bounded the concurrency notion that our execution model admits is bounded this model represents systems where complete is too strict and complete does not accurately model cells that progress at similar but not identical et al define bounded with schedules consisting of and each consists of a subset of the components this is what we have been calling a schedule up to this point next we block together into a each consists of all components taking k steps split across multiple for example let us consider three nodes and the schedule indicates the first two take a step while the third suppose the second schedule is the then the two together make a in which all nodes take one step and which is therefore bounded schedules over are much more expensive to enumerate than schedules over especially bounded schedules over bounded where each node necessarily moves once can be encoded without loss of information as pairwise happensbefore between connected nodes that is a bounded is an assignment of or to each edge in the node topology the following lemma holds lemma et al a exists if and only if a realizable exists over the node topology here a realizable is one that does not cause an inconsistent ordering of nodes in a cycle we use this result to efficiently encode partial programs as formulas section and restrict schedules to be bounded using allows us to define a compact symbolic encoding of our programs into formulas which would have not been possible with translating programs into formulas we now describe how to translate execution of programs to smt formulas enabling verification and synthesis we first give rewrite rules that construct a formula corresponding to the symbolic execution of a program we then describe additional constraints that encode domain knowledge to be used in synthesis of programs translation of program execution the translation of program execution is parameterized by the following symbolic variables · for each time step t and each pair of connected cells c c we define a channel configuration variable that must hold exactly one of the three values and these variables encode the symbolic schedule for program execution variables and are to be consistent in the following way · for each component c we represent each function fi fc as a lookup table with symbolic values for each value in its domain lc lc entries of the lookup table are represented by the variables that take values in lc · for each component c we represent its mutation symbolically as a variable mc that encodes the index of the function to use technically for it is the sequence of ordered bell numbers or numbers while for bounded it is num edges among fc if mc has value i then the function will be used as the update function of component c · for each component c at each execution step we create a variable tc that takes values in the domain of lc these variables represent the component state symbolically over the execution of the program translation rules for compiling program execution to an smt formula are shown in figure is the toplevel rule for translating the execution of a program unrolling the execution for k steps uses the symbolic values to assert the input states that should be read by each component at a given if a cell cell runs before or at the same time as another cell cell ie the variable between the two cells at a time step has value or the components in cell reads their input states from cell at the previous time step on the other hand if cell runs after cell it reads its input states from the current time step finally asserts that the state of a component is updated in terms of its symbolic mutation input state own state and update function the outermost conjunction over possible update functions for each mutation the inner conjunction possible input value tuples of the update function the symbolic state is updated given symbolic lookup variables for the chosen mutation this translation does not impose any constraints on the parameterized update functions and therefore encodes a very large space of possible update functions to help with the program synthesis task we need to restrict this space this is achieved in section by motivated constraints on the structure of the parameterized update functions domainspecific constraints on update functions the translation in section does not impose restrictions on the structure of the update functions that are left unspecified by the user when modeling systems a hypothesis typically involves stating highlevel invariants about whether a component or another one in this section we describe how the space of update functions is restricted using this highlevel knowledge we first formalize how the highlevel invariants are stated by defining a partial labeling of edges with activation and semantics definition edge labeling given a partial program p the partial function label edges edges in p as either or as a components state expresses its activation level we assume the existence of a total order on its possible states this will allow us to state the properties that restrict the space of update functions definition state ordering let c be a component and lc the set of possible state values for c the state ordering c is a total order on lc using the edge labeling and the state ordering for each component we now define a partial order on the combined input values for a component definition input ordering given a component c with update function fc lc × lc × × lc the partial order c on elements of lc × × is defined as v vn c u un i n c vi ci ui c vi ci ui cells edges t c edges t c edges t c edges t c edges tk tc tc c c cell tc mc i fi fc figure translation rules for symbolic execution of programs intuitively is a partial order on the strength of the input values to a component based on the activation and annotations we now describe two kinds of invariants that restrict the space of possible update functions input monotonicity our first property is motivated by the following observation if there is an edge from component c to component c then an increase in c should not have by itself the effect of decreasing c conversely if c and c are connected through an edge then a decrease in the value of c should not result by itself in the decrease of c i i lc × × v lc i c i i c i state monotonicity the second property that we assert imposes a monotonicity constraint on fc in terms of the value of c this property expresses that for the same input value a greater the activation level of the component cannot be updated to a smaller value i lc × × v v lc v c v i c i we found that constraints that encode these two invariants based on user annotations on component connections is crucial for ensuring that the structure of update functions agree with existing knowledge synthesis and spaces of models in section we described how we translate program execution to formulas in this section we present algorithms that this translation for verification and synthesis as well as specification ambiguity analysis the formula that encodes program execution update functions which are the holes in partial programs schedules and input configurations ie the space for update functions and the space for schedules are typically very large however specifications are typically experiments which are sparse and inherently small of order experiments based on this observation we develop algorithms that for input configurations only in the following we refer to the symbolic output parameter of translating the execution of p with input m and schedule s as p m s and we denote by e the specification given as a partial function from m to f verifying programs the correctness condition presented in section is defined as the properties and are in and respectively as a result the correctness condition is in we verify correctness conditions and separately using a verifier vd that searches for schedules that lead to the violation of the specification and a verifier va that checks whether all nondeterministic outcomes for a given mutation can be reached for some angelic schedule verifying for schedules the formula states that the set em is an upper bound for all observed outcomes of p with input m m dome s s p m s em to check this property we attempt to it by searching for a schedule that produces an outcome for an input in dome the domain of e given the observation that there is a small set of input values in dome we solve this formula by unrolling the existential quantification over this set and by symbolically for a schedule the condition p m s em is expressed by unrolling over values in em which is also a small set we thus solve the formula s p m s f f em if this formula is satisfiable p does not satisfy and we obtain a concrete counterexample m s such that running p on input m and schedule s leads to an if it is unsatisfiable then p is correct with respect to verifying for angelic schedules the angelic condition states that all outcomes in the set that m maps to must be observable ie appear in some execution of p on m m dome f em s p m s f this amounts to searching for an angelic schedule for each f em we reduce the correctness property to an efficiently solvable problem by unrolling values of the domain dome again based on the assumption that this is a small domain to we construct the following query for each m dome and for each f em s p m s f if the above formula is unsatisfiable for some m and f then no angelic schedule can be found for reaching that outcome when running p and m f is a counterexample inputoutput pair that does not hold if the formula is satisfiable for each m dome and for each f em then verification for angelic schedules succeeds verifier counterexample mi si angelic verifier counterexample mi fi m p m s e h · · · ml p ml sl e sp m s f ··· sp mk s fk figure the synthesizer consists of three communicating solvers the two generate two kinds of counterexamples and the synthesizer generates models that satisfy the constraints for all counterexamples a program verifies against the specification e if it verifies against both vd and va synthesizing programs in our language it is possible to define a partial program p that admits freedom in the update functions of its components we now present a synthesis algorithm for finding update functions in p such that the completed program p h is correct with respect to the correctness condition our procedure the two vd and va to check correctness properties and angelic respectively in order to solve the following synthesis problem sh h h h this formula is in due to the quantifier alternation resulting from h being nested within the quantification over h we solve sh by developing a counterexampleguided inductive synthesis algorithm which the problem into two solvers an inductive synthesizer and the verifier vd and one solver the angelic verifier va the inductive synthesizer produces a candidate model that is correct on all counterexamples and sends this model to both if both the model the synthesis successfully terminates if either fails counterexamples are produced refining the correctness constraints placed on the inductive synthesizer making it eventually produce a correct model or conclude that no model exists in the model space described by p the solver architecture is shown in figure precisely the synthesizer maintains two sets of counterexamples ce dome × s and ce dome × f the first set contains pairs of inputs and schedules and is computed with counterexamples given by the verifier for schedules the second one is a subset of the inputoutput specifications and is in turn computed with counterexamples found by the verifier for angelic schedules starting with initial sets ce and ce the synthesizer solves at each step the following formula to find a candidate model h p hm s em s p hm s f mf ce if the above formula is unsatisfiable the partial program cannot be completed ie synthesis fails otherwise the valuation of h defines a candidate model that we attempt to verify using vd and va if at least one of the returns with a counterexample the synthesizer attempts to find a new candidate after updating the sets ce and ce with the counterexamples returned by either verifier if a candidate model is validated by both we obtain the completed program p h that is correct with respect to the specification e for ambiguity analysis given the above procedure for synthesizing programs we are now interested in spaces of possible models in particular we analyze ambiguity of specifications if a specification is we aim to reduce ambiguity by expanding it if on the other hand it is our goal is to reduce the specification size without introducing ambiguity computing aggregate outcome we first give an iterative algorithm to find aggregate outcome set for a given program p and a given input m the aggregate outcome set p m is the set of outcomes of p on m over all schedules we approach the task by first computing the outcome of p on m under an initial schedule s we then the set of observed outcomes obs by searching for a schedule leading the program to produce a previously outcome to find such an outcome we build a formula that states that the new outcome must differ from each value in the obs set inferred so far each step of the algorithm thus attempts to extend obs by solving the following formula s p m s f f obs if this formula is satisfiable we obtain an outcome that we add to the set obs and then attempt to solve the formula with the updated set if it is unsatisfiable we have obtained all outcomes that can be produced by p on input m alternative models to that a given hypothesis is the explanation to a a would like to learn whether there exists another hypothesis that differs from the first on its observable outcome on an experiment but is correct on the known experiments given a program p that expresses the first hypothesis and a partial program p that expresses a space of alternatives for the second we can state this query formally as pm if this query is satisfiable then there is an alternative program ph and a new experiment m such that performing the experiment m will at least one of p and ph we now describe an algorithm to solve this query given the hypothesis that the space of mutation experiments m is small we approach this task by unrolling the existential quantification over m the problem then reduces to synthesizing ph for a given mutation m such that pm can differ from pm in two distinct ways it can either contain an output value not in pm or it can be a strict subset of pm we give one algorithm for each case case a program ph that produces an outcome not seen in pm can be found by the synthesis query described in section with a constraint that there exists a schedule that leads ph to produce an outcome not in pm ie pm we solve the following formula to answer this query h s p m this formula is satisfiable if and only if there exists a completion of program ph that produces an outcome not in p m it is and is handled using the mechanism of a synthesizer communicating with two to perform inductive synthesis described in section case alternatively ph may be found by to synthesize a model that always produces outcomes in a strict subset of pm this is achieved by elements of pm one at a time to see if such a model can be found we do not need consider all subsets of pm as we only state that pm f is only an upper bound of the possible outcomes for input m h s s pm f this formula is satisfiable if and only if there exists a completion of program ph such that its observable outcome set is a strict subset of observable outcomes of p on input m similarly to case we use the scheme of solvers described in section to solve this formula minimization in a context where performing experiments is an expensive process a may want to obtain a minimal specification that sufficiently the space of models to validate a hypothesis given a partial program p that expresses a hypothesis and a specification e that is with respect to p the task of finding a minimal specification em is stated as p e em p we compute a minimal specification em by iteratively restricting the domain of e for the partial program p this can be done by invoking the alternative model query once for each mutation in dome at each step we check whether program p can be completed to a program p h that a set of outputs p hm distinct from em considering as specification the set of currently input values this check is performed using the alternative model query described in section if synthesis fails m is marked as redundant otherwise removing m from the specification leads to ambiguity and as a result m should be kept in the final set of inputs upon considering all inputs in the domain of e a minimal specification is obtained by removing from the domain of e those inputs that are marked as redundant case study c development we attempt to synthesize a model for the cells that start off identical but through coordination among themselves and with the cell ac agree on specific from informal descriptions of interactions found in literature we develop our template vp c the template is shown in figure a derived from figure from the template we observed that there are nodes with extremely behavior these are ls the nodes of the sem let and and the nodes while we can introduce holes in them with expected performance yet not being have a very clear understanding of these nodes and so expect to see a simple and known behavior in them additionally introducing holes in these nodes leaves too much freedom to the synthesizer such that generated models do not have a interpretation therefore we run our tool with unknown update functions for lin let and lst the generated update functions satisfy the specification and template structure of the program on the other hand lin which has a very well understood behavior with the other components to give models that are hard to explain to the therefore we additionally allow the user to specify the behavior of lin concretely and synthesize let and lst let and lst are indeed the most complex functions in their timing delays and have the most complex dependences indeed in our attempts prior to synthesis when designing the verifier to write the model by hand we actually failed additionally the models previously written did not maintain the lin behavior therefore our synthesizer was solving a problem that had been impossible to solve manually even after considerable effort the specification consists of experimental observations of the outcomes of six cells in sequence some of these observation have nondeterministic outcome a fragment of the specification is shown in figure b from the template and these experiments our synthesizer generated update function solutions to let and lst that were by the to be behaviors the output from the synthesizer is shown in figure a it is important to note that this is a very significant previously when we had written down a model for in rm it had the following the previous model did not satisfy a invariant required on the lin component and all efforts to fix the model failed rm is too expressive and therefore there were cases where the model read the future which was hard to interpret the model readability debugging extension and interpretation our synthesized alternative model solves all these our first relevant result is therefore that through synthesis we have the prediction from previous work without the of human modeling specification ambiguity for c models next we analyzed the ambiguity in the specification the important unknown is the specific node within the that sends out the signal to lin and lst we with all four under our definition of understanding the specification ambiguity alternative models for particular input configuration of the experimental observations are deterministic we to know how many models exist if only the deterministic outcomes are we found that under this relaxed specification all four of coming from any node of the work then using the alternative model query from section we for a model including any one of the four remaining outcomes the synthesizer eliminates two that have from let and this was significant since it formally the intuition that the comes from higher up in the additionally it showed that sem in addition to let which was earlier was a valid possibility for the input configuration for models next we to observationally distinguish these two remaining valid models our observations the entire all nodes let to together we to infer if a mutation exists that distinguishes these two remaining hypotheses we expanded the experimental set by all possibilities of the nodes possibilities of expansion for each of the rows leading to experiments our synthesizer shows that no other exist that would observationally distinguish these two hypotheses this the significant effort experiments each of which are expensive and as they now know that mutation experiments will not ac l l lin lin let lin sem ls lst let let lst lin exp pattern ac lin lin lst pp pp pp pp pp pp formed wt wt wt wt formed wt ko wt wt formed wt ko ko wt formed ko ko wt wt figure a the template vp c we use for our experiments which is derived as simply the union of connections known to as informally shown by figure the nodes are instrumentation nodes to help read out the outcome b a small fraction of the specification e rows out of obtained from literature in a pattern of indicates that both and are outcomes observed in experiments suffice to distinguish these and experiments need to be performed inferring the minimal specification we run our minimization query from section for each of the queries with significant results we infer that for the space we are searching over only four experimental observations suffice to yield a unique model this set contains all nondeterministic outcomes and additionally others that together constrain the system enough to yield the unique model that is explained by the experiments our exploration demonstrated that let is not the only possibility for but sem is as well let and cannot play that role and the models using let and sem cannot be distinguished observationally these suggest a possible from sem that cannot be distinguished through mutation experiments on the components included in our model therefore other types of experiments would need to be done performance evaluation we implemented our language as an embedded in scala our synthesis and analysis framework also implemented in scala uses the z theorem prover as its underlying constraint solver we interface with z through the library our framework consists of k lines of code we show performance results for the evaluation of our synthesis procedure in figure a for each example we present total execution time maximum memory usage number of calls to the underlying smt solver z average call time the structure of holes in the partial programs as well as the search space for synthesizing update functions and are models of the decision in c cell development that express each different hypotheses about the cells through their topology and are synthesized using a specification e with domain size while and are synthesized using a specification e whose domain is restricted to elements is the example introduced in section for each example we report the total running time for synthesis the maximum memory usage number of calls to the underlying smt solver z the average time z takes to solve these queries a description of holes in the partial program as a sequence of number of states for each unspecified update function and the size of the search space for synthesizing these functions in all cases we find that even for a complicated synthesis problem such as the our synthesizer is efficient in figure b we present performance results for the pruning procedure described in section we report the domain size for the result of the procedure and the initial domain size in the column as expected the time for pruning is significantly higher than for only synthesis this is because multiple synthesis and verification queries are solved in the process of minimization however compared to the amount of time this could potentially save the ie or even years of work in doing redundant experiments our inference times are related work inference of models while model checking of manually written logical models has been an active area of research we are not aware of work that these models in contrast a growing body of literature exists on inference of models the first class of such models uses ordinary differential equations an example of model inference from temporal and spatial data is the work by et al who reduce the amount of prior knowledge needed to infer an accurate model et al find parameters for models by optimizing a notion of continuous degree of satisfaction of temporal logic formulas because models are continuous these techniques do not appear directly applicable for inference of logical models based on concurrent systems machine learning has also been used to infer models et al use time series data of levels to infer whether a is an or a of another time series data of is not available in our setting so these approaches do not apply to the inference of our models ac ac ac ac ac ac s s s ac ac ac lin ls let ls let ls ls let s lin ls lin ls let lin ls s s lin ls lin ls let lin ls lin lin ls a ac ac ac ac ac ac s s s ac ac ac lin ls lin sem s s lin ls lin ls sem lin ls b figure synthesized update functions given two different connection for let and lst a the topology with lst and lin by let the template allows for three let states and three lst states b the topology with lst and lin by sem the template allows for three let states and two lst states example time mem calls a time calls holes search space · · · · · example time mem b calls time calls total figure all times are in seconds and memory usage is in a evaluation results for synthesis the number of levels ie states for each synthesized update function is shown in the holes column b evaluation results for specification pruning we report for each example the size of the specification domain and the size of the original specification domain stochastic modeling an alternative to modeling systems using nondeterministic concurrency is to use if we were interested in making on the systems output behavior ie the most likely the behavior of the cell for a given mutation we might select a model that of under varying initial parameters including those not yet measured in the lab such predictive models are often stochastic in contrast we care to only discover a explanation for the system ie how communicate to agree on a particular cell it is appropriate here to rely on a discrete model because the modeling problem is to find a program that each observed outcome on at least one execution as opposed to some ratio of all executions the existence of such a schedule is sufficient to determine the need to have the crucial interaction synthesis algorithms for concurrent systems our synthesis algorithm extends the synthesis algorithm for concurrent data structures that work showed how to extend the algorithm from the sequential setting into the semantics of concurrent programs the resulting algorithm however did not handle the richer specification used in this paper ie the angelic correctness indeed new algorithms had to be developed for the specifications of this paper the project developed for concurrent data structures by deriving them from highlevel specifications it is not clear how these derivation algorithms can be adapted to synthesis of concurrent systems under inputoutput examples such as ours model checking ­ and abstract interpretation have been applied to analyze various systems all such efforts to manually construct and validate models have demonstrated the need for a synthesis system various other have been used to model systems including petri nets boolean networks and process algebras while our techniques are not directly applicable our success in synthesis for a model previously expressed in the expressive rm formalism demonstrates potential for synthesis in these other as well conclusion we present a language and develop algorithms for synthesizing concurrent models from experiments that perform on cells and observe the results of the mutation on developed cells we synthesize models that all nondeterministic outcomes of experiments this variant of synthesis requires a algorithm which we design by allowing three solvers to communicate counterexamples we also develop algorithms for analyzing specification ambiguity that a model is the explanation whenever possible under given assumptions and computing minimal specifications we carried out a significant case study synthesizing a model of cell specification in the c that expresses a previously unknown hypothesis references and thomas a henzinger reactive modules formal methods in system design ­ a j and h h stochastic analysis of in cells ­ aug v e james c david w mark d peter and j identification of interactions from spatial and temporal expression data a j myers and learning network from time series data trans comput ­ and temporal logic analysis of networks under parameter uncertainty ieee transactions of automatic control page de page and analysis and verification of models of networks a modelchecking approach in and symbolic model checking of networks c petri net modelling of networks brief ­ and abstract interpretation of networks pages ­ de and z efficient smt solver in tacas tools and algorithms for the construction and analysis of systems volume of lecture notes in computer science pages ­ david l model checking cell in cav page j n a and t a henzinger predictive modeling of during c development comput e may david and thomas a henzinger as acm ­ and thomas a henzinger executable cell nature ­ november thomas a henzinger and bounded concurrency for modeling interactions in pages ­ gulwani string processing in using inputoutput examples in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ acm j m g d and o probabilistic model checking of complex theoretical computer science ­ r and david the system as a reactive system modeling t cell activation with in pages ­ david pnueli e and michael j formal modeling of c development a approach in pages ­ ali and scala to the power of z integrating smt and programming in pages ­ s li s m and r essential components of signal networks a dynamic model of guard cell e oct h h and a stochastic mechanisms in expression proc sci usa ­ martin odersky and programming in scala a guide press and shapiro the picalculus as an abstraction for systems and continuous valuations of temporal logic specifications with applications to parameter optimization and measures theor comput sci ­ christopher grant jones and concurrent data structures in proceedings of the acm sigplan conference on programming language design and implementation pldi pages ­ acm and combinatorial for finite programs in pages ­ new york ny usa acm gulwani and jeffrey s foster from program verification to program synthesis in popl martin and deriving linearizable finegrained concurrent objects sigplan not ­ june a s c and i between the and in c development science ­ jan 