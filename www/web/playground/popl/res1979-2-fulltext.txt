inductively corn constructs in very high l languages c dept of computing and information university of science abstract in this paper we study the of applying the reduction in strength technique to programs in settheoretic languages focusing on the high level constructs involving set we define recursively two classes of expressions we shall call inductively computable and inductively computable predicates which can be evaluated with an order of magnitude im of the asymptotic running time as compared to the straightforward evaluation the developed for this comparison can be used to derive further results when additional in formation is known for programs written in very high level languages which often consist mostly of nested iterative constructs this tech amounts to the algorithm used to compute the program by replacing it with an asymptotically faster algorithm i introduction recently there has been much interest in and study of very high level languages el e fe m s it is generally recognized that in these languages is particularly since a straightforward translation may pro very inefficient programs one powerful op technique is an extension of the tech called reduction in strength ie the re placement of multiplication with addition in a loop al ac au cs ck this extension was first investigated by e and was called it inversion further include fu s ps in ps it was called formal differential ion the basic idea is as follows if a expression such as a b is to be computed within a loop that work supported by the national is executed repeatedly then md research of c n ada rather than computing its value directly from the operands a and b it may be easier to com it from its previous value provided that the modifications that had occurred to its operands can also be computed y most set opera tions such as set union set intersection and set difference are amenable to this type of tion fu s ps however whether the tech should be to an expression at a particular point in a depends also on the structure of the control flow fu if the modification in the operand no matter how small were to be frequently enough the work to update this change would be too much for the optimization to be it is to this problem of that we wish to address ourselves in this paper it is clear that this technique is only if the work spent in computing the changes to the operands involved in an expression and in updating the current value of the expression from its previous value is less than that spent in com it directly from its operands as e points out it is not clear how to tell in advance whether a transformation is help ing or the running time ps gives some heuristics to the conditions under which the technique may be in fu a set of are built up from the bottom starting with tions which obviously improve the running time of the program and developing additional transformations recursively and unman fu formalize the tive notion of easy to compute they define an induction variable to be one such that the change in its value the loop can be com using a bounded amount of work tion expressions can be built from induction variables the changes in their values around the loop can be computed using a bounded amount of work so that they can be evaluated with an order of magnitude improvement in running time when reduction in strength is applied er the most important application of this tech is not in operations such as set union but in expressions such as and predicates involving set in the spirit of fu we shall give recursive definitions of inductively computable and inductively comput able predicates which are two classes of expres sions such that if they are evaluated properly an order of magnitude improvement over the straight forward evaluation can be obtained in section ii the main results are presented in section iii we discuss various interesting extensions of the results to special cases ii main results before going on to the theorems we need some basic definitions we shall adopt the informal versions of the definitions given in fu definition a w is an induction variable induction expression of loop l at edge e if one can m the program such that there is a constant upper bound on the work taken by the extra steps added to co the change in the value of a w between any two consecutive times that control is at e within l if w is a boolean expression we define w to be an induction expression of l at edge e if its value rather than its increment can be computed with a constant amount of work definition a expression w is of limit ed at edge e in loop l if the difference in its values between any two tive times that control is at e within l is of bounded size as pointed out in fu these two notions are not the same nor does one imply the other to be specific let us consider the x a i x in a straightforward on this is actually a loop of its own in which x runs through every element of a as given in vu it cannot be an expression in a loop outside its own internal loop except under the most trivial of such as in the case where tx is a constant function independent of x in the following discussion we shall assume that lx is a function of x theorems and are essentially from fu and form the basis for the definitions of inductively computable and inductively computable predicates theorem let l be a loop containing the set former x c a i x suppose a is an induction variable and is of limited at e sup pose for all x which could ever be members of a x is an induction expression at e then the value of x c a i x at e can be computed with work proportional to i a i cost where by cost we mean the work necessary to com x for any one x that may be in a note that the straightforward evaluation of the set former requires i a i cost work proof between any two consecutive times when control is at e the number of xs in a such that the value of x changes is bounded by i a since each x is an induction expression at e the total work taken by the added steps to com them is bounded by a constant times i a between any two consecutive times that control is at e the number of new elements added to or deleted from a is also bounded because a is an induction variable and is of limited at e the work involved in the addition and deletion is proportional to cost hence the total work taken by the added steps is tional to i a i cost · theorem let l be a loop containing the predicate pa let pa be either vx c a x or ix e a x suppose a is an induction variable and is of limited at e suppose for all x which could ever be in a x is an induction expression at e in l then the value of pa at e can be computed with work proportional to i a i cost where cost is the work necessary to compute x for any x that may be in a the straightforward evaluation of pa requires i a i cost in the worst case proof let pa be vx c a x the value of pa at e can be by computing t the cardinality of the set x c a i x which can be computed with work proportional to ia i cost pa is true iff t in actual imple only t rather than the set itself is computed similarly if pa is x c a x its value is true iff the set x a i x is nonempty u in actual implementations only those tx which have actually changed since control was last at e should be the mapping which gives us those x to be updated is the inversion function as used in e note that this does not improve the asymptotic running time since x may need to be updated for all x in a also the inversion function itself may need to be updated not to mention the space re to store this function in the above theorems the improvement does not depend on creating the inversion function in section iii we shall discuss conditions in which it is desirable to create such a mapping and show how further im is example consider w xc gb if b is an induction variable and is of limited at e then x x g b is an induction expression and is of limited at e for all x in a if a is also an induction variable and is of limited at e then the value of w can be computed by computing the change in w since control was last at e let tx let a w e a ­ w e be new identifiers which have the value of the change in w since last time control was at e a w e maintains the ele ments added to w and a ­ w e maintains the elements deleted from w since control was last at e a a e a a e a b e a ­ b e are new identifiers with similar interpretations aw e and a ­ w e can be computed as follows aw e e for x in a a e do aw e e ux for x in a a begin compute tx xb if tx o then aw end ea w e u xl for a ­ b for z in a do if y in z then begin if tz o tz tz end w e u z for y in a b for z in a do if y in z then begin tz tz if tz o then a w e a w eu end z hence w can be computed using work proportional to a cost where cost in this case is the work necessary to compute i xb i for any x that may be in a if we use an inversion function as suggested in e we may define to be x c a i y e x the above program can then be modified to become the following aw e e ­ a e do begin e for y in x do end x x for x in a a e do begin compute tx i xb i if tx o then aw ea we j x for y in x do u x end for a ­ b for z in do begin if tz o then e tz tz end e uz for y in a b for z in do begin tz tz if tz o then aw ea end w e j z if find is the loop then the work necessary to obtain a we and a ­ we is proportional to c cost where c is an upper bound on the size of for any y in a and cost is the over all for all x in a where each cost x is proportional to i xb however we have introduced the extra statements to update find whenever the set a is changed and the added cost is proportional to x i for any x that may be in a since in the worst case c may be i a i introducing the inversion function here may not improve the running time of the program if from the program one can conclude that c is bounded by a constant independent of i a then a we an d a ­ we can be computed using work proportional to cost using the function find the work necessary to compute i xb i is proportional to x i if we take each element in x and test for membership in b where a member test is assumed to take constant time let m be the maximum i x i over all x that may be in a the straightforward implementation takes time proportional to i a i m while the above program takes time proportional to i a i m hence from the and the predicates given in theorems and we build up more complicated and predicates which can be evaluated with an order of magnitude im in running time over the implementation we shall call this computable and inductively computable predicates for any s and any predicate pa we define costs and to be the cost of evaluating s and pa in the manner that is if s x a i x costs is defined to be i a i cost where cost is as defined in theorem if pa is the predicate vx e a x or the predicate x ca x is defined to be we shall define an inductive y computable s at edge e in loop l and the s of s an inductive y computable predicate pa at edge e in loop l and the of pa inductively as if s x c a i x satisfies the conditions in theorem then s is an inductively computable at e we define to be ia i cost where is as defined in theorem define the level of s to be let pa be the predicate v x a x or the predicate x c a x if pa satisfies the conditions in theorem then pa is an inductively computable predicate at e we define to be i a cost ie the cost to evaluate it as given in the proof of theorem define the level of pa to be let s x c a i x suppose a is an induction variable and is of limited at an edge e in loop l suppose for all x which could ever be members of a x is an inductively computable predicate at e then s is an inductively computable at e we define to be ia i cost where is the maximum of over all x that may be in a and cost is the maximum of over all x that may be in a define the level of s to be one more than the level of x let pa be the predicate v x a x or the predicate ix c a x if s x e a i x is an inductively computable at e then pa is an inductively computable predicate at e we define to be the same as define the level of pa to be one more than the level of x the definition of is motivated by the following lemma lemma let s be an inductively computable and pa be an inductively computable predicate then it is possible to evaluate s and pa using work proportional to and pa respective y proof we shall prove this by induction on the level of s and pa basis let level of s be that the lemma is true follows from theorem let the level of pa that the lemma is true follows from theorem inductive step let s be of level k assume the lemma is true for s and pa of level k let s be x c a i x since s is an inductively com a is an induction variable and of limited at e and x is an inductively computable predicate of level k between any two successive times that control is at e the number of x in a such that the value of x changes is bounded by ia since each x is an inductively computable predicate at e of level k by the inductive hypothesis its value at e can be computed using an amount of time equal to hence the total work in is i a i where is the maximum of over all x that could ever be in a between any two successive times that control is at e the number of new elements added to or deleted from a is also bounded be cause a is an induction variable and is of limited at e the work involved in the ad and deletion is to cost which is the maximum of over all x which could ever be in a hence the total cost involved is i a cost which is as defined in of the definition the proof for pa of level k is similar · the following theorem shows that an computable s and an inductive ly computable predicate pa can be evaluated much faster than by the straightforward tion theorem let l be a loop containing the set former s x c a i x if s is an inductively computable at e then where i a i is the size of a and x i is the size of any x that may be in a let pa be the predicate vx a x or the predicate x c a x if pa is an inductively computable predicate at e then where i a i is the size of a and i x i is the size of any x that may be in a proofi we shall prove this by induction on the level of s and the level of pa basis let s be of level then by definition x i costs i cost we assumed x to be dependent on x so let pa be of level similarly by definition a i xl p xl a cost al cost i inductive step let pa be of level k assume the theorem is true for any inductively comput able predicate of level k then since a i x cost x for all x in a by the inductive is an inductively computable level k hypothesis as x predicate at e of similarly if s is an inductively of level k then computable predicate in loop l at edge e if within the loop all assignments to a are from a then s and pa can be evaluated in time proportional to i a i proof by the lemma s and pa can be evaluated using time proportional to i a i cost where the second term is the time involved in additions or made to a if all assignments to a within l are from a and there is only a bounded number of them a being an induction variable the work in is bounded assuming each deletion takes unit time hence the total time taken is tional to i a i u iii extension to special cases in the previous section we defined an in computable s x c a i x and an inductively computable predicate pa vx c a x or x c a x such that they can be evaluated using time al to i a i cost while the straight forward implementation takes time proportional to j a i cost the expression i a i cost is the sum of two terms the first one being the time involved in updating the x for possibly all x in a while the second term is the work involved when are made to a there are various conditions under which the second term cost may be or the first term may to simply these are given in the following theorems let us first the theorems in many applications it is found that within the loop all the assignments to a are either all from a or are all additions to a this is because usually a certain subset of a is desired which is obtained by adding elements one at a time starting from the null set until a certain condition is met or by deleting from a until a certain predicate holds in the following theorems we let s be of the form x c a i vx and let pa be of the form vx t a x or x e a x theorem let s be an inductively computable and let pa be an inductively com theorem let s be an inductively computable and let pa be an inductively computable predicate in loop l at edge e if between any two successive times control is at e the number of x in a such that the value of x changes is bounded by a constant and that there exists a function to obtain those x then s and pa can be evaluated using time proportional to cost proof since each x for all x in a is an computable predicate the work involved in updating each x is if the number of such predicates that needed to be updated is bounded by a constant the total work involved is proportional to the second term cost comes from the work involved in a bounded number of additions or made to a u in the above theorem we are assuming that the function that gives us those x which need to be changed can be set up outside the loop l and that it is not necessary to update the function within l this in general would not be true however there exists some very useful cases in which this restrictive condition applies for example consider the expression x a i fx y a function f may be changed by the statement fx z if we consider a function as a set of ordered pairs with distinct first elements then if xz is an element of f the change fx z can be considered as deletion of the element xz from f and addition of element xz to f if we let w be the variable which maintains the value of the set x c a i fx y then for each change to f such as fx z it can be replaced by the following code if fx y then ww x y then x fx z for each change to the operand f of the predicate x namely there is at most only one x in a for which the corresponding x is changed hence if we assume that testing for takes constant time maintaining the change made to w takes bounded time ing that the number of changes made to a and f are bounded the straightforward evaluation of w from its operands takes time proportional to if all assignments to a in loop l are from a then a condition can be relaxed but s and pa can still be evaluated with improvement over the straightforward evaluation theorem let s be x c a i x and let ps be vx c a x or ix c a x if x is an inductively computable predicate in loop l at edge e and all assignments to a in l are from a a need not be an induction variable at e then s and pa can be evaluated using time proportional to i a proof let w x c a i x if a is not an in variable of l at e the number of tions from a and hence from w between times control is at e may be proportional to ia however since deletion takes unit time the cost of deleting each element x from w may be to the cost of deleting x from a hence the total cost of updating a possible i a i number of predicates fix is proportional to i a as each predicate is an inductively computable predicate u by a careful of the work spent in evaluating an expression similar results can be obtained if all assignments to a within l are additions to a for any x a i x at edge e in a loop l to be evaluated incrementally within the loop its initial value has to be computed directly from the operands before entering the loop this cost is usually to the initialization of the loop as it is induced only once independent of the number of times the loop is executed if all assignments to a in l are additions to a for each element x added to a an amount of work proportional to cost is needed to compute the initial value of x successive values of x at e within l can be obtained using work proportional to if x is an inductively computable predicate now for each x added to a within l the corresponding x is computed from the operands only once as there is no deletion within the loop successive evaluation of x at e will still be computed incrementally hence theorem and still apply with changed to additions the cost of computing those x for each x added to a ie cost may be to the initialization of the loop l as the computation is done only once independent of the number of times the loop is executed references al fe allen program optimization annual review in automatic programming pp in vol ac fe allen and j a of optimizing transformations in design and op of compilers r cd prentice hall pp f e allen j and k kennedy reduction of operator strength tr dept of math sciences rice univ aug au av aho and jd the theory of parsing translation and compiling vol ii compiling prentice hall ck j and k an algorithm for reduction of operator strength tr dept of math sciences rice univ march cs j and schwartz programming languages and their compilers institute new york el j relational level data struc tures in programming languages technical report computer science department ty of california at e j high programming on very high level operations proc sigplan level languages in fe ja et al recent developments in algol based language for artificial intelligence cs standard university august ac and jd unman application of lattice algebra to loop proc nd acm symp on principles of programming languages jan fu ac and jd unman induction variables in very high level languages proc rd acm symp on principles of programming languages jan m morris and setl of california a comparison of lab ps b and j t schwartz expression continuity and the formal of algorithms proc th acm symp on principles of programming languages jan s j t schwartz on iterator inversion setl institute method of no s j t schwartz on programming i and ii institute and 