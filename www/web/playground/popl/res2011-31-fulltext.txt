regular expression containment coinductive axiomatization and computational interpretation university of copenhagen abstract we present a new sound and complete axiomatization of regular expression containment it consists of the conventional axiomatization of concatenation alternation empty set and the singleton set containing the empty string as an idempotent semiring the fixedpoint rule e e × e for and a general coinduction rule as the only additional rule our axiomatization gives rise to a natural computational interpretation of regular expressions as simple types that represent parse trees and of containment proofs as coercions this gives the axiomatization a constructive interpretation containment proofs do not only a containment but under our computational interpretation transform a membership proof of a string in one regular expression into a membership proof of the same string in another regular expression we show how to encode regular expression equivalence proofs in and into our containment system which their with a computational interpretation and implies completeness of our axiomatization to ensure its soundness we require that the computational interpretation of the coinduction rule be a total function hereditary totality can be considered the of syntactic side conditions it explains their soundness yet cannot be used as a conventional side condition in its own right since it turns out to be undecidable we discuss application of regular expressions as types to bit coding of strings and at other applications to the use of regular expressions for substring matching where classical techniques are a priori neither regular expressions as types nor subtyping interpreted are novel per se somewhat surprisingly this seems to be the first investigation of a general framework for the latter in the context of the former however categories and subject descriptors f formal languages regular sets d applicative functional programming general terms languages theory keywords axiomatization coercion coinduction computational interpretation containment equivalence regular expression type permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright © acm introduction what is regular expression matching in classical theoretical computer science it is the problem of deciding whether a string belongs to the regular language denoted by a regular expression that is it is membership testing in this sense matches but does not this interpretation is used for most theoretical computer science results by subset construction the theorem the lemma closure properties the star height problem derivatives fast regular expression equivalence algorithms and matching algorithms bisimulation etc if membership testing is all we are interested in regular expressions and finite automata denoting the same language are completely in that case we may as well implement regular expression matching using a dfa and about the original regular expression in programming however membership testing is good enough we do not only want a answer we also want to obtain proper matches of against the of a regular expression so as to extract parts of the input for processing in a compatible regular expression for example matching against e yields a substring match for each of the subexpressions they match abc ab c and the empty string respectively if we use a institute of and ieee instead we get abc abc however how is this possible the reason is that is ambiguous the string abc can match the left or the right alternative of and returning substring matches makes this difference observable in a membership testing setting ambiguity is not observable and thus not much studied an and limitation of matching is that we only get one match under kleene star the last one this is why we get a match of abc above but not intuitively we would like to get the list of matches under the kleene star not just a single one this is possible with regular expression types et al b each group can be named by a variable and the output may contain multiple bindings to the same variable for a variable under two kleene however we cannot the bindings between the different level groups an even more refined notion of matching is thus regular expression parsing returning a parse tree of the input string under the regular expression read as a grammar a little fact is that the parse trees for a regular expression are isomorphic to the elements of the regular expression read as a type eg the type interpretation t e of regular expression e is a × b × c d see a × b × c list with a b c d being singleton types identified with the respective values a b c d they contain the values p inl a b inr d inr a b c and p inl a b inr d inl a b inl c are elements of a × list representing two different parse trees of the same type since their yields the same string this shows that is ambiguous when we have a parsed representation of a string we sometimes need to transform it into a parsed representation of another regular expression consider for example ed which is equivalent to e ed corresponds to a dfa that can be used to match a string efficiently but what if we need a parsed representation of the string with respect to e we need a coercion a function that maps parse trees under one regular expression here ed into parse trees under another regular expression here e such that the underlying string is preserved since e is ambiguous there are different coercions for doing this the choice of coercion thus a particular ambiguity resolution strategy in particular we may need to make sure that it always returns the greedy leftmost parse as in matching or the longest prefix parse as in matching also we will be interested in efficient coercions over less efficient ones equivalent ones eg for e to e we prefer the coercion that copies a reference to its input instead of the coercion that traverses its input and returns a copy of it even if coercions are not used to transform parse trees they are useful for regular expressions under their language membership testing interpretation the existence of a welltyped coercion from le to lf is a proof object that logically that e is contained in f once it is constructed it can be checked efficiently for that e is contained in f instead of on search of a proof of that each time the containment needs to be checked the purpose of this paper is to develop the basic theory of regular expressions as types with coercions interpreting containment as a conceptual and technical framework for regular expression based programming where the classic view is contributions before into the details we summarize our contributions regular expressions as types the interpretation of regular expressions as types built from empty unit singleton sum product and list types was introduced by and cardelli for the purpose of regular expression matching we allow ourselves to observe and point out that the elements of regular expressions as types correspond exactly to the parse trees of regular expressions understood as grammars and cardelli refer to types as describing a concrete structured representation of values but do not that those representations are essentially parse trees conversely and as well as other works define an inference system for parse trees but do not make explicit that that is to a typetheoretic interpretation of regular expressions proofs of containment by coercion we observe that containment can be characterized by finding a coercion a function mapping every parse tree under one regular expression to a parse tree with same underlying string in the other regular expression the size of a coercion will necessarily be exponential in the sizes of e and f for reasons in the worst case but it may be small in many cases this means that proving a containment amounts to finding a coercion for the corresponding regular types allowing us to bring functional programming to bear for example e e × e for all e can be proved by defining the obvious function f fun f a a list a list a that the elements in the input the idea of a coercion interpretation of an given subtyping relation is not new our observation expresses something more elementary and however the existence of a coercion between regular types however specified implies containment of the corresponding regular expressions note the direction of reasoning from existence of coercion to containment coinductive regular expression containment axiomatization with computational interpretation we give a general coinductive axiomatization of regular expression containment and show how to interpret containment proofs computationally as transformations on parse trees each rule in our axiomatization corresponds to a natural functional programming construct specifically the coinduction rule corresponds to the principle of definition by recursion where the side condition guarantees that the resulting function is total we show that the derivations of the by kozen and can be coded as coercion judgements in our inference system this provides a natural computational interpretation for their as far as we know no previous regular expression axiomatization has explicitly been given a sound and complete computational interpretation where all derivations are interpreted computationally and lu come close however they provide what can be considered the first coercion synthesis algorithm implemented in an extension of haskell they show how to construct an explicit coercion for each valid regular expression containment by providing a computational interpretation of algorithm and for deciding regular expression containment they show that their treatment is sound and lu lemma a and state that it is complete we observe that being based on the construction of deterministic linear forms their work can be thought of as implementing a proof search using algorithm in axiomatization parametric completeness let us define ex xm f x xm if the containment holds for all substitutions of xi with closed regular expressions our axiomatization is not only complete but complete for infinite alphabets if ex xm f x xm for all regular expressions x xm then there exists c such that c ex xm f x xm as a consequence a axiom such as e × e e × e is derivable not just admissible in our axiomatization we can prove it once and use the same proof for all instances of e we observe that axiomatization kozen is also complete but neither nor appear to be so in case we need to make a case distinction as to whether the regular expression e substituted for x has the empty word property and in case the proofs use the derivatives of e which are syntax dependent application bit coding we believe regular expressions as types with coercions have numerous applications in programming both to think about regular technically we sketch one potential application how bit coding can be used to represent parse trees and thus strings this can be thought of as a regular expression specific string representation that often can be compressed more than the original string a investigation of this and other applications requires separate treatment however we assume basic knowledge of regular expressions as in hopcroft and ullman and denotational semantics as in notation and terminology a denotes an alphabet a possibly infinite set of symbols the strings over a is the set of finite sequences s t with elements from a the length of a string s is denoted by s the nary concatenation of s sn is denoted by their s sn for n it denotes the empty string we use inl and inr as the tags distinguishing the elements of a disjoint sum of two sets such that x y inl v v x inr w w y we treat recursive types where fold fold denotes the isomorphism between a recursive type and its unrolling in particular we define the list type x by x × y the empty list is an abbreviation for fold inl and cons x y stands for fold inr x y the list notation x xn is syntactic sugar for cons x cons xn we say a unary predicate p universally implies another unary predicate q if xp x qx regular expressions as types and coercions in this section we show that a regular expression e can be interpreted as an ordinary type and regular expression containment as the existence of a coercion between such types the elements of the types correspond to proofs of membership of strings in the regular language denoted by e which in turn are the parse trees for e viewed as a grammar a coercion then is any function that transforms parse trees without changing the underlying string definition regular expression expressions is the set of abstract syntax tree defined by the following regular tree grammar e f g h a e f e × f e where a a in of our interpretation of regular expressions as types we write × instead of the more or · for concatenation our notational convention is that × bind in decreasing order eg a a × b stands for a a × b regular expressions as languages the language interpretation of maps regular expressions to regular languages kleene this is also called the standard interpretation of since it is isomorphic to the free kleene algebra over a kozen definition language interpretation the language le is the set of strings defined by l l la a le f le lf le × f le · lf le where s · t s t s s t t e ei e · ei we write s e if s le e f if le lf and e f if le lf aa se sf se tf st e s e × e s e a regular expression matching aa ve inl v e f wf inr w e f ve wf v w e × f v e × e fold v e b type figure matching relation and type as expected le is the set of all finite of strings from le le s sn n si le for all i n definition constant part the constant part oe of e is defined as oe if le and oe otherwise definition matching we say s matches e and write s e if the statement s e is derivable in the inference system in figure a matching is sound and complete for membership testing proposition s e if and only if s e the derivation of a matching statement s e describes a parse tree for s under e understood as a regular grammar this paper is about studying the parse trees not just the regular language denoted by e regular expressions as types parse trees are in correspondence with regular expressions interpreted as types that is all we need to do is interpret the regular expression constructors as type constructors and we obtain exactly the parse trees definition type interpretation the type interpretation t maps a regular expression e to a set of structured values t t t a a t e f t e t f t e × f t e × t f t e v vn vi t e we write v e if v t e note that this is the ordinary interpretation of the regular expression constructors as type constructors is the empty type the unit type a as a type the singleton type a the sum type constructor × the product type constructor and the list type constructor definition we say v e and write v e if the statement v e is derivable in the inference system in figure b is sound and complete for type membership proposition v e if and only if v e by inspection of figures a and b we can see that a value v such that v e corresponds to a unique derivation of s e for a string s that is uniquely determined by v definition the function flat from values to strings is defined as follows flat v w a w v in particular we have theorem le v t e regular expression containment as type coercion since each regular expression can be thought of as an ordinary type whose elements are all the parse trees for all its strings under the language interpretation we can characterize regular language containment as the problem of transforming parse trees under one regular expression into parse trees under the other regular expression definition coercion a function f t e t f is a partial coercion from e to f if v for all v t e whenever f v it is a total coercion or just coercion if f v for all v t e we write t e f for the set of partial coercions from e to f and t e f for the set of total coercions from e to f in other words a coercion from e to f is a function that transforms every parse tree under e to a parse tree under f for the same underlying string clearly if there exists a coercion from e to f then e f the coercion takes any membership proof of a string in le to a membership proof for the same string in lf conversely if e f we can define a coercion from e to f by mapping any value v e to a value w f where theorem containment by coercion e f if and only if there exists a coercion from e to f an immediate corollary is that two regular expressions are equivalent if and only if there is a pair of coercions between them corollary equivalence by coercion pairs e f if and only if there exists a pair of coercions f g such that f t e f and g t f e it may be to expect such pairs to be isomorphisms that is f g f and g f e this is generally not the case however we have a a a but there is no isomorphism between them since there are two values for a a but only one value for a theorem provides a simple and useful method for proving regular expression by functional programming find a function from e to f as types and make sure that it terminates outputs each part of the input exactly once and in the same lefttoright order the latter is usually easily checked when using pattern matching in the definition of the function example we prove the rule kozen a b a × b × a in one direction find a function f a b a × b × a and make sure that it terminates uses each part of the input exactly once and outputs them in the same lefttoright order as in the input f f inl u z let x y f z in u x y f inr v z let x y f z in v x y we can see that f terminates since it is called recursively with smaller arguments and the output contains the input components in the same lefttoright order consequently f defines a coercion and by theorem this a proof that the regular language la b is contained in la × b × a the other direction is similar in this example we defined an element of the function space t e t f and then verified manually that it belongs to the t e f the following section is about designing a language of functions each of which is guaranteed to be a coercion soundness and that furthermore is expressive enough so that it contains a term denoting a coercion from e to f whenever e f completeness declarative coinductive axiomatization at the core of all of regular expression equivalence are the axiomatization of product × sum empty and unit as the free idempotent semiring over a see figures and we add the familiar axiom for in figure which models that e is a fixed point of x e × x let us call the resulting inference system weak equivalence it is a sound but incomplete axiomatization of regular expression equivalence in particular we have a a but they are not weakly equivalent remark intuitively this is because weak equivalence does not allow invoking recursively what we want to prove the basic idea in our axiomatization is to add recursion by way of a general finitary coinduction rule e f ef ef here e f is a assumption it may be used an arbitrary number of times in deriving the premise but is when applying the inference step since the premise is the same as the conclusion without a side condition restricting its applicability this rule is unsound we could simply satisfy the premise by immediately e f from the assumption by the coinduction rule e f for arbitrary e f would be derivable the key idea of this paper is to make the side condition not a property of the premise but of the derivation of the premise to this end we switch from equivalence to containment and our inference system with names for the rules at a typetheoretic formulation with explicit proof terms these proof terms can be computationally interpreted as coercions as defined in section the coinduction rule then reads f e f c e f as in and section where the side condition is a syntactic condition specific to recursive subtyping the computational interpretation of c is the recursively defined partial coercion f such that f c where c may contain free occurrences of f for soundness all we need is for the coercion to be total that is terminate on all inputs this leads us to the side condition in its most general form the computational interpretation of c must be total e f g e f g ef f e e e ee e e × f × g e × f × g e e e × f g e × f e × g e f × g e × g f × g figure axioms for idempotent ee ef f e eg f h ef gh ef f g eg eg f h figure rules of equality e e × e figure rule for unfortunately totality turns out to be undecidable and we present efficiently syntactic conditions that totality and yet are expressive enough to admit completeness axiomatization consider the coercion inference system in figure each axiom of the form p e f is a shorthand for two containment axioms p e f and p f e definition coercion judgement let be a sequence of coercion assumptions of the form f e f with no f repeated a coercion judgement is a statement of the form c e f that is derivable in the inference system of figure if is empty we may omit it and write c e f by induction on its derivation a coercion judgement f e f fn en fn c e f can be interpreted as a continuous function f c e f t e f × × t en fn t e f which is specified by the equations in figure for example the clauses for should be understood as f e f f ef fn x of inl v inr v inr v inl v the interpretation of is defined to be the least fixed point of a continuous function on t e f which always exists since t e f is empty or a cpo with bottom the interpretation of is the empty function since the type interpretation of their domain is empty formally definition computational interpretation the computational interpretation f f e f fn en fn c e f e f g e f g ef f e untag f f ee e e ef assoc e × f × g e × f × g swap proj e e × f g e × f e × g e f × g e × g f × g wrap e × e e id ee de e c d e e df f e f df f e f e f f e f f ef ce ef f coinduction rule figure declarative coercion inference system for regular expressions as types with suitable side conditions for the coinduction rule this is sound and complete for regular expression containment see sections and for side conditions of a coercion judgement is the least continuous function that maps partial coercions from ei to fi bound to the fi to a partial coercion from e to f satisfying the equations of figure we can interpret all computation judgements but without a side condition controlling the use of the coinduction rule the coercion inference system is unsound for regular expression to wit we can trivially derive e f for any e f we might hope that a simple rule would ensure soundness definition let e f be a coercion judgement we say an occurrence of f in c is by d if c contains a subterm of the form d × d and the particular occurrence of f is in d we call if for each occurrence of f there is a d that f is not sufficient for soundness however consider id × f proj e f which is derivable for all e and f for we have annotated id with a subscript indicating which regular expression it operates on computationally this coercion judgement does not terminate on any input this is an case it contains both v inl inl v inl v inl inr v inr v inr v inl v inl v inr v inr inl v v inr inr v v inr v v inl v inr v v untag inl v v untag inr v v v inl v w x v w x w x v w x v swap v v proj w w w inl w inl v w inr x inr v x v w v inl w v x v inr x v w inl v w v x inr v x v w inl v w v x inr v x wrap v fold v wrap v fold v v id id c dv c v inl cv c w inr c × dv w cv v figure computational interpretation of coercions a proj coercion and an f that is only by a coercion operating on a regular expression in this case whose language contains the empty string soundness we have seen that without a side condition on the coinduction rule the coercion inference system is unsound for regular expression the key idea now is this impose a side condition that guarantees that the coercion in the conclusion of the coinduction rule is total since all other rules preserve totality of coercions this yields a sound axiomatization of regular expression containment by theorem since our coercions may contain free variables we need to generalize totality to secondorder coercions definition hereditary totality we say coercion judgement c e f for f e f fn en fn is total if f c e f f fn is total whenever fi is a total coercion from ei to fi for all i n we are now ready to define sound restrictions of the coercion inference system instead of a specific side condition we over side conditions for the coinduction rule to express generally what is necessary for such a side condition to guarantee soundness definition coercion inference system with side condition consider the coercion inference system of figure where the coinduction rule is equipped with a side condition p a predicate on the coercion judgement in the conclusion f e f c e f e f p e f we write p c e f if each application of the coinduction rule in the derivation of c e f satisfies p we arrive at the soundness theorem which provides a general criterion for sound side conditions theorem soundness let p be any predicate on coercion judgements that universally implies hereditary totality then p d e f implies e f for all d e f this theorem shows that hereditary totality is an upper bound for how the side condition can be without the of sound computational interpretation of a regular expression containment proof as a coercion interestingly allowing partial coercions does not necessarily make the resulting inference system unsound for proving regular expression containment if we define the side condition p t e f e f the resulting inference system is trivially sound and complete since e f is derivable for those e f such that e f clearly f e f is computationally completely useless however it never terminates unfortunately hereditary totality itself is undecidable even for the restricted language of coercions by coercion judgements theorem whether or not c e f is total is undecidable proof even totality of c is undecidable this follows from the undecidability of c × × which in turn follows from encoding machines register machines as closed coercion judgements using a unary coding of natural numbers this makes hereditary totality as a conventional side condition in an axiomatization where valid instances of an inference rule are expected to be decidable below we provide polynomialtime decidable side conditions that are sufficient to encode existing derivations in previous see section in each case their soundness follows from application of theorem in this sense hereditary totality can be considered the of all side conditions even though it itself is too extensional to be used as a conventional side condition definition syntactic side conditions si define predicates s s s and s on coercion judgements of the form e f as follows · s e f if and only if each occurrence of f in c is by a d where d e f is the coercion judgement for d occurring in the derivation of e f and oe from definition · s e f if and only if each occurrence of f in c is and for each subterm of the form c c in c at least one of the following conditions is satisfied proved by kobayashi and at the ifip tc working group at april c is closed and c is closed · s e f if c is of the form wrap id id × f d where d is closed · s s s it is easy to see that s s s and s are polynomialtime they furthermore imply hereditary totality lemma hereditary totality for si let e f such that si e f with i then e f is total proof sketch side condition s is a special case of s the case of s follows from s and s we have formulated s separately since s is sufficient to code all derivations in and s by itself without s is sufficient for axiomatization the general idea behind the side conditions s s is that they ensure that every recursive call f in the body c of a recursively defined coercion is called with an argument whose size is properly smaller than the size of the original call the difference between the two conditions is the definition of size in each case consider s define the size v of a value by v that is it is the length of the underlying string values containing may be of size eg and the size of a component of a pair may be the same as the size of the pair v v consider a call of to a value v of size n the predicate s ensures that all recursive calls to f in c are only applied to a value constructed from the second component of some pair where the first component has size at least since coercions never increase the size this guarantees that the recursive call is applied to a value of size at most n now consider s define the size v of v as follows inl v v fold v v a inr v v v w v w note that if we had defined to be then this would be just the size hence our terminology the idea for ensuring termination of a recursively defined coercion is the same as before but for size instead of size with size we have the important property that each component of a pair is properly smaller than the pair in particular w v w for all v we say a coercion c is if cv v all primitive coercions except for proj are and the inference rules preserve side condition s guarantees that each recursive call is applied to an argument of size properly smaller than the original call informally this is because s guarantees that a recursive call of f is never applied to a value constructed from the output return value of a from theorem lemma and theorem we obtain corollary soundness for side conditions si let s s s s as in definition i then si d e f implies e f completeness we show now how to code derivations in and of regular expression equivalence in our coercion inference system figure with side condition s or s kozen this provides a computational interpretation for each of these systems furthermore it implies that coercion axiomatization with either s or s is complete more precisely we encode every derivation of e f as a pair ef e f e e e f e f if of figure rules for axiomatization f of coercion judgements c e f and d f e which provides a computational interpretation of a regular expression equivalence as a pair of coercions that witness e f according to corollary even though they are for regular expression equivalence these also provide completeness of our coercion axiomatization for regular expression containment assume e f this holds if and only if e f f by completeness of the regular expression equivalence e f f is derivable and we can construct a coercion judgement of c e f f composed with this yields c e f and we are done theorem completeness let p be either s or s if e f then there exists c such that p c e f it follows that any side condition logically between s or s on the one hand and hereditary totality on the other hand yields a sound and complete coercion axiomatization of regular expression containment corollary soundness and completeness let p be such that either s or s universally implies p and p universally implies hereditary totality then p c e f if and only if e f whereas hereditary totality is the natural upper bound we that there are natural weaker lower bounds than s and s system f arises from adding the rules of figure to the axiomatization of weak equivalence figures and the side condition of the inference rule in figure is called the no empty word property to be precise we prove by induction on derivations of e f in system f that there exist coercion judgements s c e f and s d f e this is straightforward for the weak equivalence rules we thus concentrate on the rules in figure ef consider e f by induction hypothesis there exist s c assume e e f f and s d f e and call this assumption we f reason as follows e e × e by wrap f × f by id c × f f by wrap this shows that f e f s wrap id c × f wrap e f note that id c × f wrap e f satisfies side condition s and thus s its computational interpretation is the on lists with s satisfied we can ap technically this is the dual due to to original formulation where the rule for kleene star is as e e × e the coinduction rule to conclude s id c × f wrap e f similarly we get d × g wrap f e s fix id consider e e the case e e follows from the rule above since e e for the converse containment assume f e e we have e e × e by wrap e × e by f × e e × e by e e × e by proj e × e e by e e by wrap e by untag we are a bit informal here we have left associativity congruence and identity steps implicit let us consider e e now without c in full detail from the derivation above we can see that f satisfies side condition s and thus s and we can conclude s rule operationally f e e e by e the coinduction traverses its in put list of type t e removes all occurrences of inl and returns the vs for each inr v in the input e f finally consider e f × g if of our induction hypothesis s d assume f f f × g g e is s e let and we c e f × e us consider f × g can calculate d f g and e first e as follows f × g f × f × g by wrap × g f × f × g by gf by proj gf by f f by e by d we can see that f × g e satisfies s and since of also s and thus s we can thus conclude s that f × g e by the coinduction rule observe f × g e is total whether or not of since s is also satisfied for the other can calculate c direction e f assume s g × g essentially e in the f × g and we reverse direction to the above calculation e f by c gf by gf by g × g f × f × g by proj f × f × g by f by wrap here the coercion judgement e f × g may computationally be nonterminating choose eg c proj e × e for of however e f × g satisfies side condition s and thus s in particular it always terminates we can conclude s e f × e g by the coinduction rule kozen kozen has shown that adding the rules in figure to weak equivalence is sound and complete for regular expression equivalence formally a containment e f in his axiomatization is an abbreviation for e f f we show now that all derivations in his system can be coded as coercion judgements with side condition s e × e e f e × f f e e e figure rules for axiomatization of kleene algebras ai ai aj ai i j e f ai e × f ai × f oe e e ai ai × × f e oe figure definition of consider e × e e it is sufficient to construct a e × e since e as desired can calculate c e we × then e e × e as follows e × e e × e × e by wrap × e e × e × e by × e e × e × e by f e × e × e × e by swap e × e × e by e × e by wrap writing c explicitly we have c wrap × id swap assoc id × f id × wrap observe that e × e e × e satisfies side condition s and we can conclude s e × e e × e by the coinduction rule f consider the rule e × f f our induction hypothesis is that there exists and we calculate c s e d × e f f f assume as follows f e f e × f e × e × f by wrap × f e × e × f by by f f by proj f f by d f by untag note that e × f f satisfies side condition s and we can apply the coinduction rule to conclude e × f f s the rule e e e is similar to the previous rule with an additional step involving e × e e × e the following results hold for all alphabets but for convenience we assume that a is finite in this section the ea for regular expression e and a a is defined in figure e f e f ea fa fan ef oe of figure coinduction rule recognized that can be combined with the of and the coinductive fixed point rule for recursive types of and to give a coinductive axiomatization of regular expression equivalence his rule is given in figure indeed it can be seen that in the presence of a transitivity rule of equational logic the and only the rule is needed to obtain a complete system for regular expression equivalence without the other rules of inference system a sequent style presentation of is as follows e f g ea fa for all a a oe of let us write and for where all occurrences of in are replaced by respectively we can show by rule induction that for each derivation of g e f there exist coercion judgements s c e f and s d f e the only interesting rule to consider is by induction hypothesis we have f e f ca ea fa and g f e da fa ea for all a a where oe of note that e oe aa a × ea shows that e oe aa a × ea is derivable from the rules for weak equivalence figures and extended with axiom a f f see also lemma p a is only required for what and cardelli call problematic regular expressions regular expressions of the form g where by applying the derivation coding of axiomatization from subsection to the derivation of e oe aa a × ea we know that there exist s ce oe aa a × ea e and s de e oe aa a × ea this gives us the following derivable coercion judgements f e f s de aa × ca cf e f g f e s df aa × da ce f e we can observe that they satisfy side condition s and thus s by the coinduction rule we can thus conclude s aa × ca cf e f s aa × da ce f e this provides an alternative proof to the one based on coding system f for that e f implies s e f examples we give examples of coercion judgements for regular expression example as coercion we continue example by implementing the function proving a b a × b × a in the coercion language abbreviate e a b and f a × b × a we can calculate a b a × b × a as follows e a b × e by wrap a b × f by f b a × f by b × f a × f by b × a × b × a a × f by assoc b × a × b × a a × f by b × a a × f by wrap b × a a × a × b × a by assoc b × a a × a × b × a by b × a f by wrap × b × a f by proj a × a × b × a f by f f by wrap f by untag writing it out in full the coercion coercion judgement is wrap id × f id id assoc assoc wrap id id wrap × id proj id wrap × id id untag a b a × b × a in the above example the coercion is operationally basically the function f defined in example it folds a computable function over its input list and therefore runs in linear time kozen proposition gives a proof of the same inclusion in his axiomatization of kleene algebra when encoding it as in section we obtain a similar coercion this raises the question whether computational interpretation of all proofs of the same containment in the of kozen and yield coercions of the same complexity this is not the case as illustrated by the next example example coercion efficiency consider a × a a the simplest way to prove this with rules is to start from a × a a proved by wrap by the left inference rule in figure we then get a × a a by the right inference rule in figure we finally obtain a × a a let us consider the computational interpretation of this proof we have two nested applications of the left and right respectively inference rule from figure this gives quadratic runtime it is to us whether there exists a proof using rules whose computational interpretation as a functional program runs in linear time it is possible to construct a coercion for a × a a in our coercion inference system however this can be systematically obtained by encoding the minimal proof in axiomatization in fact the encoding of any proof in axiomatization will have linear run time this is because the only admissible application of recursion in axiomatization is of the form id × ca cf where f does not occur in de and cf which entails that only constant amount of processing occurs for each constant part of the input parametric completeness let us extend regular expressions by adding variables that can be bound to arbitrary regular sets formally e f g h a x e f e × f e where x ranges over a set of formal variables such a regular expression is closed if it contains no formal variables we define x xm f x xm if the containment holds for all substitutions of xi with closed regular expressions our axiomatization is immediately applicable to regular expressions with free variables without change it is not only complete but complete for infinite alphabets theorem parametric completeness let a be infinite let the side condition p for the coinduction rule in figure be either total or s then x xm e f if and only if p c e f proof only if by rule induction coercion axiomatization is closed under substitution with total or s as side condition note that this is not the case for s technically s is not even defined for regular expressions with variables since ox is undefined if assume x xn e f let b bn be n distinct alphabet symbols not occurring in e or f since a is infinite they exist by definition of x xn e f we have ex b xn bn f x b xn bn by theorem completeness there is a derivable coercion judgement p c ex b xn bn f x b xn bn since coercion axiomatization with hereditary totality or s as side condition is closed under substitution the b bn can be replaced by arbitrary regular expressions e en respectively such that c eb e bn en f b e bn en in particular we can choose x xn for e en and thus obtain c e f as a consequence of theorem a containment such as e × e e × e is derivable not just admissible in our axiomatization we can synthesize a single coercion judgement for it and use it for all instances of e for finite alphabets our axiomatization is incomplete however x x a b holds for a a b but x a b is not derivable we observe that axiomatization kozen is also complete for infinite alphabets but not for finite alphabets neither nor appear to be complete in case we need to make a case distinction as to whether the regular expression e substituted for x has the empty word property and in case e needs to be the proof of which depends on the syntax of e application compact bit representations of parse trees if the regular expressions are statically known in a program we can code their elements more precisely their parse trees as bit strings bit coded strings intuitively a bit coding of a parse tree p factors p into its static part the regular expression e it is a member of and its dynamic part a bit sequence that uniquely identifies p as a particular element of e consider for example the string s as an element of h a b it has the unique parse tree corresponding to ps inl a inr b inl a inl a inr b with ps h which shows that is an element of lh figures and define directed coding and functions from parse trees to their canonical bit and back informally the bit coding of a parse tree consists of listing the inl and inr constructors in preorder traversal where inl is mapped to and inr is mapped to no bits are generated code a v e f e w e f f w e × f e f v e e × e figure typedirected encoding function from parse trees values to bit sequences d d d a a d d e e let v d d e in inl v d d e e let w d d e in inr w d d e × e let v d d e w d d e d e in v w d let v d d e × e in fold v d e let w d d e in if d then w else error figure typedirected function from bit sequences to parse trees values for the other constructors for example the bit coding bs for ps is we can think of the bit coding of a parse tree p as a bit coding of the underlying string note that the bit coding of a string is not unique it depends on · which regular expression it is parsed under and · if the regular expression is ambiguous which parse tree is chosen for it as an illustration of the first effect the bit representation bs of s under h a b × a b is since both h and h are unambiguous there are no other bit representations of s under either h or h bit code coercions so what if we have a bit representation of a runtime string under one regular expression and we need to transform it into a bit representation under another regular expression this arises if the branches of a conditional expression each return a string but under different regular expressions e e and we need to ensure that the result of the conditional is a bit coding in a common regular expression f that contains the e and e let us consider s again and how to transform bs into bs as we have seen in section e is contained in e × e for all e and there is a parametric polymorphic coercion c xx x × x mapping any value p e representing a parse tree for string s to a parse tree p e × e for s in particular applying c to ps yields ps we can compose c with code and from figures and to compute a function c operating on bit c code · c · instead of converting to and from values we can define a bit coding coercion by providing a computational interpretation of d d d d untag bd d d d d d d d d swap swap d d d d e × f g let d bd e in bdd e × f e × g let d d e in d d wrap d d wrap d d c c d cd c c d c d c × c d e × f let d d e in cd c d c c d c cd d fix d figure coercions operating on typed bit sequence representations instead of values d a d e e let d d e in d d e e let d d e e in d d e × e e × e let d d e d d e in dd d figure typedirected function for splitting bit sequence into corresponding to components of product type v fold v µx figure rule for µ coercion judgements that operates directly on bit coded strings see figure it uses the typedirected function split from figure for splitting a bit sequence into a pair of bit sequences consider for example the coercion c e × e to e × e from section by interpreting c according to figure we arrive at the following highly efficient function ge which transforms bit of values of e × e into corresponding bit representations for e × e d d let d d d the bit coded version of c e e × e gives us a function he that operates directly on bit of parse trees of strings in e and transforms them to bit in e × e d note that is the bit coding coercion from h to h it transforms into without ever a string or value the presented bit sequences are compact but their sizes depend on the regular expression used thus it is necessary to use reasonable regular expressions to obtain compact bit sequences in fact the most compact representations can be found only by generalizing regular expressions to we will use the remainder of this section to study this extension and the compression it allows a common representation of strings over an alphabet a a of characters from the alphabet a sequence of bit bytes representing each of the different characters and uses the remaining byte to indicate the end of the string this gives a total size of · n bits to represent a string of length n consider now the size of the bit sequence from section of a string under regular expression e where e is a sum type holding all the characters in this can be written in many ways using permutations and of the characters for example if we define e as a a a a this means that the size of the bit coding of ak is k bits long this can be improved by ensuring that the type is balanced such that each path to a character has the same length as there are characters this means we will use bits to represent each characters leaving one path unused so one character only uses bits now we can look at the space required for the bit coding of a string under type e since e is to e × e the representation of the empty string requires bit while the representation of other strings is bit plus bits for representing the first character plus the bits to represent the rest of the string for the type e thus up to · n bits are used to represent a string of length n the reason why bit for regular types use one bit more per character is due to the very restrictive recursion in regular expressions the extra bit is used to say for each character that we do not want to end the string yet this is because we can only use the constructor to define recursive types and a regular expression e always to e × e therefore we use one bit for each character to choose the right hand side after the unfold this is equivalent to using a unary integer representation to state how many times the e inside the is used which leaves room for optimization we now generalize the recursion to in order to obtain more compact bit consider the language of expressions over a finite alphabet a an a × µx x we define the free variables of to be the set of variables x that occur in without a binder µx if there are no free variables in then we say that is closed we call if is closed in all subterms of the form × we can now define the language recursive expressions from as the closed tail we need to define semantics and tion for the new expressions but we can reuse the definitions from regular expressions l t v e simply by adding new rules for the new µ and x constructs we can extend the from definition with an environment and replace the definition of t e with t x x and t µx i t i where x and n x t n similarly l can be extended to finally we can use the rules from figure except the fold rule is replaced with the rule for µ in figure we can now prove that expresses exactly the same lan guages as reg theorem of for all e reg there is such that v e for all there is e reg such that v v v e proof sketch the first statement is proved by encoding e as µx × x where is the encoding of e the second statement is proved by first rewriting to the form µx × x where x is not free in or now it can be seen that × x le × f where e is a regular expression encoding of and f is an encoding of the equivalence of regular expressions with gram is well known are like grammars but do not exactly correspond to them lack mutual recursion but offer lo recursion where grammars only provide toplevel recursion even though expresses reg the new expressions allow exactly the same languages us to define a b c as as µx a × x b × x c × x and thus us one bit per character we need to express using this optimization the representation of any string with respect to the generalized regular expression type will use bits per character plus bits to terminate the string this is exactly the same size as the standard in fact the for this type will be exactly the same as the for the standard representation if the same permutation of characters is chosen in it may not seem very to the rep this way but it can guarantee that bit coding uses at most as much space as the representation the benefit of bit coding comes when we no longer consider all strings milner presents a sound and complete axiomatization of behavioral equivalence of denoting labeled transition systems behavioral equivalence is properly weaker than regular expression equivalence however distributivity e × f g e × f e × g does not hold but a subset specified by a regular expression in this case the bit will generally be more compact the example of this is when the regular expression allows exactly one string for example the bit sequence of under regular expression a × b × c × b × c × b × a uses zero bits since its value contains no inl inr choices of course the program needs to know the regular expression in order to interpret the bit sequences but that can be shared across interpretation of multiple bit sequences we end this section with two examples showing the bit sizes of strings under different regular expressions example in the table below z denotes a designated character and characters a b c their bit regular expression a b c d a b c a × b c × a representation size the following is a more realistic example where we also consider the data size before and after text compression example sizes for xml record collection string consider the following regular expression corresponding to a regular xml schema × and associativity have been omitted for simplicity cd this regular expression describes an for representing a list of we have found the sizes for representing a specific list containing to be as follows bit representation using e bit representation using compressed as we can see there is almost a factor reduction in the space requirement when using the regular expression specific bit the benefit is reduced by compression of the bit codes with but an space reduction is still obtained discussion regular expressions are fundamental to computer science with numerous applications in text processing natural language processing program analysis graph shortest path computation compilers program verification and more and independently provided the first sound and complete of regular expression equivalence based on a unique fixed point rule with pratt for extended regular expressions and kozen providing alternatives in the s recently coinductive based on finitary cases of coinduction principle for simulation relations have become popular for regular expressions chen and and kozen for kleene algebra with tests and show how to specialize their framework to regular languages and how to translate regular languages into socalled deterministic expressions et al example such expressions appear to correspond to nondeterministic linear forms which in turn represent free nondeterministic automata their particular translation may generate exponentially expressions than the original regular expressions however which may limit practical applicability axiomatization is based on derivatives which allow automata constructions and pairwise regular expression rewriting lu and to be understood as proof search in this paper we present a declarative coinductive axiomatization of regular expression containment generalizing algorithmic coinductive axiomatization of regular expression equality ours is the first axiomatization of regular expression containment with a computational interpretation of containment proofs as functions coercions operating on regular expressions read as regular types like axiomatization but unlike and coinductive it is complete for infinite alphabets if ex f x for all x then there is a parametric polymorphic coercion c x ex f x and cardelli were as far we know the first to state the precise connection between regular expressions as languages and regular expressions as types section in this paper coinductive with a style computational interpretation have been introduced by and for recursive type equivalence and subtyping on by et al as an alternative to the axiomatization of and cardelli which uses the unique fixed point principle in this fashion classical unification closure can be understood as proof search for a type isomorphism and the product automaton construction of kozen et al as search for the coercion embedding a subtype into another type di et al provide a coinductive characterization of recursive subtyping with products but it is not a proper axiomatization since it directly to bisimilarity recursive type isomorphisms have also been studied by abadi and and have been used for stub generation et al the finitary coinduction rule in its most general form is p p p it requires a side condition for soundness which is usually specific to the syntax of the formulae p and the particular logical system at hand numerous syntactic variations may be possible and care must be applied to retain soundness eg by not allowing a transitivity rule et al this work represents the end of a for a general semantic side condition at least for containment formulae interpret a proof of containment computationally as a function and let the side condition be that the conclusion now with explicit proof object under this interpretation be total for regular expression containment hereditary totality turns out to be undecidable but it the soundness of our side conditions s and s which each yield sound and complete of regular expression containment their disjunction is expressive enough to facilitate a compositional encoding of derivations in and here declarative and algorithmic are used in the same sense as in benjamin types and programming languages mit press bisimilarity is defined that is as a greatest fixed point but not necessarily as required in an ordinary recursive axiomatization and section discuss how the finitary coinduction rule can be understood as a rule for finding a finite set of formulae that are consistent intuitively this corresponds to constructing proofs of such formulae that are finite but may be circular they may contain occurrences of formulae to be proved as assumptions this is also the essence of circular coinduction for behavioral equivalences and goguen and provide a general framework for applying circular coinduction soundly it allows marking certain equations as frozen to prevent them from being applied which would lead to unsound conclusions our approach is different in the following sense we allow circular equations without any restriction an equation is interpreted as a pair of potentially partial functions whose definition depends on the particular circular proof of the equation an equation is valid sound however only if the two functions making up its computational interpretation are total our specific bit representation of parse trees of strings corresponds to composing regular expression parsing with the function of and who attribute the technique to work in the s on text compression with syntactic source information models see references in their paper bit coding captures the idea that only choices tags of sum to be encoded which is also the key idea of coding in proofcarrying code necula and our direct compilation of containment proofs to bit manipulation functions appears to be novel however it should be noted that compaction by bit coding is orthogonal to statistical text data compression as we have illustrated combining them may yield significantly bit strings than either technique by itself type and techniques appear to be applicable to regular expression types et al ab and lu and other extensions notably contextfree languages this remains to be investigated however note that regular expression types are a proper extension of regular expressions as types there are also numerous practically motivated topics to investigate inference of regular type and search for practically efficient coercions implementing them of regular expressions by annotating them automata constructions for fast input processing that yields parse trees and more we hope that this may lead the way to putting logic and computer science into a new generation of expressive generally applicable regular expression processing tools acknowledgements we would like to thank the anonymous reviewers for their critical and constructive comments and for detailed for improvement any remaining problems are solely the authors the first author is to kobayashi and for solving the question of decidability of hereditary totality theorem we would like to thank kozen for sharing many insights on kleene algebras as part of a held at as well as for ideas and suggestions for the for thanks also to for and her work on kleene coalgebras and its relation to regular expressions finally we would like to thank the participants of our course topics in programming languages theory and practice of regular expressions held at in for exploring some of the applications of regular expressions as types completeness is out of the question of course since contextfree grammar containment is not recursively enumerable references m abadi and m p syntactic considerations on recursive types in proc ieee th annual symp on logic in computer science lics new new ieee computer society press june r m and l cardelli subtyping recursive types acm transactions on programming languages and systems toplas ­ september v rewriting regular inequalities in proc th international conference germany volume of lecture notes in computer science lncs pages ­ springerverlag august v partial derivatives of regular expressions and finite automaton constructions theor comput sci ­ doi v m and p d rewriting extended regular expressions theor comput sci ­ doi j s c m and m flexible stub compilation from pairs of declarations in pages ­ c and j typed and unambiguous pattern matching on strings using regular expressions in proc th international acm sigplan symposium on principles and practice of declarative programming m and f coinductive axiomatization of recursive type equality and subtyping ­ j a derivatives of regular expressions acm ­ j doi h chen and r a approach to kleene algebra with tests theor comput sci ­ n on certain formal properties of grammars information and control ­ j h regular algebra and finite machines in gb by william sons isbn r di f pottier and d subtyping recursive types modulo associative commutative products in proc international conference on typed lambda calculi and applications m isomorphisms of generic recursive polynomial types sigplan not ­ doi m p a coinduction principle for recursive data types based on bisimulation information and computation ­ conference version proc th annual ieee symp on logic in computer science lics pp a and l cardelli greedy regular expression matching in proc st international colloquium on automata languages and programming icalp volume of lecture notes in computer science pages ­ july springer v m y and b c pierce recursive subtyping j program ­ a a procedure for checking equality of regular expressions j acm ­ doi c using proofs by coinduction to find traditional proofs in proc st conference on algebra and coalgebra in computer science number in lecture notes in computer science lncs springer september j hopcroft and j ullman introduction to automata theory languages and computation addisonwesley h a and g parametric polymorphism for xml in j palsberg and m abadi editors popl pages ­ acm a isbn x h j and b c pierce regular expression types for xml acm trans program lang syst ­ b institute of and ieee standard for information technology portable operating system interface part and section regular expression notation new york ieee standard p and j programming language extension in proceedings of the th acm sigplansigact symposium on principles of programming languages popl page acm s c kleene representation of events in nets and finite automata automata studies d kozen a completeness theorem for kleene algebras and the algebra of regular events information and computation ­ may d kozen kleene algebra with tests transactions on programming languages and systems ­ may d kozen on the theory of kleene algebra with tests technical report computing and information science cornell university march url d kozen j palsberg and m efficient recursive subtyping mathematical structures in computer science conference version presented at the th annual acm sigplansigact symp on principles of programming languages popl d a complete system of identities in m editor icalp volume of lecture notes in computer science pages ­ springer isbn k z m lu and m rewriting regular inequalities in proc second symposium november volume of lecture notes in computer science lncs pages ­ springer november r milner a complete inference system for a class of regular behaviours j comput syst sci ­ g c necula and s p checking of untrusted software in popl pages ­ l a coinductive axiomatization of xml subtyping term project report university of copenhagen v pratt action logic and pure induction in proc logics in ai european workshop volume of lecture notes in computer science lncs pages ­ springer g and j goguen circular coinduction in proc international joint conference on automated reasoning g and d circular coinduction a proof theoretical foundation in proc rd conference on algebra and coalgebra in computer science number in lecture notes in computer science lncs pages ­ springer september isbn j j m m automata and coinduction an exercise in coalgebra in d sangiorgi and r de editors concur volume of lecture notes in computer science pages ­ springer isbn a two complete axiom systems for the algebra of regular events j acm ­ doi j url a m m and j j m m nondeterministic kleene coalgebras logical methods in computer science url m and k z m lu adding regular expression types to haskell in o z and v editors volume of lecture notes in computer science pages ­ springer isbn g the formal semantics of programming languages an introduction foundations of computing series mit press isbn 