typing for debugging type errors chen school of state university martin school of state university abstract changing a program in response to a type error plays an important part in modern software development however the generation of good type error messages remains a problem for highly expressive type systems existing approaches often from a lack of precision in errors and specifically they either fail to the source of the type error consistently or they report too many potential error locations moreover the change suggestions are often incorrect this makes the debugging process tedious and we present an approach to the problem of type debugging that is based on generating and a set of suggestions specifically we generate all type changes that can possibly fix the type error these suggestions will be and presented to the programmer in an iterative fashion in some cases we also produce suggestions to change the program in most situations this strategy the correct change suggestions quickly and at the same time never misses any suggestions the computation of the potentially set of suggestions is efficient since it is based on a type inference algorithm that type checks a program with variations only once efficiently type information for shared parts we have evaluated our method and compared it with previous approaches based on a large set of examples drawn from the literature we have found that our method other approaches and provides a alternative categories and subject descriptors f logics and meanings of programs studies of program structure d programming languages language functional languages d software engineering testing and debugging general terms languages theory keywords type inference error type error messages choice types change suggestions debugging this work is supported by the national science foundation under the grants and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa acm copyright is held by the publication to acm introduction generating informative and helpful type error messages remains a challenge for implementing type inference algorithms soon after the algorithm w had been developed this problem was rec it has since numerous research efforts ­ although considerable progress has been made there is still no single method that consistently produces satisfactory results most of the existing approaches perform in certain cases as an example consider the following haskell function which checks whether a list is a the first equation for fold contains a type error and should return z instead of z fold f z z fold f z fold f f z x xs flip f x y f y x rev fold flip xs rev xs xs existing tools have difficulties in finding this error for example the glasgow haskell compiler ghc produces the following error message occurs check cannot construct the infinite type t t expected type t actual type t in the second argument of namely xs in the expression rev xs xs while technically accurate the error message doesnt directly point to the source of the error and it doesnt tell the user how it could be fixed either the use of compiler makes the error message difficult to understand for many programmers while giving reasons for the failure of unification might be useful for programmers and type system such error messages still require some effort to manually some of the types and solve unification problems produces a similar error message and from the same problems one of the problems of the approach taken in ghc is that it commits to a single error location because in some cases the program text does not contain enough information to make the right decision about the correct error location this has led to a number of program slicing approaches that try to identify a set of possible error locations instead the basic idea is to find all program positions that contribute to a type error and those that do not for example the type error for sml produces the following for presentation purposes we have slightly the outputs of some tools by changing their indentation and line breaks result we have translated the program into ml for to work fun fold f z z fold f z fold f f zx xs fun flip f xy f y x fun rev xs fold flip op xs fun xs rev xs xs showing too many program locations involved in the type error the value of the slicing approach because of the burden put on the programmer to work through all marked code and to single out the proper error location to address this problem techniques have been developed that try to minimize the possible locations to a type error an example is the type debugger which produces the following output fold f z z fold f z fold f f z x xs flip f x y f y x rev fold flip xs rev xs xs is based on constraint solving and identifies a minimal set of unsatisfiable constraints from which the corresponding places in the program to the type error are derived while is a clear improvement over other slicing approaches in fewer potential error locations a programmer still has to work through several code parts to find the type error in particular out which types should be used at specific locations can be quite time on the other end of the location we find approaches that like ghc or follow johnson and idea of finding the most likely erroneous location and try to add or suggestions for how to correct the error one example is the compiler which was developed to support the of typed functional programming languages a declared focus of is to generate good error messages for our example it produces the following message type error in infix application expression rev xs xs operator type a a bool does not match b b c because unification would give infinite type unfortunately doesnt perform much better than ghc or on this example and provides feedback only in terms of internal representations used by the compiler is a tool for type checking ml programs that also produces change suggestions the type error on the function and suggests the following change since doesnt offer a type option the result is directly from file line characters this expression has type a list list but is here used with type a list relevant code rev xs file line characters try replacing xs rev xs with xs rev xs of type b list b list list bool within context let xs xs rev xs unfortunately the suggested error location is not correct according to and although the suggested change will eliminate the type error it changes the wrong code the suggested change of partially applying to the pair of differently typed lists turns type into a list a list a list list bool change suggestions is a while it can be very helpful in simplifying the task of type errors it can also be sometimes very and when the suggested change doesnt work in the shown example both tools fail to correctly the error location the tasks of debugging type errors seems to be an inherently ambiguous because in some situations there is just not enough information present in the program to generate a correct change consider for example the expression not the error in this expression is either not or but without any additional knowledge about the purpose of the expression there is no way to decide whether to replace the function or the argument this is why it is generally impossible to one point in the program as the source of a type error this fact provides a strong justification for slicing approaches that try to provide an account of error situations on the other hand in many cases some locations are more likely than others and specifically in larger programs information about the context of an erroneous expression can go a long way of a single location for a type error thus a reasonable between slicing and approaches could be a method to compute all possible type error locations together with possible change suggestions and present them and in small portions to the programmer at the core of such an approach has to be a type checker that produces a complete set of type changes that would make the program type correct in this paper we present a method for change inference whose core is a technique to answer the question what type should a particular subexpression have to remove type errors in a program we have also implemented and evaluated a prototype for a type checker that is based on this technique to keep the complexity we only produce socalled atomic type changes that is type changes for the leaves of the programs abstract syntax tree this helps avoid the introduction of too or too extreme changes consider for example the nonatomic type change suggested by for the program which seems to be not realistic or consider changing a whole program to a value of type bool or int which always works but is ever correct however errors that are best fixed by nonatomic expression changes are quite common examples are the of function arguments or the addition of missing function arguments the identification of such nonatomic program changes is not out by it could also be the case that the whole expression is incorrect and should be replaced by something else but we ignore this case for now rank loc code xs rev fold change code of a a a z a a a a a bool a b a a b a to new a b a z a a a a a b a a a b a a result type a bool a bool a bool a b a bool figure list of type and expression change suggestions inferred for the example the approach taken and can actually often be achieved by expression changes from type changes returning to the example figure shows a list of all type changes computed by our prototype that can fix the type error the correct change first in our method note that this is not a representation intended to be given to end users we rather an integration into a user interface in which locations are and over those locations with the will pop up windows with individual change suggestions in this paper we focus on the technical foundation to compute the information required for implementing such a user interface each is essentially represented by the expression that requires a change together with the inferred actual and expected type of that expression since we are only considering atomic type changes this expression will always be a constant or variable in case of a type change but it can be a more complicated expression in case of expression change we also show the position of the code in the program and the result types of the program if the corresponding change is adopted this information is meant as an additional guide for programmers to select among suggestions the list of shown suggestions is produced in several steps first we generate all possible type changes that is even those that involve several locations note that sometimes the suggested types are for example the suggested type for fold is a a a b a a although a b a a b a would be this can be generally attributed to the context of the expression on the one hand the given context can be too restrictive and coerce the inferred type to be more specific than it has to be just as in this example the first argument flip forces fold to have a a a as the type of its first argument on the other hand the context could also be too there is no information about how fold is related to in the fourth line of the program thus the type of the second argument of fold is inferred as b this cant be by exploiting type information of the program second we filter out those type changes that involve only one location we present those first to the programmer since these are generally easier to understand and to adopt than change suggestions should the programmer reject all these suggestions suggestions will be presented next and so on third in addition to suggestions we also try to infer some nonatomic expression changes from type changes in general only the programmer who the program knows how to translate required type changes into expression changes however there are a number of common programming such as or arguments that are indicated by suggestions similar to our prototype identifies our prototype represents z as z we have added the line and column numbers by hand since our prototype currently works on abstract syntax and doesnt have access to the information from the parser these kind of changes that are mechanical and do not require a deep understanding of the program semantics in our example we infer the replacement of z by z because the expected type requires that the return type be the same as the first argument type we thus suggest to use the first argument that is z to replace the application z note however that we dont infer a similar change for the fifth type change because fold is partially applied in the definition and we have no access to the third argument of fold had the rev function been implemented using an list argument say xs we would have also inferred the to change fold flip xs to xs note also that we do not suggestions with atomic expression changes for example in the second we do not suggest to replace xs by xs there are two reasons for this on the one hand we believe that given the very specific term to change the inferred type and the expected type the corresponding required expression change is often easy to deduce for a programmer on the other hand specific expression changes requires knowledge about program semantics that is in many cases not readily available in the program thus such suggestions can often be finally all the suggestions are according to a few simple but effective complexity heuristics at the core of the proposed method is a type system for inferring a set of suggestions this type system is described in detail in section we show that the type system generates a complete and correct set of atomic type change suggestions the type system is based on a systematic variation of the types of atomic expressions in a program therefore some background information on how to represent variation in expressions and types how to make use of it for the purpose of type inference and what technical challenges this is provided in section equipped with the necessary technical background the behind inference can then be explained on a high level in section the algorithmic aspects of type inference and some measures for controlling runtime complexity are discussed in section we also briefly describe a set of heuristics that we use for ranking change suggestions the method of expression changes from type changes is discussed in section we have evaluated our prototype implementation by comparing it with three closely related tools and found that typing can generate correct change suggestions more often than the other approaches the evaluation is described in section related work is discussed in section and conclusions presented in section complete this paper typing the idea of type change inference is to explicitly represent and reason about between inferred and expected types that are detected by the type checker this idea can be realized in different ways and the cf type inference presented in this paper is just one of this more general strategy in this section we will introduce the idea of typing and some technical machinery that will then be employed to formalize type change inference first the goal of cf type inference is to generate suggestions for how to change types and expressions in a program to fix a type error both kinds of changes will be represented using the generic choice representation of the choice calculus that was introduced in the first application of this representation in the context of type checking was to extend type inference to program families that is a set of related programs we will introduce the concept of choices expressions and types and some related concepts in section second when type checking a program family it is important to obtain the types of some programs family members even if the typing of other programs fails this leads to the notion of partial types typing patterns and an associate method for partial unification the application rule will be further generalized to accommodate partial types we will explain these concepts in section expressions and types the choice calculus provides a way of representing variation in software the most important concept is the named choice which can be used to represent variation points in both expressions and types for example the expression e not a true contains the named choice a that represents a choice between the two constants and true as the argument to not the process of eliminating a variation point is called selection selection takes a selector of the form di where d is the name of the variation point traverses the expression and replaces all the variation points named d with its corresponding ith alternative in this paper we are only concerned with binary choices that is i will be either or for example selecting a from e yields the plain expression not plain expressions are obtained after all choices are eliminated from a expression note that variation points with different names vary independently of one another and only those with the same name are synchronized during selection for example the expression a odd not a true represents only the two expressions odd and not true while a odd not b true represents the four expressions odd odd true not and not true through the use of independent choices programs can very quickly encode a number of programs that differ only slightly ensuring the type correctness of all plain programs is challenging because the approach of generating and checking each variant is generally infeasible typing solves this problem by introducing types and a method for typing programs in one run the result of type checking a program is a type from which the types for individual program variants can be obtained with the same selection as the program is derived the syntax of types is shown below where ranges over type variables and ranges over type constants d the type is used to denote the occurrences of type errors and will be discussed in section under typing the expression a odd not has the type a int bool bool bool the most important property of typing is that the type for each plain expression selected from the expression can be obtained through the same from the corresponding type for example selecting a from both the expression and type the expression not has the type bool bool typing patterns d d d d d d otherwise × d d d d d d d × d d × d d figure operations for typing applications an important technical part of typing is the fact that the equivalence of choices is not merely but by a set of equivalence rules originally described in for example a int int is equivalent to int written as a int int int since either decision in a yields int the equivalence relationship plays an important part in and a challenge to the unification of types for details we refer to a of the typing approach is that it can succeed only if all variants are well typed that is it is impossible to assign a type to the expression a odd not even though one of its variants is type correct typing addresses this issue typing the idea of typing is to assign the type to program variants that contain type errors the explicit representation of type errors via as normal types supports the continuation of the typing process in the presence of type errors moreover each program can be typed and the resulting type contains for all variants that are type incorrect and a plain type for all variants for example a odd not has the type a bool which encodes exactly the types that we obtain if we generate and type each expression separately the most challenging part of the type system is the handling of function applications because type errors can be introduced in different ways for example the function might not have an arrow type or the type of the argument might not match the argument type of the function moreover we have to consider the case of partial matching that is in the case of types the argument type of the function and the type of the argument might be compatible for some variants only deciding in such a case that the whole application is of type would be too restrictive this challenge is addressed by the following typing rule e e e e the first two premises the types for the function and argument unlike in the traditional application rule however we do not require to be a function type instead the third premise tries to lift into an arrow type using a function that is defined at the top of figure lifting specifically accounts for the case in which is a choice between arrow types as in a bool bool int bool a bool int a bool bool and it also deals with and introduces if necessary error types for example a int bool int can succeed only by introducing an error type and thus yields a int a bool the fourth premise computes a typing pattern that records to what degree that is in which variants the type of e matches the argument type of the partial arrow type obtained for e as can be seen in figure a typing pattern is a possibly nested choice of the two values type error and typing success the computation of a typing pattern proceeds by induction over the type structure of its arguments note that the definition given in figure contains overlapping patterns and assumes that more specific cases are applied before more general ones when two rules are equally applicable the computed result is equivalent modulo the relation note also that we employ the notation x for a sequence of alternatives x xn types or expressions used within choices in figure this applies only to the case n for two plain types matching reduces to checking equality for example int int and int bool on the other hand matching a plain type with a type results in a choice pattern for example int d int bool d note that for two arrow types to be matched successfully both their corresponding argument types and return types have to be matched successfully there is no partial matching for function types we define the operation to achieve this which is also presented in figure we can essentially view it as the logical and operation if we treat as true and as false for example when computing int a bool int b int bool we first obtain b and a for matching the argument types and return types respectively next we use to derive the final result as a b in the fifth and final premise the typing pattern is used to preserve the type errors that the fourth premise has potentially produced this is done by the return type with the typing pattern the operation essentially replaces all the s in the typing pattern with the variants in the return type and leaves all s unchanged denoting the occurrences of type errors to see the application rule in action consider the expression a not odd b true the first two premises produce the following typing judgments a not odd a bool bool int bool b true b int bool lifting transforms the type of the function into a bool int a bool bool which is equivalent to a bool int bool the computation of a bool int b int bool yields a b b and the return type of the function bool with yields a b bool b bool typing the main idea behind typing is to systematically vary parts of the illtyped program to find changes that can eliminate the corresponding type errors from the program it is infeasible to apply this strategy directly on the expression level since there are generally infinitely many changes that one could consider therefore we perform the variation on the type level basically we ask for each atomic expression e the question what type should e have to make the program well typed the reasoning is built into the type checking process in the following way to determine the type of an expres sion e we first infer es type say but then instead of this type we leave the decision open and assume e to have the type d where d is a fresh name and is a fresh type variable by leaving the type of e open to we account for the fact that e may in fact be the source of a type error by choosing a fresh type variable for es alternative type we enable type information to flow from the context of e to an alternative type that into the context in case doesnt if does fit the context it is with and the choice could in principle be removed however this is not really necessary and we in fact dont do this since in case of a program we can find the type at the end of the typing process by simply selecting the first option from all generated choices let us illustrate this idea with a simple example consider the expression e not if we vary the types of both not and we obtain the following typing judgments not a bool bool b int where and represent the expected types of not and according to their respective contexts to find the types and we have to solve the following unification problem a bool bool b int where denotes the result type of the application and denotes that the unification problem is solved modulo the type equivalence relation mentioned in section rather than the usual identity another of the unification problem is that two types may not be in that case a solution to the unification problem consists of a socalled partial unifier which is both most general and introduces as few errors as possible the unification algorithm developed in achieves both these goals for the above unification problem the following unifier is computed the generality introduced by and ensures that only the second alternatives of choices a and b are constrained a b int b a bool a bool additionally the unification algorithm returns a typing pattern that characterizes all the variants and helps to compute the result type of the expression in this case we obtain a b based on the unifier and the typing pattern we can compute that the result type of the expression of not is a b bool from the result type and the unifier we can draw the following conclusions · if we dont change e that is we select a and b from the expression the type of the expression is the variant corresponds to a and b in the result type which reflects the fact that the original expression is ill typed · if we vary not to some other expression f that is if we select variant a and b from the result type the result type will be moreover the type of f is obtained by selecting a and b from the type that is mapped to which yields int in other words by changing not to an expression of type int not becomes well typed in the larger context may be further constrained to have some other type · if we vary to some expression g that is if we select a and b from the type then the result type becomes bool · if we vary both not to f and to g which means to select a and b the result type is moreover from the unifier we know that f and g should have the types and respectively term variables x y z type variables value constants c type constants expressions e f c x xe e e let x e in e if e then e else e types d type schemas selectors s di type environments x substitutions choice environments l d figure syntax of expressions types and environments this gives us all atomic type changes for the expression not the combination of creating variations at the type level and typing provides an efficient way of finding all possible type changes inference this section presents the type system that generates a complete set of atomic type changes after defining the syntax for expressions and types in section we present the typing rules for inference in section in section we investigate some important properties of the inference system syntax we consider a type checker for lambda calculus with figure shows the syntax for the expressions types and meta environments for the type system we extend the bar notation to other sequences of elements such as bindings both the definitions of expressions and types are conventional except for types which introduce choice types and the error type we use l to denote program locations in particular leaves in we assume that there is a function e f that returns l for f in e for presentation purposes we assume that f uniquely determines a location we may omit the subscript e when the context is clear the exact definition of · does not matter as usual binds type variables to type schemas for storing typing assumptions we use to denote type substitutions that map type variables to types the metavariable ranges over type substitutions that are for types or partial for types finally we use the choice environment to associate choice types that were generated during the typing process with the corresponding location in the program operations on types can be lifted to by applying them to the types in we the conventional definition of fv that computes the free type variables in types type schemas and type environments we write s for s the application of a type substitution to a type schema is written as and replaces free type variables in by the corresponding in the definition is as follows d d if dom if note that we do not consider polymorphic types this is not a problem since we can always lift quantifiers out of choices for instance d can be transformed to e con c is of type d fresh c d c d var x d fresh x d x d x dom d fresh x d x d abs x e xe let x e fv fv x e let x e in e app e e e e if bool ei iii if e then e else e figure rules for inference d with fv and fv and and typing rules figure presents the typing rules for inferring type changes the typing judgment is of the form e and produces as a result a type that represents all the typing potential for e plus a set of type changes for the atomic subexpressions of e that will lead to the types in since we are only interested in atomic changes during this phase we only vary the leaves in the ast of programs which are constants and variable references this is reflected in the typing rules as we generate fresh choices in rules con var and in each case we place the actual type in the first alternative and an arbitrary type in the second alternative of the choice when an variable is accessed it causes a type error we thus put in the first alternative of the choice the rules abs and let for abstractions and are very similar to those in other type systems except that variables are bound to types the rule app for typing applications is very similar to the application rule discussed in section the only difference is that the rule here keeps track of the information for the if rule the same machinery as the app rule for the potential introduction of type errors and partially correct types in particular the condition e is not strictly required to have the type bool however only the variants that are equivalent to bool are type correct likewise only the variants in which both branches are equivalent are type correct d l d ¬ d l d l d s s b bi i bi s s s b ai b ai if a b figure simplifications and selection properties in this section we investigate some important properties of the inference system we show that it is consistent in the sense that any type selected from the result type can be obtained by applying the changes as indicated by that selection we also show that the inference is complete in finding all atomic type changes based on this result we also show that the inference system is a conservative extension of the hindleymilner type system hm we start with the observation that inference always succeeds in deriving a type for any given expression and type environment lemma given e and there exist and such that e the proof of this lemma is obvious because for any construct in the language even for variables there is a corresponding typing rule in figure that is applicable and returns a type next we need to simplify in the judgment e to investigate the properties of the type system specifically we define a simplification relation in figure that eliminates idempotent choices from note that the purpose of simplification is to eliminate choice types that are equivalent to or equivalently remove all positions that dont contribute to type errors thus there is no need to simplify types nested in choice d in figure also we formally define the selection operation s in figure selection extends naturally to lists of selectors in the following way s s s s next we want to establish the correctness of the inferred type changes formally a type update is a mapping from program locations to the intended meaning of one particular type update l is to change the expression at l to an expression of type we use to range over type updates a type update is given by the locations and the second component of the corresponding choice types in the choice environment we use · to extract that mapping from the definition is l l d for the time being we assume that all the alternatives of choices in are we will lift this restriction later for example with l a int bool we have l bool the application of a type update is part of a type update system that is defined by the set of typing rules shown in figure these typing rules are identical to an ordinary hindleymilner type system except that they allow to the types of atomic expressions according to a type update that is a parameter for the rules we only show the rules for constants variables and applications since those for abstractions and are obtained from the hm ones in the same way as the application rule by simply adding the parameter we write more e for e and we use the notation e to pick the type e if e is defined and otherwise c is of type c c x x x e e e e figure rules for the system the rules and employ a type update if it exists otherwise the usual typing rules apply rule the application of change updates to subexpressions since we are considering atomic change suggestions only we can now show that by applying any of the inferred type changes using the rules in figure we obtain the same types that are encoded in the type potential computed by inference we employ the following additional notation we write for the list of selectors d for each choice d in for example a int bool b bool int a b formally we have the following result we assume that has been simplified by in figure and the alternatives of choices in are plain as mentioned before theorem inference is consistent for any given e and if e and there is some such that then e moreover the inference is complete since it can generate a set of type changes for any desired type theorem inference is complete for any e and if e then there exist and a typing derivation for e such that and the proofs for these two theorems can be constructed through an induction over the typing derivations of both type systems in particular note that constants and variable reference have the same type in these two systems regardless of whether or not they are changed the introduction of arbitrary alternative types in rules con var and are the reason that inference is highly nondeterministic that is for any expression e we can generate an arbitrary number of type derivations with different type and corresponding type changes many of those derivations dont make much sense for example we can derive a int bool where a int bool however since the expression is type correct it doesnt make sense to suggest a change for it on the other hand the illtyped expression e not succ can be typed in two different ways that can correct the error yielding two different type and type changes we can either suggest to change succ to an expression of type int bool or we can suggest to change not into something of type int the first is obtained by a derivation for e a with a bool bool int the second is obtained by a derivation for e b bool with b int int int bool interestingly we can combine both suggestions by deriving a more general typing statement that is we can derive the judgment e a b bool b where a bool bool b int b int int a int bool int we can show that the third typing is better than the first two in the sense that its result type a contains fewer type errors than either of the result types and b is more general for example by selecting a b from both result types we obtain and bool respectively making the same selection into the third result type we obtain bool likewise when we select with a b we get the types and respectively for each selection the third result type is better than either one of the first two in the following we show that this is not an but that we can in fact always find a most general change from which all other suggestions can be instantiated first we extend the function to take as an additional parameter a list of selectors s we also extend the definition to work with general types and not just s l s l d d s intuitively we consider all the locations for which the second alternative of the corresponding choices are chosen we need to apply the selection s because each type may include other choice types that are subject to selection by s next we will show that inference produces most general type changes from which any individual type change can be instantiated we observe that type and type changes can be compared in two different ways first the result of inference can be more defined than another result which means that for any s for which s yields a then so does s second a result can be more general than another result written as if there is some type substitution such that similarly we call a type update more general than another type update written as if dom dom and there is some such that for all l l l since we have these two different relationships between type changes we have to show the generality of inference in several steps first we show that we can generalize any type change that produces a type error in the resulting type for a particular selection when there is another type change that does not produce a type error for the same selection lemma most defined type changes given e and and two typings e and e if s and s then there is a typing e such that · s s and for all other s s s · s s and s s for all other s next we show that given any two type changes we can always find a type change that generalizes the two lemma of type changes for any two typings e and e if neither s s nor s s holds there is a typing e such that · s s s s and for all other s s s · s s s s and for all other s s s we can now combine and generalize lemmas and and see that inference can always produce and general results at the same time this is an important result captured in the following theorem theorem most general and type changes given e and and two typings e and e there is a typing e such that for any s · if s and s then s and s s · if s and s then s and s s · if s and s then s and s moreover s s and s s the proofs for lemma lemma and theorem can be established by showing that in each derivation step the result types from two derivations can always be combined into the result type for a third derivation such that the new result type is both more general and contains fewer errors the key we need is that given a type we can change the type for a specific variant and leave all other variants unchanged from theorems and it follows that there is a typing for complete and principal type changes we express this in the following theorem theorem complete and principal type changes given e and there is a typing e such that for any if e then there is some s such that s and s finally there is a close relationship between inference and the hm type system when inference succeeds with an empty set of type changes it produces a type that is identical to the one derived by hm this result is captured in the following theorem where we write e to express that expression e has the type under in the hm type system theorem for any given e and e e based on theorem theorem theorem and the fact that we can infer that when a program is well typed the type system and the hm system produce the same result theorem e if and only if e note that e implies that e and this theorem also implies that inference will never assign a to a program a change inference algorithm this section presents an algorithm for inferring type changes we will discuss properties of the algorithm as well as strategies to bound its complexity given the partial type unification algorithm presented in the inference algorithm is obtained by a straightforward translation of the typing rules presented in figure the cases for variable reference and if statements are shown below function application is very similar to if statements and the cases for abstractions and can be derived from w by simply adding the of infer × e × × infer x ­ returns when x is d ­ d and are fresh return x infer if e then e else e infer e bool infer e infer e return for variable reference the algorithm first tries to find the type of the variable in and either the found type schema with fresh type variables or returns if the variable is after that a fresh choice containing a fresh type variable is returned the variable then has the returned choice type with the inferred type in the first alternative and the type variable in the second for typing if statements we use an algorithm for partial unification in addition to a partial unifier a typing pattern is generated to describe which variants are unified successfully and which see section otherwise the algorithm follows in a straightforward way the usual strategy for type inference we can prove that the algorithm infer correctly implements the typing rules in figure as expressed in the following theorems theorem inference is sound given any e and if infer e then e at the same time the type inference is complete and principal we use the auxiliary relation to express that for any s either s or s s intuitively this expresses that either the corresponding variant in is more general or more correct we also define if for any l and l the condition holds theorem inference is complete and principal if e then infer e such that for some and from theorems and it follows that our inference algorithm correctly computes all type changes for a given expression in one single run during the inference process choice types can become nested and the size of types can become exponential in the nesting levels fortunately this occurs only with deep of function applications where each argument type is required to be the same for example the function f is more likely to cause this problem than the functions g n and h because only the function f requires all argument types to be unified which causes choice nesting to happen to keep the runtime complexity of our inference algorithm under control we eliminate choices beyond an nesting level that satisfy one of the following conditions a choices whose alternatives are and b choices whose alternatives contain errors in the same places these two conditions ensure that the eliminated choices are to contribute to type errors there are cases in which this strategy fails to eliminate choices but this happens only when there are already too many type errors in the program and we therefore stop the inference process and report type errors and change suggestions found so far this strategy allows us to maintain choices whose corresponding locations are likely sources of type errors and discard those that note however that this strategy the completeness property captured in theorem we have evaluated the running time and the precision of error against the choice nesting levels see section we observed that only in very cases will the choice nesting level reach a value that typing is able to deal with finally we briefly describe a set of simple heuristics that define the ranking of type and expression changes we prefer places that have expression changes see section because these changes reflect common editing we changes that are lower in the abstract syntax trees because changes at those places have least effect on the context and are least likely to introduce results we prefer changes that have minimal shape difference between the inferred type and the expected type for example a change that doesnt influence the of function types is higher than a change that does change expression changes while it is generally impossible to deduce expression changes from type changes there are several situations in which type changes do point to likely expression changes these situations can be identified by unifying both types of a type change where the unification is performed modulo a set of axioms that represent the pattern inherent in the expression change as an example consider the following expression xy xy our type change inference suggests to change from its original type a b c a b c to something of type int int int d given these two types we can deduce to curry the first argument to the function to remove the type error at the same time we substitute d in the result type with int by unification modulo different theories has developed a theory and an algorithm to systematically deduce changes of this sort we have adopted this approach and extended it slightly for expression changes such as the arguments of function calls and uncurrying of functions or adding and removing arguments of function calls the extension is based on a simple form of identifying type changes such a change is used to modify the types then approach is applied and the result is then interpreted in light of the type change as a new form of expression change as an example here is the method of identifying the addition or removal of arguments to function calls in this case the differences in the two types to be unified will lead to a type change that pads one of the types with an extra type variable for example given the inferred type and the expected type we turn the first type into the application of approach suggests to swap the arguments also is mapped to interpreting the through the type change of we deduce the removal of the second argument besides these systematic change we also support some adhoc expression changes specifically we infer changes by the expected type only for example if the inferred type for f in f g e is b c while the expected type is a b a c we suggest to change f g e to f g e another example are situations in which the result type of an expected type matches exactly one of its several argument types in that case we suggest to replace the whole expression with the corresponding argument this case applies in fact to the example where the type change for is to replace a a a by a b a we therefore infer to replace z which is z by z because the first argument type is the same as the return type another case is when in expression f g h the expected type for f is a b a b then we suggest to remove f from the expression there are more such adhoc changes that are useful in some situations but we will not discuss them here in section we will compare our method with original here we only note that the success of the method in our prototype depends to a large degree on the additional information provided by inference specifically the more precise and less expected types that are used for the unification evaluation to evaluate the and efficiency of the typing approach we have implemented a prototype of inference and deduction in haskell in addition this example is adapted from where is called map examples with oracle ambiguous examples never complete partial incorrect cf typing ghc figure evaluation results for different approaches over collected examples in to the constructs shown in section the prototype also supports some minor straightforward extensions such as data types and case expressions we compare the results produced by our cf typing tool to and ghc there are several reasons for selecting this group of tools first they provide currently running implementations second these tools provide a similar functionality as cf typing namely type errors and presenting change suggestions both at the type and the expression level we have slicing tools from the comparison because they only show all possible locations and dont suggest changes for evaluating the applicability and accuracy of the tools we have a collection of examples from about these papers include recent phd and papers that represent most recent and work these papers cover many different of the debugging problem including error slicing explanation systems reordering of unification automatic and interactive debugging since the examples presented in each paper have been carefully chosen or designed to illustrate important problem cases for debugging we have included them all except for examples that involve type classes since our tool as well as doesnt currently support type classes this exclusion did not have a significant effect we unique examples regarding type classes involved in type errors discussed in both ghc and were able to produce a helpful error message in only case otherwise the examples range from very simple such as test map even to very complex ones such as the example introduced in we have the examples into two categories the first group with oracle contains examples for which the correct version is known because it either is mentioned in the paper or is obvious from the context the other group ambiguous contains the remaining examples that can be reasonably fixed by several different changes for the examples in the with oracle group we have recorded how many correct suggestions each tool can find with at most n attempts for the examples in the ambiguous group we have determined how often a tool produces a complete partial or incorrect set of suggestions for example for the expression f g a f a f g a g true which is given in suggests to change true to something of type int while this is correct there are also other changes possible for example changing f to f true since these are not mentioned the result is as partial figure presents the results for the different tools and examples with unconstrained choice nesting level for cf typing note that output is considered correct only when it points to the correct location and produces an error message that is not simply a unification failure or some other point there are a few interactive approaches that have been proposed but they do currently not provide running implementations moreover has to focus on typing extensions of the haskell type system since the tool has off its facilities it is not a candidate for comparison running time s cf typing examples figure running time for typing x of the examples times of view we have included ghc only as a since it is widely known the comparison of effectiveness is meant to be between cf typing and the numbers show that cf typing performs overall best even if we only consider the first change it which comes in second taking into account second and third suggestions up but cf typing performs even better in cases where produces multiple suggestions all suggestions are wrong for cf typing out of the correct suggestions that is are expression changes for the numbers are out of or and for it is out of or this shows that produces a higher rate of expression change suggestions at a lower overall correctness rate most of and failures are due to identified change locations another main reason for incorrect suggestions is that it introduces too extreme changes in several cases change doesnt fix the type error most cases for which cf typing fails are caused by missing parentheses for example for the expression print a b our approach suggests to change print from the inferred type a io to the type string string or change from the expected type a a a to the inferred type io string string neither of the suggestions allows us to deduce the of the expression to summarize since the examples that we used have been designed to test very specific cases the numbers do not tell much about how the systems would perform in practice they provide more like a test for the tools but the direct comparison shows that cf typing performs very well compared with other tools and thus presents a alternative to type debugging with the help of typing we can generate all the potential changes very efficiently the running time for all the collected examples is within seconds figure shows the running time for both our approach and for processing the reported examples for each point x y on the curve it means that x of all examples are processed with y seconds the running time for our approach is measured on a with a dual core processor and gb ram running windows xp and ghc the running time for is measured on the same machine with the purpose of the graph is simply to demonstrate the feasibility of our approach second we have evaluated how increasing levels of choice affect the efficiency of the inference algorithm and how putting a limit on maximum nesting levels as described in section can efficiency at the cost of precision for this purpose we have automatically generated large examples and we use functions of types like to trigger the choice elimination s running time s precision time precision choice nesting levels figure limits on choice nesting efficiency for precision discussed in section we first generated type correct examples and then introduced one or two type errors in each example by changing the leaves arguments and so on each example contains about nodes in its tree representation figure presents the running time and precision against choice nesting levels for these generated examples a change is considered correct if it a type error and appears among the first four changes for that example precision is measured by the number of examples that have correct change suggestions over the number of all examples from the figure we observe that a nesting level between and achieves both high precision and efficiency related work we have our discussion of related work according to major features shared by the different approaches single locations most of the ap are based on some variant of the algorithm w and report an error as soon as the algorithm fails since the original algorithm w is in the order in which unification problems are solved which has a negative impact on errors many approaches have tried to eliminate this examples are algorithms m g w sym and m sym and and i ei all these algorithms interpret the place of unification failure as the source of the type error in contrast johnson and and the tool use heuristics to select the most likely error location from a set of potential places although heuristics often work well and lead to more accurate locations they can still get due to the constraint in contrast we explore all potential changes and rank them from most to least likely in expression changes from type changes we have used an extension of technique since his ap is based on the algorithm w it from the of error mentioned above moreover his approach doesnt have access to the precise expected type which helps in our approach to ensure that expression changes will not have an impact on the program as a whole type conflicts some approaches have focused on identifying and the causes of type conflicts wand records each unification step so that they can be tracked back to the failure point and on the other hand record the reason for each unification that is being performed and and yang produce textual explanation for the cause of the type errors while these techniques can be useful in many cases there are also potential first the explanation can become quite and and the size grows as the program size increases second the explanation is inherently coupled to the underlying algorithm that performs the inference thus knowledge about how the algorithms work is often needed to understand the produced messages third the usually lead to the failure point which is often the result of unification and not the true cause of the type error finally although a potential fix for the type error may in the middle of the explanation chain its not always clear about how to exploit it and change the program interactive debugging while many tools attempt to improve the static presentation of type error information interactive approaches give users a better understanding about the type error or why certain types have been inferred for certain expressions consequently several approaches to interactive type debugging have been the ability to infer types for variables enable a type debugging paradigm that is based on the idea of replacing a program by a fresh variable if such replacement leads to a type correct program then the error location has been identified however the original system proposed by and requires users to do these steps manually later automated this process by systematically out parts of the program and running the type checker iteratively since type changing is based on unification it can again introduce the problem also it is how to handle programs that contain more than one type error through a number of different techniques and and have developed tools that allow users to explore a program and the types for any subexpression also allows users to query how the types for specific expressions are inferred all these approaches provide a mechanism for users to explore a program and view the type information however none of them provides direct support for finding or type errors error slicing the main advantage of slicing approaches is that they return all locations related to type errors the is that they cover too many locations recent improvements in have to reduce the number of locations but the problem still recall the example in the introduction moreover slicing tools do not provide suggestions of how to get of the type error like error slicing approaches our cf typing approach is complete in not missing any potential change however the changes we presented to users involve fewer locations usually users have to focus on only one location and its suggestions for type changes type uncertainty similar to choice types sum types can also encode many types and developed a type system based on sum types to record the causes of type errors specifically they place two types into a sum type technically named choice types provide more finegrained control over variations in types than sum types while sum types are unified this is only the case for choice types of the same name each alternative in a choice type is unified with all the alternatives in other choices with different names also their system returns a set of sources related to type errors thus it can be viewed as an error slicing approach however compared to other slicing approaches it is not guaranteed that the returned set of locations is minimal moreover the approach doesnt provide specific change locations or change suggestions typing by searching cf typing and could both be called search based although the search happens at different levels while cf typing changes on the type level works on the expression level directly which makes it impossible for to generate a complete set of suggestions given an illtyped program first has to decide where the type error is uses a binary search to the erroneous place this way of searching causes to make in errors when the first part of the program itself doesnt contain a type error but actually type errors because its too constrained for example the cause of the type error in the example discussed in section is the fold function which is itself well typed as a result fails to find a correct once the problematic expression is found searches for a program by creating of the original program for example by the arguments to functions or uncurrying function calls and so on compared to our change deduction approach this has both advantages and in some cases it can find a correct change while our approach fails to do so as for example in the problem discussed in section on the other hand its power to generate arbitrarily complicated changes can lead to suggestions such as the to change xs rev xs to xs conclusions we have presented a new method for debugging type errors the approach is based on the notion of typing which is the idea of systematically varying the types of all atomic program elements to generate a typing potential for the erroneous program that can be explored and about we have exploited this typing potential and the associated set of type changes to create a list of and suggestions that can eliminate type errors from programs a comparison of a prototype implementation with other tools has demonstrated that the approach works very well and in fact its in future work we plan to investigate other uses of typing and type changes for example the integrated representation provides opportunities for defining type queries that can be used to examine programs and also form the basis for sophisticated user interfaces to support more interactive forms of type debugging we also plan to investigate how well the approach works for the debugging of type errors in richer type systems references m and r type errors in polymorphic languages acm letters on programming languages and systems ­ k l and e w debugging type errors technical report state university of new york at b there is hope for your type errors in int workshop on implementation of functional languages s chen m and e an type system for lambda calculus in acm int conf on functional programming pages ­ s chen m and e extending type inference to programs acm trans on programming languages and systems to appear o compositional explanation of types and algorithmic debugging of type errors in acm int conf on functional programming pages ­ september v unification with application to of type inference phd thesis university l and r milner principal for functional programs in acm symp on principles of programming languages pages ­ d and f type inference in science of computer programming pages ­ h eo o lee and k yi proofs of a set of hybrid type inference algorithms new generation computing ­ m and e the choice calculus a representation for software variation acm trans on software engineering and methodology ­ c and j b type error slicing in implicitly typed higherorder languages in european symposium on programming pages ­ b d and a van for learning haskell in proceedings of the acm sigplan workshop on haskell haskell pages ­ new york ny usa acm b j top quality type error messages phd thesis the sept g f johnson and j a a approach to isolation in incremental type inference in acm symp on principles of programming languages pages ­ o lee and k yi proofs about a type inference algorithm acm trans on programming languages and systems ­ july o lee and k yi a generalized type inference algorithm technical report technical research on program analysis system advanced institute of science and technology b m d and c chambers searching for messages in acm int conf on programming language design and implementation pages ­ b d and c chambers searching for ml messages in workshop on ml pages ­ b j type errors in functional programs phd thesis university of edinburgh college of science and engineering school of b j type errors in functional programs phd thesis for foundations of computer science the university of edinburgh m and p sum types the source of type errors in acm int conf on functional programming pages ­ t type error slicing in in functional programming pages ­ springer p j m and j interactive type debugging in haskell in acm sigplan workshop on haskell pages ­ f tip and t b a approach for type errors acm trans on software engineering and methodology ­ jan m wand finding the source of type errors in acm symp on principles of programming languages pages ­ j r type inference and type error for hindleymilner with extensions phd thesis the university of january j yang type errors by finding the source of a type conflict in in functional programming pages ­ j yang improving polymorphic type phd thesis university may j yang g p and j b improved type error in int workshop on implementation of functional languages pages ­ 