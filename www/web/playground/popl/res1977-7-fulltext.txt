of a graph grammar for control analysis dept of mathematical rice university texas sciences i introduction a standard approach to the analysis of program structure construct the control flow graph which models the possible for the purpose of code optimization execution paths through the program is to various graph algorithms etc can be applied to the control flow graph to produce data flow information possible studies of the typical control flow graphs indicate that such graphs tend to fall into a restricted subclass of general graphs for example empirical have shown the of program graphs have no multiple entry loops the recent work on structured programming has suggested that good programs fall into an even more restricted structures subclass sequential in fact that all programs be synthesized from three basic control statements ifthenelse statements and loops formal language theory has given us a practical way to specify the set of strings which com a given language via a grammar it is then a natural idea to extend grammars from the strings graphs in of getting the same power of expression several researchers have used this approach to in this paper we study the applicability of a approach to describing the set of control flow graphs which arise from good programs in the sense proposed by many programming resulting flow graph language contains all those programs constructed according to the rules the and also admits with loops if such loops are constructed the grammar we use is the flow graph which was studied originally in there are several properties of this grammar perhaps the most important from the of a is the existence of a parsing algorithm which leads directly to a data flow analysis method in the present work we summarize the results from and address several new questions first how often do programs written by people with no knowledge of the rules fall into the language defined by in other words is the language a natural one for programming second once a program has been parsed according to do benefits other than fast data flow analysis the paper is organized into three main sections section ii introduces and the parsing algo rithm from answer the graph parse suggestions section iii is question of in a graph attribute for further investigation to an empirical study described above section iv discusses grammar framework the summary at the by the authors in an attempt several applications of the end of the paper includes to ii the grammar the flow graph grammar consists of the rules depicted in figure work supported by the national science foundation department of mathematical sciences rice university division of computer research grant c single terminals exit basic block block with test rules h le non terminals computation region start node decision region cc d i cd l dc dd figure note jump which that the two terminal symbols represent blocks of at the end the two represent computation region may do some computation but also makes a decision at some point the family of flow graphs is the set of graphs which code with and without a conditional with one exit and a decision region about which exit to take can be generated by applying the rules f ble if m note that rules and allow various consider the graph depicted in figure a graph r is said to be this is an example graph taken from figure graph a derivation for the ble can be determined member of the graph is shown in by applying the parsing parsing algorithm returns figure whether or not a particular algorithm presented in if the the sequence of productions required flow graph is graph is a to reduce it to a single node otherwise for completeness the algorithm halts we include an outline with a report of the parse of failure algorithm algorithm p parse outline r a graph a list l of nodes in straight u order the visit by depthfirst search r a parse p otherwise the answer no reverse of the order of last method visit a entry node apply all reduction of r pr reductions takes place remove a from possible false with a as otherwise l u header set add reductions success to linked predecessor of all i success g is linked its to predecessor successors then else ab ql then u a null to true if at least one r make a the unique else a next node from l u remove a from l u g q od i t is now a single computation node then return rp else return no end algorithm furthermore p properly implemented arbitrary graphs in time linear in the parse leads to a algorithm for data flow analysis it was shown in that the family admits many graphs produced the size of the graph on members of through the use of control structures suggested as extensions natural set of am from those results we were structured concepts fall naturally for structured programming control structures w and led to the question into that question examples are control structure the counterexample of and manna how many programs written with or without led us to the investigation described in the next section iii the empirical study for our study of the structure of typical application programs we decided since there exist numerous scientific applications in that language structures do not particularly good programming the next step was to acquire programs for the study members of the rice us with an supply which we into the following groups to look at fortran programs and since the control provided fortran programs written by in an engineering class where was not the sample represented solutions to two problems structured programming a find the roots of a b compute the time to target and range equation and the required from the for a with given two subroutines function for a compound during routines were as much as ten years from a large dept application to construct using the method old and many had been written at other the the dept routines used to calculate in a structure application and functions for certain data dept routines to deduce structure a large system for analyzing cc t dc a lo j jc figure derivation of graph five routines via used by the a simulation dept to determine mean square of macro structure separation of routines two mathematical sciences dept applications a a finite element metric elements differential equation solver which uses a procedure and b a collection equations of hi procedures for solving quadratic partial differential routines from two dept programs a a program by solving which solves the free problem a system of coupled partial differential for a with equations variable b a program which simulates the slow flow of under given boundary conditions all in a total of five e and how many were routines were analyzed to determine the results are summarized how many were in table below group number of programs number of reducible reducible reducible of reducible programs reducible total table analysis the last column indicating the percentage of reducible programs which are also is worth comment since most fast data flow analysis routines work for reducible programs one should compare the method with those for applicability the last column in table indicates that the method would work in nearly of those cases which could be handled by one of the fast nonlinear methods overall more than four out of five of these programs all written without the benefit of structured programming were though we were with this result we were by the of groups and without which of the programs would have been we therefore a study of the programs in these groups to determine the reasons they failed to reduce so frequently the first step was to perform a static analysis on all the programs to determine average length and of various statement types results of this study appear in table group l math sci of statements table static analysis computed statements from this table we can see that the programs in groups and were extremely long and contained many if we compare the statistics for group with those for group which reduced more frequently we see that group programs were three times as long on the average but contained five times as many five times as many labelled statements and only twice as many it seems likely that many of the loops in group were implemented with rather than resulting in a fairly complex control flow structure our next step was to analyze programs in groups and to determine specifically why they failed and to see if a richer grammar might reduce them for the purposes of this analysis we defined two new grammars the first extended the grammar by adding two new rules depicted in figure i q figure extensions the resulting grammar programs reduced under a more is called s these rules x grammar and an analysis exit regions of groups and showed that an additional was also considered this grammar named consists of rules of and the rules depicted for reduction under this grammar the results of these in figure groups studies are summarized and were also in table analyzed i i of i programs number of reducible reducible x reducible reducible reducible which were reducible i i table it can be seen that significant improvements in reduction grammars however it is our that the programs in group and that increasing the complexity of our grammar is not we are currently a systematic paper can be achieved by using the larger and have an appropriate approach which too many complex way to deal with will be reported control structures such programs on in another new nonterminal rh three exit region l j m figure additional rules for iv applications the description of program flow graphs allows a number of applications to be carried over from language theory in particular many algorithms on the flow graph can be specified via attributes on the graph grammar as an example we show how one might specify the analysis of simply stated the problem is this suppose we are given for each branch xy in the program the probability that branch will be taken after block x is executed we wish to determine the expected frequency fx of execution of each block x in the program during a single execution of the whole program under certain simplifying markov assumptions ck the expected can be expressed as follows k n the program o entry node fx e all other nodes a figure there are method for several points the system of equations is described to notice about this graph grammar by the graph attribute grammar in the attribute on its value p is a synthesized attribute for nodes within the region that is the values its value of p for for composite regions is based terminal nodes are given the attribute is an inherited attribute that is its value for nodes within based upon its value for the region as a whole and upon the values of a region is because of the dependence of upon we are forced to evaluate first thus the attribute grammar in figure gives rise to a algorithm the first pass moves forward through the parse computing for larger and larger regions the second pass moves backward through the parse computing f for smaller and smaller regions the first value of f is the one for the whole program no which is by assumption the whole program is executed once figures and present an example computation with figure the reduction pass and associated transition probability computations and figure the production pass and frequency computations from the considerations above and the example we can see that the attribute grammar specification gives rise to the classical algorithm for ck furthermore by applying of tech in we can compile these attribute grammars into finitestate machines which use the parse or its reverse as input the eventual result may be a system to generate graph based optimization algorithms by analogy with these algorithms should be linear in the size of the input program v summary and conclusions we have investigated points its an empirical study tend to write programs the of a graph grammar for program control flow from two view for describing programs and its applicability to compiler construction has shown that programmers even those in structured programming which are derivable using we might conclude that a typical good pro we would not have also f find shown this rules based a promising could lead upon g new to a system too restrictive specifying global for the automatic flow algorithms via an attributed generation of compiler acknowledgements we are particularly to our at rice who provided us with sample programs dept and dept f t richard john chen dept de dept f and allen mathematical sciences dept f bruce and we also engineering helpful dept comments given by c jr rosen of ibm research and of rice and entry rules start o semantic rules cc z w loop z w z w l z vw d z vw cd z dc vw l z dd vw w y w x x w ax vw ax vw x y w v i rx y pz wl pz wl fx fz x pz wl f xf z pz f xf z v f xf z v r z d p vw x v w y figure z x for enter exit dc cc a cc figure a reduction sequence f cc a fl fl t f cc fl i e fl fl dc fl figure production sequence aho av w sethi r and jd optimization x compilers references code optimization r cd and finite prenticehall churchrosser systems in nj au aho av and jd prenticehall the theory of parsing nj translation and compiling vol au aho av and unman jd prenticehall the theory of g translation nj and compiling vol ii compiling au aho av and unman jd node for symposium on theory of computing reducible nm flow graphs proc pp may annual al allen fe control flow analysis sigplan notices vol no pp july acm a allen fe a basis for program optimization amsterdam proc ifip conf northholland co ac fe and j graph theoretic constructs for program flow analysis ibm research report rc tj watson research center heights ny july am conf e and manna z the translation q north holland co of goto amsterdam programs into while programs proc ifip be jc an algorithm for tracing live variables based on a technical report tr ibm laboratory december program graph ibm bj c and g flow diagrams turing machines and languages with only two formation rules vol no may ck j and kennedy k computations on program flow graphs ibm research report rc tj watson research center heights ny november cs di j and schwartz york programming languages dijkstra ew on structured gramming academic press programming and their compilers new york university in dijkstra and hoare structured new pro vol cp and no jan pp j analysis of graphs by ordering of nodes r to appear science kennedy k in proceedings october and l grammars and global of the annual ieee symposium program on the data analysis foundations of computer fs friedman dp and shapiro sc a case for sigplan notices vol no july gw graham sl and wegman m a fast record of the second acm symposium jan pp and usually on principles linear algorithm of programming for global languages flow analysis conf palo alto california hu ms and unman jd analysis of a simple algorithm for proc acm z lm symposium on principles of programming global data flow problems languages boston mass hu ms and unman jd pp june flow graph siam j computing hu ms and unman jd pp july of reducible flow graphs vol no jacm vol no jl m on attribute grammars and the semantic specification of programming languages phd thesis computing and information sciences dept case university october j m live variable analysis attribute grammars and program optimization draft dept of computer science university of north hill nc march ka rh an march view of structured programming sigplan notices vol no kennedy k pp a global flow dec analysis algorithm international computer section a vol ke kennedy dept k a comparison of mathematical of algorithms sciences rice for global university flow analysis texas technical report ke ke m kennedy k node applied to data flow analysis conf on principles of programming languages palo alto california record of the second jan acm symposium kennedy k mathematical sciences chains with rice university applications rice technical texas april report dept of kennedy k and j sequencing technical report texas oct a deterministic attribute grammar dept of mathematical evaluator sciences based on dynamic rice kw kennedy k and sk automatic generation of efficient evaluators for attribute grammars to appear in conf ga jan record of the third acm symposium on principles of programming languages kp bw and new york pj the elements of programming style co kp bw and pj programming vol no dec style examples and counterexamples computing ki ga a unified symposium on principles approach to global program of programming languages optimization boston mass knuth e an empirical study vo no pp of fortran programs software proc acm oct practice and experience kn knuth e structured dec programming with goto statements computing vol no kn kn knuth e semantics knuth e p semantic of contextfree of contextfree languages math systems theory j pp languages correction systems theory lc lee and sk structured notices vol no april programming and automatic program synthesis sigplan mt g and tarjan re ibm research report rc lower bounds on the lengths tj watson research center of node sequences heights in directed ny july graphs ma martin jj the natural dec set of basic control structures sigplan notices vol no ro rosen b tree manipulating systems and churchrosser theorems vol no jan sa s the scope of variable concept the key to structured notices vol no programming sigplan se m mathematical nj theory of global program optimization prenticehall se sethi testing for the churchrosser property jacm vol no oct sh b the of control structures sigplan notices vol no dec t tarjan re depthfirst june search and linear graph algorithms siam j computing vol no u unman jd fast algorithms for the elimination vol pp of common subexpressions acts informatica we e control structures for programming languages sigplan notices vol no wr no april and bm loops without cycles i sigplan notices vol wi n on the composition of dec programs computing vol no wa russell db and vol no dec an a language for systems programming z ct structured control in programming languages proceedings of the conference proceedings vol press 