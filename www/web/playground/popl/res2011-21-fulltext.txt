modular reasoning for deterministic parallelism university of cambridge uk university work done while on at cambridge matthew j parkinson microsoft research cambridge uk abstract a concurrency control protocol into a program is difficult and one way to this burden is deterministic parallelism in this approach to a sequential program is annotated with sections that can execute concurrently with automatically injected control constructs used to ensure observable behaviour consistent with the original program this paper the formal specification and verification of these constructs our highlevel specification defines the conditions necessary for correct execution these conditions reflect program dependencies necessary to ensure deterministic behaviour we connect the highlevel specification used by clients of the library with the lowlevel library implementation to prove that a clients requirements for determinism are enforced significantly we can reason about program and library correctness without abstraction boundaries to achieve this we use concurrent abstract predicates based on separation logic to behaviour in the implementation to allow generic specifications of libraries that can be instantiated by client programs we extend the logic with higherorder parameters and quantification we show that our highlevel specification abstracts the details of deterministic parallelism by verifying two different lowlevel implementations of the library categories and subject descriptors d software engineering program proofs d programming languages language constructs and programming structures general terms languages theory verification keywords separation logic concurrent abstract predicates concurrency futures introduction writing safe and efficient concurrent programs is challenging because it requires programmers not only to useful units of work into threads that can be executed in parallel but also to suitable concurrency control to coordinate the access of these threads to shared data to enable effective reasoning about concurrent programs however it is essential to modular abstractions whose implementations can be hidden behind well permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm defined interfaces allowing clients to reason about correctness in terms of abstract rather than concrete behaviour in this paper we consider the verification of one such concurrency construct barriers in deterministic parallelization code regions in a sequential program are executed concurrently while the program is internally nondeterministic control constructs are used to ensure that it the same deterministic observable behaviour as its sequential counterpart automatic parallelization of this kind has been for numerical computations however it is also possible to extract parallelism from structured sequential programs where program dependencies are not readily apparent one way to achieve deterministic parallelism is through barriers we can think of these barriers as resource management operations that enforce the original sequential order program dependencies a resource could be any program variable data structure memory region lock etc for which ownership guarantees are essential in order to enforce deterministic semantics we assume barrier implementations are provided as part of a library while the intuition behind using such barriers is quite simple there are many possible implementations verifying that an implementation to this intuition is challenging for several reasons first the patterns of in a barrier implementation are highly nonlocal to access a resource a barrier must wait until all logically preceding threads have indicated that it is safe to do so these logically preceding threads represent sources in a dependency graph this abstract view of does not fit with the structure of a highly concurrent implementation making it difficult to avoid abstraction boundaries furthermore compiler optimizations might to identify the point in a threads execution path from where a resource is no longer required in some cases this means threads can release resources without ever them so that subsequent of this resource by its ancestors to its descendants can it an ancestor of a thread is a computation that logically precedes it under sequential execution and a is a computation that logically follows it implementations of barriers must allow a thread to the acquisition of a resource in this way finally barriers may have to treat reads and writes differently to ensure preservation of sequential behaviour although many reads can be performed concurrently they must be with respect to writes moreover reads must be with respect to other reads if there is an write in the sequential order in this paper we show how to reason in a modular way about implementations of such barriers to do this we use concurrent abstract predicates a technique based on separation logic that enables abstract reasoning about concurrent modules our logic allows us to reason about both highlevel behavioural properties and lowlevel implementation details this approach allows finegrained reasoning about behaviour meaning that each thread can be given access to exactly the behaviour it needs to run according to the abstract specification this behavioural reasoning is local meaning even nonlocal descriptions of the shared state can be and abstracted by concurrent abstract predicates in this way we take a first step towards the formal specification and verification of a system for deterministic parallelism while full verification of compiler analyses transformations and library implementations is our goal we focus here on just the verification problem for libraries we present a highlevel specification for reasoning about barriers for deterministic parallelism independent of their lowlevel implementation we prove that two lowlevel implementations of these barriers implement our highlevel specification in the presence of runtime thread creation and dynamic data our specification must also be both generic and dynamic in the sense that it must be able to construct signals at runtime that protect arbitrary resources to support the transfer of arbitrary resources between threads we have extended the concurrent abstract predicates approach to support higherorder predicate parameters and higherorder quantification the controlled resources are represented by propositional arguments to abstract predicates we make the following contributions we develop a highlevel abstract specification for reasoning about libraries that implement barriers used to enforce deterministic parallelism this specification can express complex behaviours such as the dynamic construction of new barriers and between threads we provide proofs that two implementations of such barriers satisfy our highlevel specification the first implementation while the second information from logically earlier threads to avoid this we extend prior work on concurrent abstract predicates to support higherorder parameters and following higherorder separation logic by allowing propositional parameters we can define predicates that take invariants as arguments to enable abstract reasoning about resource transfer an extended version of this paper containing full proofs is available as a technical report a specification for deterministic parallelism in this section we describe the behaviour of a library providing barriers for enforcing deterministic parallelism we define a highlevel specifications for these barriers which allow us to prove that programs using these barriers preserve sequential behaviour we assume that code sections to be amenable for parallelization have been identified and the program split accordingly into threads we assume a total logical ordering on threads such that executing the threads in the logical order gives the same result as the original program barriers are associated with resources eg program variables data structures etc that are to be shared between program segments there are two sorts of barriers a grant barrier logically later threads that the current thread will no longer use the resource a wait barrier blocks until all logically prior threads have that they will no longer use the resource ie have grants we assume barriers have been appropriately injected by a compiler to ensure that all data dependencies in the original program are consider the following function f here corresponds to nondeterministic choice so sleep for an arbitrary period of time else sleep suppose now that we run two instances of f in sequence x y when this program terminates location x and y will both hold here the second call to f may have to wait for the first call to finish its arbitrarily long sleep even though the first call will do nothing more once it we this function by constructing two new functions f and f we run both concurrently but require that f passes control of x and y to f before allowing f to continue executing else sleep else sleep x y the barriers in f and f ensure that the two threads wait exactly until the resources they require can be safely modified without sequential program dependencies the correct ordering is enforced by barriers that communicate through a channel in the example creates the channel i assuming the barriers are correctly implemented the resulting behaviour is equivalent to that of the original sequential program verifying a client program how can we verify that our program based on f and f has the same specification as the original sequential program typically one would incorporate machinery as part of a parallelization program analysis clients would then reason about program behaviour using the operational semantics of the barrier implementation the correctness of with respect to the sequential program semantics would therefore require a detailed knowledge of the barrier implementation any changes to the implementation could the correctness of the analysis in contrast we reason about program behaviour in terms of abstract specifications for grant wait and such an approach has the following advantages can modify their underlying implementation and be sure that relevant program properties are preserved by the implementation and client proofs in this case proofs involving compiler correctness can be completed without knowledge of the underlying implementation we will reason about f and f using separation logic we write the following assertion to denote that x points to value v and y to value v and that x and y are distinct x v y v to reason about the parallel composition of threads we use the par rule of concurrent separation logic p c q p c q p p c c q q par now to reason about f and f we must be able to encode the fact that f can give up access to x and y by calling while f can access to them by calling to use the parallel rule we must be able to give the two threads preconditions we encode these two facts by defining two predicates and req corresponding to the future resource the resource that can be acquired from logically earlier threads and the required resource the resource that must be supplied to logically later threads we read these as follows p ­ by calling wait on i the thread will acquire a resource satisfying the assertion p p ­ by calling grant on i when holding a resource satisfying p the thread will lose the resource p these predicates are abstract each instantiation of the library will define them differently the client program knows nothing about how they are actually defined the client only depends on an abstract specification that captures the intuitive meaning of the predicates emp i p p p p p p emp note that this is a weaker version of our full specification given in fig the specification of is this tion is implicitly universally quantified for all assertions p mean ing that we can construct a predicate for any assertion new and req predicates can be constructed at runtime using meaning we can construct an arbitrarily large number of channels for use in the program given these two predicates we can define the following for f and f v x v y v req i x vv y v v fx y v i emp v fx y v i x v v x v y v y v v the specification for f says that the thread must supply the req predicate with the resources x and y such that the value in x is less than the specification for f says that the thread can receive x and y with the value in x less than fig gives for these two specifications given this specification the proof for the main program goes through as follows no x y nx y o x y x y x y parallel rule x y this proof establishes that the postcondition for the version of the program is identical to the postcondition for the original sequential version in the full specification we impose an extra requirement that p is stable meaning invariant under concurrent interference but this holds trivially for assertions such as x v y v v x v y v req i x vv y v v x vv y v v req i x vv y v v abstract spec emp n contradiction as v emp no v i x v y v abstract v x v y v o x vv y v v n else as v x vv y v v figure proofs for f and f to many threads suppose we want to run many copies of the function f in sequence for example over an array of values vs we might have the following sequential program j to this program we want each call to f to run in a separate thread to do this f must be modified to contain calls to both grant and wait intuitively each call to f receives the resource from logically earlier threads those invoked in earlier loop iterations with wait then it to logically later threads those invoked in later loop iterations using grant to allow many threads to access the same resource in sequence we can construct a chain of channels a wait barrier called on a channel for grant barriers on all preceding channels we use the ordering in chains of channels to model the logical ordering between a sequence of threads a chain initially consists of a singleton channel constructed using we introduce an operation split that allows us to insert a new channel into the chain the specification of split takes a req predicate for an existing channel and creates a new and req predicate representing the new channel the new channel is inserted into the chain immediately before the existing channel we extend the req predicate with an additional argument identifying the preceding channel in the chain the split operations specification is given in fig there are two more potential sources of parallelism in f first in the original transformation involving f and f we did not distinguish between the resources x and y however we need to gain access to y only if we take the first branch of the conditional otherwise we can release y to logically future threads to this parallelism in the new version of f we use two chains of channels one for x and one for y second we can exploit the ability to access to a resource without it first in the simple specification given p p i p p p p p i p j j emp j p i qq i p nil p axioms p p p p p p figure full abstract specification for deterministic parallelism above we can only call grant if we hold the required resource however this is often not necessary for example if we take the second branch of the conditional in f we do not need the resource y it is safe to future threads that y is available conditional on all logically prior threads it even though the thread itself never acquired access to the resource can be a powerful technique for suppose a thread is logically last in a chain of threads accessing a resource suppose the thread takes an execution path it unnecessary to ever access the resource without a call to grant will block until all earlier threads have finished with the resource with the thread can pass the barrier and continue executing of the status of logically earlier threads to support we modify the specification for grant see fig this new specification allows a thread to a req using the preceding predicate in other words the thread gives up the ability to ever acquire the resource and instead for this capability to future threads when the resource becomes available from logically prior threads the next thread in the logical order will receive it the assertion p p is used to convert the state supplied by the future to the state required by the next thread in fig we also add an axiom to our specification this is a fact about the library predicates that clients of the library can make use of the axiom allows resource splitting this axiom asserts that when a thread can receive a resource p using identifier i access to that resource can be split between two threads potentially before the resource is available the assertion p pp asserts that p can be split into p and p we now define fp top of fig a version of f which is safe to run in parallel with many copies of itself this function takes arguments ix and representing the next points in the two channel sequences and and representing the immediately prior points we verify fp against the following specification x x no fp emp y y a proof of this specification is given in fig note that we only assert basic memory safety in this specification we could verify a resource satisfies p p iff its combination with any disjoint resource satisfying p produces a resource satisfying p if x else sleep j future figure example of f and a client the future annotation marks the call to fp as a source of deterministic parallelism x x y y x x y y if x x y x y o x x else o y y emp sleep n o emp figure proof for program fp more complex properties by giving the and req predicates stronger invariants line of the proof is there the precondition does not assert that the thread has access to y rather it asserts it can acquire access by calling wait instead of doing this the thread access to the resource giving it up without ever having it gx if sleep else if sleep else figure example function g and its the version of the main program is given at the bottom of fig we give the following for this example here the predicates true and true are dummy req predicates used to represent the logically element of the sequential order the predicate array stands for the array of values no max max nil true x nil true y j max true x x x true y max x true x x true y y y future dummy req predicates max x y we have shown that our version of the program is with a little more effort we could verify the behaviour of the program even though this program features many threads running at once with complex communication between threads each individual thread is able to reason locally without dealing with other threads or the implementation of the barriers relating reads and writes further parallelism is available by refining read and write accesses to a resource consider the function g given in fig it is safe for parallel threads to read x at the same time however it is important that writes to x are and that groups of reads are with respect to writes if two groups of reading threads are separated by a writing thread the logically later group must wait for the writer to finish before reading to exploit this we split reading and writing into two channels we use r and rp for reads and w and wp for writes w and r are the outgoing channels while wp and rp are the incoming channel as soon as the thread nondeterministically takes the first branch of the x x rp x wp x if apply x the future splitting x axiom to rp x rp x wp x x wp x wp x o emp n emp figure proof for program gp conditional it can use the read channel to signal that later threads can read in contrast a thread that to write must wait for both the read and write channels the program is given in fig in separation logic read and write access are often controlled by fractional permissions each thread can hold either full permission on a location x denoted x v or fractional permission denoted x v full permission gives the thread exclusive permission to write while fractional permission gives permission to read fractional permissions compose by addition as follows x v x v x v if we give the function gp the following specification rp x x wp x x gp emp this specification says that when a thread receives a fractional permission from the read channel only half of it has to be sent on to future threads using the read channel the other half can be supplied on the write channel this allows a thread to keep the ability to read while future threads that they also can read fig shows a for the program we the writing branch of the conditional as it is straightforward the most proof step is line where the specifications axiom is used to divide up access to the predicate half is used to the req predicate r allowing logically later threads to read while half is used to allow the current thread to read in this way many threads can simultaneously have fractional access to the resource verifying a simple implementation so far we have given an abstract specification for deterministic parallelism the specification was independent of the implementation return in skip return i figure implementation of library of the barrier in this section we show how such a specification can be justified by giving a simple implementation of the wait and grant barriers and verifying our abstract specification against this concrete implementation the implementation is given in fig this implementation supports resource transfer using a sequence of nodes each of which has a bit field and a prev field each req pair is associated with a single node and the order of the sequence represents the logical ordering the implementation requires that bits are set in sequential order in § we consider a more sophisticated implementation that allows and show that it also implements our abstract specification the wait barrier simply for the immediately preceding bit to be set as bits are set in order with logically earlier threads setting their bits before logically later ones this suffices to show that all the earlier bits in the order have been set recall from the previous section that our specification permits threads to the ability to access a resource meaning that grant can be called before wait within the same thread to ensure that bits are set in sequential order grant must wait for the previous bit to be set before setting its own bit the implementation uses the prev field of the bit to call wait and then sets its bit when it exits bits are set atomically by grant denoted by the constructor functions and split are implemented by allocating a new bit split inserts a bit into the order by the prev pointer of the existing bit to point to the newly allocated bit this allows computations to dynamically instantiate that have internal deterministic parallelism proof approach to prove the correctness of our modules functions we use concurrent abstract predicates we extend this work with higherorder quantification allowing us to prove specifications that abstract over the particular resource held by the predicate concurrent abstract predicates extend standard separation logic with two new kinds of construct allowing explicit reasoning about sharing and interference the first are named shared regions denoted by boxed assertions of the form r p i this asserts that the region r contains a resource satisfying p and nothing else this region is shared between the current thread and an arbitrary number of other threads the permitted state changes over the region are controlled by the interference environment i the second are capabilities resources controlling the updates that a thread can perform in order to the contents of a shared region a thread requires a capability in its local state denoted ac t i o nr this is a permission for the operation action on the region r the exact operation denoted by the name action is determined by the interference environment for region r suppose that action denoted the ability to rewrite the value in a shared address x from to then we would have the following interference environment i x action x x a capability both whether the operation is permitted to the local thread and whether it can be performed by the environment following exactly what is allowed and is determined by the permission level we write if the thread can exclusively perform the action gz if the thread and the environment can perform the action and dz if neither the thread nor the environment can perform the action the value z is used to track the amount of permission allowing capabilities to be split and combined updates performed by a thread must be permitted according to the capabilities held by the thread in local state socalled abstract updates those that do not modify the underlying can be performed at any time by a thread we write p q to denote that p can be abstractly updated to give q as assertions describe shared states that can be updated by other threads we need to be able to describe assertions that will remain true no matter what the environment does we describe these as as stable capabilities specify exactly what behaviours the environment can perform giving finegrained control of stability for example the following assertion is stable because i specifies that the only way region r can be is by the action operations and the exclusive capability to perform this operation is held by the thread in local state x r i x ac t i o nr our logic includes an assertion that holds if p is stable an abstract specification for a module consists of abstract pred function specifications and axioms to show that a concrete implementation of a module corresponds to a particular abstract specification we must supply concrete definitions for the modules abstract predicates and then show that the following three properties hold the module implementation satisfies the abstract specifications given the concrete predicate definitions the predicate definitions are stable and the axioms hold given the concrete predicate definitions for simplicity we assume that resources are garbage collected rather than being explicitly deallocated this means that we can safely remove from assertions and we often use this to clean up the postconditions for operations verifying the implementation next we prove that the implementation satisfies the abstract specification we give definitions to the and req predicates in fig in all our predicate definitions we assume variables are existentially quantified the definition of i p captures three pieces of information first that there exists a shared bit at address i second that i is the immediate predecessor of i and it can be read by the thread third that the thread must supply the resource p before setting the bit at i in this definition we use two auxiliary predicates pa and box the predecessor access predicate asserts that i is either nil or it is a shared bit that can be read this ensures that the thread that holds req is able to access the preceding bit the predicate p asserts that the thread can exchange the resource p for i p p p r p i i i r i nil i i putr r i i r p p p p p r r p ii j figure collected predicate definitions the permission d on set for the bit i hence in order to acquire the full permission to set the shared bit the thread must supply the resource p to the predicate p that is the following abstract update holds r p p i i r i i se below we prove that the abstract implication holds for the moment we just note that boxes are used to control the splitting of resources according to the splitting axiom note that the definition of box is recursive as it the box predicate inside the shared region and in the interference on the shared region the fixed point exists by first finding a solution ignoring the interference environment and then restricting the interference environment by the resulting solution finally we give a definition to p this assertion must capture one essential piece of information that either the shared bit at i is zero or the resource p is available for collection in these definitions names with square brackets are capabilities the semantics of such capabilities are defined by the interference environments we define two environments the first ii defines the interference over the shared bit i this environment includes only a single operation the ability to set the shared bit ii set the interference environment ji p r defines the interference over the regions ji p t t intuitively the first case for put allows the thread to push the resource p into the shared state and a fractional permission to set the shared bit the first case for get allows the thread to re the resource p the second cases are used in resource splitting see below for details the first obligation for showing that our module implements the abstract specification is to use our program logic to prove the module functions specifications proofs for grant wait and split are given in fig the proof of is almost identical to the proof of split and hence omitted the proof of grant operates by first to the specification of wait to recover the full resource from a possible predicate we also use the specification which can be proved trivially it then the resource and the box predicate for permission to set the shared bit finally it sets the shared bit and all the remaining resource the proof of wait until the bit field is which the case where the resource is not present as the resource can only be removed by the wait thread this assertion is stable under interference the thread uses the get to recover the resource and all the other resources the proof of split and allocates a new piece of memory sets the pred and bit fields to appropriate values then creates the and req predicates by the new memory in a shared region the second obligation we must is to show that the predicates are stable to do this we check each of the predicate definitions to make sure that each shared region assertion is invariant under permitted interference resource splitting using boxes our specification requires that we can split predicates according to the axiom given in fig we use the box predicate to support this splitting in our concrete implementation intuitively each box initially shares its shared region with a predicate then if that predicate is split the box instead contains a pair of boxes representing the shared state for the two new predicates the definition of a predicate p fig either allows the thread to access the set permission or contains two boxes with resources p and p such that p p p in the proofs of the modules operations we on the assumption that a predicate p and resource p can be for a permission to set the shared bit we now justify this assumption with a proof our definition of box is the least fixed point of the recursive definition we reason inductively hence it suffices to prove that the entailment holds when box is defined as false and under the assumption that the disjunction holds the base case of the induction holds trivially as p is false in the first inductive case we assume that the left disjunct in the shared region holds the proof is given in fig a in the second case we assume that the property holds for p and p the proof is given in fig b the proof given in fig c shows that the axiom holds for the concrete predicate definitions we only show the left case for the disjunction the right case is easy this proof uses the get action while at the same time creating new regions for the two new futures this completes the proof that our simple implementation corresponds to our highlevel specification logic and semantics in this section we present the syntax and semantics of our logic it extends the previous work on concurrent abstract predicates with higherorder parameters and quantification following the work of et al on higherorder separation logic our assertion logic is a typed higherorder separation logic extended with predicates that denote the ability to change the state and a connective for expressing sharing the syntax of the assertion r p p i i defs assumption r p i i putr r i i s e r j action put r i i putr rr p i i j gc r i i a r p p i i defs and case split r i i putr p r p p p p p action put r i i putr p emp r j p p p p p assumption and gc r i i s e b p p p p def r ri i r p ii j action get creation of two new regions r p p p p p p p gc p p c figure proofs of abstract updates language is as follows int region p q l m false p q x p l m x m e emp p q p q l m m r p r i i x y p q i i dl gl where r ranges over region names over token names and v over values we lift expressions e from the programming language to the logic note that we use p q when the term is of type terms are typed in the obvious way and we will implicitly assume all definitions are welltyped our propositions have three important aspects they describe the contents of the state the capability to change state and a partitioning of these contents and capabilities between local and shared regions for completeness the full semantics of terms is given in fig below we will only describe the features of the semantics a more explanation can be found in model we model propositions with worlds that have three components a local component that specifies the current local state and local capabilities a shared component that specifies the current shared state and shared capabilities and an interference environment that specifies the possible interference or protocol on the shared component of the world the shared component is split into many named regions each of which is modelled by an a local world is modelled by a partial heap heap specifying the locally accessible state and a capability mapping mapping from actions in action to permission to perform that action in dg each action is mapped to either a full permission an exclusive permission to perform that action that hence the environment from performing the action a guarantee permission gz a permission to perform that action a permission dz a on the action that also prevents the environment performing it and an empty permission that does not allow the action but does not the environment from performing it following the z of and guarantee are used to track how much permission is required to exclusive permission members of action a region a token and a sequence of val arguments an actions semantic meaning as interference over a shared region is defined by an interference environment in the set the definition of an interference environment as a relation over enforces the restriction that the interpretation of an action does not allow you to change the interference interpretation of any actions model operations as we are building a separation logic we require a composition operator on worlds that will be used to interpret the separating conjunction and separating implication we use the standard operation from separation logic for combining heaps h h by disjoint partial function combination we use the composition model for dg this has as the unit of it combines two guarantee or permissions by combining their fractional components to produce a guarantee or permission with the sum of the if the sum to then it to if the sum to more than then combination is undefined this is then lifted to the function space in the obvious way we define the composition of as the combination on both components and on world as the combination on the component where the and components are equal we define other useful operations on the model that aid in the definition of the semantics s all the shared regions into a single one lh gives the heap component of l lp gives the permission component of l and w a world into a single heap finally we define the set of wellformed worlds a world is wellformed iff all the regions and the local component can be combined each capability is defined in the interference environment and the capabilities only mention valid regions types the types are semantically interpreted as in figure we use i for interpretations of the free variables in a term it is a dependent product from a variable to the denotation of the type of that variable we interpret propositions on the powerset of worlds terms the interpretation of false variables function application and function abstraction are standard the predicate emp specifies that the local component of the heap is empty and makes no restriction on the shared part the no i p p p p p o i p p p p p o wait spec or by pa i p p n unfold r definition o i p p i i n push resource into the r i i i box s e tr o n r i i action set i o s e tr n collect emp no p g e tr r p i i rr ii j skip ff p r i i r j j abstract action get ff p rr ii j n o garbage collect p no i p p n i i i region for new predicates p n i i i r i n construct r a new box for the future pu p n i i i r i n ge tr tr s e tr r ir r j return in fold definitions i i ret i i i p q i q figure proofs for grant wait and split interference environment or the capability the pointsto predicate l m specifies that the location l contains the value m in the local world and that the heap contains nothing else the capability m r that says the local world contains the permission on region r for action with parameters m the assertion says that p will remain true given the permitted interference on the shared world that is if we start in a world satisfying p and take a step in r then we must still satisfy p the r shared assertion p says that the shared region r satisfies the i assertion p and that regions interference is specified by i interference we define several relations giving the possible updates to the shared world as a result of the thread and the environment following jones we call the interference permitted to the environment the rely and the interference permitted to the local thread the guarantee we define the semantics of the interference as a relation of for a particular update p q we specify that a part of the must satisfy p and replacing that part with a part satisfying q gives the we also allow the action to increase the number of regions in an unspecified way this will allow actions both to and to create new shared regions simultaneously we allow the dynamic creation of regions the relations rc and gc model this creation the first rc specifies the if the environment creates a region the environment can only create a region if it does not already exist it adds a new shared region and the relevant definition to the interference environment the second gc specifies the if the current thread created a region this differs from the rely as all of the permissions on actions for the new region are given to the current thread the global rely relation r allows any action in the inference environment that is not explicitly with a permission or a full permission as well as the creation of regions we restrict r to wellformed worlds the global guarantee g allows any action for which there is either a full permission or a guarantee permission the guarantee requires that the permissions and heap domain must be the same before and after the action upto between regions this ensures that permissions and heap cannot be created out of we also allow region creation and restrict g to wellformed worlds program logic we give the proof rules for our program logic in figure the judgements are of the form p c q where is an assumption about the logical context and is an assumption about the procedures in the context of the form we use to encode the assumptions about the abstract predicates and their axioms we assume a standard semantics of programs where c h c h denotes a successful reduction in the procedure context a mapping from procedure names to commands and c h fault denotes a memory access problem we then define the semantics of judgments as follows definition configuration safety c w i q safe always holds and c w i q iff the following four conditions hold w if w w r then c w i q w fault c h if c w c h then w such that w w g h w and c w i q and if then w such that w w h w w g and w q i model dg h heap i tz z t d g a action address val l action × w world region × token × val heap × s × × action dg region model operations v v v t z t z if z z h h v hv hv if v hv hv t z t z t z z if z z v v v if v v v defined h h h h if h h and are defined h h h s l s i l s i l l s i if l l defined s s i i h p l s i l s h l s i l s defined s p r r doms v r v types int z region region terms false i x i ix p q i x p i w w p i w q i s v p lm i x m i l i m i v m p q i p q i w w w p i w q i w w p i w w q i emp i s i l m i l i m i s i i w w p i w w r w p i r pi i m r s i r m i i s i sr s i p i ir i ir interference x y p q v i i ir i ir i ir s s v i l l l l s i p l s i q sr l l sr l l r doms r r sr sr rc l s i l s i i r doms s sr l r gc l s i l s i i r doms s sr l l l l l r n where r v and or r r l s i l s i i a s s ia s lp a dz doms doms rc g l s i a s s ia lp a g doms doms l s i i s lp s l p dom s lh dom s l h gc definitions p pq i q w p i h p i h q i h w h h i i p pq q i p pq i q w h h p q w w w g w q i p i q figure semantics of assertions sl p c q p c q p c q par p q p cq exists p c q p p c c q q p cq p f q p f q call sl p c q p pq q atomic p c q frame p c q p r c q r p c q pn cn qn p f q pn fn qn p c q let p let f c fn cn in c q p c q p p q q p c q figure selected proof rules from all rules assume that the pre and postconditions of their judgements are stable definition judgement semantics p c q holds iff ni ni in p cq where ni p f q in p f q and in p cq w p c w i q differences from the cap paper the original paper treated the meaning of interference syntactically in the model that is the equivalent of was a map from action to syntactic definition of the actions this was done to avoid a cyclic definition in world in this paper we have out the semantics of interference to be a separate component we thus impose the restriction that the interference environment cannot update the interference environment note this kind of update was not allowed before but was not explicitly forbidden in the model just in the interpretation this small of the semantics allows higherorder quantification we extend the model from the original cap paper to additionally contain permissions this is a straightforward extension to the original paper finally we take an intuitionistic model for the permissions this enables permissions to leak the library we are considering in this paper requires garbage collection to collect signals when they are no longer accessible p i p p g e tr r i i i « rd r r bb i ir p p i p p p r i i i p j r i nil i i i r i i i s e r p p putr p p p j verifying a more complex implementation figure predicate definitions for bit setting the module implementation given in § imposes a strong sequential order on calls to grant a wait only checks its immediate predecessor so a call to grant must ensure its predecessor is set before setting its own bit in this section we consider an alternative implementation that allows bit setting we prove that this implementation also implements our abstract specification the new implementation uses the same datastructure as the simple implementation bits can be set by calls to grant in arbitrary order but as a consequence each call to wait must examine all prior bits before as this implementation uses the same datastructure as the first one the split and operations are identical the grant and wait operations are defined as follows while skip i as with the first implementation each address has a bit field and a prev field calling grant sets the bit field for the current address from to then exits immediately when wait is called it blocks until every bit field earlier in the order is set to do this it prev fields waiting for each bit field to go to before accessing the preceding location in this way wait ensures that all previous threads have called grant the predicate definitions given in fig are similar to those for the simple implementation the main difference is in the definition of the predicate when the shared bit is set the resource that is available to the thread may include a preceding predicate so if the current thread expects resource p it may instead get a resource satisfying p p p where i is the immediately preceding location in the logical order the thread can then recover p by checking the bit for i which may include a predicate for the preceding location i only when the thread has checked all the bits earlier in the order can it be it holds the full resource in this way our predicate definitions reflect the fact that the thread does not know exactly which threads have supplied a resource and which have simply access to it no p o i nil p p p p p skip r i p p p p p i n o i nil p p p p p n o is false if i nil so p figure proof for wait the req predicate is defined similarly to the first proof with a recursive box predicate controlling access to the interference environment for the shared bit ii is i the environment ji p r for regions is put dr p p p p p p p p p emp p emp get i rd p p p p p here the symbol is the iterated version of a proof for wait is given in fig the most interesting step is line where the resource is from the shared region we justify this step by the following proof the other case where a pa rather than is present is trivial no p p p unfold p definitions r i se ti i i rd r r i i i p p p p p j ip r skip p p rr i i i p p p p p j ip r into local state and gc r get i i i p p p p p p p transitivity of r i i i p p p p p the proof for grant and split are similar to the proofs for the case once again the proof of grant depends on the fact that can be split according to the resource held by it related work and conclusions most work on combining separation logic with concurrency constructs has considered them as primitive in the logic this begins with work on concurrent separation logic which takes statically allocated locks as a primitive csl has been extended to deal with locks and locks others have extended separation logic or similar logics with primitive channels and event driven programs concurrent abstract predicates combine the explicit treatment of concurrent interference from relyguarantee and abstraction through abstract predicates with a concurrent of disjointness supported by capabilities in this paper we have combined concurrent abstract predicates with higherorder separation logic we used our higherorder logic to define and verify a specification for barriers that enforce complex data and control dependencies in concurrent programs although we have in this paper on barrier constructs used for deterministic parallelism our logic is intended as a general approach to specifying concurrency constructs our syntactic approach has the advantage that concurrency constructs of different kinds combine for example lock predicates defined in can be through our channel predicates without changing the semantics or proofs of correctness for either module in addition we can verify that concrete implementations of constructs satisfy their specification acknowledgements thanks to the anonymous richard thomas vafeiadis and john references c j bell a appel and d walker concurrent separation logic for parallelization in sas e d t yang t and g safe multithreaded programming for cc in oopsla b l birkedal and n higherorder separation logic and abstraction toplas r l jr v s d s v s r j p h and m a type and effect system for deterministic parallel java in oopsla pages ­ acm j checking interference with fractional permissions in sas t m p m j parkinson and v vafeiadis concurrent abstract predicates in ecoop t p and m abstraction and refinement for local reasoning in m x m j parkinson and v vafeiadis reasoning in esop m s and m j parkinson modular reasoning for deterministic parallelism computer laboratory technical report university of cambridge x r and z shao on the relationship between concurrent separation logic and reasoning in esop a j berdine b cook n and m sagiv local reasoning for locks and threads in c m and c reasoning about locks in pages ­ c a r hoare and p w ohearn separation logic semantics for communicating processes ­ a a w appel and f oracle semantics for concurrent separation logic in esop b and f modular full functional specification and verification of lockfree data structures technical report cw dept of computer science c b jones steps toward a development method for programs toplas ­ n r l birkedal and j verifying programs using frame properties in k r m leino p and j channels and locks in esop a x and s quasistatic scheduling for safe futures in pages ­ acm p w ohearn resources concurrency and local reasoning m j parkinson and g m separation logic and abstraction in popl pages ­ m c rinard and m s lam semantic foundations of jade in popl pages ­ acm v vafeiadis modular finegrained concurrency verification phd thesis university of cambridge july j and c calcagno tracking heaps that with in tacas pages ­ a s and a safe futures for java in oopsla pages ­ 