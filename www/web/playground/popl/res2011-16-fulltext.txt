ahmed university blame for all robert bruce findler university philip wadler university of edinburgh g siek university of at abstract several programming languages are beginning to integrate static and dynamic typing including plt scheme and c and the research languages and flanagan and field and however an important open question remains which is how to add parametric polymorphism to languages that combine static and dynamic typing we present a system that permits a value of dynamic type to be cast to a polymorphic type and vice versa with relational parametricity enforced by a kind of dynamic sealing along the lines proposed by and ahmed and dreyer and our system includes a notion of blame which allows us to show that when between a type and a type any cast failures are due to the portion of the program we also show that a cast from a subtype to its supertype cannot fail categories and subject descriptors d language constructs and features procedures functions and subroutines general terms languages theory keywords casts coercions blame tracking lambdacalculus introduction the long of work that static and dynamic types includes the partial types of the dynamic type of abadi et al the coercions of the contracts of findler and felleisen the dynamic dependent types of et al the hybrid types of et al the gradual types of siek and the types of and felleisen the programming of and findler and the blame calculus of wadler and findler integration of static and dynamic types is a feature of net languages including basic and c is being explored for javascript python and ruby and is the subject of the recent stop workshop held in conjunction with ecoop permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm a unifying in this work is to use casts to between statically and dynamically typed code casts may be introduced by compiling to an intermediate language the blame calculus may be regarded as either such an intermediate language or as a source language the main of the blame calculus is to assign positive and negative blame to either the term contained in the cast or the context containing the cast with associated notions of positive and negative subtype these support the blame theorem which ensures that when a program goes wrong blame lies with the side of a cast wadler and findler in this paper we extend a fragment of the blame calculus to incorporate polymorphism based on a notion of dynamic sealing for simplicity our fragment includes base types function types and the dynamic type as found in gradual types but subset types as found in hybrid types our system adds the ability to cast a value of dynamic type to a polymorphic type and vice versa we name this system the polymorphic blame calculus a fundamental semantic property of polymorphic types is relational parametricity as introduced by reynolds our system uses dynamic sealing to ensure that values of polymorphic type satisfy relational parametricity for instance every function of type x xx must either be the identity function one which always returns its argument or an undefined function one which never returns a value and this property holds true even for values of dynamic type cast to a polymorphic type relational parametricity some program optimizations notably deforestation as employed by the glasgow haskell compiler et al our system may guarantee the validity of such optimizations even in the presence of dynamic types dynamic sealing to enforce parametricity has a long history sealing for data abstraction goes back at least to morris cryptographic sealing for parametricity was introduced by pierce and extending casts to include while relational parametricity was first explored in the context of programming by and ahmed a practical implementation for scheme contracts was described by et al recently et al used dynamic sealing to restore parametricity in a language our development is supported by the use of type bindings to control the scope of type variables both statically and dynamically type bindings are closely related to constructs for generating new type names et al an important difference is that our type bindings are that is there is no scope our development also uses static casts to and reveal the representations of type variables together with type bindings static casts provide a syntactic means to preserve the type hiding nature of type abstractions after they are instantiated static casts play an important role in the static semantics of our system but a role in the dynamic semantics as such static casts are implicit in our main system as in et al however we use an explicit version of the static casts as a technical device in our proof of the subtyping theorem the explicit casts are closely related to the coercions of and are of the syntactic type abstractions of et al we present three technical results in this paper the first result is the principle sections and which the way we implement casts that instantiate polymorphic values the second result is the blame theorem section which states that when between a type and a type any cast failures are due to the portion of the program the final result is the subtyping theorem section which states that a cast from a subtype to a supertype cannot lead to blame for that cast we do not present a relational parametricity result that result is and will be an adaptation of the result by and ahmed the paper comes with a redex model covering some of the systems in this paper available online this paper is an improved version of a paper in stop the current paper is completely rewritten and has lost one author and another among the more significant differences we use type bindings as compared to a global store and we prove the subtyping theorem a conjecture in the earlier paper from untyped to typed the blame calculus provides a framework for integrating typed and untyped programs one scenario is that we begin with a program in an untyped language and we wish to convert it to a typed language here is a simple untyped program let pos x x in let app f x f x in app pos it returns true we indicate untyped code by surrounding it with brackets · untyped code is really a due to harper it is a special case of typed code where every term has the dynamic type to aid the we sometimes write variables of type with a here is the same program rewritten with types let pos x i x in let app x y f xy x x f x in app i b pos this program returns true b as a matter of software engineering when we add types to our code we may not want to do so all at once of course it is trivial to rewrite a program however the technique described here is intended to apply also when each definition is replaced by a module we the transition between untyped and typed code with a relatively new construct et al siek and with an old name cast casts can be between any two compatible types roughly speaking type a is compatible with type b when a value of type a can be to type b we are particularly interested in the case where either the source type is corresponding to untyped code into typed code or where the target type is corresponding to typed code into untyped code we introduce an order on types corresponding to precision where is the least precise type we introduce a notion of blame associated with casts so that we can prove the following result if a cast between a type and a more precise type fails then blame on the side of the cast an immediate corollary is that if a cast between untyped and typed code fails blame lies with the untyped programs cant be a cast from a type to a type is called widening here is the above program rewritten to demonstrate widening it is mostly untyped but contains one typed component cast for use in an untyped context let pos x x in let app x y f xy x x f x in let app app x y xy xy p app pos in it returns true every cast is annotated with a blame label used to fault if the cast fails the cast in the above program has blame label p our notation is chosen for clarity rather than ing the source type of the cast is redundant the type of the source can always be inferred in a practical language we would expect the source type to be of course the untyped context may not satisfy the constraints required by the typed term if in the above we replace app pos by app pos it now returns blame p p rather than p indicates that the fault lies with the context containing the cast labelled p rather than the term contained in the cast this is what we expect because the context is untyped passing a typed value into an untyped context requires an appropriate instantiation for the type parameters as you might guess in this case the type parameters x and y are instantiated to however you might not guess that instantiating to always works regardless of whether the target is or something more precisely typed one of the contributions of this paper is to prove the principle if instantiating a type parameter to any given type yields an answer then instantiating that type parameter to yields the same answer a cast from a type to a type is called narrowing here is the above program rewritten to demonstrate narrowing it is mostly typed but contains one untyped component cast for use in a typed context let pos x i x in let app f x f x in let app app p x y xy xy in app i b pos this returns true b of course the untyped term may not satisfy the constraints required by the typed context if in the above we replace f x f x by f x x it now returns blame p p rather than p indicates that the fault lies with the term contained in the cast labelled p rather than the context containing the cast this is what we expect because the term is untyped to check for this error the implementation must each value that is from type x to type yields a value with x and to cast from type to type y fails because the x and y are distinct one of the contributions of this paper is to work out the details of sealing in a setting with dynamic types one consequence of sealing is that typed terms always satisfy appropriate parametricity properties even when they are derived by from untyped terms we now begin our formal development simplytyped lambda calculus all the systems in this paper extend a callbyvalue simplytyped lambda calculus shown in figure we let a b and c range over types a type is either a base type or a function type ab the base types include integers and booleans written i and b respectively we let s and t range over terms terms include constants primitive application variables abstractions and application the variables v and w range over values a value is either a constant or an abstraction we write t a if term t has type a in type environment a type environment maps variables to types the function ty maps constants and primitive operators to their types the function maps an operator and a tuple of values to a value and must preserve types that is if ab and · v a then there is a w such that op v w and · w b suitable choices of can specify arithmetic conditional and fixpoint operators we write s t to indicate that redex s reduces to t and write s t to indicate that reducing a redex inside s yields t we let e range over evaluation contexts which are standard simplytyped blame calculus before to polymorphism we review the of the simplytyped blame calculus shown in figure the blame calculus extends the simplytyped lambdacalculus with a dynamic type written and with four term forms dynamic casts terms type tests and blame one can think of the dynamic type as the sum of all the base types plus the function type ib accordingly the ground types are the base types together with the type every value of dynamic type is constructed by a cast from ground type to dynamic type written v g these casts can never fail so they are not with blame labels for example id x x is a value of type a test s is g returns true if s evaluates to a value on g for example i is i returns true in general a cast s a p b converts the value of term s from type a to type b casts are with blame labels we assume an operation of negation on blame labels if p is a blame label then p is its negation and p is the same as p we write s a p b q c as shorthand for s a p b b q c a cast from a to b is permitted only if the types are compatible written a b every type is compatible with itself the dynamic type is compatible with every type and functions are compatible if their domain and range are compatible note the in the function rule for now compatibility is symmetric but this will change in section finally the term blame p indicates a failure identifying the relevant label blame terms may have any type we now briefly review the reduction rules a cast from one function type to another reduces to a wrapper function that casts the argument applies the original function then casts the the reversal in the argument cast and the corresponding of the blame label wrap a cast from a ground type to itself is the identity id the side condition g avoids overlap with wrap for now the only ground type other than is but this will change in section a cast from type a to factors into a cast from a to the unique ground type g that is compatible with a followed by a cast from g to ground here we see the reason for distinguishing between casts and ground terms otherwise whenever the ground rule is applicable it would be applicable infinitely many times a cast from to type a the ground g of the value of type if g is compatible with a the two casts to a direct cast from g to a if g is not compatible with a the cast is conflict a test checks the ground of the value of type if it matches the test returns true else it returns false an occurrence of in an evaluation position causes the program to abort abort for example say pos x i x then pos ib p i pos i p i b p pos b p true b the function cast factors into a pair of casts the cast on the ranges the order and the blame label the cast on the domains the order and the blame label the swap is required for types to work out negation of the blame label is required to assign blame appropriately as can be seen by changing the argument pos ib p false b pos false b p i b p blame p the inner cast fails blame to the label p on the cast p rather than p indicates that the fault in the original cast lies with the context containing the cast rather than the term contained in the cast that is we blame the untyped context for failing to supply an integer rather than blame the typed function for failing to accept a boolean a cast from type dynamic to itself is the identity v p v where v is observationally equivalent to v to see this take v w g then w g p w g p w g p g via and ground and a cast from a ground type to itself produces either an equivalent value via id or wrap it is straightforward to define an embedding · from the untyped lambda calculus into the blame calculus c c op m q a b r x x x m x m q m n m q n m is g m is g if ab for example x x x x explicit binding the traditional way to reduce a type application is by substitution x t a we begin by why this cannot work in our case and then introduce a variant of the polymorphic lambda calculus with an explicit binding construct the problem a naive integration of casts and dynamic type with type substitution cannot ensure relational parametricity say we wish to cast the untyped constant function k x y x to a polymorphic type we consider two casts k p x y xy x k p x y xy y syntax variables x y constants c base types i b types a b c ab type rules terms s t c opt x xa t t s environments · x a values v w c xa t contexts e · e t e s v e c reduction rules t a ab opt b xa t v op v xa xa beta x a t b xa t ab t ab s a s t es et step figure simplytyped lambda calculus syntax type rules blame labels p q types a b c ab ground types g h terms s t c opt x xa t t s s a p b s g s is g blame p environments · x a values v w c xa t v g contexts e · e t e s v e e is g e a p b e g untyped terms m n c x x m m n m is g sa ab s a p b b sg s g s s is g b blame p a compatibility aa a b a a bb ab a b reduction rules v ab p a b x a v x a p a b p b v g p g v if g v a p v a p g if a g and a v g p a v g p a if g a v g p a blame p if g a wrap id ground conflict v g is g true v h is g false if g h p blame p if e · abort figure simplytyped blame calculus extends figure we expect the first cast to succeed and the second to fail the latter because of parametricity the parametricity property for the type x y xy y guarantees that a value of this type must be either the constant function which returns its second argument or the undefined function which never returns a value so an attempt to cast the constant function which returns its first argument to this type should fail the traditional way to reduce a type application is by substitution this cannot work in our case to see why consider reducing each of the above by substituting xi y i k p x y xy x i i k p iii k p x y xy y i i k p iii note how in the second line of each reduction the substitution has erased the difference between the two system has that the terms were once polymorphic thus we see that special runtime support is needed to enforce parametricity in the literature such runtime support is called dy syntax types a b c ab x x b terms s t c opt x xa t t s x t t a xa t environments · x a x xa · x xa values v w c xa t x v contexts e · e t e s v e x e e a xa e type rules x t b x t x b t x b a t a xa t b a x new xa t b t b xa reveal t t xa tb reduction rules x v a xa v xa c c xa yb t xa t xa y v y xa v if y x and y figure polymorphic lambda calculus with type bindings extends figure syntax types a b c ab x x b ground types g h x terms s t c opt x xa t t s s a p b s g s is g blame p x t t a xa t values v w c xa t v g x v contexts e · e t e s v e e is g e a p b e g x e e a xa e compatibility reduction rules ab a x b x ax b x a b v g is g true v h is g false v x is g blame xa v g xa v g xa v x blame p v a p x b x v a p b v x a p b v ax p b if g x for any x if g h and h x for any x if g x if x if b and b x b for any x b generalize instantiate figure polymorphic blame calculus extends and updates figures and sealing which we review in section in particular our approach is inspired by the dynamic sealing of and ahmed the dynamic type generation of et al and the syntactic type abstraction of et al based on these ideas we introduce an alternate semantics for the polymorphic lambda calculus as a step towards defining our polymorphic blame calculus polymorphic lambda calculus with explicit binding we avoid the problems above by introducing a polymorphic lambda calculus with explicit binding shown in figure as usual types are augmented by adding type variables x and universal quantifiers x b and terms are augmented by adding type abstractions x t and type applications t a the key new construct is explicit type binding xa t type environments are augmented to include as usual type variables x and more type bindings xa as usual we assume an implicit side condition when writing x or xa that x is not in the type rules for type abstraction and application are standard the type rule for binding the type environment with the binding and a side condition ensures that free type variables do not escape the binding new two additional type rules which are not syntax directed permit a type variable to be replaced by its bound type or vice versa within the scope of a type binding reveal we now briefly consider the reduction rules our rule for type applications instead of performing substitution introduces an explicit type binding three new rules push explicit type bindings into the three value forms constants value abstractions and type abstractions side conditions on the last rule avoid capture of type variables for example x xx yx y x i xi xx yx y x xi xi yx y x xi yx y xi by rules beta beta and respectively note that for the term xi yx y to be welltyped that must be regarded as having type is why the type rules permit both replacing a type variable by its binding and the converse as is well known allowing type abstraction over terms with arbitrary effects can be problematic as we will see in section the same issue arises here due to raising of blame as a possible side effect the usual solution is to restrict type abstraction to apply only to values as in the value polymorphism restriction of sml wright we would like to do the same here and restrict our syntax to only include type abstractions of the form x v however this would not be consistent with the reduction which may push the type binding construct a type abstraction a similar issue arises with the reduction generalize introduced in section instead therefore we allow the body of a type abstraction to be any term hence the term form x t but only consider a type abstraction to be a value if its body is a value hence the value form x v this further requires that we permit reduction type abstractions hence the context form x e relation to standard calculus we relate the polymorphic lambda calculus with explicit binding to the standard polymorphic lambda calculus based on type tion we omit the definitions of the latter to save space we define the erasure t from the calculus with explicit bindings to the calculus as follows c c opt opt x x xa t xa t t s t s x t x t t a t a xa t the only clause of interest is that for a binder which is erased by performing the type substitution we also define the application of an environment to a type a and the erasure of environments a xa a xa xa x x xa we can now state that the polymorphic lambda calculus with bindings correctly implements the standard calculus that is erasure preserves types and reductions proposition erasure if s a then s a and if s s then either s s or s s type safety it is straightforward to show the usual type safety results for the calculus with explicit binding typically these results are formulated with respect to closed terms and empty environments but because we allow reduction under type abstractions and binding our results are formulated with regard to terms that may contain free type variables and environments that may contain type variables and bindings but not term variables we let range over such environments with this we have the usual results for canonical forms progress and preservation proposition canonical forms if v c then either · v c and c for some c and or · v xa t and c ab for some x t a and b or · v x w and c x a for some w x and a proposition progress if s a then either s v for some value v or s s for some term s proposition preservation if s a and s s then s a relation to dynamic type generation et al present a form for generating type names new x a in t the main difference between our bindings and new is that new adds its binding to a global list of bindings new xa in t xa t if x dom earlier versions of our system also used a global list of bindings but two aspects of our system require the change to local bindings first evaluation proceeds under in our system which makes it problematic to use the global binding approach let s xy x and consider the following program and reduction sequence let f x in f i f b y x let f xs in f i f b y x xs i xs b y x xi s xs b but the next step in the sequence is problematic we would like to rename the x in x s but that would lose the connection with y also y should really get two different bindings local bindings solve this problem by binding y x locally inside the x second bindings play a role in enforcing parametricity which we discuss in detail in section an earlier system the n calculus by uses local type bindings but n performs scope that is the type bindings float the type bindings in this paper are because they can trigger errors and we want those errors to occur at locations polymorphic blame calculus now that we have established the machinery of explicit binding we consider how to combine dynamic casts with polymorphism the polymorphic blame calculus is shown in figure the syntax is simply the union of the constructs of the blame calculus and the polymorphic lambda calculus and the type rules are the union of the previous type rules two new cases for quantified types are added to the definition of type compatibility one each corresponding to casts to and from quantified types note that these break the symmetry of compatibility by the simplytyped blame calculus we discuss compatibility in with the corresponding reductions in sections and the intuition behind parametric polymorphism is that functions must behave uniformly with regard to type variables to maintain parametricity in the presence of dynamic types we that dynamic values corresponding to type variables must be treated abstractly recall that values of dynamic type have the form v g where g is a ground type a key difference in moving to polymorphism is that the ground types in addition to including base types and the function type now also include type variables x a value of the form v x is called a value we now briefly consider the reduction rules tests are updated so that if the value is then the test indicates blame rather than returning true or false the reason for this change is discussed in section two rules are added to push bindings into the one new value form ground values the motivation for these rules is also discussed in section finally the last two rules extend casts to the case where the target type or source type is a quantified type generalize instantiate these rules are discussed in sections and a side condition on generalize avoids capture of type variables and a side condition of instantiate avoids overlap with ground and generalize the rules and introduce two global blame labels and p which are not to label any cast generalization perhaps the two rules of greatest interest are those that cast to and from a quantified type we begin by discussing casts to a quantified type the reverse direction to section rule generalize casts a value to a quantified type by abstracting over the type variable and recursively the value note that the abstracted type variable may appear free in the target type of the cast observe that the corresponding rule for compatibility asserts that if the cast on the left of this rule is compatible then the cast on the right is also compatible we now have enough rules in place to return to our examples from section here is the first example k p x y xy x i i x y k p xy x i i y i xi k p xy x y i xi k x p y p p x y i xi k x y p x y i xi x p x y i xi the first step applies generalize twice while the step applies and id this yields as expected the second example is similar save for the last steps k p x y xy y i i y i xi x p y y i xi blame p blame p here the step applies conflict and the final step applies abort this yields blame p as expected parametricity we now consider some further examples with an to understanding how sealing preserves parametricity the parametricity property for the type x xx guarantees that a value of this type must be either the identity function or the careful readers will that some reductions are shown out of order so as to group related reductions together undefined function consider the following three untyped terms id x x inc x x test x if x is i then x else x function id is parametric because it acts uniformly on values of all types while functions inc and test are not since the former acts only on integers while the latter acts on values of any type but behaves differently on integers than on other arguments however all three functions to type x xx yields values that satisfy the corresponding parametricity property id as one might expect yields the identity function while inc and test perhaps surprisingly both yield the only other parametric function of this type the everywhere undefined function here is the first example id p x xx i xi id x p p x xi x p x the last step is by rules and id no matter which type and value are supplied the casts match up so this behaves as the identity function here is the second example inc p x xx i xi inc x p p x xi x q i i q blame q p x the last step is by rules conflict and abort here q labels casts in inc introduced by embedding typed integer addition into the untyped lambda calculus regardless of what type and value are supplied the casts still dont match so this behaves as the everywhere undefined function here is the third example test p x xx i xi test x p p x xi if x is i then · · · else · · · blame the last step is by rules and abort values should never be examined so rule ensures that applying a type test to a value always allocates blame rules and add to ensure they do not overlap with the use of explicit binding plays a central role the test i is i returns true while the test x is i allocates blame to even when x is bound to type i regardless of what type and value are supplied the test always fails so this behaves as the everywhere undefined function an alternative choice might be for v x is g to always return false on the that a value is distinct from any ground value this choice would still retain parametricity because under this interpretation the result of test would be the identity function however we would lose another key property we want to ensure that can lead to blame but cannot otherwise change a value in this case converts test to the everywhere undefined function which is acceptable while converting it to the identity function would violate our criterion finally consider the polymorphic type x x the parametricity property for this function states that it must be either a constant function ignoring its argument and always returning the same value or the everywhere undefined function lets see what happens when we cast id to this type id p x x i xi id x p p xi x p xi x blame p here rule plays a key role ensuring that the attempt to pass a value at type x through the binder for x must fail in an earlier system we that did not have bindings ahmed et al this term would in fact reduce to a value of type a strict interpretation of the parametricity requirement it was only a violation because the value of type was so any attempt to examine it would fail still from both a theoretical and practical point of view the current system seems because it detects errors earlier and even if the result of the cast is not examined instantiation having considered casts to a quantified type we now turn our attention to the reverse casts from a quantified type rule instantiate casts a value from a quantified type by instantiating the quantified type variable to the dynamic type and recursively the result observe that the corresponding rule for compatibility asserts that if the cast on the left of this rule is compatible then the cast on the right is also compatible the rule always with the dynamic type often we are to the dynamic type and in that case it seems natural to instantiate with the dynamic type itself however is this still sensible if we are to a type other than the dynamic type we show that there is a strong sense in which instantiating to the dynamic type is always an appropriate choice lets look at some examples let k be a typed constant function k x xx yx x here is an example to dynamic type k x p k p instantiating typed code to works when typed code to untyped code perhaps more surprisingly it also works well when typed code to a different type because every value into the type instantiating to yields an answer if instantiating to any type yields an answer here is an example of to static type k x p i i i k p iii this of course gives us exactly the same answer as if we had instantiated k to i instead of k i i i i p i i i in this sense we say that is a if instantiating to any type yields an answer then so does instantiating to however instantiating to is something of a policy in that it may yield an answer when a strict instantiation would fail for instance consider a slight variant on the example above k x p i i true k p i i true here instantiating to i directly is more strict yielding blame rather than a value k i iii p i i true blame p in other words though a is a of none to formulate the relevant property precisely we need to capture what we mean by saying that one term yields an answer if another does so we formulate a notion of contextual approximation first we define convergence and divergence a term that neither nor diverges must allocate blame definition a closed term s written s if s v for some value v and diverges written s if the reduction sequence beginning with s does not terminate next we define a variant of contextual approximation where a term that allocates blame approximates every term definition term s approximates term t written s t if for all evaluation contexts e we have · es implies et and · es implies et we can now state the principle theorem principle if v x a and b and hence ax b then v c p b v ax p b we defer the proof until section evaluation under type abstraction as noted in section an feature of our presentation is that we evaluate type abstractions we now provide an example there of why such evaluation is necessary parametricity guarantees that a term of type x x cannot reduce to a value one term with this type is x blame r in our calculus this term is not a value and it evaluates to blame r however if we did not evaluate under type abstractions then this term would be a value we want it to be the case that v a p q a is equivalent to v for any value v of type a among other things it is easy to show that this is a consequence of the principle however if x blame r is a value this is not the case x blame r x x p q x x x blame r p q x x x blame r p q x x blame r this is no cast that should leave a value unchanged has instead converted it to blame the solution to this difficulty as described in section is to permit evaluation under type abstractions and to only regard terms of the form x v as values we conjecture that if we based our system on callbyname rather than callbyvalue that evaluation under type abstraction would not be necessary type safety the usual type safety properties hold for the polymorphic blame calculus lemma canonical forms if v c then v c and c for some c and or v w g and c for some w and g or v xa t and c ab for some x t a and b or v x w and c x a for some w x and a compatibility ab aa a b a a bb ab a b ax b xa b ab a xb x subtype a b a a a g a a a b b a b a b b x a b a b a x b x positive subtype a b a a a a a b b a b a b ax b x a b a b x a x b negative subtype a b a a a g a b b a a b b a b a b ax b x a b a b a x b x naive subtype a n b a n a a n a n a b n b a b n a b ax n b x a n b a n b a n x b x figure subtyping relations proposition preservation if s a and s s then s a proposition progress if s a then either · s v for some value v or · s s for some term s or · s blame p for some blame label p preservation and progress on their own do not guarantee a great deal because they do not rule out blame as a result in sections and we characterize situations in which blame cannot arise subtyping relations figure presents the compatibility relation and four forms of positive negative and naive compatibility determines when it is sensible to attempt to cast one type to another type and the different forms of subtyping characterize when a cast cannot give rise to certain kinds of blame all five relations are reflexive and all four subtyping relations are transitive why do we need four different subtyping relations each has a different purpose we use a b to characterize when a cast from a to b cannot yield blame for that cast one useful consequence is that from a quantified type x b to any instance of that type never yields blame however while subtyping gives a strong guarantee it arises relatively in programs that integrate static and dynamic typing what we wish to show for such programs is not that they never fail but that when they do fail that blame always lies on the less precisely typed side of the cast and this is the purpose of the other three relations we use a b and a b to characterize when a cast from a to b cannot yield either positive or negative blame respectively and we use a n b to characterize when a is a more precise type than b the definitions are related in that a b holds if a b and a b but not conversely and a n b holds if and only if a b and b a we tried to our definitions so that the first clause like the second would be an equivalence but failed to do so compatibility is written a b it is reflexive and the dynamic type is compatible with every other type the remaining three compatibility rules can be read off directly from the reductions wrap instantiate and generalize replacing in the reductions yields the conditions in the rules the casts on the lefthand side of the reductions correspond to the in the conclusion of the rules and the casts on the righthand side correspond the hypotheses thus the compatibility rules are designed to ensure that reducing compatible casts yield compatible casts function compatibility is contravariant in the domain and covariant in the range corresponding to the in the wrap rule a polymorphic type x a is compatible with type b if its instance ax is compatible with b corresponding to the instantiate rule a type a is compatible with polymorphic type x b if type a is compatible with b assuming x does not appear free in a so there is no capture of bound variables corresponding to the generalize rule ordinary subtyping is written a b it characterizes when a cast cannot give rise to blame every subtype of a ground type is a subtype of because a cast from a ground type to never allocates blame as with all the relations function subtyping is contravariant in the domain and covariant in the range a polymorphic type x a is a subtype of a type b if some instance is a subtype of is the one way in which subtyping differs from all the other relations which instantiate with rather than an arbitrary type c it is easy to see that a b and a b together imply a b but not conversely the next two relations are concerned with positive and negative blame if reducing a cast with label p allocates blame to p we say it yields positive blame and if it allocates blame to p we say it yields negative blame the positive and negative subtyping relations characterize when positive and negative blame can arise in the next section we show that a cast from a to b with a b cannot give rise to positive blame and with a b cannot give rise to negative blame the two judgments are defined in terms of each other and track the of blame labels that occurs in the contravariant s sf p a b s sf p s a p b sf p a b s sf p s a p b sf p q p q p s sf p s a q b sf p s sf p s g sf p s sf p qp s is g sf p blame q sf p c sf p t sf p opt sf p x sf p t sf p t sf p s sf p x a t sf p t s sf p t sf p t sf p t sf p x t sf p t a sf p xa t sf p figure safety for and position of function types we have a and b for every type a and b because to can never give rise to positive blame and from can never give rise to negative blame we also have a g implies a b because a cast from a ground type to cannot allocate blame and a cast from to any type cannot allocate negative blame we also define a naive subtyping judgment a n b which corresponds to our informal notion of type a being more precise than type b and is covariant for both the domain and range of functions the blame theorem the blame theorem asserts that a cast from a positive subtype cannot lead to positive blame and a cast from a negative subtype cannot lead to negative blame the structure of the proof is similar to a type safety proof depending on progress and preservation lemmas however the invariant we preserve is not but instead a safety relation t sf p as defined in figure a term t is safe for blame label p with respect to and written t sf p if every cast with label p has a source that is a positive subtype of the target and every cast with label p has a source that is a negative subtype of the target we assume that p and p p lemma blame progress if s sf p then s blame p lemma blame preservation if s sf p and s s then s sf p positive and negative subtyping are closely related to naive subtyping proposition factoring a n b iff a b and b a the proof of proposition requires four observations lemma if a b and x a then x b if a b and x b then x a given x b we have ax b iff a b given x a we have a bx iff a b we may now characterize how positive negative and naive subtyping relate to positive and negative blame note that typically each cast in a source program has a unique blame label corollary blame theorem let t be a program with a subterm s a p b where the cast is labelled by the only occurrence of p in t and p does not appear in t s sf p a b s sf p a b s sf p s a p b sf p s a p b sf p q p q p s sf p s sf p s a q b sf p s g sf p s sf p qp qp s is g sf p blame q sf p t sf p c sf p opt sf p x sf p t sf p t sf p s sf p x a t sf p t s sf p t sf p t sf p t sf p x t sf p t a sf p xa t sf p figure safety for · if a b then t blame p · if a b then t blame p · if a n b then t blame p · if b n a then t blame p the first two results are an immediate consequence of blame progress and preservation lemmas and while the second two results are an immediate consequence of the first two and factoring proposition because our notion of more and less precise types is captured by naive subtyping the last two clauses show that any failure of a cast from a term to a context must be on the context and any failure of a cast from a term to a context must be on the term the blame theorem and subtyping theorem give no guarantees regarding the two global blame labels and p we are an alternative design in which the is and forms are labelled and the safety relations can guarantee the absence of blame going to those labels under suitable static conditions the subtyping theorem the subtyping theorem asserts that a cast from a subtype to a supertype cannot lead to any blame as with the blame theorem the structure of the proof is similar to that of a type safety proof depending on progress and preservation lemmas again we use a safety relation s sf p as defined in figure a term t is safe for blame label p with respect to written s sf p if every cast with label p or p has a source that is a subtype of the target we assume that p and p p lemma subtyping progress if s sf p then s blame p the preservation result is a little more complex than that for the blame theorem because it involves approximation as introduced in section lemma subtyping preservation if s sf p and s s then either s sf p or there exists s such that s s and s sf p the proof is by case analysis on s s and s s where the case for instantiate depends on the principle we may now characterize how subtyping relates to blame syntax binding reference p q x x terms s t c opt x xa t t s x v t a xa t s a p b values v w c xa t x v v a x x contexts e · e t e s v e e a xa e e a p b type rules t b xa reveal t b x t xa t x b b reduction rules x v a xa v b x if x v x b xa v b y y xa v b y y v p v x a t ab p a b xa a p a b p b x v x b p x b x v b p b v x p x v if x p and x p if x p and x p v a x x x a v figure polymorphic lambda calculus with static casts extends and updates figures and syntax terms s t c opt x xa t t s sa p b sg s is g blame p x t t a xa t sa p b values v w c xa t v g x v v a x x contexts e · e t e s v e e is g ea p b eg x e e a xa e ea p b reduction rules v p v figure polymorphic blame calculus with static casts extends and updates figures and corollary subtyping theorem let t be a program with a subterm s a p b where the cast is labelled by the only occurrence of p in t and p does not appear in t · if a b then t blame p and t blame p the result is an immediate consequence of subtyping progress and preservation static casts the polymorphic lambda calculus with explicit bindings figure includes two type rules that are not syntax directed reveal and in this section we introduce the polymorphic lambda calculus with static casts which extends the earlier calculus by adding two new constructs so that the two type rules in question become syntax directed the result is a calculus which syntactically records exactly where type abstraction occurs similar in some respects to that of et al the more refined type information provided by the new calculus will be of use in the proof of the principle provided in the next section polymorphic lambda calculus with static casts we introduce the polymorphic lambda calculus with static casts in figure it proves convenient for the new constructs to use a notation similar to that for dynamic casts and hence we call them static casts dynamic casts may fail and are with a blame label static casts may not fail and are with a binding reference static casts come in two forms corresponding to the rules reveal and in the polymorphic lambda calculus with explicit binding assume binding xa appears in the environment we reveal the binding of a type variable with the construct s b x and we the binding with the construct s x b for convenience in the reduction rules we use the syntax s a p b to range over both forms where p is a binding reference that is either x or x we write p for the that adds an when one is missing or removes the when one is present with the addition of static casts we have a new value form it is now the case that a value of type x always has the form v a x x where v has type a and x is bound to a in the environment the rule for type application is modified to also insert a suitable static cast the static cast depends upon the type of the type abstraction it is easy to annotate terms to preserve this information we introduce a reduction rule to push explicit bindings through the one new value form surprisingly the reduction rule requires no side conditions the type system already ensures that x y and x we also introduce reduction rules to perform static casts for each type constructor base types functions quantified types and type variables the rules to push a static cast through a base type or a type variable both the rule for dynamic casts id the rule to apply a static cast to a function the corresponding rule for dynamic casts wrap just as wrap the cast on the arguments and the blame label also the static cast on the arguments and the binding reference one difference between and wrap is that does not introduce a new wrapper function to apply the cast but instead performs substitution directly in the body of the lambda abstraction this greatly simplifies the simulation relation used in the proof of the principle the approach is not for wrap because a dynamic cast can fail but works here because a static cast cannot fail the rule to apply a static cast to a quantified type is simpler than the corresponding rules for applying a dynamic cast for dynamic casts we require separate rules for universal quantifiers in the source instantiate and in the target generalize while for static casts it suffices to use a single rule to handle a universal quantifier in both the source and target since one will be a substitution instance of the other finally if a static cast meets its negation the two casts relation to explicit binding we relate the polymorphic lambda calculus with static casts to the polymorphic lambda calculus with explicit binding we define the erasure from the calculus with static casts to the calculus with explicit binding as follows c x xa xa t x x t a xa xa t a p proposition erasure if s a then a and if s s then either s · or s · type safety it is straightforward to show the usual type safety results for the polymorphic lambda calculus with static casts notably there is now one additional canonical form for a term whose type is a type variable proposition canonical forms if v c then either · v c and c for some c and or · v xa t and c ab for some x t a and b or · v x w and c x a for some w x and a · v w a x x and c x for some w x and a proposition progress if s a then either s v for some value v or s s for some term s proposition preservation if s a and s s then s a polymorphic blame calculus with static casts given the above development it is straightforward to augment the polymorphic blame calculus to include static casts as shown in figure the syntax is just the union of the of the previous calculi only one additional reduction rule is required to apply a static cast to the dynamic type of the previous results to relate the calculus with static casts to the one without are straightforward as are of the type safety results and we omit the details the principle we now provide the proof of theorem the principle to prove the theorem we introduce a relation s t that is contained in and prove that is a simulation examining the theorem gives our starting point for the relation v c p b v ax p b as these terms reduce this cast can break into many casts but they will all have the general form s a p b t a p b or the form s b p a t b p a where s t and a and a are the same except some types in a are replaced by in a to make the latter specific we introduce a few definitions definition if is a map from type variables to types its erasure is the map that takes each x in the domain of to definition we say that type a simulates type a written a a if there exists a type a and a map such that a a and a a for example if a and a we have a a by taking a y z and y xx and hence y z as a second example consider what type a may simulate a type variable x a x the answer is that x is the only type that simulates x so a x the full definition of the relation is given in figure the rules on the righthand side make a congruence and the remaining rules help us keep terms related as they reduce we add the following side condition to the rule the type variable in the binding reference does not appear anywhere in the program on the righthand side of this is because arises from in which there is a type abstraction on the left that does not appear on the right note that the simulation rules say nothing about types but when the terms on each side of the conclusion are well typed then the terms in the hypothesis are as well furthermore we have the following lemma lemma if s t s a and t a then a a the proof is a straightforward induction on s t an important property of is that it relates values to terms that reduce to values lemma value on the left of if v t then t w and v w for some value w in the proof that is a simulation the case for beta requires the following lemma regarding substitution lemma substitution preserves if t t and v v then t xv the result is a consequence of the fact that is a congruence we now show that simulates both the reduction relation and the step relation beginning with the former s t aa s a p b t a p b s t aa s b a t b a blame q t st y s t st s a p b t st xa s t vw v vw x v w cc xx s t aa xa s xa t s t s t s s t t blame s t aa y s y t st sa ta st s is g t is g st s a p b t a q b vw vg s t aa bb s a p b t a p b t t aa xa t xa t figure simulation relation lemma p simulates suppose s a and t b if s t and s s then t t and s t for some t the proof relies on the presence of bindings and static casts to preserve type information especially the presence of type variables lemma p simulates suppose s a and t b if s t and s s then t t and s t for some t we then prove that is contained in lemma if s t then s t proof the proof is by case analysis on the reduction of s suppose es then et by lemma suppose es then et by lemmas and the proof of the main theorem follows from this lemma proof of the principle we have v c p b v ax p b and we conclude by applying lemma related work runtime sealing and ahmed present semantics for a system scheme and ml that enforces the parametricity of ml values with polymorphic type with embedded scheme values their system places boundaries between the two languages their boundaries roughly correspond to a combination of a static and dynamic cast in our system the contributions of our work with respect to the work of and ahmed is that we apart the notion of dynamic and sealing associating sealing with type abstraction instead of the interface between languages and we establish the blame and subtyping theorems and the principle syntactic type abstraction et al develop a general theory of syntactic type abstraction in which multiple agents interact and have varying of knowledge regarding the types at the interfaces between agents their general theory can be used to express the type abstraction in the polymorphic lambda calculus as well as many other kinds of syntactic abstractions they present two systems a simple system and a system the system can handle a program with one type abstraction whereas the system is needed for arbitrary programs using one agent per type abstraction however the system adds considerable complexity for generality that is unnecessary in our setting the advantage of our system is that it up to handle arbitrary number of type abstractions while much of the simplicity of the system et al develop an extension of system f with type equality coercions their coercions closely the static casts of this paper including the reduction rules their system does not have an analogue of our type bindings and instead uses substitution to perform type application integrating static and dynamic and felleisen formalize the interaction between static and dynamic typing at the of modules and develop a to the blame theorem wadler and findler design the blame calculus on the blame tracking of higherorder contracts findler and felleisen and prove the blame theorem et al explore the interaction of type dynamic with refinement types and firstclass types that is allowing types to be passed to and returned from functions this provides a form of polymorphism but not relational parametricity in the language et al show how to integrate typed and untyped code using like types to the gap in a way that better enables compiler optimizations in statically typed regions of code their formal development includes classes and objects but not polymorphism conclusion we have extended the blame calculus with support for firstclass parametric polymorphism using explicit type binding to maintain relational parametricity for values of polymorphic type our calculus supports casts between the dynamic type and polymorphic types when from a polymorphic type our system the type variable with the dynamic type a choice justified by the principle if instantiating a type parameter to any given type yields an answer then instantiating that type parameter to the dynamic type yields the same answer we proved this principle via a simulation argument that on the presence of type bindings and static casts we have also proved the blame theorem so in the new polymorphic blame calculus welltyped programs cant be further as a corollary of the principle we have proved the subtyping theorem showing that a traditional notion of subtyping is sound with respect to our operational semantics looking forward there are interesting questions regarding how to extend this work to subset and dependent types ultimately we hope to obtain a language with a full type system supporting dynamic typing all the way to total correctness acknowledgments our thanks to for his support and in early discussions of this work work on this paper was supported by nsf grant and by a distinguished from the and computer science work was supported by nsf grant references martin abadi luca cardelli benjamin pierce and gordon plotkin dynamic typing in a statically typed language acm transactions on programming languages and systems ­ april ahmed robert bruce findler and philip wadler blame for all in workshop on evolution stop pages ­ robert bruce findler and matthias felleisen contracts for higherorder functions in acm international conference on functional programming icfp pages ­ october andrew john launchbury and simon l peyton jones a short cut to deforestation in acm conference on functional programming languages and computer architecture pages ­ september n and flanagan hybrid checking for flexible specifications in scheme and functional programming workshop scheme pages ­ september greg morrisett and syntactic type abstraction acm transactions on programming languages and systems ­ november robert bruce findler and polymorphic contracts in dynamic languages symposium pages ­ robert harper practical foundations for programming languages working draft dynamic typing syntax and proof theory science of computer programming ­ and ahmed parametric polymorphism through runtime sealing in european symposium on programming esop pages ­ and robert bruce findler operational semantics for programs in acm symposium on principles of programming languages popl pages ­ january james h morris jr types are not sets in acm symposium on principles of programming languages popl pages ­ october dreyer and parametricity in acm international conference on functional programming icfp pages ­ september and david walker dynamic typing with dependent types in ifip international conference on theoretical computer science pages ­ august benjamin pierce and relating cryptography and polymorphism manuscript url john reynolds types abstraction and parametric polymorphism in r e a editor information processing pages ­ northholland generativity and dynamic for abstract types in acm conference on principles and practice of declarative programming pages ­ g siek and gradual typing for functional languages in scheme and functional programming workshop scheme pages ­ september martin m t simon peyton jones and system f with type equality coercions in acm workshop on types in languages design and implementation pages ­ type inference with partial types in international colloquium on automata languages and programming icalp volume of lecture notes in computer science pages ­ springerverlag and matthias felleisen migration from scripts to programs in dynamic languages symposium pages ­ october philip wadler and robert bruce findler welltyped programs cant be in european symposium on programming esop pages ­ march andrew k wright simple imperative polymorphism higherorder and symbolic computation ­ dec and jan integrating typed and untyped code in a language in acm symposium on principles of programming languages popl pages ­ 