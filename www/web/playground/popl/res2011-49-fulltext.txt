streaming transducers for algorithmic verification of programs university of pennsylvania c abstract we introduce streaming data string transducers that map input data strings to output data strings in a single lefttoright pass in linear time data strings are unbounded sequences of data values tagged with symbols from a finite set over a potentially infinite data domain that supports only the operations of equality and ordering the transducer uses a finite set of states a finite set of variables ranging over the data domain and a finite set of variables ranging over data strings at every step it can make decisions based on the next input symbol updating its state the input data value in its data variables and updating variables by variables and new symbols formed from data variables while avoiding duplication we establish that the problems of checking functional equivalence of two streaming transducers and of checking whether a streaming transducer satisfies prepost verification conditions specified by streaming over inputoutput are in pspace we identify a class of imperative and a class of functional programs manipulating lists of data items which can be effectively translated to streaming transducers the imperative programs dynamically modify a heap by changing of and by adding new nodes the main restriction specifies how the can be used for traversal we also identify an equivalent fragment of functional programs that traverse a list using syntactically restricted recursive calls our results lead to algorithms for assertion checking and for checking functional equivalence of two programs written possibly in different programming for commonly used routines such as insert delete and reverse categories and subject descriptors d software engineering methods model checking f logics and meanings of programs specifying and verifying and reasoning about verification general terms verification theory algorithms keywords transducers algorithmic software verification lists this research was partially supported by nsf grants and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm introduction we propose streaming transducers as an abstract and model for programs that access and modify sequences of data items in a single pass the idea of using transducers for modeling such programs is a natural one however the class of regular which has theoretical properties such as mso characterization is defined by transducers as an example consider the reverse that the input string it is not definable using classical transducers such as machines we need a second backward pass during which the output is produced on the other hand this can easily be computed by a program that traverses a list both in the settings of imperative programs manipulating lists and functional programs using tail recursion our streaming transducer model can capture such computations naturally furthermore we show that verification problems such as checking functional equivalence assertion checking and checking correctness with respect to prepost conditions are decidable for this transducer model even in the presence of values from an unbounded data domain in the proposed model a deterministic streaming transducers map input data strings to output data strings in a single lefttoright pass in linear time a data string is a sequence of items of type data × tag where data is a potentially infinite set of data values and tag is a finite set of labels the only operations allowed on the type data are tests for equality and ordering and this restriction is essential for decidability the transducer uses a finite set of states a finite set of variables ranging over data and a finite set of variables ranging over data strings at every step it can make decisions based on the current state the tag of the next input symbol and the ordering relationship of the data of the next input symbol with the data values stored in data variables it can update the state modify data variables using the input data value and update the variables using assignments whose are of variables and new symbols formed using data variables a key restriction is that a variable can be used at most once in a expression at each step multiple variables are necessary for the transducer to compute different possible chunks of the output and the restriction on how they can be used ensures that at every step there is merely a of outputs computed so far without duplication we consider the following two decision problems for streaming transducers equivalence given two streaming transducers do they define the same partial functions prepost condition checking given a streaming transducer a precondition and a postcondition both expressed by similarly defined streaming over data strings is it the case that for every input satisfying the precondition the corresponding transducer output satisfies the post condition we show both problems to be in pspace we also show that extending the model along several possible directions leads quickly to undecidability of basic problems such as reachability we then identify a class of programs that precisely correspond to the streaming transducers the input to a program is a single list with elements of type data × tag possibly with additional arguments of types data tag and bool and the output is a single list possibly with additional returned values of types data tag and bool the key restriction needed for decidability of verification problems is that the program computes the output in a single pass processing the next item of the list at each step a number of commonly used routines such as insertion deletion membership reversal sorting with respect to tags but not data values naturally satisfy this restriction for imperative programs the input list is stored in a heap of nodes each of which can store a tag a data value and a pointer during the computation of the program the induce an forest structure over the nodes the program accesses the heap using a finite number of pointer variables and uses a finite number of data variables the program can add new nodes to the heap change values stored at nodes referenced by pointer variables and also modify of such nodes a key restriction on the traversal of the heap using is that the only legal use of the on the is in the assignment curr where curr is the unique pointer initially pointing to the head of the input list we also show that for this class of programs a variety of assertion checking problems such as is a program location reachable and does the heap acyclic are solvable in pspace finally we present a class of functional programs which traverse an input list from left to right using recursive calls the key restriction is that a call to the function f with input list l can recursively call f with input tail l and returns value obtained by composing its input arguments and the values returned by the recursive call without examining them we show that this class precisely corresponds to the streaming data string transducers thus the results of this paper show how to automatically compile two programs one written in imperative style and one written in functional style into an intermediate lowlevel transducer model and check if the two are semantically equivalent streaming transducers data strings and a data domain is a totally ordered possibly infinite set d of data values we will use to denote the strict total order over d throughout this paper assume d to be fixed a data symbol over where is a finite set of symbols or tags is a pair d with and d d a data string w over is a finite sequence d d k dk of data symbols over a data language over is a set l of data strings over a deterministic data from an input alphabet to an output alphabet is a partial function f from data strings over to data strings over for a data f from an input alphabet to an output alphabet the domain of f is the data language over consisting of data strings w such that f w is defined as an example let d be the set of strings over characters ordered by the standard ordering let contain two tags private and public a data symbol denotes an entry in an consisting of a name tagged either as private or public a data string represents an here are a few examples of data languages language l consists of all data strings in which names appear in the order that is data symbols are sorted in an increasing order according to over data values and language l consists of all data strings that do not contain duplicate entries a few examples of useful data are f maps a data string to its reverse f maps a data string w to ww where w is the subsequence of w containing private entries and w is the subsequence of w containing public entries and f an entry from the input data string if the string also contains to model operations such as insertion and deletion that take data as inputs in addition to a data string we can encode all inputs in a single data string for example the f given an input data string checks if names appear in the order in the tail w and if so it returns w with d inserted in the correct position to maintain the output string sorted f is undefined if the input string is empty or if the tail of the input string is not sorted transducer definition we now describe our model of deterministic transducers the transducer reads an input data string lefttoright in a single pass and computes an output data string the transducer uses a finite set of states a finite set of data variables that range over data values and a finite set of data string variables that range over data strings over the output alphabet at each step the transducer reads the next data symbol of the input string and chooses a transition depending on the current state the tag of the input symbol and the ordering relationship of the data value of the input symbol with values of all its data variables the transition updates the state updates the data variables possibly using the input data value and updates the data string variables in parallel using assignments whose are of data string variables and new data symbols formed using data variables when the transducer the entire input string the final output string is produced by similarly data string and data variables a key restriction is that a data string variable can be used at most once in a expression in a transition and thus at every step there is merely a of output chunks computed so far without duplication we now define the model formally a deterministic streaming transducer s from an input alphabet to an output alphabet consists of a finite set of states q an initial state q q a finite set of data variables v a data variable curr v used to refer to the data value of the current input symbol a finite set of data string variables x a partial output function o from q to × v x a finite set e of transitions of the form q q where q q is a source state is an input tag is a boolean formula over atomic constraints of the form v curr and curr v with v v q q is a target state and is an assignment mapping data variables v to v and data string variables x to × v x it is required that for each q q and x x there is at most one occurrence of x in and for each transition q q for each x x x appears at most once in the set of strings y y x and for each pair of transitions q q and q q with the same source state and input tag the tests and are mutually exclusive that is is unsatisfiable a valuation for such a transducer s is a partial function over data and data string variables such that for each data variable v v either v is undefined or is a data value in d and for each data string variable x x either x is undefined or is a data string over the output alphabet such a valuation naturally extends to a partial boolean function to evaluate tests each test is a boolean formula over atomic constraints of the form v curr and curr v with v v the value is defined if v is defined for all data variables v occurring in and if so is evaluated using the values assigns to these data variables a valuation also extends to strings in × v x given a string u in × v x the valuation u is defined when is defined for all the data and data string variables occurring in u and if so u is the data string over the output alphabet obtained by replacing each data string variable x in u with the data string x and each data variable v in u with the data value v given an s a configuration of s is a pair q where q is a state in q and is a valuation for s the initial configuration is q where q is the initial state of s v is undefined for each data variable v and x is the empty string for each data string variable x the transition relation over the set of configurations is defined as follows consider a configuration q and an input data symbol d the transducer first updates the valuation to by setting curr to the input data value d next let q q be a transition such that satisfies the test if there is such a transition then the updated state is q and the updated value of each data and data string variable x is obtained by evaluating the x according to the valuation that is if there exists a transition q q such that for curr d then q d q · determinism ensures that each configuration has at most one successor for a given input data symbol the transition relation extends to a relation over input data strings in the natural way given an input data string w over q w q means that the configuration of the transducer after reading the input data string w is q if no such configuration exists that means no transition is enabled at some step the semantics of s is then defined to be the s defined as for an input data string w over if q w q and is defined then sw is defined to be otherwise sw is undefined we call a data f from an input alphabet to an output alphabet to be if there exists an s such that s f examples to illustrate our definition of transducers let us consider the mentioned in section the f to reverse the input data string can be implemented by a streaming transducer s with a single state a single data variable curr and a single data string variable x the input tag is processed by the transition with update x by default a variable that is not explicitly updated remains unchanged we omit such assignments for readability the output function outputs x no tests on input data values are needed notice that classical definitions of transducers allow adding output symbols only at the end of the output computed so far adding a symbol to the front of the string variable x at each step is crucial to implement reverse in a single lefttoright pass now let us consider the f that maps a data string w to ww where w and w are the of w containing private and public entries respectively this can be implemented by an s that maintains two data string variables x and x and a single data variable curr at each step if the tag of current input symbol is private the symbol is added to x the precise assignment is x x curr x otherwise the symbol is added to x in a symmetric manner the output function outputs the concatenation xx note that it is not possible to implement this by an using just one variable the f a private entry from the input data string if the string also contains a public entry with a matching data value when reading an input symbol with data value d the streaming algorithm needs to figure out if a private entry with the same data value has been encountered before an with k variables can effectively use only k data values for tests at any step x u curr curr q q u curr v y curr q v curr v y curr u curr u curr v y v curr curr curr v y q curr u curr v y curr figure f and since the number of possible data values in an input string is unbounded f is not consider the f that inserts the head symbol of the input string in its tail provided that the tail is sorted the transducer s uses three data variables u to remember the head data value v to remember the previous data value and curr to refer to the current data value it uses a data string variable x to remember the first data symbol and y to compute the output the transducer is shown in figure the transducer is in state q initially in state q after reading one symbol in state q after reading or more symbols provided the tail so far is sorted and all its data values are smaller than the head data value stored in u and in state q after reading or more symbols provided the tail so far is sorted and the head symbol has already been inserted in the output in states q and q the variable v stores the previous data value and the test v curr checks for of the input v gets updated to curr at each step if this test does not hold no transition is enabled and the output will be undefined the transition to q inserts the data symbol stored in x in the output y the output function is undefined in state q and is x in state q yx in state q and y in state q streaming a streaming is a streaming transducer s with an empty set of data string variables such an s has a finite set of data variables that can remember the data values from the input string and can make decisions based on their relative ordering the output alphabet plays no role in the behavior of an given an input data string w either the output sw is defined or undefined and the domain of the transducer is the data language associated with the s this is the same as saying that the output function o marks states of s as accepting or based on whether the output function o is defined or undefined at a state we call a data language l over an alphabet to be if l is accepted by a streaming the data language l consisting of sorted data strings can be defined by such an using one data variable that the previous data value along with the data variable curr needed to refer to the data value of the currently read symbol thus l is a data language the data language l consisting of data strings without duplicate entries is not by an argument similar to the one for the f among different types of automata over data strings that have been studied data automata have as a good candidate for the notion of for languages of data strings however data automata are too expressive for our purpose as they have an undecidable emptiness problem in the presence of ordering on data values properties in this section we note some properties of streaming transducers at understanding their expressiveness first observe that a streaming transducer s cannot output new data values that is for every input data string w any data value appearing in the output data string sw must appear in some symbol in w second streaming transducers are bounded in the sense that the length of the output string is within at most a constant factor of the length of the input string proposition if f is a from to then for all input data strings w over f w ow the depends on the fact that the parallel assignment at each step is each variable can appear in a expression at most once not only this is needed for decidability of the equivalence problem it also allows an efficient implementation if the data strings corresponding to variables are stored in linked lists then the assignment can be executed by only changing a constant number of pointers proportional to the description of the transducer but independent of the lengths of the data strings they store and thus independent of the length of the input string proposition if f is a then given an input string w the output f w can be computed in time ow this also means that the sorting that maps an input data string to its sorted version is not due to wellknown lower bounds for sorting obviously streaming transducers cannot capture all streaming algorithms as a specific example let us the f that maps a data string w to ww where w and w are the projections of w containing private and public entries respectively consider the variation f that maps w to a merge of the two projections w and w taking elements from the two lists in an alternate manner this can be easily implemented in if we maintain two over the input string one corresponding to private entries and one corresponding to public entries note that the emptiness problem of finite automata with multiple is undecidable and the traversal allowed for streaming transducers is restricted by design to ensure decidability of key analysis problems in particular f is not let us now consider some closure properties for the class of transducers given two data f and f and a test l as a data language suppose we want to compute fw when w l and fw otherwise if all of f f and l are specified using then we can construct an for the desired by a modified product construction proposition if f and f are data from to and l is a data language over then the following data f is for an input data string w over if w l then f w fw else f w fw it turns out that data are not closed under functional composition that is given two s and s we cannot always construct an s such that sw proposition there exist data f and f from to such that the following data f is not for an input data string w over f w proof we choose to be a singleton set and thus it plays no role consider the f that maps a data string dd · · · dk to its reverse · · · d f is consider the f that maps a data string dd · · · dk to dk that is f just the first data value for each input symbol read it is easy to implement f by an now consider the composition f f · f the f maps an input data string dd · · · dk to we can prove that f is not note that the above proof uses the fact that the data domain d is unbounded and we can always find a fresh data value that has not appeared in the input string before if we make d finite then the transducers are closed under composition imperative programs updating linked lists we consider a class of imperative programs that manipulate list data structures each node of the heap stores a tag a data value and a pointer to another node for clarity in this section we will assume that the output alphabet is the same as the input alphabet so we need to consider tags of only one type the input data string is stored in such a heap using one node for each position null pointer indicates the end of the list a program is invoked with the reference to the of the list as input the program traverses the list using and computes using variables that range over tags over data values over booleans and over pointers into the heap it can create new nodes and add them to the heap and can also manipulate the shape of the heap by updating the of the nodes referenced by its pointer variables the output data string is returned using a that points to the head of the list storing that output during the computation of the program of two may point to the same node and thus the heap in general has a structure of an unordered forest since the output is computed by possibly the nodes that store the input we need careful syntactic restrictions to allow a traversal of the input list while repeated or nested traversals we require that a typical traversal assignment x for pointer variables x and y is the only legal use of the on the is in the assignment curr where curr is the unique input pointer assignments of the form y to update the heap structure are allowed provided x and curr are not the same an attempt to execute y in a state where x and curr reference the same causes a runtime error alternatively we can require each such assignment to be syntactically guarded by the boolean condition x curr a program can have additional input and output parameters and each such inputoutput parameter can be a data value a boolean value or a tag before we describe the syntax and the semantics in detail let us first consider a of examples the following function a list and corresponds to the data f function reverse input ref curr output ref result curr local ref prev curr if curr nil then curr while curr nil result curr curr prev prev result suppose given an input data string w and an input data symbol d we want to delete each symbol in w whose data value equals d and return the resulting data string along with a boolean flag that indicates whether or not some symbol was actually deleted the following function implements this function delete input ref curr input data v output ref result output bool b local ref prev while curr nil v curr b result curr prev curr if curr nil then curr nil while curr nil if v then curr b else curr prev curr curr nil syntax types variables are typed the possible types are bool for variables tag for variables ranging over the alphabet data for variables ranging over the data domain d along with an undefined value denoted and ref for reference variables that index into the data heap along with the null reference nil variable declarations a program variable is declared along with its type bool tag data or ref and an annotation which can be either local input or output the input annotation means that the variable is an input to the function a function has exactly one input variable of type ref and can have multiple input variables of other types we will use curr to name this unique input reference variable the output annotation means that the variable is an output of the function and local annotation means that the variable is neither an input nor an output there is exactly one output variable of type ref which is used to return a single data string the declaration of each output and local variable has an associated value the initial value of a variable of type bool or tag can be either a constant or an input variable of matching type the initial value of a data variable can be either or an input data variable the initial value of a pointer variable can be either curr or nil data expressions and assignments a data expression is of the form a variable of type data or where r is a variable of type ref denoting the data value stored in the indexed by r a data assignment statement assigns a data expression to a data variable tag expressions and assignments a tag expression is of the form a variable of type tag a constant from the alphabet or where r is a variable of type ref denoting the tag value stored in the indexed by r a tag assignment statement assigns a tag expression to a tag variable reference expressions and assignments a reference expression re is either a variable of type ref or the constant nil a reference assignment statement is either r re where r is a local or a output variable of type ref and re is a reference expression re where r is of type ref and re is a reference expression r de re where r is a local or a output variable of type ref and te is a tag expression de is a data expression re is a reference expression or curr the first assignment allows of reference variables except for the input variable curr the second assignment updates the heap by changing the of the indexed by r provided r and curr do not point to the same the third assignment creates a new with tag value given by te data value given by de and given by re the last assignment allows traversal and is syntactically restricted to ensure that only the unique input reference variable is used to traverse the input list boolean expressions and assignments an atomic boolean expression is either a boolean constant or tests equality between two tag expressions or tests equality or ordering between two data expressions or tests equality between two reference expressions a boolean expression is formed from atomic boolean expressions using standard logical connectives for negation conjunction and disjunction a boolean assignment statement assigns a boolean expression to a boolean variable statements an assignment statement is either a data assignment statement a tag assignment statement a reference assignment statement or a boolean assignment statement a statement s is either an assignment statement a conditional statement of the form if be then s or if be then s else s where be is a boolean expression a while statement of the form while be s where be is a boolean expression or a finite sequence of statements program a list processing program p consists of a sequence of variable declarations followed by a statement semantics recall that a program has a single input variable of type ref and a single output variable of type ref the semantics of a program is defined as a partial function from an input data string together with values for input variables to an output data string together with values for output variables for example the semantics of delete is a partial function from × d × d to × d × configurations given a program p its configuration is completely described by the values of its data tag boolean and reference variables the program counter indicating the next statement to be executed and the let loc be the set of locations in p this can be the set of vertices in the controlflow graph of the program a h consists of a finite set n of a data function fd n d that gives the data element stored at each node a tag function ft n that gives the tag element stored at each node and a function fn n n that gives the of each node where n is the set n together with the constant nil a c of p then consists of a location loc a data heap h n fd ft fn and a partial function over all the program variables that maps each data variable to d each reference variable to n each boolean variable to and each tag variable to initialization given an input data string d · · · k dk the initial heap h consists of the set n n nk of nodes one per each data symbol of the input string the data function is given by di the tag function is given by i and the function is given by ni for i k and nil the initial location is the unique entry location of the controlflow graph for the initial valuation curr n for all other input variables x x is set to the corresponding input value for all local and output variables x x is defined according to the initialization in the declaration for x the initial configuration c of the program is h transition relation over configurations the operational semantics of programs is defined by a transition relation over the configurations first given a configuration c n fd ft fn there is a natural way to evaluate a data expression de to obtain a data value d a tag expression te to obtain a tag value a reference expression re to obtain a value n and a boolean expression be to obtain a boolean value every program configuration c n fd ft fn can have at most one successor configuration determined by the statement s at location the details are standard and we illustrate them using a few cases suppose the statement is a conditional statement if b then s else s then if cb then the successor configuration of c is h and if cb then the successor configuration of c is h suppose the statement s is a reference assignment statement r de re the effect of executing the statement s updates the control location from to the unique successor location of the statement s for the updated data heap h the set of nodes is n n where n n is a new the data function is the tag function is and the function is the updated valuation is r n suppose the statement s is a reference assignment statement re if cr then this is an error and the configuration c has no successor otherwise the successor configuration is c such that the location is the unique successor location of in the controlflow graph the valuation unchanged and the updated heap is n fd ft that is the of the node cr in the heap changes to which may be nil or a termination and output an execution of the program is obtained by starting in the initial configuration c and with the successor configuration as long as possible if this execution is infinite then the program is nonterminating and the output is undefined suppose the execution is finite and ends in the configuration cf f hf f if the location f is not the unique exit location of the controlflow graph then again the output is undefined otherwise the returned value of each output variable is given by the final valuation f of program variables for the unique output reference variable r let d d · · · be the unique sequence of values stored in the heap hf starting at the node f r following the until the nil value is encountered if this sequence is infinite this indicates that the program created a cycle in the heap during its computation and the output is again undefined if this sequence is finite it is the returned output data string streaming transducers with transitions we extend the model of streaming transducers by allowing the transducer to update its state data variables and data string variables using an transition that does not consume an input symbol we will first show that it is possible to eliminate such transitions and then we will translate programs to transducers with transitions the definition of a deterministic streaming transducer s with transitions extends the definition of as follows in a transition q q can now also be provided there is no transition of the form q q with the restriction is needed for ensuring determinism in a state q either all outgoing transitions are transitions or all outgoing transitions have non tags and thus consume the next input symbol note that the original determinism requirement still applies if there are multiple transitions with same source state and same input tag which now may be their tests must be mutually exclusive r n n n n n n n n n n n r r w w r curr figure storing heap in data strings as in case of a configuration consists of a state q and a valuation for the data and data string variables the definition of the transition relation q d q for and d d is unchanged the transitions are defined by if there exists a tion q q such that then q q · a run over the input data string w is obtained by starting in the initial configuration q and applying either an transition or a transition corresponding to the next input data symbol until all the input data symbols are consumed and no more transitions are possible this ensures determinism for a given input string w there is at most one configuration q such that q w q and q has no successor the semantics sw is defined to be ow in such a case provided is defined and is undefined otherwise note that it is possible that such a transducer keeps on executing transitions without terminating and in such a case the corresponding output is undefined it turns out this extension does not add to the expressiveness proposition given a streaming transducer s with transitions one can effectively construct a streaming transducer without transitions s such that s s with the same number of states same number of data variables and the same number of data string variables from programs to streaming transducers in this section we describe how to translate list processing programs to streaming transducers the first step is to view the semantics of a list processing program as a partial function from data strings to data strings to associate such a data string p with a program p we encode input parameters in the same manner as described in sec if p has ki input variables and ko output variables then we prefix the input data string with ki symbols each encoding one input argument and prefix the output data string with ko symbols each encoding one output value the main challenge in the construction is to store the information in the data heap used by the program p using a bounded number of data and data string variables in the corresponding transducer s figure shows a possible configuration of the data heap that the program accesses using the reference variables curr and r r r r the first observation is that the that are not accessible from any of the reference variables are not relevant to the execution of the program and can be ignored second nodes such as n and n that are accessible from can contain only input symbols that the program has not processed so far these nodes have not the execution of the program so far and information in these nodes does not need to be stored when the program executes the statement curr the node n becomes relevant this step is analogous to the transducer s processing the next input symbol the heap using a bounded number of strings is achieved using an encoding similar to a node is called a referenced node if a reference variable points to it in the example n n n and n are referenced nodes information in such nodes needs to be stored explicitly by s for each reference variable r of p s maintains a data variable dr and a tag variable tr storing the information in the node that r points to a node such as n is called an node as two nodes point to it and both these nodes are accessible from the programs reference variables if p has k reference variables then there can be at most k nodes the n n and n n n are heap segments in each such segment the first node is either an node or is the of a referenced node the of each node in the sequence points to the next node in the sequence no node other than the first is an or a referenced node and the of the last node is either nil or points to an or a referenced node if p has k reference variables then there can be at most k heap segments the sequence of data symbols stored in an heap segment is stored in a data string variable by s in our example the data string w stores the data symbols in n n and the data string w stores the data symbols in n n n the finitestate control of s the shape of the heap r and r point to the same node the of the node points to the data string stored in w the of the node referenced by r and of the last node of w point to w w is followed by the node which is followed by the node such a shape can be captured by a function fn y y where y contains all the reference variables of p and all the data string variables of s that store the data strings in heap segments if p executes the assignment curr then n is no longer an node and in this case the two heap segments into one this is achieved by s by the assignment w w ww to the data string variables updating the variable corresponding to r and changing the shape by updating to r and to curr proposition given a program p one can effectively construct a streaming transducer s with transitions such that p s if p has m locations kr reference variables kb boolean variables kt tag variables and kd data variables then s has kd kr data variables kr data string variables and om · kb · · states proof the transducer s has a data variable for each data variable for p and also for each reference variable of p to store the data values in referenced nodes in the heap it has kr data string variables to store heap segments the state of s stores the location of control of p the boolean value of each boolean variable of p the tag value of each tag variable of p a partition of the reference variables of p two reference variables are in the same partition if they point to the same for each equivalence class in the partition either a tag value stored at the node referenced or nil and for each data string variable and each equivalence class of the partition a next value that gives either a data string variable or an equivalence class of the partition the last component stores the shape of the heap the bound on the possible number of states follows by a simple counting argument if p has data boolean or tag input variables the transducer s first the initial prefix of data symbols setting up the initial values using transitions then the transducer processes the first input symbol assigning the corresponding to curr in its state to tag of the input symbol and assigning the data variable corresponding to curr to data of the input symbol after this phase the control location is set to the unique entry location all output strings are empty there are no heap segments in the initial heap and the partition has only two classes some reference variables are nil and some are in the class that contains curr we now describe transitions of s corresponding to statements of p the only statement that causes a non transition is the statement curr the transition that corresponds to this statement in s changes the stored control location of p changes the partition of reference variables into equivalence classes curr is split from its current equivalent class a new tag value is stored for the new equivalence class of curr for each reference variable p from the previous equivalence class of curr the new next value of p ie will be curr if for any data string variable x that stores an heap segment of s we have curr then we append the current data symbol from before the transition is executed to x all other statements are captured by an transition as they do not correspond to the move of the head of the automaton boolean tag and data assignments can be simulated directly we have already described using an example how a statement curr can affect the shape of the heap and how this is captured by assignments that s can perform in its transitions in section we have mentioned that the assignments that a streaming transducer performs on its data string variables can be executed by only changing a constant number of pointers a program equivalent to a transducer stores data strings in list segments on the heap and keeps pointers to the first and last nodes of the segment to perform an assignment of the form x xy the program performs commands yf xl yl where xf xl is a reference to the first last node representing x and similarly for y we obtain the following proposition proposition given a streaming data string transducer s one can effectively construct a program p such that s p functional programs on lists we consider a simply typed functional language with types bool tag data list and function types with letrec recursion and pair and list constructors as in the previous section we assume that for ease of presentation the terms are defined by t true false t t s for all s tag x fun t t if t then t else t x x x x tt t t nil cons t t append t t t head t tail t let xt in t letrec in t the operators and apply to terms of type data the lists are of type list tag × data or list for short the list and pair terms are standard we defined a class of functional programs that intuitively captures functions that process a list by through it from left to right the recursion restriction we define is a minor generalization of tail recursive functions where we allow the caller to perform operations on but not test the values that the callee returns this allows capturing common routines such as insert delete and reverse both and recursive we allow wrapper functions in order to enable the standard programming style for tail recursive functions a function is a list processing function iff it is defined by the following term fun × t letrec × t × t list × t t in f a this term encodes a wrapper function that can pass some additional arguments to a recursive function f the following conditions are required to hold · one list let us denote the first argument to f by definition of type list by l the list l is the only list accessed by head and tail the contents of the other list variables are thus not examined however it is possible to use cons or append with these variables · type restrictions the types t and t are products of types bool tag data with possibly more than one component of each type these are input and output arguments of the list processing function the type t is a product of types bool tag data and list with possibly more than one component of each type intuitively these are buffers where the recursive function can store results · recursion restriction the first argument to any recursive call is the term tail l where l is the first argument to f every recursive call to f is in an expression e defined by let r f tail l a in t furthermore e is the last expression the caller evaluates ie t is the callers result using the type restriction above we have that r l r rn and a a an and t l t tn where l is a list and l is a list expression each of r rn and t tn is of type bool tag or data and each of a an is of type bool tag data or list we have the following restrictions on these subexpressions i a list variable of f can appear in at most one expression ai or tj this is similar to the restriction that requires the assignments of to be ii if ti is of type bool then the only variable from r it can use is ri iii if ti is of type tag or data then we have ti ri iv the only variable from r that l can use is l · term t the term t is of the form fun x list × t × t t where t does not contain the function definition term fun or the recursive definition term letrec · the expression is of type t if t contains list types the corresponding values in are nil note that all the above conditions can be checked syntactically examples the data f that a list can be encoded as a list processing function as follows fun letrec reverse list × list list fun fun if l then result else reverse tail l cons head l result in reverse l nil a function that given a list l and a data value d all occurrences of d in l is encoded as follows fun letrec list × data list fun fun if l then nil else if head d then tail l d else cons head l tail l d in l d one of the recursive calls in is in an expression that adds a cell to the front of the list cons head l tail l d this recursive call is not tail as the caller function applies an operation to the result returned by the callee however the recursive call satisfies the recursion restriction from our definition of list processing functions and it satisfies the other restrictions as well the constructions in this paper lead to an algorithm to check if the imperative function delete of section and the above function are semantically equivalent ie specify the same such a check can be used for full functional verification of one using the other as the specification from list processing functions to streaming transducers semantics the simplytyped functional language we defined contains standard terms the values of the language as well as the typing rules and the evaluation relation t t for all the terms are omitted here as they can be found in a standard the operational semantics is given by a transition system whose states are subterms of f whose transitions are given by the evaluation relation t t and whose initial state is the term f as for imperative programs the semantics of a list processing function can be viewed as a data string that is a partial function from data strings to data strings to associate a f with a list processing function f list × t t we encode input parameters in the same way as in section given a data string w its first ki symbols can represent ki input variables and the rest represents the input list converting a data string to a list term of type list is straightforward given a data string the function ki returns the parameter values and the function ki returns the tail of the input string represented as a list term similar encoding to data strings can be used for output values and output lists given a tuple l r rn of type list × t enc r rn returns the corresponding data string given a list processing function f we have that fw w iff f l r rn and enc r rn w proposition given a list processing function f list × t t one can effectively construct a streaming data string transducer s such that f s let g be the recursive function used by f if g has kb boolean variables kt tag variables kd data variables and kl list variables then s has · kt states kd data variables and kl data string variables we note that the construction used in the proof of proposition is more direct than the one used in the proof of proposition the list variables apart from the list that is traversed and data variables are modeled directly by data string variables and data variables of the transducer and the control state of the transducer encodes the value of boolean and tag variables given an s we can construct an equivalent program f we first describe the arguments of the recursive function g the function f uses its boolean arguments encode state of s its data arguments correspond to data variables of s and its list arguments correspond to the data string variables of s a transition q q is translated by making the function g test whether the current boolean arguments correspond to q whether the current tag is and whether holds for the current data arguments if so the function makes a recursive call with parameters encoding q and the assignments from the function we obtain in this way is tail recursive the next proposition follows proposition given a data string transducer s one can effectively construct a list processing function f such that s f decision problems in this section we prove that the equivalence problem and the prepost condition checking problem are decidable for streaming data string transducers we also show that for a number of extensions of the streaming transducer model already the basic analysis problem of reachability is undecidable sound and complete abstraction for order and equality in proofs of decidability of equivalence and prepost condition checking of that operate on an infinite data domain d we will construct finite state systems that do not store values of the data variables of the but only keep track of order and equality predicates in order to prove that such an abstraction is both sound and complete for analysis problems we will need the lemma presented in this subsection let v be a set of variables that range over d we fix v and an infinite d for this subsection we will consider pairs of the form v d where the set v d v represents the set of variables with a defined value and where is an on v d short for order on equivalence classes an is a pair where the first component is an equivalence relation on v d and the second component is a strict total order on equivalence classes of for data variables v v we write v v if v belongs to an equivalence class c v belongs to an equivalence class c and c c for example if v v v v all variables have a defined value then a possible on v d can be represented as v v v let be a valuation of data variables as in the definition of a pair v d represents a set of valuations we write v d iff is defined precisely for the variables in v d and for all v v v d we have that v v iff v v and v v iff v v let be a boolean combination of constraints of the form v v and v v for variables v v v let be a map from v to v modeling assignments as in the definition of transitions of we write if satisfies and · similarly to the definition of for pairs v d we define a transition relation v d v d iff a v d contains the variables which were assigned to by from variables in v d b implies and c is the obtained from by executing let ua be a sequence of pairs vd vd n let u be a sequence of valuations n let upd be a sequence of pairs n n the sequence ua to the sequence upd if for all i if i n then i ii i similarly the sequence u to the sequence upd if for all i if i n then i ii i the proof of the following lemma uses the fact that the infinite data domain d contains chains that is sequences of elements in an increasing order of unbounded length the proof is omitted here in the interest of space a similar proof is a part of the proof of theorem of lemma let upd be a sequence of pairs n n let ua be a sequence of pairs vd vd n such that ua to upd then there exists a sequence of valuations u n such that u to upd and for all i if i n then ui equivalence checking given two streaming transducers s and s from to the streaming transducer equivalence problem is to determine whether s s in order to show that the problem can be solved in pspace we reduce the problem to a reachability problem in counter machines a counter machine m is a tuple qm m qm fm where qm is a set of states qm is the initial state and fm qm is a set of final states the transition relation m is a relation in qm × qm × note that counter machines do not test the content of the counter a configuration of the counter machine is a pair in q × z that is it consists of a state and the value of a counter a transition relation on configurations is defined as follows q z q z iff q q c m and z z c the counter reachability problem is to decide whether there exists a state q fm such that qm q this is a special case of the reachability problem for pushdown automata while the latter is the following lemma shows that the former is in lemma the counter reachability problem is in proof consider a counter machine m qm m qm fm we observe that for all q q qm if there is a path q q then there is such a path with stack depth bounded by n this is a consequence of a reachability algorithm easily adapted from reachability algorithm for pushdown automata which computes summaries for pairs q q the iteration in which a pair q q gets added is the minimum absolute value of counter needed to reach from q to q the number of iterations is at most the number of summaries that is n note that this observation holds for all pushdown automata we can thus assume that the counter ranges over n n state of a counter machine is q z where z is the value of a counter therefore we need to consider only on possible configurations this statement does not hold for general pushdown automata thus our reachability problem is a reachability problem in a graph with on states the problem can be therefore solved in space n theorem the streaming transducer equivalence problem is in pspace proof let us consider two streaming transducers s and s from to they are not equivalent if there exists an input data string w over such that one of the following three conditions hold i sw is defined but sw is not or ii sw and sw are defined but have different lengths iii sw and sw are defined and have the same lengths but there exists a position p such that the data strings sw and sw differ at the position p we construct a counter automaton and a state q such that q is reachable in m if and only if s and s are not equivalent the automaton m nondeterministically chooses which type of difference of the three described above it will find we only describe here how m can determine that there is an input string such that the output symbol of s is different from the output symbol of s the construction for the other two cases uses similar ideas and is simpler the automaton m nondeterministically simulates s and s running in parallel it keeps track of states of s and s precisely but only keeps some information on the data and data string variables intuitively m during the course of simulation of s resp s where the position p in the output is and uses its counter to check that the guess is the same for s and s for each data string variable m at each step where the contents of the variable will appear in the output with respect to the position p more concretely for each data string variable x of both s and s m which of the following categories the variable is in i left of p class l ii center ie position p is in this string class c iii right of p class r iv x does not contribute to the output class n maintaining consistency of assignment of data string vari ables into these four classes is straightforward first consider the case when at a particular step s performs an assignment y a v and m that the contents y will appear to the left of the position p in the output of m to verify that this guess is consistent with previous m checks that in the previous step z was in class l the assignment caused two output symbols a v and b v to appear to the left of the position p therefore m increases its counter by outputs of s are taken into account by decreasing the counter rather than ing second if at a particular step s performs an assignment x a vz and m that the symbol b v in this assignment will be at the position p then i m verifies that at the previous step y was in class l and z was in class r ii m increases its counter by two in order to simulate the fact that s outputs a v and b v as before when simulating s m decreases the counter and iii m assigns x to class c note that initially no variable is assigned to class c and at each step at most one variable is in class c because of the assignment re the cases when m that a variable to which s resp s assigns is in class r or class n are similar in the remainder of the proof we assume that the data domain d is infinite if it is finite the automaton can directly store values from d in its finitestate control and the construction is simpler for data variables m keeps track of which variable is defined and for the defined variables it keeps track of the ordering and equality information more precisely let us consider the following set of variables v v curr v curr vp vp curr where v and v are the sets of data variables of s and s and vp and vp are used by m to store information about the data value s and s output at position p the automaton m stores a pair v d where v d v that contains all of the variables whose values are defined in computation of s and s and is an on v d the pair v d is updated as steps of s and s are simulated and their transitions are executed note that m maintains only one variable curr common to m and m because the two automata are running on the same input the fi part of the construction is the of vp the variable used to store the output of s at position p when m that the output symbol of s at position p will be one in the righthand side of the assignment such as x a vz it is simulating currently it assigns x to class c as above and if it that at position p is the symbol b v then i the value b from is stored in the finite state control of m and ii vp is added to v d the set of defined variables and vp is added to the equivalence class of v in the construction for vp is analogous to summarize a state of m consists of a state of s a state of s a set v d v representing the defined variables an a partition of the data string variables of s and s to classes as described above and a symbol from at position p for s and s if m that the output to position p was already performed the set of states of m is thus a product q × q × v × × qb with the components corresponding to items to the initial state of m is the tuple containing initial states of s and s with the set v d empty all the variables are undefined and the component has a special value i from this state there are nondeterministic transitions which choose the initial assignments of data string variables to classes the other transitions are as described above the set of final states consists of states where either the variables vp and vp are defined but does not imply vp vp or the symbols stored in the finitestate control of m for position p in output strings of s and s differ we now prove that a final state of m is reachable iff there exists an input data string w and a position p such that sw and sw differ at position p we will need the following notion that relates configurations of m to configurations of s and s let c q be a configuration of s let c q be a configuration of s and let cm qm qm v d qb e be a configuration of m e is the value of the counter the cm is an abstraction of configurations c c denoted by c c cm iff the following conditions hold · states the states of s and s are the same in c and c as they are in cm · data variables or are defined for each of the variables in v d and the values and assign to variables in v d are consistent with · data string variables let el be the number of symbols in the data string variables of s that are assigned to class l in qb class c in qb contains by construction at most one data string variable of s if class c contains a data string variable x of s then we can a position p in the data string in x let ec the values be the number of characters to the left of el and ec are defined analogously for p s in x and a position p in a data string variable x the following equality is required to hold el ec el ec e where e is the counter value in cm furthermore let d be the data value at position p we have that the equality and order relations that contains on vp and the other data variables hold for d and the values of these data variables given by and an analogous condition holds for the data value at position p claim the automaton m can reach the configuration cm q q v d qb e in k steps iff there exists an input string w of length k such that s s after traversing this input reaches a configuration c c and c c cm the claim is proven by induction on k the more difficult part of the proof of the claim is the lefttoright implication where we are required to find an input string w that satisfies the condition we need to find a sequence of valuations that is the same as the sequence of pairs v d given by the sequence of configurations of m it is here that lemma is used using claim we now prove that a final state of m is reachable implies that there exists an input data string w and a position p such that sw and sw differ at position p a final state of m is a state where we do not have vp vp or where the symbols stored for positions p and p differ by claim this means that there is a position p in the output of s and a position p in the output of s where the data values or the symbols differ if such a state is reachable using claim we get that el ec el ec which implies p p which implies that p p the other implication can be also easily shown using claim complexity checking whether a particular final state of m is reachable can be done in lemma a nondeterministic algorithm first which final state is reachable and then checks its reachability in the number of states of the counter automaton m we constructed is linear in the number of states of s and s and exponential in the number of data string and data variables of s and s furthermore given two states of m one can decide in polynomial time in the number of variables whether there is a transition between the two states we thus have that the streaming transducer equivalence problem is in pspace theorem implies that checking equivalence is in pspace for programs from section and functions defined in section the reason is that the number of data and output variables of the resulting transducer is linear in the size of the program more precisely in the number of data and reference variables of the program checking prepost conditions and assertions let s be a streaming data string transducer s from to let a be a streaming data string on and let a be a streaming data string on the triple holds iff for all input data strings w over we have that if a accepts w and sw w then a accepts w the prepost condition problem for is to determine given a s and a whether holds prepost condition checking is useful in the context of verification because we can for example ask whether a transducer that takes a sorted list with respect to an ordering on as an input returns a sorted list with respect to an ordering on as an output the upper bound in the following theorem is obtained by reduction to the emptiness problem in nondeterministic finite automata theorem the prepost condition problem for is in pspace the above definition of prepost condition checking corresponds to partial correctness we can also check total correctness there is a pspace algorithm to check given s a and a is it the case that for all input strings w accepted by a sw is defined and a accepts sw the constructions discussed so far can also be used to solve a number of assertion checking problems for programs reachability given a list processing program p a location of p and a streaming data string a is there a data string w accepted by a such that starting from the initial heap that stores w there is an execution of p leading to a configuration with location for this we need to construct the corresponding to p as discussed in section and simulate it on an input together with a the complexity is pspace the same construction can be used if additional constraints are specified on boolean and tag variables of p at the end of the execution pointer analysis given a list processing program p two pointer variables x and y and a streaming data string a is there a data string w accepted by a such that starting from the initial heap that stores w there is an execution of p leading to a configuration in which both x and y point to the same recall that the compilation of programs into keeps track of such aliasing relationships and has the necessary information to answer such a query we can also check if a pointer variable r is guaranteed to be nonnull whenever it is using expressions such as and detection given a list processing program p and a streaming data string a is there a data string w accepted by a such that starting from the initial acyclic heap that stores w there is an execution of p leading to a configuration in which the heap contains a cycle formed by of again the compilation of programs into keeps track of the heap shape and can be used to solve this problem in pspace undecidable extensions data string transducers a deterministic data string transducer dst is an extension of the streaming data string transducer model where at each step the transducer can decide whether to move left or to move right or to put more precisely a transition of a dst is defined by a a tuple q q where q q and are as for and is in for we assume that the input data string is by two special symbols the machine stops when it reaches a final state if the machine never reaches a final state or if it tries to move left while the tag is or it tries to move right when the tag is then the output undefined given a dst s and a state q of s the dst reachability problem is to determine whether there exists a data string w such that s enters the state q while processing w theorem the dst reachability problem is undecidable the theorem is proven by reduction from the undecidable problem of emptiness for automata the main step of the proof is to show that a dst can recognize whether the input data string encodes a computation of a machine the proof uses the fact that the data domain is ordered programs with multiple traversing pointers the class of imperative list processing programs considered in section restricts how next pointers of heap nodes can be traversed there is one special pointer variable curr and it is the only pointer variable that can traverse the next pointer now consider the class of programs denoted by short for programs with multiple traversal pointers obtained by lifting this restriction and allowing assignments x for any two pointer variables x and y given a program p from the class and a location the reachability problem is to determine whether there exists a data string w such that starting from the initial heap that stores w there is an execution of p leading to a configuration with location theorem the reachability problem is undecidable the proof of the undecidability is again by a reduction from the reachability problem for automata the basic observation is that if multiple pointers can traverse the heap simultaneously the program can check whether two successive parts of the heap encode two successive configurations of the machine data string variable equality while a number of analysis problems for and assertion checking problems for programs are decidable checking whether the can reach a configuration where the contents of two string variables are the same is undecidable given an s a state q of s and two data string variables x and y of s the data string variable equality problem is to determine whether there exists a data string w such that s reaches a configuration where x y and the state is q the following theorem is proven using a reduction from correspondence problem theorem the data string variable equality problem is undecidable related work we are not aware of any prior decidability results for checking semantic equivalence of list processing programs even for the restricted case of bounded data domains the decidability of safety properties for programs with lists was investigated in the negative result in holds for a very restricted class of programs programs with only loops which do not modify the list data structure compared to the model of we do not allow general traversal assignments of the form x but allow only one pointer variable curr to traverse the next pointers of the heap nodes we also assume that the initial heap is acyclic but analysis algorithms can detect if cycles get introduced during program execution in previous work we have presented decidability results for a class of concurrent list accessing programs the two models are different the model in allows concurrency and nondeterminism but is not able to capture for example the list reversal the restrictions in are rather and that is what this study in search of a robust model extending the streaming transducer model to capture concurrency is an interesting research direction there is an literature on automata and logics over data strings and algorithmic analysis of programs accessing data strings while existing literature studies and languages of data strings we want to handle destructive methods that eg delete elements and thus a model of transducers is needed a number of techniques have been proposed for shape analysis see also for a survey in particular the regular model checking approach transducers to reason about programs in the following manner the set of heaps feasible at a program point is represented by either a string automaton or a tree automaton and the transformation on the heap due to a single statement is captured by a corresponding transducer model the transformation of the entire program then corresponds to iterated composition of such transducers given a regular initial set of heaps the set of heaps reachable after one transition will be regular however regular languages are not closed under unbounded union so the set of all reachable heaps need not be regular consider a program that given an input list w outputs the list ww note that data values do not play an important role in this for such a program the iterative fixpoint procedure to compute the set of all reachable configurations does not terminate in fact the set of reachable configurations is not regular and cannot be represented by a finitestate automaton however a streaming transducer that computes such a can be easily defined it is important to note that our decision procedures do not attempt to compute the set of reachable configurations or heap contents the literature on regular model checking provides several techniques for of the set of reachable heaps to ensure termination such as widening and specialized abstractions using counters analyzing programs that manipulate dynamic linked data structures is a widely studied problem commonly described as shape analysis proving assertions of such programs is undecidable and the of the literature consists of techniques for verification see eg the core problem these techniques focus on is computation of invariants that often need to quantify over the nodes in the heap let us consider function delete from section if the function was called with the parameter d a natural postcondition is that all nodes reachable from result have values different from d a quantified invariant needed to prove the postcondition could be automatically computed using for example the approach described in however we emphasize that in contrast to the methods for checking safety properties our approach is sound and complete for a welldefined class of programs and in addition to checking of assertions and prepost conditions we presented an algorithm for checking equivalence of programs conclusions we have introduced a streaming transducer model and showed that it can serve as a foundational model of list processing programs our results lead to algorithms for checking functional equivalence of two programs written possibly in different programming for commonly used routines for processing lists of data items we are not aware of any prior decidability results for checking semantic equivalence of list processing programs even for the restricted case of bounded data domains we also believe that the streaming transducer model introduced in this paper is of independent theoretical interest we have started the investigation of expressiveness and related theoretical proper of the transducer model when the data domain is bounded classical finitestate transducers need to be to implement an operation such as reverse in a subsequent paper we showed that the streaming string transducer model is equivalent to transducers and thus to string learning streaming string transducers from inputoutput examples and defining a similar streaming transducer model for data are potential directions for future research references r and p c of streaming string transducers paper in r p c and s algorithmic analysis of programs in csl pages ­ m a t l and c david logic on words with data in lics pages ­ a b m and t regular model checking in cav pages ­ a p p and t verifying programs with dynamic structures in regular model checking in tacas pages ­ a m p r p and t programs with lists are counter automata in cav pages ­ m and r on flat programs with lists in pages ­ p c a d s and r model checking of linearizability of concurrent list implementations in cav pages ­ s reasoning about heap manipulating programs using automata techniques to appear in scientific review volume on modern applications of automata theory d p ohearn and h yang a local shape analysis based on separation logic in tacas pages ­ j and h mso definable string and finitestate transducers acm trans comput log ­ w undecidability of static analysis ­ r e g and s sagiv predicate abstraction and canonical abstraction for lists in pages ­ r j berdine b cook g and m sagiv shape analysis by graph decomposition in tacas pages ­ f t and v finite state machines for strings over infinite alphabets acm trans comput logic ­ b pierce types and programming languages mit press a podelski and t counterexampleguided focus in popl pages ­ g the undecidability of aliasing acm trans program lang syst ­ s sagiv t reps and r parametric shape analysis via valued logic acm trans program lang syst ­ t regular model checking using widening techniques notes theor comput sci 