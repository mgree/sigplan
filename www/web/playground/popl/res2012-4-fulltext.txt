towards a program logic for javascript college london college london smith college london abstract javascript has become the most widely used language for web programming the dynamic nature of javascript makes understanding its code difficult leading to programs and a lack of adequate tools we believe that logical reasoning has much to offer javascript a simple description of program behaviour a clear understanding of module boundaries and the ability to verify security contracts we introduce a program logic for reasoning about a broad subset of javascript including challenging features such as prototype inheritance and with we adapt ideas from separation logic to provide tractable reasoning about javascript code reasoning about easy programs is easy reasoning about hard programs is possible we prove a strong soundness result all libraries written in our subset and proved correct with respect to their specifications will be wellbehaved even when called by arbitrary javascript code categories and subject descriptors f theory of computation logics and meanings of and verifying and reasoning about programs general terms reliability theory verification keywords javascript separation logic web introduction javascript has become the language for web programming web applications used in eg are based on a combination of javascript and programming javascript has become an international standard called used in eg features a programming language based on even web applications written in eg java f or languages such as or are either compiled to javascript or they lack browser integration or compatibility javascript is currently the assembly language of the web and this seems to change javascript was initially created for small tasks which from the flexibility of the language and tight browser integration the modern demands placed on javascript are although this flexibility and browser integration are still key advantages the inherent dynamic nature of the language makes current web code based on permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm difficult to write and use the expectation is that and future standards will improve the situation however although the main now support the of code being written is in even if there is a wide acceptance of which is certainly not clear from the current it is that libraries will have to interface properly with code we therefore believe that there is a growing need for generalpurpose expressive analysis tools for both and which provide simple correct descriptions of program behaviour and a clear understanding of module boundaries we introduce a program logic for reasoning about while it is to ignore the parts of the language and reason only about code in practice javascript programs have to interface with arbitrary web code we therefore use a model of the language that does not the most challenging javascript features for example the behaviour of prototype inheritance and the between scoping rules and the with statement is complex this means that our basic reasoning rules must also be complex we overcome this complexity by establishing natural layers of abstraction on top of our basic reasoning with code we can within these layers of abstraction and the reasoning is straightforward with arbitrary code we must break open the appropriate abstraction layers until we can the invariants of the abstraction in this way we are able to provide clean specifications of a wide variety of javascript programs our reasoning is based on separation logic separation logic has proven to be for reasoning about programs which directly manipulate the heap such as c and java programs a key characteristic of javascript is that the entire state of the language in the object heap in a structure that the variable store of many other programming languages it is therefore natural to investigate the use of separation logic to verify javascript programs in fact we had to adapt separation logic both to present an accurate account of variable store see section motivating examples and also to establish soundness for soundness it is usual to require that all the program commands are local according to a definition first given in many javascript statements are not local by this definition for example even a simple variable read is nonlocal because its result may depend on the absence of certain fields in the variable store we instead prove soundness using a concept of weak locality recently introduced by smith in this paper we reason about a substantial subset of javascript including prototype inheritance with simple functions no recursive or higherorder functions and simple eval our treatment of functions and eval is precisely enough to expose fully the complexity of the variable store building on the work of and we will extend our reasoning to higherorder functions and complex eval in future we prove soundness of our reasoning with respect to a faithful subset of the formal figure a javascript variable store operational semantics of et al our soundness result has powerful implications library code written in our subset and proved correct with respect to their specifications will be wellbehaved even when called by arbitrary javascript code our result is constructed in such a way that it will be simple to extend to reasoning about higherorder functions and complex eval in due course motivating examples as argued in there are many reasons why the behaviour of javascript programs is complex for a start javascript is a dynamically typed language which does not have a standard notion of variable store instead javascript variables are best regarded as being stored in the heap in a structure which the variable store this structure consists of an abstract list of scope objects called the scope chain analogous to stack frames in other languages every scope object has a pointer to a linked list of providing inheritance since scope objects inherit data from their the value of a variable cannot be resolved by a simple list traversal variable resolution is further complicated by the fact that javascript objects may share a common prototype behaviour can make simple programs consider the code c defined below x null y null z null f v v var v y v v z v what values should the variables x y and z store at the end of the program the correct answer is undefined and respectively we explain how this occurs as we through our reasoning in section we prove the following triple of this code y z f v l ls c undefined y z f l v we distinguish a global logical expression l with value ls denoting the scope chain the store predicate y z f v states that the structure referred to by ls contains none of the program variables mentioned the variables occur to the left of the bar the store predicate undefined y z f l v denotes the final values for all the variables the variables occur to the right of the bar with assigned values to understand the complexity of the heap structures described by store predicates consider the example heap given in figure this diagram illustrates a typical shape of a javascript variable store each object is denoted by a box in this example the current list of scope objects is given by l l l l l lg where the li are object addresses and lg is a distinguished object con the global variables which must occur at the end of the current list of scope objects each scope object has a pointer to a list of with the arrows representing prototype relationships these prototype lists can be shared but cannot form cycles in prototype lists must either end with the distinguished object or be empty however many implementations v and allow the programmer to directly access and change the prototype pointers allowing incomplete prototype chains ending in null but not allowing the creation of cycles we work with incomplete prototype chains since we want library code to work well with such implementations to look up the value of a variable x in our example heap we check each object for a field with name x starting with l checking the prototype list from l then moving along the list of scope objects in our example the x in object l will be found first since the whole prototype chain of l will be visited before l when reading the value stored in x this is all we need to know if we write to the same variable x the effect will be to create a new field x at l this new field will the x field in object l in the usual way all of this detail is abstracted away by the store predicate the formation of this predicate is subtle and requires some adaptation of separation logic as well as the separating conjunction for reasoning about disjoint heaps we introduce the connective for reasoning about partially separated heaps it is used for example to account for the sharing of prototype lists illustrated in figure we also use the assertion l x which states that the field x is not present at object address l this predicate is of the out predicate in stating that values are not present in a concurrent list it is necessary to identify the first x in the structure in our example the x at l is the first x since it does not occur in the prototype list of l nor in the prototype list of l until l our store predicate allows us to make simple about variable assignments without our store abstraction y z f v l ls x null null where the assertion true potentially prototype lists the evaluation of the function expression has the effect of creating a new function object and returning the address l of that object the object contains a number of internal fields including body which contains the body of the function and scope which stores the function closure ls our inference for the function definition is approximately vx null y null z null l ls f l null y null z null f l ll body ls true w l scope ls as well as the store predicate we assert that the state also contains object cells such as l scope ls this assertion means that there is an object with address l in the heap and it definitely contains at least the field scope which has value ls the assertion says nothing about any other field of l we assert that our function object has fields body and scope the full specification given in section is actually a little more complicated than this for now we hide additional fields in the assertion true we know that this program example is challenging because the final values of the variables are all the complexity of the example occurs within the function call when javascript calls a function it performs two passes on the body in the first pass it creates a new scope object and local variables to undefined in the second pass it runs the code in the newly constructed local scope our reasoning reflects this complexity the hoare triple for the function call has the following shape null y null z null f l v l l body ls true w l scope ls to find a suitable postcondition we must reason about the function body the precondition of the triple given below is constructed from the first pass of the function call as well as containing the precondition of the function call it contains a new scope object l with fields given by the parameter of the function and the local variables discovered by the first pass for our example it contains the assertions l w null for the parameter declaration and l v undefined for the local variable declaration the object l also has a proto field which points to null since scope objects do not inherit any behaviour and a this field which can only be read we also have the predicate proto this w v which asserts the absence from l of all the fields we have not mentioned as parameters knowing this absence of fields is essential if in the function body we wish to write to variables such as the x and y which do not appear in the local scope object finally the new scope object l is to the scope list l using this precondition we are now able to give the triple obtained by the second pass of the function call l l l ls null y null z null f l v l body w l scope ls proto this w v l w null l v undefined l proto null l this l true l l xl v ls v var v y v undefined y z null f l v l body w l scope ls proto this w v l w null l v l proto null l this l true the postcondition follows simply from the three assignments in the function body first variable x gets the value undefined since this is the current value of the local v then the local v is assigned and finally the global variable y is assigned the value of the local variable v the var v statement has no effect in the second pass of the function call the postcondition of the function call is the postcondition of the function body with local scope object l off the current scope list l l undefined y z null f l v l body w l scope ls proto this w v l l w this null l ls l true proto null reasoning about the final assignment is straightforward with z assigned the value of the global variable v the final postcondition is obtained using the consequence rule to hide the function object and local scope object behind the assertion true since they are to requirements and existentially function object l ll ls true undefined y z f l v part of the challenge of understanding this example is knowing the scope of local variable v in javascript variables can only be declared local to functions not other blocks such as if and while this can lead to behaviour especially when a local variable the name of a global variable one technique for solving this problem is to use the with statement and a literal object to declare local variable blocks precisely where they are needed using with is often considered bad practice and it is in however it is widely used in practice and can certainly be used to improve the program readability we are able to reason about even extremely uses of with consider the program c a b with b a b with an operational understanding of variable store it is not so difficult to understand that this program returns the value even though the value of ab at the end of the program is it may not be quite so clear that this program can fault it may also execute arbitrary code from elsewhere in the variable store leading to a possible security violation we only understood this example properly by doing the verification in section we prove the triple f f proto null r c true a similar proof is possible for a precondition where a and f are in the store with arbitrary values either precondition ensures the program returns the value as expected the obvious first try was to have eg just f as the precondition this does not work as when reasoning about the assignment to the variable f we cannot assert that the variable f is not in the local scope as discussed earlier we work with incomplete prototype chains in the variable store with some web code it is possible for programmers to directly access and change the prototype pointers resulting in the distinguished object not being a part of the variable store this means that may contain the field f without our proposed precondition the statement a b then results in the creation of a new object l with no field f as expected but with field proto pointing to which may contain f l l b l f l proto the with statement makes this new object l the most local cell in our variable store but because f is an inherited property of l the meaning of the assignment to f has now changed ­ it has become an overriding assignment of a local variable we write the new function f into the most local object l when the program returns from the with statement the function call to will fault since there is no f in scope to call in many web including and this behaviour can be induced by running the program window proto null c in the default starting state the proto notation allows the programmer to directly access and change the internal proto in web usually contains a pointer to the object and window usually contains a pointer to the object lg fields resulting in a program state which causes the program c to fault nonstandard features such as this are widely used in practice and so it is important that our reasoning be robust to the states they produce in this example it is possible to induce a similarly starting state without the use of any nonstandard features which results in the call to f executing arbitrary code not mentioned in our program consider running the program c c where c is code this could result in a security if f is passed sensitive data operational semantics we define a bigstep operational semantics for a large subset of javascript that represents the inheritance and scoping mechanisms described in the standard our semantics follows closely the full smallstep javascript semantics of mitchell and except that we make some simplifications as discussed in section we work with a bigstep semantics because it better to our reasoning heaps the javascript heap is a partial function h r v that maps references r r l × x which are pairs of memory locations and field names to values this structure the important role that references play in the semantics of the language values v v can be basic values v locations l and lambda abstractions xe the set of locations l is lifted to a set containing the special location null analogous to a in c which cannot be in the domain of any heap we denote the empty heap by emp a heap cell by l x v the union of two disjoint heaps by h h and a read operation by hl x an object is represented by a set of heap cells addressed by the same location but with different field names for ease of notation we use l x v xn vn as a shorthand for the object l x v l xn vn as discussed javascript has no variable store instead variables are resolved with respect to a scope object implicitly known at run time scope objects are just objects whose locations are recorded in the scope chain we use a standard notation el l l for lists each scope object has a pointer to a prototype list which need not point to a variable x is resolved as the property named x of the first object in the scope chain whose prototype list defines x scoping constructs such as function calls and with cause subexpressions to be evaluated with respect to a local scope object by putting the local scope object at the beginning of the scope chain and then removing it after the subexpressions have been evaluated all user programs are evaluated starting from the default scope chain lg where lg is the location of the global javascript object described below the final object in any scope chain is always lg but in a scope chain are allowed for example the javascript program is valid and usually results in the subprogram c being evaluated in a state in which lg is both the most global and the most local object the auxiliary scope function defined below returns the location of the first object in the scope chain to define a given variable it depends on the prototype function which returns the location of the first object in the prototype chain to define the variable scope and prototype resolution h l x and h l x h x null h l x null h ll x l h l x null h ll x h l x h null x null l x domh h l x l l x domh hl proto l h l x h l x the set of variable names x is partitioned in two disjoint sets the internal variable i and the user variable names x u the internal names x i scope body proto this are not directly accessible by userdefined code but are used by the semantics as noted in section some implementations do give programmers direct access to some of these internal variables but we do not model those programs we do model all the program states that such programs might create and take care not to make strong assumptions about the types or values of those internal variables in this way libraries verified using our techniques are robust in the presence of unverified realworld code user names are denoted by x y z x u and are considered a subset of strings keywords such as var are not valid variable names it is worth at this point a of the javascript semantics the evaluation of a user variable x does not return its value but rather the reference l where such value can be found l is obtained using the predicate in general the values r v r returned by javascript expressions can be normal values v or references r when a user variable x needs to be in an expression the semantics implicitly calls the dereferencing function defined below which returns the value denoted by the reference dereferencing values h r r h r r h l x null l null h undefined h l x l l null h hl x we introduce the definition of a wellformed javascript heap a javascript expression can only be evaluated in a of a wellformed heap with respect to a valid scope chain all javascript expressions maintain the wellformedness of heaps a heap h is wellformed denoted by h if its objects and prototype chains are wellformed prototype chains must be acyclic they can end with null rather than and if it contains the global scope object lg and the distinguished objects and lfp which we will see later serve as the default for new objects and functions a scope chain l is valid with respect to heap h denoted by l if all the locations in the chain correspond to objects allocated in h and if it ends with the global object lg formal definitions are given in the default initial state h is the smallest wellformed heap that also contains the special function object le the eval function and its prototype h null where l denotes an object at location l which is empty except for the prototype l l l proto l we conclude this section by defining the heap update operation which will be used by the semantics many javascript expressions update a heap cell if it is present or create it if it is not present we reflect this form of update in our heap update operation update hl x v l x domh l null hl x v h l x v h l x vl x v h l x v x v x v the last rule says that an update to a reference whose location is null has the effect of allocating and ing a new global variable which behaviour of implicitly creating global variables when a variable name is first used values and expressions to aid our presentation we introduce the syntax of all javascript programs statements and expressions simply as expressions our operational semantics will only describe the behaviour of wellformed programs as defined by syntax of terms values v and expressions e v n m undefined null e e e x v var x this delete e e e ex ee e e function xe function new ee x e xn en ee where a basic value v can be a number n a string m including the user variable names the special constant undefined or the null location the operator denotes a standard number and boolean operator or string concatenation expressions e include sequential composition variable lookup literal values conditional expressions loops local variable declaration this deletion arithmetic and string concatenation object property lookup function call and eval assignment function declaration recursive functions constructors literal objects computed access and the with statement evaluation rules an expression e is evaluated in a heap h with respect to a scope chain l if it successfully terminates it returns a modified heap h and a final value r selected evaluation rules are given below and then discussed see for the full definition recall that the set of variables is a subset of the set of strings that a heap value v can be a basic value v a memory location l or a function closure xe and that a return value r can also be a reference operational semantics h l e h r notation h l e h v rh l e h r h r v definition h l e h v h l var e h undefined value h l v h v member access h l e h l l null h l ex h computed access h l e h l l null h l e h x h l ee h variable h l x l h l x h object h h i n hi l ei hi vi hi xi vi h l xe hn l binary operators h l e h v h l e h v v v v h l e e h v assignment h l e h h l e h v h hl x v h l ee h v this h l this l h l this l hl this l h l this h l function h h l x e l h l function xe h l function call h l e h r r l h r l l le hl body xe hl scope l h l e h v h h x v e l h ll e h v h l ee h v eval h l e h le h l e h m e h l e h v h l ee h v with h l e h l h ll e h r h l h r obj defined earlier fun this act defined below we briefly discuss some of the evaluation rules that show nonstandard features typical of javascript rule definition for var e simply executes e and away the return value the var declaration is only used by defs defined below to identify function local variables rule variable uses to determine the scope object where a given variable can be found without dereferencing the variable rules access return a reference to the object field denoted by the corresponding expressions rule object uses the obj notation introduced in section to introduce a fresh empty object at location l and then its fields accordingly freshness is by wellformedness of h and disjointness of rule binary operators assumes the existence of a semantic version for each syntactic operator each is a partial function defined only on arguments of a basic type in this case numbers or strings and returning results of some other possibly the same basic type corresponding to the intended meaning of the operation rule assignment is quite subtle suppose we have the expression x now consider figure of section if x were defined as a field of the object l then x would be an assignment the value of the field x in the object l would be with the value if x were not found anywhere then it would be created as a global variable ­ a field of the object lg finally consider the actual case in this figure x is found to be a field of object l which is a prototype of l which is in the scope chain in this case x is an overriding assignment with the effect of creating a new field x in the object l to the existing x in l this complexity is handled in two places the variable rule uses the function defined in section to return a reference note that the function does not return a reference to precisely because we wish to model this behaviour secondly the heap update operation h the of either an existing field or in this case creating a new field rule this the this identifier as we will see when executing a method of an object we use the internal variable this to store the location of that object when executing a function call this points to the global object lg the this rule uses and to the value of this which is then returned by the this statement rule function introduces the notation l x e l l proto lfp prototype l scope l body xe to allocate a fresh function object at location l the internal prototype of the new function object points to the standard function prototype object lfp the rule also creates a new empty object at l and stores a pointer to it in the prototype field of the new function if the function is ever used as a constructor using the new keyword then the object pointed to by this prototype field will serve as the prototype of the newly constructed object note that the field is mutable and so may be used by a programmer to a inheritance structure recall from section that javascript function calls can be surprisingly complex we now describe rule function call which uses two auxiliary functions this and act recall also that the rule this uses internal this fields to determine the semantics of the this keyword the values of the this fields are determined by the function call rule using the auxiliary function this r l l this domh lg otherwise to understand this first notice that every newly created local scope object has a this field while no other objects ever will the function call rule finds a pointer to a function in the location if l is a regular object which has no this field then the function must be a method of that object and so the this field of our new local scope object should point to l on the other hand if l is a special local scope object which has a this field then the function must be a regular function and not a method and so the this of our new local scope object should point to lg this unique behaviour precisely captures the behaviour of the this keyword the auxiliary function act describes the allocation of a new local scope object x v e l l x v this l proto null l e the object is allocated at address l and contains a function parameter x with value v the internal fields this proto and the local variables declared in an expression e the auxiliary function defs defined in searches the function body e for instances of the var keyword and sets all the appropriate fields of our new local scope object to the value undefined as discussed in section rule eval looks like an ordinary function call but the function being called is not an ordinary function object it is the special builtin object le it assumes a partial function parse that a string m into a javascript expression e only if there are no syntax errors the control expressions are mostly standard see except for the with rule that evaluates e in a starting with the object obtained by evaluating e safety an important property of the evaluation relation is that it preserves wellformedness of the heap for any valid scope chain theorem wellformedness let h l be such that h l if h l e h r then h and although the theorem is about wellformedness its proof reported in shows that starting from a wellformed state and scope chain all the intermediate states and scope chains visited during the computation are also wellformed and all the locations occurring in intermediate return values correspond to objects effectively allocated on the heap javascript subset we work with a subset of javascript in order to limit the size and complexity of our semantics for this paper our subset is substantial and despite some minor and simplifying assumptions discussed below faithful to the standard a significant property of our semantics is that our programs will run in states generated by any valid javascript program including those reached by programs using nonstandard features that we do not model such as proto or and our reasoning of section will therefore interface well with realworld javascript programs we do not model implicit functions adding them is straightforward but would add significantly to the length of our lg has this in some not all implementations is on the issue presentation we have no boolean type instead where control structures if and while require a boolean we use other types whose behaviour is equivalent to the type conversion that occurs in javascript values such as and null behave like false and values such as and string behave like true for simplicity we use an implicit return statement for functions moreover our functions take only one parameter rather than the arbitrary list of parameters usual in javascript and do not have the arguments object or the constructor property as mentioned in section we simplify our presentation of javascript programs statements and expressions into a single class of expressions we also omit several javascript constructs such as labels switch and for as they do not contribute significantly to the problem of program reasoning in this presentation we only consider the core language and do not model the many standard libraries which make available to programmers instead of exceptions we have a single error condition denoted fault our reasoning conservatively avoids this means that programs which are proved using our local hoare reasoning will run without exceptions in javascript interpreters assertion language our assertion language follows that of parkinson and in their work on reasoning about java they use assertions of the form l x v to denote that a partial heap contains the object l with field x which has value v using the separating conjunction the assertion l x v l y w declares that a heap contains an object l which must have two separate fields x y with the appropriate values the assertion l x v l x w is unsatisfiable since it declares two fields x for l this style of reasoning is not enough for javascript we must also assert negative information about fields not being in the heap and extend the structural assertions of separation logic to account for partial separation due to shared prototype chains recall the example of a javascript variable store in figure to find the value of x in the store we must not only determine that the object l has a field x but also determine that no fields named x occur earlier in the store we use assertions l x to declare that a heap contains an object l which does not have a field x the assertion l x l y w declares that the heap contains an object l which does not have field x but does have field y the assertions l x v l x and l x l x are unsatisfiable thus the assertion l x states the full knowledge that field x is not in object l now consider what happens when we want to describe the state of more than one variable at a time in section we introduce a predicate which allows us to assert for example the variable x is found in the store in object l l x l or the variable y is not in the store l y null both of these assertions must make use of the proto fields in order to the variable store so we cannot separate them using but the first assertion does not mention any y field and the second assertion does not mention any x field so we cannot join them with in order to make both assertions about the same variable store we need a way for them to share their common parts to do this we introduce the connective p q which allows partial separation between heaps we can use to describe the state of more than one variable in a given store l x l l y null and we shall see in section that it is also when defining the predicate an assertion may be satisfied by a triple h l consisting of an abstract heap h a scope chain l and a logical environment an abstract javascript heap is a partial function h r v that maps references r r l × x to values v v or abstract heaps thus declare information about fields not being present in an object as well as the fields that are present we also define an evaluation function which takes an abstract heap to a concrete heap h l x hl x iff l x domh hl x we use this function in section to define the relationship between our reasoning using hoare triples and our operational semantics we define a logical environment which is a partial function from logical variables x x l to logical values v l which may be a return value r any expression e or a list ls of logical values we also define logical expressions e which are different from program expressions in that they can not read or alter the heap expressions e are evaluated in a logical environment with respect to a current scope chain l logical expressions and evaluation e l v v l e v ls xl vl e x l v e e e e e e e logical variables scope list logical values binary operators list cons reference construction lambda values vl v ll l x l x ee l e if e l ls e l if e l l e l x e e l v v if e l v e l v ee l x e l if e l x assertions include the boolean assertions structural assertions of separation logic and our new connective basic assertions for describing cells in a javascript heap expression equality set and list assertions and quantification over logical variables assertions p p p p p ¬p true false p p p p p p e e e e e e set e e x p x p boolean assertions structural assertions javascript heap assertions expression equality set membership list element quantification notation e e e for e e e e for the logical operators bind in order ¬ the structural assertions and are standard separation logic assertions the separating conjunction p q says that the heap may be split into two disjoint heaps one satisfying p and the other q the right adjoint p q says that whenever the heap is extended by a heap satisfying p then the resulting heap satisfies q it is useful in proving the soundness of some of our layers of abstraction in section as given in the connective p q is novel it says that the heap may be split into two heaps one satisfying p and the other q but these two heaps need not be disjoint they may share zero or more common cells we shall see in section that this is particularly useful when reasoning about the variable store it is possible to define analogously with but since this is not useful for javascript reasoning we omit it here note that p q p q and p q p q but neither of the reverse implications hold the assertion e e e declares information about a cell including the information that field e does not occur in object e assertion says that the heap is empty the notation set denotes a literal set or a named set such as x the set of javascript field names note that since there are sets for numbers strings and locations we can use set inclusion to assert the type of a particular javascript value the satisfaction relation h l p is defined below the cases for the boolean assertions are not given as they are standard satisfaction of assertions h l p h l p q h h h h h h l p h l q h l p q h h l p h h h h l q h l p q h h h h h h h h h l p h h l q h l e e e h e l e l e l h l h emp h l e e e l e l h l e set e l set h l e e e l is in the list e l h l x p v h l x v p h l x p v h l x v p we have given a direct definition of the connective when logical variables range over heaps it can be derived p q r r p r q r it remains to be seen what natural logical properties are satisfied by this connective program reasoning in the spirit of separation logic we give small axioms and inference rules which precisely capture the behaviour of all javascript expressions except for the usual approximation for while and conservative approximations of function call and eval reasoning about function call and eval is interesting and complex and will be the focus of future work as outlined in section because our reasoning captures the full complexity of javascript semantics particularly with respect to the variable store and the with command it is possible to prove properties about extremely subtle programs unfortunately proving any program at this level of abstraction involves a level of detail which most programmers would rather avoid we therefore provide several layers of abstraction which make it possible to reason at a natural high level about wellbehaved javascript programs we discuss these abstractions in section our hoare triples take the form p eq which means if e is executed in a state satisfying p then it will not fault and if it terminates it will do so in a state satisfying q the postcondition q may refer to the special variable r which is equal to the return value of e auxiliary predicates for our reasoning rules we require predicates that correspond to functions such as and used by the operational semantics in section these predicates present us with two distinct challenges sharing and precision to consider sharing recall the scope function from section when searching for a variable y in the example store given in figure since y is not present in the store will check the entire structure before returning null to indicate that y cannot be found what is of interest to us is the order in which the cells in the store will be checked notice that the cell l will be checked twice and the cell will be checked three times this is because the cells l and are shared between the prototype chain of the object l and the object l in addition is shared by these prototype chains and the prototype chain of lg as we shall see below we can describe these partially shared structures using our connective to consider precision recall the function when this time searching for a variable x either in the store of figure or in the identical store but for the of a single object such that the prototype of l would be l in each of these stores the function will return the same value ­ the location l in our program reasoning our predicate which will correspond to the function of the operational semantics must be more precise as we need to distinguish between these two possible cases with the challenges of sharing and precision in mind we first give then explain the logical predicates and logical predicates null ls l ls x l l ls l x l l null ls ls l ls x l ls l x null ls ls x l null null l l x l v l x v v l ls l x l n l x l proto n ls n x l val val val r ls undefined ls l x null l null ls l val l ls l x l l x val val these predicates closely follow the structure of the functions defined in using to the challenge of sharing prototype chains mentioned earlier the predicate l x l holds only for abstract heaps h such that the function from section gives us h l x l meaning that the value of the variable x in the variable store given by the list l can be found in the object or a prototype of the object at address l however recall the challenge of precision mentioned earlier in order to distinguish between all the possible heaps which satisfy the predicate l x l we work with an additional first argument the predicate ls l x l is precise in the sense that for any abstract heap h it holds for at most one of h the first argument ls is a list of lists which specifies the exact cells which must be visited and the order in which they must be checked in order to determine which object in the variable store defines the variable x for example recall the heap illustrated in figure if the prototype of the cell l has address l then the predicate l l l l l x l is satisfied by the abstract heap consisting of the x and proto fields of the four objects in the lower left corner of that diagram notice that we do not need to visit every object in the variable store in order to discover the location of the variable x in the spirit of the small axioms of separation logic our predicate holds for the smallest possible heap in which we can be sure of discovering the variable we are interested in the predicates and are similar in that they their operational counterparts with the addition of one extra argument to make them precise in the case of and the first argument ls is simply a list of addresses rather than a list of lists of addresses because each predicate only down at most one prototype chain the inference rules also require logical predicates corresponding to a number of other auxiliary functions given in section below we define and fun predicates which assert the existence of a fresh object and function object and that returns the local variables of an expression in order to reason about function call we also use a defs predicate which we define in auxiliary predicates l lg l this v l this where l v v lg e null undefined e null undefined v vn v x l v env x body proto f scope env f body x body f prototype proto f proto lfp l e x xn where l xi l e inference rules we define below some inference rules p eq for reasoning about javascript expressions the full list can be found in inference rules p eq definition p eq r p var eq r undefined value vr v variable p ls l x l ls v p xp r variable null p ls l x null p xp r v q r ls v l l null p r req x x u r r v s ls q v l l null s ls v x p r object i n pi ri yi xi r yi proto x xn q pn l l l x x proto rl xn l xn x · · · xn r v v r s ls v v q s ls v v v v v p e eq r v assign global p er r req lg x r v q s ls v v p e eq lg x v r v assign local p er r req l x v r v q s ls v v p e eq l x v r v function l l proto l proto q l x proto e l scope body function while p es r v s r ls v v s q ep s r undefined r p with p s l l l l ll r v l l s r ls v l l q r p l l l function call p er r f r s t ls f f f body x e f scope ls l ls r v r s ls v v r l l l x v r l this t l proto null l e this x l r l e p q l ls frame p eq p req r consequence p p q q p eq elimination p eq x p ex q disjunction p q although most of the rules correspond closely to their operational counterparts some rules further comment rule definition shows the use of the variable r to record the result of an expression rule variable shows the use of to express the overlapping of predicates and rule assign global shows the use of to assert that certain known memory cells are available for allocation rule function call describes dynamic functions but does not support higher order reasoning rule frame does not have the usual side condition because javascript stores all its program variables on the heap so any variable modified by an expression is necessarily contained entirely within the footprint of the expression rules consequence elimination and disjunction are standard soundness we show that our inference rules are sound with respect to the operational semantics of section when proving the soundness of any system involving the frame rule it is usual to first show the locality of the programming language and use that property to show the soundness of the frame rule unfortunately many javascript statements are not local according to this standard definition we therefore use the recently introduced notion of weak locality from thesis definition soundness of a hoare triple a hoare triple p eq is sound if for all abstract heaps h scope chains l and environments it satisfies the following two properties fault h l r p h l e fault safety h r h l r p h l e h r h h h h l r r q theorem soundness all derivable hoare triples p eq are sound according to definition the proof reported in involves showing that the predicates used by the hoare rules correspond to the auxiliary functions used by the semantics showing that all javascript expressions are weakly local with respect to their preconditions and finally showing that all our inference rules are sound layers of abstraction as mentioned in section using the rules given so far reasoning about javascript program involves detail that most programmers need never consider most of the time programmers will work at a higher level of abstraction for example treating the variable store as if it were a regular variable store this is a good practice as long as the abstraction holds however if the program happens to come across a corner case that breaks the abstraction its resulting behaviour can appear almost this may be a particular problem when writing library code since the programmer has no control over the programming discipline of the client who uses the library in this section we introduce several explicit abstraction many alternatives are possible but those presented here are enough to demonstrate the concept and reason about some interesting programs we are able to use these to reason at a highlevel way about many wellbehaved programs we know exactly what the boundaries of these layers of abstraction are so we can ensure that our programs remain safely within the abstraction if we wish we can even choose to break an abstraction execute some particularly subtle lowlevel code the abstraction and then continue to work at the high level layer exploring the scope list central to reasoning about javascript variables are the and predicates the first abstraction layer consists of alternative versions of these predicates which make reasoning about certain common cases simpler the predicate from the end the most global end of the scope rather than from the beginning the local end which makes modifying a variable easier to specify it makes use of which says that a variable does not exist in a particular partial scope the lg predicate does the same but lg from its specification in order to make reasoning about global variable instantiation simpler we give several useful triples about variable assignment in we prove these triples by using and showing the equivalence of and layer predicates ls ls var null ls ls var null ls ls ls var l var l l ls l var l l null l ls l ls ls l ls var end ls l var null ls ls var end lg l ls l lg ls ls l ls var end lg ls l var null lg ls ls var end lg null null lg lg null lg l l var l v l var v v l lg lg l l ls l proto var l n l var n lg ls n var l l lg these predicates give us much more flexibility to reason about javascript variables found in various places in the variable store even at this quite low level it is possible to prove general specifications about programs with many corner cases a good example of this sort of reasoning is simple assignment statements we prove the following general triples about simple assignments the first three triples deal with the assignment of a constant to a variable in the cases of variable variable and variable respectively the fourth triple deals with assigning the value of one variable to another all four are proved sound in simple assignments p l l l x null l l ls g lg l l x lg q l g lg x null proto lg l gl l s xv v p x p l ll l x l l x ll v q l l l x l l pr x l l x v l x v rl pr p x p q l l l x l l l x l l x l x v v p x p ls l y ly ls ly l l l x l l x v v q ls l y ly l l x l l x r p x compared to the assign global and assign local inference rules these triples provide an explicit account of the footprint of the assignment and more clearly describe the destructive effects of assignment yet they are still quite complex and are difficult to compose it would be useful to ignore some information about the exact structure of the variable store while the information about the mappings of variable names to values to do this we introduce a new store predicate layer a simple abstract variable store the predicates below provide a convenient abstraction for an variable store the store predicate xn x v xm vm ls ls ls in l xi null lg xi jm l xj lj km lk vk ls l this the assertion bx y describes a heap a variable store given by scope chain ls in which the variables a and b are not present and the variables x and y take the values and respectively the body of the predicate uses the predicate to assert the absence of a and b and the and predicates to assert the presence and values of x and y this information about the exact structure of the store and the locations of x and y is hidden from the programmer since at this level of abstraction it should be of no concern the part of the body of the predicate ensures that the store predicate always enough resource to call any function that is stored in the variable store the variables a and b can be as can the variables x and y to facilitate program reasoning at this level of abstraction we provide several inference rules all of which are derived using previous levels of abstraction in we start by giving rules for and overriding a variable with a constant and with another variable writing to a store let q xv let q xv x x · · · xn x · · · xm p x p x v v x x · · · xn x · · · xm p p x xm vm x y x · · · xn x · · · xm p x p x xv xm vm x y x · · · xn x · · · xm p p x true r v x v xm vm notice that each of these rules has a postcondition which includes true this is because or overriding a variable may a portion of the variable store for example consider the overriding assignment x in the store given in figure in this case the cell l x has become to requirements in separation logic it is not sound to simply about these cells so we hide them in the general assertion true one limitation of this level of abstraction is that the abstraction only covers a static and unknown scope chain if we call a function which adds a new cell to the scope chain then the rules above are to reason about our program the following rules allow us to reason at this level of abstraction about a program which a global variable from within a new local scope frame writing to a store from a deeper scope let q s l proto x null v l x x v l y v xm and ls x y x · · · xn x · · · xm p x x v xm vm p s true x y x · · · xn x · · · xm p x v x v xm vm p s true finally we provide two rules for a more general case of store interaction in these cases the value which is to be written to the variable is the result of computing some arbitrary expression these specifications are therefore necessarily more complicated since they must incorporate some features of sequential composition we that whatever the expression does it must not alter the variable store in a way that changes the visible values of the variables destructive store x x · · · xn x · · · xm r r p er x ls v v q xr m vm v r s ls x v v v r p x es x x · · · xn x · · · xm r x x ls v v r l x l s l x x l xv ls v v q v r p x es it may seem surprising that we only provide derived rules for destructive variable and not for destructive variable update this is because such an update rule would be unsound the destructive expression might have the side effect of overriding the variable we wish to update this serves to further demonstrate the need for the lowlevel reasoning introduced earlier in this paper we can use highlevel abstractions such as the store predicate where they are sound but if we wish to reason about programs with expressions we will sometimes be forced to reason at a lower level the scope of a variable the store abstraction gives us the tools we need to easily reason about programs with large numbers of variables for example consider the program from section y z f v x null vx null y null z null true f v var v l null y null z null f l l body w l scope l true v null y null z null f l v l body w l scope l true l undefined y z null f l v proto this w v l proto null l w null l v true frame undefined y z null f l v z v undefined y z f l v true frame undefined y z f l v proto this w v l proto null l w null l v true l undefined y z f l v true l ls l l ls null y null z null f l v l body w l scope ls proto this w v l proto null l w null l v undefined l this true l ls l ls undefined y z null f l v proto this w v l proto null l w null l v true figure reasoning about variable x null y null z null f v z v with the store predicate and the results given above reasoning about this program is simple a proof of the main program is shown in figure it relies on a simple proof of the function body here and given in full in reasoning about with this level of abstraction also leads itself to reasoning about the with statement consider the with example from section where f implicitly returns b a b with a b this program demonstrates the importance of modelling with cor recall that when correctly modelled the closure of the func tion f will refer to the object b which was pointed to by the variable a at the time that f was defined however even though the variable a is changed to point to a different object before is called the closure continues to point to the object b thus the program normally returns the value not recall also that we must be careful with the f field of the object we can reason about this program using the store predicate the proof is in figure this proof relies on a for the invocation judgement of p with the let p l b l proto true f f proto null a b l l f proto null l f p with a ls l l l ls l f proto null l f p ls l f f f proto null l f f body cb f scope l ls p ls l f l ls l f f f proto null l f f body cb f scope l ls p a b ls l f l l ls l f f f proto null l f l b l f l proto f body cb f scope l ls p ls l f l loc l ls l f f f proto null l f l b l f l proto r f body cb loc f scope l ls proto null p r figure reasoning about with ls l f l loc l loc l ls l f f f proto null true l b l f l proto l b l f l proto f body cb f scope l ls loc b loc proto null for space reasons we only give the reasoning for the case in which neither a nor f are in the variable store the same techniques in with the disjunction rule can be used to prove the general precondition in both the simple and the general case we must constrain our precondition with the assertion f proto null the requirement for this term may seem surprising consider running the above program in a state satisfying f f in this case when the assignment to f is made the function pointer will be written to the cell l f rather than into the global variable store since the variable store does not contain a function value for the variable f the call to will cause the program to fault the problem is potentially even worse if f contains a function pointer in this case the call to will not fault but rather will execute whatever code it finds this kind of could lead to very bugs in the case of a system like which attempts to code from code it could even lead to a security layer a recursive abstract variable store while reasoning using the store predicate it is possible to handle large numbers of assignments and small numbers of function calls however for large numbers of function calls another abstraction is helpful consider an abstract variable store as a list of lists of pairs with the most local scope frame at the head of the outer list the list x y x z represents a store in which the global scope contains the variables x and z an intermediate scope adds the variable y and the most local scope the variable x the list elements of pairs can be represented in our logical expression language as lists containing two elements for readability we use the notation x v above we define the recursive store predicate store which describes an abstract variable store store which does not contain the variables in the list the recursive predicate · · · xm x v · · · xn vn · · · xm x v · · · xn vn x · · · xm x · · · xm x ls v · · · xn vn ls l proto null l lg im l xi jn l xj vj · · · xn ls x v · · · xn vn ls ls xi ls l xi · · · xn ls ls notice that uses the store predicate to constrain the most global scope frame in the abstract scope list while being rather more restrictive about more local scope frames local scope frames must be by javascript objects which contain fields for each variable defined at that scope level furthermore they must assert the absence of fields which are not in the store the or which would otherwise a variable declared in a more global position in the store this is handled by the predicate notice that local scope frames have a null prototype and may not be the lg object these criteria are met by the scope frames created by a normal function call and are not normally met by with calls this makes this abstraction ideal for reasoning about programs with many function calls and no internal uses of the with statement notice however that we do not with calls in the enclosing scope represented here by a toplevel use of the store predicate this means that this abstraction will facilitate reasoning about libraries which are written in a way and which may be called by clients we provide several rules for reasoning at this level of abstraction in the most interesting of which are destructive variable and update destructive update r r p er q er m r s var r p x es q true r r r q r ls ls x ls s var curr r p x es q r var notice that we may not safely update variables in the global portion of the abstract variable store with the results of potentially destructive expressions this is for the same reason as the corresponding restriction on the store predicate in section there is a corner case which would lead to very behaviour at this level of abstraction however we have an advantage we can be sure that the local abstract scope frames were constructed in a more way and so we are able to reason about updating them with destructive expressions using the second rule above data l undefined i undefined l n l l l n l data l l i n l n l l n l l figure the specification of form validation consider a web form with a number of text fields and a if the is when the page loads then an event handler on the form can be used to check if valid data has been entered in all the fields before enabling the let us assume that the programmer has separated the concerns of parsing the web page and of the data the data validation function will be called with a single parameter an object with one field for each text value to check a count of those text values and boolean corresponding to whether the should be an example function which might perform the validation check is var var i i i notice that this code deals with variables in a way it makes use of no global variables instead to use function parameters and local variables the repeated work of the loop body is into a function which could be expanded to provide extra functionality or used elsewhere with little cost in readability using the abstraction it is straightforward to show that the function body satisfies the specification given in figure related work we believe this paper is the first to propose a program logic for reasoning about javascript our program logic ideas from separation logic and proves soundness with respect to a bigstep operational semantics in this section we discuss related work on separation logic and the semantics of javascript we build on the work of ohearn reynolds and yang who introduced separation logic for reasoning about and on the work of parkinson and who adapted separation logic to reason about java we made several to their work in order to reason about javascript as in we use assertions of the form l x to denote that a field x in object l has value we extend these assertions by l x which denotes that the field is not in l this is inspired by et als use of the out predicate to state that values are not present in a concurrent set we introduce the connective to account for data structures we have not seen this connective before which is surprising since shared data structures are common for example in linux there has been much work on various forms of concurrent separation logic with sharing but they all seem to take a different approach to our connective we prove the soundness of our frame rule using a new technique developed in phd thesis there are several approaches to proving soundness of the frame rule and we list the key developments here the first and most commonly used approach by ohearn reynolds and yang involves first proving that the commands of the programming language under consideration are local and then using that property to prove the frame rule later birkedal and yang a method in the soundness of the frame rule into their definition of hoare triples this made it possible to prove the frame rule without reference to locality but did not extend well to concurrent programs vafeiadis solved the concurrency problem in where he proves soundness of concurrent separation logic without reference to locality thesis was written at the same time as and takes a different approach rather than removing all reference to locality from the soundness proof smith uses a generalised weak locality property which allows us to handle some nonlocal behaviour we prove our soundness result with respect to a bigstep operational semantics of javascript following the smallstep semantics of et al except where discussed in section their semantics captures the complete language at the same level of abstraction to where a javascript programmer reasons in and flanagan provide a definitional interpreter of javascript written in ml which has the advantage of being directly executable but includes implementation details that the semantic meaning elsewhere et al compile javascript to an intermediate language in order to provide typebased analyses on the object language they justify their translation in a novel way by checking that it satisfies an established test suite of javascript programs however the translation is complicated and it is not immediately apparent that it is sound in fact many approaches translate javascript programs using features such as the with construct into programs which do not for example park lee and show that this is often feasible but do not handle interactions between with and eval there are a number of more abstract models of javascript which have proven useful to study selected language features but which are not sufficiently concrete for our purpose overall we have chosen the semantics in because it appears to be the most faithful to the actual javascript semantics as et al argue in all the features of javascript are in the and cannot be easily abstracted away conclusions and future work we have defined a program logic for reasoning about javascript based on an operational semantics which is essentially faithful to we have adapted separation logic to reason about a javascript subset modelling many complex features such as prototype inheritance and with we reason about the full dynamic nature of functions but do not provide higherorder reasoning we also provide only conservative reasoning about eval full reasoning about these features will be technically challenging although we believe that we can build on the recent work of we do not currently reason about implicit type coercion javascript allows the programmer to define functions to convert values between different types adding this feature to our operational semantics is simple the complexity in handling it with our program reasoning will be in reasoning about higherorder functions as discussed above due to our choice of operational semantics we have been able to prove a strong soundness result any library formally specified using our reasoning will behave well even when called by arbitrary javascript code in section we illustrated this property by that our with example behaves according to its specification even when embedded in a program which uses the nonstandard proto feature finally our soundness result can be extended to include more sophisticated reasoning about higherorder functions and eval we have given several examples of our reasoning with small code examples that javascript is to understand and our reasoning can help in particular our with example shows a potential bug that could easily go for some time and perhaps lead to security holes in environments despite the complexity of the language and the of the bug reasoning about this and other examples is made surprisingly simple by our example abstraction layers we hope that this work will form the core of a larger body of work on web programming for example has defined a typesafe dom api and smith has developed reasoning about dom core level it would be valuable to integrate these approaches to dom modelling with the javascript reasoning presented here et al have developed techniques for building secure javascript out of untrusted code they prove security properties of their enforcement mechanisms but do not study their functional correctness our reasoning makes such an analysis possible we also intend to develop reasoning for highlevel libraries such as and we will make each of these libraries the focus of its own layer of abstraction following the examples in section to make reasoning about uses of those libraries very natural as with our existing layers of abstraction it will be possible to safely break these abstractions where necessary in order to code and reason at a lower level while this paper deals with the and the both provide targets and others have recently given a smallstep operational semantics of it would certainly be interesting to reason about code and to the connections with our reasoning presented here about we are particularly interested in understanding the behaviour of libraries written in when called by code written in to make this program reasoning useful for javascript programmers it is essential that we provide tool support we intend to produce analysis tools capable of bugs such as the one described in the with example in section and integrate our tools with such as or acknowledgements and smith are supported by grant p is supported by grant we thank ohearn da and wright for discussions we especially thank for her for detail references c p and s towards type inference for javascript in proc of ecoop j berdine c calcagno and p ohearn modular automatic assertion checking with separation logic in j berdine b cook and s memory safety for code in cav gm mj parkinson and a m pitts mj an imperative core calculus for java and java with effects technical report cambridge l birkedal and h yang relational parametricity and separation logic in pages ­ n hoare logic for higher order store using simple semantics in proc of t m p m parkinson and v vafeiadis concurrent abstract predicates ecoop d and m parkinson towards practical verification for java in oopsla pages ­ acm m x mj parkinson and v vafeiadis reasoning d dreyer g and l birkedal the impact of higherorder state and control effects on local relational reasoning in icfp pages ­ p s and g smith towards a program logic for javascript college london technical report number november a c and s the essence of javascript ecoop pages ­ d and c flanagan status report specifying javascript with ml in proc of ml pages ­ international language specification rd edition the write less do more javascript library com s j c mitchell and a javascript with filters rewriting and wrappers in pages ­ s j c mitchell and a object capabilities and isolation of untrusted web applications in ieee symposium on security and privacy pages ­ s jc mitchell and a an operational semantics for javascript in proc of lncs s and a languagebased isolation of untrusted javascript in pages ­ p ohearn j c reynolds and h yang local reasoning about programs that alter data structures in csl p w ohearn resources concurrency and local reasoning theor comput sci ­ park lee and an empirical study on the of the with statement in javascript in m j parkinson and g m separation logic abstraction and inheritance in popl m j parkinson local reasoning for java technical report univ of cambridge computer laboratory phd dissertation prototype core team prototype javascript framework easy and dom manipulation for dynamic web applications wc g c b and j the eval that do a study of the use of eval in javascript applications accepted for publication at ecoop g s b and j an analysis of the dynamic behavior of javascript programs in pldi j l birkedal b and h yang nested hoare triples and frame rules for higherorder store in in proc of csl g d smith local reasoning about web programs phd thesis of computing college london a u m s j c mitchell and j automated analysis of javascript in proc of ieee security and privacy ieee p towards a type system for analyzing javascript programs in proc of esop volume of lncs p a type safe dom api in proc of pages ­ v vafeiadis concurrent separation logic and operational semantics in vafeiadis and m parkinson a of relyguarantee and separation logic in in th concur springer h yang o lee j berdine c calcagno b cook d and p ohearn scalable shape analysis for systems code in cav d a n and i javascript instrumentation for browser security in proc of popl 