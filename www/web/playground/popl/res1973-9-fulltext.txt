formalization of l paris paris vii g france is a family of programming languages which has been designed in the framework of a research on computer architecture the system the development of is such as to place it in the framework of structured programming the of label and goto have and are replaced by those of program equations this gives rise to important mathematical properties which are useful in the system furthermore this fact may bring implications in the theory of programming in particular we powerful methods proving the correctness of programs the semantics of is welldefined algorithm which allows one to translate assume that the semantics of combinatory with respect to combinatory logic that is there any program a into a word a of combinatory logic is known exists logic an we the word a thus obtained contains constants reducing this word until no reduction rule remains only and the execution of the program consists in applicable the reduced word thus obtained ie result of the program it is necessary that certain constants of and of combinatory logic should have the same interpretation to simplify we have simply added to combinatory logic these specific constants and the operating rules in correspond to the reductions in combinatory logic this is made more precise in the following since the allocation will be during the interpretation of the programs most of the declarations are and are not considered in this formalization however concerning the added constants their by the computer is by a control of types similar to that described by b such a calculus ia in any way for a variant apl of as for the procedures we a simplified treatment of the calculus of types the header of a gives the possibility of determining its type which is more general and more precise than that defined in the languages such as algol we use this calculus of types to generalize the procedure calls the correspondence and combinatory logic thus allows one al to describe without ambiguity how a machine executes a program b to define machine the interpretation and therefore the semantics of a program c ­ to establish of the programs independently of any the research reported here was supported in part by the de en these properties give the possibility of defining transformations which preserve the equivalence of the programs these transformations may be used by the system to increase the efficiency of program execution by a machine the treatment of programs and more generally the architecture and the logical functions of the system are thus justified remark let us first mention arguments a and b forms forms an some notations the ab the symbol the combinator which applied more generally is a combinator with n arguments to two and which a an n to every natural an mm integer n we associate a combinator which selects th the nl of we use two particular constants error we also use the predicate dx if at least cu and q we may interpret q which has one argument one component m as the undefined and q as the x this i else argument o must be an finally we use specific algorithms un with n arguments these algorithms lattices operator sup they may be interpreted as follows let us take for instance correspond n to the if ab then a if then b if then a else we also write u a b instead of when a and b are the above definition must be extended by comparing a to b component by component the result being an of the same length the basic language ls definition the basic language ls describes at al i the operations of sums and products for a b al sum ab product these contain either primitive operations are described below f for the operations moment it or compound is enough to distinguish primitive three of them f the set of which instructions f fq f the set of t cfl t the constant a which to the dummy ls is generated by the two following rules a a and the elements of f belong to m b then as ix the translation of these formulas in combinatory logic is defined by the algorithm t i if ta a and ta ii t and thus two new constants are introduced in lc and we generally admit that formula ab b is computed only if the execution of a resp not lead to an error q hence the following rules of reduction for any variable in the t does ab j the respective values of and c are remarks if the errors are not taken into account composition written and to set ab ab so cb it is possible to limit to a simpler we suppose that such that v leads to an error for we can always limit ourselves to a set t we introduce functions thanks to appropriate definitions the composition of tests bv boolean for instance u u etc we can generalize set the formula of tests if we suppose that tg c o n we can al and tt with t equivalence in ls and properties two which give the same from the arguments can be considered in fact different the variable used in the reduction rules states of the machine so we can set any possible arguments as equivalent the ta definition tb two words a and b of ls are equivalent if and only if v that cq o properties i i in the same way we have ii aa u a and i i aa a properties ii associativity abc abc a bc abc as a matter of fact abc j ab ab c if then abc else abc a else if ba then abc ba but j if then abc abc a else if ba then abc ba the property of then allows the of unnecessary in the way we have property iii distributivity va and remark it can be established that there is no left a if on the other hand one knows that ca o then ab the property let us first of distributivity may be generalized for this we introduce define the terminal occurrences of a word of is the notion of continuation definition an occurrence f of a word in a ie to be terminal if al either a b or there are a and d such aa y and is terminal in c or there are and a test t such as and is terminal in y or in for in aa d and bc are terminal in a a and b are not the continuation of a by denoted by is defined as follows definition pa the word obtained from a by concatenation the terminal occurrences of a and of the elements of f in a of the word to all property iv generalization of distributivity pa this is demonstrated by induction on the of the word ct if the length precisely pa a if a ie of the form ab we have of a is one we have bp a if a is of the form we have the extended language the procedures semantics of the language it is the language are later in which the procedures are described except the calls of procedures which up to now we described the extended language describe or even recursive for that purpose of label but that of action variables the possibility to we do not use the notion we consider a new set va the action the extended of ls language le is obtained by adding by elements of v to the words a we call equation in ls any word of the form where x belongs to va and f belongs to le x is the left right member of the equation the of va which have some occurrences in f can be considered as variables which range ls and is then an implicit equation which binds x to these variables the body p of a procedure is an ordered pair such that a e is a finite set of equations in ls and such that for any variable of action xk occurring in one of the f there exists equation and only one ek of which the left part is precisely x an b there is an equation en of which the left part is x n the body of a procedure is then a set of equations similar to these which define the grammar of a c language can consequently solve them by the method in fact it is to complete ls in by infinite words which are the limits of in for that purpose the of l are associated to the polynomial of the free associative algebra the of which are elements of the free with an unit element and the coefficients of which belong to the ring p ab pa pb p t pa pb we call of two polynomials and p the number s of the having the smallest degree and which in one of the polynomial and o ae a in the other s thus becomes an space s being the degree has as a thus sequences in s p only if eo k pz are equivalent if and to let the set of the set of equivalent sequences the language l corresponds such a completion is equivalent to that proposed by scott it is known that in the language the system e verifies some conditions conditions of which do not the generality of the e admits a unique and h f applying into solution fo let f be the fo is such aa fo fifo the expression of this solution in combinatory logic must then verify the condition f operator of abstraction where y is a fixedpoint but we may write then the may be written combinator f m tf where x is the as follows to build tf it ie sufficient to give the translation of the in and we then have the translation of the body p of a procedure is then the n th component of equivalent systems two systems el and e are equivalent if they have the same solution let eq be the system one equation variable x k where f j ff f is from and e the fj by substituting system identical to el except for fk for the occurrence a of a theorem of substitution the systems eq and e are equivalent the solution of e is f f f by definition p e is equivalent to but now the consequently the ie the fixed point th j equation of e if f x if in other words fo is solution the two systems el and e are then equivalent this result shows that during the process of successive approximations allowing to reach the fixedpoint solution of the system all substitutions are allowed this of substitution then defines transformations that preserve the equivalence of the systems of equations it also the techniques of copy used by and manna to transform the goto programs into while programs the iteration definitions iteration is an abbreviation for a particular form of action in fact we construct a new language li which besides ls contains iterations the iterations are a generalization of the loops while of algol the li alphabet is by the ls alphabet and by the three symbols m an iteration has the following structure body of the iteration where body of the iteration is obtained from the words of ls by substituting to some occurrences of elements of f the constant o the language li is obtained by adding by induction the iterations to ls thus we may construct nested iterations an iteration is interpreted as follows if during its execution we meet the u then one goes out of the innermost iteration in which symbol ie met and one goes to the following formula one continues the normal execution of the iteration j one starts again at the beginning of this latter if one meets a terminal occurrence different from m however in of its analogy to regular expressions the to describe all without having to auxiliary variables in the regular expressions there is no equivalent to these tests ie still for exit the incompleteness in the language li appears because extended to the iterations for instance let of o it is impossible to transform into be also an exit of b the continuation operation cannot be in which a contains an occurrence for the occurrence of m in u should thus we consider the infinite obtained from li by substituting countable set a let li be the set of the any element of a to the occurrences of m we extend the notion of terminal occurrence to the iterations if these is y such as ua and ia a terminal occurrence of a has a terminal occurrence in a definition it is said that and y contains exactly has an occurrence n more symbols at the level than n in a if there ie y and such as definition the language li is a of li such as al the iterations only have terminal occurrences in the words of li b vn any occurrence of u is a terminal n occurrence at level pn oj is a more general n symbol than iterations the words of li u the occurrence thus only of which terminal leads to the termination of the n iterations this does not decrease the generality of this language at all of the continuation operation which is in li for the word on the left of does not belong to l whereas that belongs to but according to the interpretation of on they are equivalent on the right the semantics of the iteration can be defined by an algorithm which permits to a set of action equations to each word of li let m c li and j an occurrence at level o of the iteration let z and z two action variables we associate to m the two actions zi z where is obtained from al by in i to every terminal occurrence of the elements of f and at level o b by every occurrence at level o of cl by replacing every occurrence at level n of on by z d by replacing every occurrence at level n of by un in the occurrences of are terminal and at the level pn by thus adding a number of equations in a finite number of steps we are led to a e which no longer contain any iteration by definition this system is associated to n we verify that the action such a system is said regular have only terminal each equation of e translation of into an iterative a regular system of those systems thus corresponds we are able to a flowchart the li to them in li language permits to write the solutions as a matter system of fact the following algorithm permits to associate a word of li to each regular let e be such a system al set i b if fi then f if i and go to d otherwise i c transform fi into f as follows go to e at level i o the word u to every terminal occurrence of the elements of f which is ii every occurrence of zz at level o in f iii replace every occurrence of u at level n n by a n iv replace every occurrence which is at the level i n by the word thus obtained within the brackets and and frame d substitute f for every occurrence of xi in every lj by u np if the occurrence of xi at the level p equation e set and if go to b otherwise go to f indexed by replacing f the last equation in the first p equations system is translated into li ie thereby transformed and then x in the p into first x z f where p p equations fc li by substituting and so on the entire x p we have thus method semantically reduced to a simple established the equivalence between equivalent to the of auxiliary location of the level of the regular systems and the language li variables shows that their utility can be of the iterations structure of the formulas and of the tests rules of of the formulas we have until now the formulas as atoms the established are then of the structures of the formulas since we may define many variants of fortran variant or apl variant for instance we do not try to define a precise structure of the formulas but rather the rules by which they are we again consider the following sets f set of constants f fm ­ of the in practice we may limit operators v ourselves to ms fq is the of variables set of the monadic y xl o operators f the set v p we suppose the nary vi i are d functions of n arguments the domain of which is by definition finite thus they can be represented by tables and for that reason unlike procedures they may be modified by an if the domain of a nary variable is the cartesian product of n segments of the natural integers then we say that it is an array the rank of which is n it is generally speaking a tree the terms are generated by the two following rules al the constants and the variables are terms b if terms t are terms and if n and then and the elementary formulas or assignments are generated by the two following rules a if o and if t is a term their x is an assignment b if are terms and then is an assignment finally the formulas are obtained from elementary formulas by adding in an inductive way the assignments to the terms the formulas and xt zf x and hence we need only to consider are then equivalent are by definition to a respectively yz xy the elementary formulas of assignments therefore equivalent to remark we must be careful to distinguish the symbols and which are used in the composition of the formulas from the same symbols which appear in ls to prevent any confusion it would be to choose other notations but this has no importance for what follows semantics of the terms the constants and the variables of are translated into lc by constants designated by the same symbols fi fx v the semantics of the terms is then defined by the rules and variables rules the interpretation of each constant f is then described by a set of rules of reduction correspond to conversion in the full xcalculus these rules are of the form these with iii we say these functions are scalar operators if xl does not belong to the domain of f we admit that we may also use a set u of mixed operator such that operators the in which at least one x or a is an array i or a tree we may choose for of which can be described by means of scalar operators and specific mixed iterations adapted to the data structures array and tree this has already been out with regard to the apl operators that are incorporated into besides these iterations have properties these properties may be used to interpret a term in a global way this global interpretation leads to a significant simplification of the and considerable number of memories we from now on that all the operators are scalar in the translation of the terms the set of the variables later on how the variables u vi is i in fact we show translation of the formulas a every formula is first put into the form xt in the formula k is by definition o that it is a function a function whose domain is finite let us suppose to simplify of one variable the domain is then isomorphic to an entire the explanation segment of integer n if such is the case the word xi is by definition equivalent to b in lc is no equivalent to the operation of thus we cannot define directly the semantics of the formula to give the algorithm of translation of an assignment it is to know the context in which it appears this context is the procedure itself consequently we must first of all specify this context that is make precise what we mean by a procedure is is translation of tests the predicates of are translated into lc by some constants t he predicates are used to form the tests t distinguish the nary predicate designated as for by the same symbols the operators we may their interpretation is a nary predicates vi tests are total functions of the tests is thus described by a set of rules of reduction in which t lin o and a let it be that we that the as in the formulas the variables have not in the translation translation of the procedures assignments and tests a is a ii p vr at where p is body of the procedure ii vt ia the set of the variables which have occurrences in pm is the set of the variables of procedures which have occurrences in p an is the sat of arguments of ii defined by header of ii with two new sets thus introduced for every procedure pm and am the elements of pm used in the procedure calls described in a later of course every one of the variables is distinct from simple variables the other variables or procedure variables and but the are either let be the translation of ii into lc the algorithm t does not take the assignments the variables and the tests into account us describe the algorithm let z be an auxiliary variable let n we define a application segment on the function where natural integers xc a is a word in combinatory logic function z is by then o else every let xt xc in ba an assignment let be the t under such conditions the word obtained transform of by substituting this assignment tx l x word by is for if t is a test its transform by is calls in a po a call of the procedure pi may exist in the formulas r ie the result part a the argument part the effective arguments corresponding the formal arguments we first consider the transfer of arguments we have i i rp a where place to place to let m be the symbol a new constant be the function if interpreted as the undefined and let then such that am else p co thus the call of the procedure pi is translated by o pl n since the of every formula of is an the result this definition of the procedure to be reducible before the call call does no require the effective of p is also an n arguments if they are terms as for the of the results we may suppose that in the result part rr every ri is of the form where xo and xl e vp as in the formulas a result transmitted in the form ie by definition equivalent to but we must consider the case in which a variable of po is present in different thus we use the algorithm un cf j the set of defines an application rl the value o transmitted to the is then ri let r be the j set of j values appearing then in the r let such that be the function else z i defined where u is the set of variables of po as follows the procedure call by po ie then translated by o thus the interpretation of a call of the procedure in the words of combinatory logic and of the procedures ru hi by a procedure ie defined by but not in the very written in logic these after the transformation ot each procedure where every variable has except procedure variables are free in hl is translated into the procedure variables a word which of combinatory l do not belong to am the expressions of procedures and the extensions of types until now we have that the procedure call with the rule of of types but we have defined a mechanism which gives us the possibility of extending this rule this has been formalized in the and may be applied to most of the programming we use it in without restriction the interest of such a mechanism is that it the language with very simple rules of semantic extensions at the level of the procedures them this simplifies the programming and avoids the use of a great number of intermediate procedures translation of programs a program is a set of data these data are either d where p is a set of procedures structures of elements of f or procedures which and p is a are to belong to p the execution of c is defined by the call the desired results are indicated in r we suppose that all the data may be applied to pi that is not restrictive let be an auxiliary variable in p and d we replace every pi p by the of such is designated the p of procedures into an ri free variable of procedures by and we then transform in r we take as for the action equations the translation of the c is is then the word consequently cc obtained is then which may be reduced a word of logic this the semantics which of c only constants and the reduction of tc leads al either to r the set of expected results b or to an error in the case b we may point give the state of the memory out the error appeared besides the obtained of the computer at the moment at which the error appeared values references de la paris vi publication n de stanford university the translation of goto programs into while cs architecture of the system ture june international workshop on computers the as a formal and description for computer programming language formal language description languages the algebraic theory of contextfree languages computer programming and formal system and north holland notes on structured programming university of un et des de des des et de la paris july des algorithms de presentation intuitive de paris n du des application au apl paris description march des primitives technique des de et interpretation cr des de paris a t pp et tz des expressions pp the lattice of springer verlag symposium on semantics of algorithmic languages types as lattices amsterdam june international interaction paris october le pro types et lee de procedures la paris july des et de 