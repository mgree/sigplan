compilers by l graham and p t university of california at berkeley introduction a substantial portion of any programmers time is spent in debugging one of the major services of any er to be to provide as much information as possible about compiletime errors in order to minimize the time required for debugging a good error detection and recovery scheme should the number of errors detected but minimize the number of times it reports an error when there is none these spurious error and their associated error messages are usual ly by an recovery action in this paper we describe a recovery scheme for syntax errors which provides high quality recovery with good information at relatively low cost in addition implementation of the recovery scheme can be automated that is the recovery routine can be created by a parser generator therefore the compiler designer need not be with the difficulties of error recovery and the programming effort necessary to design and a of adhoc recovery routines the syntax error recovery scheme we propose does not any overhead for parsing correct programs or correct portions of programs with errors once an error has been detected the parsing stack andor the input stream are modified in order to get the syntax analyzer back on the track ie to get back to parsing as if the program were syntactically valid as is true of any recovery scheme the recovery action taken does not necessarily with the programmers any given piece of syntactically incorrect source text may mean different things for different computations research supported by the national science foundation under grant gj present address bell north for example consider the incorrect algo statement i nm ij among the many equally correct versions of the above statement are the following two different statements i nm i nm i j furthermore different classes of programmers for instance programmers vs programmers may make different kinds of errors consider the syntactically invalid fortran iv statement readable given by e james and a former fortran ii programmer would probably have meant read able whereas a fortran iv programmer would probably have meant read able some people try to syntactic error handling systems into two categories recovery and correction they define the former to be systems which do not allow the execution of programs having syntax errors while defining the latter as those systems which permit the execution of such programs the previous example shows why this terminology is very whether a system allows syntactically incorrect programs to be run has little to do with whether it has made the right correction of the syntax errors involved as shown above there is often no single right correction hence we will not make this distinction the recovery method to be presented is embedded in a simple precedence parser although the techniques we used are particularly well suited to this parsing method the ideas are easily incorporated in other methods of parsing the results presented in this abstract are contained in the phd dissertation of the second author which contains a more complete discussion of many of the issues which can only be on here summary of previous methods in the last there has been increasing interest in the problem of syntactic error recovery and a variety of techniques have been discovered the simplest and automatic recovery technique was discovered independent y by several people this strategy is frequently referred to as the go forward to a safe place and then back up technique or the mode in this scheme when an error is detected the input is advanced until one of a class of special symbols such as a or an end is located the parsing stack is then erased until the special symbol can follow the top of the parsing stack this method is fast and requires a small amount of code but the errors contained in that portion of the text which is are not detected thus possibly many additional computer runs to detect all of the errors in the users program in addition little information is available about the nature of the error if the parsing method being used is predictive that is it is possible to determine easily all the possible valid continuation symbols for the input read so far then the input can be advanced until one of these symbols is encountered the recovery scheme for described by and implemented by l james is a more sophisticated version of this technique in the most parsing methods it is possible to find very local changes to the input at the point of error detection for example insertion or deletion of a single symbol or token which make the input locally correct however these changes might not be correct with respect to larger portions of the input one approach used by and la france among others is to try out all the possible local modifications by the parse for each if as in the method one continues multiple parsing for an unbounded number of steps the combinatorial explosion in space and time makes the technique very therefore la france bounds the amount of multiplicity another approach is to try only a small possible local modifications and use the first one that works see the approach taken by and the is to build into the parsing table error actions based on the edge of programming errors and appropriate particular recovery actions such a system handles the expected errors reasonably well but can on errors the grammar by error productions is another form of this approach one can combine the local correction approach and the special knowledge technique by having an table of possible local modifications for each symbol or pair of symbols in error see for example et al and definitions and notation a contextfree grammar is a tuple g where is a finite set of terminal symbols n v z is a finite nonempty set of symbols p is a finite set of rules or productions xx where x e n and x e and s e n is the initial for any rule xx x is side abbreviated lhs and x is side i rhs symbol the left hand the right hand as usual with respect to a grammar g we define the relation on v x v such that for any a e v b e v a b if and only if there exist u e n u m u e v and u u in p such that a and b out we represent by transitive closure of for any no we call the sequence a al an the closure oi n a derivation of an a of length fi q if where for ai u and ail for some oi e v i e t and ui u in p the derivation is a rightmost a sequence of symbols u is a form if s au the form is if there is a rightmost derivation such that s u if u e x then u is a sentence the language lg defined or ge q is th e set of all es thus lg u e z i su we refer to the process of a derivation given a sequence of terminal symbols and a grammar as parsing given a form e v rule uu the transition from to out obtained by substituting u for u is called a reduction for any grammar g simple precedence relations o are defined for all a b e v by ab ab if for some u n e v p contains rule u if for some u a e v contains a rule u and a p ab if for some o v a ye v xy e n p contains a rule u and and y ba a grammar grammar g if is a simple precedence a for all relation is satisfied at most one precedence for any set of symbols v v denotes the set of all sequences of symbols from v and v v a where a is the empty sequence b p contains no rule with rhs c no two rules in p have the same rhs d with respect to g there is no rightmost derivation ss simple precedence parsing and error detection we briefly review simple precedence parsing for the reader the parser for a simple precedence grammar g v uses a pushdown store called the parsing stack which we represent as a sequence of symbols with the base of the stack at the left and the top of the stack at the right there is a stack symbol designated d and an symbol designated where t are not in v the last input symbol is always we extend the precedence relations to and by the rules that for every x e v if there is some u e v such that s xo then x and if there is some o e v such that s ox then x initially the parsing stack contains only for an input string which is contained in lg the parser works in the following way the output steps semantic routines etc step step step step step read the next input symbol if the precedence relation between the symbol at the top of the parsing stack and the input symbol is or then stack the input symbol and go to step if the input symbol is and the contents of the stack is ds then exit otherwise the precedence relation between the top stack symbol and the input symbol is scan the stack from right to left until the first instance in which a symbol call it a and the symbol to the right of it in the stack have the precedence relation find the rule having as rhs the sequence of symbols to the right of on the parsing stack replace the symbols to the right of a by the of that rule and go to step a lhs in the usual precedence parser errors are detected in one of two ways the first occurs when there is no precedence relation between the top of the parsing stack and the incoming symbol step this situation is usually referred to as a character pair error in a typical algol grammar for instance the ai j k would have error between the i and the j since an identifier can never be followed by an identifier the second type of error is found when a potential rhs is detected using the precedence relations step but it does not match the rhs of the grammar step this type of error is normally referred to as a reduction error a reduction error can arise in the way the simple precedence grammar s n n dd dl generates the sentence if the parser for this grammar is given as input eventually step finds a potential rhs dd yet no rule of the grammar has this rhs the error detection a simple precedence parser can be significantly improved without any increase in the running time of the parser first as suggested by when a reduction is performed a check can be made step to see that a and the lhs to be have precedence relation or otherwise a error occurs the second error detection extension is an improvement in the detection of reduction errors in this second extension which is original as far as we know the system checks the top of the stack for prefixes of of rules of the grammar before it puts a symbol onto the stack this can be done for example by having the production table sorted by and having a pointer into this table which is advanced before each symbol of a rhs is all the with a common prefix will then be together when a new rhs is i e when the top symbol of the stack and the symbol to be have precedence relation the previous pointer value is saved and the pointer is set to the first production such that the leftmost symbol of the rhs is the symbol to be when the prefix at the top of the stack is to be ie when the top symbol of the stack and the symbol to be have precedence relation the pointer is set to the first rhs having that prefix fol by the symbol to be when the prefix at the top of the stack should be a rhs ie when the top stack symbol and the input symbol have precedence relation the pointer should be pointing to the rule with that rhs in the latter two cases if there is no such rhs a id rhs error is said to have oc since the traditional parsing method must also search through the step our method entails no increase in parsing time the only difference in our method is that it does the searching incrementally whereas the usual method performs it all at one time consider again the example given in the discussion of the usual precedence parser in the system described in this paper the parser detects a rhs error on the second since there is no production whose rhs with dd notice that a character pair error is another kind of error and a reduction error is one kind of rhs error in certain other parsing methods such as lr parsing errors are detected as soon as the part of the source program that has been seen thus far no longer forms a prefix of a sentence in the language being parsed in this class of methods which will be referred to following as methods having the correct prefix property the error is recognized at the possible point in a single deterministic scan of the input text this does not mean however that the error is necessarily detected exactly at the point of its occurrence the error and its detection may in fact be an unbounded distance apart for example suggests considering the regular language o with the input ok the error is detected at the first if one assumes that a correction involving the minimum number of changes is the most appropriate change then the symbol in error is most probably the that is kl symbols back in the input notice however that it suffices to change both s im s in order to recover from the error it is possible that even with our modifications the simple precedence parser may detect an error an unbounded number of symbols after a correct prefix parser for the same grammar however in practice our modified simple precedence parser detects most errors at the same place they would be detected by parsers having the correct prefix property furthermore while early detection of errors may be useful for providing error messages the to correct the error at that early stage in order to preserve the correct prefix property can be a decided for example given the language abc u i n o and the input bf a correct prefix parser will detect an error at the first f change the f to a c and repeatedly indicate that each symbol is in error a grammar is easily constructed for this language such that the modified simple precedence parser for that grammar will not detect an error until the end of the input however at that point our recovery scheme will simply delete the a the phase after an error is detected a recovery scheme must recover from the error and continue parsing so as to be able to detect and report subsequent errors to the programmer the recovery strategy may involve simple or complex of the input stream andor the parsing stack immediately after error detection most recovery strategies begin to consider what the input stream andor the parsing recover from the error the method described a phase between the error detection and the correction phase the phase thus is called the phase when an error is detected the stack may be in an configuration in the sense that reductions may be possible if the error is ignored in addition parsing of the input stream past the point of the error detection may yield important information as to the cause of the error the two ideas above are the motivation for the phase the phase attempts to information about the point of the error detection by performing as many reductions as possible in the of the detection point the point at which the error is detected be designated this is the point immediately preceding a rhs if the corresponding lhs lead to a error the point at the top of the stack if the corresponding lhs leads to a rhs error similarly if there is a error is at the top of the stack but if the incoming causes a rhs error the symbol is and followed by and the input is advanced the phase is divided into two sometimes three parts the backward move consists of assuming that there is a relation between the symbol to the left of and the symbol to the right which may be the input symbol and returning control to the parser this causes all possible reductions at the top of the stack to be made once the backward move is done the state of the parser perhaps being unchanged the forward move is carried out it is assumed that s a precedence relation between the symbol to the left of and the symbol to the right and control is again returned to the parser the forward move terminates when a second error is detected the second error is either another real error in the source text or another of the first error ie because of the top of the stack does not contain the prefix of a rhs we by at least the second error point one symbol between finally a second backward move may be done from the point phase this completes the consider the following algol example mq i mp then k else m the most error is that there is a missing if preceding i for a typical algol state of the parser after the error is detected will be that the stack has the form d variable a message is only if there appears to be a second error in the source text the input symbol is and the rule with rhs variable has a lhs which cannot follow for example the rule may be factor variable no reductions are made by the backward move the forward move reduces i m p to expression and then assuming the grammar contains a rule if clause if expression then detects a second there is no rhs with prefix expression the stack then has the form expression then and the incoming symbol is k the second backward move does not alter the configuration this example illustrates the of a forward lookahead without a fixed a priori bound since the forward move reaches the the correction phase has the information to be able to insert an if we are of any other practical that would be able to recover in this manner we most other schemes would change the to a or some other equally recovery action of course the backward and forward moves may not make the correct reductions for example the algol fragment x i j with a missing operator between i and j wi be parsed to something like a statement x i followed by an expression j however our empirical tests indicate that the phase provides information for instance in the previous example the wi the correction phase to delete the expression j this is as correct an action as inserting a the correction phase the forward move provides in effect an unbounded lookahead beyond the point of error detection after the phase the right context of the error provided by the forward move is contained in the parsing stack plus the current input symbol the purpose of the correction phase is to change the contents of the parsing stack so that the error situation is and the parsing stack is to the prefix of a rightmost form in fact the correction phase only that in the of the error the parsing stack appears to be the prefix of a rightmost form that is the contents of the parsing stack could be obtained by the simple precedence parser on some input without having discovered an error since we wish to use as much of the context of the error as can be efficiently exploited the correction phase considers changes to sequences of symbols rather than isolated changes to single symbol s for the sake of efficiency only three sequences of symbols are candidates for correction and only a fixed number of possible are considered the choice among the possibilities is determined by a probabilistic pattern match the candidates for modification are the sequence of symbols from the to the left of up to from that l up to and from to furthermore these candidates can be changed only be deleting the entire candidate sequence or by replacing the candidate sequence by the rhs of some rule of the the restriction on possible is not since it corresponds to the first that the precedence relation at point is i relation at point second that the precedence s and third that the precedence relation at point is o there is also an implicit assumption that the precedence relation at point s in practice this is almost always the case one can modify the correction phase so that prefixes of are also possible but the increase in computation is significant when measured against the empirical percentage of instances when such are necessary thus if the number of rules in the grammar is n we consider only nl possibilities we choose from among these the change which is the fit and appears to correct the error the correction phase is divided into two parts the first part reduces the set of possibilities to those for which the result of the replacement or deletion is locally correct essentially a modification is locally correct if it does not create a error or a rhs error more precisely definition let g be a simple precedence grammar a reduction xx is locally correct in the context v if y e v p p xb p if a x and xs b then is the rhs of some rule in p if a x and x b then x is the rhs of some rule in p otherwise if a x then is a proper prefix of the rhs of some rule in p the deletion of x is locally correct in the context y e v a b e v d if a b then is the prefix of the rhs of some rule in p if a b then ya is the rhs of some rule in p in considering a candidate sequence for replacement or deletion the left context is always the sequence of symbols starting with to the left the the tests for local correctness can be done since it is the set of or non terminals which are tested and the error checks are those done by the parser in most cases these tests eliminate a substantial portion of the possibilities in our experiments the second part of the correction phase determines which of the remaining possibilities has the fit that is which of the potential requires a minimum of symbol cation a weighted measure is used in order to compute how close a given rhs is to one of the candidates for change two vectors i and d are used for each symbol in the grammar the i vector contains the cost of inserting that symbol anywhere in the stack and the o vector gives the cost of deleting that symbol anywhere in the stack the fit is then defined to be the match with the minimum cost as an example of the cost computation consider the following two lines im imp the apparent error here is that the symbol im was left in the source text for a typical algol grammar the phase leaves the stack in the following state i variable statement the cost of changing the to candidate using the production statement is if the to candidate is changed using the same production the cost is the most alternative for our recovery system in this situation is probably the deletion of the to candidate the cost of deleting a sequence of symbols is simply the sum of the cost of deleting each symbol hence the cost of deleting the to candidate is after the pattern matching process has determined the cost of the changes by using the cost vectors the minimum cost change is made control then returns to the parser in the event that the minimum cost is greater than a fixed a form of the mode is used the assumption in that case s that the change although locally correct is so that it is probably wrong the cost vectors i and d can be generated mechanically or can be provided by the there are a variety of heuristics which can be used in selecting the costs in order to improve the quality of the recovery for example brackets w end etc and the non terminals them etc should have relatively high i and d values and long words should have high deletion costs the form of the correction phase we have just described is only one of many variations that can be used for example one can have a cost function r which assigns costs to replacing one symbol by another these values are normally lower than the corresponding i d costs one can permit a greater variety of for the three candidate phrases a more definition of locally correct can be used can be incorporated all of these additions have their uses although at a certain additional cost in the amount of recovery code and the maximum time to recover from a single error one can also reduce the amount of computation in the correction phase and get recovery that is almost as good all of these variations are discussed further in comparisons with other recovery methods we implemented the recovery method complete with a variety of features which could be independently or for purposes for pascal and for an al syntax we then compared the recovery actions taken by our system on a body of test data with the performance of the pascal and algol w compilers although such comparisons are necessarily somewhat each compiler does some kind of recovery for every error it our system appears to discover more of the errors when the errors are and in general to give fewer spurious error in addition the errors that one or more of the other compilers handles well are almost always dealt with properly by our system it is that more use of these techniques will provide additional information the sorts of errors for which our techniques seem particularly powerful are such things as errors in the middle of a list other methods end the list at that point and either or the remainder of words systems that errors that show up later parsers tend to treat everything already parsed as correct and errors involving bracket ing remarks we have omitted from this paper any discussion of error messages language design to reduce errors grammar design to facilitate recovery and of these recovery techniques in other parsing methods all of these topics are discussed in the aspects of this approach to error recovery which give it its power are the ability to from lefttoright parsing in order to analyze the lookahead beyond the point of error the systematic approach which reduces in the treatment of errors the structural constraints on the grammar which reduce the number of to cost vectors which can reflect the expected behaviour of the programmer and the relatively easy way in which the can the error recovery references hr s and graham sl algol w implementation technical report cs computer science department stanford university stanford ca may hr s graham sl and te e algol w language description technical report cs computer science department stanford university stanford ca sept rw morgan hl ra and tr a high performance subset of pl technical report computer science department cornell university ny february rw and tr design and implementation of a compiler for pl communications of the association for computing machinery vol march pp d the use of transition matrices in compiling vol january pp james eb and dp adaptive correction of statements communications association for vol january pp james lr a syntax directed error recovery method thesis technical report computer systems research group university of knuth de on the translation of languages from left to right information and control vol november pp la france syntaxdirected error recovery for compilers phd thesis iv document computer science department university of illinois illinois june rp error detection and recovery for syntax directed compiler systems phd thesis computer science department university of jp automatic correction of syntax errors in programming languages phd thesis technical report tr computer science department cornell university ny december morgan hl correction in system programs communications of the assoc for computing machinery vol february pp tg syntax error detection correction and recovery in parsers phd thesis institute of technology nj sp practical syntactic error recovery for programming languages phd thesis technical report department of computer science university of california berkeley ca june n and h a generalization of algol and its formal definition communications of the association for computing machinery vol january and february pp and pp n a programming language for the computers journal of the association for computing machinery vol january pp n the programming language pascal acts informatica vol january pp n the design of a pascal compiler proceedings of the international school on program structures and fundamental concepts of programming germany july 