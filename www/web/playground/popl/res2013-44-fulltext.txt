complete interpolation institute of technology thomas new york university abstract craig interpolation has been a valuable tool for formal methods with interesting applications in program analysis and verification modern smt solvers implement interpolation procedures for the theories that are most commonly used in these applications however many theories remain which limits the class of problems to which techniques apply in this paper we present a generic framework to build new interpolation procedures via reduction to existing interpolation procedures we consider the case where an theory can be formalized as an extension of a base theory with additional symbols and axioms our technique uses finite instantiation of the extension axioms to reduce an interpolation problem in the theory extension to one in the base theory we identify a criterion that allows us to detect the cases where our technique is complete we discuss specific theories that are relevant in program verification and that satisfy this criterion in particular we obtain complete interpolation procedures for theories of arrays and linked lists the latter is the first complete interpolation procedure for a theory that supports reasoning about complex shape properties of data structures we have implemented this procedure in a prototype on top of existing smt solvers and used it to automatically infer loop invariants of programs categories and subject descriptors d software engineering verification f logics and meaning of programs specifying and verifying and reasoning about programs i artificial intelligence deduction and theorem proving general terms algorithms theory reliability verification keywords craig interpolants decision procedures satisfiability module theories program analysis data structures introduction in his work recognized the of craig interpolants for the automated construction of abstractions of systems since then algorithms have been developed for a number of problems in program analysis and verification an important requirement for most of these algorithms is that interpolants are ground ie quantifierfree this is because the computed in permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm again serve as input to decision procedures that only support quantifierfree formulas modern smt solvers implement ground interpolation procedures for the theories that are most commonly used in program verification this includes theories such as linear arithmetic the theory of uninterpreted function symbols with equality and combinations of such theories however many theories remain this limits the class of problems and programs to which algorithms can be applied in this paper we present a generic framework that enables the modular construction of ground interpolation procedures for theories via a reduction to existing interpolation procedures we focus on cases where an theory can be formalized as an extension of a base theory with additional symbols and universally quantified axioms as an example of such a theory extension consider the theory of arrays over integers here the base theory is the theory of linear integer arithmetic the extension symbols are the array selection and update functions and the extension axioms are read over write axioms which give meaning to the extension symbols theory extensions often appear in practice eg as part of the background theories of verification systems such as and why and the tools that are built on top of these systems our starting point is the approach to interpolation for local theory extension presented in local theory extensions are extensions for which satisfiability of ground formulas can be decided via a reduction to satisfiability in the base theory the reduction works by instantiating the extension axioms only with terms that already appear in the input formula in this reduction approach is applied to the problem of computing ground interpolants in local theory extensions this technique is used eg in the interpolation procedures underlying the software model checker and the prover in the interpolation approach was shown to be complete for a syntactically defined class of local theory extensions unfortunately many interesting theories do not fall into this class instead of syntactic restrictions we identify a stronger condition on the theory extension than just locality to ensure completeness of interpolation we then relate this condition to a semantic property of the models of the theory extension we refer to this property as the partial property this property allows us to systematically construct theory extensions for which the approach produces a complete ground interpolation procedure the resulting framework then applies to a more general class of theory extensions than we discuss several nontrivial examples of theories that are relevant in program verification and to which our framework applies in particular we consider the theory of arrays with difference function using our approach we obtain an alternative ground interpolation procedure for this theory unlike the procedure presented in our procedure does not require a decision proce for this specific array theory instead it reduces the interpolation problem to existing interpolation procedures for uninterpreted functions and linear arithmetic the second example that we discuss in detail is a variation of theory of linked lists with reachability predicates which was studied more recently in we show that this theory does not admit ground interpolation unless it is extended among others with an additional join function given two heap nodes the join function returns the join point of the two list segments that start in the given nodes if such a join point exists the join function is not just of theoretical interest but is also useful to express properties about the heap that are important for verifying frame conditions we prove that our extended theory of linked lists with reachability has partial using our approach we then obtain the first ground interpolation procedure for a theory that supports reasoning about complex shape properties of data structures this interpolation procedure has promising applications in shape analysis and may also provide a new perspective on the construction of shape domains in parametric shape analysis to show the feasibility of our approach we have implemented a prototype of our interpolation framework and instantiated it for the theory of linked lists presented in this paper we have successfully applied the resulting interpolation procedure to automatically infer loop invariants for the verification of programs summary the main contributions of this paper can be summarized as follows · we present a new framework to construct interpolation procedures for theories · we present a criterion that allows us to identify the theories for which our interpolation framework is complete · we present examples of theories that are important for program verification and to which our framework applies in particular we present the first decidable theory for reasoning about complex shape properties of data structures that admits ground interpolation · we report on our experience with a prototype implementation of our framework which we have successfully used to infer loop invariants of simple programs an extended version of this paper including proofs of key lemmas and theorems is available as a technical report motivation and overview we our approach using the concrete application of interpolation to the problem of inferring invariants for program verification consider the reverse function given in figure this function takes a pointer x to a list as input the list and then returns a pointer to the head of the list our goal is to verify that the reverse function preserves ie if the input list is acyclic then so is the output list we can express of list x by saying that null is reachable from x by following the n pointer fields in the heap using the notation that we formally introduce in section this is denoted by the reachability predicate x n null hence the property we want to verify is that if the precondition x n null holds at the entry point of function reverse then the same formula holds again at the return point the graph in figure an intermediate state of the heap that is observed during the execution of reverse when the function is applied to an acyclic list of length six this state is observed at the entry point of the while loop after the first three iterations of the loop an appropriate inductive loop invariant for a hoare proof of struct node struct node n int data list v n v n x curr v n v prev null n n v n v list reverse list x list prev curr succ curr x prev null while curr null succ curr n prev prev curr curr succ x prev return x figure c code for reversal of a linked list the graph a reachable program state at the entry point of the while loop in function reverse our verification goal must capture the situation depicted in figure but abstract from the concrete length of the list segments that is the loop invariant must express that the list segments pointed to by prev and curr are acyclic in fact only the former is strictly necessary for the proof and that the two list segments are disjoint an appropriate inductive loop invariant is given by the following formula prev n null curr n null prev n curr null n the term prev curr denotes the join point of the list segments n starting from prev and curr ie prev curr is the first node that is reachable from both prev and curr by following n pointer fields in the heap unless such a node does not exist in which case its n value is prev the formula prev curr null thus implies the disjointness of the two list segments note that this formula cannot be expressed in terms of the reachability predicate unless we allow universal quantification over heap nodes we next describe how to compute inductive loop invariants such as using our interpolation approach program verification given an unsatisfiable conjunction of formulas a b an interpolant for a b is a formula i such that i is implied by a the conjunction i b is unsatisfiable and i only about common symbols of a and b a popular approach to verification uses bounded model checking to generate infeasible error traces of the analyzed program these infeasible error traces are then translated into unsatisfiable formulas a b where a and b encode a partition of the trace into a prefix and suffix trace an interpolant i for a b then describes a set of program states that includes all states that are reachable by executing the prefix of the trace and only includes states from which no feasible execution of the suffix is possible the interpolant i is then used as a candidate invariant to refine the search for additional infeasible error traces this process is until a fixed point is reached ie until an inductive invariant has been computed that proves the program correct we illustrated this approach through an example the lefthand side of figure shows an error trace of function reverse that is obtained by unrolling the while loop three times the first and last assume statements correspond to the precondition respectively the postcondition of reverse this error trace is infeasible ie there is no execution that reaches the end of the trace note that a failing assume statement blocks an execution the righthand side of figure shows an encoding of this error trace into a firstorder formula using static single assignments note that the symbols · · · ·· and ·· · are interpreted that assume x n null x n null curr x curr x prev null prev null assume curr null a curr null succ succ prev n prev prev curr curr succ prev curr curr succ assume curr null curr null succ succ prev prev curr curr succ n prev prev curr curr succ assume curr null curr null succ b succ prev prev curr n prev prev curr curr succ assume curr null curr succ curr null x prev assume x n null x prev ¬x n null figure spurious error trace of function reverse and its encoding as a trace formula is they are given meaning by a specific firstorder theory here the theory of linked lists with reachability that we introduce in section the symbol · · · is interpreted as described above the symbol ·· denotes field dereference and the symbol ·· · field update the remaining symbols such as curr and n are uninterpreted we call this formula the trace formula of the error trace because the valuations of uninterpreted symbols that make the trace formula true exactly correspond to the feasible executions of the trace since the error trace is infeasible its trace formula is unsatisfiable we can now split the trace formula into two parts a and b say where a corresponds to the prefix of the trace up to the end of the first iteration of the while loop and b to the remainder of the trace this is depicted in figure since a b is unsatisfiable we can the two formulas a possible ground interpolant for this choice of a and b is prev n null curr n null prev n curr null note that this is a valid interpolant for a and b in particular it only about uninterpreted symbols that are common to both a and b further note that modulo renaming of variables formula exactly corresponds to the inductive loop invariant of reverse formula is also the exact interpolant that the prototype implementation of our interpolation framework produces for this particular conjunction a b we next describe through an example how our interpolation framework works in detail interpolation through an example our interpolation framework is parameterized by a theory extension this theory extension consists of the base theory for which we assume that a ground interpolation procedure exists and the symbols and axioms that extend the base theory in our example we consider the theory of linked lists with reachability where the base theory is the empty theory that is the base theory only supports uninterpreted constants and equality the extension symbols · are the symbols · · ·· and ·· · which we described earlier as well as the constrained reachability predicate · ·· · intuitively a fc b means that b is reachable via an f path from a that does not go through c in particular a f b is simply a shorthand for a fb b the meaning of the extension symbols is given by the extension axioms shown in figure of section all free variables appearing in these axioms are implicitly quantified note in particular how the constrained reachability predicate is used to define reachability with respect to an updated field f u v in terms of reachability with respect to field f in the following we denote this set of extension axioms by k interpolation reduces the computation of in in the theory extension to the problem of computing in in the base theory thus effectively building new procedures by existing ones the reduction works by the interpreted extension symbols into uninterpreted ones this is accomplished by generating finitely many ground instances kt of the extension axioms k for a finite set of terms t that is computed from the input formula a b the set of terms t is chosen such that the formula kt a b is already unsatisfiable in the base theory if in addition the set kt does not contain instances that mix symbols of a and b then kt can be divided into kt where contains only symbols of a and only symbols of b that is we obtain an instance a b of an interpolation problem for the base theory modulo uninterpreted functions where a a and b b we then compute a ground interpolant i for a b using the interpolation procedure for the base theory finally from i we a ground interpolant i for a b we illustrate this approach by computing an interpolant for the following formula a b c f a af c c f b ¬b f c ab note that this conjunction is unsatisfiable in the theory of linked lists with reachability because a implies that c lies on an f cycle while b implies that this is not the case from the formula a b we compute the sets of terms ta and tb that we use to instantiate the extension axioms in our example we use ta a c cf and tb b c cf figure then shows the resulting sets of ground clauses a a and b b note that we omit all instances of extension axioms that are not needed to prove of a b to see why the conjunction a b is unsatisfiable suppose that a c then clause in a implies cf c if on the other hand a c then clauses and imply a f c hence together with and this implies a fa cf cf f a if cf f a then implies cf f c if a fa cf then from follows again cf f c because otherwise clause gives a c which contradicts the assumption thus a implies the formula i c fc cf f c using similar reasoning we can show that i b is unsatisfiable since i only about common symbols of a and b it is an interpolant for a b and hence also for a b note that in the above derivation of the interpolant i all function and predicate symbols in a and b where treated as uninterpreted symbols ie we can compute i by applying an interpolation procedure for the theory of uninterpreted functions with equality to the formula a b we thus reduced the problem of computing ground interpolants in the theory of linked lists with reachability to computing ground interpolants in the combination of the base theory which is empty in our case with the theory of uninterpreted functions and equality the of this reduction approach is whether it is indeed always possible to compute sets of terms ta and tb from ab such that the reduced formula a b is an interpolation problem for the base theory that is to find ta and tb a c f a af c cf f a a f c cf f c a fc af a c a fa c a c c fa cf c a a f c a fa cf a fc cf cf f c a fa c c fa cf c fa cf c f a a fa cf cf f a b c f b ¬b f c c fb cf cf fb c cf f b c fc cf cf f c c f b cf f b c fc fc c cf c fb fc c b cf c c f b c b cf f c cf f b cf fc b b f c cf fb c c f b figure interpolation problem a b that is obtained from after instantiation of the extension axioms all function and predicate symbols are uninterpreted such that a b is unsatisfiable and a b do not share terms that are not already shared by a b it is here where our semantic completeness criterion of partial comes into play it allows us to systematically construct these sets of terms in the following we define the syntax and semantics of formulas we further recall the notions of partial structures and local theory extensions as defined in finally we define the problem that interpolation problems we are considering sorted firstorder logic we present our problem in sorted firstorder logic with equality a signature is a tuple s where s is a countable set of sorts and is a countable set of function symbols f with associated arity n and associated sort s × · · · × sn s with si s for all i n function symbols of arity are called constant symbols we assume that all signatures contain a sort bool s and equality symbols s of sort s × s bool for all sorts s s bool note that we generally treat predicate symbols of sort s sn as function symbols of sort s × × sn bool and we typically drop sort annotations from equality symbols terms are built as usual from the function symbols in and sorted variables taken from a infinite set x that is disjoint from a term t is said to be ground if no variable appears in t a atom a is a term of sort bool we use infix notation for atoms built from the equality symbol a formula f is defined via structural recursion as either one of a f f or x sf where a is a atom f and f are formulas and x x is a variable of sort s s we typically omit sort annotations from quantifiers if this causes no confusion we use syntactic sugar for boolean constants f f implications f f and existential quantification xf total and partial structures given a signature s a partial structure m is a function that maps each sort s s to a nonempty set m s and each function symbol f of sort s × · · · × sn s to a partial function m f m s × · · · × m sn m s we denote by m the support of m which is the union of the interpretation of all sorts in m we assume that all partial structures interpret the sort bool by the set of booleans we further assume that all structures m interpret each symbol s by the equality relation on m s a partial structure m is called total structure or simply structure if it all function symbols by total functions for a structure m where extends a signature with additional sorts and function symbols we write m for the structure obtained by restricting m to given partial structures m and n a weak embedding of m into n is a total injective function h m n such that for all f and a an m if m f is defined on a an then n f is defined on ha and hm f a an n f ha if h is a weak embedding between m and n then we denote this by h m n we say that m weakly into n if a weak embedding of m into n exists a weak embedding between total structures is simply called embedding if m weakly into n and m n we call m a partial of n which notation is denoted by m n given a total structure m and a variable assignment x m the evaluation tm of a term t in m is defined as usual for the evaluation of a ground term t in m we write just m t a quantified variable of sort s ranges over all elements of m s from the interpretation of terms the notions of satisfiability validity and entailment of atoms formulas clauses and sets of clauses in total structures are derived as usual in particular we use the standard interpretation of propositional connectives in classical logic we write m f if m satisfies f under where f is a formula a clause or a set of clauses we write m f if f is valid in m in this case we also call m a model of f the interpretation tm of a term t in a partial structure m is as for total structures except that if t f t tn for f then tm is undefined if either tim is undefined for some i or tm is not in the domain of m f we say that a partial structure m weakly satisfies a literal l under written m w l if i l is an atom a and either am or am is undefined or ii l is a atom ¬a and either am or am is undefined the notion of weak satisfiability is extended to sets of clauses as for total structures a clause c respectively a set of clauses is weakly valid in a partial structure m if m weakly satisfies c for all assignments we then call m a weak partial model of c theories and theory extensions a theory t over signature is simply a set of formulas we consider theories t defined as a set of formulas that are consequences of a given set of clauses k we call k the axioms of the theory t and we often identify k and t for a theory t and formulas clauses sets of clauses f and g we use f t g as a shorthand for t f g let s be a signature and assume that signature s se e extends by new sorts se and function symbols e we call the elements of e extension symbols and terms starting with extension symbols extension terms a theory t over is an extension of a theory t over if t is obtained from t by adding a set of universally quantified clauses k local theory extensions the following definition captures one specific variant of local theory extensions that is discussed together with other variants of this notion in and let t be a theory over signature s and t t k a theory extension of t with finite k and signature s se e in the following when we refer to a set of ground clauses g we assume they are over the signature c which extends with a set of new constant symbols c for a set of clauses k we denote by stk the set of all ground subterms that appear in k an embedding closure for t is a function associating with a set of universally quantified clauses k and a finite set of ground terms t a finite set t of ground terms such that i all ground subterms in k and t are in t ii is monotone ie for all sets of ground terms t t if t t then t t iii is idempotent ie for all sets of ground terms t t t iv is compatible with any map h between constants ie ht ht where h is extended to terms for a set of ground clauses g we denote by g the set let be the set of instances of k in which all extension terms are in g we say that t t k is a local theory extension if there exists an embedding closure such that for every finite set of ground clauses g t g iff t g theory extension t t k is a local theory extension if it is a local extension where is defined as t stk craig interpolation modulo theories we use a notion of craig interpolation modulo theories where interpreted symbols are considered to be shared between formulas let be a signature and t a theory let further c be the signature extended with fresh constant symbols c we say that a t is shared between two sets of ta and tb if all constants from c in t appear in both ta and tb ie we say that t is if c respectively t is if c we extend these notions from sets of terms ta and tb to clauses and sets of clauses as expected given a conjunction a b of a b that is unsatisfiable in t a craig interpolant for a b is a i such that a i is a consequence of a in t a t i b the conjunction of i and b is unsatisfiable in t i b t and c all terms in are shared between a and b we say that t admits ground interpolation if for all finite sets of clauses a and b with a b t there exists a finite set of clauses i that is a craig interpolant for a b interpolation we now present our framework for interpolation in the following when we refer to a theory extension t t k we denote by the signature of t and by e the signature of t where e se e are the extension symbols and sorts in the case of local theories the reduction approach to interpolation works as follows suppose we are given sets of ground clauses a and b over whose conjunction is unsatisfiable in t the goal is to compute a ground interpolant i for ab locality tells us that we can reduce the problem of checking of a b in t to checking of ka b a b in t here ka b is the finite set of instances of clauses in k that are obtained by replacing the free variables appearing below extension terms in k with ground subterms appearing in k a b such that all resulting ground extension terms in already appear in ab the instances can be partitioned into instances ka obtained by instantiating clauses in k with terms from a only instances kb obtained by instantiating clauses in k with terms from b only and mixed instances kc obtained by instantiating clauses in k with terms from both a and b if it is possible to find a finite set of terms that the mixed instances kc into sets of instances and instances then we obtain an interpolation problem for the base theory a b t here a and b are the results of applying expansion to eliminate the extension symbols from the sets of clauses ka a respectively kb b from a ground interpolant i for a b one can then easily a ground interpolant i for a b the question is whether it is indeed possible to separate the instances kc into and parts the result in proc input t t k theory extension ground interpolation procedure for t w closure for t a b sets of ground with a b t begin a a kw a b b b kw b a i b return i end figure generic interpolation procedure sufficient conditions on the theory extension to ensure this unfortunately these restrictions are quite in particular the axioms in k are required to be horn clauses of a specific form which rules out many interesting applications instead of such syntactic restrictions on the theory we first identify a stronger completeness condition on the theory extension than just locality and then relate this condition to a semantic condition on the models of the theory by combining these two results we obtain a framework of complete ground interpolation procedures for a more general class of theory extensions w theories to formalize the set of terms that is required to separate the mixed instances of a and b we introduce the notion of an closure an closure for a theory extension t t k is a function w associating with finite sets of ground terms ta and tb a finite set w ta tb of ground terms such that i all ground subterms in k and ta are in w ta tb ii w is monotone ie for all ta ta tb tb w ta tb w ta tb iii w is a closure ie w w ta tb w tb ta w ta tb iv w is compatible with any map h between constants satisfying hc hc for all constants c c that are not shared between ta and tb ie for any such h we require w ta tb and v w ta tb only contains terms for sets of ground clauses a b we write w a b as a shorthand for w sta for the remainder of this section w always refers to an closure we next identify the cases where the instances of extension axioms can be separated definition we say that a theory extension t t k is w if for all sets of ground clauses a and b t ab iff t kw a b a kw b a b from this definition we directly obtain the following theorem theorem if t t k is w then it is local where is defined by t w t t for all sets of ground terms t our generic interpolation procedure is described in figure procedure reduces the given interpolation problem a b for the theory extension t t k to an interpolation problem a b in t where is the theory of uninterpreted function symbols with equality for w theory extensions procedure is sound and complete provided that a complete ground interpolation procedure for t exists theorem let t t k be a theory extension such that t has a ground interpolation procedure all free variables in k appear below extension symbols and t t is w then is a ground interpolation procedure for t identifying w theories we now present our semantic criterion to identify w theories let us begin by the model theoretic notion of an for a theory t is a tuple ma mb mc where ma mb mc are models of t with ma mc mb and mc ma mb theory t has the property if for every ma mb mc of t there exists a model md of t and ha ma md and hb mb md such that hb mc if in addition where for any sets x y and function f with domain y f x f x x x then t is said to have the strong property note that t has the strong property iff for all models ma mb mc of t with ma mc mb and mc ma mb there exists a model md of t with ma md mb it is wellknown that and ground interpolation are strongly related theorem a theory t has ground interpolation iff t has the property theorem provides an effective tool to check whether a given theory admits ground interpolation unfortunately the property only tells us that ground interpolants exist not how to compute them other than by enumeration to this fact we define a related notion of partial that refers to partial instead of total models and weak instead of this notion allows us to characterize w theories together with theorem we then obtain a powerful model theoretic criterion that does not just allow us to prove the existence of ground interpolants but also tells us how to construct the interpolation procedure by applying theorem for a weak partial model m of a theory extension t t k we denote by t e m the set of terms t m f a an ai m f e m f a an defined where we treat the elements of the support m as constant symbols that are interpreted by themselves further we denote by the set of all weak partial models m of t in which all symbols in are totally defined and t m is finite let w be an closure for theory extension t t k a partial w for t t k is a tuple ma mb mc where i ma mb mc ii mc is a of both ma and mb iii mc ma mb vi both t ma and t mb are closed under w ie w t ma t mb t ma and w t mb t ma t mb and v t ma t mb t mc definition a theory extension t t k is said to have the partial property with respect to w if for all partial w ma mb mc there exists a model md of t and weak ha ma md and hb mb md such that hb mc to simplify we assume that the extension axioms k are in a specific normal form a clause c is called flat if no term that occurs in c below a predicate symbol or the symbol contains nested function symbols a clause c is called linear if i whenever a variable occurs in two terms in c that do not start with a predicate or the equality symbol the two terms are identical and if ii no such term contains two occurrences of the same variable note that every set of extension axioms can be syntactically transformed into one that is flat and linear intuitively a weak partial model m of a b corresponds to a partial w ma mb mc where ma is obtained from m by restricting m to the terms in a mb is obtained by restricting m to the terms in b and mc is obtained by restricting m to the common terms of a and b partial then tells us that we can always obtain a total model of a b from m this is what the following theorem says theorem let t t k be a theory extension with k linear and flat if t has the partial property with respect to w then t is w finally in order to apply theorem we need to be able to identify the cases where a ground interpolation procedure for the theory t exists one possibility is that we view t as the disjoint combination of the theories t and in this case we require that t is decidable has the strong property and is infinite since satisfies the same properties a ground interpolation procedure for the disjoint combination of the theories t and exists as follows from corollary corollary let t t k be a theory extension such that satisfiability of sets of ground clauses is decidable for t t is infinite t has the strong property all free variables in k appear below extension symbols and t t is w then is a ground interpolation procedure for t where is the ground interpolation procedure for the disjoint theory combination t alternatively we can view t as a local extension of t and use results from to obtain the procedure this yields different requirements on the base theory than the ones stated in corollary see the technical report for further details examples our framework of complete interpolation applies to many known local theory extensions including those described in in the following we discuss two nontrivial examples that go beyond the theories considered in theory of arrays with difference function our first example is the theory of arrays with difference function that has been recently investigated in we define this theory of arrays as a theory extension t that is parametric in its base theory t for this purpose we assume that the base theory t is over signature s with sorts index and elem in s and that t satisfies the assumptions of corollary examples of appropriate base theories are the empty theory in which case contains only equality predicates the theory of uninterpreted function symbols with equality and the theory of linear arithmetic interpreting the sort index as integers the theory extends t with a fresh sort array and extension symbols rd array × index elem wr array × index × elem array and array × array index the function symbols rd and wr stand for the usual array selection and update function whose meaning is given by read over write axioms rd wr a i e i e i j rd wr a i e j rd a j the function is defined as follows for any two distinct arrays a and b the term a b denotes an index at which a and b differ this is formalized by the following axiom a b rd a a b rd b a b note that this axiom is obtained by the axiom for arrays ab a b i rd a i rd b i where is the introduced function for the existentially quantified variable i the set of extension axioms of our theory of arrays consists of the and versions of the axioms and where a b i j and e are implicitly universally quantified variables for instance the and version of axiom is b wr a i e i j rd b j e it is wellknown that the standard theory of arrays ie the one given by axioms and does not admit ground interpolation we illustrate this through an example due to jhala consider the ground formulas a b wr a i e and b j k rd a j rd b j rd a k rd b k whose conjunction is unsatisfiable there exists no ground interpolant for a b that only contains the shared constants a b and the theory symbols wr and rd however as has been observed in such a ground interpolant can be constructed if one includes the difference function in the theory an appropriate ground interpolant for a b in the extended theory is given by b wr a a b rd b a b in fact the authors of have shown that including the function is sufficient for ground interpolation we now give an alternative proof of this result by showing that has the partial property this leads to an alternative interpolation procedure for theory that can be easily implemented on top of an existing interpolation procedure for the base theory in order to define an appropriate closure we need to generalize the example above that is we have to define in such a way that there exists no partial ma mb mc with arrays a and b that are shared between ma and mb and ma mb on the number of indices at which a and b differ to this end inductively define for any terms a and b of sort array and k the term a k b as follows a k b a if k and a k b wr a k b a k b b rd b a k b b for all k note that if in some two arrays a and b differ in exactly k positions then b a k b now define as follows tb let t a k b a b tb in let t rd a a b a b in t rd a i a i rd b i t where k is the number of terms of the form wr a i e in ta tb note that tb can be represented in space that is polynomial in the size of ta tb hence also a b b a is polynomial in a b for finite sets of ground clauses a b clearly satisfies properties i ii iv and v of closures to see that it also satisfies iii note that does not increase the number of terms of the form wr a i e lemma is an closure theorem the theory t has the partial property with respect to theory of linked lists with reachability our second example is an extension of theory of linked lists with reachability which is also at the core of the logic studied in this theory is useful for reasoning about the correctness of programs that manipulate data structures we show that neither original theory nor its variation in admit ground interpolation using counterexamples to the partial property for theory we then systematically develop an extension of the theory which admits ground interpolation as a result we obtain the first complete ground interpolation procedure for a nontrivial theory of linked data structures as in the previous example we define our theory of lists with reachability as a theory extension t that is parametric in its base theory t we require that the base theory is over the signature s with a sort addr in s and that t satisfies the assumptions of corollary theory extends the base theory with an additional sort field and extension symbols rd wr df jp lb and r the associated sorts are as follows rd field × addr addr wr field × addr × addr field df field × field addr jp lb field × addr × addr addr r field × addr × addr × addr bool before we present the axioms of the theory extension we define the meaning of the extension symbols in terms of a set of structures in which the interpretation of extension symbols is determined by the interpretation of the sorts addr and field we call the structures in heap models in a heap model m the sort addr represents a set of memory addresses and the sort field a set of pointer fields we use a memory model ie each field is represented as a function from addresses to addresses the base theory may eg interpret the sort addr as integers to model pointer arithmetic or it may leave this sort uninterpreted to obtain a more abstract memory model in a heap model the extension symbols rd and wr are interpreted as function application and function update respectively for notational convenience we write xf and f x y in formulas for terms of the form rd f x respectively wr f x y an atom rf a b c holds in a heap model m if there exists a path in the function graph by field f that addresses a and b and the shortest such path does not visit address c in formulas we write x fu y instead of rf x y u and we write x f y as a shorthand for x fy y note that a f b holds in a heap model m iff a and b are related by the reflexive transitive closure of f the function symbol jp is interpreted such that a b denotes the join point of addresses a and b ie a b is the first address on the f path starting in a that is also on the f path starting in b unless these paths are disjoint in the latter case we define a b a note that even if the f paths starting in a and b are not disjoint we might still have a b b a if the two f paths form a cycle in formulas we write x y as a shorthand for x y the function symbol lb is interpreted such that if b is reachable from a via f then a b is the last address before b on the shortest f path from a to b the function symbol df is interpreted as in the theory of arrays ie df f g denotes an address for which f and g take different values in case f and g are not the same functions m rd f a f a m wr f a b f a b m rf a b c iff a b d f d d m addr d c m df f g a m addr f a ga if f g m a b c iff a c d f d b d f b c f a c m a f b b if m rf a b f b figure restrictions on the interpretation of extension symbols in a heap model m formally for a binary relation p over a set x respectively a unary function p x x we denote by p the reflexive transitive closure of p the set of heap models is then defined as the set of all structures m such that i m is a model of t ii m field is the set of all functions m addr m addr iii the interpretation of the extension symbols in m satisfies the restrictions specified in figure and iv for every a m addr f m field the set b m addr a f b b f a is finite condition iv is not strictly necessary but it provides a more precise characterization of the models that we obtain from partial of we make the following simplifying assumption which restricts the set of input formulas that we consider assumption the set of uninterpreted constants c contains at most one constant of sort field assumption means that we will only consider input formulas ab in which all terms of sort field are related by a finite sequence of field writes that is there will be no models of such formulas in which the interpretation of two terms of sort field appearing in a b differ at more than n addresses where n is the number of field writes in a b the extension axioms are the set of clauses that is obtained by computing the conjunctive normal form of the axioms given in figure and and the resulting set of clauses the following lemma states that the resulting theory extension is a sound axiomatization of heap models lemma all heap models are models of as we shall see later the extension axioms are also sufficient to fully characterize heap models ie every ground formula that is satisfiable modulo is also satisfiable in some heap model however let us first explain why the theory without the function jp does not have ground interpolation to this end consider the situation illustrated in figure the graphs ma mb and mc partial heap models where the dashed edges denote binary reachability x f y transitive and reflexive edges are omitted for readability the structures ma and mb are almost identical they only differ in the order in which the list segments starting in c and c join the list segment starting in c in ma the segment of c joins before the one of c and in mb it is the other way around we express ma and mb in terms of formulas a and b as follows a b c fc a c fc a a f a c fa a a f c a a c fc b c fc b b f b c fb b b f c b b reflexive x fu x step x fu xf x u xf x x f y x y x fx y x y reach x fu y x f y linear x f y x fy u x fu y linear x fu y x fv z x fu z z fu y x fv y y fv z transitive x fu y y fu z x fu z transitive x fz y y fz u y f z x fu y join x f x f y join x f z y f z y f x f y join x f z y f z x fz x f y join y f x f y x f y x x y x yf y x y x fw y x fu y x fw u v fw y v fu y u w readwrite xf x y y readwrite x y yf x z yf f g df f gf df f gg figure axioms of theory extension the conjunction a b is unsatisfiable because a and b do not agree on the order of the join points of the list segments an appropriate ground interpolant for a b is given by f c f c f c all other ground interpolants for a b also rely on the join function hence if we drop the join function from the theory we lose ground interpolation this is also reflected in a violation of the property if we drop joins the models ma and mb have a common mc which we also in figure there is no model md in which both ma and mb can be embedded while preserving the common mc the function lb plays a similar role than jp in that it is also needed for the completeness of ground interpolation a corresponding counterexample to partial can be found in the extended version of this paper we omit further details here because the function lb appears to be of less practical importance than the join function although the full theory admits ground interpolation it is still difficult to an closure that allows us to prove partial for this theory we illustrate this using the unsatisfiable formula in section one ground interpolant for a b is cf f c which expresses that c lies on c f a f f c f a f c c c f c f f f c c f c f b c f b f f c c ma mc mb figure an ma mc mb of the theory of linked lists without join that witnesses a violation of a cycle in order to prove the partial property for theory we have to ensure that the shared of every partial already contains all information about which of the shared terms c lie on a cycle since we can express this using the formula cf f c we may attempt to define the closure such that for every shared field f and every shared address c defined in the common also cf is defined however since cf is again shared such an operator would fail to satisfy condition iii of closures we can avoid this problem by further extending with an additional predicate symbol cy field × addr bool such that c holds iff cf f c the corresponding extension axioms defining cy are as follows cycle x f y y f x x x y cycle x x f y y f x note that in these axioms we do not use cf to define c which avoids the problem with the definition of the closure mentioned above we denote by the set of extension axioms obtained by adding these axioms to and we denote by the resulting theory extension t to define the closure for we first define the terms f k g for all terms f g of sort field and k as in the case of the array theory except that we replace array reads by field reads and array writes by field writes the closure for is then defined as follows tb let t f k g f g tb in let t df f gf f g in let t t af f a ag t in let t t a bf a bf t in let t t a f b a b f t shared with tb in let t t a fc b a b c f t in let t t a f a t shared with tb in t where k is the number of terms of the form f a b in a bf denotes a bf if lb does not appear in a or else it denotes a and similarly a f b denotes a f b if no join appears in a and b or else a the intermediate set of terms t in the definition of tb is similar to the set of terms computed by for the theory of arrays the set of terms t ensures that the joins of all shared terms are defined note that in models of we ff f ff f have for all a b c and f a b c a c or a b c b c ff f ff f and similarly a b c a b or a b c a c because of this property and assumption we can avoid the construction of terms with nested occurrences of joins the set t ensures that the reachability predicate is fully defined in all partial models finally t ensures that the predicate cy is defined for all shared terms lemma is an closure we can now prove that theory has the partial property in fact we can prove a slightly stronger statement lemma for every partial ma mb mc of there exists a total model md of and weak ha ma md and hb mb md such that moreover is isomorphic to a heap model theorem the theory t has the partial property with respect to theorem does not just give us a complete ground interpolation procedure for but also for this is because we can always rewrite atoms of the form c in interpolants for theory into atoms cf f c obtaining an interpolant for corollary theory admits ground interpolation finally we can show that satisfiability of ground formulas modulo is equivalent to satisfiability of ground formulas modulo heap models this is a consequence of lemma and lemma theorem let g be a finite set of ground then g iff m g for all m note that the number of terms in tb is polynomial in the size of ta tb and hence so is the number of generated instances of extension axioms together with theorem this implies that satisfiability of ground formulas modulo is decidable in np provided t is also decidable in np combining interpolation and abstraction we now turn towards more practical concerns a common problem in algorithms is that interpolants are not unique often the interpolation procedure produces interpolants that are not useful for a specific application this may cause eg that the refinement loop of a software model checker diverges because the generated interpolants do not sufficiently abstract from the infeasible error traces to illustrate this problem consider the program shown in figure the function takes two lists x and y as input and them by first traversing x and then the pointer of the last node of x to y a second while loop then traverses x again to check whether y is reachable after the concatenation suppose we want to use verification to check that the assert statement in never fails the righthand side of figure shows the trace formula for a spurious error trace of which is obtained by unrolling both loops twice the trace formula is unsatisfiable hence we can compute an interpolant for the indicated choice of a b one valid interpolant is as follows null y null this interpolant is rather useless for obtaining an inductive invariant that allows us to prove our verification goal the interpolant only rules out the one given error trace and fails to abstract from its ie the length of the traversed list we would rather like to obtain the alternative interpolant x n y which is the inductive loop invariant we are but how can we ensure that the void list x list y list curr prev prev null curr x while curr null prev curr curr if prev null x y else prev n y curr x while curr null curr y curr assert curr y prev null curr x curr null prev curr curr a curr null prev curr curr curr null prev null n y curr x curr null curr y curr b curr curr null y curr curr null curr y curr y figure c code for concatenation of two lists the second while loop checks whether y is reachable from x after the concatenation the righthand side shows the trace formula for an infeasible error trace that is obtained by unfolding both while loops twice interpolation procedure finds the right interpolant what accounts for a good interpolant often depends on the concrete application it is therefore difficult to generic strategies that can be into the interpolation procedure our approach enables the user of the interpolation procedure to domainspecific knowledge that helps to guide the proof search and improves the quality of the produced interpolants this can be done as follows note that a partial model m can be thought of as a symbolic representation of a set of total models namely the set of all models into which m weakly in fact for many local theory extensions we can represent a ground formula a as a finite set of partial models each of which is represented as a finite set of ground unit clauses we can then guide the interpolation procedure as follows instead of a b directly we enumerate partial models ma of a which we one by one with b however before we compute the interpolant of ma b for a given partial model ma we first apply a userdefined abstraction function that ma by certain clauses for instance in the case of the theory of we may want to drop all clauses containing the function symbol for field dereference from partial models and only keep information about reachability and joins this idea of combining interpolation and abstraction is realized in procedure given in figure which refines our earlier procedure in figure procedure takes as additional arguments the userdefined abstraction function and a procedure that is able to generate partial models for satisfiable formulas in the theory t the while loop the partial models of a in each iteration we only consider partial models that are not yet subsumed by the already computed interpolants i this ensures that only few partial models have to be considered in practice the conditional statement in the body of the while loop guarantees that the interpolation procedure back to the full partial model ma in the cases where the abstraction function is too and does not preserve of ma b procedure enables us to easily incorporate domainspecific abstraction and widening techniques proc input t t k theory extension ground interpolation procedure for t model generation procedure for t w closure for t abstraction function for weak partial models a b sets of ground with a b t begin i while a kw a b do ma a kw a b a ma kw ma b b b kw b ma if a b then a ma kw ma b b b kw b ma i i b return i end figure interpolation procedure with userdefined abstraction of partial models into the interpolation procedure while still treating the underlying interpolation procedure for the base theory as a black box the ability of modern smt solvers to generate models for satisfiable formulas makes it easy to implement this approach implementation and evaluation we have implemented our framework in a prototype tool and instantiated it for the theory of linked lists with reachability that we presented in section the prototype is written in ocaml it implements a variation of the algorithm presented in figure we use the smt solver z v for the generation of partial models and for interpolation of formulas in the base theory communication with both provers is done via their interfaces the difference between the implementation and the algorithm in figure is that we use the incremental solving capability of the smt solver to get a more finegrained abstraction of partial models instead of immediately back to the full partial model ma whenever the abstract partial model is too weak to prove we sort the clauses of ma in a particular order and then push them one by one on the assertion stack of the solver each time we push a new clause onto the stack we check whether the conjunction of the stack with b is still satisfiable once it becomes unsatisfiable we compute the interpolant the order in which the clauses of the partial model are pushed is determined by a weight associated with each clause where clauses are considered first the weight function encodes the domainspecific knowledge that the proof search of the solver in our implementation we have chosen the weight function such that weight is given to clauses that contain dereferences of pointer fields this makes it more likely that the computed interpolants abstract from the length of the lists the number of generated instances of extension axioms is polynomial in the size of the input formulas which means that the underlying decision problem remains in np however in practice the eager instantiation approach can still be a performance with of clauses generated even for small examples we therefore implemented several optimizations to reduce the number benchmark reverse delete ma inst time s table summary of experiments the columns list the benchmark name the number of loop in the error trace the number of generated partial models for a the number of generated instances of extension axioms and the total computation time of instances of axioms that we generate first we compute the congruence closure for the terms appearing in the original input formula and then only instantiate axioms by selecting one representative term per congruence class we have found this to work particularly well for trace formulas which typically contain many equalities second we use a more lazy instantiation approach where we first compute a subset of the terms in the closure that is likely to be sufficient for proving for example in our experiments we never needed to generate instances with terms that contain the df function apart from these obvious optimizations our instance generation procedure is still rather naive to evaluate the feasibility of our approach we have used our implementation to automatically infer loop invariants for verifying properties of simple programs in particular we checked functional correctness properties and whether certain shape invariants are preserved for this purpose we manually generated spurious error traces from the considered programs by unrolling their loops a few times our prototype accepts such error traces as input and converts them into trace formulas which are then our experiments where on a linux with a processor and gb ram table shows the summary of our experiments in all cases the obtained interpolant was an inductive loop invariant of the program and strong enough to prove the program correct roughly of the running time is spent on io with the provers however the main of the implementation is the eager instantiation of extension axioms we believe that the running times can be significantly improved by using more sophisticated instantiation approaches such as which instantiate axioms incrementally related work our notion of partial is closely related to the strong property whose role in ground interpolation for disjoint theory combinations has been recently studied our use of properties is orthogonal to as we consider theory extensions rather than disjoint theory combinations in a sense partial is the adaptation of the weak condition in to the case of interpolation our approach can thus be thought of as the of the two orthogonal approaches described in and note that neither of the interpolation techniques presented in and can be applied directly to the theory of lists considered in this paper the approach in is restricted to extension axioms of a very specific syntactic form horn clauses in which all predicate symbols are binary and where additional guard constraints on the quantified variables apply all three restrictions are violated by the axioms of the list theory the approach in could be used in principle to obtain an interpolation procedure for the combination of a theory of lists with uninterpreted heap nodes and eg the theory of linear integer arithmetic for interpreting heap nodes as addresses however the technique in assumes that interpolation procedures for the component theories already exist there is no interpolation procedure for the list theory component to start with hence the combination technique of cannot be applied other approaches to interpolation that are less closely related include which is based on quantifier elimination ground interpolation procedures for specific theories have been developed eg for linear arithmetic over reals and integers uninterpreted functions with equality functional lists as well as combinations of these theories these are the procedures that our approach builds on we discussed two specific theories for which ground interpolation reduces to these existing procedures the theory of arrays with difference functions and the theory of with reachability extended with join we believe that our approach applies to many other theory extensions that are of importance in program verification such as our theory of imperative trees interpolation approaches that use automated theorem provers have been studied eg in unlike our approach these methods target undecidable fragments of firstorder logic and infer quantified interpolants sometimes such quantified interpolants are needed to obtain inductive invariants we can use our approach to infer quantified interpolants by applying techniques explored in one interesting observation is that these quantified interpolants themselves often constitute local theory extensions and can therefore be treated systematically by our framework if they become part of subsequent interpolation problems to out knowledge version of the theorem prover is the only other system that has been used to infer shape invariants of data structures unlike our theory of axiomatization of reachability predicates is incomplete recent works have explored techniques to influence the quality of computed interpolants eg by reducing the size of proofs from which interpolants are generated restricting the language in which interpolants can be expressed or by controlling the interpolant strength our technique of the proof search of the interpolation procedure through userdefined abstraction functions is orthogonal to these approaches in spirit it is most closely related to the key difference is that we do not need to modify the underlying interpolation procedure which would our modular approach to interpolation the idea of using the ability of smt solvers to generate models for abstraction has been previously explored eg in whether the approach of combining interpolation and abstraction can be explained more in terms of abstract interpretation eg in the spirit of remains a question for future research conclusion we have presented a new interpolation framework that enables the modular construction of ground interpolation procedures for theories we introduced the semantic notion of partial to systematically identify and construct theories for which our framework yields complete interpolation procedures we gave examples of both new and existing theories to which our framework applies using a prototype implementation we demonstrated that our framework enables new applications of algorithms in program verification therefore we see this work as a starting point for a new line of research that studies efficient interpolation procedures for applications in program verification acknowledgments this work was supported in part by the european research advanced grant and by the science project sn references f r s s and n lazy abstraction with interpolants for arrays in volume of lncs pages ­ springer p properties and interpolation theorems for equational theories algebra ­ m and k r m leino to goto where no statement has before in volume of lncs pages ­ c a and c the standard version d t a henzinger and g lazy shape analysis in cav volume of lncs pages ­ springer d d and r majumdar interpolation for in cav volume of lncs pages ­ r proving pointer programs in hoare logic in volume of lncs pages ­ springer a d p and t an sequent calculus for quantifierfree presburger arithmetic j reasoning ­ a d p and t beyond quantifierfree interpolation in extensions of presburger arithmetic in volume of lncs pages ­ springer r s and s quantifierfree interpolation for a theory of arrays in volume of pages ­ r s and s from strong to modularity of quantifierfree interpolation in volume of lncs pages ­ springer p cousot r cousot and l the reduced product of abstract domains and the combination of decision procedures in volume of lncs pages ­ springer w craig three uses of the theorem in relating model theory and proof theory the journal of symbolic logic ­ l de and n z an efficient smt solver in tacas pages ­ k a b and h a model checker for concurrent systems in tacas volume of lncs pages ­ springer v d m and g interpolant strength in volume of lncs pages ­ springer e m and t error invariants in fm volume of lncs pages ­ springer jc and c the platform for deductive program verification in cav volume of lncs pages ­ springer a a j s and c ground interpolation for the theory of equality in tacas volume of lncs pages ­ springer y ge and l m de complete instantiation for quantified formulas in modulo theories in cav volume of lncs pages ­ springer a s and c ground interpolation for combined theories in volume of lecture notes in computer science pages ­ springer a a practical approach to satisfiability modulo linear integer arithmetic ­ january a t t h le and r efficient interpolant generation in satisfiability modulo linear integer arithmetic in tacas volume of lncs pages ­ springer m j and a podelski nested interpolants in popl pages ­ acm t a henzinger r jhala r majumdar and k l abstractions from proofs in st popl k l and a interpolation and symbol elimination in in volume of lncs pages ­ springer k l and a in the grey area of proofs in popl pages ­ acm c s and v on local reasoning in verification in tacas pages ­ s incremental instance generation in local reasoning in cav volume of lncs pages ­ springer r jhala and k l a practical and complete approach to predicate refinement in tacas volume of lncs pages ­ springer r jhala and k l transition relation approximation logical methods in computer science b universal relational systems math ­ d r majumdar and c g interpolation for data structures in pages ­ acm d and g software verification with in cav volume of lncs pages ­ springer s k and s qadeer back to the future precise program verification using smt solvers in popl pages ­ acm j towards a mathematical science of computation in ifip pages ­ k l interpolation and model checking in cav volume of lncs pages ­ springer k l an theorem prover theor comput sci ­ k l lazy abstraction with interpolants in cav volume of lncs pages ­ springer k l quantified invariant generation using an saturation prover in tacas volume of lncs pages ­ springer g nelson verifying reachability invariants of linked structures in popl pages ­ acm a podelski and t counterexampleguided focus in popl pages ­ acm t w reps s sagiv and g symbolic implementation of the best transformer in volume of lncs pages ­ springer a rybalchenko and v constraint solving for interpolation in volume of lncs pages ­ springer m sagiv t reps and r parametric shape analysis via valued logic acm toplas ­ v reasoning in local theory extensions in pages ­ v interpolation in local theory extensions logical methods in computer science n and t complete interpolation technical report tr new york university t m and v an efficient decision procedure for imperative tree data structures in volume of lncs pages ­ springer g and m a combination method for generating interpolants in volume of lncs pages ­ 