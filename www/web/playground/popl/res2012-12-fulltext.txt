symbolic finite state transducers algorithms and applications microsoft research david microsoft research university of benjamin microsoft research microsoft research abstract finite automata and finite transducers are used in a wide range of applications in software engineering from regular expressions to specification languages we extend these classic objects with symbolic alphabets represented as parametric theories potentially infinite alphabets makes this representation strictly more general and than classical finite transducers and automata over strings despite this the main operations including composition checking that a transducer is singlevalued and equivalence checking for singlevalued symbolic finite transducers are effective given a decision procedure for the background theory we provide novel algorithms for these operations and extend composition to symbolic transducers augmented with registers our base algorithms are in that they are therefore we also supply a separate model generation algorithm that can quickly find counterexamples in the case two symbolic finite transducers are not equivalent the algorithms give rise to a complete decidable algebra of symbolic transducers unlike previous work we do not need any syntactic restriction of the formulas on the transitions only a decision procedure in practice we recent advances in satisfiability modulo theory smt solvers we demonstrate our techniques on four case studies covering a wide range of applications our techniques can synthesize string in of bytes in roughly a and we find that our new encodings significantly previous techniques in and speed of analysis categories and subject descriptors d software engineering verification f mathematical logic and formal languages mathematical logic work done while the author visited microsoft research permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm general terms algorithms theory verification keywords automata composition equivalence smt introduction finite automata are used in a wide range of applications in software engineering from regular expressions to specification languages nearly every programmer has used a regular expression at one point or another to parse or manipulate text finite transducers are an extension of finite automata to model functions on lists of elements which in turn have uses in fields as as computational and testing while this formalism is of practical use it from certain in the presence of large alphabets they can up in the number of transitions as each transition can encode only one choice of element from the alphabet furthermore the most common forms cannot handle infinite alphabets symbolic finite transducers sfts are an extension of traditional transducers that attempt to solve these problems by allowing transitions to be labeled with arbitrary formulas in a specified theory while the concept is straightforward traditional algorithms for deciding composition equivalence and other properties of finite transducers do not immediately generalize to the symbolic case in particular previous work on symbolic finite transducers have needed to impose restrictions on character theories to achieve decidable analysis our work breaks this barrier and allows for arbitrary formulas from any decidable background theory in practice we the recent progress in satisfiability modulo theory smt solvers to provide this decision procedure we find that our algorithms are fast when used with z a state of the art smt solver the restriction we do make on sfts is a semantic one that the sft is singlevalued this restriction is needed because equivalence is undecidable even for standard finite transducers the property is decidable for symbolic finite transducers this gives us a way to check transducers arising from practical applications before applying our algorithms while it was previously known that equivalence was decidable for singlevalued finite transducers again it does not immediately follow that equivalence should be decidable for singlevalued symbolic finite transducers because typically finite state transducers streaming transducers symbolic finite transducers symbolic transducers effective closure under composition closed closed for finite alphabets closed proposition closed extension of proposition equivalence undecidable in general decidable for singlevalued case and case decidable decidable for singlevalued case theorem undecidable already for the singlevalued case through direct encoding of counter machines alphabet finite set of elements comparable with equality total orders infinite any decidable theory any decidable theory figure summary of decidability results the bottom two rows summarize our contributions case study image location privacy section feature st representation arithmetic sft composition for program analysis module theory stream manipulating programs figure summary of case studies even very restricted extensions of finite automata and finite transducers lead to undecidability of the core decision problems in fact our proof requires a separation between the automata theoretic parts of our algorithms and the use of the decision procedure our algorithm for deciding equivalence is while we can determine that two symbolic finite automata are not equivalent our proof does not provide a way to find a counterexample fortunately we provide a separate model generation procedure that can find counterexamples once it is known that two automata are not equivalent figure summarizes known results about finite state transducers over sequences and extensions focusing on the key properties studied in this paper namely functional compositionality decidability of equivalence and the role of the alphabet in order to place our contributions in a clear context in section we compare our main techniques to closely related techniques used for streaming transducers section describes further related work including work on extending automata to trees applications section presents four case studies in different areas our first case study extends previous work in using symbolic finite transducers to model web sanitization functions our techniques allow the addition of register variables which enable encoding a sanitizer that could not be handled efficiently by previous symbolic approaches our second case study shows an application to analysis of javascript found on the web our third and fourth case studies additional theories beyond strings figure summarizes how each case study reflects a novel feature of our work in addition to these case studies finite transducers have been employed in other areas such as analysis of web sanitization frameworks detection and natural language processing our work immediately applies to these application domains contributions our contributions are the following · we present novel algorithms for composition and equivalence checking of symbolic finite transducers our algorithms unlike previous work make no restrictions on the formulae used in the transducers we require only a decision procedure for the background theory · we show that the property of symbolic transducers is decidable this gives rise to a decidable complete algebra of symbolic transducers the impact is that singlevalued symbolic transducers can now be first class objects for constructing program analyses · we present four case studies that demonstrate how our new algorithms enable new applications we demonstrate that our algorithms not only terminate but that they run quickly in practice for problem instances of interest paper organization the rest of this paper is structured as follows in section we provide an introduction to symbolic finite state transducers section describes the core algorithms section provides four detailed case studies of transducer use finally we discuss closely related work in section and conclude in section symbolic finite transducers we now formally define symbolic finite transducers we give examples of how these objects model program behavior and we define analyses that may be on such transducers we assume a background structure that has an effectively enumerable countable carrier set or background universe u and is equipped with a language of function and relation symbols with fixed interpretations we use and to denote types and we write u for the corresponding of elements of type as a convention we abbreviate u by and u by because these symbols are used frequently the boolean type is b with ub t f and the integer type is z terms and formulas are defined by induction over the background language and are assumed to be welltyped the type of a term t is indicated by t terms of type b or boolean terms are treated as formulas ie no distinction is made between formulas and boolean terms all elements in u are also assumed to have corresponding constants in the background language and we use elements in u also as constants the set of free variables in a term t is denoted by t is closed when and closed terms t have semantics t over the background structure substitution of a variable x in t by a term u is denoted by a term f is an expression of the form xt where x is a variable and t is a term such that x the type of f is f denotes the function that maps a to as a convention we use f and g to stand for terms a term of type b is called a predicate we write and for predicates and for a we write a for a t we often treat as a subset of given a term f xt and a term u f u stands for ie we assume implicit reduction a predicate is unsatisfiable when satisfiable otherwise the following is a key notion in the paper two terms f g are equivalent relative to a predicate denoted f g when f g is unsatisfiable where f g def xx f x gx is called the difference predicate of f and g relative to definition a label theory for is associated with an effectively enumerable set of terms of type and an effectively enumerable set of predicates that is effectively closed under boolean operations and relative difference effective closure under boolean operations in definition means that and ¬ an important and direct consequence is the following g f x gx in particular it is not possible to express relative equivalence of terms directly other than through of a difference predicate this is important in order to maintain our decidability results while making minimal assumptions about the label theory in our use of label theories below difference predicates play a central role and are always used in a positive context ie not as above a label theory is decidable when satisfiability for is decidable we assume an effective witness function for a predicate such that if then witness example as an example of a decidable label theory for z × z z consider the combined theory of pairs and quantifierfree integer linear arithmetic suppose and are the projection functions from pairs let f be x x let g be xx x and let be xx x then f and g are equivalent relative to because f g is unsatisfiable ie xx x x x x is unsatisfiable given a set x we write x for the kleene closure of x similarly is the type of sequences over a sequence of length k is denoted either by x xk or x with xi as the ith element of x for i x next we describe an extension of finite state transducers through a symbolic representation of labels the advantage of the extension is and modularity with respect to any given label theory it naturally the finite state transition graph from the label theory definition a symbolic finite transducer sft over is a tuple q q f r where q is a finite set of states q q is the initial state f q is the set of final states and r is a set of rules p f q where p q q is a predicate and f is a a sequence of terms over a given label theory for we use the more intuitive notation p f a q for a rule p f q ra and call its guard we omit the index a when a is clear from the context we treat f as a function x f x f kx where k f we lift the definition of relative equivalence of terms to sequences f and g of terms f g iff f g and for all i i f f i gi we use the notation of rules to also denote concrete transitions when the is clear for p q qa a and b p ab a q if for some p f a q r a b f a ie the transition p ab q is an instance of a rule concatenation of two sequences seq and seq is denoted seq · seq definition for a and b p ab a q denotes the reachability relation there exists a path of transitions from p to q in a with input sequence a and output sequence b let n a when there exist bi such that b b · b · · · bn and p p ab p ab p · · · pn pn q we let p a p for all p qa definition the of a denoted ta is the following function from to def b q fa qa ab q is viewed as that b the binary relation or subset iff b the domain of a is d a def a the following subclass of sfts captures that behave as partial functions from to definition a a is singlevalued when for all a sufficient condition for is determinism definition a is deterministic when for all p f a q and p g a r if then q r and f g in terms of concrete transitions determinism of a means that if p ab a q and p q then b q b q it follows by induction over a for a that if p ab a q then b q is unique for the given p and a in particular when p qa and q fa and thus a is singlevalued determinism is however not a necessary condition for as is illustrated below in the following examples all sfts are singlevalued the first example illustrates a few simple functional list transformations expressed as deterministic sfts that illustrate how global properties of sfts depend on the theory of labels example let the input type and the output type be z all sfts have a single state here predicates and terms are terms in integer linear arithmetic all elements by increment adds to each element all from the input p p q q r xx r r r properties such as commutativity and idempotence of sfts depend on the theory of labels for example whether and commute or whether is idempotent depend on properties of integer addition and multiplication none of the examples can be expressed as traditional finite state transducers over a finite alphabet our results about composition and equivalence checking discussed below allow us to effectively establish such properties modulo decidability of a given label theory the following example illustrates a common string transformation where the use of nondeterministic sfts is essential example suppose that the following c code is intended to implement a function that extracts from a given input stream of characters all of the form x where x for example sf int q char c char foreach char x in input if q if x q else q else if q if x q else q else if q if x yield return yield return c yield return q c x note that the variable q keeps track of the relative position in the pattern x and c records the previous character the corresponding singlevalued sft is xx x q q x x q x x x q x q is nondeterministic because there are two rules from q to q and q respectively yielding different outputs for the same input if the characters are represented as integers then a deterministic version of does not exists and if the characters are represented as bit that corresponds precisely to the standard encoding of characters in c then the size of the equivalent deterministic sft is times larger example below explains how is constructed from the c code sft algorithms in this section we study algorithms for composition and equivalence of sfts first we show that sfts are effectively closed under composition next we provide an efficient algorithm for singlevalued equality of sfts modulo a decidable theory of labels finally we introduce an algebra of sfts that enables a variety of practically useful decision problems such as deciding and deciding commutativity and idempotence of singlevalued sfts we omit s in figures for a more compact view composition of sfts given two t and t t t denotes the following function t t def b t a at b this definition follows the convention in notice that applies first t then t contrary to how is used for standard function composition note also that is trivially preserved by composition we say that label theories for and are composable if there is a label theory for such that · if f and g are a terms then x is a valid term in · if is a predicate and f is a term then xf x is a valid predicate in proposition let a and b be sfts over composable label theories then there exists an sft a b that is obtained effectively from a and b such that the algorithm for a b can be implemented with a dfs procedure that by assuming decidability of the label theory eliminates incrementally all composed rules that have unsatisfiable guards and finally eliminates all deadlock states states from which no final state is reachable equivalence of sfts we introduce an algorithm for deciding equivalence of singlevalued sfts while general equivalence of finite state transducers is undecidable the undecidability is caused by allowing many different outputs for a given input singlevalued transducers furthermore correspond closely to functional transformations over lists computed by concrete programs as illustrated above this does not in general rule out nondeterministic sfts sfts a and b are equivalent a b when ta tb deciding a b reduces to two independent tasks domain equivalence da db partial equivalence a a symbolic finite automaton or sfa is an sft all of whose outputs are empty let da denote the sfa obtained from the sft a by replacing all outputs by then da db iff da db equivalence of sfas is decidable over decidable label theories the decidability of sfa equivalence depends on the assumption that the label theory is closed under this assumption is not needed for partial equivalence for developing a decision procedure for partial equivalence of singlevalued sfts we use the following weak form of partial equivalence singlevalued equality or equality a b a b c b c b c proposition a is singlevalued iff a a if a and b are singlevalued then a b iff a and b are partially equivalent singlevalued equality of two sfts a and b may fail for two reasons there is an input a and outputs b and c such that a has a with b b c a has a with b b c and for some position i i b bi ci we introduce the following basic product construction of sfts as a generalization of the product of sfas the product construction is most effectively realized by using a dfs procedure note that the product of sfts is a sfts are not closed under product definition the product of sfts a and b denoted a × b is defined as the least fixpoint of pair states q qa × qb and rules under the following conditions · qa qb q · if p p q p f a q and p g b q then q q q and p p fg q q provided that all states from which fa × fb is not reachable are eliminated from a × b example consider the sft in example then the product has rules p p ff q q for all rules p f q and no other rules due to elimination of eg q q is a because the guard of the only possible rule q q q q from q q is unsatisfiable let da × b denote the set of inputs that are accepted by the product it follows from the product construction that da × b da db the reachability relation is lifted to a × b and the following holds for p p p q q q p abc q p ab a q p ac b q we omit the index a × b when it is clear from the context for q and k define the offset relation q k def a b c qa abc q k b c the intuition behind q k is that for some common input a there exists an output b from a that is either of an output c from b with at product state q when k or behind when k the following lemma is used to detect lemma if there exists q and m n such that q m and q n then a has a with b moreover a has a with b iff there exists q and m such that q m lemma suggests an efficient dfs algorithm to detect if a exists and otherwise computes the fixed offset such that p in order to decide if a exists between a and b we first assume that a and b have no and assume that is defined and for p we say that × is a of a product state p when the following holds a b c b c qa p it follows that if otherwise lemma if a b then each product state in has a fixed proof assume a b suppose by way of contradiction that there exists p with two distinct and by lemma we know that and and either or suppose the case is thus or else the are identical by definition of there exist a b c a b c such that b c b c qa p qa p since p is not a there exist a b c and qf such that p abc qf it follows from a b that b · · b · b c · c · a b · · b · a c · c · a b · c and since b c and b c it follows that · b c and · b c that lemma can be used to check for as follows in a depthfirst manner compute for every state in the product the current if the state gets with a different then a b example the product × in example has trivially no because offsets of all product states are and thus of all product states are finally assuming a × b has no and each product state p has a fixed p then p is when for all rules p fg q the maximal prefixes of · f and · g are equivalent relative to note when with a sequence f of terms of type we assume an implicit conversion of to x let k min · f · g k aa · f ja · j we say that p is a if p is not verifying absence of is a linear search over rules in a × b that verifies the condition for each rule lemma if a × b has fixed and no then a b contains a proof assume that a × b is as stated existence of a p implies by definition that there exists a since p is both reachable and not a assume a b we show that there exists a since a and b have no there exist a b c such that b c b c and there exists a position i i b such that bi ci fix i to be the smallest such position so there exists a a b b c p q such that a · a is a prefix of a b · · b is a prefix of b b · · c is a prefix of c and qa p abc q where and · bj · cj with j i b so there exists a rule p fg q such that a but · f ja · thus p is a because does not hold the following theorem describes precisely the assumptions under which equality of sfts is decidable theorem if a and b are sfts over a decidable label theory then a b is decidable moreover if the complexity of the label theory for instances of size m is f m then the complexity of a b is on · f m where n is the number of rules and m the size of the rules proof by using lemmas and deciding satisfiability of is needed in the construction of a × b deciding f g is needed for deciding validity of the formula in lemma we need to decide if f is constant relative to a satisfiable formula decide if f f witness lemmas and are combined into a single dfs algorithm shown in figure that equality of sfts over a decidable label theory line corresponds a b def c a × b q qc s while s p qp foreach p f g q rc p u v · f · g if q fc u v return f if u v if v i ui vi return f w uv uu c if w c q qq c return f if q s qq c if u v to the case u v return t figure equality algorithm for sfts to detection of a final state with nonzero offset by using lemma line corresponds to use of lemma line corresponds to use of lemma line corresponds to use of of lemma the number of iterations of the loop as well as in the product construction is bounded by ra · rb the algorithm uses satisfiability checks during product construction in line and in the loop in lines and in line the number of checks is linear in the length of the output sequence v decide if there exists i i v and is satisfiable similarly for line the complexity follows theorem shows that complexity of equality of sfts depends on the complexity of the label theory for example if we use linear arithmetic with one free variable as the label theory and guards are represented in normalized form as conjunctions of linear inequalities then the elimination procedure implies a polynomial worstcase complexity of equality the algorithm for of classical singlevalued finite transducers has complexity ot q where t is the set of transitions with a symbolic encoding we can replace t by the decision complexity for the alphabet theory symbolic encodings also make expressing dependencies between inputoutput characters to types sfa explicit of an sfa over sft explicit of an sft over a sfa a a a × a b a b sft b b b a f a a b b f f figure algebra of sfts a is a valid sfa expression b is a valid sft expression f is a valid formula label theories are assumed composable give the in a to we use transitions of the form p q it represents transitions required by explicit finite transducer representations overall the full sft over bit arithmetic for the uses states and rules compared to concrete transitions required by an equivalent classical finite transducer we also evaluate the benefits of sfas in sfa equivalence is required for the domain equivalence check of sfts relation to automata in closely related work present streaming transducers an extension of classical finite state transducers that is largely orthogonal to sfts presented here for example streaming transducers allow the input which is not possible with sfts but require the character theory to be a total order so that equivalence remains decidable the authors prove the decidability of equivalence of streaming transducers by reducing it to reachability of automata at a high level the automaton is constructed so that it simulates the execution of the two given transducers in parallel synchronized on the input tape while using the counter to represent the length offset between outputs if the automaton can reach a final state on a zero count then the simulated transducers must have different output on some input while our main algorithm equality algorithm in figure is similar in spirit we do not make explicit use of the automaton construction to do so would impose two restrictions on our approach the automaton construction would require satisfiability checking of conjunctions of formulae in the background theory and it would require special handling to deal with the fact that we allow elements in output sequences to be functions of the input symbols while we are that the first requirement can be readily we are of any way to the second restriction without additional limitations on the types of output functions and by adding a symbolic component to the automaton itself instead we focus on a more adhoc construction that does not impose additional restrictions with respect to the algorithm in figure is reflected in the use of witness or model generation modulo the input condition and the output transformation functions is essentially the implementation of lemma algebra of sfts we introduce an algebra of sfts in figure that allows us to express several useful decision problems involving sfts and sfas note that b a of an sft b with an sfa a is again an sfa because all the outputs of b a are empty we call b a the inverse image of b under a the definition of b a in our algebra is as follows definition let b be an sft and a an sfa the domain restriction of b for a denoted b a is the sft obtained from b × a by eliminating the second output component from all the rules the following property follows from and tb ab if b da otherwise we say that the sft algebra in figure is decidable if validity of all the formulas f in the algebra is decidable theorem the algebra of sfts is decidable if the label theories are decidable proof the sfa operations are effectively closed under intersection an complement and equivalence is decidable if satisfiability of the guards is decidable decidability of equality of sfts is theorem closure under composition is proposition domain restriction is given in the following corollary identifies a collection of practically relevant decision problems that follow from theorem subsumption of sfts a b is the problem of deciding if for all b reachability is the problem of existence of an input that is transformed to an output accepted by an sfa corollary the following decision problems over singlevalued sfts over a decidable label theory are decidable subsumption equivalence idempotence commutativity reachability proof assume a and b are singlevalued sfts and recall proposition subsumption a b is da db a b equivalence a b is a b b a idempotence is a a a commutativity is a b b a reachability of a given output sfa d is a d the following example illustrates a use of the sft algebra for reachability analysis of sfts the example is a digest behind security analysis of string sanitizers with respect to known attack vectors example consider the sft b from exam ple is it possible that b does not detect all tags in other words does there exist an input b that matches the p but let a and a be the sfas such that da and da let ap be the sfa that accepts all strings that match the p t t q q x q x q x q the question is equivalent to deciding if fails b ap a a because for b d b dd a tb ap b a a da tb ap b b it turns out that d when is an sfa with states eg aa dd what is is that d can be effectively converted back to a that describes all inputs where tags are not detected by considering the witness it can easily be traced back to the missing case in the program line of the c code should be q x by verifying for the sft corresponding to the fixed code we can verify the new code indeed detects all tags it also follows from theorem and proposition that we can decide of sfts this is a practically valuable result that the burden of the semantic assumption of in decision problems that assume corollary of sfts over a decidable label theory is decidable extension with registers we extend sfts to symbolic transducers or sts by allowing the use of registers this will provide a more representation and enable more efficient symbolic analysis methods to be used by taking advantage of recent advances is smt technology an st uses a set of variables called registers as a symbolic representation of states the rules of an st are guarded commands with a symbolic input and output component since the finite state component of an sft can be represented with a particular register of finite type the explicit state component is omitted from sts moreover by using cartesian product types we represent multiple registers with a single compound register definition a symbolic transducer or st with input type output type and register type is a tuple q r where q u is the initial state is a predicate called the final state condition and r is a finite set of rules f g where is a × predicate f is a sequence of terms of type × and g is a term of type × we write a to indicate the inputoutput element type and the register type of an st a when we write a we assume to be implicit a rule f g ra denotes the following set of concrete transitions f g def q ga q a q although the formal definition finite states it is often useful to explicitly include a separate finite state component we do this in the examples below moreover it is technically convenient to extend final states with final outputs by extending to be a finite set of final output rules g where is a predicate and g is a sequence of terms of type intuitively a final output is the output produced when the end of the input has been reached often this is but it need not be when all final outputs are then is equivalent to being a predicate as in definition ie q a then means that q a final outputs correspond to a restricted use of rules as used in classical finite transducers the reachability relation p ab a q for a b and p q u is defined analogously to sfts the definition of ta is lifted similarly for a def b · c q qa ab a q q c a example consider the c code in example there is a direct mapping of the code to an st a that uses the compound register q c the initial state of a is the final state condition is t and the rules are we omit s q x x q x x q x x q x x q x c x q x x the register update rq rc of a rule corresponds to the assignments q rq and c rc since all assignments to c have the form c x c corresponds to the previous input character a can be automatically transformed to the equivalent sft the register c is eliminated by using a new state and nondeterminism one can effectively construct a wellfounded axiomatic theory of an st a over a background of lists similarly to symbolic automata in defines a symbol ta that provides a sound and complete axiomatization of ta ie for any model a u ta moreover can be directly as an auxiliary theory of any smt solver that supports lists by in this way we obtain an integrated decision procedure for satisfiability and model generation for quantifier free formulas that may arbitrarily combine formulas over the background u with atoms v where u l and v l are arbitrary list terms a direct application outlined in figure is a proce a b def assert u v w nil while t if a a u u return else u u figure given sts a b generates a witness a b c such that b c and b c for of sts where the auxiliary theories are to the solver in line and longer are used to invoke the solver to decide of the instance in line the procedure computes a witness of case studies we present four case studies for applications of sfts the first case study focuses on sophisticated string manipulation that goes beyond our first case study of sanitizer analysis with bek that is discussed further in section we want to emphasize that the utility of sfts goes well beyond reasoning about string sanitizer processing figure summarizes the essential features of each case study representing to prevent injection attacks such as and sql injection web applications employ sanitizers which are string manipulation routines that remove or encode input characters many applications include their own sanitizer implementations recent work by et al several such sanitizers that a subset of popular sanitizers can be modeled using transducers furthermore they show that safety properties of web sanitizers can be checked using transducer analyses we focus on the sanitizer to evaluate the practical utility of the st representation figure a public string string input sb new new input while character c if c null c else return public character input character first if first null return null if return null character second if second null return null if character c input if c null return c else if second character c input if c null return c return null private character input return input private character input sb new while character c if c else if break else break try int i return new character catch e return null figure in java from the code shown converts named entities eg lt to and numeric entities eg to the numeric entity conversion is difficult to model efficiently using previous approaches realworld implementation taken from the library transforms html entities back to the symbol they represent entities can be named eg lt maps to or numeric in or representation eg entity maps to symbol for simplicity we will restrict our attention to entities intuitively is difficult to cast as a transducer because it requires lookahead a single output symbol may depend on a specific sequence of several characters the full set consists of more than one symbols to a entity therefore we need to up to six while that is possible using either sfts or traditional transducers it requires a large state space in contrast the corresponding st is quite figure shows a st that uses two registers to handle numeric entities with exactly two the compound register is q y z we illustrate explicitly the finite x x y z x xy z x y z xx q q q x xx x x q x y x x q x yx x x q q x zx y q q y z q x ¬x y x figure st representation of the code in figure restricted to numeric entities of the form this st uses two registers to remember one each and uses arithmetic to compute the corresponding code point the terms are implicit in the labels eg the output y z is short for x y zy z where x is the input and y z the register state component that is the value of q final outputs unless they are are shown by labels on outgoing arcs from final states characters correspond to their code points eg the actual happens in the rule from state q to q with guard x where the output · y z corresponds to invocation of in figure the states qi roughly correspond to the control flow of the code in figure evaluation we compare the st representation to the equivalent sfts in terms of size and analysis speed let denote an st that models for entities of the form n ie up to n for each i we compute an sft that is equivalent to by the possible register values at each state figure a shows the number of both states and edges on the for both representations the denotes the number of modeled the most is that the st representation is smaller for example for the encoding the sft encoding has over × as many states and × as many edges as the equivalent st encoding we consider the speed of two algorithms composition and equivalence checking the experimental task is to find a witness ie an input string w that demonstrates that for some number of we consider three different algorithms for performing this task uses an representation and an eager search computing entire transducers stl uses a lazy approach by encoding the entire st into the underlying smt solver and sft represents an eager approach figure b shows the speed results compositions represents the number of times we compose each class of transducer with itself composition refers to the time taken to perform the composition for the lazy stl this time is since the composition is simply to the underlying solver refers to the time taken to find the actual witness after the composition each column represents a single experimental run we employed a timeout per run the label om marks runs that ran out of memory while to marks cases that the timeout these results show that sts in particular using the lazy representation are significantly more scalable for this task than sfts the sft representation either memory or passes the timeout in the of cases the eager st representation the lazy representation only for the smallest two for larger runs ie more compositions and more the lazy sft representation much more ranging from to seconds over the composition range compared to several for the eager representation code of web pages contain malicious javascript that attempts to take over a web browser an active research literature has proposed static and dynamic methods for detecting these attacks a key finding of this work is that authors use techniques to decide which to to the user figure shows an example of browser the code iterates over the list of in the browser and queries their version numbers in some cases version numbers are by adding leading s to them finally variables and are combined to produce the final value this value is then used to select a specific attack to run against the user figure list several concrete values from real browser note that has at least one known and may thus be of special interest to an attacker we consider a scenario in which we have acquired these eg through network and want to find out the corresponding names at a higher level the question is can we find out interesting properties by com this code is simplified for purposes the original considers more types including etc a initial transducer sizes var i i i var if var if not base if else else else else java var q figure browser and code found in javascript b running times figure results the task is to prove that does not commute with itself and to provide a witness that demonstrates this for a given number of compositions we evaluate three representations eager st composition stl lazy st composition using z and sft sft composition we consider five distinct models indicated by based on how many the st or sft can handle preconditions based on a postcondition our techniques can answer this question in the by modeling the code of figure using multiple sfts the key idea is conditional assignment translates into nondeterministic case splits inside the sft at a high level each transducer corresponds to a split or a merge in the control flow of the code relative to a single variable of interest this is illustrated in figure which shows the transducer together with the path predicates modeled by each of its three main branches the transducer reads both and separated by a special symbol its output is guaranteed to start with if and only if the branch was taken for the sake of brevity we do not display the remaining sfts figure lists the full set of sfts and their statistics takes the output of and models the control flow join at the end of the first if statement models the final while loop in figure the manipulation of variable is analogous figure sft with corresponding path predicates for the code evaluation we compute the of the composition transducers discussed above as follows for each w we construct an sfa that accepts w and corresponds to the postcondition w the of and correspond to preconditions for a single iteration of the for loop in figure for example for w q we find a precondition that relates values of to values of as follows already had value possibly with up to five or entirely of and contained the substring together with and in that relative order condition represents the case where had a version number while condition represents the case in which a version number was extracted inside the for loop for all real we tried our analysis took less than one second per next we evaluate whether inverse image generation as used above to relatively large output values unlike most previous string constraint solvers sft sft states variable composed edges variable composed figure sfts used for the example statistics for the and components are shown the composition sfts take approximately one second to compute combination ff no ff ie no of interest ff ff q q q q q figure browser using an sft model computing input values for and takes less than one second per figure inverse image generation time in seconds for outputs up to bytes the outputs were randomly generated from the language qn over bit characters based analysis does not impose length bounds on the strings under consideration this is only if the approach actually to large strings we show the approach does scale by generating random of the form qn and the time it takes to compute the inverse for both the and variables figure shows results in general our approach takes less than half a to generate for up to worth of output in contrast the solver was limited to finding up to bytes worth of output our case study demonstrates several important points first sfts are for describing code by making use of nondeterminism the transducers needed can be large on the order of of states and edges but figure transformation illustrated we can construct them from much smaller transducers of states and edges through composition the computation reveals interesting relations among mutually dependent variables finally the computation is efficient it can generate valid string inputs for outputs that measure several in size while we are of any previous string constraint solver that can handle this order of magnitude from our first two case studies we have the following key · sts can be more in representation than sfts we saw in our example that our st representation had times fewer states and times fewer edges than our sft representation · lazy st encoding best for our example taking between to seconds for six characters and two compositions eager st encoding is slower and eager sft encoding times out above two characters · sfts can accurately model real examples of malicious javascript code our analysis requires less than one second to recover versions from real examples of generated by malicious code found in the · previous work in string constraint solving has focused almost exclusively on constraints that require fewer than bytes for example the of experiments were with length bounds of bytes or fewer in contrast our techniques can synthesize in of bytes in roughly a image to illustrate the generality of sfts we look at image transformations a clear advantage of representing image transformations in the form of transducers is the ability to do composition on transducers it gives us in fact image editors such as represent image contents as the original image as well as a series of image transformations such as black and white conversion contrast and the like in many cases of course editing a image that includes of bit before might involve a of such transformations applying them one after another in a sequence is often too to be practical a better alternative consists of composing the transformations together and applying them to the input image only a single time we focus on image which is a image transformation figure illustrates the two transducers for and vertical of an image privacy via entropy a feature of our analysis is that we can estimate a privacy metric for image using our techniques our starting point is the observation that if an image has a unique given then the does not hide the original image at all just consider a black square no matter how many times we might attempt to it the image will remain unchanged on the other hand after a face there may be multiple original that yield the same face put another way a face image defines a set of potential candidate original if we assume that all candidate original are equally likely then we can define the entropy h of the original face after a transformation as follows h log in other words we use the reverse mapping given to us by the inverse transducer and take the of the size of its for the entirely black image example h because there is only one element in the to increase privacy our goal is to the entropy note that given for of a given size we can always check if two result in the same image after our techniques allow us to write down a smt formula where the number of solutions is equal to the number of of on a specific image this is the first connection to our knowledge between smt techniques and probabilistic definitions of privacy of course computing the exact number of solutions is p complete but we can employ approximation techniques to estimate this then we can compare different methods of by the entropy induced we leave exploration of the impact of different approximation techniques as future work location privacy located in most mobile devices track our location while the of applications such as and show user demand for sharing this information this also raises privacy concerns as a reaction to privacy concerns location sharing service started allowing users to only release the they are in not their precise location so that a trace of a users might look like park ca palo alto ca ca view ca ca clearly given the sizes of these tracking the user precisely might present some difficulty to generalize one approach that has is context sensitive choice of intuitively if i am located in a location such as location is fine to reveal if i am in a area such as the we should only reveal a location approximation this can be encoded with a transducer that works on a stream of recorded location measurements to summarize given use a lookup list of world and their and values and point calculation to compute the to the current location determine the population via a lookup table map the population to a high or low density area h or l based on the last five enter a output state depending on that the pair is approximated with different precision this can be captured by a transducer with different output actions depending on the current state for instance for areas we can drop location seconds and for areas we can drop location et al consider additional trace techniques such as adding or traces which can also be represented using our sft framework related work in an applied setting we introduced and applied sfts to analysis of security sanitizers in the bek project this work on procedures for sft analysis and did not state or prove any algorithmic results on sft decision procedures in comparison the current paper provides the missing formal foundation for bek program analysis it further new and more general algorithms including the more general equality algorithm that factors out the decision problem for the new support for registers enable new previously infeasible application areas these include even example and most of the case study section furthermore the new support for nondeterminism allows elimination of registers as illustrated in example without general equivalence of finite state transducers is undecidable and already so for very restricted fragments equivalence of decidability of singlevalued was shown in and extended to the case there exists k such that for all v k in the decidability of equivalence of the case does not follow from the singlevalued case corresponding decidability result of equivalence of sfts is shown in unlike for the singlevalued case that has a practical algorithm figure the case is substantially harder the equality algorithm does not generalize to this case because the satisfiability checks cannot be made locally lemma does not imply violation of in the case in recent years there has been considerable interest in automata over infinite languages starting with the work on finite memory automata also called register automata finite words over an infinite alphabet are often called data words in the literature other automata models over data words are pebble automata and data automata several of logics with respect to different models of data word automata are studied in this line of work focuses on fundamental questions about decidability complexity and expressiveness on classes of automata on one hand and fragments of logic on the other hand a different line of work on automata with infinite alphabets introduces lattice automata that are finite state automata whose transitions are labeled by elements of an atomic lattice with motivation coming from verification of symbolic communicating machines streaming transducers provide another recent symbolic extension of finite transducers where the label theories are restricted to be total orders in order to maintain decidability of equivalence eg full linear arithmetic is not allowed finite state automata with arbitrary predicates over labels called finite state or symbolic finite automata sfas in the current paper were first studied in the context of natural language processing while the work views symbolic automata as a fairly trivial extension the fundamental algorithmic questions are far from trivial for example it is shown in that symbolic by a combinatorial optimization problem called generation leads to significant compared to automata algorithm implementations the work in introduces a different symbolic extension to finite state transducers called finite state transducers this extension is not expressive enough for describing sfts besides identities it is not possible to establish functional dependencies from input to output that are needed for example to encode transformations such as we use the smt solver z for solving label constraints that arise during composition and equivalence checking algorithms as well as for witness search by model generation using auxiliary sft axioms finite state transducers have been used for dynamic and static analysis to validate sanitization functions in web applications in by an overapproximation of the strings accepted by the sanitizer using static analysis of existing php code other security analysis of php code eg sql injection attacks use string to obtain in form of context free grammars of the html output by a server et al show how multiple automata can be composed to model looping code our work is complementary to previous efforts in using smt solvers to solve problems related to list transformations the tools and extend the solver to handle equations over strings and equations with multiple variables the work in shows how to solve subset constraints on regular languages in contrast we show how to combine any of these solvers with sfts whose edges can take symbolic values in the theories understood by the solver topdown tree transducers provide another extension of finite state transducers a finite state transducer is a topdown tree transducer over a monadic alphabet similar to finite state transducers decidability of equivalence of topdown tree transducers is known for the singlevalued case including a specialized method for the deterministic case and also for the case several extensions of topdown tree transducers have been studied eg symbolic topdown tree transducers are studied in where partial equivalence is shown to be decidable for the linear singlevalued case conclusion we introduced a symbolic extension of the theory of classical finite transducers where transitions are represented by terms modulo a given background theory our approach enables a range of analyses in combination with constraint solving techniques the core algorithms we presented are composition and equivalence checking of singlevalued symbolic finite transducers and we showed how to decide whether arbitrary symbolic transducers have the property we demonstrated how our work directly applies to analysis of web string sanitizers detection image manipulation and location privacy and we expect more applications to follow our techniques can synthesize string in of bytes in roughly a our st representation had times fewer states than previous approaches and we found lazy st encoding for our example took at most seconds even in the most extreme cases these algorithms make it possible to work with symbolic representations of transducers just as traditionally done with finite state transducers as first class in designing new analyses and program transformation techniques by the continuous advances and improvements in constraint solvers and satisfiability modulo theories solvers references r and p streaming transducers for algorithmic verification of programs in popl pages ­ acm d e r d m a a and t j data and of usable data sets ieee security and privacy d m v n e c and g composing static and dynamic analysis to validate sanitization in web applications in ieee security and privacy bek m c and g automata vs logics on data words in csl volume of lncs pages ­ springer n and m symbolic transducers technical report microsoft research january m a t l and c david logic on words with data in lics pages ­ ieee a j and j scott exploring end user for location services and the value of location in september k z chen g j x and j automated collection and of scenarios in march b and p attribute grammars and recursive program schemes theoretical computer science ­ m c and g detection and analysis of attacks and malicious javascript code in conference nc april k and j the equivalence of transducers on languages is decidable theoretical computer science ­ c b b and c mostly static javascript detection in proceedings of the usenix security symposium aug g b and b c elimination and its dual journal of combinatorial theory a ­ l de and n z an efficient smt solver in tacas lncs a j demers c and b on some decidable properties of finite state translations informatica ­ p how unique is your web browser in privacy pages ­ j some open questions and recent results on tree transducers and tree languages in r v editor formal language theory pages ­ academic press j and s a comparison of pebble tree transducers with macro tree transducers informatica z decidability results concerning tree transducers ­ z and h syntaxdirected semantics formal models based on tree transducers springer t l and b lattice automata a representation for languages on infinite alphabets and some applications to verification in sas volume of lncs pages ­ t the of the equivalence problem for free nondeterministic generalized machines j acm ­ p and m an evaluation of automata algorithms for string analysis in lncs springer p and w a decision procedure for subset constraints over regular languages in proceedings of the conference on programming language design and implementation pages ­ new york ny usa acm isbn p and w solving string constraints in p b d p and m fast and precise sanitizer analysis with bek in proceedings of the usenix security symposium august o the of the equivalence problem for with unary input output alphabet and applications siam journal on computing ­ m and n automata in st annual symposium on foundations of computer science volume pages ­ ieee a v p j p and m d a solver for string constraints in n kobayashi n and h higherorder tree transducers and recursion schemes for program verification in popl pages ­ acm j a survey of computational location privacy personal comput ­ august a j m and k the power of extended topdown tree transducers siam j comput ­ june t d and v typechecking for xml transformers in proc th acm symposium on principles of database systems pages ­ acm y static approximation of dynamically generated web pages in proceedings of the th international conference on the world wide web pages ­ isbn k d s and h information in javascript implementations in proceedings of web security and privacy may f t and v finite state machines for strings over infinite alphabets acm trans cl ­ g v and d finite state transducers with predicates and identities grammars ­ ch l and s j verifying higherorder functional programs with patternmatching algebraic data types in popl pages ­ acm j r algorithms for image processing and computer and sons p b and b a against code injection attacks in proceedings of the usenix security symposium aug p d s s f and d a symbolic execution framework for javascript in ieee security and privacy m p relations in gi conference on automata theory and formal languages volume of lncs pages ­ l automata and logics for words and trees over an infinite alphabet in z editor csl volume of lncs pages ­ h equivalence of tree transducers is decidable math systems theory ­ m and n symbolic tree transducers in of system psi m n and l de symbolic automata constraint solving in c and a editors volume of lncs pages ­ m p de and n symbolic regular expression in ieee g d a d h and z su dynamic test input generation for web applications in a transducers and deciding their equivalence siam journal on computing ­ february f t and o h relational string verification using automata in proceedings of the th international conference on implementation and application of automata pages ­ 