well easy to sound modular verification of c code executing in an unverified context frank popl consist complete abstract over the past great progress has been made in the static modular verification of c code by means of separation program logics however the runtime guarantees by such verification are relatively limited when the verified modules are part of a whole program that also contains unverified modules in particular a memory safety error in an unverified module can the runtime state leading to assertion failures or invalid memory accesses in the verified modules this paper runtime checks to be inserted at the boundary between the verified and the unverified part of a program to guarantee that no assertion failures or invalid memory accesses can occur at runtime in any verified module one of the key challenges is enforcing the separation logic frame rule which we achieve by checking the integrity of the footprint of the verified part of the program on each control flow transition from the unverified to the verified part this in turn requires the presence of some support for memory at runtime we formalize our approach and prove soundness we implement the necessary runtime checks by means of a program transformation that translates c code with separation logic annotations into plain c and that relies on a protected module architecture for providing memory and restricted module entry points benchmarks show the performance impact of this transformation depends on the choice of boundary between the verified and unverified parts of the program but is below for realworld applications categories and subject descriptors d software engineering verification keywords separation logic verification runtime checking introduction the construction of reliable software in unsafe languages like c or c is known to be challenging yet because of the performance of these languages and because they can give the programmer access to lowlevel details of the machine on which the program is executing they are often the languages of choice for software such as operating systems and servers and for embedded software permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright © acm one way of significantly increasing in the reliability of software is the use of program verification over the past program verification technology for programming languages has reached a level of that makes it possible to verify realworld software with considerable effort two examples are the verification of using the verifier and the verification of sel a of the l family but there are many other examples of projects that formally verify the safety andor functional correctness of parts of c programs for large systems it is essential that the verification technique used is modular each module for instance each function is verified to with its specification relying only on the specification of the other modules that the verified module is interacting with several sound modular verification tools for c have been proposed however the soundness properties of these have an important limitation to the best of our knowledge all soundness results for modular c have the form under the condition that all modules of a program have been verified any execution of that program will with the specification in other words as soon as there is one unverified module all are off the implementations of modules that are not verified are part of the trusted computing base it is assumed that they with the specifications for these modules that were used to verify the verified part of the program such assumptions are particularly for languages such as c as a single error such as a buffer overflow in one unverified module can in principle up the runtime state of all modules this has several consequences · while testing a partially verified program failures may still occur in the verified part of the program and the root cause for such failures may be hard to track down this includes both memory safety failures eg dereferencing invalid memory addresses as well as failures of assertions that were statically verified to hold · security properties verified to hold in a module are not guaranteed to hold when that module is used as part of a larger unverified program hence the benefits of partial verification for security purposes are limited in particular in a security setting one must consider that memory safety errors may be exploited by means of code injection attacks maintaining the integrity of a verified module in such a setting is very challenging what is needed is a technique for ensuring that failures cannot occur in the verified part of the program any runtime error should either lead to a failure in the unverified part or be detected on entry to the verified part this will that the state of the verified module is always valid and that no properties that were verified to hold for this module state will ever be violated the approach we suggest is based on performing runtime checks at the boundary between the verified and unverified part of the program while sound approaches for such dynamic contract checking exist for safe languages to the best of our knowledge there is no system that achieves such sound contract checking for unsafe languages such as c furthermore existing approaches each memory access in the unverified part or verified part a large performance cost while we will perform our checks only when the boundary the main contribution of this paper is the development of a program transformation that given a c program partitioned into an unverified module and a module verified by means of separation logic transforms the verified module into a module that includes sound and complete runtime checks at the boundaries of the module a key problem that needs to be solved is how to make sure that memory errors or alternatively malicious code in the unverified part cannot the state of the verified module while still only performing explicit checks at the boundary we solve this problem in two steps first the boundary checks perform integrity checks on the heap footprint of the verified module on to the verified module we check that the heap memory owned by the verified part has not been changed by the unverified part of the program this ensures that bad writes to the heap performed by the unverified part are detected second we need a mechanism for the integrity of local variables and control flow metadata of the verified module for this we rely on the recent work on protected module architectures which are lowlevel security architectures providing support for data regions and restricted module code entry points early are while the most recent research implement this protection in hardware thereby reducing the trusted computing base to just the processor itself intel recently hardware support for under the name intel software guard extensions hence this type of protection mechanisms will be available in the future the combination of the module boundary checks and the protection of local variables and control flow gives us a very strong modular soundness guarantee no verified assertion in the verified module will ever fail at runtime even if the module runs as part of a application that is subject to code injection attacks the main contributions of this paper are · the development of runtime checks for separation logic contracts at the boundary between a verified and an unverified part of a c program · a formal correctness proof of these runtime checks · the observation that existing fully abstract secure compilation techniques to a ensure the soundness of these runtime checks even in the presence of code injection attacks exploiting memory safety errors in the unverified part · the development of a robust prototype based on the verifier · the quantification of the performance cost of the technique by means of and macro benchmarks the remainder of this paper is structured as follows first we elaborate on the problem we solve and on our proposed solution in sections and section gives an informal explanation of our program transformations and section illustrates them using an example program section formalizes the transformations in section we discuss our prototype implementation and the results of our benchmarks finally we discuss related work in section and conclude in section problem statement we assume as given a separation program logic for c and a sound modular static verifier that checks of c functions with contracts expressed in the program logic for we work in this paper with the verifier but our results are not specific to we use syntax in our examples separating conjunction is written as and x introduces an existentially quantified logic variable for programs in which each function is statically verified and where the main function has an empty precondition verification ensures that no routine ever performs an illegal memory operation and each routine its contract however verifying the entire code base of a program is often infeasible for instance because it is too costly in terms of programmer effort trying to prove full program correctness properties for partially verified programs would clearly be since there are no guarantees about the behavior of the unverified parts however as this section will point out even statements concerned only with the verified parts of the program cannot be proven in general for partially verified programs written in memory unsafe languages we consider singlethreaded c programs consisting of two parts an unverified context and a statically verified module each function of the verified module and each function prototype used by it specifies a separation logic contract consisting of a precondition requires and a postcondition ensures static verification ensures that the verified functions are memory safe and with their specifications but only under the assumption that the precondition holds on function entry and that any function called from those functions to its own specification int lst l void lst l req v v v unverified functions int main struct lst l void lst l unverified sort implementation verified functions int lst l req v v res int s struct lst l proof statements return s consider the example program shown above on the left is the context consisting of a main function a function and a prototype for a function on the right is the verified module which contains the function and a prototype for the function takes as input a nonempty list and claims that after execution the list still contains the original values and the return value will be the of the input list this function relies on functions len nth and to perform its task the verifier relies on the contracts of those functions in addition to the proof statements in itself to prove that the function will its contract the implementation of len and nth is not shown in the example but they are assumed to be part of the verified module hence the verifier can verify those functions as well on the other hand for the function the verified module only contains a prototype hence the verifier can only assume that its implementation will the specified contract linking the two parts of the example program together and executing them may still lead to violations of the verified module spec if one of the functions has a bug we say that a function has a bug if it does not with its contract that is there exists an execution of the function that satisfies its precondition but an invalid memory access violates the postcondition or performs another function call and violates the precondition of the called function we assume that the static verifier is sound ie it any function with a bug hence there are only bugs in the unverified context not in the verified module for instance if called from main has a bug and returns an invalid eg memory address the len function or some other verified function could perform an illegal memory operation likewise if has a bug and violates the contract specified in its function prototype then the verified function might not its contract either furthermore because c is a memory unsafe language can write to arbitrary memory locations thereby modifying data belonging to the function for instance could write to the original list l instead of the copy l that it was given hence any properties verified to hold by the verifier about l while verifying might be violated at runtime after a call to the unverified function note that can also read memory that it is not allowed to by its contract this is also a bug but it will not violate any property of the verified module assumed by the verifier hence our runtime checks will allow this how bad the effects of bugs in the unverified part of the program can be depends on how the program is executed a safe execution performs complete runtime checking and will detect bugs as soon as they appear et al propose a way to perform such executions every memory access is checked and contracts are checked on each function entry and exit hence safe executions are expensive it is sound to remove the runtime checks from the verified module as the soundness of verification implies that these checks will never fail in the safe execution but as long as there is a significant unverified part the performance cost will be high because of this performance cost executions of c programs are usually not safe hence executions can enter an error state and continue executing we say an execution is in an error state if it has performed memory accesses resulting in undefined behavior according to c semantics or if the execution has violated some of the separation logic specifications an execution can only enter an error state in a function with a bug that function is the root cause of the error state an execution fails at the point where it detects the error state and terminates safe executions fail immediately at the root cause of a bug but other executions may continue after entering an error state typically what happens then is the program behavior depends on details of the compiler and the machine on which the compiled code is executed most c compilers will generate code that may detect some error states such as the dereference of a memory address that the operating system has not even allocated to the program but in general failure of the execution may happen long after going into an error state as a consequence executions may enter an error state in the unverified context but then fail in the verified module the verified module may also be operating while in an error state yet not fail and possibly further up the runtime state and the error state of the execution this is exactly why partial verification is less useful than it could be as discussed in the introduction our approach is to develop efficient runtime checks to be inserted at the boundary between verified and unverified code that make sure that no failures can occur in the verified module executions can enter an error state while executing in the unverified context and the execution may then continue in an error state but we have the guarantee that any error state that might impact the verified module will be detected before control flow enters the verified module as a consequence we have that the execution never fails while control is inside the verified module overview of our solution to guarantee that error states never impact verified modules we need to model the execution of programs with memory safety errors we describe two such models below controlflow safe execution the controlflow safe execution models programs as commands that operate on a heap this is a standard model of unsafe imperative programs in the separation logic literature memory safety errors may impact any part of the heap but they cannot modify local variables or the control flow in other words attacks or stack are not modeled for the controlflow safe execution it is sufficient to perform runtime checks at the boundary between the verified module and the unverified context roughly speaking the checks that need to be performed at the boundary are the following each function of the verified module should check that its precondition holds on entry from an unverified function check that the postcondition holds after an ie a call from the verified module to an unverified function and ensure that unverified functions did not modify any heap locations that could affect the verified functions correct execution in our approach the first two checks are based on a translation of separation logic pre and postconditions into equivalent c code that will check the validity of those conditions at runtime for the third check our approach keeps track of the footprint of the verified module ie the memory locations that the module can read or write and it uses an integrity check to ensure that unverified functions do not modify the contents of those locations except for the locations explicitly allowed by the precondition of the called unverified function right before performing a call from a verified function to a function of the unverified context a cryptographic is calculated over the contents of the verified modules footprint which is and compared against the original on of the verified module we develop a program transformation on the verified module that the necessary runtime checks in section and we prove them correct for the controlflow safe execution of programs in section unsafe execution of course for most realistic c compilers the controlflow safe execution model is too abstract control flow information and local variables ie the runtime stack are stored in the same memory space as the heap and hence memory safety errors can also modify control flow or contents of local variables this is particularly relevant if we consider the possibility that our program might be under attack and an adversary provides input that a memory safety error in the unverified part of the program by performing one of the many possible low level attacks against c programs hence we also consider unsafe executions where programs are compiled in the standard way to a von style processor architecture under such unsafe executions the boundary checks discussed above are as memory safety errors might the integrity that the boundary checks compute also of the control flow or of local variables in the verified functions may lead to failures in the verified module to restore the property that no failures occur in the verified module we build on a recently proposed fully abstract secure compilation technique towards protected module architectures this compilation technique modules from a potentially malicious context and ensures that any possible effect that the malicious context can have on the module can be understood at source code level by composing this secure compilation technique with the program transformation for the controlflow safe execution we get the desired property that no failures can occur in the verified module even in the presence of code injection attacks or other of memory safety errors in the unverified context program transformations this section describes how a verified module can be transformed into a module containing runtime boundary checks and how our prototype implements these checks at an level the module can be divided into a functional part and a boundary checking part the former is essentially a copy of the verified module given as input where the separation logic contracts and proof statements have been removed and the functions have been given a fresh name and marked static in order to remove them from the modules public interface the latter part contains new functions and data structure definitions to actually perform the runtime boundary checks the module is constructed such that each transition between the context and the functional part passes through the appropriate function of the boundary checking part the transformation is based solely on the source code of the verified module and the annotated function of the unverified part hence the transformation does not require access to the source code of the unverified part the resulting module can be linked with the unverified part no recompilation of the unverified part is necessary the sections below explain concretely how different kinds of separation logic constructs can be translated into c code for checking them we assume the controlflow safe execution model since it is the execution model provided to us by the fully abstract compilation scheme as described in section pure assertions pure assertions as opposed to spatial assertions only reference local variables and hence do not make claims about the heap such assertions can be translated straightforwardly into a c expression as shown by the example below original module int x req x res if x return int p return p int x int y req true res x y module functional part static int x if x return int p return p boundary checking part static int x int y int r y if r x y trap return r int x if x trap return all assertions in this example ie the contracts of and prod are pure in the module has been replaced by an entry stub that first checks the precondition before calling which is a slightly modified version of the original the only functional difference is that the modified version calls the prod stub instead of the original function prod in the context the stub first calls prod in the context and then checks whether the postcondition holds if any check fails the trap function is called which ends execution the functions prod and have been marked static to indicate they are not in the public interface of the module spatial assertions spatial assertions describe parts of the heap they indicate that a certain memory region should contain certain values the assertions need not necessarily specify exactly what those values are they can instead existentially quantify over them by binding a logic variable see for instance the logic variable bindings a and b in the precondition of the original module in the example below the difficulty with spatial assertions is that a function in the context can these values even though that function might not be allowed to do so by its contract thereby possibly properties of the verified module verified to hold by the verifier in separation logic terms this corresponds to a violation of the frame rule as described in section we use a cryptographic over the memory footprint of the module to solve this problem original module struct pair int a b module struct pair int a b void pair p req pa a pb b pa pb void pair p req pa n pa m m n static void pair p static void pair p char h h int n if h trap int m if m n trap void pair p a b fp the code above shows our approach in the module on the right the verified function f has been replaced by an entry stub that first calls for both integer pointsto assertions in the precondition of the original f then calls f and finally calls again for both integer pointsto assertions in the postcondition the function is a data type checking function provided by our runtime checking system it takes as arguments a pointer p to an integer and an enumeration value and performs two important functions the function first checks whether p points to a valid integer which it does by simply reading p secondly the function adds or removes the memory region by the integer ie the memory region of bytes starting at address p to or from a global data structure describing the modules footprint when the enumeration value is p for produce the memory region is added to the footprint and when it is c for consume the region is removed when adding a region to the footprint checks that the region does not overlap with the existing footprint this corresponds to the semantics of the separating conjunction which requires that the footprint of each of its conjuncts a disjoint part of the heap we do not support conjunction but argue in section that this does not pose problems if all checks pass the function returns the integer value at the given address or ends execution by calling trap otherwise functions similar to are provided for other data types char unsigned int and pointers because the memory sizes of those data types can differ in the function f of the module the call to the ct function of the context has been replaced by a call to the ct stub this stub first removes the footprint of precondition from the modules footprint before calculating a hash over the memory regions described by the remaining footprint this hash is stored in the local variable h where it is protected from the context by the secure compilation scheme next the stub calls ct over control to the context when the context function returns the stub verifies that the memory described by the footprint has not been with by the hash and comparing it to the original value stored in h finally the stub checks whether the postcondition of ct holds by producing its footprint and checking whether the values in the corresponding memory region to the contract note that we do not prevent the context from reading memory it is not to by its contract because this can never violate properties of the verified module assumed by the verifier for our prototype we implemented the footprint data structure as a this data structure supports ok addition removal and overlap testing and on traversal with k the number of bits in a memory address eg for a bit cpu and n the number of memory regions in the the footprint description must be protected from being by memory safety errors in the unverified context and hence we store it in the memory section provided by the predicates separation logic predicates are named parameterized assertions used to provide data encapsulation and to describe recursive data structures for instance the following predicate describes a linked list of integers of a certain size struct list int value struct list next pred list l int size l size lvalue n size size size predicates can have an arbitrary number of parameters and separation logic allows us to existentially quantify over each of them for instance a valid precondition could be meaning that there must be a linked list of size on the heap translating this quantification into a runtime check would however be problematic since in general the entire heap would need to be examined in order to bind a value to l at runtime hence we require predicates to be precise predicates must separate their parameters into input and output parameters and only output parameters can be quantified over when using a predicate in a predicate definition each output parameter of the predicate must be assigned a value in all execution paths of the predicates body we discuss the implications of this requirement in section in syntax parameters before the in the parameter list of a predicate definition are input parameters and the other parameters are output parameters hence for defined above l is an input parameter and size is an output parameter static void list l int size op if l size else op struct list n op int size size op size size the code above shows the transformation of the predicate it is a predicate checking function with one more pa than the original predicate this extra parameter is an value indicating whether the predicate will be used for consumption or production and its value is simply passed on to the data type checking functions eg described in sec tion input parameters have the same type in the runtime check ing function as in the original predicate and output parameters are pointers to the type of the parameter in the original predicate the predicates body is transformed straightforwardly into c code when an output parameter is assigned a value in the predicate body the corresponding pointer parameter in the run time checking function is assigned a value as well as by the recursive call to a predicate call assertion is transformed into a call to the corresponding predicate check ing function if an assertion uses a constant value or previously bound variable for an output argument instead of binding a new variable eg s with s already bound instead of s then this is to first binding a fresh variable to the output parameter and then it with an equality eg s s s this allows the core transformation to assume that output arguments are always existentially quantified inductive data types while spatial assertions and predicates are in some cases sufficient to prove memory safety they are to prove full functional correctness for most programs for instance the predicate defined in the previous section specifies the size and memory footprint of a linked list but does not say anything about its contents supports a rich specification language with inductive data types and fixpoint functions ie primitive recursive functions over them the example below shows how such constructs can be used for specifying functional correctness properties ints ints pred list l ints values l values lvalue v n values fixpoint int lst switch lst case return case tail return v int list l req values values res implementation omitted the behavior of is completely specified by its contract our transformation translates such inductive data type specifications into tagged structures a known technique for implementing variant types in c the code below shows the data structure definitions corresponding to ints and its two constructors struct ints int tag struct int tag no members struct int tag int struct ints to prevent the context from with instances of these data structures when the context is in control the data must either be stored in the private memory section provided by the or be included in the modules footprint such that its incorporated in the cryptographic described in section we chose to store the data in the private memory section which is faster than the approach but does require more private memory besides these structure declarations the transformation also generates an equality comparison function for each inductive data type finally fixpoint function definitions are translated straightforwardly into equivalent c functions function pointers allows programs using function pointers to be verified by letting users associate contracts with classes of functions the code below shows how a verified module can use a function pointer to call a function in the unverified part int x req true result void g int x req true int y gx the on the left defines as the class of functions that take an integer argument and return a strictly positive integer result on the right the function f takes a pointer g to such a function applies it to a local variable x and stores the result in y the contract for g is specified by the assertion in the precondition of f which refers to the on the left our transformation handles function pointer calls almost the same way it handles regular calls that is an stub is generated for each defined function pointer and the module calls this stub instead of calling corresponding function pointers directly function pointer take as an argument a pointer to the concrete function to call for instance for the example code above the function pointer stub would be static int f int x calculate footprint hash int result fx verify footprint hash check postcondition return result indirect function calls from the context to the module are also supported naturally since all functions of the functional part of the module have been made static the only accessible functions of the module are those in the boundary checking part the fully abstract compilation scheme uses the restriction on module entry points to ensure that only those public functions can be called from the context at runtime hence the necessary runtime checks are performed whenever the unverified part calls the module through a function pointer example program this section uses an example program to illustrate how the transformations described above affect the modules footprint description figure the example program and the footprint at various execution points note that the program is an abstract example created to illustrate the footprint evolution under various control flow transitions and is not intended to model any useful computation the program consists of the verified functions vf vf and vf and in addition to the standard c library two unverified functions main and the unverified function is annotated with a separation logic contract so it can be called from figure when executing the example program on the left the footprint as shown on the right the boxes on the left are unverified functions while the boxes are verified functions the boxes on the right represent the heap with the parts representing the modules footprint lines are function calls and dashed lines are returns the verified functions the function signatures and contracts shown in figure refer to a struct m and predicate defined as struct m int x int sz pred a int sz sz true sz a sz instance represents a character array of size sz starting at heap address a the char predicate used by is a primitive which asserts that its argument points to a valid character in memory its translation is a call to the data type checking function similar to described in section we now discuss how each of the function calls shown in figure affects the modules footprint description assume main allocates an array a of n bytes and an instance m of struct m using the standard unverified malloc function and assigns the value n to ms sz field at this point the heap contains a and m and the footprint description is empty next main calls the verified function m and hence this functions entry stub will check whether its precondition holds the precondition check consists of reading the sz field of m and verifying that a is in fact a character array of size n as part of this check the memory by ms sz field and the entire array a will be added to the footprint description the memory by ms x field is not mentioned in precondition and hence is not added to the footprint description next vf calls directly without passing through a boundary checking function because both caller and callee are in the module no runtime checks are performed and hence the footprint description remains the same the vf function now makes an sz which passes through the corresponding stub the stub first removes the array a from the footprint description because it is ref in precondition and then the memory in the remaining footprint description consisting of only the sz field of m before calling we assume allocates an array b of integers again using the standard malloc function and then calls this functions entry stub will verify that b is a valid array of integers and will add b to the footprint description the vf function now executes its unspecified body and then returns thereby removing b from the footprint description as specified by its postcondition now is back in control and returns to its stub in the module the stub will first check that the memory in the footprint still consisting of only ms sz field has not been modified by the hash and comparing it to the original execution is aborted if any change is detected if the new hash matches the original the stub checks whether postcondition holds and adds the second half of a back to the footprint description as specified by postcondition the stub then returns control to vf note that it is impossible that vf now tries to access the first half of a since this would have been detected by the static verifier when verifying vf the vf function now returns to vf without any change in the footprint description because both functions are part of the module finally vf returns to main removing the second half of a and ms sz field from the footprint description as specified by postcondition control is now back at the main function and the footprint description is empty formalization this section formalizes the transformations described in section and shows that they are safe and precise safety means that the module does not fail even when it is interacting with a context that does not its contracts precision means that the module behaves exactly like the original verified module when interacting with a context that does its contracts focusing on the of the transformation we do not formalize inductive data types nor function pointers due to space constraints we only give a highlevel overview of the formalization here and leave the full text and proofs for our extended technical report programming language we first define a simple imperative programming language that models c the syntax of this language is defined in figure and its operational semantics are described in figure we write e s to indicate the value of an expression e evaluated under a store s assuming standard nonnegative integer expression evaluation in addition to standard imperative language constructs such as heap lookup mutation allocation and deallocation the language provides two assertion commands the first is which asserts that the boolean expression b holds and the other is which asserts that the memory address l is allocated both commands evaluate to skip if the assertion succeeds and to trap otherwise as opposed to failing is a clean way of indicating an our runtime checks trap whenever they discover a bug in the context once a program it remains in the state forever ie it diverges program states s h c consist of a map from routine names to routine definitions a stack s a heap h and the program under execution c the stack is a list of stores s each of which is a partial function from vars to n the heap is a partial function from memory locations in n to values in n execution starts from an empty store and heap we assume our programs are wellformed that is they never try to use a variable that was not defined earlier in the code and they do not refer to undefined routines definition failure we say a program c fails when it is stuck for wellformed programs this corresponds to reading writing or an memory location since we prove safety for any module absence of failure according to this definition also implies absence of assertion failures separation logic we define separation logic triples of the form p c q and p c q triples of the first form mean that the static verifier asserts that given the function mapping routine names to contracts if p holds then c will not fail and q will hold after executing c the corresponds to the of the functions of the context including their contracts triples of the latter form mean that if p holds in some state stack and heap then executing c under the context fail and q will hold in the resulting state the corresponds to a concrete context in the form of a map from routine names to routine definitions because the verifier is sound p c q implies p c q under the critical condition that the routines of the contracts defined in the essence of our formalization is to show that our program transformation will allow us to discard this critical condition we are only concerned with partial correctness so c is allowed to diverge which is what happens when our runtime checks trap see figure the assertions p and q are defined as p q b b p q e x pe x y e p q p q p q ¬p where booleans b and expressions e are defined as in figure p refers to a userdefined predicate pred px y a and x introduces a logic variable x the first parameter of a userdefined predicate is an input parameter and the second is an output parameter the assignment assertion y e is used to bind a value to predicate output parameters the formal semantics of this assertion language are defined in figure where a judgment s h p s means that p holds under store s and heap h and binds new logic variables using e x and pe x to end up with the updated store s contract assertion language although assertions in our metatheory range over the full language defined above routine and predicate contracts come from a more restricted language of precise assertions a b b a a e x pe x y e a a in particular routine and predicate assertions do not include standard conjunction disjunction negation nor top furthermore we require userdefined predicates to constrain their output parameter to a single value using the y e construct exactly once on each possible execution path of their body these requirements make existential quantification constructive assertions indicate how each variable can be assigned a value thereby avoiding an exhaustive search which would an runtime performance cost while disjunction negation and conjunction between spatial predicates might seem to limit the expressiveness of the contract assertion language this language subset corresponds exactly to the assertion languages supported by and other separation program extensive experience with these tools has shown that this subset is sufficiently expressive for practical purposes in the rest of the text we will consistently use symbols p and q for metalevel assertions and symbol a for contract assertions transformations in this section we formalize the transformations described in section we start by defining a function from assertions to commands that models the production of a see section the code generated by this function assumes there is a program variable fp containing a set of memory locations that represents the modules current footprint the generated code will trap if a does not hold or if its footprint would overlap with the footprint in fp create a program variable x for each logic variable x in a and add the assertions footprint to fp the function is defined as follows e y e a a if b then else x e x fp x x e fp fp x x where fp is the program variable that stores the footprint y returns if x is in the list represented by y and otherwise and y adds x to the list represented by y x x e fp x x where implements the production part of the predicate checking routine for p defined as routine x res fp y with a the body of pred px y the fp x is syntactic sugar for a tuple consisting of fp and x a next we define the additional transformation functions required to safely perform from a module to routines of the context that might not their contract we first define a function that models the consumption of an assertion as explained in section this function needs to be called right before making an to consume remove the footprint of the context functions precondition from the current footprint fp the structure of is identical to that of but it has to remove as footprint instead of adding it furthermore there is no need for to check that a actually holds because the static verifier already this when checking the verified module hence we do not need to use the assert and commands in the definition of cons the function is defined as follows e y e skip a a if b then else x x e fp fp x x where y removes x from the list represented by y x x e fp x x where implements the consumption part of the predicate checking routine for p defined as routine x res fp y with a the body of predicate pred px y a now we just need a function that can generate for routines rx of the context this function takes a mapping from routines to contracts corresponding to the of functions defined in the context for r is defined as routine p x s p res rx s p asserts s res f p res where we assume all introduced variables are fresh and returns a of the contents of the footprint x corresponding to calculating the hash of the footprint as described in section finally we can define the full transformation function ca using a function c as follows x rx f p x p x where r is a routine of the context and is the name of the stub routine generated by c c c c if b then c else c if b then c else c x alloc x alloc fp fp fp fp c c for all other kinds of c the full transformation function ca then is ca fp c safety and precision we now come to the two crucial properties our transformation must have safety and only state the theorems here but leave the full proofs for our extended technical report we first need a new definition before we can state these main theorems definition the function returns a variant of the program how works is of no importance to our formalization but one can see that the command could be used to check each memory location before accessing it thereby preventing failure the safety theorem states that if the context does not fail but does not necessarily its contracts either then the module will never fail theorem safety for any command c environment assertions and such that c and an arbitrary context we have finally our precision theorem states that our transformations do not change the expected behavior of the module when the context its contracts theorem precision for any command c and assertions and such that c we have that the condition means that the context the contracts specified by under standard separation logic this means other conditions that context functions cannot read outside the footprint specified by their precondition however our precision theorem can actually be slightly stronger than this because the theorem holds even if the context is allowed to read outside its designated footprint as argued in section prototype performance we have implemented the transformations described in section as a translator written in ocaml this translator e n x e e e e c x e x x x x x rx if b then c else c x alloc skip c c b true f e e e e ¬b l n n x y z vars routine routine rx c program figure syntax definition of our imperative language e e c evaluation contexts s h trap s h trap s s st e sn s sx n st s h ex e s h skip s h c s h ec s s st e s true s h e then c else c s h ec s s st e s f s h e then c else c s h ec s s st sx l s sx n st s h ex x s h s s st sx l l n h h hl sx s h ex x s h s s st sy n s x n s r routine rx c call s h ez ry s h ec z ret s s s st s s x st return s h ex ret s h s s st l l l n h s sx l s h hl n alloc s h ex alloc s h s s st sx l l n h h h l n s h s h s s st x sl s h s h s s st x sl s h s h trap s s st b s true s h b s h s s st b s f s h b s h trap figure smallstep operational semantics of our imperative language b s true h pure s h b s b s true s h p s h b p q s s pred px y p e sn x n h p s m s y predicate s h pe z sz m s h p s s h p q s s h q s s h p q s pred px y p x n h p s s h pe z e sn sz s y s e sn h assign s h y e sy n s h top s e sl h l n pointsto s h e x sx n b s f s h q s s h b p q s s h p s s h q s h h h h h s h p q s where h h domh domh s h p s s h q s s h p q s h h h e sl h l n sx n s h e x s s h p s negation s h ¬p s s h p s s h p assertion figure semantics of our assertion language module call return return check hash assertion assertion module validity footprint footprint x pre x x x x post x x x figure actions performed for all types of boundary transitions takes as input a verified c module with annotations including annotated function for any function of the context called from the verified module and outputs a version of the module the translator significant parts of the existing such as its parser and typechecker although prevents us from the source code at this time a binary version of the translator is available online the translator has been by the popl evaluation in the sections below we describe the results of the performance impact of the inserted runtime checks versus the verified module without any runtime checks we ran and macro benchmarks on a standard system without a protected module architecture in order to quantify the overhead of just the runtime checks and we discuss the additional overhead introduced by a in section all benchmarks were compiled with gcc using optimization level and were executed on a system with a intel core i cpu with of ram running the hash function used to calculate the hash over the footprint when performing an is benchmarks since our transformations introduce checks at the boundary between the verified and unverified part there will be a performance overhead when the boundary during a boundary check up to three actions are performed checking whether the assertion pre or postcondition holds adding or removing the assertions footprint from the footprint description maintained by the module and hashing the memory in the modules footprint description figure shows which actions are performed for each kind of boundary transition we measured the contribution of each of these factors using two benchmarks based on simple data structures similar to those used in the first benchmark is a verified module that takes as input a linked list of integers and sorts it using insertion sort the second benchmark is another verified module that does an traversal of a binary search tree to produce a sorted linked list both modules have been verified for memory safety ie not for full functional correctness the entry point signatures of these two modules are as follows struct l req struct req v v figure shows the distribution of execution time over the different actions performed by the runtime checks for these benchmarks for input lengths of and elements the number time fraction x x x x x xx x x x x insertion sort to list to list code validity fp hashing figure the execution time distribution over the different runtime checking actions for our benchmarks for different input lengths the numbers above the indicate the total execution time overhead in comparison to the code above each bar indicates the total overhead in comparison to the code the left bar shows that for small input sizes the insertion sort module significant time modifying the footprint description and checking assertion validity as the input size increases however the relative overhead due to these actions to the point where it becomes this is because modifying the footprint and checking assertion validity are on operations that are only performed when entering or the module and insertion sort is a on algorithm hence the time spent doing useful inside the module increases faster than the time spent performing runtime checks no time is spent on hashing because the benchmark does not make any the middle bar shows that the module almost all of its time hashing its footprint resulting in a performance overhead that increases with increasing input size this is because the benchmark performs an to malloc for each node of the input that it the memory for the output list is allocated while traversing the input because hashing the module footprint is an on operation and it is performed n times we have an on hashing overhead since the to list algorithm itself is only on the hashing overhead quickly dominates the execution time it is however possible to reduce the hashing overhead to on by using a slightly modified algorithm that first the size of input and then allocates memory for the entire output list with a single malloc call this will cause the module footprint to be only once instead of n times the performance overhead of this algorithm is shown in the right bar of figure while the relative overhead is still significant it now remains constant with increasing input size this shows that the choice of boundary between verified and unverified code and the number of times this boundary is can have a large impact on performance macro benchmarks while the benchmarks from section show how the execution time overhead is distributed over the different actions performed during a runtime check they do not show the major advantage of our approach the fact that there is no performance impact on code running completely in the verified or in the unverified part but not between the two to show this effect and to the realworld feasibility of our approach we have constructed three realistic macro benchmarks in which we verify and a small part of an application but leave the of the application unverified we measured both the execution time and memory overhead for these macro benchmarks modules the first two macro benchmarks are modified authentication modules which are used by the web server for verifying user for instance as part of http basic authentication the first benchmark is based on the module and uses a single pair of valid in memory the other benchmark is based on which reads the list of valid from a file on disk both modules provide a single entry point function that takes client sent to the web server by the browser as input and returns an integer indicating whether or not they are valid the signatures of these functions are shown below int u char p req user pass user pass result user pass secret result true result int u char p req user pass user pass the modules code consists mainly of a number of to various io and string processing functions of the standard library in particular the module performs such per http request while the module performs as can be seen from the signatures above the module has been verified for full functional correctness while the module has only been verified for memory safety but this makes no difference at runtime the path of the valid file has been in the source of the module we set up the version of to serve the default sample with a database we used the http server tool ab to measure the time required to perform http requests using concurrent client threads the client and server were executed on the same host to eliminate any network and we made sure the web server did not use any form of caching the memory overhead was measured by comparing the set size of the modules the first two rows of table show the results for the benchmarks the execution time overhead is low at and over three runs for the and module respectively the memory overhead is also low at and the difference in overhead between the two modules is due to the different number of they perform and because the module needs a relatively large buffer for reading lines from the password file this buffer is part of the modules footprint and hence needs to be described by the footprint description and when making the is an with many current linux distributions it contains a function that is used to determine whether the names of users trying to log in appear in the file of blocked users we have verified this function and have moved it into a separate module which we then with our prototype translator the signature of this function is shown below int char name req fn n fn n the implementation of this function is quite similar to the module performing to var io and string processing functions per session the benchmark consists of performing sessions using concurrent client threads where each session consists of a user in a file and then again the third row of table shows the results obtained by taking the average of three runs both the execution time and memory overhead are again low our claim that realworld applications consisting mainly of unverified code plus a small module only a small performance overhead overhead as explained in section our runtime checks assume a controlflow safe execution model which we propose to achieve using a fully abstract compilation of the source code to a since the and macro benchmarks described above were performed on a standard system without a their results do not yet represent the overhead of our full approach while recent developments indicate platforms will be available for systems in the future the currently available for systems are still in an experimental state which us from running our benchmarks on top of them in order to still quantify the overhead of a fully abstract compiler and a we developed a benchmark to be run on which is a for the prototype consists of a fully abstract compiler towards a small bit based on the ti of and of ram the benchmark consists of a module that provides a function for calculating the of a linked list of integers similar to the code example given in section the functions precondition asserts that the list is a valid nonempty linked list and its body performs three one to copy the list one to sort the copy and one to free the copy before returning the hash function used for this benchmark was the results indicate the overhead of both the compiler and the platform is below reducing hashing overhead the benchmarks show that considerable time can be spent hashing the modules footprint one way of reducing this overhead is to do away with hashing and instead copy the entire module footprint contents to a secure location in memory eg the private memory region when making an and to check the footprint against this copy on return experiments show that this gives a performance benefit of between and in comparison with hashing but it obviously requires much more memory another potential performance issue is that as the verified of an application grows the size of the modules footprint grows as well which means more data must be on each boundary transition however as the verified grows the part of the data that is used exclusively by the verified part of the application is likely to grow as well hence this data can be placed in private memory where it can be accessed only by the module and hence need not be on boundary transitions an interesting way to solve both issues is by taking advantage of hardware page protection support to reduce the amount of data to be on boundary transitions if an entire memory page is part of the modules footprint it can be marked readonly in hardware before making an and be to readwrite access on return however memory pages are typically at least in size making this approach too to be used directly a hybrid approach where pages that are completely in the footprint description are set readonly and the rest of the footprint is or copied is but we consider it out of scope for this paper execution time s overhead set size overhead table the macro benchmarks show a low realworld performance overhead in terms of execution time and memory consumption summary our benchmarks show that the performance overhead of the runtime checks can be significant if there is little computation in or outside the verified module compared to the computation required for the boundary checks most of this overhead is due to hashing the modules footprint and memory regions the footprint description nevertheless the macro benchmarks show that this overhead becomes once more computation is performed in the unverified context hence when developing modules to be verified and it is critical that the boundary between verified and unverified code is chosen that is developers should try to minimize the number of boundary in order to minimize the performance overhead although we could not run our full set of benchmarks on a system a separate benchmark performed on indicates the platform overhead is these results demonstrate the practical feasibility of our approach related work separation formal verification ensures memory safety which can be considered one of its main advantages for memory unsafe languages such as c there are however many other solutions for making c memory safe such as and these systems rely on a combination of type system extensions static analyses and runtime checks to ensure memory safety but make no attempt at providing correctness guarantees beyond that furthermore these solutions protect against while we protect against more powerful ie that have already the ability to execute code in the unverified part the idea that software modules should specify contracts in the form of pre and postconditions was by meyer in the programming language such contracts can then be checked statically or dynamically and there is a amount of literature both on static and on dynamic checking of contracts some examples include the java modeling language based tools and net contracts we rely on fully abstract secure compilation for providing a controlflow safe execution platform and ensuring the soundness of our runtime checks in the presence of code injection attacks full abstraction was by abadi and has recently been used as a basis for secure compilation to machine code and javascript a related approach is that of ts a subset of javascript that ensures even when interacting with an untrusted javascript context although the techniques used in ts are different from our approach this work shares our goal of providing a robust foundation for code while still allowing interaction with an untrusted environment in the remainder of this section we limit our attention to the most relevant and closely related works our approach combines modular static verification with runtime checking to achieve a nontrivial soundness property in the context of an unsafe programming language the approach is based on separation logic so that there is a clear notion of memory own and we can compute the footprint ie the owned region of memory of a module and take a of that regions contents for our implementation and experiments we have used the separation assertion language and static program verification tool for c and java other separation program include and space another modular static verification tool for c programs is however instead of separation logic it uses a verification logic that is based on ghost variables so it is not clear how one would generate runtime checks for module specifications written in annotation language runtime checking of separation logic assertions is known to be challenging because of the frame rule a related approach is that of et al although some of the techniques used in their approach are similar to ours eg tracking and splitting predicate parameters into input and output parameters their objective is different from ours their runtime checker aims to as close to the standard separation logic semantics as possible while our approach only aims to ensure that no failures can occur in verified code we can hence allow unverified code to read arbitrary memory which is not allowed under standard separation logic et al use a heap coloring technique and runtime checks at every method invocation and field access in unverified code to check this introduces a large performance overhead on the order of × if all necessary checks are done that increases as the size of the unverified code grows as shown in section the relative performance impact of our approach decreases with a larger unverified also since the implementation of et al needs to unverified code the entire must be whereas we only need access to the verified module finally the implementation of et al is for java so they do not address the complications related to the lack of memory safety of c another related approach is that of in which runtime checks are used to protect c programs from data attacks developers must annotate critical data structures with special type declarations from which point on they should only access those data structures using those special types in its whole program protection mode runtime checks are inserted throughout the entire to detect illegal accesses to the critical data structures causing a large performance overhead in its library protection mode however only the memory accesses of a small core of the application corresponding to the verified module of our approach are instrumented critical memory writes in the core are modified to maintain a copy of critical objects on separate memory pages which are made readonly using hardware page before calling untrusted code critical memory reads in the core are instrumented to check consistency of both copies thereby detecting writes to critical objects from untrusted code the library protection mode is similar to how we enforce the separation logic frame rule in the sense that critical regions of memory are integrity protected when calling untrusted code our solution provides stronger guarantees than since we ensure validity of arbitrary separation logic assertions instead of only data structure integrity also does not prevent untrusted code from the page making it to attacks in the unprotected part finally although the performance cost of library protection mode is low it grows with both the number of boundary and the number of reads and writes to critical data in the core part of the application et al described the runtime checking of annotations for c programs in the context of the platform is an executable subset of a behavioral specification language for c programs both function contracts and annotations can be specified and can be translated into runtime checks by the translator in order to perform such runtime checks each memory allocation deallocation and variable assignment is instrumented to record information about the modified region of memory into a data store this store hence contains a copy of the programs data and some meta data about it the runtime pre post and annotation checks query the store in order to determine the annotations validity although the approach the use of static analyses to statically discard some of the runtime checks there is no notion of a verified and an unverified part hence the entire program must be instrumented for the checks to be sound and complete this results in a high overall performance cost ranging from × to × the problem of checking contracts at the boundary between statically checked modules and modules has also been studied extensively in higherorder programming languages findler and felleisen this line of work and proposed higherorder contracts which have been implemented in the programming language the main challenge addressed is that of function values passed over the boundary of such function values with their specified contract is generally undecidable but it can be handled by the function with a wrapper that will check the contract of the function value at the point where the function is called this is similar to how we handle function pointers the corresponding contract is checked when the function is called one concern that has received extensive attention is the proper assignment of blame once a contract violation is detected while this line of research shares our goal of safely composing a statically checked module with an module the issues of higher order contracts and blame assignment are largely orthogonal to the problems we address in this paper conclusion separation verification of c code is a powerful technique for the absence of code failures however verifying large programs is difficult and requires significant and effort modular verification tools support partial verification where only the most critical modules are verified and where over time more and more modules get verified unfortunately this kind of partial verification gives only limited guarantees at runtime bugs in the unverified part of the program can also impact the state of the verified part and hence might trigger failures in verified modules we have proposed a way to transform and compile partially verified programs such that the runtime guarantees are significantly better without performance after our code transformations no failures can ever occur in the verified module if a bug is in the unverified part of the program this is detected before it can impact the state or control flow of the verified module this is useful for testing as it detects bugs faster and for security as it can guarantee verified properties of modules even in the presence of code injection attacks against the unverified part of the program acknowledgments we thank and our anonymous reviewers for their valuable comments and suggestions that have improved the quality of this paper this work has been supported in part by the intel university research and by the research holds a phd of the research foundation references m abadi protection in translations in proceedings of the th international colloquium on automata languages and programming icalp pages ­ london uk uk springerverlag isbn p r b and f secure compilation to modern processors in proceedings of the ieee th computer security foundations symposium pages ­ dc usa ieee computer society isbn url p b and f sound modular verification of c code executing in an unverified context extended version technical report cw url t m austin s e and g s efficient detection of all pointer and array access errors in proceedings of the acm sigplan conference on programming language design and implementation pldi pages ­ new york ny usa acm isbn x url m and w runtime verification of net contracts j syst ­ mar url j berdine c calcagno and p w ohearn modular automatic assertion checking with separation logic in proceedings of the th international conference on formal methods for components and objects pages ­ berlin springerverlag isbn url l y d r m d j r g t k r m leino and e an overview of tools and applications int j tools ­ june url s c calcagno d and v vafeiadis resource invariant synthesis in proceedings of the th symposium on programming languages and systems pages ­ berlin springerverlag isbn url wn c david h h and s automated verification of shape size and bag properties via userdefined predicates in separation logic sci comput program ­ aug url e m m d m t w and s a practical system for verifying concurrent c in proceedings of the nd international conference on theorem proving in higher order logics pages ­ berlin springerverlag isbn url m m t s and w modular verification of concurrent c in st international conference on software engineering pages ­ may c r b findler c flanagan and m felleisen correct blame for contracts no more in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn url d and m j parkinson j towards practical verification for java in proceedings of the rd acm sigplan conference on objectoriented programming systems languages and applications oopsla pages ­ new york ny usa acm isbn url u lowlevel software security attacks and in a and r editors foundations of security analysis and design iv pages ­ springerverlag berlin isbn url r b findler and m felleisen contract soundness for objectoriented languages in proceedings of the th acm sigplan conference on objectoriented programming systems languages and applications oopsla pages ­ new york ny usa acm isbn url m and plt reference technical report plt inc c fournet n j chen pe py and b fully abstract compilation to javascript in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn url m b c pierce and s weirich contracts made manifest in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn url j p i l wang and s wu analysis of report http intel corporation intel software guard extensions url http pid b and f expressive modular finegrained concurrency specification in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn url b j and f a quick of the program verifier in proceedings of the th conference on programming languages and systems t j g morrisett d m w j and y wang a safe of c in proceedings of the general track of the annual conference on usenix annual technical conference pages ­ berkeley ca usa usenix association isbn url g k g j d p d k r m t sewell h and s sel formal verification of an os kernel in proceedings of the acm nd symposium on operating systems principles pages ­ new york ny usa acm isbn url n g and j an optimized memory monitoring for runtime assertion checking of c programs in runtime verification th international conference rv france september proceedings pages ­ url j m b j a m k and h an execution infrastructure for minimization in proceedings of the rd acm european conference on computer systems pages ­ new york ny usa acm isbn url http b meyer applying design by contract computer ­ oct url g c necula s and w typesafe of code in proceedings of the th acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn url h h v and wn runtime checking for separation logic in proceedings of the th international conference on verification model checking and abstract interpretation pages ­ berlin springerverlag isbn url j p w r a van c b i and f extensible devices with a trusted computing base in proceedings of the nd usenix conference on security sec pages ­ berkeley ca usa usenix association isbn url http m p r b d clarke and f secure compilation to protected module architectures acm transactions on programming languages and systems toplas accepted for publication in acm toplas p j t w j b and f software verification with case studies science of computer programming ­ mar url j c reynolds separation logic a logic for shared mutable data structures in proceedings of the th annual ieee symposium on logic in computer science lics pages ­ dc usa ieee computer society isbn url c k n d walker and b modular against data attacks in proceedings of the ieee th computer security foundations symposium pages ­ dc usa ieee computer society isbn url r and f software application components against or in proceedings of the acm conference on computer and communications security ccs pages ­ new york ny usa acm isbn url n c fournet a k j chen py and g gradual typing embedded in javascript in proceedings of the st acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn a s l j j and a design implementation and verification of an extensible and modular framework in proceedings of the ieee symposium on security and privacy sp pages ­ dc usa ieee computer society isbn url 