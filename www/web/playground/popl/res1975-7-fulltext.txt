actor semantics of and massachusetts of technology cambridge massachusetts abstract on and actors has led to the development of a for semantics of programming languages its value in describing programs sideeffects and synchronization m discussed formal definitions are written and explained for sequences cells and a simple synchronization primitive jn there is discussion of the implications of actor semantics for the over elimination of sideeffects a fo fo semantics is usually developed and presented m some context which it might be designed for the purpose of the definition of a specific language as a guide to programmers and the formalism might be used as the means for describing properties of a particular program or as a basis for a set of proof rules for verifying properties of programs the motivation for this paper is development of a semantic base not fol some particular programming language but rather for a of the systems of interest are those which and synchronization the concepts systems particular which must be available to express properties of these be presented and examples given however no programming language will be used our approach to the semantics be on the concept of an actor an actor is simply an object which can send or messages all elements of a can be viewed as actors the only activity possible is of one actor to another actor the energy for comes from an which can follow the script of an actor all programs and systems will be referred to as actors the existence of more than one indicates parallelism continuations once an actor m is transmitted to another actor t the proceeds by following the of i using information from m for this to be of any me as a model of computation it must be possible for m to have some structure in many cases m will simply contain a message it will often also contain a continuation part then m may actor semantics was not developed to explain or define m a language to the direct realization of this semantic base be as apply message continuation if a is sent a continuation then all further instructions computation most be by the target a makes it possible to indicate another actor to which control can be passed ie an actor whose script the may follow the reason that it m useful to be able to about in a semantic is that otherwise much of the has io implicit in like an evaluator or a s a pattern of passing messages m a it should ie possible to between say recursive and computations as being two different patterns of message which can be precisely an ordinary functional call to a function f can be implemented by passing a with an explicit continuation to f the continuation represents actor to which the value of f should be sent in other kinds of control structures can be expressed such as jumps m which no continuation u present and see appendix distribution of information information can be m various ways in an actor system often it o represent knowledge with different uses of the same appearing m different in several places how one might choose to it depends on ones purposes and the various uses to which the knowledge can be put on use as the key to representation of data structures with the approach of on the notion of type van for example in and the usual operations on lists there is in how the information about the structure of lists may be operations and the data themselves one m the function call denoted by l can directly produce the length of the list l that is the operation length could be defined in such a way that it knows enough about how are constructed and about how they can be decomposed to be able to operate on the list directly and to compute its length for example operator length could repeatedly ask the list l for its next element and keep a count of the number of times it succeeds the length might know nothing about and when sent one would have to depend on the list itself to understand its own and to understand it m terms of the concept length among others what happens in this case is that length l around and l for its this makes sense for fixed lists since for such lists the information never changes and need only be once this style of definition is particularly useful for polymorphic operators in an interact system where new of objects which share some of the properties of can be at any time it is desirable for length l to continue and to extend correctly to new data types that are defined when information can be put it seems natural polymorphic operators can be defined without of type checking instead the operator can be applied to any type of data and t ts up to the data to determine whether it is a reasonable and if so how to perform its operation depending on either style can lead to a more efficient implementation but both should be representable behavior of an actor actors are defined by their behaviors a behavior is a partially ordered set of events which represent the behavior only a single process is a sequence of events a description of the behavior of an actor has at least two uses first lt defines the actor secondly it the properties of the actor which can be on in a proof about properties of another system in which it is contained the event ot to m well suited o the expression of meanings of programs with sideeffects and parallelism rather than to record the current state of the world in something like a state vector changes in state are reflected in changes over time m the behaviors of the actor cells the event approach is particularly useful when there is as well as change in state if one tries to record all possible global states including control for all the processes one can become in a combinatorial of states in order to describe the effect of a change in a cell using global states one would have to make the corresponding changes m the state for each of the processes which could be active level of detail in describing computations another degree of in actor semantics involves the amount of o be included in specifications that is an actor can be specified or its set of possible behaviors can be specified in as much or as detail as is desired in an existing actor system this level of detail is fixed by the choice of a set of distinguished actors contained m the actor system only events these actors be recorded as behavior of the to specify desired behavior of a system one writes axioms which any of the system must satisfy at a very high level of detail these axioms essentially be inputoutput constraints ie what is to be done not how if more detailed specifications are made the behaviors which will realize those inputoutput constraints become more restricted generally in note that while the as a source of energy for computation may be analogous to some notion of process the is definitely not meant to any of the following concepts program counters pushdown stacks or address spaces order to prove that a set of specifications is satisfied by a particular one the behaviors of the system at a level of greater detail than that of the and proves that these behaviors realize the behavior that is required these points should give some of how the simple actor concept can be used as a block to define the higher level concepts which are useful tools after the formal definitions of behaviors of actors in the following section we will give definitions of several familiar systems the application of these concepts behaviors since actors are by their behaviors the concept of behavior have to be defined behaviors consist of events definition an event is a t m a ec where t is the target m is the a is the and ec is the event count of the a as stated an event is a description of the transmission of m to t by a since the events of a single are totally ordered in time an event count is also necessary to completely characterize a this means that if identical occur some particular t m and u then the two can in fact be distinguished by the proper time for ss at which they occurred the event ec denotes the time immediately after ec therefore t m a ec immediately precedes t m a cc and we can write t m a ec t m a cc for events with different t ml al t m a lf and only if at least one of tz mz az is created in the event il ml al some actors have the ability to create new actors creates an actor with the behavior of a cell creates a list etc the transitive closure of the relation is referred to as precedes ie for events el and e el e is read as e precedes e this is the ordering which can reasonably be considered to be a property of the actor system in question the relationship between precedes and the actual at which events occur m that if el e then el will necessarily occur before e in any computation other orderings may be imposed by axioms for synchronization primitive introduces precedes actors for constraints in example a the a m m a set of events partially ordered by the closure of the an external environment for an actor system is a set of actors the outside of the system this includes an assignment of an initial set of and initial events for each which will determine the of history for this system and environment these initial events will always be about which cross the boundary and enter the actor system ie events which have a target the system and a message outside the system histories are written for systems in environments the behavior of an arbitrary system of actors can be extracted from the history by choosing only those events which involve certain distinguished actors note we will consider any new actor created by an event involving an actor m the system to be in also for any history of the actor system the behavior of system with respect to the set of actors a c m the subset of the events of the history containing events m a ec where either t is m and m is not m is in z and t n not either i or m is in a thus an event be in the behavior if it describes either a transmission across the boundary of ie with target inside and outside or vice versa or a transmission with a actor as either target or message this is how the level of detail of a behavior is fixed by the choice of a note that if the set a is empty then the detailed behavior results ie the behavior of as seen from the outside two systems are equivalent with respect to some set of distinguished actors if and only if they have identical with respect to that same set of actors the choice of distinguished actors can make a difference m equivalence of systems for example two programs for factorial can be seen to be equivalent at the level of inputoutput transformation ie with no actors distinguished even if a larger set of actors would one to be a and the other to be if represented by is considered to be a distinguished actor then in any of one factorial there might be a series of events i i a i a x a and so on while in the other there might be a series n a x nl n a j n a behavioral specifications of systems since behaviors of most actors are infinite objects it not often be possible to out completely the set of behaviors of any given or desired actor and fact many behaviors of a system will contain about events in the environment instead characteristics common to a behaviors of any actor system actor in can be specified m the form of ax about events and the precedes relation these are not hoare style axioms about transformations of predicates over the occurrence of an operation or of a line of code but rather are about the kinds of events that can possibly occur in a computation and how they must be ordered when an actor m being specified as a that is when it m not defined in terms of other actors the axioms describe which must be satisfied by any any actor can be described from the outside but lf an is to be implemented m terms of other actors it should be understood that between any two events there may be an number of other events if we examine a history or even a behavior however all events related by precedes so related when we do not wish to imply that e immediately follows e we will write m the event count indicate that there in general can be used m any place in an event to we do not care about what actor or appears recall that if two events el and e are known to be in a behavior we can write el e to indicate that el precedes e when el and e have not previously been mentioned a statement of the form el e should be read as whenever ei is in the behavior then so is e and el precedes e or alternatively as if el is m the history behavior it will cause ez this is a way m which we guarantee response in finite time from an actor we will continue to use the convention on the actors the are of the following general form apply message continuation we often omit the part when it is not of interest sequences the following axioms about the behaviors of sequences summarize some of the familiar properties of sequences while the use of to constrain the kinds of behavior an actor can have note that since sequences are indeed functional objects they could have been described m more conventional mathematical notation scott and an actor which ts a sequence of n elements has the property among others that it can be for m element if a sequence is by xl xn property can be specified by the following axiom x xn apply i c cd a ec c apply xi this means at the level of detail at which sequences are black boxes the in which th xl xn is sent the message i and the c always causes as the next event the transmission of the ith element of the sequence to that continuation this transmission had three components a message a continuation and a department this last actor is the one to which messages are sent if the target actor does not its message for instance for i n it is the case that the sequence satisfies x xn apply i c cd a ec cd apply ix cc when using axioms as of all possible one assumes that for any messages not explicitly dealt with the actor being described causes to be sent to the department thus at this stage m the it can be assumed that any transmission apply x c cd a sequence where x is nor a sequence containing an integer causes to be to cd cells do not as a functional a cell is created with some contents it is possible to ask for the contents of a cell messages to that cell can its contents thus it is possible that several events in a single behavior can have targets namely the cell and identical and yet cause different events to occur this occurs when the events have apply contents continuation but the contents have been changed between the two events in each case the continuation is sent different actors this means that cells are primitives speaking an actor system has a sideeffect if its behavior has changed over time in terms of functions a sideeffect has occurred when the same procedure p has been called on two different with the same argument and returned different values this can be generalized to behaviors by looking at future rather than just at values returned cells correspond to sideeffect primitives in various languages it is likely that most readers have on them m programming we will now try to formulate exactly which properties we have been on first would be that creation of a cell or allocation of space for a cell with its initial value should be an guaranteed to take only finite amount of time this is also a property of updates and contents queries who has that a given program which contains statements always terminates has on these properties axiom cells apply x cl a apply cell where cell is a newly created actor axiom i cells can to contents queries and updates cell apply contents continuation cd a ec continuation a e cell apply x continuation cd a ec continuation apply cell c cc notice that a cell returns itself not hs value after update newly created actors are marked in events by an it is often useful to be able to tell explicitly when an actor a appears for the first time m event e since for any other event el in which a occurs it must be the case that e el the next two properties that we rely on are related initially we expect contents to find the original contents in the cell this should be true until an update transmission is sent similarly once an update is sent say y we would expect to find y in the cell it is upd thus two more axioms are required one about the initial contents and the other about the last contents stored says that if cell first appears in event el and if no update occurs between el and contents query e then e will be an event which sends the initial contents to the continuation this has implications for the knows about which can be formalized and has implications for control structure recognition and implementation details see appendix axiom contents a cell created with x as its contents will to the message contents with x if no new value has been explicitly placed there yet suppose that po el is in the behavior where e is apply x c cd al el is c apply cell ccl ec if are events e e where el e e e is cell apply contents c cl e is cl apply y a and e e e e where e is of the cell apply then yx axiom makes a similar statement about the last contents stored by an update rather than about the initial contents the only significant change from the statement of axiom is that e is cell apply x c cd a unfortunately these axioms are reasonable only in the absence of since we are ignoring the fact that only refers to imposed by the program in programs without parallelism it is the case that time constraints imposed by the program form a order on events making these axioms sufficient also due to the nature of the cell m the absence of its use does not really increase power see appendix but in there may also be update events occurring independently of this ordering in a such as cell apply apply c a ec c apply cell a cc c at cell apply c a c app y cell al c apply cell a cell apply contents c al i c apply al the message place marked by the question mark can represent either the message or which actor it will be is not a property of the axiom force it to be the obvious n to weaken the axiom from saying exactly what has to be returned to the to just restricting the set of actors it could be the last line of axiom to say that y is n the set e is apply z c cd a e e or e e that is y can be the initial contents or any value stored in parallel with this should be similarly such that the contents could be the contents stored in the last event to the contents query or m any update which is parallel to the now observe the following behavior apply c ec c apply cell a cc d cell apply c al cell apply a cell apply contents c a i cell apply sy c apply cell apply contents c al c apply al in fact out about the contents of cells is that it is even more restricted than stated because if has value then can no longer have any value in but rather can only have values m there many examples m which we can make that restrict the contents of a cell these are actually about constraints in to those imposed by as to the order in time in events could have occurred a first to these examples might be that although the current definition it may be reasonable to accept behavior once nondeterminism is a possibility perhaps we simply should not rely on any contents in situation however are times when we do rely on the behavior of cells even m the presence of parallelism for instance several solutions to the mutual exclusion of critical sections which do not make use of di knuth implicitly make use of the cells its last contents stored even in the presence of parallelism we found that the fact from which all our about reasonable behaviors were made was that contents had to be consistent with some possible total ordering of all references to that cell in that ordering each time the contents is checked it must agree with the last contents stored thus cells allow one to make about the actual order m which events occur even though the events may not be necessarily ordered by this is the property of cells which makes it possible to use waiting to independent processes axiom in any an actor cell created by it is possible to a total ordering on all events which have cell as target this ordering has the properties that if el and e have cell as target then e e el e if el e where el cell apply contents c a ec and e c apply x a cc then x is the contents with respect to the last contents defined for an arbitrary respect to stored with respect to an ordering can be total ordering and used in axiom with for the event e the last contents stored in cell with respect to the ordering is defined to be either the contents f cell is created m e and there is no update event e such that e e e or the actor stored m update e if e e and there is no other update e such that e e e there can still be since although in any computation the events referring to a particular cell can be totally ordered in fact only parts of that ordering will be forced by the actor system synchronization synch m the in the total order it imposes total ordering on all events involving it this means that if some synchronization actor always a cell it would never be necessary to about unordered updates and contents queries the would impose an ordering and the cell would always contain the last in the precedes relation contents stored this is part of a general form for specifying behaviors of any system using synchronization there must be an axiom to the effect that an m imposed and axioms about other properties of the system can be dependent on this ordering one way to protect a cell would be to define a primitive which can create cells and protect them should have behavior satisfying apply x c a ec c apply a cc in order to the behavior of it is necessary to describe m some more although its means of synch can be left the fact that it contains a locally known cell and this cell n m a actor which is known to the world should be the behaviors of also satisfy apply x c a ec apply x c a where c has which satisfy c apply cell a c a now we can describe the behavior of axiom from the outside a protected should look like a cell apply contents c u ec c apply c a cc and apply c a ec z c apply a cc the rest of the of can be inferred further details about what it does with its messages axiom sends messages to cell apply x c a cell apply x cx u where cx t a ec c t a cc thus behavior of cell has sideeffects because its behavior reflects the axiom adds ordering to a behavior if el e and e e where e apply x c al e cell apply x cx a e apply x c u e cell apply x cx a then either e e this says that in the interface between and cell there n locking and going on which causes all events with cell as target to be ordered by precedes the exact mechanism cannot be seen at this level of detail but it exists axiom given el e e and e as above and e e then in fact e s apply al e that is the event m which a response is made from the cell and allows another transmission to the cell thus c x must know how to free the cell again since the synchronization mechanism m primitive we cannot see the chain of events the it is simply a property of this that it causes the protected cell to let else get to the cell now from the point of view of the cell all events are totally ordered by precedes f cells were always used inside only the simpler single axioms for cells would be interesting the more complex global ordering constraints can be from a understanding of synchronization which imposes ordering and of cells which remember their contents conclusions we can express characteristics of a sideeffect primitive in the of parallelism sideeffects are described by of possible changes in behavior rather than in a state vector synchronization can be used to impose additional ordering constraints further research is in progress on applying this semantic to synchronization actors similar to monitors hoare once a expressive set of descriptions is developed we will implement some systems such as an system or a to the problem and correctness to descriptions the formalism can also be used m studies of the behaviors of a variety of control structures an example of this of work a result on elimination of cells presented in the append ix concerning sideeffects there m some at present over the and of use of sideeffect primitives a result to the effect that cells or other sideeffect can be eliminated from programs and that this can be done certain bounds on loss in efficiency m given before starting our of this although this result may be of little help in deciding which way to program it does show that it is possible to avoid sideeffect primitives if that is your m the least which must be known before discussion is meaningful also when considered in light of the actor semantics of this fact can be seen to be true even m the presence of iteration generators and we present the result with informal argument rather than proof and then proceed with discussion of sideeffects ur control and data structures there is a uniform procedure for eliminating cells from with sideeffects it causes at most an n in n vs n loss of efficiency in time and at most a c m vs m increase in storage where c is a constant the general idea is that instead of having cells with contents which can be changed the system has to keep track of these contents in some format which can be referenced by the cells name we call this object a map then whenever the contents of a cell is needed it can be found by the map whenever the value of a cell named n is to be updated to v this change must be simulated without an actual sideeffect that is the existing map can not be changed by the operation of updating the of a cell can be accomplished by creating a new map which we shall call map whose is identical to that of except that when for the contents of nl it must with v the new map map must be the one examined m the future on all update and content operations on cells all statements cells must have access to the current map the way to give them this access is to always pass around the current map this can be done m programming languages by passing around an additional argument namely the map to ail the map would then be available as a local variable in each procedure body in this would be done by rewriting sequential code to pass the map from one statement to the next so that the simulated propagate through the sequence in both cases all creation of new cells and all updating or accessing of the of cells will be simulated by operations on the current map in an actor based m which the basic operation is the of a message actor to a target actor the current map must be in all messages we continue to use the message passing to in the bound on loss of efficiency in with this decision time n measured by the number of which must occur can be thought of as taking one unit of time although an amount of real time may pass between on how the program is being the of the map to each only linearly increases the time taken the comes in the number of t needed to look up in the map the bound s based on a tree structured implementation of the map it is well known that a tree with n nodes can be or copied in proportional to in n thus at any if there are m nodes in the map a of a cell statement updating accessing causes extra in a number proportional to in m at the nth of computation there can be at most n in which a cell was created and the size of the map increased the a computation of n can be in at worst n in rr the bound on space is based on one possible physical storage the tree f it m stored in the form then if the original computation created m cells realized in m location the requires qm ions of the theorem also called references and ions in the literature are objects are very commonly used in current generation the very common use of cells needs to be m the light of the discovery of of programming do not use of cells the following are some points from sides of the argument the use of cells can introduce a time variant behavior in systems makes them harder to understand and the variant behavior can make it much harder to prove and verify properties of because some of the assumptions which have been established in the middle of a module as a result of conditional tests can be by invoking a procedure with sideeffects at the level of hardware the use of causes for computer systems which use buffer cache memories unless expensive are taken two processors might load the contents of a cell their respective caches and update the contents in the actor model the intuitive of one object pointing to another has been formalized into one actor about another so the former can send to the the use of cells can introduce cycles into the graph of the about relation for actors the use of a reference count scheme for garbage collection impossible on the other hand the reference count scheme for garbage collection itself puts a substantial efficiency on systems and may not be the most way to do garbage collection an alternative scheme is to run a conventional copying garbage collection in parallel with regular computation also a style of programming without cells creates more than a style using cells many have become to using cells in their and are co change without a very reason just as many of the programmers who have become used to using the are to give it up on a more level some note that a sideeffect is a of behavior that is very important in the world in which we and feel that this of behavior should be directly in the computational primitives available for use by programmers also there are cases such as communication between two processes running m parallel where cells are required programming which do not use cells note that the of cells theorem applies to actor systems with access to as opposed to the acalculus where there is explicit access only to the message part of a transmission thus it applies to systems with iteration generators and eg systems as powerful as et a which use but not real parallelism each of the above control structures has its own programming style which does not the use of cells we these and the tradeoffs involved using examples below this is similar to the use of continuations as in fischer iteration and sideeffects control structures can be realized il the and thus without cells we will give a simple example to illustrate how this is done label a n a then a else n n a of course the above m also a recursive definition of in the sense that it is defined in terms of however in of the actor semantics it is not a recursive definition in the sense of languages it does not use up arbitrarily large amounts of intermediate working storage in order to do the computation using the actor semantics the of factorial is m both of recursive label a n then n factorial n the reason that storage increases is that the number of actors currently pointed to known about continues to increase actors which are to are not for garbage collection after formalizing the knows about we can demonstrate that only requires a bounded amount of working storage conceptually every actor a consists of two components which are i ly bound together a data part and an action part called a script the data of an actor consists of a finite set of actors known to the actor and the script of the actor consists of a of what to do if the actor m sent a transmission we shall indicate that an actor a knows a set of actors a by the notation aa a fundamental restriction of the actor model of computation is an actor t can only be sent a if it is known to the more formally the restriction can be expressed as follows if an event a ec tm a cc occur in a behavior then it be the case that t and m are either the same as ml or are known either to or to ml ie t and m are restricted to being in the set ml an actor aa created by an event tt mm a ec is restricted to knowing about a subset of the union of the actors known to it and the actors known to m ie a is restricted to a subset of t u m any event e which refers to aa must be by the event which created t we each newly created actor is not to any actor more formally the requirement is that for any x it must be the case that xa where is the usual the above restrictions express a kind of locality or restriction for actor systems we can demonstrate that does not use arbitrarily large amounts of working storage by analyzing the computations of and observing the structure of the knows about relation in the course of the computation some ry actors will be created but only one such temporary will be needed at any given instant this establishes an upper bound on the amount of temporary sto age needed generators with and without cells we shall demonstrate how to define generators with and without cells by generators that produce the etc m sequence on demand using a device called streams by peter we develop implementations that use the same interface with the polymorphic operator next which requests the next element the interface u defined in such a way that it work streams with sideeffects and mitchell n as well as with functional streams the polymorphic operator next which makes this happen works by around and passing the to using the message next to ask for its next and to to if it doesnt have a next a stream consists of two components a first which is the next element in the stream and a rest which is another stream that holds the rest of the elements after the first below we define a stream that produces integers are up to some limit it produces the next larger square each time it is for it and returns the square along with a stream for generating more to construct a stream of receive a sequence of a limit of how many to produce and a count from which to begin producing then return an actor which when either to produce the next element or to to a if it doesnt have one checks count o see if it is greater than the limit and if so to the otherwise it returns a stream which has the square of the count as its next element and rest which is a stream of with the same limit but whose count is one greater than the input count below we define a polymorphic operator which the elements of any stream which it is given for example limit count will print and then print done to of a stream receive a stream ask the stream for its next if it has a next receive the stream and bind its first and rest print the first of the stream then of the rest of the stream if the stream has no next print done below we define a port a stream with side effects that produces square integers up to some limit it produces the next larger square each time it is for its next returning itself with i behavior by a side effect as the rest to construct a port for receive a sequence of a limit of how many to produce and a count from which to begin producing let be a cell that initially contains the count label the actor whose behavior is defined below as return which is an actor which when either to produce the next or to to a if it doesnt have one checks the contents of to see if it is greater than the limit and if so to the otherwise it increments the contents ot the count then returns a stream which has as its next element the square of the contents of and rest which is note that we have defined the port in such a way that the polymorphic next can also be used to obtain from it thus in many cases the decision of which of the two implementations of the square generator to use can often be deferred or even later for example to their respective starting to start the system execute the following limit count will also and then print done however the behavior of is not exactly the same as that of once a port for has been then it is totally used up and has no more useful behavior there is no built into ports the burden of providing such a capability if it is desired is by the user of the port debugging a system where ports are used as the basic communication primitive can be because useful debugging activities such as the contents of a port have sideeffects in contrast a stream for does not change its behavior as a result of being and can be used for other purposes at the same time such as searching for successive whose sum is an odd prime generators can always be implemented almost as efficiently without the use of cells as by using cells except that avoiding the use of cells imposes more of a collection problem data structures and sideeffects the of programming used for generators is applicable to which behave like a variety of data structures such as stacks queues sets and making it possible to them either with or without sideeffects for example pop can a value of the form next rest the technique n also to implementing control structures such as ation and which can be implemented either with or without cells and sideeffects are a control structure which are often used by programmers in artificial intelligence and systems programming they have recently found and and m applications as the for a programming style early intelligence programs were organized as of a pass of a pass of constraint a pass of hypothesis formation it is now generally recognized that of this kind are because it is often necessary for information to flow across boundaries at all stages of the processing were introduced by to convert the separate and passes of a a single pass using cells and a coroutine control structure m a language like or can be built to do this m the following way we assume that there are four cells known globally to both the lexical analyzer and the syntactic analyzer of the compiler cell for messages to lexical analyzer cell for messages to syntactic analyzer for of analyzer cell for of syntactic analyzer the is initialized by setting and update the contents of the cell to be start goto the contents of cell whenever the analyzer has parsed the next lexical item l then it can resume the analyzer by executing the following update the contents of to be which is defined below then update the contents of to be l and then goto the contents of read the contents of return as the value of this lexical routine whenever the syntactic analyzer needs more input it can resume the lexical analyzer by executing the following update the contents of to be which is defined below update the contents of to be next and then goto the contents of read the contents of as the value of this in order to explain the of passing instead of messages we shall attempt to translate the above scheme into the and show where it runs problems the idea is very to he one used m he of cells theorem in that we will increase the size of all the messages passed around the lexical analyzer to include and increase the size of the messages passed m the syntax analyzer to include the system n started by sending start to whenever the analyzer has parsed the next l then it can resume the syntax analyzer by the l h message unfortunately the above scheme has a bug in that by the rules of the the value will be sent to syntax analyzer instead of to the lexical analyzer the bug can be fixed to produce an efficient solution by using j operator as follows let x x l x message using we indicate how to eliminate the side effects involved in between the syntactic and lexical without loss of efficiency to start the system send the message dart to whenever the lexical analyzer has parsed the next item l then it can resume the syntax analyzer by sending the apply l continuation to where continuation is an actor which receives from the syntax analyzer and the work of the lexical analyzer whenever the syntax analyzer needs more input the lexical analyzer it sends a transmission of the following form to apply next continuation when s be used we would to that we do not rewriting programs using the algorithm described in such activity s just as as rewriting programs that use the goto construct by while loops and boolean variables instead a style of programming that has certain definite advantages must be developed the theorem does not imply that the style of which we discussed above can always be used to cells further research is needed on this has in for artificial intelligence away from heavy on sideeffects as illustrated by the development of the context mechanism m qa defining worlds in terms of actors and and the between in terms of message passing smith and a programming that avoids the use of cells seems very since the programs are just as efficient and seem more readable to many people in the case of generators and not using cells the of using sideeffects but imposes some additional collection overhead the proposal to avoid the use of cells m actors that behave like data bases seems more because a great many database parallel access to the database on the several in all such cases the cells used should be within some kind of modular synchronization primitive such as i hoare or ia et al acknowledgements this research was by the mit artificial intelligence laboratory and project mac under a contract from the of research we would to thank david allen and for helpful comments which led to substantial improvements m the form and content of paper r m ports a method for dynamic communication and job control et al sim begin d and a model for control structures for artificial intelligence programming languages august m e design of a cacm july d j m reference report no theoretical unit school of intelligence university of edinburgh m y e w of a problem in concurrent programming cacm sept fischer m j lambda calculus acm conference on proving about programs jan c description and theoretical analysis using of a language for proving theorems and manipulating models for a robot phd mit february c p and r a universal modular actor formalism for artificial intelligence stanford aug pp hoare c a r an axiomatic basis for computer cacm oct hoare c a r an operating system structuring concept cacm oct knuth d e concurrent comments control on a problem in cacm may r a systems programming sigplan notices dec p j a correspondence between algol and cacm february a proving algorithms information and control by tail functions j a formal description of a subset of algol in formal language description languages for computer programming north holland d v and g j the reference al memo no mitchell j g the modular programming system processes and ports june f j a and r j qa a procedural calculus for intuitive reasoning phd stanford november scott d and c towards a mathematical semantics for computer languages oxford university computing laboratory august and towards a programming b conference july algol a report on the algorithmic language 