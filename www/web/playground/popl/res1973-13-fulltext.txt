advice on structuring compilers and proving f morris university them correct t the purpose of this paper is to an approach and to support that advice by discussion of an example towards achieving a goal first by john that compilers for higherlevel programming languages should be made completely trust by proving their correctness the author that the problem can be made much less and than the unrestricted ro problem to d so will of course restricting what a may be the essence of the present advice the proof that a diagram of the form is that a proof of compiler correctness should be source language l compile y target language t source semantics i source meanings m target semantics q target meanings u the symbols in the diagram refer to the example to be given below it is of course not very to regard a compiler as a function assigning target language programs to source language programs however the rest of the diagram does have a non content it that semantics should be an actual function assigning mathematical objects meanings to partial functions of some fairly complicated type that is it forms of semantic definition such as those provided by the definition method or by sets of reduction rules of some form which only provide for any given pair of program and input data some tion for finding the output if any the bottom side of the diagram is merely an for the highly that the meanings of target lan guage programs are not identical with but only represent in some adequate way the mean of the source language programs from which they were compiled there is one crucial elaboration to what has just been said it is further that the of the diagram should be made not merely sets but algebras and that the arrows defined a number family should be homomorphisms in l seem to be the of sets of elements of oe operations each taking specifically appropriate different a heterogeneous universal algebras tool a heterogeneous algebra types its which are connected number of arguments of specified types as has bv a and producing a result algebras under a suitable the corresponding of specified type for a homomorphism their operations must have corresponding pairwise correspondence of the to constitute a homomorphism to exist between two argument and result types and for a set of functions between it must respect the operations in the t same way as does a conventional homomorphism eg of groups that heterogeneous algebras where s t u v are any ti v the corresponding of and where o are any corresponding operations of a and of a must satisfy the is a of a s o x equation ru o os ot y work supported by contract no for all a if every element of every sets so is a are said to be generating sets of elements of so to for uo the of the present paper just given by applying them to the problem we begin at once claim whatever will be made for it an of familiar describe will be to putting statement and partial proof by introducing an example as a language features which the author some on the simple compiler cor programming language no it is intended merely to he knows how to to give an intuitive syntax for our language languages are intended idea of what is modelled we present first between this syntax and those to be helpful rather than a possible concrete of other algollike st var empty be then st else be do st se const blocks expressions with initialized declarations values var be in se are both made and to be se boolean expressions var and const are simply we will refer to sets as var and const which for convenience we can abstractly characterize the heterogeneous algebra l which is to model our example language merely by that it is to be a word algebra ie one in which no equalities hold save between and by naming its specifying the generating sets and giving the types of its operations in modelling a programming language by a heterogeneous algebra it appears there will generally be need ed one for each abstract syntactic phrase class in with this we take to have four var stat with respectively the following generating sets var continue const there are operations whose names we concrete syntax of the following types from the corresponding bits of val var var x stat x stat stat x stat res stat x x x x x var x x stat stat we next proceed to an algebraic specification of semantics for that is to the definition of an algebra of meanings and of a homomorphism lm we first note that it would be irrelevant to our present purpose to commit to a particular system of arithmetic values we shall merely assume that they constitute a set a that there is a given denotation function value and a given operation plus in a practical example there would of course be many such operations taking various num of arguments and we shall where appropriate assume that the target machine which we develop has the to store elements of a and to perform plus this to the usual practice in leaving details of numerical range and opera tions to the implementation as we shall have to assign to define a type environment meanings to phrases with free variables it us of partial env functions assigning values to variables and to make all our meanings functions of environments assignment although concept in tion of variables following types in fact we can also take environments to this would not work for languages which creation of places was we therefore take the four of be the entities with a more not to be sets of affected developed with elements by the var x env env x env denotes the set of we have still to define the operations in and the effect of on the generating sets of l it is a fundamental result of universal algebra that when we have done so we will specified the homomorphism uniquely and moreover in case the domain is a word algebra as l is that any actually exists see for example where this called the unique extension lemma as a to ity we shall combine the specifications of and of the in a conventional style of recursive the use of p xyz then function definition the notation for following a special the of observe in form of composition if q pq df the semantics v v e e for for here for and subsequently while q q yf here y is the minimal fixpoint undefined function then s else s ql q combinator ql fl is the totally s e r rr r let v be r r r w note well that although the definition of b and others to follow gram in a language and may be so interpreted yet it must restricted kind if it is to define a homomorphism each line save those defining on the sets is it follows that each u must be defined to depend solely u and not upon any other functions of st u reads like a a program of a of the definition an operation in upon s t we now turn homomorphism syntaxdirected for computing a an interpreter amount of time to the definition y l note in the homomorphism it gets done with any of a target language for our example in passing by way of motivation that a real world does bear a follows the phrase structure of its input finite program in a finite indeed roughly and of a to a program and unlike linear roughly speaking on a stack together into by the of phrases into the semantics of l the programs machine the phrases with we introduce of will be to be interpreted to no ones operations of t will be ones which two arise however the first is caused free variables we cannot expect to compile such our solution here is similar to that used to define a set of symbol tables or maps map var n it will turn out that the from the top of the stack and we will map to some suitable class of values of maps will represent make each of t be a set of functions down from the second difficulty represented by an algebra arises quite to another generally in translating from one in general the given second algebra wj not be a image of the first s required s to construct or derive see the discussion of derived operations n the operations of the actual target algebra from the given operations by composition and the use of constant operands in our case demands that we define an underlying compilation of and then derive flowchart algebra t not towards he the operations of of opera tions we make the following rather definition of for every finite set d there is a separate of t which we may call the the intuitive idea is that elements of d label in each at which it may be attached to others in particular there will be a of s for h for halt with one entry point and one exit note that s and h are not meant for variables of any kind but simply as two the and letters of the alphabet for any three sets d e f and any three functions d dj e e f f there is a binary operation o of t producing an from a and an intuitively o works into one point each set of points of the d and e whose labels map to a and then some of these points with the elements of f to give an is used merely as set for example composition of is given by defined as follows o the actual numeric them from tions are ation of values on the here on the and with loops right are author would be they have the no useful the first to agree however of information that the we will to contains at least the following primitive or for each ns ln for loading the nth stack element to the top of the stack and for removing the top of stack for each an and storing load for putting one special add for replacing the top two stack one special equal for deleting the top two stack otherwise at f a on the elements elements it n positions down stack by their sum i and at t if they were equal there are also empty having all their labels at the same point again for the of our two sets of partial derived target functions of and and one set of partial functions type with of type we will to correspond take var to stat to we may now proceed in the same style tions defining the effect both of the compiling as for and to give homomorphism y lt and of the operations in t the remaining definitions of needed are collected at the end we make one auxiliary definition v for now the compiler v m the empty cm for for for here and subsequently vm l mv m q sm m q then sl else ys res rm m m m m push m m push v rl k rm this is a trick st has the effect of deleting the stack element below the top one we now define who but we append wish to fs fh es ds df dt eh of their out the equations intended effects for those fx fy es fz ds df dt eh fs fh es dx dz dy eh s q h produces fs ff es ft ds df dt et ef which are immediately consumed by s q qz we next turn to the description of the algebra of meanings for t intuitively speaking we want to interpret our by running them on a whose set of of the of elements of a that is of all finite sequences with values in a for we will consider oo to be the top stack element and so on down for each of we take its of meanings to consist of binary relations from to itself we denote the set of all such relations by thus intuitively the meaning of a flowchart will tell us just what state final state pairs it can compute from each to each exit the of any formal distinction between and exits is perhaps but seems to facilitate the treatment corresponding to each o x determined by functions def we an operation q of go defined q dz as follows l d ue fz xi here x converse of this by turns u denote respectively relational and and i denotes the identity formula is that to compute in a flowchart in the pieces back and as cartesian product composition union relation on z the content together from pieces is to compute often as one at the in particular in l we denote by ql q the operations corresponding to by way of the of t and u it may be said that they are intended to to an algebraic model of flow nd machines introduced by in and further developed in in that model individual and the ma on which they run are viewed as algebras of a special type meanings relations computed by running on any machine are given by a uniform algebraic product operation in explicit constructions on are defined correspond ing closely to the t operations of the present paper and a formula essentially equivalent to that above as giving the connection between the t operations and the is there derived from the properties of the algebra product having defined t u merely the element the operations in by giving its effect on we do so as follows a to the stack a we may now specify the generating sets for brevity let a semantic homomorphism of t that is on the aa d note the result of pre ln xo yt iff x s y h t x s cn xo iff x s y h t au xo iff x s y h o a a p t s o y t uo xa iff x s y h o t ul corner tables it is now possible of our compiler the to be precise of to define the algebra u which is to form the lower righthand correctness diagram with the target semantic elements of u must follow those of in being functions of symbol we have the for the types of the members of the four var x x we of course want to reflect homomorphism that is we can mapping by th equations the define action of the underlying the desired effect of considered simply as a lv v pm for for pc any other that this function actually is a homomorphism tu for an appropriate choice of opera tions in u is a fact of universal algebra stated for algebras in under the name restrictions lemma it is convenient to display the necessary operations in the form of a recursive definition of the composite note that we are constructing both t and u to be of l under y and so that this form of definition is in fact we can the definition of dy mechanically from that of y by simply replacing each t inst by inst each o by q and each y by however we the here for we should than z rela tions reflexive to would merely some formulas below v m m q sim m m q then sl else sm res rm m m m m m v be r rm m m it is now necessary to define the fourth side of the compiler correctness diagram translating between define an encoding function meanings it proves more convenient to m than one in the opposite direction it will then be necessary as a final step in proving at least for programs without correctness to show that e has a inverse free variables which are the only ones we really to be able to run we will define e simply as a family of mappings one per the proof that s is in fact a homomorphism will constitute the main inductive part of the correctness proof to get an intuitive of the behavior of e it is necessary to realize that stacks in the implementation contain two kinds of entry values of and anonymous intermediate results thus example a function s in the statement of m we want es to be such that once provided with a symbol table which stack represent the current environment it will change these just as s does but will leave all other positions unchanged we this notion by defining an auxiliary function for changing a stack to bring it into agreement with an environment i ai for it is now not too difficult to write the necessary four equations defining e ev v for vs var cs m sis h mo for er m su for eq m s change for the formal parameter notation s like are partial functions strictly ing relations to make all the types fit which of the argument is the letter s is meant to indicate that es m and the they must be considered as the correspond are defined only when the first component at this point although nothing has been problem within algebra in what the carry through the correctness proof the equation has as yet been proved in the modelling author which we shall to be a do here the main goal of a compiler natural manner only in part of the paper correctness to actually is to prove eo necessary proof has been structured for us by our algebraic approach namely we have in the first that is that place to show that we have not merely s respects each of the operations a function but a homomorphism of and in the second place to show directly that the diagram for the elements of the generating sets of l it will then follow by the unique extension lemma that c and on the sets must be the same homomorphism if we to algebraic terminology we could call these two parts the inductive and base steps of a proof by structural induction but note this is an induction on the structure of source programs not of computations after proving that the diagram we must still show that for a program p without free variables we actually can s and recover from proving commutativity for the generating sets is not hard which was only carried along for purposes we have for it is easy to discover from the definitions taking notational convention used in defining s that both so and function for the var trivially advantage of the work out to the similarly the definitions yield immediately that this completes the base of the induction the inductive part of the proof verifying that e respects shall carry out here only for the operations and the operations of we for val we can in fact check involved arbitrary are identities on var directly we compute v lm v h and since we know that from the definitions all the for which is for the same thing what we have to prove for is the equation under which the assumption may be rewritten from the definitions of e and as the assumption mso we may begin by expanding the lefthand side w rd change w starting attention now from the other end we work out what comes to to the action of it is not difficult to see that we have by giving some for i yt iff but this amounts taking note of what does to su h which considering the definition of change we may rewrite as ma and this as we have seen is just the proof that complete programs those containing no free the consider such a program p defined environment m the empty symbol we are after by is p e in table fact we now examine the special case of variables and belonging we assume to and let e denote the empty completely un and c empty stack just the component then the answer of this for the second component can compile the come out will be ut our flowchart mo run it statement of tells us that we on the target machine starting at sc and eo just in case p eo is stack element is with the desired element of a as the only the omitted above appear to statement where parts of the correctness proof which offer no particular difficulty save y will have to be either proven by has been possibly showing for in the case its argument and of the while to be a continuous ox else to some extent this defined however appears to be equivalent the proof would since in this application be quite tedious the definitions to when written out of the compiler and of the two semantic functions can yet any must to every be made very much than they are of these definitions there is a and need for notational improvements and if reliable proofs are to be produced for a sufficiently expressive in the present paper and aside from its automated formal on homomorphisms system to carry them out everywhere is basically in its approach the aim has been to some of the facts underlying the correctness of compilers the author that efforts such as this applied one will complement to a the problem of the such as milners in and also and designing good proving languages should be easier if one has an idea first of what one will want to say in them references g and jd theory pp heterogeneous algebras j combinatorial r m burstall approach and p j machine intelligence programs and their proofs an algebraic d scott and c towards a mathematical semantics for computer languages programming research group oxford computing laboratory p j intelligence a symmetric automata theory machine f l morris stanford correctness of translations of programming computer science memo cs languages r milner and r proving compiler logic machine intelligence correctness in a mechanized p and d park induction rules and proofs of termination proc des des et de la france july 