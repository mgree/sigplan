universal properties of impure programming languages computer laboratory university of cambridge paul school of computer science university of abstract we investigate impure callbyvalue programming languages our first language only has variables and its equational theory is a variant of theory of that the commutativity axiom we demonstrate that type constructions for impure languages products sums and functions can be characterized by universal properties in the setting of where the commutativity law may fail this leads us to new universal of two earlier equational theories of impure programming languages the premonoidal categories of power and and the models of moggi our analysis thus puts these earlier abstract ideas on a canonical foundation them to a new syntactic level categories and subject descriptors f semantics of programming languages keywords premonoidal categories monads introduction in this paper we introduce a new equational account of impure programs this account is analogous to the equality for the pure typed calculus it provides a simple reasoning tool that is justified both syntactically and semantically by compositional interpretations in a variety of models it is given a canonical status through universal properties and let us that the equality of the pure calculus is not appropriate in the impure setting under the callbyvalue semantics for instance if m has side effects then the law for products does not hold m m m for this reason the categorical notion of product does not immediately apply to callbyvalue programming languages an equational account of to move to the impure setting we must the nature of substitution which we do by introducing the new notion of premulticategory § in the equality of a pure calculus substitution is essential eg xm n m n x in a callbyvalue language substitution is more the standard ml expression let val x n in m end permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright © acm is in some sense equivalent to m n x in the pure fragment of ml whereas in the general it means evaluate n call the result x and continue as m this sequencing plays a fundamental role and it forms the basis of our definition of premulticategory our starting point is a language with at least two typing rules t a x a u b x a x a let val x t in u end b and satisfying three equations let val xx in t end t let val xt in x end t x let val x t in let val y u in v end end let val y let val x t in u end in v end x any reasonable callbyvalue programming language will have an analogue of let val roughly speaking it is the essence of form and eg it is often helpful to understand a term in context t a as a generalized function which takes a valuation for the context and returns a result of type a if we thus draw a term one input for every variable in t output of type a then we can understand let val as composition of functions and a single variable is just a the third law says t xu y v t xu y v the three laws are thus the laws of identity and associativity for composing multivariate functions the classical theory of also proposes a commutativity law t u x v y t x v let val x t in let val y u in v end end x let val y u in let val x t in v end end y this law does not hold for impure programs consider the case where t def print and u def print world our equational theory of let val is thus a variant of which we call § jeffrey the of the graphical calculus by introducing special control arrows first class types via we argue that type and term constructions should be defined in the context of the simple language with let val in a canonical and universal way to this end we give universal properties for products § sums § and callbyvalue functions § in impure languages one important consequence of universal properties is that although there may be many isomorphic implementations of say a product type there is exactly one isomorphism between any two implementations which means that there is a canonical way to translate between them we focus on product types for now but we will later deal with sum types and function types the concept of product is already present in the little language with let val for we can describe terms x a × b t c as terms x a x b t c the principle of says that this concept determines the product types if they exist concretely requires that there is a term x a y b x y a × b which is universal in the following sense the term induces a family of functions between sets pc t z a × b t c u x a y b u c where pc t def let val z x y in t end and this family of functions is required to be a natural family of the condition means that each pc has an inverse in other words that there is an assignment x a y b u c z a × b pc u c satisfying some equations in standard ml we can define pc by pattern matching let pc u def let val x y z in u end the technique of is syntactic in that it suggests constructors and destructors for product types it is also semantic because it only determines the types upto unique isomorphism of types it gives a universal property there is a unique isomorphism between any two implementations the principle of is a fundamental idea in abstract mathematics gives an account of for one of our main technical contributions is to develop the theory of in the setting of § and to demonstrate its to the principles of programming languages monads and premonoidal categories two important to this work are work on monads and the line of work on premonoidal categories and freyd categories by power and this earlier work has been very in programming languages research our of it is that its analysis of impure computation is with its treatment of types using premonoidal categories we show that impure computation can be separated from types in these models § notion of c model def is defined in terms of strong monads it in one the structure of impure programming languages with product types and function types one of the contributions of power and work is to the function types from notion of c model they do this by directly categorical structures of computations which they call premonoidal categories this is in contrast to development which around monads on a category of values the notion of premonoidal category again in one the structure of impure lan guages with product types freyd categories the distinction between computations and values to the theory of premonoidal categories in this paper we the principles of impure computation from type structure by introducing the notion of premulticategory and the related notion of freyd multicategory a premulticategory with a distinguished class of values our main theorems recover the earlier constructions by using universal properties to introduce type structure to this framework · a premonoidal category is a premulticategory with products theorem · a freyd category is a freyd multicategory with products proposition · a c model is a freyd multicategory with products and function spaces § coherence from we now give a more technical summary of the connections between premonoidal categories and in a programming language the types a b c and a b c are not identical but they are isomorphic in a canonical way in the approach of power and the isomorphism between the two types is given as part of the data for a premonoidal category this coherence approach has proved extremely successful in many areas of mathematics but it appears several steps away from programming language syntax in our work the isomorphism does not need to be given instead it can be derived from the universal property of products this is a version of result to give a monoidal category is to give a multicategory with tensor products the situation is actually more complicated power and require that the given isomorphism is central which informally means that it doesnt matter when it is executed although this requirement is reasonable from a pragmatic point of view it does not seem to arise from a requirement of higher category theory premonoidal categories do not seem to be in a monoidal this problem is by our result which provides a explanation of the requirements in premonoidal categories in summary whereas the original definition of premonoidal category is several steps away from programming language syntax our new characterization essentially is programming language syntax this is because rather than everything in one we characterize type constructions as universal properties over a basic framework for impure computation a basic equational account of impure programs we begin by analyzing the basic structure of an impure programming language with variables and the equations which we propose are three of the four equations of recall that an ordinary category a collection of objects a collection of morphisms between the objects a selection of identity morphisms and an associative composition operation roughly speaking a premulticategory is similar except that the morphisms do not go from one object to another rather they go from a context to an object a this is a natural way to study typed programming languages since a program in a context has a type a at this stage we do not ask for the objects to be closed under operations product types unit types nor for any special morphisms arithmetic nonetheless we certainly do not these things at this stage a premulticategory can have more content than the basic structural requirements as well as the syntactic examples of that arise from programming languages we have more concrete examples coming from set theory pointed sets and we explain how a strong monad gives rise to a premulticategory definitions and notational convention informally the language of can be thought of as a language for terms in context formally a morphism a goes from a list of objects to an object we introduce the following informal convention we will often write a list a b c annotated with variables x a y b z c this allows us to informally index the list using variables rather than numbers eg we can write y for the second element of the list by doing this we can reason about lists without with arithmetic on indices in everything we do the informal variables can be translated into numbers at the of readability the of this paper is the following definition of premulticategory this is a version of multicategory an idea first extensively investigated by definition a premulticategory is given by the following data · a collection of objects ranged over by a b etc · for each list of objects and each object a a collection of morphisms a is given if t a then we write t a · identity morphisms for each object a a morphism aa must be given we this requirement informally as a rule x a x a · composition given a morphism t a and morphism u a b if the length of is i then a morphism u i t b must be given we this requirement informally as a rule t a x a u b t x u b the notation t x u can be understood as shorthand for let val x t in u end execute t bind the result to x and continue as u the data is subject to the following equations · identity laws x a t b ta x a x x t t b t x x t a in case the notation is the first law means that for any morphism t a b the composite of with t at position i where i is the length of is equal to t · associativity law t a x a u b y b v c t x u y v t x u y v c more formally this law is v i u j t v i u ij t where i is the length of and j is the length of commutativity and in general given morphisms t a and u b we say that t with u if it doesnt matter which order t and u are executed to be precise t with u if the following equations hold for all v x a y b v c t x u y v u y t x v c y b x a v c t x u y v u y t x v c if t with all u then we say that t is central in other words t is central if it doesnt matter when it is executed a premulticategory is a multicategory if all morphisms are central calls this the axiom of commutativity examples of have significant recent interest in category theory logic and algebra eg and in the semantics of continuationpassing and of state have not been studied before to our knowledge first simple example multicategory of sets we begin by describing the multicategory of sets but let us first set up some notation given a list of sets we write for the product of those sets for instance a b c a b c a a b b c c if we view as a context then is the set of valuations for that context in the multicategory of sets the objects are sets and a morphism a is a function a thus a morphism a is something which assigns a result in a to every valuation of the identity morphisms are the identity functions composition is by composition of functions given morphisms t a and u x a b and given valuations a b c let t x ua b c def ua tb c this is a multicategory all morphisms are central second simple example multicategory of pointed sets in the multicategory of pointed sets the objects are sets a equipped with a distinguished element a a morphism t a is a function t a that is strict in each argument if a is such that ai for some i then ta a identities and composition are as in the multicategory of sets it is easy to check that these yield functions that are strict in each argument all morphisms are central third simple example premulticategory of stateful functions let s be a fixed set thought of as a set of states we form a premulticategory whose objects are sets and where a morphism a is a function the idea is that a stateful function takes as an argument a valuation of its context and also an initial state it returns a result and also a final state composition is defined as follows given t a and u x a b and given valuations a b c and an element s s let t x ua b c s def ua a c s where a s tb s this premulticategory is not a multicategory unless s has at most one element the central morphisms t a are the functions that do not change the state ie for each valuation a there is an element ta of a such that for all states s s we have ta s ta s connection with programming languages welltyped terms of a programming language such as standard ml form a premulticategory modulo observational equivalence composition t x u amounts to the ml syntax let val x t in u end the identity and associativity laws are simple observational equations under this interpretation not all morphisms are central for instance print x print world y x y print world x print y x y connection with deductive systems as observed are closely related to deductive systems such as the sequent calculus the identity morphisms correspond to the axiom and composition corresponds to cut the identity and associativity laws provide a starting point for a procedure however whereas the commutativity axiom plays a natural role in equivalence of proofs we are it in the context of programming languages moreover we are not interested in cut elimination since plays a crucial role for instance we cannot eliminate sequencing from the following program without changing its meaning print enter your name x y print y connection with algebra the words commutativity and are used by analogy with algebra let m e be a monoid ie a set with an associative binary operation and unit e we can build a premulticategory from m it has one object and a morphism for each element of m the identity morphism is e and composition m x n is monoid multiplication m n a morphism m in this premulticategory is central if and only if it is central in the usual algebraic sense n m n n m the premulticategory is a multicategory if and only if the monoid is commutative m n m n n m this is a simple motivating example let be an alphabet and let be the monoid of strings over the alphabet the unit is the empty string and multiplication is concatenation when we think of this as a premulticategory we can think of the object as the unit type in ml and we can think of elements s of the monoid as commands output s with the equation output s x output t output st examples from monads moggi proposed monads as models of impure programming languages plays a key role in his metalanguage this can be explained by noting that every strong monad induces a premulticategory examples of monads on the category of sets include the state monad s × s the continuations monad r r and the exceptions monad e all of these computational effects can be in recall that a monad on the ordinary category of sets is given by an assignment of a set t a to each set a a family of functions a a t a and an assignment from functions f a t a to functions f t a t b all satisfying some axioms given a monad t we can define a premulticategory of t functions the objects are sets and a morphism a is a function t a the identities are defined using composition is defined as follows given t a and u x a b and valuations a b c let t x ua b c def a tb c where str t a t a is a strength which is uniquely defined for any settheoretic monad prop this construction can be carried out for any strong monad on a symmetric monoidal category the premulticategory induced by a monad is a multicategory if and only if the monad is commutative in the sense of commutative monads have special in the study of linear logic eg any monoid m e induces a monad m × on the category of sets the premulticategory induced by the monoid in the premulticategory induced by its monad and the three notions of commutativity for monoids monads and coincide in this situation while many notions of computation can be described by monads there is a difference between and monads a strong monad cannot be defined without having a product structure and a construction t we argue that these constructions on types × and t have nothing to do with impure computation in section we show that these constructions × and t have universal properties when they exist so that they need not be specified at all structural laws our language for doesnt have any structural laws in a composite t x u there is a linearity constraint the variables in t must be distinct from the variables in u except for x moreover the context cannot necessarily be there are many situations in programming languages where is essential and so we now explain how to introduce the structural laws into the theory of if a am and b bn are lists of objects then we define a renaming f to be a function m n such that ai for i m compose as functions see also eg definition a premulticategory is cartesian when for every morphism t a and every renaming f a morphism tf a is given t a f tf a such that tid t and tf g tf g when both sides are defined and satisfying the rule t a x a u b t x f g tf x g b for any f g and g where the g f g and g g x a x a are defined in the obvious way special kinds of renaming correspond to the classical structural laws the of the form x a y b y b x a determine the exchange laws the injective of the form x a determine the weakening laws and the of the form y a z a x a determine the contraction laws all can be built from morphisms of these three kinds eg we can work with a subset of the structural laws by focusing on a particular wellbehaved class of definition cf def a premulticategory is symmetric when for every morphism t a and every renaming f a morphism tf a is given such that the rules in definition are satisfied we emphasize that symmetric and commutative are not in a cartesian premulticategory some morphisms interact particularly well with the renaming structure cf we say that a morphism t a is if for all u b t x b and t a is if for all u y a z a b t x ty tz b definition a cartesian multicategory is a cartesian premulticategory in which every morphism is central and various authors have investigated general categorical frameworks that include symmetric cartesian and many more elaborate examples but those frameworks are based on simultaneous substitution and do not seem to work well for product types and tensor products in the previous section we introduced an equational theory for programs with we did this without making any assumptions about the type constructions in the language we now explain what it means for a language to have types we do this by using the universal property of tensor products which is well understood for this universal property has the immediate consequence that any two implementations of the product type are isomorphic in this sense having products is seen as a property and not additional structure we discuss a limitation of this view in § in this section and in the following two sections on sums and functions we will deal with particular concepts in section we provide general notions of and show that these particular concepts are instances of the general notions tensor products definition consider a list a an of objects in a premulticategory the list can be thought of as a specification for a product type a an the list is not actually a product type because it is not actually an object a tensor product for is a single object that represents it definition a tensor product for a list of objects a an is an object together with a morphism which we no x a xn an x xn together with an operation on morphisms x a xn an t b y y x xn t b for each pair of lists and each object b the notation y x xn t should be understood as pattern matching a variable of product type into its components x xn binding them in t we require the morphism to be central that is y t z u t z y u and we impose the following two conditions x a xn an t b x a xn an x y y x t t b y u b y y x xn x xn y u u b the first equation says that if we form a tuple and then extract its elements nothing happens the second equation says that if we extract the elements of tuple and then build the tuple again nothing happens in section we will explain how this definition amounts to in a more abstract sense examples of in the multicategory of sets every list of objects has a tensor product the tensor product of a list is the product set that is the set of valuations for the universal morphism is the identity function essentially the same representation works in the premulticategory of stateful functions and the premulticategory of arising from a monad on the category of sets recall that a pointed set is a set a equipped with a chosen element a a in the multicategory of pointed sets every list a an has a tensor product given by the smash product which is a of the free pointed set on the product of where is generated by a ai an pointed sets are a simple algebraic theory more generally one can build a multicategory from any algebraic theory with algebras as objects and maps as morphisms a example is the of multicategory of vector spaces which also has tensor products a wellknown characterization theorem says that for a given algebraic theory the multicategory of algebras has tensor products if and only the corresponding monad is commutative cf connection with programming languages the syntax for tensor products is very similar to the syntax in ml in standard ml the object would be written a an and the assignment y x xn t is written as follows let val x xn y in t end the of the universal morphism and the two equations are straightforward observational equivalences thus we can build a premulticategory with all tensor products whose objects are types and whose morphisms are terms in context modulo observational equivalence if the empty list has a tensor product then this behaves like the unit type in ml for instance the sequencing notation t u can be understood as shorthand for t x x u a convenient programming practice is to write tuples with terms in the components by a lefttoright order of evaluation we have the following derived typing rule t a n tn an n def t x tn xn connection with logic the rule for matching is the left rule for tensor products in the sequent calculus presentation of linear logic the right rule of the sequent calculus looks like the derived rule although there is nothing canonical about it in the setting the order of evaluation of t tn unless they are central basic first results we now state some basic results that can be derived from the definition of tensor product they are instances of general results in section proposition matching associates and with composition t b z b u c y y x tz u y x tz u c t b z b u c y y x t z u t z y x u c proposition for any list x a xn an of objects any object r and any morphism r r there is a unique morphism t y r such that x xn y t r the unique morphism t is central if r is central as a corollary of this result we achieve our main theorem theorem tensor products are unique up to unique isomorphism and the unique isomorphisms are central in other words there is a canonical way to translate between any two implementations of product types sums and labelled variants in the previous section we demonstrated that products can be given a universal property in a model of an impure programming language in this section we show that sum types labelled variants can also be given a universal property in a similar way definitions constructor contexts and sums we fix an infinite set of constructors a constructor context is a finite partial function from constructors to objects of a premulticategory a sum for a constructor context is an object and a family of morphisms c c dom x c cx that is universal in the sense that each morphism is central and there is an operation on morphisms xc c tc a c dom y match y as a subject to the following equations xc c tc a c dom d match y as tc c td a y t a y match y as y t c t a examples of sums sums in settheoretic the multicategory of sets has sets as objects and multivariate functions as morphisms sums of constructor contexts are given by disjoint unions def c a a c the universal maps take a c to c a a similar analysis works for stateful functions and for the premulticategory arising from a monad on a distributive category in the multicategory of pointed sets the objects are sets a equipped with an element a and the morphisms are multivariate functions that are strict in each argument this multicategory also has sums of constructor contexts given by a sum def c a a c where c c connections with programming languages in mllike languages variant types must be declared given a constructor context c a cn an we would expect an ml definition datatype c a cn an the universal family of morphisms can be combined with composition to yield the more familiar term formation for constructors t c ct def t x cx a c dom the equations in the definition are straightforward observational equivalences in a programming language basic first results we state some basic properties that can be derived from the definition of sums they are instances of general results in section proposition matching associates and with composition xc c tc a c dom z a u b y match y as tc z uc match y as z u b t a xc c z a uc b c dom y match y as t z t z match y as b proposition for any constructor context any object r and any family of morphisms rc x c there is a unique morphism t y r such that for all c dom x c cx y t rc r the morphism t is central if each rc is central in consequence sums are unique up to unique isomorphism and the unique isomorphisms are central on values and freyd in impure programming languages it is usually necessary to identify a class of values among the class of all programs for instance in an impure functional programming language the most natural evaluation strategy for function application is callbyvalue expressions are reduced to values before they are passed as arguments we have proposed to understand a program as a morphism in a premulticategory to accommodate values we must identify a class of morphisms which are the values we call this structure a freyd multicategory the idea of distinguishing between values and computations is in the categorical study of semantics from distinction between ordinary morphisms and morphisms running through the work on premonoidal categories eg and freyd categories the distinction between values and computations also arises in arrows in functional programming and forms the basis of recent syntactic systems eg the idea of identifying a class of values also plays a crucial technical role from the perspective of morphisms between with tensor products morphisms of if represent programming languages then a morphism between them is a compositional translation definition let c and d be a morphism f c d is given by an assignment of an object f a of d to each object a of c and an assignment of a morphism f f f f b in d to each morphism f b in c such that identities and composition are preserved our running example concerns the monoid s flip e e where flip flip e as explained in section the monad s × on the category of sets induces a premulticategory c whose objects are sets and where a morphism b is a function s × b it can be thought of as a semantics for a simple programming language with a command flip that the contents of a bit of memory we also consider the premulticategory d of stateful functions § with two states bool true false the objects of d are sets and the morphisms b are functions × bool b × bool there is a morphism of f c d that is identity on objects and takes a morphism f b in c to the stateful function given by f f a s b s s where f a b s ie interpreting the command flip as an instruction that the state this can be understood as arising from a monad morphism s × × bool bool discussion preservation of we now investigate what it means for a morphism of to preserve tensor products since tensor products have a universal property we would expect preservation of to be a property rather than extra structure given a list a an of objects of v and a tensor product r r we say that a morphism f c d preserves the tensor if f r is also a tensor proposition let f c d be a morphism between where c has tensor products the following are equivalent f preserves every tensor product f preserves central isomorphisms and every list of objects in c has a tensor product that is preserved by f the issue here is that there may be many different for a given list of objects all related by canonical central isomorphisms if f preserves central isomorphisms eg if d is is a multicategory then the equivalence of items and allows us to check that f preserves all tensor products by checking that one chosen tensor product is preserved to illustrate this let us return to our example of the premulticategory c and the premulticategory d of stateful functions the premulticategory c is actually a multicategory since e and flip commute the morphism f c d does not preserve because f flip id is not central in d this example also illustrates the complications involved with preservation of tensor products in the setting in c every list has a tensor product given by e id this is a reasonable implementation of the tensor product from the programming language perspective this tensor product is preserved by the morphism f c d into the premulticategory of stateful functions however the structure flip id also happens to be a tensor product of the list in c this tensor product is not preserved by the morphism f c d because f flip id is not central in d in the example informally flip id is central in c by it would have been better to explicitly e id as a value and flip id as a we could then require this special class of central value morphisms to be used for the representations for and we could require this class of value morphisms to be preserved by morphisms of before we make this formal we briefly consider another way to resolve the situation we could remove the requirement that the representing morphism be central this is difficult to from a pragmatic perspective moreover from the mathematical perspective it is because the induced family of associativity morphisms abc a b c a b c is not natural and moreover does not support a coherence result the diagram does not commute see § definition freyd multicategory informally a freyd multicategory is a premulticategory that is equipped with data about which morphisms are values formally a freyd multicategory is a morphism return v c from a multicategory v to a premulticategory c such that v and c have the same objects and return is identity on objects and preserves the idea is that morphisms in v are values morphisms in c are computations and is the computation that immediately returns v we do not require return to be injective on morphisms although it often will be in practice we freyd by introducing a special judgement v v a of values morphisms in v and a rule v v a a describing the morphism return v c the of return is expressed by the following equations x a x a v v a x a v w b x w x b we also have the two equations stating that values are central among all morphisms § because v is a multicategory and v c preserves then we can understand x t as an explicit substitution of the value v for x in t in the syntax we can substitute tv x as shorthand for x t note that this implicit substitution is only an informal convention whereas it is syntax in the explicit substitutions of abadi et al a morphism of freyd f f v return c v return c is a pair of morphisms between f v v f c c such that return f f return examples of freyd recall that the premulticategory of stateful functions has sets as objects and stateful functions as morphisms a stateful function a is an ordinary function × s a × s where s is a fixed set of states in this context we let our multicategory of values be the multicategory of sets and pure functions and return v c is the evident inclusion morphism which is faithful provided s is not empty given a monad t recall that the associated premulticategory has sets as objects and morphisms a are ordinary functions t a in this context we let our multicategory of values be the category of sets and pure functions the morphism return v c is defined by the unit of the monad we can now our morphism c d from the premulticategory induced by the monad s × to the premulticategory of stateful functions § in both cases the value multicategory is the multicategory of sets and pure functions and id f c d is a morphism of freyd and sums in freyd we define a freyd multicategory with to be a freyd multicategory return v c in which v has and return preserves them this makes sense because return preserves we say that a morphism of freyd f f v c v c preserves resp sums if f preserves resp sums to illustrate we return to our motivating example the morphism from the freyd multicategory induced by the monad s × to the freyd multicategory of stateful functions this does preserves as an aside we remark that from the syntactic point of view it is slightly to ask for v to have for although it is usual to consider the representing maps v vn as values it is less common to consider the pattern matching syntax x y v as a value expression the phrase complex value for this situation our framework provides us with an option for describing without using complex values by c to have and for the representing maps to come from v without for v to have using implicit substitution we would have a more familiar grammar for values v v vn xv notice that these maps in v are not uniquely determined unless the functor return v c is injective on morphisms moreover two such representations are not necessarily isomorphic in v structural laws we can also of symmetric freyd which are freyd return v c such that v and c are symmetric def and return preserves the renaming structure v v a f a we say that a freyd multicategory return v c is cartesian when v is cartesian as a multicategory def c is cartesian as a premulticategory def and return preserves the renaming structure all the examples in section are cartesian function spaces we have introduced an equational theory for impure programs § and shown that product and sum types can be characterized by universal properties § we now characterize callbyvalue function types by a universal property we characterize function types in the context of freyd § by the steps taken by power and the key point is that firstclass callbyvalue functions can delay computations for instance in ml the expression fn x print testing does not immediately print it will only print when applied to an argument we use freyd to distinguish between computations which can be delayed and values which cannot be delayed in what follows we will assume that our are symmetric in the sense of section this means that objects in contexts can be it is to work with function spaces without this assumption definition function spaces we define the concept of function space in the setting of a symmetric freyd multicategory § a symmetric multicategory v values a symmetric premulticategory c computations and an morphism of symmetric return v c such that each is central let be a list of objects and let a be an object we will define what it means for the freyd multicategory to have a function space a the idea is that the of the function space are functions that take a valuation of the context and return a result of type a perhaps with some sideeffects along the way when is empty then the object a behaves like a space of delayed computations like monadic type constructor we do not have the isomorphism in a callbyvalue language and unless the freyd multicategory has all tensor products we cannot accurately express nary functions in terms of unary functions definition a symmetric freyd multicategory return v c has function spaces if for every list x a xn an and every object b there is an object b and a morphism b b not necessarily central f b x a xn an f x b together with an operation on morphisms t b v t b subject to the following equations t b f f x t b v v b v x f f x v b we work up to equivalence we consider variables to be informal notation for indices in lists examples of function spaces set theoretic examples the freyd multicategory of sets has v c as the multicategory with sets as objects and multivariate functions as morphisms the function space b is the set of functions b the representing map is the evaluation function which takes a function and a valuation and evaluates that function recall that the freyd multicategory of stateful functions has v as the multicategory of sets and functions and c as the premulticategory of sets and stateful functions the function space b is the set of all stateful functions b notice that in particular the function space b is the state monad s b × s given a monad t on the category of sets recall that the corresponding freyd multicategory has v as the multicategory of sets and functions and c as a premulticategory of sets and functions the function space b is the set of all functions t b in particular the function space b is isomorphic to the monad t connection to programming languages the connection with programming languages is clear the two equations are variants of the and equations which are straightforward observational equivalences in all languages we suggest the following syntactic sugar let f t tn def t x tn xn f x in this callbyvalue semantics expressions are reduced before being passed as arguments we certainly have not captured exactly observational equivalence that is not our aim our aim is to identify an equational theory that holds in all good models our equations hold in syntactic models and also in more semantic models which are not fully abstract but which are nonetheless useful connections with proof theory let us briefly investigate the extent to which the correspondence is relevant in the callbyvalue setting the rule for abstraction is essentially the right implication rule of the sequent calculus the syntactic sugar leads to the left rule for implication t a tn an y b u c f a an b f t tn y u c which is clearly not canonical because it depends on the order of t tn in fact the explicit helps us to distinguish different proofs for example consider the following two terms f a b x a c f x c b f a b x a f x w c w c b if f x is a value which is an assumption that the language is pure then these terms are equal without this assumption these are two distinct terms which correspond to two different sequent calculus proofs as first observed by in general the last two technical sections of this article place our work on a secure abstract foundation throughout this article we have of and universal properties on the understanding that these concepts a canonical status to various constructions we now provide a general notion of that accounts for the constructions that we have introduced products sums and function spaces for an ordinary category c there are two notions of that are dual to each other we can of for a covariant functor c set and of for a contravariant functor set the covariant notion of allows us to describe and the contravariant notion allows us to describe limits the situation is more sophisticated with for there is no reasonable notion of dual for thus we must treat the two differently we do this by considering for left and right modules of very informally we may say that a left or right module specifies a concept ­ a concept like product sum or function a representation for the module is a first class type that represents the concept throughout this section we work with symmetric this means that we can the contexts which makes the notation easier left modules and left we introduce a notion of left module and of for this general notion to our characterization of function types definitions and first results given a symmetric premulticategory c we define a left module m to be an assignment of a set m to each list of objects together with a family of functions c a × m a m satisfying two conditions we write m t when t m and we write t a x a m u m t m x u for t u the two conditions are x a m t x a m x m x t t lm t a x a u b y b m v m t m x u m y v t x u m y v lm representations of left modules for a fixed object r we can understand c r as a left module definition let m be a left module for a symmetric premulticategory c a representation of m is an object r of c together with an isomorphism of left modules c r m an isomorphism of left modules is a family of that respects the left module structure a representation is always determined by an object r and an element of m r to show this we use the following variant of the lemma technically this can be seen an instance of the lemma for ordinary categories proposition let m be a left module for a symmetric premulticategory c and let r be an object to give a left module morphism c r m is to give an element of m r in more detail given an object r and an element r m r we have a family of functions r r c r m given by r rt def t m x r tr m t m x r using x r m r conversely given a left module morphism ie a family of functions c r m that respects the left module structure we recover an element of m r proposition says that these two constructions are mutually inverse corollary let m be a left module of a symmetric premulticategory the following data are equivalent · a representation for m def · an object r and an element r m x r together with a family of functions m c r m t t r satisfying the following conditions m t m t m x r t tr t m x r t r uniqueness of representations proposition if r r m x r is a representation of m and a m y a then there is a unique morphism t y a r such that y a m a t m x r in consequence representations are unique up to unique isomorphism example function spaces in section we defined a notion of function space for freyd return v c given a context and an object b we define a module m for v as follows m def c b the module structure µ is defined in terms of the premulticategory structure of c v v a x a m u m v m x u def x u the two conditions are immediately verified the data for a left representation is exactly the data for a func tion space b the axioms are exactly the axioms for function spaces in section in terms of module morphisms we briefly remark that left modules provide a more abstract account of recall that a morphism t is central if it with all morphisms for all u and v t x u y v u y t x v this can be explained in a more abstract way as follows every morphism t a determines a family of functions between sets of morphisms t x c x a b c b the domain and codomain have an obvious left module structure and the morphism t is central if and only if this family of functions is a left module morphism for all b right modules and right we now provide a notion of right module which is an account of composing on the right the induced notion of accounts for the product and sum types that we introduced in sections and definitions and first results given a symmetric premulticategory c we define a right module m to be an assignment of a set m a to each list and each object a together with for each b the structure of a left module § c a × m a b m b and also a family of functions m a × c a b m b satisfying three conditions we use the following notation we write m t a if t m a and we write t a x a m u b m t a x a u b m t m x u b m tm x u b for u and u respectively the three conditions in addition to lm and lm are m t a m tm x x t a rm m t a x a u b y b v c m tm x y v tm x u y v c rm t a x a m u b y b v c m t m x y v t m x y v c rm the last condition rm specifies that the left µ and right structures associate with each other technically our notion of right module can be seen as an instance of a general concept in locally indexed category theory and the self construction see § § representations of right modules for a fixed object r the assignment m a c r a can be made into a right module in a straightforward way definition let m be a right module for a premulticategory c a representation of m is an object r of c together with an of right modules c r a m aa an isomorphism of right modules is a family of that respects the right module structure that is both µ and a representation is always determined by an object r and an element of m r this follows from a new variant of the lemma for which we need the following definition definition let m be a right module for a premulticategory an element t m a is central if it satisfies the following equations u b x a y b v c m tm x u y v u m y tm x v c u b y b x a v c m tm x u y v u m y tm x v c proposition let m be a right module of a symmetric category c and let r be an object to give a right module morphism c r a m aa is to give a central element in m r corollary let m be a right module of a symmetric premulticategory the following data are equivalent · a representation for m def · an object r and a central element r m r together with a family of functions a m a c r a m t a x r x t a satisfying the following conditions m t a m rm x x t t a rr x r t a x r x rm x t t a rr uniqueness of representations proposition if r r m r is a representation of m and a m a then there is a unique morphism t x r a in c such that m rm x t a a if a is central then so is t in consequence representations are unique up to unique morphism and the unique isomorphism is central examples products and sums · given a list define a right module m by m a def c a a representation for m is a tensor product in the sense of section · given a constructor context § define a right module m by m a def c c a a representation for m is a sum in the sense of section premonoidal categories and monads in section we defined as a notion of model for an impure programming language with variables and we argue that this is the primitive setting for studying callbyvalue impure programming languages in sections and we showed that products and sums can be characterized by a universal property which means that they are unique up to unique isomorphism in section we provided a similar universal property for function spaces we now justify our work by showing that it subsumes earlier of callbyvalue programming languages the premonoidal and freyd categories of power and and the monadic models of moggi · we show that a premonoidal category is essentially the same thing as a premulticategory with tensor products · we show that a freyd category is essentially the same thing as a cartesian freyd multicategory with tensor products · we show that a strong monad on a category with finite products is essentially the same thing as a cartesian freyd multicategory with tensor products and function types with empty domain · we show that a c model is essentially the same thing as a cartesian freyd multicategory with tensor products and all function types the last three facts can be from the first one by building on earlier work by power and premonoidal categories we now recall the notion of premonoidal category before we begin we give some concrete examples the category of sets and functions is a premonoidal category with the product of sets forming a premonoidal structure indeed any monoidal category is a premonoidal category but the motivating example is the category for a monad let t be a monad on the category of sets recall that the category of t has objects sets and that morphisms a b are functions a t b the product of sets induces a premonoidal structure on this category which is typically not monoidal in section we will show how to convert a premulticategory to a premonoidal category this will suggest a premonoidal category built from the syntax of a programming language our definition of premonoidal category is by taking things up a level we take advantage of a multicategory whose objects are themselves categories we start by defining strict premonoidal categories and move to premonoidal categories a multicategory of categories we the collection of all ordinary categories into a symmetric multicategory the objects of the multicategory are themselves ordinary categories and so our contexts are lists of categories a morphism f a in is defined to be a mapping that is in each argument for instance if b c then for each pair of objects b and c respectively from b and c an object f b c of a must be given and this must extend to families of functors f c b a and f b c a but not necessarily a functor b × c a this multicategory has tensor products and this structure has been used in various areas from rewriting theory to implications ex strict premonoidal categories before to premonoidal categories in general we define strict premonoidal categories a strict premonoidal category is a monoid in the multicategory a monoid in a multicategory is an object a with morphisms i a and x a y a x y a satisfying the monoid laws y a i x x y y a x a i y x y x a x y z a x y w w z y z w x w a in the morphism i a is the same thing as an object of the category a the construction a a a is not a functor a from the product of categories but rather a construction that is in each argument central morphisms just as central morphisms play a crucial role in they also play an important role in the theory of premonoidal categories we begin by that a category is a category a together with a morphism a a a in the multicategory for each object c and each morphism f a b we have morphisms f c ac bc and c f c a c b given morphisms f a b g c d in a we thus have two morphisms a c b d ac fc b c bg b d ac ag ad fd b d if these are equal we say that f and g commute a morphism in a category is central if it with all morphisms premonoidal categories in the multicategory the sets of morphisms a an b can themselves be considered as categories given morphisms f g a an b a cell f g a family of morphisms a f a ga in b indexed by lists of objects a an from categories a an respectively that is natural in each argument with this in mind we can weaken by replacing the equalities with central natural isomorphisms definition a premonoidal category is a category a a a a with an object i and central natural isomorphisms y i y y x x i x xyz x y z x y z that make the following and laws hold i x sis xx x y i x y i xy xy note that while the of and is reasonable from a pragmatic perspective it is ad hoc in that it does not come from the analysis of as a multicategory coherence the definition of premonoidal category is not based on universal properties and so a priori there is nothing canonical about and a canonical status is given by the coherence theorem proposition which characterizes the morphisms that can be built from and definition let a be a set an is generated from the grammar s t i s t a a a such that each element of the set a appears exactly once an between f s t is a string that is built using composition and their subject to the obvious wellformedness condition proposition let s and t be all isomorphism strings f g s t are equal when interpreted in any premonoidal category coherence theorems like this form an important part of the category theory literature nonetheless we that it is more desirable that the structure arises a priori from universal properties which is the content of our main theorem theorem for one thing the universal properties place the structure closer to programming language syntax main theorem our main theorem provides a connection between with tensor products and premonoidal categories it is a variation of the established connection between with tensor products and monoidal categories theorem let a be a set the following data are equivalent a premulticategory with tensor products whose objects are a a premonoidal category whose objects are a this section is to the proof of this theorem we begin with the following straightforward property of tensor products in proposition a premulticategory has all tensor products if and only if it has tensor products of the empty list and of every two element list of course it is useful to have explicit nary product types but the universal property tells us that any two implementations are isomorphic from a premulticategory to a premonoidal category given a premulticategory c with tensor products we define a premonoidal category a morphism f a b in the premonoidal category is a morphism f a b in c composition and identities are immediately derived from the premulticategory too the unit of the premonoidal structure is and the premonoidal tensor a c is the tensor product a c in the premulticategory this can be made into a structure given x a f b and y c g d let f c def z a c z x y f x x y b c a g def z a c z x y g y x y a d one verifies that this structure is preserves composition and identities by some algebraic manipulation using the axioms for which we omit for brevity having the structure in place we can note that the two notions of are related proposition a morphism f a b in a premulticategory is central § if and only if it is central in the induced category § this is by algebraic manipulation the coherence isomorphisms in the premonoidal category are defined by b def z b z x y x y b a def z a z x y y x a abc def xyz a b c xyz xyz xy a b c again some algebraic manipulation is needed to show that these morphisms are isomorphisms that they are central that they are natural and that they satisfy the coherence diagrams from a premonoidal category to a premulticategory we begin with some remarks about contexts in a premonoidal category a list of objects determines an object of the premonoidal category a a a an def a a a an i in particular i and a a i we often need to lists the coherence result prop gives us a canonical central isomorphism between and the objects are typically not identical given a premonoidal category we define a premulticategory with the same objects a morphism a in the premulticategory is a morphism a in the premonoidal category the identity morphisms a a in the premulticategory are the right identity isomorphisms a i a in the premonoidal category for composition given t a and u x a b we let t x u be the following composite t a a u b where the isomorphisms are the canonical coherence isomorphisms in the premonoidal category the identity and associativity laws for follow from the and of the coherence isomorphisms proposition a morphism t a in a premonoidal category is central in the premonoidal category if and only if it is central in the induced premulticategory the tensor product of the premulticategory is straightforward for any list let def the universal morphism is the identity morphism given t b we let y x t def y t b again the isomorphism is the canonical coherence isomorphism the two laws for tensor products follow from the and of the coherence isomorphisms equivalence in the statement of theorem when we say that the two notions are equivalent we do not mean that they are exactly the same rather we mean that if we begin with a premulticategory c build a premonoidal category and then recover a premulticategory from the premonoidal category we recover a premulticategory that is isomorphic to c conversely if we begin with a premonoidal category c and then build a premulticategory out of it and then recover a premonoidal category from the premulticategory we recover a premonoidal category that is isomorphic to c in this sense the two notions are equivalent this concludes our proof of theorem of the main theorem we conclude this paper by building on the main theorem theorem to recover new universal of various models from the literature structural laws power and define a symmetric premonoidal category to be a premonoidal category with a central natural isomorphism a b b satisfying coherence conditions proposition to give a symmetric premonoidal category is to give a symmetric premulticategory def with tensor products sums and categories power and define a category to be a premonoidal category with finite in which the functors a and a preserve finite for all objects a proposition to give a category is to give a premulticategory with all tensor products and sums § and monoidal categories we turn to the wellknown representation theorem for recall that a multicategory is a premulticategory in which all morphisms are central § similarly a monoidal category is a premonoidal category § in which all morphisms are central § proposition cf a premulticategory with tensor products is a multicategory if and only if the corresponding premonoidal category is a monoidal category to give a symmetric multicategory def with tensor products is to give a symmetric monoidal category to give a cartesian multicategory def with tensor products is to give a category with finite products freyd and freyd categories we now connect our analysis of values § with the notion of freyd category a freyd category is defined to be an premonoidal functor v c from a category v with cartesian products to a premonoidal category c proposition to give a freyd category is to give a cartesian freyd multicategory § that has tensor products § strong monads and function spaces we now use the known connections between closed freyd categories and monads to provide a universal characterization for monads in computation proposition let v be a symmetric multicategory with all let be the corresponding symmetric monoidal category proposition the following data are equivalent a strong monad on a symmetric freyd multicategory v c that has function spaces with empty domain a § proof outline from to let c be the premulticategory for the monad § from to a monad on v is given by the construction t a def a moggi models a callbyvalue functional programming language by a c model which is a strong monad on a category with products and with certain function spaces we now give this a universal status by an equivalent definition using proposition let v be a cartesian multicategory with tensor products let be the corresponding category with finite products proposition the following data are equivalent a c model structure for a cartesian freyd multicategory v c with tensor products and function spaces remarks we have given universal properties for type constructions in impure programming languages products sums and function spaces we have done this using the novel notion of premulticategory which is a basic equational account of impure computation we have shown that monads and premonoidal categories can be understood from this point of view and hence given a canonical status acknowledgments s supported by the trust and grant pb supported by advanced research references m abadi l cardelli pl curien and jj explicit substitutions j program ­ t j and t monads need not be in pages ­ r what is a categorical model of arrows in proc pages ­ p n benton and p wadler linear logic monads and the lambda calculus in proc lics pages ­ a un triple ­ a higher dimensional word problem in proc pages ­ pl curien and distributive laws in and universal algebra j r e and a an effect calculus with linear types in proc csl pages ­ m p semantic analysis of by evaluation for typed lambda calculus in proc pages ­ c flanagan a b f and m felleisen the essence of compiling with continuations in proc pldi pages ­ f c and g m algebraic categories with few monoidal structures or none j pure and applied algebra ­ c direct models of the computational lambdacalculus in proc xv pages ­ h a lambdacalculus structure isomorphic to sequent calculus structure in proc csl pages ­ c representable advances in mathematics ­ m in and around algebra and logic talk available from the authors page b semantics of weakening and contraction of pure and applied logic ­ b and i freyd is for arrows in proc a jeffrey premonoidal categories and a graphical view of programs unpublished a monads on symmetric monoidal closed categories der math ­ y towards an algebraic theory of boolean circuits j pure algebra j deductive systems and categories ii in category theory theory and their applications volume of pages ­ springer t higher higher categories p b springer p b j power and h modelling environments in callbyvalue programming languages comput f equational categories univ math j ­ g a fully abstract relational model of syntactic control of interference in proc csl pages ­ p and n linear continuations and duality r e and s state in models of callbyvalue in pages ­ e moggi computational lambdacalculus and monads in lics pages ­ e moggi notions of computation and monads comput p w ohearn on typing j program ­ j power premonoidal categories as categories with algebraic structure theor comput sci j power and e premonoidal categories and notions of computation math struct comput sci ­ j power and h closed freyd and in proc icalp u s global state considered unnecessary an introduction to semantics lisp and symbolic computation ­ j g modelling term rewriting systems by technical report tr university 