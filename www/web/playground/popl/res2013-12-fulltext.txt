abstract conflict driven learning department of computer science university of california berkeley department of computer science oxford university daniel department of computer science oxford university abstract modern satisfiability solvers implement an algorithm called conflict driven clause learning which combines search for a model with analysis of conflicts we show that this algorithm can be generalised to solve the problem of determining if an additive transformer on a boolean lattice is always bottom our generalised procedure combines of greatest fixed points with of least fixed points to obtain more precise results than computing fixed points in isolation we implication graphs used in satisfiability solvers to derive transformers from ones our provides a new method for static that operate over lattices to reason about properties that require disjunction categories and subject descriptors f logics and meanings of programs specifying and verifying and reasoning about programs keywords satisfiability conflict driven clause learning lattices the algebraic essence of satisfiability solvers the performance of solvers for the boolean satisfiability problem sat has improved at an exponential rate in the last several factors contribute to these improvements including and elegant algorithm efficient implementations of data structures and heuristics that exploit the nature of practical problem instances a recent survey of these developments by and concludes with the following question given its theoretical the practical success of sat has come as a to many in the computer science community can we take these to other problems and domains this paper presents an approach to instantiating the conflict driven clause learning algorithm in sat solvers on new problems we introduce a of boolean satisfiability the problem is to determine if a function on a lattice maps all elements of the lattice to bottom instances of the problem include satisfiability for formulae in propositional logic and quantifierfree first order theories source to target reachability in transition systems language emptiness for automata and assertion violation in programs we show that permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm solves an instance of the problem for certain functions on finite powerset lattices the contribution of this paper is abstract conflict driven clause learning a strict mathematical of to abstractions we show that is a specific technique to combine of a greatest fixed point with of a least fixed point we provide a correctness argument for under general conditions these conditions are satisfied by abstract domains used in practice and lead to a new family of analysis procedures our work also enables a new understanding of discussed next abstract interpretation of many existing lattices used in static analysis lack negation have meet operations that precisely model conjunction and join operations that disjunction precision loss due to joins is often eliminated by a domain or analysis with disjunction such may from case explosion meaning that the number of disjunctive cases to be considered grows large as the analysis we show that the main data structure in a sat solver called a partial assignment represents elements of a well known abstract domain and that constraint propagation in sat solvers is fixed point iteration in this domain sat solvers compute fixed points in abstract domains the conceptual insight of this paper is that learning techniques used by sat solvers can be viewed as an abstract transformer for negation the combination of precise conjunction in the partial assignments domain with negation provided by learning allow a solver to reason indirectly about disjunction without cases we show that abstract domains used in practice satisfy the conditions required to support learning a second insight of this paper is that the implication graph construction in sat solvers is a technique for constructing an transformer starting from an overapproximation an abstract transformer can be viewed as a directed graph in which edges represent transformer application the graph represents a dual transformer and sets of vertices approximate applications of this dual transformer in a sat solver the graph represents a deduction transformer and its inverse represents an abduction transformer when lifted to programs we can start with an postcondition transformer and derive an precondition transformer the insights above have practical which we have demonstrated with two practical instantiations of we have instantiated with the interval abstract domain to c programs that manipulate floating point variables our is more precise that a standard static and more efficient than an smt solver if either is run in isolation we have also instantiated in the framework to derive an smt solver for floating point logic in both cases our instantiations avoid case explosion by several tools contribution and content this paper presents abstract conflict driven learning a procedure for reasoning about functions on boolean lattices by operating on lattices our goal is to present an account of that reveals its generality and to present correctness arguments that apply to all instantiations of towards this end we make the contributions below the problem a problem which satisfiability of logical formulae reachability in transition systems and assertion violation in programs a view of as a procedure for solving a specific instance of the problem a of to solve the problem by combining greatest fixed point and least fixed point computation a novel technique for deriving transformers from transformers based on a of implication graphs to abstract domains soundness and completeness arguments that apply to all instances of the paper is as follows we introduce the problem in section and discuss several instances of this problem we apply abstract interpretation to derive over and solutions to the problem in section and combine these approximations in sections and the of implication graphs to abstract domains is discussed and illustrated in section the problem we introduce the problem and show that satisfiability of formulae and error reachability in transition systems are instances of this problem subsequent sections lift to solve this problem terminology a lattice is called bounded if it has a greatest element called top and denoted and has a least element called bottom and denoted a function f on a complete lattice l is additive if f x y f x f y and is completely additive if f x f x a completely additive function maps to the dual notions are called multiplicative and completely multiplicative the function f is if f x x for all x and is extensive if f x x for all x a function is idempotent if f f x f x for all x a transformer is a monotone function on a lattice an upper closure is an idempotent and extensive transformer and a lower closure is an idempotent and transformer the pointwise order f g between functions from a set to a poset holds if f x gx holds for all x the pointwise meet of f and g denoted f g where both functions map into a lattice is defined as x f x gx the pointwise join is similarly defined the set of transformers on a complete lattice form a complete lattice under the pointwise order the de morgan dual of a function f on a boolean lattice is f ¬ f ¬ we require the following property of de morgan proposition if f is a completely additive function on a powerset lattice f is a completely multiplicative extensive function the least fixed point of a transformer f on a complete lattice is denoted and the greatest fixed point is denoted bottom and top everywhere the material below is new definition a function f on a bounded lattice is if f x for all x the problem is to determine if a function on a lattice is a witness is an element a such that f a is not bottom a witness a is minimal if no b a is a witness the property and problem are similarly defined the dual notions for the problem are a witness and a maximal witness in this paper we consider the problem for completely additive functions on powerset lattices lemma a completely additive function on a powerset lattice is a lower closure proof consider a function f ps ps for each x in s f x is either or is x because f is since f is completely additive f x equals f x for every subset x of s in particular f x equals x x f x it follows that f f x equals f x due to lemma we abbreviate completely additive function to additive closure for the rest of the paper theorem below is a consequence of lemma it is straightforward to prove but the fixed point view is valuable because an abstraction of a lower closure may not be idempotent in which case a transformer in the abstract yields strictly more precision than applying it once theorem the following statements are equivalent for a completely additive function f on a powerset lattice f is is bottom f is is top the implication from to is straightforward while the implication to holds because f is a lower closure the equivalence of and follows by negation and of and due to the closure property and of fixed points next we show that two wellknown problems satisfiability and error reachability can be reduced to the problem neither reduction is surprising but allows us to think of decision problems rather than function problems as bottom everywhere let struct be a set of structures and form be a set of formulae and struct × form be a satisfaction relation between structures and formulae if is in we write and say satisfies or that is a model of the details of the structures and the formulae are not relevant for the a formula is satisfiable over struct if some in struct satisfies and is unsatisfiable over struct otherwise we drop the qualifier over struct the satisfiability problem is to determine if a given formula is satisfiable we formulate satisfiability in terms of a transformer the domain of structures is the model transformer mod maps a set of structures to the subset containing only models of mod s s properties of can be expressed as properties of mod the set of models of is mod struct and is unsatisfiable exactly if mod struct is empty observe that mod is completely additive and hence it is in the scope of problems we consider we denote the function ¬ mod ¬ as and call the conflict transformer the conflict transformer adds to any set of structures all of the set of of is and is unsatisfiable exactly if contains all structures observe that is completely multiplicative and extensive theorem a formula is unsatisfiable exactly if mod is a witness for mod is a set of structures that contains a model of a minimal witness is a singleton set containing a model of a witness for is a set of structures strictly contained in struct that some models of a maximal witness for is a set that contains all structures except one model of we define two logics for use in examples propositional logic let prop be a finite set of propositional variables the set of literals is lit p ¬p p prop containing a variable or its negation a clause is a disjunction of literals and a formula is a conjunction of clauses as is common in the sat literature we view clauses as sets of literals and formulae as sets of clauses the set of truth values is b t f literals formulae and clauses are interpreted over functions prop b from variables to truth values and are called propositional assignments the entailment relation is defined as follows for each assignment and literal l l exactly if l t if l is a variable and l f if l is the negation of a variable for each clause c c exactly if l for some literal l in c for a formula we say if c for every clause c in inequality logic inequality logic can express order between variables let vars be a set of firstorder variables the set of difference predicates is x y x y vars the set of inequality literals contains all difference predicates and their we interpret difference formulae over integers the set of structures struct vars z consists of functions from variables to integers a structure satisfies a predicate x y if the inequality x y holds for formulae the entailment relation is defined as expected feasible traces via bottom everywhere let m s t be a transition system where s is a set of states and t s × s is a transition relation let s be the set of nonempty sequences of states a trace is a sequence n satisfying that every i i is a valid transition a state t is reachable from s if there exists a trace starting in s and ending in t given sets of states p and q the feasible trace problem is to determine if there exists a trace from a state in p to a state in q we formulate the feasible trace problem as a problem the domain of sequences is ps the feasible trace transformer ps ps maps a set of nonempty sequences of states to the subset containing only traces that start from a state in p and reach a state in q we assume n is the last state of below x is a trace p n q the set of traces from p to q has several fixed point by cousot once again the function is completely additive and we denote the function ¬ ¬ as and call it the transformer the set contains the set x as well as all sequences that are not traces all sequences that start in p but do not lead to q and all sequences that end in q but do not start in p theorem given a transition system and sets of states p and q there is no trace from p to q exactly if is a witness for is a set of sequences containing a trace from p to q a minimal witness is a singleton set containing a feasible trace from p to q a witness for is a set of sequences that a trace from p to q a maximal witness contains all sequences except one trace from p to q the view of feasible traces as to reachability and assertion checking in programs the definition of the set of traces of a program is wellknown and is not here we directly apply the procedures developed in this paper to reason about programs reachable states via bottom everywhere we consider reachability problems defined in terms of states rather than over traces we make such a distinction because the details of lifting are different for abstractions and for statebased abstractions the material here is also required to distinguish from iteration let m s t be a transition system where s is a set of states and t s × s is a transition relation the concrete lattice of states is ps recall that a transition system defines the two transformers below t s s t is in t and s is in x s s s t is in t and t is in x the sets of forward and backward reachable states have standard fixed point below reachable states consist of pairs x y such that every state in x reaches some state in y and when applied in an abstract domain this kind of iteration yields strictly more information than forward analysis or backward analysis in isolation x lfp x p q x lfp x q p y lfp x p y lfp x q x the functions and above are completely additive and the function is completely additive see chapter of notes for a proof to see that is not consider q which will contain the states reachable from p and q respectively intersection can be used to make the function theorem the following are equivalent given a transition system and sets of states p and q no state in q is reachable from a state in p is is is the proof of the first three statements is straightforward the proof of equivalence to is due to cousot a minimal witness for is a state in q that is reachable from p a minimal witness for is a state in p from which a state in q is reachable the function ¬ ¬ maps a set of states x to a set containing x and states that are not reachable from p and states not in q observe that such a function can directly be computed by computing a fixed point using the function ¬ post ¬ the same applies for and the function ¬ pre ¬ these dual functions have been implemented in model checkers and used to compute fixed points henzinger et al discuss temporal properties that can be checked with these fixed points and cousot and cousot combine these fixed points with abstraction note that the functions and ¬ ¬ are different intuitively iteration exploits a temporal duality between and backwards analysis in contrast will exploit a different duality between functions and their de morgan abstract procedures for in this section we apply abstraction to the problem if an overapproximation of a function f on ps is bottom everywhere the function f is also if an underapproximation of the dual function the function f is also we now the and analysis present in sat solvers and model checkers we begin by abstract interpretation abstract interpretation the key idea of abstract interpretation is to solutions to a problem by a fixed point and derive approximate solutions by fixed point approximation for convenience we work in the galois connection framework cousot and cousot extensively discuss these are required to theories such as linear arithmetic because the lattice of polyhedra is not complete and for analysis of automata and abstractions a galois connection between posets c and a written c a is a pair of monotone functions c a and a c satisfying that x y holds exactly if x y does the lattice c is called the concrete domain and a is called the abstract domain monotone functions on c are called concrete transformers and those on a are called abstract transformers an abstract transformer fo a a soundly approximates f c c if the pointwise order f fo holds if c is a powerset lattice an abstract domain a is called an overapproximation because it satisfies x x for all x if a is an abstract domain of c it is called an underapproximation of c because it satisfies x x a sound abstract transformer on an overapproximation is called a sound overapproximation and one on an underapproximation is called a sound underapproximation the next two notions precision of an approximation a galois connection implies there is a precise approximation f called the best abstract transformer an abstract transformer fo f is complete at a if f a and is complete if it is complete at every a if an abstract transformer fo is complete at a no precision is lost for example if post is a concrete successor transformer and is a sound abstraction that is complete at an abstract state a every abstract transition from a also exists in the concrete in other words there are no spurious transitions and discuss completeness in detail parametric fixed points we require the notion of a fixed point above or below an element let f l l be a monotone function on a complete lattice and a be an element of l the greatest fixed point below a denoted is the greatest fixed point of the function xf x a the least fixed point above a denoted is the least fixed point of the function xf x a the parametric fixed point functions below map an element x of l to the least fixed point above x and greatest fixed point below x respectively and interpolation we use the terms and interpolation for techniques used to fixed point computation operators move or from an element in a lattice as illustrated in figure interpolation operators move between elements lfp figure to a greatest fixed point and interpolation to a least fixed point the two operations are not dual let l be a lattice an l l is a unary extensive function we write a for the application a the dual notion of a l l is a unary function the definitions above are based on but not identical to those for widening operators without a well requirement a interpolation is a binary function l satisfying that for all x and y in l the inequality x y implies the inequality x x y y we write interpolation application as x y the standard definition of a narrowing operator extends interpolation with a condition the notions of interpolation and dual narrowing both denoted are defined note that and interpolation are not dual operations just as widening and narrowing are not dual though interpolation is we distinguish between and interpolation based on whether the operator is used in a least or greatest fixed point computation completion completion is an operation that an abstraction with disjunction consider an abstraction a of a powerset lattice ps with the abstraction a is disjunctive if a b a b a subset q of a is closed if for every x in q and y in a y x implies that y is in q a set is called a the smallest containing q is denoted q and the of a singleton set x is denoted x in examples we denote a as the set of its maximal elements we omit a general discussion of when such a representation is possible the lattice over a written da is the set of of a ordered by inclusion strictly because the lattice with respect to the identity relation is isomorphic to ps the completion of a is the lattice da with the abstraction and functions below in contrast to the standard treatment we use as abstractions da d a ps x x q da ps d a x x p for proofs that the pairs of functions above form galois connections and that the domains are disjunctive abstract we apply abstract interpretation to determine if a function is let o be an abstract domain in a galois connection with ps we denote the abstraction and functions as o and o we assume that o is the empty set let fo o o be a sound abstraction of a completely additive function f if to the function f is if does not to we do not know if f is due to in the transformer this intuition is stated below and the proof follows from the basic soundness results of abstract interpretation theorem if f a completely additive function on a powerset lattice fo o o is a sound overapproximation of f and is the function f is if we know that fo is complete at some element a we can determine despite working in an abstraction that f is not since fo only has to be complete at a single element the lattice and transformer may still be proposition if fo is complete at a and is not f is not the procedure below takes as input an transformer fo an abstract element o and a operator in addition a procedure to check emptiness o is required together with a sufficient criterion for completeness of fo the procedure attempts to determine if fo is bottom on all elements below o in the lattice the output is a pair with the first element being either not or unknown and the second element representing the last lattice element obtained if to the function f is bottom on elements below oo if fo is not bottom on the fixed point o and is complete at o we know f is not neither condition above may hold due to in the transformer or domain in this case is used to check if fo is also bottom on elements below the fixed point unlike standard applications of widening is applied here to improve precision algorithm abstract search for a non witness o o o o o o repeat o o o o foo until o o or o if o then return o if fo satisfies completeness criterion at o then return not o d o if d o then return return d model search in sat solvers we show that the procedure in algorithm model search in sat solvers the abstract lattice contains partial assignments the abstract transformer is called the unit rule the greatest fixed point computation is boolean constraint propagation and is implemented by decisions we briefly elaborate on these points further details are in a partial assignment maps each variable to true false or unknown the set of partial assignments vars true false consists of partial assignments and a unique element in implementations of sat solvers the state is indicated by a special conflict flag partial assignments form a lattice with respect to the natural pointwise order and are equivalent to the constants lattice or the cartesian abstraction for boolean valued variables the element represents a partial assignment in which all variables have undefined values and represents the empty set the function maps to and to the set defined below for all x vars x implies x x propositional solvers deduce properties about a formula using the unit rule the unit rule asserts that if a partial assignment is defined on all but one literals in a clause and does not satisfy those literals it must satisfy the remaining literal to satisfy the formula for a propositional literal l we write l if l x and x t or if l ¬x and x f the unit rule for a clause is a decreasing transformer on the lattice of partial assignments x t x f for all l c c c x x and for all l c c c ¬x x and for all l c otherwise moreover can be as the best abstract transformer for the model transformer mod c the unit rule extends to formulae in by taking the pointwise meet of unit rules for each clause in the formula unit unit c c boolean constraint propagation repeatedly applies the unit rule and computes the fixed point a solver makes a decision by assuming that some variable which is unknown in a partial assignment has a definite value a decision maps a partial assignment to x v where x is unknown in and v is a truth value observe that decisions are applications of a downward operator if all variables are assigned to t or f in then otherwise is x t or x f for some x such that x consider the conditionals in if starts from and leads to the formula is unsatisfiable as returned by the first conditional a sat solver terminates if it finds a satisfying assignment since assignments are partial assignments the unit rule applies to them observe that unit for an assignment is if does not satisfy and is otherwise more generally unit equals mod so finding a satisfying assignment is a sufficient condition for completeness another sufficient condition is that at least one literal in each clause is satisfied by the current partial assignment to the algorithmic content of model search in a sat solver is an instance of where o is propositional decision making fo is given by unit and the completeness check tests whether all variables have been assigned to t or f several heuristics and carefully implemented data structures are required to achieve high performance with but these aspects correspond to the fixed point iteration and abstract domain implementation model search for inequalities we instantiate for reasoning about inequality formulae let lit be the set of inequality literals we introduce an inequality abstract domain which contains only conjunctions of inequalities specifically each element of where represents a conjunction of inequalities we use the superset order because a larger set of constraints represents more constraints and has fewer models the join is intersection of sets of constraints and meet is union the empty set represents true and the set of all inequalities is one representation of false observe that false has multiple representations because every set containing a predicate and its negation is equivalent to false recall that the concrete domain of structures was z the function z maps a set of constraints to their models p for every p in we use an example due to et al to illustrate on an inequality formula a b a c b d c d d a as with propositional logic we will use the best abstract transformer for a clause but construct the transformer for a formula in the abstract mod c c we apply to check satisfiability of the sets below represent the evaluation of each clause in the abstract domain a b a c d a a b a c d a d b d c bd cd lit the second step above requires explanation the best abstract transformer for the singleton clauses when applied to has the effect of computing the transitive closure of constraints in due to a b and d a the inequality d b is added to the conjunction of with b d represented by bd is unsatisfiable as is the conjunction of with c d the best representation of an unsatisfiable conjunction is the set of all constraints compare the calculation above to solving the same formula with in a propositional variable would have been introduced for each predicate and two solvers one for propositional logic and one for inequalities would have been required to solve the formula by instantiating we can solve the formula using only the abstract domain which plays the role of a theory solver and without introducing extra variables this difference becomes important for large formulae and is the motivation for techniques like natural domain smt the generalised technique of et al referred to as also solves this formula without introducing propositional variables unlike makes decisions and uses the rule for conflict analysis to solve the formula an instantiation of over may use as defined above for fo a decision operator such that and otherwise x y such that x y is not in the completeness check for an element can be performed by determining whether for every clause c the intersection c is nonempty the check for o being empty amounts to detecting a conjunction of unsatisfiable constraints if constraints are represented as directed graphs the emptiness check is implemented by cycle detection feasible traces the approach to the feasible traces problem is to construct an automaton representing the traces of a system and the negation of a correctness property and check if the language of this automaton is empty this approach can be viewed as indirectly computing the greatest fixed point of where p represents the set of initial states of a system and q represents states that violate a property abstract is distinguished from several procedures that combine dual reasoning because the procedure used to reason about the problem is not dual to let u be an abstract domain that ps with functions u and u we assume that u is s let fu u u be a sound abstraction of a completely multiplicative extensive function f where f is completely additive and if to then the function f is the procedure computes an underapproximation of a least fixed point using the interpolation operator correctness follows directly from known theorems in abstract interpretation and it suffices for us to discuss instantiations of this procedure algorithm abstract non fu u u u × u u u u c u u if c then return c if fu satisfies completeness criterion at c then return not c if c u then return unknown c return fu c conflict analysis in sat solvers we now show that conflict analysis in sat solvers is an instance of consider the completion of partial assignments treated as an underapproximation that is every set of truth assignments is by a set of partial assignments conflict is a technique used by sat solvers to the reason behind a partial assignment leading to a conflict techniques replace a partial assignment with partial assignments from which can be derived by the unit rule there may not be a unique partial assignment from which is derived so of partial assignments have to be considered we define a transformer for conflict below q q for some c conflict can be viewed as restricted application of resolution example consider a formula x ¬x y and a partial assignment x true y true such that is since y can be derived by the unit rule if x is true and x can be derived if y is true we have x true y true there may be many ways to a conflict but generating all solver memory to avoid representing sets of conflicts a sat solver usually chooses one conflict in example each set in x true y true can be used we model this step with a choice function choice × the choice function ensures that the effort of a conflict is not lost and satisfies choice where and are observe that choice is an interpolation we that the soundness of the procedures in this section follows from standard results in abstract interpretation over programs instances of are procedures that least fixed point computations for example the set of all counterexamples leading to an error can be defined by a least fixed point counterexample analysis techniques usually this set by choosing one or some subset of counterexamples with fo learned transformer with fu conflicting element not figure abstract conflict driven learning abstract conflict driven learning the procedures in the previous section were treated separately the algorithm in modern solvers combines and as in figure rather than return unknown from information from the fixed point computation if produces results can still learn information about the conflict for the greatest fixed point computation this section makes this combination precise the abstract conflict driven learning procedure is shown in algorithm the procedures runs of and communication between the two procedures is achieved using two functions and learn conflicting elements are from to a function we require that this function soundly f ie that f o u a natural choice for this transformer is to compute the composition u o which maps an abstract element in o to its best in u in the other direction a transformer is as discussed below algorithm abstract conflict driven learning o o o o fu u u u × u u o u learn u o o loop s o if s then return s o u s u fu u if s then return u fo fo best learning transformer if derives starting from o to determine if f is bottom at a concrete element c it suffices to check if f is bottom at because f is if is invoked on an abstract element a it suffices to check if fo is bottom on elements below oa the procedure is used to an element that leads to a conflict but it operates in an domain thus we need to learn information about elements after within an underapproximation the best learning transformer is a function that takes elements u and o and u from o learn u × o o u theorem let fo be a sound overapproximation of a completely additive transformer f and let fu be a sound underapproximation of the de morgan dual f of f if represents the empty set then the transformer fo where u is oo is a sound overapproximation of f theorem strictly the notion of learning from sat solvers to every instance of the problem we give an example of a simple sound learning procedure supported by all lattices an element that leads to is in the sense of search learning defines a sound learning transformer u × o o o if o u otherwise the rule checks whether search has entered a region that is known to map to theorem soundness if returns not then f is not bottom everywhere if it returns then f is bottom everywhere proof assume the algorithm returns not then returned not o then fo is complete at o oo and foo o by completeness we then conclude that f is not bottom at oo assume the algorithm returns then re turned we denote by u the initial value of u in abstract non and by u the return value with u u it is an invariant of the algorithm that fo is a sound overapproximation of f hence whenever returns o it holds that f oo it holds that u u oo for such an o by duality we have that f oo u u returns u u such that u u by soundness of abstract interpretation it holds that u u fu u since f is an upper closure operator with f u u and fu u it follows by idempotence that f it follows that f therefore f is bottom everywhere abstract conflict driven clause learning the previous section showed that the notion of learning is very general clause learning is a specific form of learning in which abstract transformers are implicitly represented by clauses since model search in sat solvers is driven by the unit rule clause learning can be viewed as learning unit rule transformers we present a generalised unit rule that clause learning to richer lattices abstract conflict driven clause learning is a strict of the algorithm in sat solvers in § we demonstrate that propositional solvers operates over the partial assignments domain and its completion we present as a variant of the procedure presented in the previous section operating over an overapproximation o and its completion do clause learning to understand the essence of clause learning it is useful to compare the unit rule with learning consider a clause c p and the partial assignment p f q t which contains no satisfying assignment to c consider strictly greater than we have that however if is the partial assignment p false by unit rule application we have p false q false the rule only search away from elements where f is bottom in contrast if f is y c y c q x x figure generalised unit rule for intervals almost bottom on the unit rule the search away from the part of that leads to bottom example we illustrate a generalised unit rule for the abstract domain of intervals over integers assume an abstract transformer fo is on the interval c in figure we design a generalised unit rule that maps the interval q in the figure to the interval which the search to the portion of q not known to lead to in what follows we write an interval constraint such as x y as x the complement of the interval c x y is not an interval however c is the intersection of the infinite intervals x x y and y the complement of each of these intervals is an interval and the set of can be viewed as a clause containing x x y and y the meet of q x y with each element of this generalised clause is bottom for all elements except x so we only consider x in this way we the propositional unit rule to new domains we point out the to the propositional unit rule every interval is the intersection of infinite intervals just as a partial assignment is the conjunction of literals infinite intervals like propositional literals have the complement of a partial assignment is a clause and the complement of an interval can be represented as the disjunction of infinite intervals the rest of this section the unit rule to new domains this section deals with of lattice elements into elements which cannot be further decomposed called an element m is meet irreducible if x y m implies that x m or y m the set of meet of a lattice a is ma a function a is a meet decomposition if for all a the set is finite and a a meet decomposition is if for any a a and b it holds that a a most abstract domains used in practice have an obvious unique meet decomposition eg partial assignments decompose into partial assignments with only one variable taking a boolean value intervals and decompose into sets of a number of examples of possible abstract domains with are given in figure are not limited to numeric abstractions for example the depicted controlflow abstraction abstractly represents a set of traces in terms of controlflow branches an element a of an abstract domain a has a precise complement if there exists an element a such that a ¬a a has meet if every element m ma has a precise complement m ma a domain a admits meet if a has meet and a meet decomposition generalised unit rule an abstraction a with meet admits a generalised unit rule a × a a in contrast to the propositional unit rule which is defined with respect to a clause we define the with respect to elements that lead to this is only a difference of presentation since the negation of a clause is a partial assignment on which unit is bottom for all m a a n m n and for all m m a a otherwise m m if returns a n as above we call n a unit irreducible the transformer can be lifted to a learning transformer o × u o where u do for a set s we define cs we skip the proof that is a sound learning transformer we instantiate abstract conflict driven learning with to derive abstract conflict driven clause learning an abstract algorithm abstract conflict driven learning is sound to achieve completeness we need to ensure that learning the procedure to explore new regions of the abstract lattice the abstract algorithm appearing next the search of propositional the abstract procedure in algorithm operates over an domain o with and its completion do learning refines the transformer fo with the generalised unit rule algorithm and clause learning o o o o fu do do do do initialize o to singleton sequence o repeat s if s then return s u s c fu u l fo fo fo l until is empty return not o o o o o o repeat o o o foo o until o o or o if o then return if fo satisfies completeness criterion at o then return not d o if d o then return return · d the algorithm uses a modification of to record transformer application on a stack concatenation of two stacks concrete domain abstract elements meet irreducible concrete abstract elements meet intervals pv z l x u x x array abstraction pv n z x y x i x i pv z ± y c x y x y set abstraction pv d × sv pd x s y r xq xq equality pv z x y w z x y x y controlflow abstraction p traces li else l else l if figure the set v represents program variables and is denoted by · the difference to is that after learning the procedure to a state before the element that is by the learning transformer a call to fo returns a nonempty prefix of such that fo where fo l fo if no such prefix exists the empty sequence is returned indicating that fo is progress and precision if we extensions such as and propositional never generates the same clause twice the number of clauses over a fixed set of literals is finite so a solver makes constant progress and necessarily terminates the procedure makes progress if each iteration of the outer loop decreases some wellfounded order solvers do not return unknown decisions refine partial assignments until either or a satisfying assignment is obtained in propositional solvers decisions are made by computing a greatest lower bound between the current element and a meet irreducible that is a partial assignment in which only one variable is not decisions never directly cause a conflict we these conditions below a meet irreducible is a operator o o satisfying two conditions o equals o m for some m if oo is not o o is not the precision requirement given next ensures that a sequence of decisions eventually leads to an abstract element that can be without loss of precision a is precise if whenever o is equal to o the function fo is complete at o with respect to f the progress condition in a propositional solver is that learning causes model search to deduce new information the generalised notion we use is that of which ensures that the procedure away from the element that most recently led to a function is if whenever fo returns then is the empty sequence or l is strictly smaller than this condition ensures that the search into a new part of the search space lemma in some iteration of the main loop let and be respectively the stack before and after if the function is then after learning it holds that fo and are incomparable proof let o and o be respectively and and let c be the element returned by it holds that c o let o m where m is the unit irreducible and therefore after learning foo m it holds that m c and therefore also m o we now show that foo and o are not ordered assume for a contradiction that foo o then it holds that foo m since we also know that foo m it must hold that foo this violates the condition that the function returns a prefix therefore foo o now assume for a contradiction that o foo then o m and from o c we can derive o m and consequently o this is not possible because never returns a representing the empty set we have shown that o and foo are incomparable analogous to the case of propositional sat can be implemented using a operator we informally sketch the reason let be the stack kk m during a run of the procedure such that the last element k m is derived by applying a operator if we can determine that f o we may refine fo by learning the transformer to k and then applying yields the element k m which the search to a new region theorem relative completeness if the is precise and fu terminates the result is or not proof we prove by contradiction if unknown is returned returned unknown o which is only possible if o equals o since is precise we know that fo is complete at o this is impossible because not would have been returned theorem termination if o is finite and are then makes progress proof the procedures and terminate over finite lattices to prove the theorem we assume that the outer loop of is nonterminating and derive a contradiction let r be the last element of the sequence at the beginning of an arbitrary iteration of the main loop of since the lattice is finite we can reason using wellfounded induction we show that eventually the stack to a prefix whose last element is b r base step assume r is an atom meaning every r that satisfies r r also satisfies r then the step will be with r and will return an element c r therefore it holds that after learning for therefore necessarily returns to an element b r in order to satisfy the condition that after a induction step assume that for all r r the induction hypothesis holds assume for a contradiction that never jumps to an element greater than r then r is the target of a infinitely often then it must be the case that in two subsequent iterations i and i returns a stack with the same final conflicting element c such that r is the target of the corresponding in both cases after the first such we have by lemma that fo immediately infers an element a r such that a and c are unordered specifically a is not greater than c therefore any subsequent call to returns a stack with a last element that is smaller than a and therefore different from c this contradicts the above which states that i from c this completes the proof it therefore holds that in an infinite run backtracking will eventually return an element strictly greater than this is impossible hence all runs of terminate though we only show termination for finite lattices the termination of is usually nontrivial to argue when applied to decidable logics that involve infinite lattices such as linear arithmetic specific details of the theory the transformers and acceleration techniques must be used to prove termination it is not clear that there are general termination arguments for infinite lattices and chain conditions are not enough because of the alternation of the two procedures and the use of decisions and choice which also operate on infinite sets abstract implication graphs the design of transformers such as fu is a challenging problem that has received less attention than the design of transformers sat solvers use fo applications to construct an implication graph and use this graph to derive fu we now implication graphs to other domains implication graphs as transformer abstractions consider a proof rule that when applied to a an yields the c if we view and as elements of an abstract domain we can a proof rule as a transformer fo that satisfies fo a an c implication graphs provide a means to derive from thereby implementing an abduction transformer recall that mo is the set of meet of o an implication edge is a directed in ei we order implication edges so that e e means e requires weaker than e to derive stronger define m m m m to hold if m m and for every m in m there exists m in m satisfying m m an implication graph g is an set of implication edges and the domain of implication graphs i u ei contains implication graphs with the order in practice an set is represented by its minimal elements figure contains examples of implication graphs all incoming edges to a node represent one and each represents its a of the form m is depicted by m an implication graph represents an abstraction of a transformer as shown below assume below that fo is a transformer let red o be the lattice of transformers on o with the pointwise order define two functions i red o i and i i red o below if m m ei f m m ii o m m m i m o proposition the functions i and i form a galois connection example we illustrate the application graph construction for reachability analysis of a program with the interval abstract domain the problem is to determine if the location is reachable in the flow graph in figure an implication graph derived by applying abstract successor transformers is shown the label dl denotes decision level which contains meet that are without making assumptions these represent facts obtained by a run of a static due to the error is reachable in the abstract suppose we apply to force the constraint a at the location n this constraint is in the figure if we continue static analysis with this assumption we conclude that is unreachable the facts required to arrive at this conclusion are shown in the implication graph in the figure extracting dual transformers we now show how conflict analysis can be viewed as construction of a dual transformer from an implication graph the dual transformer maps a set of consequences c to the set of a from which we could have derived c the dual implication transformer defined by an implication graph i is do do below c c q m q m c m m i theorem if the implication graph i represents an overapproximation of fo the transformer f proof consider an implication graph i that the transformer fo and a closed set c o we prove the inequality do c f we show that is in c for all c in c consider c in c if c is in c we have that is in c because fo is and c is if c is in c c c is by definition of the form c q m where q m is in c for some m m in i since i soundly approximates fo we have that fo m m and as a consequence also that m q m since c is closed and q m is in c it holds that c c we have shown that c c is contained in c the soundness of fo implies that the of f oc c c is contained in the of oc c c we can rewrite the above condition as f do do where is the pointwise lifting of the subset order the functions f f form a galois connection due to which the inequality f do do is equivalent to do f do thus f example consider the interval implication graph i shown in figure consisting of the following y x y x x x we compute a least fixed point over and represent sets by their maximal elements c x x c c c y x x c c c it follows that the formula is unsatisfiable this fixed point computation in which meet are replaced by their is similar to conflict analysis in sat solvers implication graphs we briefly discuss implication graph see for a more algorithmic discussion in propositional meet are of the form x v where v is t or f meet irreducible partial assignments are incomparable in more general lattices such as intervals there is an order on meet the order on meet represents implications that follow from theory axioms this order intervals xy x y array y ix x i y y x x x i y i y i z x z set q x q xy xz y z x z x q xs xq equality z x z xy yz xz xz controlflow c l ifc b else b l error else safe l else l if to reach error l else figure abstract implication graphs a n a dl c a c a c a c a c a c a a a n b n b c c c c b b b b dl n a c n b b n b b n a c a c n b b c c b figure implication graph for reachability of the program location marked with can be used to implication graphs to derive more useful dual transformers example we illustrate implication graph on the example in figure computing for the graph i depicted leads to a sound transformer using this transformer one can find for example that n b is sufficient to deduce a conflict there is a more general graph that still allows deduction of of the constraint on the node n b can be to obtain n b likewise c a and n a can be generalised respectively to c and n a computing over the resulting graph i allows one to find that n b is sufficient to deduce a conflict by the graph we can derive more general conditions under which a location is unreachable learning allows us to this condition and discover that the flow graph always satisfies n b because the variable b is in the interval at the location n we can now prove that is unreachable without any assumptions we note that instantiated in this way over programs is a method to dynamically discover a trace partitioning related work a survey of the literature on combining logical solvers and abstract interpreters is beyond the scope of this paper we limit ourselves to discussing extensions of solvers to richer problems the architecture also called lazy smt combines a sat solver with a solver for the conjunctive fragment of a theory to determine satisfiability of quantifierfree formulae in a theory in the original lazy smt architecture decisions and learning take place in the propositional solver which may cause theory facts to be splitting on demand allows new theory facts to be encoded by propositional variables and added to a formula is an alternative to lazy smt in which all reasoning happens directly in a fragment of the theory and no propositional solver is required see for a theoretical and empirical comparison of and other approaches that a propositional solver in of making decisions and learning directly in a theory include smt generalised and theory specific solutions for equality and integer linear arithmetic using the proof system is one for to new domains the details of the decision and learning operations have to be designed for each theory but the algorithm used by the solver and its soundness and follow from our work in separate work we have instantiated to derive an smt solver for floatingpoint logic and shown that this solver performs better than using a propositional encoding and better than smt solvers use the and delayed theory combination methods to combine solvers for different theories abstract interpretation is a modular framework which allows abstract domains to be combined in several different ways the method and have recently been shown to be instances of more general product constructions in abstract interpretation these product constructions lift to instantiations of if can be instantiated over domains o and o it can be instantiated over the product o × o our work allows to be lifted to verification problems we have instantiated with the interval abstract domain to the bounds of variables in programs with floatingpoint variables lazy annotation with interpolants to programs and uses an smt solver to implement constraint propagation and craig interpolation for learning we work with abstract domains and do not assume the domain is closed under boolean operations or that it supports interpolation satisfiability modulo path programs to programs by combining a sat solver and an abstract interpreter and method has been lifted to programs in our work provides an abstract interpretation view of which we extended to other procedures in and to in an account of method is given in and contains a transition system view of a natural question is whether is a form of counterexample abstraction refinement cegar cegar uses non witnesses to construct a new domain and new transformers implements transformer refinement and makes progress when no non witness is found never changes the domain and this is crucial for efficiency because the implementations of the abstract domain and transformers can be highly conclusion in this paper we applied abstract interpretation to study the conflict driven clause learning algorithm implemented by sat solvers we showed that can be understood as a approximation algorithm that combines of greatest fixed points and of least fixed points to determine properties of a function on a boolean lattice our generalised abstract conflict driven clause learning procedure and its correctness proofs rely on properties by the data structures in sat solvers as well as by abstract domains used in practice in separate work we have instantiated to derive an smt solver and a program and obtained positive results problems to investigate in future instantiations include satisfiability in theories of weak arithmetic assertion checking with relational abstract domains and of pointers a second family of problems is to design abstractions of states and traces so that can be applied to model checking problems and to determine emptiness of nondeterministic automata over finite and infinite words we the paper by a question by and about whether the from the success of sat solvers lift to other domains we believe that our work a mathematical answer to this question that applies to algorithmic issues our work does not explain or provide a means to lift the heuristics used by sat solvers to new problems we conjecture that heuristics to efficiency of constraint propagation are closely related to those for exploiting in program analysis it is our hope that future work will provide a framework for understanding these connections and for lifting engineering techniques in sat solvers to new problem domains acknowledgments this work was supported by the corporation project project and the fp was supported by a microsoft research phd we thank the abstract interpretation community in particular and cousot for their support and of this work thanks lee and lee for their in an independent project which allowed time for this one references b j van de o and h generalizing and satisfiability for equalities information and computation ­ c r a and c splitting on demand in sat modulo theories in proc of logic for programming artificial intelligence and reasoning pages ­ m v l a and d an abstract interpretation of in proc of verification model checking and abstract interpretation to appear e clarke o s y lu and h counterexampleguided abstraction refinement for symbolic model checking j of the acm ­ s natural domain smt a preliminary in proc of formal modeling and analysis of systems pages ­ p cousot constructive design of a hierarchy of semantics of a transition system by abstract interpretation theoretical computer science ­ p cousot abstract interpretation mit course p cousot and r cousot systematic design of program analysis frameworks in proc of principles of programming languages pages ­ p cousot and r cousot abstract interpretation and application to logic programs journal of logic programming ­ p cousot and r cousot abstract interpretation frameworks journal of logic and computation ­ aug p cousot and r cousot refining model checking by abstract interpretation automated software engineering ­ p cousot r cousot and l the reduced product of abstract domains and the combination of decision procedures in proc of foundations of software science and computational structures pages ­ v l and d satisfiability solvers are static in proc of static analysis symposium pages ­ v l d and m numeric bounds analysis with learning in proc of tools and algorithms for the construction and analysis of systems pages ­ h g r a and c fast decision procedures in proc of computer aided verification pages ­ r and e incompleteness counterexamples and refinements in abstract modelchecking in proc of static analysis symposium pages ­ l a m and d deciding floatingpoint logic with systematic abstraction in proc of formal methods in design pages ­ w r s f and a gupta program analysis via satisfiability modulo path programs in proc of principles of programming languages pages ­ t a henzinger o and s qadeer from to symbolic model checking formal methods in systems design ­ d and l m de to the solving linear integer arithmetic in proc of automated deduction pages ­ s and l boolean satisfiability from theoretical to practical success communications of the acm ­ aug k l lazy annotation for program testing and verification in proc of computer aided verification pages ­ k l a and m sagiv generalizing to richer logics in proc of computer aided verification pages ­ r a and c solving sat and sat modulo theories from an abstract procedure to jacm ­ x and l the trace partitioning abstract domain acm transactions on programming languages and systems n and a learned clauses in proc of theory and applications of satisfiability testing pages ­ a and t reps a generalization of method in proc of static analysis symposium pages ­ a and t reps a method for symbolic computation of abstract operations in proc of computer aided verification springer 