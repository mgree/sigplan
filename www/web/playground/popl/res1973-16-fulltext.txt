optimization working paper a di italy b k and l r strong ibm j watson research center heights new york usa this paper discusses the of procedure optimization and a general theory of semantics which is motivated by technical problems in specifying and program that optimize procedure one particular transformation is treated in detail recursive algol procedures sometimes pass parameters by name in such away that the general thunk is unnecessary and inefficient we present an optimization which detects this kind of callbyname and implements it we prove that the transformation preserves semantics and we discuss the effect on running time and management and overview programs written in procedural languages can a substantial portion of their running time to procedure entry and exit in a language with recursion and block structure the a straightforward compilation may be costly for example a variable local to a procedure may be during a recursive call but then not be used anywhere after the call an optimizing compiler should detect and remove many instances of unnecessary and similar procedure optimization is especially important for large tasks where is critical has shown that the goals of are often best when the modules do not correspond to the boxes in a flowchart the process being he points out that the information hiding criterion he proposes has one major without optimization of procedure a system according to this criterion is much less efficient than one according to major stages in processing page to this we add that the procedures in a system according to information hiding are likely to be recursive recursive procedures cannot be eliminated by simple of calls so other means of optimization explored a theory of optimization requires some mathematical representation of programs both before and after application of optimizing the mathematical framework should be helpful in proving that optimized programs really do compute what the intended none of the available semantic theories are suite right for optimization have yet another semantics from ideas present in various places in the literature particularly this theory of semantics is sketched in section after a discussion of an representation of programs in section section deals with one particular optimization callbyname section further work in progress section the semantic theory used here with other work tree the nesting of statements and expressions within each other and the roles of each part in the whole are naturally expressed by a tree structure with labelled nodes and an ordering on the children of each node as in text x a b tree x d these trees are somewhat more convenient for our purposes than trees section trees are not enough for our because control flow is not we also need a representation like a flowchart a directed graph with symbols on the nodes and arcs we call such graphs because a similar but less general that name in the literature on graph grammars the web representing a program should have at least one node for each statement in the program and the arcs should express possible control flow h appropriate web can be obtained by arcs between the nodes in an tree for operators representing complex combinations of simpler statements such as block for blocks or cond for the conditional construction we add an extra operand called a have the operator cd and act like the dot in adding a as an explanation of if p then a else b in figure we simultaneously represent an algol block as a tree and as a web most of the symbols used are specific to algol or its close only next and are part of the general theory the arcs labelled are not control flow arcs they point from uses of names to their declarations the and other information in lower case are not part of the web which every name and uses explicit arcs rather than of character strings to connect name uses to name declarations the combination of tree structure and web structure is crucial to our treatment of section section independent of syntactic details in addition to the indicated by procedure declarations high level languages have other with wide variety of syntax fixed in their defining interpreters for example iteration are in algol section and this would be applied when control reaches the node marked iter in figure are essentially rule section pairs r s some leaves of rand symbols rather than operators x has a domain of trees occurrences of x are an arbitrary tree from appear in a program rule ma be applied at nodes in trees replacing subtrees that match the r by subtrees that match the s in addition to the considerations fi o section we specify a fairly simple convention for carrying along the web arcs here we will not fix on any particular set of tree structured as the set of programs for we do not wish to define any one language here we only wish to explore the consequences of that are satisfied by fairly natural definitions of procedural languages to define any particular language in such a way as to the theory one would have to specify a vocabulary of symbols a set of programs domains for parameters in rule and so on how this is done is of no concern to us at the moment the kind of language considered here is algol w and on conditions there is one feature of some of these languages that we cannot deal with declarations which call for nontrivial tions in array bounds for example we that there be only constants variables and arithmetic operators conditionals procedure calls and other expressions involving a flow of control must be kept out of most declarations the one exception is of course the procedure declaration which may arbitrarily elaborate computations in the procedure body the symbols carried by nodes in trees for any given language form its set of o symbols we assume that all only on nodes with k children for k a nonnegative integer operator appears only on nodes with two or more children table i lists the special operators assumed by the theory any given language uses most of these plus many operators to itself the symbols carried by web arcs for sw given language its set of cursor symbols table ii lists the special assumed by the theory some other operators and used by algol appear in figure in figure we used the special cursor start for starting the process ing in blocks as well as in groups this additional use is not part of the general theory we assume that operators have been classified in three ways the classification for special operators is in table iii other operators must be classified in such a way that declarative and are declarative must also be we also assume that the set of tree structured counted as programs has various reasonable properties for a node has at most one the only in the general theory are the operators but given language may other whose are part of the definition of the in the node carrying iter in figure according to figure the is another of algol because the test h an until or while loop may itself be a long our example the test is straight forward so the statement becomes an until statement according to the in figure when the left of an operator use stop o terminate computations o statements group poly treat a series of statements as one statement kl declare a procedure with k arguments call k kl call a procedure with k arguments o refer to procedures or variables m o transfer control formal o parameters table i special operator symbols cursor use start jump pass control from a group to its first constituent pass control sequentially point from uses of names to their declarations point from to their targets table special cursor symbols operator stop continue group proc k formal m imperative yes es yes no yes es yes yes flows imple es yes no yes yes yes yes no macro no no no no yes no no no table iii classification of special operators x next array i hl ea y i non y start ter next k begin integer yk y lo in real array x step e yo end fig tree structured for block web fig iteration of step iu iu test test action ey e next no t y c start c test fy fig partial of the domain of f consists of trees whose operators imply control flow v fig partial of the domain of e consists of trees without implicit control flow next f node involves control flow then figure is used the definition includes such as figures these definitions use symbols as for which actual trees may be substituted each z has a domain dz of trees that may replace it for d for figure contains just contains all arithmetic expressions certain closure properties for the domains and establishes technical to support the results stated in section space does not permit details here we close this section with some terminology to be used later as in section nodes in trees are strings of nonnegative integers the set of all such strings is nn the children of a node n in a program p are all nodes nl appear in p for k a nonnegative integer child is a triple a where mp ain nn and c is a cursor the tail of a is ta m the head of a m in a program p may be a because it carries a or because some proper descendant n calls for some computations before the operation pm can take place for example is not a in algol but expression still be here the call leads to a proper descendant n of the node with and the operator pn is macro if pn were formal or if n had control in p ie with other than then n would also computations when a node n in a program p has no it is said to be h thus a is one that carries a or has proper descendants if n is a in p and p is the result of performing the appropriate at n in p then we write p n pt a declaration is simply a that k for the moment nodes from p which carry formal and have to children pk with kk represent uses of formal parameters procedures computations semantics a state e of the abstract interpreter for a is an assignment of values to all the variables in a possibly infinite ion general theory a few variables for special purposes and puts a few restrictions on the transition relation among states the variables include a set cells of cells which may hold scalars arrays stacks or whatever is appropriate for a specific language a few variables not in cells have special functions in and hold the input and output files proc holds a tree structured web env holds a partial function mapping declarations in to cells this is the environment holds a node in prog the notion of control flow is as much like ordinary flowchart control flow as possible initial state e is the root of in a final state n stop what happens in between is the of control in the current state of the program nodes and the values of expressions built up from cell contents and primitive operations the source programs of a language are those values of prog in initial states for and other languages which have no distinction and value generating are source programs between imperative statements expressions all for algol the source programs which form a proper subset of the programs straight forward of the procedure call in a b c leads to an assignment statement of the b be in end this is although it violates the rules the simplest way to both algol and in our theory without making either is to allow the set of source programs to be properly set of programs contained in the of the interpreter is initial iff is a source program is the empty domain out is each ex in cells is here the default values for out and for cells are part of the definition of any specific language empty files zero numbers and null strings would be natural choices for each pair p such that p is a source program and in is a possible value for in there is a initial state c such that p is like the set of programs the transition relation is language dependent we are concerned with properties of e in procedural languages not with a in which to specify before restrictions on l we state the obvious definition for the inputoutput relation computed by any source program p if in and out are values for in and then where g is to say that prog the initial state to say that carries with prog is final is stop the partial function p is the meaning of p under consideration when we attempt to show that optimized programs have the same meaning as their sources we will find it convenient to treat infinite and successful computations in a uniform way we require that the transition relation be a total function on states for each state c one state such that state if then is said to be a dead final states are dead of course ac computation is any infinite sequence co l of states with e initial if some is dead the ation is said to if some c is final it terminates success even successful computations are in sequences they just eventually with i if x is a set of variables are states then and c s n mod x iff y ny not in order to we also set the use of for each variable x when control is a in prog the theory sketched in section specifies what to do when it is carrying a special operator we have c ti for the obvious choice of ri like continue each merely passes control for other we have yet to rule out like if this program now contains array declarations then else which cannot be executed without scanning the entire program we must the dependence of each on only a small set of nodes the next two will do this first we must say just what means here the of a node n in a program p consists of n together with all proper descendants p of n in p such that is no control arc has tail p let c be a state then is dead or or if c is then no ancestor declarative inp no proper descendant inp is in the domain of tv if is then no proper ancestor of n is declarative in p every n in is ready in the sense of sec pn is and is not formal p some a has and suppose u g mod prog that n is the same subset of and that all p n have pp pp suppose that all nodes in have the same in p and in p then c is and some state ri has ri and prog let p be a program and let p be the result of a node m in p then p p lem let p be a program ad let in the p then there is p such that p and no are performed computation of p on in in the copy rule semantics of procedure calls have been included in our but we have not yet specified the semantics of procedure declarations or any other declarations since we are concerned with meaning not implementation a very simple is appropriate declaration principle let be a state such that a a and carries a declarative operator then e pn where is ha and e u control if the operator is for some k then env nv there is a cell x such that x nn for algol and other languages without a by names w could a value of iv for sharing of storage add that x is not already we close this section with some remarks on the scope of our semantics as was in section we cannot allow declarations to involve nontrivial computations array bounds may be large arithmetic expressions but they must be and this restriction to a subset of languages like all is not much to the programmer the effect of can be obtained by g begin end integer top top begin real array top end inst but to this is so would require a extension of the theory the of section are enough already we prefer to the spirit of phrases like the of operation are called statements section or every executable form that is every except the declarations section by restricting declarations enough to make these phrases meaningful declarations are in fact executed and at runtime too section except for the restrictions on declarations we have the to make programming language features we allow for unrestricted we allow global references in procedure templates these things made the theory more complex then it would otherwise have been but the size and shape of the added burden are what would be expected on intuitive for purposes we considered procedure template with procedure body in applications templates will consists of bodies expressed as tree structured augmented by and appropriate to the parameter passing mechanisms used for example suppose an algol procedure with body b has a real formal which is passed by the template corresponds to real formal b and the actual for in a call on the procedure would be substituted name for formal this reduction of callbyvalue to callbyname is part of the definition of algol section and hoare pp state the same reduction more along with a similar reduction of to callbyname the only other parameter passing mechanism we are familiar with is this can be reduced to callbyname via a reduction to callbyvalue to pass e by reference is to pass the address of e by value page in short our theory applies to languages with various parameter mechanisms the necessary reductions to call have already been used in nature to explain these mechanisms callbyname algol procedures sometimes use call by name in a very simple way once nonrecursive calls have made available some addresses the recursive calls merely pass the addresses down to deeper levels of recursion using a formal criterion which detects this situation as a special case an optimizer can eliminate some of the parameters passed by name to a recursive procedure for us a procedure in a program is a procedure declaration node a node p such that p carries the operator for some k the nodes pl p k are the formals of p within the template is from p is said to be other conditions on the other calls on p the call by name transformation will be applicable throughout this section we suppose that p is a program p carries in p and y is a subset of the set p of formals let a be any or jump arc in p then we say that a is under node n such that n is an ancestor if n is also an ancestor of ha then a is bound under n otherwise a is free under e distinction is same as or we choose words from logic instead so as to avoid possible minor with the usage in languages now suppose that n is an actual parameter node in a procedure call within the of p the parent m of n has po and mi n for some i o for arc a which is under n is said to be iff it is either bound under n or free under p thus the name a may be either strictly local to the actual parameter n or global with respect the procedure p condition let n be an actual parameter node in a directly recursive call on p and let n correspond to a member of y the for some pk then the following holds every is informally this condition says that the procedure cannot pass just anything to itself as an actual for a member of y it can pass a member of y it can pass something relatively global it can pass an expression which declares the names it uses last possibility does not arise in algol it does arise in and other languages which consider all statements to be expressions the second condition for callbyname is simply that recursion cannot be in from the outside a call on p by name to a call on p condition let an actual parameter in a call on p which is not directly recursive and let n correspond to a member of y no call is from n if both conditions hold we say that y is a set of formals in order to exploit this situation we must define transformations that act on each call m on p determines an correspondence cm for y for each y in y pk the together with all web arcs inherited from p including any arcs from descendants of mk to of mk for example m might be a directly recursive call and the actual for y might be a reference to a member z of y then would be on the other hand might be a declared at nodes n and n n for each directly recursive call m cm determines a transformation cm which acts on such for any correspondence a and in y let with y pk az z now consider the set of transformations g ma directly recursive call this set generates a monoid m i in g all jj where is the usual composition after h g h g in the example we with each choices k in mk thus is the identity mapping and is one in general be much larger than gl but it will always be finite what is the consider an arbitrary call m on p which is not directly recursive let m be a recursive call at m leads to call on p at the node m by condition the new correspondence form is derived from the old one for m in a very simple way q y cm further lead to further calls for any such call say q derived from the call m we have cq f cm for member now we can exploit for each choice as a call which is not directly recursive and each choice we form a new procedure p mf with only k formals the template for differs from that of p in two ways first any descendant with a to some y in y is replaced in by whose descendants form y second each directly recursive on p is replaced call f in formals not in y are treated just as inp let h calls in are not directly recursive and m us there are procedure declarations p m f the new program p is like p except at p and at calls on p which are not directly recursive in p p carries group and has children these are declarations listed in an arbitrary order plus the each call m in p becomes a call on pm ij in p where i is the unit element in m theorem let p be a procedure declaration node in a program p and let y subset of the pose y is then the p has the same meaning as p a value for in we must show that p in p we may assume at least one of these is defined suppose out the argument in the other case being similar we show out by there is a o pj of programs such that p p pj in one step to for all j j and pj computes from g to with no let p be p c j pj is like pj except for differences in procedure declarations and calls each call on p in pj appears as a call on some by to the expansion that takes pj to we can form p so as to be like j pj l except for the p vs p differences by the principle post and the procedural case of the declaration principle post the fact that pj computes to out without implies that pj in out also by j applications of we conclude that p in out in order to give a statement of theorem we make the weakening assumption that y is the set of formals of p and offer the following theorem let p be a procedure in a program p with all of its parameters passed by name if in any directly recursive call p passes to itself only a its formals b expressions relatively global to it and c expressions which declare the names they use other than those of type b and if no calls on p are passed to p then there is a straightforward conversion from p to an program p in which p is replaced by several procedures each of which has no parameters call by name time because fewer parameters are passed whenever one of the for p is called the transformation also decreases the frequency of page in a virtual memory operating environment make the top of the runtime stack reference items the bottom the memory management algorithm may have moved the lower parts of a deep stack out of fast storage by the time these references occur the cost of call by name is an increase in program size and a combinatorial explosion can be whether programs written to solve a problem will is another question in a virtual memory system one can increase program size very so long as the systems slow storage is not reached until then the important space consideration is not program size but working set size pp call by name can only improve the working set structure of a program program has a node oe an arc from p to q whenever the body of p includes a call on a in order to uv the convergence of various iterations h an analysis it is helpful to transform a program so that its calling graph will have many and small rather than few and large strongly connected components and strong show to do this with a sequence of strong and walker and strong have developed ways to avoid unnecessary in that implement recursion equations parts of this work have been extended to procedural languages with only call by value and without pointer variables it is our aim to extend this work to allow other calls and pointers as well we are to develop transformations which will replace all parameters and local variables by global variables together with a minimal use of in the sense of and theorem is a positive result in this direction stating that under certain conditions such transformations exist and avoid of course in any sufficiently powerful language including all those discussed in this paper we can avoid via coding a simulated stack note that this transformation the set of values contained in cells during computation whereas the theorem does not ith semantics semantics comes in three main which we will call and of specific semantics are the algol report and the definition of the model in the first case the on the syntax of the language to the other aspects of the interpreter which are left in the second case the on nested structures cells whose values may be pointers to other cells and scope rules for names to hide the fact that one specific language is being defined the model language let us call it ml is very apt for definitions of semantics a computes whatever its image under the following compiler from cml computes for our purposes w is too close to machine language what as a single in a dynamic program becomes a series of operations and jumps controlled by a static program on the other hand results like theorem clearly should not be proved separately for each procedural high level language semantics specifies a metalanguage in i to write definitions of languages if the itself is very precisely defined then the that arise in informal interpreters such as the one in be avoided could try to builds semantic theory based on properties of the metalanguage or of some readily family of interpreters within the metalanguage the definition language is too flexible to constitute an semantic theory there is very little in between the interpreter for epl sec and the interpreter itself sec a if one tries to specify a family of interpreters to correspond to the family of procedural languages one finds that the control structures and data structures in interpreter program statements even been expressed as abstract does not execute after they have tree structures instead the interpreter constructs a control tree whose nodes carry instructions the acyclic nature of the control tree and objects in general makes it impossible to follow a simple iterative loop without to sec iterative source programs are ultimately explained by recursion in the interpreter for optimization we wish to go in the opposite direction replacing iteration as much as possible we clearly distinguish between recursion and iteration no simple constraint on a interpreter will do this by using an tree together with possibly cyclic web arcs we allowed control to flow through the program itself just as in a flowchart or an algol program without web arcs we would need of arbitrary names to serve the purposes of arcs out names leads to constant about capture of free variables programs which are the same except for choices of names and so on as soon as one tries to prove anything such considerations become extremely tedious and error section eliminates names in of pointers between tree nodes that correspond to our and arcs his success in and formalizing a substantial portion of algol s semantics table us to deal with web structure directly rather than with names we have in this direction by adding other control and that carry so that all control flow expressed by moving along arcs in prog simulates normal flow by adding symbols like exec and the operators at nodes section and by manipulating these symbols with rules based on grammars section sections and here the third of semantics abstract about interpreters and the mathematical consequences of the we illustrated the with fragments of specific interpreters in discussing at the implications of the for a metalanguage for defining procedural languages the three can and should be but they should not be in trying say just what procedural languages have in common we have been primarily by technical considerations we that and were true of languages like long before we could say why they were true without in the syntax of that particular language we that these led to theorem long before we could state the expressed in the program locality principle post and declaration principle post another important consideration was that the should actually be true for the interpreters described informally by existing successful definitions of specific languages the semantic portions of the report and the standard semantics for were especially references r l and d on of program j definition of programming dept analysis and computer sci u of june p j virtual memory ls pz thunks comm ac e t and w comments on the implementation of recursive procedures and blocks in comm the model of block structured processes notices february a and strong h r a algorithm with applications for transforming recursive o di e p ed revised report on the algorithmic language algol comm acm i l on the criteria to be used in systems into modules rosen systems and strong h r translating recursion equations into walker s a and h r of to appear er p the definition language computing and car a contribution of algol ca n n and h a generalization and its formal definition and w reference manual science see also a language for systems we thank k c for the manuscript under very difficult 