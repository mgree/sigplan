an operational and axiomatic semantics for nondeterminism and sequence points in c university the abstract the c standard of the c programming language does not specify the execution order of expressions besides to make more effective optimizations possible eg delaying of sideeffects and interleaving it gives compilers in certain cases the freedom to use even more behaviors than just those of all execution orders widely used c compilers actually exploit this freedom given by the c standard for optimizations so it should be taken in formal verification this paper presents an operational and axiomatic semantics based on separation logic for nondeterminism and sequence points in c we prove soundness of our axiomatic semantics with respect to our operational semantics this proof has been fully formalized using the coq proof assistant categories and subject descriptors d programming languages formal definitions and theory f logics and meanings of programs specifying and verifying and reasoning about programs keywords operational semantics separation logic c verification interactive theorem proving coq introduction the c programming language is not only among the most popular programming languages in the world but it is also among the most programming languages due to weak static typing and the absence of runtime checks it is extremely easy for c programs to have bugs that make the program crash or behave in other ways can be arrays can be accessed outside their bounds memory can be used after it is etc furthermore c programs can be developed with a too specific interpretation of the language in mind giving and problems later instead of forcing compilers to use a execution order for expressions eg left to right the c standard does not specify it this is a common cause of and problems as a compiler may use an arbitrary execution order for each part of this research has been done while the author was france permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work must be for all other uses the popl january ­ san diego ca usa copyright is held by the acm expression hence to prove the correctness of a c program with respect to an arbitrary compiler one has to verify that each possible execution order is legal and gives the correct result to make more effective optimizations possible eg delaying of sideeffects and interleaving the c standard requires the programmer to ensure that all execution orders satisfy certain conditions if these conditions are not met the program may do anything let us take a look at an example where one of those conditions is not met int main int x int y x x dn x y by considering all possible execution orders one would expect this program to print or depending on whether the assignment x or x is executed first however the sequence point restriction does not allow an object to be modified more than once or being read after being modified between two sequence points p a sequence point occurs for example at the end of a full expression before a function call and after the first operand of the conditional operator c hence both execution orders lead to a sequence point violation and are thus illegal as a result the execution of this program undefined behavior meaning it may do anything the c standard uses a garbage in garbage out principle for undefined behavior so that compilers do not have to generate possibly expensive runtime checks to handle corner cases a compiler therefore does not have to generate code to test whether a sequence point violation occurs but instead is allowed to assume no sequence point violations will occur and can use this information to perform more effective optimizations indeed when compiled with gcc o version the above program which does not correspond to any of the execution orders nondeterminism in c is even more than some may think that the execution order in e e is unspecified does not mean that either e or e will be executed entirely before the other instead it means that execution can be interleaved first a part of e then a part of e then another part of e and so on hence the following expression is also allowed to print many existing tools for c verification the target program in one of their first phases and let the user verify the correctness of the version when a specific compiler for which the execution order is known and which does not perform optimizations based on the sequence point restriction this approach works but to prove the correctness of a program with respect to an arbitrary compiler this approach is even if all possible execution orders are considered see the counterexample in gcc above some verification tools perform checks to sequence points violations however as it is undecidable whether a sequence point violation may occur combined with such checks is either unsound and of and popl talk present some examples in existing tools or will valid c programs approach as a step towards taking nondeterminism and the sequence point restriction in c verification we extend the small step operational and separation logic for nonlocal control flow by and with nondeterministic expressions with sideeffects and the sequence point restriction soundness of the axiomatic semantics is proved with respect to the operational semantics using the coq proof assistant the straightforward approach to verification of programs with nondeterminism is to consider all possible execution orders however this may result in a combinatorial explosion and also it is not entirely clear how to use this approach in an axiomatic semantics that also handles the sequence point restriction hence we take a different approach we extend the axiomatic semantics with a hoare judgment p e q for expressions as usual p is an assertion called the precondition like von we let the postcondition q be a function from values to assertions because expressions not only have sideeffects but primarily yield a value intuitively the judgment p e q means that if p holds for the memory and execution of e yields a value v then q v holds for the resulting memory besides partial program correctness the judgment p e q ensures that e no undefined behavior due to the sequence point restriction to deal with the nondeterminism in c we observe that nondeterminism in expressions corresponds to a form of concurrency which separation logic is well capable of dealing with inspired by the rule for the parallel composition of separation logic see we propose the following kind of rules for each operator pl el ql pr er qr pl ql el er pr qr the idea is that if the memory can be split up into two disjoint parts using the separating conjunction in which the subexpressions el respectively er can be executed safely then the full expression el er can be executed safely in the whole memory the actual rules of the axiomatic semantics see section are more complicated we have to deal with the return value and have to account for undefined behavior due to integer overflow to ensure no sequence point violations occur we use separation logic with permission like in ordinary separation logic with permissions the singleton assertion becomes e e where is the permission of the object e at address e but we introduce a special class of locked permissions the inference rules of our axiomatic semantics are set up in such a way that reads and writes are only allowed for objects that are not locked and moreover such that objects become locked after they have been written to at constructs that contain a sequence point the inference rules ensure that these locks are released fractional permissions are used to allow memory that will not be written to be shared by multiple subexpressions our approach to handling nondeterminism and sequence points at the level of the operational semantics is inspired by and and we annotate each object in memory with a permission that is changed into a locked variant whenever a write occurs this permission is changed back into the variant at the subsequent sequence point furthermore we have a special state undef for undefined behavior that is used for example whenever a write to a locked object occurs to bring the operational semantics closer to our axiomatic semantics we make locks local to the subexpression where they were created that means at a sequence point we only unlock objects that have been locked by that particular subexpression instead of all objects this modification lets some artificial programs that were legal by the c standard exhibit undefined behavior see page but is not unsound for program verification an important part of both the operational and axiomatic semantics is the underlying permission system we give an abstract specification of it as an extension of permission algebras and give various instances of this abstraction related work nondeterminism sideeffects in expressions and sequence points have been treated numerous times in formal of c but to our there is little evidence of work on program verification and program logics for these concepts the first formalization of a significant part of c is due to using the proof assistant hol an important part of his work was to accurately formalize nondeterminism and sequence points as described by the c standard he proved various hoare rules for statements to facilitate reasoning about c programs to reason about nondeterministic expressions he proved that execution of sequence point free expressions is confluent this result is also useful for more efficient symbolic execution reasoning about arbitrary c expressions was left as an open problem has given a denotational semantics for a part of c including nondeterminism and sequence points he has implemented his semantics in haskell to obtain a tool that can be used to explore all behaviors of a c program did not consider an axiomatic semantics more recently and have defined an executable semantics of the c standard using the their semantics is very and also describes nondeterminism and the sequence point restriction moreover since their semantics is effectively executable it can be used as a debugger and an interpreter to explore all behaviors of a c program it has been tested against c test and has been used by et al to find bugs in widely used c compilers compcert a verified compiler c compiler by leroy et al written in coq supports nondeterminism in expressions in the semantics of its source language the interpreter by can be used to explore this nondeterminism has extended source language and interpreter with the sequence point restriction in the style of and there have been various efforts to verify programs in compcert c appel and axiomatic semantics for compcert operates on an intermediate language in which expressions have been and sideeffects have been removed their axiomatic semantics is thus limited to verification of programs compiled with compcert and will not work for arbitrary compilers has formalized a verification condition generator based on the why platform in coq that can be used as a tool via extraction mechanism he proved the tools soundness with respect to an intermediate language of compcert and it thus from the same limitations as appel and work black and have developed an axiomatic semantics for c they define inference rules to factor out sideeffects of expressions by translating these into semantically equivalent versions their axiomatic semantics seems rather limited and soundness has not been proven with respect to an operational semantics extending an axiomatic semantics with a judgment for expressions is not new and has been done for example by von for java in the proof assistant his judgments for expressions are quite similar to ours but his inference rules are not since he considered java he was able to use that the execution order of expressions is fully defined which is not the case for c contribution our contribution is · we define an abstract interface for permissions on top of which the memory model is defined and present an algebraic method to reason about disjoint memories section · we define a small step operational semantics that handles nondeterminism and sequence points section and · we give an axiomatic semantics that allows reasoning about programs with nondeterminism this axiomatic semantics ensures that no undefined behavior eg sequence point violations and integer overflow occurs section · we prove the soundness of our axiomatic semantics section this proof together with some extensions section has been fully formalized using coq section as this paper describes a large formalization effort we often omit details and proofs the interested reader can find all details online as part of our coq formalization the memory and permissions we model memories as finite partial functions from some countable set of memory indices b index to pairs of values and permissions a value is either which is used for uninitialized memory and the return value of functions without explicit return a bounded integer a pointer or a values are untyped apart from integer values and kept simple to focus on the issues of the paper definition a partial function from a to b is a total function from a to where is the option type defined as containing either or x for some x b a partial function is called finite if its domain is finite the operation f x y stores the value y at index x and f x the value at index x definition integer types and values are defined as signed char unsigned char signed int v val int n ptr b null for an integer value int n the mathematical integer n z should be within the bounds of a value v is true notation v if it is of the shape int n with n or ptr b it is false notation v if it is of the shape int or null notice that is neither true nor false because at an actual machine uninitialized memory has arbitrary contents in order to abstract from a concrete choice for a permission system no permissions simple permissions fractional permissions etc in the definition of the memory we define an abstract interface for permissions we permissions using four different permission kinds · free which allows all operations read write free · write which allows just reading and writing · read which allows solely reading and · locked which is used to lock an object between a write to it and a subsequent sequence point this organization is inspired by leroy et al but differs by the fact that we abstract away from a concrete implementation and allow much more complex permission systems eg those based on fractional permissions these are needed for our separation logic we define a partial order on permission kinds as the closure of read write locked write and write free since readonly memory cannot be used for writing and therefore cannot be locked the kinds locked and read are incomparable on purpose definition a permission system consists of a set p binary relations and binary operations and and functions kind p and lock unlock p p satisfying p is a partial order is symmetric p is a commutative if x y then kind x kind y if x y then kind x read if write kind x then unlock lock x x if kind x locked then unlock x x kind unlock x locked if x y and x x then x y if x y z then x z and x y z if x y then x x y if x y then z x z y if z x z y and z x z y then x y if x y then x y x and x y x y permission systems extend permission algebras by calcagno et al by permissions using kinds and by having operations for locking and whereas is a partial function in a permission algebra we require it to be a total function and account for using a relation to describe that two permissions are disjoint and may be for permissions that are not disjoint the result of is not specified in the definition of a permission system this us from dealing with partial functions in coq we require to be a primitive so we can lift it to an operation on memories see definition that is an actual coq function et al the issue of partially by defining as a relation instead of a function but as for the operation we prefer to use functions to ease reasoning about memories rule ensures that only permissions whose kind is read are disjoint this is to ensure that only readable parts of disjoint memories may overlap before we define memories we define three instances of permission systems we begin with fractional permissions definition fractional permissions z are rational numbers within we let z z iff z z and z z iff z z the operations are defined as z z z z z z if z z otherwise z z if z z otherwise write if z kind z read otherwise lock z unlock z z notice that in the above definition we yield the dummy value for z z if z z and z z if z z to account for locks due to the sequence point restriction we extend fractional permissions with a special permission seq definition permissions are defined as s seq z disjointness is inductively defined as if z z then z z the order is inductively defined as seq seq if z z then z z the operations and are defined pointwise and kind seq locked kind z kind z lock seq seq lock z seq unlock seq unlock z z we extend permissions to account for some of c first of all we need to deal with objects that are declared using the const qualifier those are readonly secondly whereas dynamically allocated memory obtained via alloc can be manually using free memory of block scope variables cannot be using free it should therefore be by the permission system definition full permissions are defined as s s readonly z here all relations and operations are defined pointwise by lifting those on fractional and permissions we use the abbreviations f w and r for the permissions and readonly respectively given an arbitrary permission system with carrier p the definition of the memory is now straightforward definition memories m mem are finite partial functions from memory indices to pairs v x with v val and x p first we define the operations that are used by the operational semantics section to interact with the memory definition the memory operations are defined as b m x if m b v x otherwise m b v if m b v x and kind x locked otherwise mb v mb v x if m b v x m otherwise alloc b v x m mb v x free b m mb locks m b m b v x kind x locked lock b m mb v lock x if m b v x m otherwise unlock m b v unlock x b m b v x b v x b m b v x here we have fin index the function is used to obtain the permission of an object allocation alloc b v x m of an object with value v and permission x should only be used with unused indices b in m ie with b m likewise a store and deallocation using free should only be used when the permissions are appropriate we will take care of these in the rules of the operational semantics next we define the memory operations that are used by the axiomatic semantics section definition the separation memory relations are defined as · we let m m iff for all b v x v and x with m b v x and m b v x we have v v and x x · we let m m iff for all b v and x with m b v x there exists an x x with m b v x the separation memory operations are defined as m m b v x x m b v x m b v x b v x m b v x m b b v x m b m b v x m m b v x x m b v x m b v x x x b v x m b v x m b the union and empty memory form a monoid that is commutative and for disjoint memories for the soundness proof of our axiomatic semantics section we often need to reason about preservation of disjointness under memory operations to ease that kind of reasoning we define a relation m m that describes that the memories m and m behave equivalently with respect to disjointness definition disjointness of a list of memories m notation m is inductively defined as if m m and m then m m notice that m is stronger than merely having mi mj for each i j for example using fractional permissions we do not have b v b v b v whereas we clearly do have b v b v definition equivalence of m and m with respect to disjointness notation m m is defined as m m m m m m m m m m m m m it is straightforward to show that is reflexive and transitive being by concatenation of sequences and is being preserved by list containment hence is an equivalence relation a congruence with respect to concatenation of sequences and also being preserved by permutations the following results allow us to reason about disjoint memories fact if m m and m then m theorem we have the following algebraic properties m m m m m m m m provided that m m m m m m provided that m mb v m m m provided that b m x for some x that is not a fragment b v x m b v x m provided x is not a fragment m m m m m m provided that m m m m lock b m m provided that b m x for some x that is not a fragment m m unlock m m here a permission x is a fragment if there is a y such that x y the language in this section we define the syntax of expressions and statements definition expressions are defined as e expr xi v e e f e load e alloc free e e e e e e e instead of v we just write v expressions may contain sideeffects assignments e e function calls f e and allocation alloc and deallocation free e of dynamic memory unary operators prefix and increment and assignment operators and the operator are omitted in this paper but are included in the coq formalization the logical operators are defined in terms of the conditional values v are annotated with a finite set of locked memory indices this set is initially empty but whenever a write is performed the written object is locked in memory and its memory index is added to see section whenever a sequence point occurs the locked objects in will be in memory the operation locks e collects the annotated locks in e stacks stack are lists of memory indices variables are de bruijn indices ie the variable xi refers to the ith memory index on the stack de bruijn indices avoid us from having to deal with due to block scope variables especially in the axiomatic semantics this is useful as we do not want to lose information by a local variable an already existing one the stack contains references to the value of each variable instead of the values itself so as to treat pointers to both local and allocated storage in a uniform way execution of a variable xi thus consists of looking up its address b at position i in the stack and returning a pointer ptr b to that address execution of load e consists of evaluating e to ptr b and looking up b in the memory definition statements are defined as s stmt e skip goto l return e block c s s s l s s if e s else s the statement syntax is adapted from and but we treat assignments and function calls as expression constructs instead of statements constructs hence assignments and function calls can be nested and can occur in the expressions of a return while and conditional statement the construct block c s a block scope with one local variable where the boolean c specifies whether the variable is or not the permission c is defined as true r and false w since we use de bruijn indices the construct block c s is operational semantics we define the semantics of expressions and statements by a small step operational semantics that means computation is defined by the reflexive transitive closure of a reduction relation on program states to define this reduction we first define head reduction of expressions and then use evaluation contexts as introduced by felleisen et al to define reduction of whole programs in the remainder of this paper we will use a memory instantiated with full permissions definition definition given a stack head reduction of expressions e m h e m is inductively defined as xi m h ptr b m in case i b ptr b v m h vb lock b mb v in case b m and write kind load ptr b m h v m for any v with m b v alloc m h ptr b alloc b f m for any b with b m free ptr b m h free b m in case b m and kind free v v m h v m in case v v v v e e m h e unlock m in case v v e e m h e unlock m in case v v m h v m in case v v if the stack is not clear from the context we write e m h e m note that an unused index for allocation in rule is nondeterministic in rules and v v and v are partial functions that evaluate a binary operation on values and integer cast on values respectively these functions fail in case of integer overflow or if an operation is used eg division by zero an assignment ptr b v rule not only stores the value v at index b but also locks b in the memory locking b enforces the sequence point restriction because consecutive reads and writes to b will fail as by the of the assignment rule and definition of the operation in order to keep track of the lock of b we add b to the set b rules and for the conditional v e e model a sequence point by the indices in the memory making future reads and writes possible again other constructs with a sequence point will be given a similar semantics see definition like and we implicitly use nondeterminism to capture undefined behavior due to sequence point violations for example in x x only one execution order performing the read after the assignment leads to a sequence point violation in semantics both execution orders lead to a sequence point violation as he also keeps track of reads our treatment of sequence points assigns undefined behavior to more programs than the c standard and and do and release the locks of all objects at a sequence point whereas we just release the locks that have been created by the subexpression where the sequence point occurred for example we assign undefined behavior to the following program of int x y p y int f if x p x return int main return x p f the execution order that leads to undefined behavior is a x b call f which changes p to x c p here the lock of x the function call in the semantics of and this program has defined behavior as the sequence point before the function call all locks so also the lock of x we believe that this is a reasonable tradeoff because dealing with sequence points locally instead of globally the operational semantics closer to the axiomatic semantics as separation logic only about a local part of the memory we believe only artificial programs become illegal because different function calls in the same expression can still write to a shared part of the memory which is useful for memoization for example given int y static int if return return the expression f f has defined behavior according to our semantics of sequence points since the c standard does not allow interleaved execution of function calls p these are not described by the head reduction h instead a function call changes the whole program state to a state in which its body is executed when execution of the function body is finished the result will be back into the whole expression to describe this behavior and to select a head redex in an expression we define expression contexts definition expression contexts are defined as es e e f e e load free e e e e expression contexts e are lists of contexts given an expression context e and an expression e the substitution of e for in e notation e e is defined as usual in the reduction of whole programs definition we allow e e to reduce to e e provided that e m h e m to enforce that the first operand of the conditional e e e is executed entirely before the others it is essential that we omit the contexts e e and e e the reduction of whole programs uses a data structure called a program context to store the location of the that is being executed execution of the program occurs by traversal through the program context in the direction down up jump or top when a goto l statement is executed the direction is changed to l and the semantics performs a small step traversal through the program context until the label l has been reached program contexts extend the by annotating each block scope variable with its associated memory index and furthermore contain the full call stack of the program program contexts can also be seen as a generalization of continuations as for example being used in compcert however there are some differences · program contexts implicitly contain the stack whereas a continuation semantics typically stores the stack separately · program contexts also contain the part of the program that has been executed whereas continuations only contain the part that remains to be done · since the complete program is preserved looping constructs like the while statement do not have to duplicate code the fact that program contexts do not throw away the parts of the statement that have been executed is essential for the treatment of goto upon an invocation of a goto the semantics traverses through the program context until the corresponding label has been found during this traversal it passes all block scope variables that go out of scope allowing it to perform required allocations and in a natural way hence the point of this traversal is not so much to search for the label but much more to incrementally calculate the required allocations and definition statement contexts are defined as ss s s l if e else s if e s else given a statement context ss and a statement s substitution of s for in ss notation ss s is defined as usual a pair ss s consisting of a list ss of statement contexts and a statement s forms a for statements without block scope variables that means ss is a statement turned that represents a path from the focused s to the top of the whole statement definition expression statement contexts and program contexts are defined as se return while s if s else s ps ss c se e resume e b program contexts k ctx are lists of program contexts given an expression statement context se and an expression e substitution of e for in se notation se e is defined as usual the previously defined program contexts will be used as follows in the operational semantics · when entering a block scope block c s the context c is to the head of the program context it associates the block scope with its memory index b · when executing a statement construct se e that contains an expression e the context se e is to the head of the program context to keep track of the statement we need to keep track of the expression e as well so that it can be when execution of the expression is finished · when executing a function call e f v the context resume e is to the head of the program context when the function returns with value v execution of the expression e v with the return value v in is · when a function body is entered the context b is to the head of the program context it contains a list b of memory indices of the function parameters as program contexts implicitly contain the stack we define a function to extract it from them definition the corresponding stack k of a program context k is defined as ss k k c k b k se e k k resume e k b k b k we define resume e k as instead of k as otherwise it would be possible to refer to the local variables of the calling function definition directions focuses and program states are defined as d direction l v focus d s e call f v return v undef s state sk m a program state sk m consists of a program context k the part of the program that is focused and the memory m similar to we have five kinds of states · d s for execution of a statement s in direction d · e for execution of an expression e · call f v for calling a function f with arguments v · return v for returning from a function with return value v and · undef to capture undefined behavior we have additional states for execution of expressions and undefined behavior the semantics of cminor and the semantics of and do not have such states because their expressions are deterministic and sideeffect free they capture undefined behavior by letting the reduction get stuck whereas that will not work in the presence of nondeterminism definition the relation m b v m allocates fresh blocks b for function parameters v with permission nondeterministically it is inductively defined as m m if m b v m and b m then m b b v v alloc b v m definition an expression is a redex if it is of the following shape a xi b v v c f v v d load v e alloc f free v g v v h v e e or i v definition an expression is safe in stack and memory m if a it is of the shape f e or b there is an expression e and memory m such that e m h e m definition given a finite partial function mapping function names to statements the small step reduction s s is inductively defined as for simple statements a sk skip m sk skip m b sk goto l m sk l goto l m c sk se e m e k e m for expressions a sk e e m sk e e m for any e and m st k e m h e m b sk e f v m e k call f v unlock m c sk e e m sk undef m provided that e is an unsafe redex for finished expressions a s e k v m sk e unlock m b e k v m sk v return e unlock m c s e k v m k s unlock m provided that v d s e k v m sk s unlock m provided that v e s else s e k v m e else s k s unlock m provided that v f s else s e k v m e s else k s unlock m provided that v for compound statements a sk block c s m c k s alloc b c m for any b such that b m b sk s s m s s k s m c sk l s m sl k s m d c k s m sk block c s free b m e s s k s m ss k s m f ss k s m sk s s m g k s m sk s m h e else s k s m sk if e s else s m i e s else k s m sk if e s else s m j sl k s m sk l s m for function calls a sk call f v m b k s m for any s b and m st f s and w m b v m b b k s m sk return free b m c b k v s m d e k return v m for nonlocal control flow sk return v free b m sk e v m a c k v s m sk v block c s free b m b k v s m sk v ss s m c sk l l s m sl k s m d sk l block c s m c k l s alloc b c m for any b such that b m and provided that l labels s e c k l s m sk l block c s free b m provided that l labels s f sk l ss s m k l s m provided that l labels s g k l s m sk l ss s m provided that l labels s note that the selection of redexes in rule a b and c is nondeterministic moreover note that the rules c and f overlap and that the splitting into ss and s in rule f is nondeterministic definition we let denote the closure of and let n denote paths of n reduction steps execution of a statement sk d s m is performed by traversing through the program context k and statement s in direction d the direction down respectively up is used to traverse respectively to the next that has to be executed when a se e containing an expression e has been reached rule c the location of the expression se is stored on the program context and execution is in e k e m execution of an expression sk e m is performed by nondeterministically e into e e rule a allows e to perform a and rule b allows e to perform a function call if the redex e is unsafe and thereby cannot be eg because of a sequence violation or integer overflow rule c ensures that the whole program reduces to the undef state when execution of an expression has in a value v we model a sequence point by in memory rule af for a function call sk e f v m two reductions occur before the function body will be executed the first to e k call f v unlock m rule b stores the location of the caller on the program context and takes care of the sequence point before the function call the subsequent reduction to b resume e k s m rule a looks up the body s allocates the parameters v and then performs a transition to execute the function body s we consider two directions for nonlocal control flow jump l and top v after a goto l rule b the direction l is used to traverse to the labeled l rule cg although this traversal is nondeterministic in the case of duplicate labels there are some in order to ensure that the reduction is not going back and between the same locations this is required because we may otherwise impose nonterminating behavior on terminating programs the nondeterminism could be removed entirely by adding additional however as we already have other sources of nondeterminism we omitted doing so to ease formalization when execution of the expression e of a return e statement has in a value v rule b the direction v is used to traverse to the top of the whole statement rule a and b when this traversal reaches the top of the statement there are two reductions to give the return value v to the caller the first reduction from b resume e k v s m to e k return v free b m rule c the function and the second reduction to sk e v free b m rule d execution of the expression e v at the caller axiomatic semantics judgments of hoare logic are triples p s q where s is a statement and p and q are assertions called the pre and postcondition the intuitive reading of such a triple is if p holds for the memory before executing s and execution of s terminates then q holds for our language we have two such judgments one for expressions and one for statements our expression judgments are p e q as usual p and q are the pre and postcondition of e respectively but whereas p is just an assertion q is a function from values to assertions it ensures that if execution of e yields a value v then q v holds the environment is a finite function from function names to their pre and postconditions that is used to with mutually recursive functions as in and our judgments for statements are r j p s q where r is a function from values to assertions and j is a function from labels to assertions the assertion r v has to hold when executing a return e for each value v obtained by execution of e and j l is the condition that has to hold when executing a goto l we use a shallow embedding to represent assertions this treatment is similar to that of appel and von and etc in order to talk about expressions without sideeffects assignments allocation and deallocation and function calls in assertions we need this for various rules of our axiomatic semantics see definition we define an evaluation function for pure expressions definition evaluation e m of an expression e in a stack and memory m is a partial function that is defined as xi m ptr b v m v load e m m b e e m e m if i b if e m ptr b e m e e e m e m e m if e m v and v if e m v and v e m e m definition assertions are predicates over the the stack and the memory we define the following connectives on assertions p q m p m q m x p x m x p x m p q m p m q m x p x m x p x m p q m p m q m p m p ¬p m ¬p m e v m e m v we treat as an implicit coercion eg we write true instead of true also we often lift these connectives to functions to assertions eg we write p q instead of v p v q v definition we let p q denote that for all stacks and memories m we have p m implies q m definition an assertion p is called stack independent if for all stack and m mem with p m we have p m similarly p is called unlock independent if for all stack m mem and index with p m we have p unlock m next we define the assertions of separation logic the separating conjunction p q asserts that the memory can be split into two disjoint parts such that p holds in the one part and q in the other due to the use of fractional permissions these parts may overlap as long as their permissions are disjoint and their values agree finally e e asserts that the memory consists of exactly one object at e with contents e and permission definition the connectives of separation logic are emp m m p q m m m m m m m m p m q m e e m b v e m ptr b e m v m b v e ­ e e e to enforce the sequence point restriction the rule for assignment changes the permission of e e into lock subsequent reads and writes are therefore no longer possible at constructs that have a sequence point we use the assertion p to release these locks and to make future reads and writes possible again definition the assertion p is defined as p m p unlock locks m m we proved properties as p q p q to push the connective through an assertion similar to and we need to lift an assertion such that the de bruijn indices of its variables are increased so as to deal with block scope variables the lifting p of p is defined semantically and we prove that it behaves as expected definition the lifting assertion p is defined as p m p tail m lemma the operation over the connectives ¬ and we have e v e v and e e e e where the operation e replaces each variable xi in e by xi the specification of a function with parameters v consists of an assertion p y v called the precondition and a function q y v from return values to assertions called the postcondition we allow universal quantification over arbitrary logical variables y in order to relate the pre and postcondition the pre and postcondition should moreover be stack independent because local variables will have a different meaning at the caller than at callee we denote such a specification as y v p y v q y v definition given a finite partial function mapping function names to statements the expression judgment p e q and statement judgment r j p s q of the axiomatic semantics are mutually inductively defined as shown in figure we have a frame weaken and exist rule for both the expression and statement judgments the traditional frame rule of separation logic includes a modifies s free a like and we do not need this as our local variables are immutable references into the memory since the return and goto statements leave the normal control flow the postconditions of the goto and return rules are arbitrary the rules for function calls are based on those by and the rule is used to call a function f e that is already in the assertion b v is used to frame a part of the memory that is used by e but not by the f itself the add rule can be used to add an arbitrary family of specifications of possibly mutually recursive functions to for each function f in with precondition p and postcondition q it has to be verified that the function body f is correct for all instantiations of the logical variables y and input values v the precondition xi w vi p y v where ei i ei denotes the p e q a p e a q x p x e q x p x e q p p p e q v q v q v p e q p ev p e v v v p emp alloc a a f ­ p e a q a f ­ p free e q write kind kind locked p e a v q a v a v p load e v a q a v a v p e q p e q av q a q v a ­ r a v p p e e v a a v r a v p e q p e q v v q v q v v r v v v v v v p p e e v v v r v v v f z w p z w q z w i pi ei qi v qi vi p y v a v v v q y v v a v r v p f e r p e v v p v v v p v e q v v p v e q p e e e q r j p s q frame a r a j a p s a q x r j p x s q exists r j x p x s q v r v r v l labels s j l jl l labels s jl j l p p r j p s q q q weaken r j p s q p e q expr r j p e q skip r j p skip p r j p s p r j p s q comp r j p s s q p e r return r j p return e q r j j l s q label r j j l l s q goto r j j l goto l q c x ­ j x ­ r x ­ p s x ­ q block r j p block c s q p e v v q v r j v v q v s p while r j p s v v q v p e v v p v r j v v p v s q r j v v p v s q if r j p if e s else s q f p q f z w p z w q z w y v l false v xi w ­ q y v v xi w vi p y v f xi w ­ q y v r j p s q r j p s q dom dom add figure the rules of the axiomatic semantics assertion e e · · · en n en states that the function parameters x are allocated with values v for which the precondition p of the function holds the postcondition xi w ­ q y v and returning condition v xi w ­ q y v v ensure that the parameters have not been deallocated during the execution of the function and that the postcondition q holds for the return value the condition l false ensures that all jump to a label that occurs in the function body our axiomatic semantics is at least as powerful as an ordinary separation logic for c because not only variants of the ordinary inference rules can be derived but also derived rules for more complex constructs for example e ­ e ­ p e v e ­ e ­ p e e e e v e v p provided that e and e are p is unlock independent and write kind kind soundness of the axiomatic semantics we will define judgments p e q definition and j r p s q definition to describe partial program correctness the judgment p e q that if the precondition p holds in m and s e m s v m then the postcondition q v holds in m also it ensures no undefined behavior occurs for each possible execution order soundness of the axiomatic semantics means that p e q implies p e q and likewise for j r p s q we prove soundness theorem by mutual induction on the derivations of p e q and j r p s q hence p e q and j r p s q should be sufficiently strong so that we get appropriate induction hypotheses the main difficulty is that the subexpressions el and er in el er can do interleaved reduction steps a simple definition of p e q that only about the end result of executing e does not work because we also need to have information about states in between since the definitions of p e q and j r p s q have a lot in common we define a more general notion to factor out like and we have to enforce the reduction sk m sk m to remain below a certain program context definition the reduction s k s is defined as s s provided k is a suffix of the program context of s definition given a predicate stack × mem × focus the judgment n l s k m is inductively defined as l s k m if l m then n l s l m if for all mf with m mf we have a sk m mf is and b if sk m mf l s then the state s is of the shape sk m mf with m mf undef locks locks m and n l s k m then n l s k m the intuitive meaning of n l sk m is that all l reductions paths of at most n steps starting at sk m mf · do not get stuck and do not end up in the undef state · always satisfy locks locks m during the execution and · the satisfies and has program context l to handle interleaving of expressions we allow the mem mf to change at each step during the execution hence instead of defining n l s k m using the reflexive transitive closure of l we defined it inductively using single steps the condition locks locks m on the annotated locks with respect to the locks in the memory is used to separate the locks of subexpressions we use a stepindexed approach to handle function calls the judgment n l sk m a nice composition property and satisfies an abstract version of the weakening and frame rule of separation logic lemma given contexts k k and k with k a suffix of k and k a suffix of k if a n k s k m and b for all m and with k m we have n k s k m then finally we have n k s k m lemma given memories m and m such that m m if a n l s k m and b for all m and with m m and l m we have l m m then finally we have n l s k m m definition validity of the environment notation n is defined as for all f with f y v p y v q y v and p y v k m we have n k f v k m here is defined as m v return v locks m q y v v m definition partial correctness of an expression e notation p e q is defined as if n locks e locks m and p d k m then n k s e k m here is defined as m v v locks m q v m and that the assertions p q j and r in j r p s q correspond to the four directions and in which traversal through a statement is performed hence we treat j r p s q as a triple p s where p is a function from directions to assertions such that p p p q p l j l and p v r v definition partial correctness of a statement s notation p s is defined as if n down d s locks s locks m and p d k m then n k sd s k m here down holds if down s or down l s with l labels s and is defined as m d s d s d s locks m p d m theorem soundness we have p e q implies p e q and j r p s q implies j r p s q this theorem is proven by mutual induction on the derivation of p e q and j r p s q thus for each rule of the axiomatic semantics we have to show that it holds in the model in order to prove the case we need to show that the expression evaluation e m is sound with respect to the operational semantics to prove the cases of the other expressions constructs we use the following generic lemma that deals with the of interleaving subexpressions lemma given a expression context e with u holes and locks e memories m with m expressions e with locks ei locks mi for each i u and functions of values to assertions p and q now if n k s k ei mi for each i u and for all v and m with m a locks mi i for each i u and b pi vi k mi for each i u we have n k s k e v then n k s k e e m m the previous lemma is proven by induction on the number of steps n theorem is used to reason about disjoint memories the proofs of the cases for the statement judgments are quite similar to those by and they involve all possible reduction paths and use lemma we refer to the coq formalization for the actual proofs extensions in this section we describe two extensions of our axiomatic semantics that improve handling of function calls the first extension makes it easier to deal with pure functions ie functions that have no sideeffects whereas the second extension enables different function calls in the same expression to have access to a shared part of the memory these extensions do not change the memory model or the operational semantics we make it possible to associate a mathematical function to a pure function for example this can be used to use function to reason about its counterpart in c we extend the environment to map function names to specifications of pure functions by partial coq functions or specifications of impure functions using their pre and postcondition y v p y v q y v the add rule is extended so that a pure function f with corresponding coq function f list val can be added to by proving v emp f v v emp f v v assertions are made parametric with respect to the environment so that pure functions can be given an interpretation by e m the rule becomes p ev p e v v v p apart from the by most rules of the axiomatic semantics remain unchanged to prove soundness of the rule we now also have to deal with pure function calls the rules for expressions of our axiomatic semantics require the memory to be separated into disjoint parts for the subexpressions el and er at each operator el er hence only readonly memory can be shared by function calls that appear in both el and er this is not very satisfactory as functions even when used in the same expression often need to have access to shared data structures eg a buffer or to that end we extend the expression judgment b p e q with an assertion b that can be used to describe the invariant of shared memory by all function calls in e the following frame rule can be used to move the memory out of the pre and postcondition into the assertion b a b p e q b p a e q a the rule for function calls is changed so that b can be used to prove the precondition and so that b has to be from the postcondition when the function call is finished for the soundness proof we need to generalize definition so that the memory of b is part of the memory mf during execution of the expression and so that is will be to the active memory at a function call this extension still does not give completeness of the axiomatic semantics though consider int x int y return x y int main f f return x since the invariant b should hold before after and in between the function calls in the expression f f the best choice for it is x w x w x w hence one can only prove that the program returns or in the end whereas it actually returns or we believe programs as the above are artificial and such nondeterminism is not in actual c programs formalization in coq all proofs in this paper have been fully formalized using the coq proof assistant formalization has been of great help in order to develop and the semantics we used notation mechanism combined with symbols and type classes for overloading to let the coq development correspond as well as possible to the definitions in this paper however in this paper we presented the axiomatic semantics as an inference system and showed that it has a model since we did not consider completeness we directly proved all rules to be derivable with respect to the model we used type classes to provide abstract interfaces for commonly used structures like finite sets and finite partial functions so that we were able to prove theory and implement automation in an abstract way our approach is greatly inspired by the approach of and van der however whereas their work relies on types equipped with an equivalence relation we tried to avoid that by using equality as much as possible in particular our interface for finite partial functions requires with respect to equality ie m m iff x m x m x extensional equality of finite partial functions is particularly useful for dealing with assertions which are defined as predicates on the stack and memory definition due to we did not have to assertions with a proof that they respect extensional equality on memories although intensional type theories like coq do not satisfy finite functions indexed by a countable type can still be implemented in a way that holds this is achieved by representing finite functions as trees in canonical form support for dependent types has been particularly useful to formulate lemma where we have to deal with expression contexts with multiple holes we represented these expression contexts using a type indexed by the number of holes because the semantics described in this paper is rather big it is quite to prove properties about it without automation in particular the reduction definition is defined as an inductive type consisting of constructors to this end we have automated many steps of the proofs for example we implemented a tactic to automatically perform reduction steps and to solve the required a tactic to perform case analyzes on reductions and to automatically impossible cases and a tactic to automatically prove disjointness of memories using the algebraic method described in section experiments show that this approach is successful as the semantics can be extended easily without having to many proofs our coq code available at is about lines of code including comments and white space apart from that our library on general purpose theory finite sets finite functions lists etc is about lines conclusions and further research the further reaching goal of this work is to develop an operational and axiomatic semantics for a large part of the c programming language formal treatment of nondeterminism and sequence points in expressions with sideeffects is a necessary step towards this goal our next step is to integrate the work of on the c memory model and type system into our formalization and make the language typed once integrated we intend to develop a verified type checker and interpreter so we can test the semantics using actual c programs extending our operational semantics to deal with concurrency is also an interesting topic for future research for example it would be useful to investigate whether our semantics can be extended to weak memories in the same way as compcert has been extended to compcert tso in order to turn the theory presented in this paper into an actual tool for verification of c programs we need to develop a verification condition generator a verification condition generator takes a program with logical annotations and generates a set of verification conditions that need to be verified for ordinary hoare logic the most common approach is to use a variant of weakest precondition calculus for separation logic one typically uses symbolic execution see for example berdine et al in case of our axiomatic semantics it is not directly clear whether any of these two approaches can be applied the problematic part is that in the rules for binary operations one has to split the memory in two parts using the separating conjunction it would be interesting to investigate how this can be automated another challenge to use our axiomatic semantics for program verification is strong automation for separation logic specific to the coq proof assistant there has been work on this by for example appel and et al as shown in section our axiomatic semantics is not complete with respect to the operational semantics nonetheless as in section we can derive the ordinary rules of separation logic and rules specifically for certain constructs it would be useful to investigate whether it is complete for another variant of the operational semantics due to our local treatment of locks to model the sequence point restriction our operational semantics assigns undefined behavior to more programs than the c standard does see page we believe that this is a reasonable tradeoff because it the operational semantics closer to the axiomatic semantics and only makes artificial programs illegal moreover this treatment of locks may enable some useful optimizations that are not allowed by the c standard a particular optimization that is not justified by the c standard is compcert s passing by reference of struct and union values through expressions in compcert copies of struct and union values are made only at function calls and assignments let us take a look at the following example struct s int x s s int f if sx sx return int main return s sx f the execution order where the compcert semantics from the c standard is a perform the assignment s s whose result is a reference to s instead of a copy of s b call f which uses an if sx to detect that the assignment s s has been executed and finally c the field x of the struct that has been modified by f is taken the return value for this execution order is which cannot be obtained from any execution order if were passed by value using a global treatment of sequence points as in and or no execution order of this program leads to a sequence point violation however with our local treatment of sequence points the execution order described above will exhibit a sequence point violation and hence our treatment would justify by reference passing of struct values for this program it would be interesting to investigate whether our semantics of sequence points by reference passing of struct and union values through expressions for arbitrary programs acknowledgments i thank my and and the anonymous for their helpful suggestions i am to leroy for many useful discussions this work is by the for scientific research references a w appel tactics for separation logic available at http a w appel and s separation logic for smallstep cminor in volume of lncs pages ­ j j b and l birkedal a framework for higherorder separation logic in coq in volume of lncs pages ­ j berdine c calcagno and p w ohearn symbolic execution with separation logic in volume of lncs pages ­ p e black and p j inference rules for programming languages with side effects in expressions in volume of lncs pages ­ r c calcagno p w ohearn and m j parkinson permission in separation logic in popl pages ­ j checking interference with fractional permissions in sas volume of lncs pages ­ c calcagno p w ohearn and h yang local action and abstract separation logic in lics pages ­ b an executable semantics for compcert c in volume of lncs pages ­ a verification of lowlevel programs in computational separation logic in pldi pages ­ acm r a and a w appel a fresh look at separation algebras and share in volume of lncs pages ­ c and g an executable formal semantics of c with applications in popl pages ­ c and g of m felleisen d p friedman e e and b f a syntactic theory of sequential control theoretical computer science ­ p certification of a tool chain for deductive program verification phd thesis international organization for standardization programming languages ­ c working group b w and d m the c programming language prentice hall nd edition r nondeterminism and sequence points in c post available at r aliasing restrictions of c formalized in coq in volume of lncs r and f a formalization of the c standard in hol and coq in volume of pages ­ r and f separation logic for nonlocal control flow and block scope variables in volume of lncs pages ­ x leroy a formally verified compiler journal of automated reasoning ­ x leroy the compcert verified compiler software and proof available at x leroy a w appel s and g the compcert memory model version research report rr inria m c in hol phd thesis university of cambridge m deterministic expressions in c in esop volume of lncs pages ­ p w ohearn resources concurrency and local reasoning in concur volume of lncs pages ­ p w ohearn j c reynolds and h yang local reasoning about programs that alter data structures in csl volume of lncs pages ­ d v hoare logic for java in concurrency and computation practice and experience ­ n a formal semantics for the c programming language phd thesis national technical university of j y chen p e c and x yang reduction for c compiler bugs in pldi pages ­ j v vafeiadis f z s and p sewell a verified compiler for concurrency journal of the acm b and e van der type classes for mathematics in type theory mathematical structures in computer science ­ 