complexity of verification for multithreaded programs germany the software institute abstract verification checks the correctness of the program executions that follow a given pattern a regular expression over the alphabet of program transitions of the form w wn for multithreaded programs the alphabet of the pattern is given by the synchronization operations between threads we study the complexity of verification for abstracted multithreaded programs in which as usual in program analysis conditions have been replaced by nondeterminism the technique works also for boolean programs while unrestricted verification is undecidable for abstracted multithreaded programs with recursive procedures and for abstracted multithreaded we show that verification is npcomplete for both classes we then a analysis in which we study the complexity in the number of threads the number of procedures per thread the size of the procedures and the size of the pattern we first show that no algorithm for verification can be polynomial in the number of threads procedures per thread or the size of the pattern unless then using recent results about parikh of regular languages and sets we present an algorithm exponential in the number of threads procedures per thread and size of the pattern but polynomial in the size of the procedures categories and subject descriptors d software engineering verification general terms verification languages algorithms reliability keywords concurrent programming safety contextfree languages introduction the analysis and verification of multithreaded programs is one of the most active research areas in software model checking this is due on the one hand to the increasing of architectures and on the other hand to the difficulty of this research was by the de program by the program and by the of science and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm about and debugging concurrent software automated analysis tools must with the very nature of the analysis problems multithreaded programs with possibly recursive procedures communicating through global variables are turing powerful even for programs having only two threads and three variables all of them boolean if communication takes place through message passing the programs are turing powerful even after applying the usual program analysis abstraction that replaces all conditions in alternative constructs and loops by nondeterminism proposed by qadeer and in is the most successful proposal to date for it restricts the problem further by exploring only those computation with a bounded fixed number of contexts a context is a segment of the computation during which only one thread accesses the global variables a context switch takes place when the identity of this thread changes reachability of a program point by a computation with at most k context switches the reachability problem is npcomplete when k is given in unary and can be checked by means of an algorithm polynomial in the size of the program and exponential in k has been implemented in several model checkers like slam and others and experiments with these tools have provided evidence that many concurrency errors manifest themselves in computations with few context switches while context bounding has been very successful it also has important limitations in particular it restricts the number of communications between threads while a thread can perform arbitrarily many reads and writes to the global variables during a context these writes are not observed by the other threads and so only the value of the variable immediately before the context switch amounts to a communication so in a computation with k context switches threads communicate at most k times in this paper we study a more flexible technique introduced by in that applies the theory of bounded languages developed in the by and to the verification problem uses the theory to prove decidability of safety analysis for multithreaded programs whose executions to a pattern a regular expression of the form w wn over the alphabet of program instructions observe that the executions of such a program can be arbitrarily long an equivalent but in our more point to view is to consider a pattern as a class of executions specified by the verifier the executions of the program may to the pattern or not but we can automatically verify whether those executions to the pattern satisfy the property in other words the programmer specifies by means of a pattern those executions is interested in we call this point of view verification the claim of is that verification provides a good between expressivity and complexity the ex point has been considered in some detail in where it is shown there that the approach is strictly more expressive than in this paper we study the computational complexity of verification thus the theoretical analysis in a we show that verification like is npcomplete and we identify an interesting and in a certain sense unique polynomial case for the complexity analysis we reduce the reachability problem for multithreaded programs to a language theory problem called modulo a pattern or for short checking of the intersection of a given set of contextfree grammars and a given pattern by putting together classical results by and and more recent results by and we first show that like reachability is npcomplete interestingly the algorithm we derive from the proof relies on satisfiability checking of a presburger formula which with the fixed point evaluation used in in the second and main part of the paper we a analysis of the size of an instance of is a function of four parameters the number of threads the maximal number of procedures per thread the maximal size of a procedure and the size of the pattern for every subset of parameters we determine the complexity of when the parameters in the subset and no others have a fixed value while this gives possible cases the results can be easily summarized apart from some trivial cases in which the problem can be solved in constant time for instance when all four parameters have fixed values the problem remains npcomplete for all subsets except one the case in which the number of threads procedures per thread and the size of the pattern are fixed but the size of the procedures is not we prove that this case is polynomial the proof uses several recent results about parikh of regular languages and complexity of sets the paper is organized as follows section contains section presents our program and formal models an analysis of the technique and the reduction of the verification problem to section shows that is npcomplete section contains our analysis of the nphard cases are covered by means of reductions from different npcomplete problems our main result the polynomial case mentioned above is contained in section finally section contains conclusions and discusses related work an alphabet is a finite nonempty set of symbols we assume the reader is familiar with the of language theory including regular and contextfree languages see eg contextfree languages a contextfree grammar is a tuple g x p s where x is a finite nonempty set of variables is an alphabet p x × x is a finite set of productions the production x w may also be noted x w and s x is the axiom given two strings u v x we write u v if there exists a production x w p and some words y z x such that u and v we use to denote the reflexive transitive closure of the language of a grammar is the set lg w s w a language l is contextfree if l lg for some contextfree grammar g a contextfree grammar is regular if each production is in x × x a language l is regular if l lg for some regular grammar g this is achieved by a family of programs parameterized by a number n such that reachability analysis for a fixed pattern proves reachability of a program point for all n but such that the number of context switches needed to reach the program point goes to when n grows we sometimes use lx g with x x to denote the language w x w multisets a multiset m n maps each symbol of to a natural number m denotes the set of all multisets over we sometimes use the following notation q q q denotes the multiset m such that mq mq and mx for all x q q the empty multiset is denoted the size of a multiset m is m p m given two multisets m m m and we define m m m as the multiset satisfying m m a ma m a for every a given m m and c n we define c · m as the multiset satisfying c · ma c · ma for every a by a linear order on every multiset m can be seen as a vector of nk where k and vice versa model and decision problem program model we model a sequential program by a system of a tuple of containing one flowgraph for each procedure nodes of a flowgraph correspond to control points of the program and edges to sequential statements a sequential statement is either a condition a boolean combination of expressions x e an assignment x e or a procedure call each flowgraph has a unique node without incoming edges the initial node and a unique node without outgoing edges the final node different from the initial node all nodes are reachable from the initial node and from the final node a multithreaded program is modeled by a tuple of systems of one for each program thread each system of uses a set of channels to send or receive messages language we call a system of together with the set of channels it uses a thread we denote by the set of channels used by the ith thread and the set of all channels by ch the edges of the are labeled by sequential statements by send statements ax indicating that the thread is to send the value of x through channel a ch or by receive statements ay indicating that the thread is to receive a value through channel a and assign it to variable y we assume that each channel is owned by a thread the owner of channel a can only contain send statements ax and all other threads can only contain receive statements ay channels work as in csp they have ie a message is through channel a only if its owner executes a send statement and all other threads having a in their sets of channels simultaneously execute a matching receive statement so we allow multiparty synchronization figure shows a model of a program with three threads each of the threads contains only one flowgraph with channels a b c a b and b c respectively the first thread channels a and c the second thread channel b and the third no channel n m l ax x n call p n cx bx ay m call p y y m by cz l bz n proc p m proc p l proc p figure a model of a program with three threads during a program execution threads exchange values through channels a trace of the program is the sequence of channels used along some full execution for instance is a trace of the program of figure corresponding to among others the execution ax ay call p call p ax ay cx cz call p y y bx by bz using standard techniques verification of safety properties can be reduced to the reachability of some program point which can be reduced to of the set of traces of a modified program notice that the set of traces is nonempty iff the program can terminate ie all threads can simultaneously reach their final node since this problem is undecidable even for further restrictions are the classical program analysis abstraction consists of replacing all condition statements by non deterministic choice which amounts to ignoring data since data do not longer influence controlflow we call the result an abstracted program unfortunately trace emptiness is still undecidable for abstracted multithreaded programs and for multithreaded for this reason we restrict the problem further however before doing so we define a formal model for abstracted multithreaded programs remark is formulated in for boolean programs programs in which all variables are boolean in boolean programs data control and so one could think that there is a deep conceptual difference with the program analysis abstraction however this is not the case since the number of valuations of the variables of a boolean program is finite the program can be easily transformed into a program whose program points are pairs consisting of a program point of the boolean program and a valuation of the variables this is in fact how the technique proceeds since it models a boolean program as a pushdown system a formal model in our presentation we to the program analysis abstraction for convenience and clarity but the technique can be equally well applied to predicate abstractions and boolean programs formal model let p be an abstracted multithreaded program with threads t tn communicating over a set ch of channels we assign to p a tuple g gn of contextfree grammars over the alphabet ch such that w in two is a trace of p steps first we iff w assign i we gn proceed with al ch such that w is a trace of p iff for every i n the projection of w onto belongs to in a second step we transform these grammars into the final grammars g gn the grammar gi over the alphabet generates the valid traces of ti these are the traces that ti can generate in an environment always ready to match its send and receive state ments gi has a variable for each node of ti a production for each edge and a further production for the final node of ti the tion corresponding to an edge leading from node x to node y and labelled by is defined as follows · if is a condition or an assignment the production is x y · if call p the production is x py where p is the initial node of procedure p · if ax or ay the production is x ay · the production for the final node z of t is z the three grammars for the program of figure have variables n n m m l l l terminals a b c a b b c and productions n an n m am m l cl n cn nn m mm l bl n bn m bm l n m observe that the number of proper procedures procedures that can be called unlike p in our example is equal to the number of variables z for which there is a production of the form x zy we call them procedure variables in our example those variables are n m it is easy to see that the traces of p under the program analysis abstraction are the words w ch satisfying the following property for every thread ti the projection of w onto is a word of this completes the first step for the second step we slightly modify each gi we set its alphabet to ch and add new productions for each variable x of gi and for each channel a that does not appear in gi we add a new production x ax the grammar so obtained is denoted by gi in our example we add productions mj to the second grammar for j and productions lj to the third grammar for j observe that a grammar gi is in a particular program normal form all productions are of the form x a or x where is a variable and is either a variable or all grammars now have ch as alphabet since every channel is owned by some thread it is easy to see that the set of traces of an abstracted program with threads t tn is equal to of a program point can be easily reduced to checking of the set of traces of a modified program our formal model reduces the reachability problem for abstracted programs to the problem for the intersection of contextfree languages since this problem is undecidable this does not immediately provide any algorithmic advantage for this reason we restrict the problem and introduce verification verification has recently proposed to only explore the traces of a multithreaded program having a certain shape inspired by the work of and he suggests to only explore traces to what we call in this paper communication patterns or just patterns for short patterns are regular expressions of the form ww wn where wi ch we study the problem of deciding given an abstract multithreaded program p and a pattern p whether some word of lp is a trace of p given the formal model given above this verification problem reduces to the following problem definition non disjointness modulo a pattern instance contextfree grammars g gg in program normal form over an alphabet and a pattern p over question is tg i lp context bounding as verification recall that in context bounding instead of whether a given multithreaded program has a trace we ask if it has a trace with at most k context switches before studying the complexity of we sketch an argument showing that context bounding can be seen as a special case of verification we do not formalize the reduction which would be very technical and tedious but describe it in enough detail in order to we hope the reader the languages of patterns are called bounded languages in the literature consider a multithreaded boolean program p communicating through shared variables without loss of generality see for details we assume that p has one single shared variable g which can take v different values we first show how to simulate p by a multithreaded program p whose threads communicate through message passing let t tn be the threads of p the program p gi that acts has as a threads t local copy each thread at any given ti has a moment variable in time every thread of p is either active or passive speaking when ti is active it simulates the thread ti when it goes passive it the simulation until its next active phase more precisely from its passive state a thread ti can either send a signal to all other threads through a channel ai by which it becomes active or receive a signal through a channel aj for some j i by which it remains passive after one of the two happens ti behaves as follows if ti has become active then it its simulation of ti thread ti simulates ti using the most recent value of g which is available from gi at any point ti may nondeterministically decide to the simulation in this case ti to all other processes the current value of g available through gi say u by sending a signal through a channel after sending this signal ti becomes passive if ti has passive then it for a signal through some channel where j i and when the signal it updates the value of gi to u observe that a context of p is simulated by an activity cycle of p ie a segment of the computation of p starting at the moment a thread becomes active and ending when it switches to the passive state since the trace of an activity cycle has length during a cycle the active thread sends exactly two signals the traces of p simulating computations of p with at most k contexts have length at most k the problem of deciding if p has a full computation with at most k context switches can now be reduced to an instance of the grammars of the instance are the result of applying the translation of section to p for the pattern let w w be the set of all sequences of length of the form there are nv of them and let p w clearly lp contains among others all sequences obtained by at most k words of w so all full computations of p with at most k contexts are simulated by computations of p whose traces belong to lp therefore if p has a full computation with at most k contexts then the intersection of the languages of the grammars obtained from p and p is nonempty the converse does not hold but this only shows that the instance of more computations of p that context bounding with k context switches of the decidability of was proved in we show it is np complete but we first define the size of an instance of since this requires some care the size w of a word w is its length w the size of a pattern p w the size of a grammar requires choice would be to define the size of a grammar g x p s as x p however recall that the grammar gt for a thread t is constructed in two steps in a first step a grammar gt is constructed that matches the behaviour of the thread is defined in a second step loop productions of the form x ax are added for every variable x and every channel a that does not appear in t in cases the number of these productions could be much larger than the number of true productions increasing since our multithreaded programs are the local variable gi is actually encoded into the nodes of the program as explained in a previous remark the size of the grammar for this reason when a grammar has productions x ax for every variable x and some terminal a we define that all those productions count as one single production for determining the size we denote the size of a grammar g so defined by g is nphard we show that is nphard even for regular grammars and fixed pattern p a from a programming point of view this means that the verification problem is already nphard for multithreaded programs and the simplest pattern theorem the following problem is nphard instance regular grammars g gg in program normal form question is tg i lp for the pattern p a proof the proof is by reduction from let be a propositional formula with n variables and m clauses c cm we define for each clause ci a regular grammar gi over the alpha v a prime number nv and assign to each clause c the number nc obtained by the of the three variables occurring in c this requires to construct n in time pn for some polynomial p it is wellknown that the ith prime number pi satisfies pi i ln i i ln ln i and so one can compute n by applying a test to each number from to n ln n n ln ln n notice that the test can take exponential time because the size of the number k is k given a clause c and a variable v we say that a number k is a c if v appears in c and k mod nv or v appears in c and k mod nv further k is a if it is a c or a c or a c where x y and z are the three variables occurring in c for instance if c x z and nx ny nz then k is a if k mod or k mod or k mod ie if k given an assignment to the variables of let n be the product of the numbers of the variables set to true by it is easy to see that satisfies c iff n is a now for each clause c we define a grammar gc in program nor form over the alphabet a the grammar gc has the numbers nc as grammar variables as axiom productions k a k c for every k nc where c is tion modulo nc and a further production k for each k nc we have ak k is a and so an assignment satisfies c iff iff is satisfiable and so p a iff is satisfiable for is in np we show that is in np the direct approach would be to there is a witness however it is easy shortest witness is the word ak see also lemma so we proceed differently in two steps first we reduce to a problem about parikh of contextfree grammars and then we show that this problem is in np the parikh image of a word w is the multiset w n that assigns to each a the number of occurrences of a in w the parikh image of a language l denoted by l is the set of parikh of its words we consider the following problem the proof is due to definition non disjointness of parikh instance contextfree grammars g gg in program normal form question is tg i the reduction from to relies on a classical result by and given contextfree languages l lg and a pattern p w wn over an alphabet there exist contextfree languages l lg such that tg i li lp iff tg i li the proof can be easily sketched take a new alphabet e a an and consider the homomorphism h e given by wi for every i n since contextfree languages are closed under intersection with regular languages and under inverse homomorphism the language li la an is contextfree and satisfies property moreover using the constructions underlying these closure properties we can easily construct from a grammar gi for li a grammar gi for li in polynomial time however for the complexity analysis in sect we also need to establish a relation between the number of procedure variables of gi and gi for this reason we provide our own direct construction a polynomial time reduction from to the following lemma contains the main properties of our construction lemma given p w wn over an alphabet e a an a homomorphism h e and a grammar g in program normal form we can compute in polynomial time a grammar gf over e in program normal such that · lp la an · if pr is the number of procedure variables in g then gf has · pr procedure variables where pa is the size of p proof sketch let gp be a regular grammar with variables such that lp this grammar clearly exists the variables of gf are triples where x is a variable of g and q q are variables of gp such that q is reachable from q the productions are chosen to satisfy that w holds in gf iff there exists u such that w hu la an x u holds in g and q u · q in gp this is achieved in two steps first a grammar g is constructed that satisfies u iff conditions and above hold the construction is similar to the triple construction used to transform a pushdown automaton into an equivalent contextfree grammar in the second step we the terminals in the productions of g the productions used to generate the letters of the words w wn are modified so that they generate no terminal at all with the exception of those productions generating the last letter of one the words w wn say the word wi these that are modified so that they generate the letter ai instead for the number of process variables notice that by the above construction each procedure variable in g yields procedure variables in gf hence if pr is the number of procedure variables in g we find that the number of procedure variables in gf is · pr a detailed proof of this lemma is given in an appendix is in np the proof relies on results of showing that parikh of contextfree languages are sets that sets are exactly the sets definable by existential presburger formulas and that satisfiability of existential presburger formulas is npcomplete we briefly recall these notions given k c nk and p p pm nk we denote by lc p the subset of nk defined as follows lc p m k n m n m c · p · · · m · pm a set s nk is linear if s lc p for some c nk and some finite p nk a set is a finite union of linear sets existential presburger formulas are defined by the following grammar and interpreted over natural numbers t x t t t t t t x · given an existential presburger formula we denote by the set of valuations of the free variables of that make true is satisfiable if is nonempty satisfiability of existential presburger formulas is an npcomplete problem see eg lemma a set s nk is existential presburger definable if s for some existential presburger formula it is well known that a set is presburger definable iff it is existential presburger definable iff it is we use the following result of th given a contextfree grammar g over one can compute in linear time an existential presburger formula g such that g lg we briefly sketch the proof for future reference let g x p s a result of characterizes lg as the set of all multisets m mp that are solution of a certain system of linear equations and for which a certain derived graph is connected then th shows that this set of multisets is presburger definable by explicitly constructing an existential presburger formula in linear time in the size of g theorem is in np proof by lemma it suffices to show that is in np let g g gg we have is and for an existential presburger formula since satisfiability of existential presburger formulas is npcomplete see eg the result follows analysis from a verification point of view it is important to analyze whether remains npcomplete or becomes polynomial for programs in which one or more of the following parameters is fixed the number of threads the maximal size of a procedure the maximum number of procedures per thread and the size of the pattern in the formal model these parameters correspond to the number of grammars g the maximal size of a grammar sg the maximal number of procedure variables in each grammar pr and the size of the pattern pa since each parameter can be fixed or not there are in principle p is fixed and that a parameter for instance the case in which g and pr are fixed but sg and pa are not is denoted by sg pr pa section consider the cases in which the size of sg is fixed sections and deal with the more involved cases in which sg is not fixed ie threads can have arbitrary size grammars in this section we assume that sg is fixed recall that the size of a grammar in program normal form is equal to the number of variables plus the number of productions but when for some terminal a the grammar contains a production x ax for every variable x then all those productions count together as one observe that the size sg of a grammar immediately pr the number of procedure variables of a grammar cannot be larger than its size this leaves four cases corresponding to the four combinations for g and pa we first observe that if on top of sg and pr we fix at least another parameter viz g or pa then each instance of can be reduced to one out of a constant number of instances and so the problem can be trivially solved in polynomial time so the only nontrivial case small but arbitrarily pa which corresponds to an arbitrary pattern this case remains npcomplete theorem the following problem is nphard instance regular grammars g gg in program normal form of fixed size and a pattern p question is tg i lp proof sketch by reduction from let be a propositional formula with n variables x xn and m clauses c cm we define for each clause ci a regular grammar gi such that i i i iff is i satisfiable let i n and ci i xi xi we define gi as a regular grammar for the language i i i where xk xk k i i i observe that we can easily give a regular grammar gi with four variables and four productions plus productions of the form x ax which are not counted in the size of the grammar it is now set of words n of and so by taking that p xx we are done grammars of arbitrary size nphard cases since sg is not fixed there are three parameters namely g pr and pa that can still be fixed or not we show that if at least one of these three parameters is not fixed then remains npcomplete in section we complete the analysis by proving that if all three parameters are fixed then becomes polynomial we have already dealt with one case theorem shows that sg pr pa is npcomplete in the theorem the gram cc are regular and so pr and the pattern is always a and so pa this leaves two cases sg pr pa a by a reduction from the problem definition ­ problem instance a set of objects o om and their associated weights w which are positive integer given in binary a positive integer w given in binary question is there a subset s o om such that the total weight of s is equal to w theorem the following problem is nphard instance two contextfree grammars g g in program normal form over the alphabet a question is lg lg lp for pattern p a proof the proof is by reduction from the problem let o om w w be an instance of the problem and let n be the maximum number of bits needed to encode any of the integers w w define g to be the grammar over unary alphabet a with productions given by the union of the sets through shown below intuitively a derivation of g nondeterministically selects a subset of objects as follows the object oi is selected by applying the production si oi has si if through the variable sin using the productions in and and then comes back to si using production formally we have sin and · si indeed the productions observe that wi of follow the × j wi if the jth bit is then the derivation moves to the next bit and if it is then the grammar outputs aj through aj the productions of make use of a wellknown encoding to ensure g o for every k n finally the axiom of g is s n si sin i o m si si i m sm im ak · k bit k of wi n is im k bit k of wi n is si i m o o ak k na we now turn to w and define the grammar gw by w k ak · w k k bit k of w n is ff w k w k k bit k of w n is ff n w o where w n is the axiom from the reasoning above we find that lg aw ¯ clearly g and gw can be computed in polynomial time and are in program normal form moreover it is easily seen that lg lp iff there is a subset s o om such that the total weight of s is w for sg pr pa we show that remains npcomplete for each of them with at most one procedure variable the proof is by reduction from the bounded post correspondence problem definition bounded post correspondence problem instance two sequences a a an and b b bn of words over an alphabet and a positive integer k n question is there a nonempty sequence i ik of k k not necessarily distinct positive integers each between and n such that ai ai bi bi theorem the following problem is nphard instance two contextfree grammars g g in program normal form each of them with procedure variable a regular grammar r in program normal form and a pattern p question is lg lg lr lp let a b k be an instance of the bounded post correspondence problem define n and assume it is disjoint from we construct the contextfree grammars g x p x where p x ai · x · i i x g y p y where p y bi · y · i i y the regular grammar r such that lr · sk i i and the pattern p a an k nk observe that since k n the size of p is polynomial in the size of the instance notice that g and g can be easily put in program normal form replace a production x ai · x · i by productions x ai · xi xi x · xi xi i · z z where xi xi and z are fresh variables finally observe that x is the only procedure variable it follows easily from the construction that lg lg lr lp iff the bounded pcp instance is positive notice that in this reduction neither the number of words in p nor their length is fixed by mean of a more involved reduction it is possible to show with a single word only but arbitrarily long this reduction is presented next a analysis we we have defined the can now size of in and a pattern consider p w the size as parameters the number n of words in the pattern and the maximal length of a pattern since the reduction of theorem requires a pattern with a large number of words n in the worst case we study whether npcomplete if on top of the number of grammars g and the number pr of procedures also the number of words n in the pattern p w wn is fixed but not their length we show that remains nphard by reduction to the problem of def consider the reduction from shown in th it does not yield a grammar with a fixed number of procedure variables because of the sets and of productions to solve this problem we first construct a grammar g with a fixed number of procedure variables that can still be used to encode big numbers by means of a more complicated encoding fix a number n and an alphabet a a an b bn and let w · · · we encode the number k n by the word wk the grammar g x p x has variables x x a an x is the only procedure variable and productions p given by the union of the sets to x an x k n ak k n ak ak n j k j k a a g can also be obtained as follows we first apply the construction of sect to the program shown in figure this returns a contextfree grammar in program normal form second some productions are merged for better readability consider the pattern p w our first lemma shows that the lp consists of a unique word given by k lemma g lp o for every k n proof the proof is by induction on k x an an bn call x an an aj bj call x an an a a bn b figure the abstracted program defining g for every i n we have ji i n as in k the only word which can be derived from a and follows p is given by w k we distinguish two cases k n and k n for k n consider the following partial leftmost derivation ak · · · ak · · · ak w · aa ak for the case k n consider an an w · aa an we only need these two partial derivations because every left most derivation that does not start like one of the two does not generates a word of lp either to conclude we apply the tion hypothesis on aa ak to show that ak w · w · w · · · wk hence that ak wk since pk i i k using this lemma we can already obtain a first reduction from the problem to in polynomial time if in the reduction of th the set is replaced by the set p we get lg lp iff there exists s o om such that ss weight is w however this reduction is not yet adequate because the variables a an are procedures variables see the sets and of productions to fix this problem we need a second lemma lemma lg lp o ak · lg ´ lp o for all k n proof any derivation of g that generates a word of lp must use the production first so that x an applying lem we get lg lp lan g lp o any derivation of g generating a word u such that belongs to lp must start with x bk · ak as shown in the proof of lem the derivation must continue with x bk · ak w · aa · · · ak and so finally lead to wk we the help of this lemma we can now proceed as follows recall that we have already replaced set in the reduction of th by p now we replace the set by · · · ak · x · im kn bit k of w is and the set by w k · · · ak · x · w k k bit k of w n is ff this gives two grammars g and g with s and w n as axioms respectively we have theorem the following problem is nphard instance two contextfree grammars g g in program normal form over alphabet each of them with procedure variable and a pattern p w consisting of a single word w question is lg lg lp proof the proof is by reduction to we construct g g and p as above the proof of correctness for the reduction essentially follows the one of th where the result of lem is used when needed we thus obtain that lg lg lp iff a subset of o om has weight w it is routine to check the following given a instance gi is computable in polynomial time x is the only procedure of gi where i and p w is computable in polynomial time note that gi are not in program normal form but can easily be into it by adding new variables and productions the transformation does not add any procedure variable grammars of arbitrary size a polynomial case we present the most involved result of the paper a polynomial algorithm to notice that the reduction of presburger formulas of th does not help because it yields formulas of arbitrary size that to the best of our knowledge do not fall immediately into any polynomial class described in the literature see eg however using some recent results of we show how to compute in polynomial time an formula that belongs to the polynomial class of as a first step we observe that because of the reduction from to shown in section it suffices to provide a polynomial algorithm for and in fact only for the instances of with a fixed number g of grammars over an alphabet of fixed size al and a fixed number of procedure variables pr ie a polynomial procedure for shows that al the size in the indeed lem reduced instance is fixed because pa is fixed in and that pr the number of procedure variables in the reduced instance is fixed since pa and pr are fixed let g gg be an instance of polynomial algorithm proceeds in two sg pr steps for the i g the algorithm computes a regular grammar or non deterministic automaton ai such that then steps can be the out in polynomial time for this we prove two facts first if gi x p s then the algorithm constructs ai in time and space for some function f second given automata a ag over an alphabet of size al the algorithm performs in g oa · · · pr and al have fixed values so do f pr and al step we show that given a contextfree grammar g in program normal form with pr variables we can construct a regular grammar ag satisfying lg in time and space for some function f for this we a recent result of which shows that such a grammar can be constructed in time and space where v is the total number of variables of g we start by defining the grammar ag definition let g x p s be a contextfree grammar in program normal form and let pr be the number of procedure variables of g we define the regular grammar ag q q as follows · q is the set of all multisets m mx of at most pr elements and q the axiom is given by s · where contains a production m · m iff p contains a production x such that x and m x m observe that q ox pr and q · al we set out to prove the following result see theorem in the next page by means of several lemmas let g x p s be a contextfree grammar in program normal form the regular grammar ag of def satisfies lg we first introduce some new notation given l l we write l l respectively l l to denote that the parikh image of l is equal to respectively included in the parikh image of l also given w w we abbreviate w w to w w using this notation we can rewrite our proof goal lg as lg the proof is a modification of the one given in the inclusion lg is proved in prop establishing lg is done through the chain of lg where is the approximation of lg defined as follows definition a derivation s · · · m of g x p s has index k if for every i m at most k symbols of i are variables the set of words derivable through derivations of index k is denoted by the inclusion is proved in lem to prove lg we need a few definition let g x p s be a contextfree grammar in program normal form we inductively define the set t r of finite labelled trees as follows · if x p then the tree t labelled by production x and consisting of one single node is a tree of t r and its yield t is equal to · if x a · y p then the tree t labelled by x a · y and having as only child a tree t t r labelled by some y p is a tree of t r and t a · t · if x y p then the tree t labelled by x y and having as only child a tree t t r labelled by some y p is a tree of t r and t t · if x z · y p then the tree t labelled by x z · y and having two children labelled by some z left and y right is also a tree of t r and t t · t a tree t t r is a derivation tree if it is labelled by a production s p for some the set of all derivation trees of g is denoted by tg the yield t of a countable set t t r of trees is defined by t derivation tree whenever in the following we mean lemma easy let g x p s be a contextfree grammar in program normal form then lg tg by lem proving lg reduces to proving tg we now introduce the notion of dimension of a tree definition the dimension dt of a tree t is inductively defined as follows if t has no children then dt if t has exactly one child t then dt dt if t has exactly two children t and t then dt dt if dt dt dt if dt dt the set of all derivation trees of dimension k for grammar g is denoted by the next lemma goes along the lines of lem but with many small changes lemma let g x p s be a contextfree grammar in program normal form with pr procedure variables then tg i proof in this proof we write t t · t to denote that t is a derivation tree except that exactly one leaf is labelled by a production of the form a with t is a derivation tree labelled a for some and the tree t is obtained from t and t by replacing the leaf a of t by t we want to prove that for every tree t tg there exists a tree t such that t t and dt pr let a tree t be compact if dt lt where lt l t and l t is the number of distinct procedure variables in t we find that l t pr for every t tg hence lt pr to establish the above result it suffices to show that for every tree t there exists a compact tree t such that t t the proof is by induction on the number of nodes of t in the base case t has just one node labelled s so dt lt hence t is compact and we are done in the following assume that t has more than one node and dt lt holds if t has exactly one child t then dt dt lt since t has one node less than t induction hypothesis shows that t can be made compact ie dt lt next we conclude from the definition of l and the structure of t that lt lt also that dt dt and finally that dt lt and we are done let us turn to the case where t has two children t and t we assume that dt dt dt finally by the induction hypothesis we can further assume that t and t are compact ie for i from the definition of dimension and l t is a subtree of t and dt lt we find that lt dt dt lt lt we conclude from above that dt lt and dt dt hence that dt dt by definition of dimension and finally that dt dt lt lt lt since t t are compact subtrees of t we now prove the following claim there is a path in t from the root to a leaf such that two nodes are labelled by z and z where z is a procedure variable our proof is by contradiction observe that for derivation tree t with child t such that dt dt the definition of dimension and program normal form shows that t is labelled by x z · y for some variables x z and y if dt k then the rooted path that goes down through the left child whenever possible has at least k nodes with label of the form z where z is a procedure variable finally since dt lt l t where l t is the number of distinct procedure variables in t we find that two nodes are labelled z and z where z is a procedure variable hence a contradiction so t can be into ta · tb · tc such that tb and tc have their root labelled z and z where z is a procedure variable as lt lt lt we also find a node of t labelled z where z is a procedure variable which allows us to write t ta · tb where tb has its root labelled z where z is a procedure variable now we cut out the middle part tb of t and insert it between the two parts ta and tb of t so that we get t ta · tb · tb and t ta · tc we then have lt lt lt lt by induction t and t can be made compact so dt lt dt dt lt dt consider the tree t obtained from t by replacing t by t and t by t clearly t t if dt dt or dt dt then dt dt lt lt by definition of dimension and we are done because t is compact otherwise we have dt dt lt lt lt so we can iterate the above procedure and insert a part of t into t this procedure terminates because the transfer of nodes from the second child to the first cannot proceed forever by this lemma proving tg reduces to showing tg i g to conclude the proof we show i g lemma for every k proof let t be a derivation tree of dimension k the proof is by induction on the structure of t base t consists of a node labelled s hence k and s is of index step t has two children t and t such that dt dt dt by the definition of dimension we have dt k let a a and a be the roots of t t and t respectively then a aa is a production of the grammar by induction hypothesis there are derivations a w of index k and a w of index k so there is a derivation a aa aw ww of index k collecting the results above we get theorem for every contextfree grammar g in program normal form with pr procedure variables lg proof in prop la lg has been proved for the reverse inclusion lg tg lem lem lem lem corollary given a contextfree grammar g with pr procedure variables we can construct in time a regular grammar ag such that lg proof follows immediately from the fact that the number of variables of the regular grammar ag of def for a contextfree grammar g with n variables and pr procedure variables is step given regular grammars a ag over an alphabet of size al we show that tg i can be checked in time oa · · · for a function h it is well known that for every regular grammar a the set la is it has been recently proved that la is small theorem th let a be a regular grammar with n variables over alphabet of size al there exists a representation of la as a union of linear sets sm j pj where m is polynomial in n and exponential in al the maximum entry of each cj is polynomial in n and exponential in al the number of in each pj is at most al and the maximum entry of each period is at most n furthermore this is computable in time polynomial in n and exponential in al this theorem suggests the following procedure to check for fixed g as given first compute for above this is done each ai a in time in the number of variables of ai since is of fixed size then for each tuple lc p pg where pi is g pi polynomial since and so in order to obtain a polynomial procedure we just need to prove that the can be checked in problem to solving a polynomial time for this system of linear equations over the natural numbers definition let t lc p pg be a tuple of linear sets of dimension al where pi o the existential presburger formula t is given by x xj id id id g al where id id denotes the formula a x a x a i i in the above definition the id id has the fol interpretation id id is satisfiable iff there exist v pid and v pid such that v v therefore v al id id is satisfiable iff pid and pid have a common vector ie iff pid pid so v id g v al id id is satisfiable iff pi hence the following result lemma let t lc p pg be a tuple of linear sets we have pi iff t is satisfiable assume now that the maximum entries and number of of the linear sets in the tuple t of def are as given in th an inspection of the formula t in def shows that in this case the number of variables of t is at most g al and so that t is an existential presburger formula with g al quantifiers and no free variables since g and al are fixed parameters g al is also fixed it follows that the satisfiability of t can be determined in polynomial time by means of the algorithm see also this concludes the proof that given regular grammars a ag over an not can holds or conclusions we have studied the complexity of verification an approach to the verification of multithreaded programs essentially introduced by in the approach the programmer to supply a pattern a regular expression of the form w wn over the alphabet of channels and possibly other program instructions the verification tool then analyzes whether the program has some execution that uses the channels to the pattern the expressivity of verification was first investigated in where it was shown that context bounding the technique introduced by qadeer and in and implemented in slam and other tools is a special case of verification in this paper we provide a further analysis and give a explicit reduction we have reduced the verification problem to the problem of deciding whether the intersection of a given set of contextfree grammars and a pattern is nonempty putting together classical results by and about bounded contextfree languages the characterization of the parikh of contextfree languages given in the encoding of this characterization into existential presburger arithmetic presented in and the fact that existential presburger arithmetic reduces to solving a system of linear equations wellknown to be in np we have shown that is npcomplete since context bounding is also npcomplete the additional expressivity of verification does not come at an extra cost in terms of asymptotic complexity we have a analysis of on the number of threads the maximum number of procedures per thread the maximal size of a procedure and the size of the pattern by requiring the value of a parameter to be fixed or not we get cases we have shown that all except one are either trivially polynomial or still npcomplete the analysis of the remaining case all parameters fixed except the maximal size of a procedure is the main technical contribution of the paper using a novel constructive proof of theorem and recent results about the parikh of nondeterministic automata we have shown that this case is polynomial given the high complexity of automatic verification of multithreaded procedural programs unless strong constraints like absence of communication between threads or restriction to local properties of a thread are imposed we think that this is a result two comments about our model are in order first while we have only considered abstracted programs ie we assume that all program paths with correct nesting of procedure calls and returns and correct synchronization over channels are feasible our approach can also be applied to boolean programs at the price of an increase in the size of the procedures and the number of procedures per thread notice that context bounding and other techniques face the same problem second we have for a communication model based on rendezvous a la csp the reason is convenience the connection between the verification problem and the emptiness problem for the intersection of contextfree grammars is easier to describe in this model our approach can also be applied to other communication mechanisms by choosing the alphabet of the patterns related work the automatic verification of safety properties for multithreaded programs with possibly recursive procedures has been studied in the last years the program is usually modeled as a set of pushdown systems communicating by some means several special cases with restricted communication have been proved decidable including communication through locks satisfying certain conditions linearly ordered systems and systems with acyclic communication structure also some additional conditions ­ several recent papers study the automatic verification of parametric programs with an arbitrary number of procedures and with dynamic creation of procedures two features that we have not considered in this paper from a complexity point of view verification lies together with and communication through locks at the lower end of the other approaches require exponential time but do not belong to np or this is not known or are the only other case we know of a problem with polynomial complexity in the size of the program is the verification of properties close to local reachability in systems communicating through locks many thanks to for providing the proof of theorem to to for a more direct polynomial time algorithm using to michael and rybalchenko for helpful discussions and finally to the anonymous reviewers for their helpful comments and to for pointing in the manuscript references find and in concurrent programs url m f b and p emptiness of automata is in proc th int conf on developments in language theory volume of lncs pages ­ springer m f a and t on the reachability analysis of acyclic networks of pushdown systems in concur proc th int conf on concurrency theory volume of lncs pages ­ springer m f a and s qadeer analysis for concurrent programs with dynamic creation of threads in tacas proc th int conf on tools and algorithms for the construction and analysis of systems volume of lncs pages ­ springer t ball and s k rajamani the slam project debugging system software via static analysis in popl proc th acm sigplansigact symp on principles of programming languages pages ­ acm press a m and t regular symbolic analysis of dynamic networks of pushdown systems in concur proc th int conf on concurrency theory volume of lncs pages ­ springer j petri nets commutative contextfree grammars and basic parallel processes ­ j p s and m theorem a simple and direct construction p b and r majumdar bounded in cav proc th int conf on computer aided verification volume of lncs pages ­ springer m r and d s johnson computers and a guide to the theory of new york s and e h presburger formulas and languages journal of mathematics ­ e subclasses of presburger arithmetic and the polynomialtime hierarchy theoretical computer science ­ j e hopcroft and j d ullman introduction to automata theory languages and computation addisonwesley st edition v vs of lock chains characterizing decidability of pairwise for threads communicating via locks in lics proc th annual ieee symp on logic in computer science pages ­ ieee computer society v tractable dataflow analysis for concurrent programs via bounded languages wo july v and a gupta on the analysis of interacting pushdown systems in popl proc th acm sigplansigact symp on principles of programming languages pages ­ acm v f and a gupta reasoning about threads communicating via locks in cav proc th int conf on computer aided verification volume of lncs pages ­ springer a d and t dynamic detection in parameterized concurrent programs in cav proc th int conf on computer aided verification volume of lncs springer e and a w to parikh of grammars complexity and applications in lics proc th annual ieee symp on logic in computer science ieee a and t reps reducing concurrent analysis under a context bound to sequential analysis in cav proc th int conf on computer aided verification volume of lncs pages ­ springer a t n and t w reps interprocedural analysis of concurrent programs under a context bound in tacas proc th int conf on tools and algorithms for the construction and analysis of systems volume of lncs pages ­ springer j h w integer programming with a fixed number of variables mathematics of operations research ­ r j parikh on contextfree languages journal of the acm ­ s qadeer the case for verification of concurrent programs in proc of th int model checking software workshop volume of lncs pages ­ springer s qadeer and j model checking of concurrent software in tacas proc th int conf on tools and algorithms for the construction and analysis of systems volume of lncs pages ­ springer g contextsensitive analysis is undecidable acm toplas ­ b complexity of of presburger arithmetic trans of the mathematical society ­ d j and s symbolic analysis of multithreaded java programs in proc of th int model checking software workshop volume of lncs pages ­ springer a w to parikh of regular languages complexity and applications s la g and p reducing concurrent reachability to sequential reachability in cav proc st int conf on computer aided verification volume of lncs pages ­ springer k n h and t on the complexity of equational horn clauses in th int conf on automated deduction volume of lncs pages ­ springer j von and m a bound on solutions of linear integer equalities and inequalities proc of the mathematical society ­ a reduction of to a construction of the grammar gf let p w wn and let wi bi for every i n let gp x p p q be the regular grammar where xp s n r o js p s n i o js s s o n o sn it is routine to check that sn i given gp and a grammar g n form our goal is to define a grammar for the language lp la an we first define g x p x which as we prove later satisfies lg lg lp x x x x x p s o x · p is the set containing for every s x n a production x and for every production x p of g and for every s n r js a production for every production x y p of g and for every s u n r js v a production for every production x · y p of g with and for every s u n r js v productions · if r js and and · qs y p if and s s u for every production x zy p of g and for every s u x n r js v y a production in what follows we use x to indicate that the derivation is carried out using the of the grammar g lemma let w we have x g w iff gp w · and x w g proof the proof for the only if direction is by induction on the length of the derivation of w i then the definition of g shows that x p and so x i we do a case analysis according to the definition of g · w it is trivially solved using the induction hypothesis · · w the definition of g shows that for some r js the production · p and induction hypothesis show that x · · also the hypothesis show production that x · y · w and we are done since · · qs y · w the production · qs p and induction hypothesis show that · qs · also the production x · show that y x p where · y and the induction and we are done hypothesis · ww w by induction hypothesis we have w · and z w also w · and y w hence we find that ww and x ww since x z · y p which concludes this case since w ww using a similar induction on the length of x w the if direction is easily proved we now obtain a grammar gf by slightly modifying g we change the productions of and respectively to and y where as e because of this change gf has alphabet e also it is routine to check that this change amounts to applying the inverse homomorphism h and taking the intersection with la an a proof of lemma given p w wn and a grammar g in program normal form we have that gf satisfies each of the following properties · e where e a an · lp la an · gf is in program normal form · gf is computable in polynomial time · if pr is the number of procedure variables in g then gf has · pr procedure variables where pa is the size of p proof the first item is obvious from the definition of gf let gf x f e pf x if follows directly from lem that for every w x g w iff qs gp where s x n and s g w the productions s o n p of gp shows that the equivalence can be rewritten as follows x g w iff qs gp w where s n and s g w we conclude from the definition of gp that lp sn i gp hence that lg lg lp and finally that la an the second item is immediate from the definition of gf and that g is in program normal form the third item is clear from the definition of g and gf for the fourth item we have that since pa is the size of p pa is also the size of x p by definition of gp also shows that each procedure variable in g yields procedure variables in g hence if pr is the number of procedure variables in g we find that the number of procedure variables in g hence gf is · pr 