automata oxford university computing laboratory abstract what is a basic model of computation with names and generation we introduce automata a new class of automata which operate on an infinite alphabet of names and use a finite number of registers to store fresh names and to compare incoming names with previously stored ones these finite machines extend and automata by being able to globally fresh inputs that is names fresh in the whole current run we examine the expressivity of both from the aspect of accepted languages and of bisimulation equivalence we establish primary properties and connections between automata of this kind and answer key decidability questions as a example we express the theory of the picalculus in and bisimulation equivalence by an appropriate and decidable in the finitary case notion in these automata categories and subject descriptors f computation by abstract devices models of computation d programming languages formal definitions and general terms theory languages verification introduction one of the most common and useful abstractions in programming is the assumption that entities of specific kinds can be created at will and moreover in such a manner that newly created entities are always fresh distinct from any other such created thus far this is for example the case with mutable reference cells exceptions datatypes etc in languages like standard ml following a long in computer science we call these entities names and specify them as follows names can be created fresh dynamically and locally compared for equality and between agents or subroutines apart from the uses mentioned above names form the basis of calculi of mobile processes eg the calculus appear in network protocols and secure transactions and are generally essential in programming for identifying variables channels threads objects codes and many other sorts of name in to our knowledge there has not been in the literature a proposal of a basic model of names providing abstract machines underlying all these we propose just such a model here permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm our model is based on the successful paradigm of automata introduced by and in the early s motivated by realworld problems where codes addresses identifiers etc may have unbounded domains those automata address a demand for a natural finitestate machine model over infinite alphabets an a is an automaton attached with a finite number of registers its structure looks identical to that of an ordinary finitestate automaton over a finite set of labels generated by indices in the range n where n is the number of registers however a operates on the infinite set of inputs a the set of names with indices i referring to the names stored in the ith register of a this simple idea the automaton from finite to infinite alphabet there are two ways in which an can access its registers either by comparing an input name to a stored one or by storing an input name in one of its registers but only in case it is locally fresh that is it does not already appear in any of them thus are their computational steps rely solely on their current registers here we introduce automata a automaton model which extends by global freshness recognition an automaton can now accept and store an input name just in case it is fresh in the whole run for example a transition q i q means that if a is at state q and the set of names that have appeared in its registers so far is h then a can accept any name a h store it in its ith register and proceed to q this feature precisely captures creation thus eg the following language not by is by a with one register l a · · · ak a i j ai aj an intuitive way to view l is as the trace of a generator one which returns reference cells in sml objects in java memory addresses in c etc research in and their formal languages has been extensive it has been shown that languages are closed under union intersection concatenation and kleene star they are not closed under complement emptiness of is decidable and is undecidable our first contribution is to answer this series of questions for we show that for emptiness and the situation remains the same as in on the other hand languages are still closed under union and intersection but this for concatenation and kleene star moreover they are not closed under complement and in fact there is an language whose complement is not by note that although the automaton does not have full access to the history h in the situation can be described as an oracle who can decide the freshness of names our main for studying equivalence between is bisimulation equivalence also called bisimilarity the notion is very relevant from the point of view of programming and process calculi in particular and in the case of it implies language equivalence more importantly we show that by examining at the symbolic level ie as ordinary finitestate automata on the set of labels it is possible to capture bisimilarity by an appropriate symbolic notion we thus prove that is decidable a symbolic bisimulation relates states of two automata in specific environments the latter specifying how are the names which appear in their registers related as a example we express the calculus in the context of automata we introduce the xcalculus system a presentation of the calculus with early transition semantics in which processes are states of an infinite transitions are given by and the system is finitely branching more specifically bound outputs are modelled by globally fresh transitions while each input is decomposed into finitely many cases either the incoming name is locally fresh or it already appears in the registers this clean treatment of fresh and bound names is the main advantage of the xcalculus and allows for the finite representation as ordinary of finitary processes moreover we strong bisimilarity by an appropriate symbolic notion in x this gives an alternative proof of decidability of bisimilarity for finitary processes motivation and related work programming languages the idea of studying names in higherorder languages and in isolation of other effects was first by pitts and they introduced the calculus an extension of the simplytyped calculus with references of unit type on the calculus were carried on by in his phd thesis which exposed a rather complexity hidden behind names it evident that better models for languages with names were needed to address this new directions in denotational and operational models were explored significantly our understanding of computation with names but at the same time leaving basic questions in particular those works examined computation at the higher level that of programs and program equivalence leaving open the question of a basic model interestingly in their initial paper on and their construction also by briefly presenting an procedural language with names there names cannot be created but they can be read from the environment as inputs and stored in a finite memory moreover stored names can flow inside the memory from one register to another and can also be compared for equality and thus trigger the authors explain that operate like for that simple imperative language with names by analogy describe the extension of the language with generation process calculi for mobile systems like the calculus where processes can create locally receive or send names the use of ordinary labelled transition systems for its semantics is in many ways for example infinite branching arises even in the case of very simple processes that receive a locally fresh name or output a locally created globally fresh one such naturally led to solutions involving representations of processes by which incorporate of some sort the most paradigm in this direction is that of automata which are structures defined in a universe of named sets and named functions can represent the calculus as a process is finitary if its it does not grow in parallelism match names between the source target and label of calculus transitions allowing thus for the use of of processes and transitions rather than all possible ones under eg permutation of fresh names the stream of research on has both on foundational issues and on pragmatic applications the work presented here shares objectives with and to some extent can be viewed as a complementary attempt to the same question based on basic machines of first principles outline in the next section we give the basic definitions on section provides some useful bisimilar constructions in section we recall and establish their connection to we examine a weaker notion of on global freshness in section in section we prove some technical results regarding closure properties for and in section we show that emptiness and bisimilarity are decidable using symbolic methods section the calculus in the setting of definitions we distinguish between two sets of input symbols · an infinite set of names a and · a finite set of constants c constants have an auxiliary role and are we let a b etc range over names we write a for the set of finite strings of names and a for its restriction to those containing pairwise distinct names strings a · · · an will be typically represented by vectors a in which case a an for each n we write n for the set n and let ln c i i i n be the set of labels generated by n moreover we define n a i j i j i to be the set of register assignments of size n we write for the of ie a a i i a and let dom i n i a whenever a i a i a j j j n i is an update of for any i n definition a automaton of n registers is a a q q f where · q is a finite set of states · q is the initial state · is the initial register assignment · q × ln × q is the transition relation · f q is the set of final states a is called a register automaton ra if there are no q q i such that q i q transitions containing labels of the form i are called known transitions those of the form are locally fresh ones and globally fresh transitions involve i thus an ra is an with no globally fresh transitions here is an informal reading of suppose a is at state q with current register assignment if input c a then in other there is no such distinction but symbols that appear in the initial register assignment can play the role of constants this yields the same notion of register automaton as that of note that the same symbol is later used to range over elements of ln · if c and q q then a accepts and moves to q · if a and q i q and i then a accepts and moves to q · if a and q q and is not stored in then a accepts it sets i and moves to q · if a and q i q and and has not appeared in the current run then a accepts it sets i and moves to q the above is formally defined by means of configurations representing the intended current state of the automaton which apart from states contains information on the current register assignment and the set of names having appeared thus far the history the latter component is necessary for globally fresh transitions definition a configuration of a is a triple q h q with q q × × and being the set of finite subsets of a from define a transition relation on configurations q × c a × q as follows for all q h q and q q · if c then q h q h · if i and i a then q h a q h a · if and a then q h a q h with i a and h h a · if i and a then q h a q h with i a and h h a we write for the reflexive transitive closure of we say that configuration q is reachable if q q for some a c we call a a closed if for all reachable configurations q h and all q i q we have that i finally the set of strings accepted by a is la a c q q h q f and is called the language by a two automata are equivalent if they the same language remark there is an equivalent definition of in which histories include by default and in which reachable configurations are the ones reached from q here instead we have decided to separate the history of the run from its initial names which appears to give a presentation but it is by no means a substantial point of difference note also that reachable configurations contain names that have appeared before one way or another if q h is reachable then h example the reader can check that the language l a of the introduction is by the following a q q q q q note that the b q q q · q q the language l a · · · ak a k i ai ai and is therefore not equivalent to a a more elaborate example is the following let a be the · q · q · q q with initial assignment the automaton works as follows it receives a name a and then keeps receiving a until some b a then it keeps receiving b until a globally fresh c it then from start thus members of la are of the form aj bk c aj bk c aj bk c cn where for all i we have ji ki ai bi and ci differs from all symbols preceding it formally setting lh an bn c ni a b c h a b we have that la s i li where we set l l and li a b a li b some basic results the languages of are regular once constrained to a finite number of symbols moreover the language accepted by an is to that do not affect its initial register these properties carry over to and are proved as in proposition let a q q f be an of n registers and s a be finite then la s is a regular language proposition for a as above if a la and a a is such that a a for all a then a la bisimulation bisimulation equivalence turns out to be a great tool for relating automata even from different it implies language equivalence and in all our cases of interest it is not too strict in this aspect we choose it here as our main of study definition let ai qi qi i i fi be with ni registers for i a relation r q × q is called a simulation on a and a if for all q q r · if q f then q f · if q q then q q for some q q r r is called a bisimulation if both r and r are simulations we say that a and a are bisimilar written a a if there is a bisimulation r such that q q r lemma if a a then la la the above is proved using standard methods bisimilarity is also called bisimulation equivalence for instance the automaton a of example is bisimilar to b q q q q · q q q q q with a bisimulation this being the following q q q h q h h h where bisimilar constructions in this section we demonstrate some bisimilar constructions which will be useful in the sequel starting from a automaton a q q f of n registers we effectively construct the following bisimilar automata · the closed a called the closure of a · for any a a with the a a this is called the extension of a by a and its initial assignment is a i n ai i a our presentation will focus on constructing the bisimilar automata and the candidate bisimulation relation r the actual proof that r is a bisimulation as these proofs are not difficult but tedious and follow directly from the constructions closures for a as above with n registers we define its closure to automata be the a q q f given as follows we set q q × pn q q dom and f q s q f recall we want to construct an automaton which is closed that is whenever a configuration with state q and assignment is reached and q i q is a transition then i a and therefore the transition is allowed the extra component added in q monitors the registers that have been assigned a name note that once a register has been assigned a name it cannot return to the state consequently will be designed in such a way so that this monitoring carries through and moreover the known transitions included in are always allowed q s q s q q c we now present and examine their properties in relation to and in fact are equivalent to and in the literature they have been used as eg compare with the precise correspondence is stated in proposition which is a result let us recall the original definition from a automaton of n registers is a a q q f where · q is a finite set of states with q q initial and f q final · is the initial register assignment · q n is the partial function q s i q s q i q i s · q × n × q is the transition relation q s q s q q s s i now we can check that the following relation is a bisimulation r q h q s h dom s and therefore that a a moreover the reachable configurations of a are of the form q s h with dom s and therefore the automaton is closed the intuitive reading of is the following suppose a is at state q with register assignment and let q i q if input a a then · if i a then a accepts a and moves to state q · if a and q i then a accepts a it sets i a and moves to state q remark if a q q f is a closed then each path q q · · · m qm in a where arrow notation represents yields is a configuration path q q h · · · m qm m hm according to the definition of for example if j i then j ji j j and j i in this case of a guarantees that j i name extension for a as above with n registers and a a a sequence of length m such that we define the extension aa as the with nm registers and description q q f given as follows we set formally a configuration is now a pair q q where q q × and the transition relation q × a × q is defined as follows for all q q and q i q · if i a then q a q · if q i then for all a q a q i a the notions of reachable configurations and accepted strings and languages are defined just as in the case of example recall the language l of example l a · · · ak a i ai ai q q × n n m × pn n m which is l is by the and q q n nm with the inclusion function f q f s q q f and a finally q f s f q f s c q q b q q q q q q q q q where q q q and comparing this to b of example the reader can observe how the differences between q f s j q f s q q j q f s j q f s q i q j s where f f f i f i f for c f f i j and s s j the transition relation in a a proceeds as in a with the exception of fresh transitions where some extra care and in have been addressed here by use of the extra register the main properties of and languages have been established as follows a emptiness is decidable for ie is la and in particular it is npcomplete is needed since the registers of the new automaton contain more b the languages accepted by are closed under union names than those of the initial one fresh transitions in a a can intersection concatenation and kleene star they are not closed now capture fewer names for example if a is one of the added names then an transition from the initial configuration could capture it before but this is no more the case as a appears in instead we need an explicit j transition for this purpose this is what the second clause of the definition of addresses for this to work under complement c is undecidable ie is la a hence the equivalence and containment problems are undecidable too ie is la lb we need to introduce the component f to keep track of the we shall see that the emptiness problem is also decidable for between old and new registers that arise in the way just proposition clearly being extensions of described for globally fresh transitions a similar situation arises implies that of the former is undecidable and hence the only that this time we need only remember which of the names in same holds for equivalence and containment in section we will the initial a have not appeared in the history thus far which is what examine closure properties of and show that closure under the component s achieves thus the following is a bisimulation concatenation and kleene star are lost closure under complement r q h q f s h f hs still fails but closure under union and intersection we now relate to the kind of automata we have intro and therefore a a a previously in essence are the same as the notions of simulation and bisimulation straightforwardly extend to in fact definition applies to all machines operating on the infinite alphabet c a which have configuration graphs containing initial and final configurations it therefore makes sense to extend these notions to pairs and pairs later on proposition for any a of n registers there is an effectively ra b of n registers such that a b conversely for any ra b of n registers there is an effectively a of n registers such that a b proof going from to is simple we use the same set of states we match each transition q i q with q i q and additionally for each transition q i q where q i we add q q the other direction is more elaborate but the construction is already known so we omit it corollary the equivalence and containment problems are undecidable for and weak automata in this section we examine a weaker version of by on the aspect of global freshness while that of local freshness even though this restriction leads us to machines that do not extend we show that remains undecidable proposition the machines we introduce operate on sets of labels c i i i i n where i stands for accept any name transitions moreover their registers are now taken from the sets n a definition a weak automaton of n registers is a a q q f where · q is a finite set of states with q q initial and f q final · is the initial register assignment · q × × q is the transition relation the transition relation has the same intuitive meaning as in the case of with the exception that in transitions of the form q i q the automaton accepts any name a stores it at its ith cell and moves to state q formally a configuration is now given as a triple q h q where q q × n a × and the transition relation q × c a × q on configurations is defined as follows for all q h q and q q · if c then q h q h · if i and i a then q h a q h · if i then q h a q h · if i and a then q h a q h with i a and h h a reachable configurations and accepted are defined exactly as in example consider the following language l a · · · ak b · · · bl a i j ai aj bi bj which is in fact the concatenation of a with itself and the q q q q q with registers both of them initially empty call the above a we claim that la a l that is s la s l for all s a the forward implication is clear if s la then either the same name a appears three times in s via the path or names a and a appear each twice in s without interleaving via the path in both cases s l for the opposite direction let s l and it to a since s a we can write s with sas a in a leads control to q now s l implies that as a so there is some a in as such that as as a and a appears in as if a a then s a leads a directly to q otherwise it leads to q via q the reader may want to verify that changing the labels of the loops at q and q above to and the label from q to q to leads to a a that still satisfies la a l we show that any has a bisimilar of the same number of registers the idea is to simulate the nonlinear memory ie a set of registers that may contain names in common of the by a linear memory plus a reordering function on the part for example here is such a simulation a b b a b c plus the reordering functions will be attached to the states of the moreover we shall simulate ie of the form i of the by means of and j for all j in the end defining the new transition relation gets a bit involved as one has to bear reorderings in mind which need to be for before making a transition and updated lemma for any a of n registers there is an effectively b of n registers such that a b proof let as follows a q q f we set q q × n construct b n and q q write elements f of q as q f simulation of nonlinear memory by linear memory and reordering f is defined in the obvious manner f moreover for each i n the multiplicity of i ie the num of times it appears in is given by the size of f f i we denote this by we let f be a simulation of such that contains no more names than and set q q f and f q f q f we now define q f q f q q c q f f i q f q i q q f f i q f q i q q f j q f q i q j q f f q f q i q q f q f q i q j q f j q f q i q where f f i j the first line is straightforward the second line says that receiving the name of the ith register in a is simulated by receiving the f ith name in b the same is repeated in the third line only that now we have to do a memory update and therefore we need to be careful with reorderings in particular storing the new name say a in the f ith register should not be allowed when if this is the case and we set f i a then a still appears in but no longer appears in thus the simulation nonetheless if then there must be some j which is free in ie j and we can safely store the new name in there updating the reordering function accordingly the last three lines of implement the idea that receiving any name can be matched by receiving either a locally fresh name or one of the stored ones thus r q h q f h f is a bisimulation and therefore a b we next show that the absence of locally fresh transitions in them of languages combining this with the previous result we obtain that are indeed strictly weaker than lemma the language l a · · · ak i of examples and is not proof suppose l la for a a with n registers then for any s a of length m we have ss la let the following be the transition path in a accepting it q · · · q q · · · m qm with the from q to qm accepting the second copy of s then none of the s can be of the form i as their names have appeared before moreover if i j then i can also accept the preceding symbol the fact that la l hence all s are in n choosing m n we arrive to a contradiction emptiness is decidable for by inheritance more interestingly the problem remains undecidable and hence the same happens for equivalence and containment proposition is undecidable for proof the proof is by reduction from the post correspondence problem and follows the track of the analogous proof in in particular we show that the locally fresh transitions of the constructed in that proof can be replaced by unlike here it is necessary to use the set c closure properties in order to establish closure properties of and following the approach on in it is useful to introduce a version of with multiple assignment that is automata that can store an input name at several of their registers at one step in particular assignments will now be taken from the sets the set of labels we shall use is the following ln c pn × pn × pn labels of the form s t are written simply s t and when we write s t a we assume a if we want to allow for we write s t a definition an of n registers is a a q q f where · q is a finite set of states q q is initial and f q are final · is the initial register assignment · q × ln × q is the transition relation the intuitive reading of is the following if a is at state q with register assignment and input c a then · if c and q q then a accepts and moves to q · if a and q s t q and s t ie appears exactly in the registers in t after it is assigned to all registers in s then a accepts it sets s and moves to state q · if a and q s t a q s t and has not appeared in the history nor does it appear in a then a accepts it sets s and moves to state q thus labels of the form s t work in the same way as in m automata and the main here is the inclusion of s t a in order for the transition to be allowed the input name a must be fresh in the history and in the part of specified by a this addition allows us to model globally fresh transitions and also to combine automata unifying their initial assignments formally let q q × × be the set of configurations and define q × c a × q as follows for all q h q · if q q with c then q h q h · if q s t q s a and a t then q h a q h a · if q s t a q s a a t and a h a then q h a q h a reachability and acceptance are defined as before note that transition labels s t a satisfy s t moreover if s t and a then the transition can only be instantiated by a name a n a that has not yet appeared in the history but is still in some register lemma for any a of n registers there is an effectively b of n registers such that a b the other direction is a bit more elaborate and we achieve it in two steps let us say that an a is pure if for all transitions q s t a q of a s t and a n lemma for any a of n registers there is an effectively pure b of n registers such that a b lemma for any pure a of n registers there is an effectively b of n registers such that a b we can now establish the following closure properties closure under union and intersection is while closure under concatenation kleene star or complement fails proposition for a and b the languages la lb and la lb are proof assume a q q f a and b q q f b of n m registers respectively for the union construct an c q q f of n m registers where q f with q q q mapping q and q to q and being elsewhere the identity finally q q c q q q s mn t mn a q q s t a q q n sn n t n an q q s t a q where q q q and sn i n i s for each s and n it follows that lc la lb for the intersection construct an c q q f of n m registers where q q × q q q q f f × f and assuming a a q q c i iq iq i q s sn t tn a an q i iq si ti ai iq i it follows that lc la lb proposition there are a and b such that the language la lb is not moreover there is an a such that the language la is not finally there is an ra b such that the language a lb is not proof for the first part we show that the language l l l is not where l a suppose l were by an c of n registers so ss lc with s being a string of m distinct names let the following be the transition path in c accepting it q · · · q q · · · m qm with the from q to qm call it p accepting the second copy of s as all the symbols of s have already appeared before none of the s is of the form i moreover as all the symbols in s are distinct there cannot be i n and j j such that j i and j i as j would then repeat a name already present in the p moreover there cannot be i i n and j j j such that j i j and j for suppose this were the case and suppose that all s between j and j are not in i and that all s between j and j are not in i n then s with a a a corresponding to j j j respectively but is also allowed to accept a hence there is s such that lc lc l but now taking m n we obtain a contradiction the second part is shown in a similar manner taking as a the automaton accepting the language la aa ak a i j ai aj for some chosen a a similar argument to the above applies that is finally we have that l a la for a a with no fresh transitions from that we obtain b by applying lemma symbolic methods the automata we have introduced can be viewed in two different either as ordinary finitestate automata operating on constant symbols and the symbols · n for machines with n registers or as machines which languages from an alphabet a finite set of constants and an infinite set of names we use the term semantic level for the latter interpretation and symbolic level for the former one the semantic is of course the intended interpretation but on the other hand our automata as operating on the finite alphabet ln is much more convenient in this section we examine methods from the symbolic level which semantic notions more specifically we start by giving a simple proof of decidability of by reducing the problem to we then proceed to our main point of focus which is the definition of an appropriate notion of symbolic bisimilarity that is equivalent to the notion of bisimilarity we have been using thus far as a corollary we prove that bisimilarity is decidable for proposition the emptiness problem is decidable for proof given an a of n registers construct its closure a and take a to be the ordinary with the same set of states initial state transition relation and final states as a and operating on the set of labels ln we claim that la la indeed if a accepts a string s c a then the accepting path in a yields a string s ln and s la conversely if a accepts a string s then the accepting path in a is also a path in a ending in an accepting state from remark we have that the latter yields a string s la in order to define a symbolic notion of bisimulation equivalence which captures its analogue we introduce auxiliary structures which record the way in which two register assignments are related in particular they record the domains of the assignments and those indices on which the two assignments coincide a symbolic bisimulation between two automata relates states of the automata in specific record environments at each bisimulation step the records are updated according to the specific symbolic transitions taking place this symbolic description is shown to accurately capture what happens at the level we adapt notion of span we call s s pn × pn × n × pn a typed span on n n if · i j i j implies that i i j j · s where i n j j i · dom s where dom j n i j i we write n n for the set of typed on n n a perhaps more intuitive way to view a typed span s s is as a triple of relations s dom s by of notation we write for the whole of s s in which case we also use the notation s s and s s if n n and i j n × n then i j n n is the typed span si i j i ij j i j sj a typed span s s relates register assignments and just in case is a bijection between the parts of n and n that have common under and while si keeps track of the indices of all names in i formally if dom s i j i j in this case s s dom gives the total number of names in and suppose for example that we have related state q of automaton a to state q of a with respect to if q i q is a transition in a and i dom then the name in register i of a in the scenario captured by the symbolic description in register i of a consequently a can only simulate the transition by some q i q on the other hand if q q is a transition in a then there are several factors to consider · any private name of a can be captured by hence a needs a simulating transition q j q for every j s · moreover a needs a transition for all names locally fresh to both a and a this can be some q q but under it may also be some q j q in order for q j q to capture all names locally fresh to a and a it must be the case that all names in history are present in the registers of a and a so that global freshness coincide with mutual local freshness if a has n registers and a has n and assuming that the initial register assignments for a and a contain the same names the latter can only happen in case less than n n names appear in the history we can therefore resolve the latter case by adding a component which counts the names in the history up to n n in the following we write n for n n and set h h n h if h n and n otherwise definition let ai qi qi i i fi be of ni registers for i such that h a symbolic simulation on a and a is a relation r q × n × n n × q such that whenever q h q r if q f then q f and if q q then if c then q q for some q h q r if i and i dom then q i q for some q h q r if i and i s dom then q q for some q h i j q r if then for any j s q j q for some q h i j q r if and h n or some q h i j q r h then q q for if i then q q or q j q for some q h i j q r setting s s s s the inverse of r is r q h q q h q r we say that r is a symbolic bisimulation if both r and r are symbolic simulations we say that a and a are symbolic bisimilar written a s a if there is a symbolic bisimulation r on a and a such that q h q r with h h and in the following propositions let us assume the hypotheses of definition let us also write h for h h and n for n n proposition if r is a symbolic simulation on a and a then r q h q h q h q r h h n h is a simulation moreover if r is a symbolic bisimulation then r is a bisimulation proposition if a and a are closed and r is a simulation on a and a then r q h q q h q h r h h n qi i h reachable is a symbolic simulation moreover if r is a bisimulation then r is a symbolic bisimulation corollary bisimilarity is decidable for proof let ai qi qi i i fi be of ni registers for i choose a a a such that and form a a a and a a a now close these and obtain closed ai we have ai ai moreover by the previous propositions a a a s a and hence a a a s a as the symbolic bisimulations between a and a live in a space bounded relatively to q q n n we can search it for such relations hence is decidable automata for the calculus we briefly recall the definition of the calculus with early semantics and strong bisimulation we use the fixed set a of names for channel names and let p range over process constants the set of calculus processes is given as follows p q a bp ap p q p q pa where a b a and a a name binding is defined as usual b is bound in and bp and processes are up to equivalence we write for the set of names appearing free in p process constants are by definitions of the form pa p where a a and moreover each occurrence of p must be guarded ie it must come in one of the forms or the semantics of the calculus is early and is given via a labelled transition relation with labels ab labels have free and bound occurrences of names but they are not up to equivalence a b a fn b bn we write n for fn bn the transition relation is given by the following rules plus symmetric counterparts out p inp ac p cb m at c h p p a ap p p ab p rec pa p open p p bp p ab res p p ap ap an sum p p p q p p p q ab q comm p q p q par p p p q p q p p q ab q close p q bp q note how the impose global freshness on names created using the constructor bisimulation is the standard notion of equivalence in the calculus here we shall consider strong bisimulation a relation r × is called a simulation if for all p p r and all with bn p if p p then p p for some p p r r is called a bisimulation if both r and r are simulations we say that p and q are bisimilar written p q if there is a bisimulation r containing p q we now define a version of the calculus with extended syntax that is directly representable by since transitions are and our automata can one symbol at a time they will be decomposed to atomic ones we add sets of input and output processes which for the intermediate stages in these for example p to a bp b p where bp is an output process output resp input processes are in the middle of sending receiving a name on a chosen channel definition the xcalculus syntax is given by the sets out and inp with elements p q a bp ap p q p q pa bp p p bp p p where a b a and a a we write for out inp and let p q range over its elements which we up to equivalence name binding is defined as expected b is bound in bp and bp it is to introduce here some very basic notions from the theory of nominal sets we call nominal structure any struc ture which may contain names ie elements of a and we denote by the set of finite permutations on a ie a a such that a a for finitely many a a for example id a a a a we shall define for each set x of nominal structures of interest a function · × x x such that · · x · x and id · x x for all x x and x will be called a nominal set if all its elements involve finitely many names that is for all x x there is a finite set s a such that · x x whenever a sa a for example a is a nominal set with action · a a and so is with action · s a a s also any set of structures is a nominal set with trivial action · x x more interestingly if x is a nominal set then so is x with action · x xn · x · xn also if x is a nominal set then so is the set s n n x with action · f i · x i x f thus out inp are all nominal sets for example · ab ab where aa bb cc note that permutations equally affect bound and free name occurrences similarly to x we have that x × y is a nominal set whenever x and y are note that if x is a nominal set and x x is such that · x x for all x x and then x is also a nominal set with the inherited action hence the following set is a nominal set k p p we write k for the restriction of k to elements p with p finally from a nominal set x we can derive its set of ox ox x x where ox note that each ox is a nominal subset of x the technology of the previous is used for defining the transition system of the extended calculus in contrast to the ordinary calculus the transition relation we define is finitely branching and this is achieved by considering and specifying channels by their context indices instead of their names more specifically we let ok be the set of each such o p is written p since p · for any permutation what in p is not the specific names occurring in or p but only their index in for example a c ab a c ab and in essence both of these are specified by an expression eg like b notation from we build up on the indices idea and use transition labels of the form for fresh definition the semantics of the xcalculus is given via a labelled transition system with set of states ok and labels i i ij where i j the transition relation is given by the rules in table note that p p implies some further remarks on reduction · transitions restricted to use only and double labels ie from ij i j · inputs are decomposed as known inputs and locally fresh ones and are therefore finitely branching the impose that whenever p then i a a and i is the least index such that i similar and apply to bound outputs open · note that the close rule involves bound outputs hence globally fresh transitions on the output side on the input side it is then necessary to have a matching locally fresh transition global freshness implies local freshness example for each a a let a a and pa b with definition c in the calculus pa induces an transition graph pa p b pc · · · in the extended calculus pa induces the following transition graph a pa a b b c b pb · · · which is by branching once at each step in fact setting b b c and since a pa b pb and a b for all a b a the graph above contains just two nodes a pa hh a and using double labels we get simply a cc the way in which the two transition relations are related is given by the following lemma which verifies the of table lemma let be registers and be labels of and x respectively for all p p with · if p p then p p · if p p then p p where either and or i a j b and or i a j b and j j there is a straightforward from the xcalculus to states are taken from ok states from ok are final and the transition relation is the one given in table double transitions however the usual symbolic notion of between is not appropriate because it is defined for transitions and moreover does not take into account the distinction between inputs and outputs we therefore define the following notion definition a simulation is a relation r ok × n m × ok nm although not essential us from unnecessary branching note that this translation typically yields infinite but we shall examine classes of processes where the resulting are finite in the end of this section inp ia i bp m at c h p p a ap p sum p p p q p ia bp i p ab out ia i bp out ib bp i p a p a p res ap ap bp i b p i a i i a p open i i a p p ab p rec pa p par p p p q p q par p i b p p q j b p q q p p q ij q comm p q p q p b p q b q close p q bp q p i jj p p p p i p p p table the transition relation for the xcalculus symmetric counterparts of sum par comm close omitted such that if p p r then and p p implies that p p for some p p r such that one of the following is the case with i dom · and · ij j dom ij and · ij j dom and j k · j k and for all k s p ik p for some p j k p r · j dom ij and · ik and j k r is called a bisimulation if both r and r are simulations we say that p and p are written p x p if there is a bisimulation r containing p p for some with proposition for all p q p q iff p x q proof the proof proceeds by showing that if r is a simulation for the calculus then r p p p p r is a simulation for x and conversely if r is a simulation for the xcalculus then r p p p p r is a simulation for note that the set of of a given is in general infinite the following result provides sufficient conditions note v v v vi v i v for such infinite behaviours we say that a process has finite control if no parallel compositions appear in its recursive definitions a process is strict if all its of the form ap satisfy a also q is a descendant of p if there is a series of transitions from p to q proposition if p has finite control and all its descendants are strict then there is some and a finite s ok such that for all p s if p p then p s and p s proof suppose that p invokes definitions pi i n for some n and take m p × max pi i n for the size function which counts a process occurrences of s ps and names free or bound but not binding eg p p ap p pa a and if q is a descendant of p then q m as a process may only increase its size by recursion and as p has finite control cannot obtain size greater than max pi i n but then because all descendants of p are strict their number of abstractions is bounded by m and hence they all have length number of symbols or constructors bounded relatively to m they are still many due to different choices of free variables but since each descendant can be matched with a context from the number of the resulting is bounded relatively to m we collect all these in s corollary bisimilarity is decidable in when restricted to processes with finite control proof for any such processes p p by the previous proposition and after processes up to nonstrict abstractions we obtain graphs with sizes bounded relatively to p and p clearly p x p iff there is a bisimulation in x between those graphs as those bisimulations live in a space bounded relatively to the sizes of p and p we can search it for such relations processes up to structural congruence the above results can be further to processes with finite degree of parallelism in a similar manner to further directions we have introduced an abstract computational paradigm and established its key properties the ground for further research the next logical step is to examine concrete applications of to the description of computation with names either in the direction of mobile calculi or that of programming languages relating this approach to existing higherlevel approaches a first such advance has been recently accomplished in by constructing a model of a restriction of reduced ml a fragment of ml with integer references representable in a variant of where labels contain store information this was achieved by representing the fully abstract game semantics of the language on the foundational side the study of the calculus in that there is a notion of polarity inherent in computation with names in particular the examined do not mix locally with globally fresh transitions and this is clearly depicted in the partition inp out a similar observation applies to describing reduced ml there the states are partitioned in for and for only are allowed to perform globally fresh transitions and only can do locally fresh ones intuitively the only notion of freshness that can be observed on the programs side is local freshness whereas the environment should be assumed to have the memory needed in order to observe global freshness these observations suggest that a notion of where states are partitioned as above is relevant and should be further in the setting symbolic bisimulations are simplified as there is no longer need for an h component cf definitions and a potential towards concerns the fact that they fail to satisfy closure under concatenation and kleene star cf section we find these results rather expected as are machines on the other hand seem to be closed under the nominal versions of concatenation and kleene star as recently introduced by and the precise connections between and regular languages with are the subject of research finally some important questions have still not been for example we have not considered deterministic versions of nor examined whether can be assuming that in a deterministic to each input string corresponds a unique path we can see that eg the accepting the language l a · · · a a ak i j ai aj has no deterministic equivalent other directions for further research concern of recently examined for and the evident connections to moreover several possible extensions of are of interest eg variants with labels data words stores or pushdown variants acknowledgements thanks to abramsky and for discussions and suggestions thanks also to the anonymous reviewers for their comments section in particular is now much simpler due to a reviewers a proofs from section proof of lemma let a q q f the construction of b q q f follows closely in particular each transition of a involving a name induces an assignment of that name in the extra register of b if the transition were a fresh assignment then this would result in the name occurring in b just once after assignment otherwise it would occur twice as the actual extra register of b changes during this process we add an extra component in states to remember it we set q q × n n and write elements of q f as q moreover q q id q q f finally n and q q c q q q n i n q q i q q n n q q q q n n n q q i q where q q and i n we write k j for the permutation that k and j we can show that the following relation is a bisimulation and therefore that a b r q h q h i n i i proof of lemma let a q q f and construct b q q f as follows the idea is to keep in the extra memory registers of b a copy of the initial configuration which is never by assignments thus whenever a wants to make a transition with label s t a b will simulate it by a transition s s n and transitions of the form s t ta where ta n n a n a and a is not in the history in order to this we need to states with information regarding whether the names in appear in the history therefore we set q q × q q f q i q f and q i q i c q q q i s t q i q s t q q i s t ta q i a q s t q q i s s n q i q s s a q q i s t ta q i a q s t a q where a ta n i n i a a n a i and ta as ta we can check that r q h q i h i is a bisimulation and therefore that a b proof of lemma let a q q f and construct b q q f by setting q q × n n and selecting f set q such that q f f q f q and f and f moreover q f q f c q q q f i q f f t s i q s t q q f i q f f i s q s s q q f q f f i s q s s q q f i q f f i s q s s n q with f f s i now the following is a bisimulation r q h q f h f and hence a b b proofs from section proof of proposition it will suffice to check only transitions so let q h q h r due to some q h q r and suppose that q h a q h with h h a we do case analysis on a below we write for i j · a say a i j then it is necessary that q i q and also implies i j so q j q for some q h q r thus q h a q h and noting that h h so h h n we can see that q h q h r · a say a i then again q i q and but i s dom thus q q for some q h q r thus q h a q h j a noting that and h h we have that q h q h r · a say a j since a h we have some q q and i a moreover j s and therefore q j q for some q h q r thus q h a q h and we can see that q h q h r · a h so q q and i a if h n then h h thus q q for some q h q r and so q h a q h j a we have and h h n thus q h q h r · a h and say transition is due to q q so i a then q q for some q h q r so q h a q h j a we have that h h n so q h q h r thus r is a simulation if r is a symbolic bisimulation then by symmetry r is a bisimulation finally if q h q r then q q r proof of proposition we check transitions let q h q r due to some q h q h r and suppose that q q we do case analysis on below we write h for h a and for i j · if i then by closure q h a q h with a q i h and hence q q h h r if a q h i dom say for i j some then a and it must be q j q we can see that q h q r if i s dom then a and there is some q q and j a we have that q h q r · if then for each a q h a q h i a and therefore q h q h for some q h q h r a for any j s j so we can take a j then we must have q j q and we can check that q h q r if h n or h then we can choose a h thus we have some q q j a noting that h h and we get q h q r finally if we choose a h then there is some q q and j a we have that and h h a thus h h n hence q h q r · if i then we work as in the last case above thus r is a symbolic simulation if r is a bisimulation then by symmetry r is a symbolic bisimulation finally if q q r then q h q r references s abramsky d r a s ch l and i d b nominal games and full abstraction for the in proc of lics pages ­ ieee comp press m c and g minimal memory automata workshop on foundations of databases n benton and v a mechanized bisimulation for the tech rep microsoft research r f m and m modeling fresh names in the picalculus using abstractions in proc of volume pages ­ s s and m symbolic bisimulation for the applied pi calculus in proc of volume of lncs pages ­ s and r ltl with the quantifier and register automata acm trans comput log g l u and e model checking for nominal calculi in proc of volume of lncs pages ­ m and a m pitts a new approach to abstract syntax with variable binding formal comput ­ m j and v freshness and in sets of traces with names submitted for publication a jeffrey and j towards a theory of bisimulation for local names in lics pages ­ m and n automata theor comput sci ­ j a game semantics of local names and good variables in proc of volume of lncs pages ­ j a fully abstract trace semantics for general references in proc of icalp volume of lncs pages ­ r milner j and d walker a calculus of mobile processes i and ii inf comput ­ r milner m tofte and d macqueen the definition of standard ml mit press u and m an introduction to history dependent automata notes theor comput sci u and m structured coalgebras and minimal for the picalculus theor comput sci ­ a s and n full abstraction for reduced ml in proc of volume of lncs pages ­ a s and n algorithmic nominal game semantics submitted for publication r m names in s editor distributed systems pages ­ acm nd edition f t and v finite state machines for strings over infinite alphabets acm trans comput logic ­ m history dependent automata phd thesis university of a m pitts nominal logic a first order theory of names and binding inf comput ­ a m pitts and i observable properties of higher order functions that dynamically create local names or new in proc of number in lncs pages ­ h and d of decision problems for automata theor comput sci ­ d sangiorgi and d walker the picalculus a theory of mobile processes cambridge university press l automata and logics for words and trees over an infinite alphabet in proc of csl vol of lncs pages ­ i names and higherorder functions phd thesis university of cambridge 