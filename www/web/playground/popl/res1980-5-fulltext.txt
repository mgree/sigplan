analysis of simple programs over different sets of primitives extended abstract a j department of mathematics boston university boston ma it is well known that most questions of interest about the behavior halting optimization and other on the other or all of these questions decidable by introducing appropriate restrictions under consideration and once such restrictions are made the next step these problems for programming languages for which they are decidable of as hand it is possible on the programming is to ask how hard it equivalence to make some language is to solve this analysis muchnick who from the language general here instead we of programming languages has been by choose to restrict their programs to operate over of as defined by meyer and operations unlike jones and muchnick we do primarily restrict our attention to others in particular by jones and finite memory our approach starts in which we in fact allow more not place any restriction on memory without nested loops i background a p program is a finite sequence of statements of two kinds tions which may in turn be of three different types first kind are the assignment xo xy x where x and y may be replaced which are of the form by the names of any the second kind are the loop statements loop x a end where the instructions x and end always come in pairs matched like left and and where a is any finite block of statements not variable x on the lefthand instruction by k variables as input variables and exactly put a loop is made to define a computable function from be found in right parentheses side of any as one variable as out further details may ln is then defined are nested up to a depth of n l does not contain to be the class of loop programs whose loop any and l contains no nested loops statements corresponding to ln is the n of functions computable by loop programs in lc in it is shown that the family n defines a hierarchy in that all primitive recursive functions following and c we shall and the class d the class of simple functions the functions which proper y include the computable time call the class l the class of simple pro class is the class of socalled elementary functions ie computable in polynomial e l s or copies are to prior a a fee andor specific permission © acm acm our primary but not exclusive concern in the present report is the analysis of the class l of simple programs mainly because nontrivial questions about the behavior of programs in ln for n are recursively undecidable and in order to go beyond the work of our loop will use more general instructions then those mentioned earlier in this section ii different bases of primitive statements we consider therefore extending the language tive structure unchanged but we allow other above primitive assignment statements equivalent arithmetic operations type of assignment of loop programs in the following way we leave their types of assignment statements in addition to the three in loop programs will now be of the following each of which being later used to abbreviate the corresponding xo o the zero xy id the identity succ operator x pred the successor x the predecessor max x z min xyz xyz i where x y may be replaced and pred are used eg to macro if x and y are distinct by the names of any variables note how the operators succ pred a statement of the form x will not be primitive as opposed variables we shall require that if a statement of the form x or x appears inside a loop end pair then variable y cannot be mentioned on the lefthand side of any assignment statement inside the pair in without this restriction assignment type is equivalent to type and type equivalent to type other possible primitive its abbreviation statements will be conditional statements taken in the form if xo then al else a ifthenelse where x is any variable and al and a are finite blocks of already defined statements a base over which loop programs may be written ie then defined to be any subset of the primitive statements just listed the corresponding class of loop programs with of depth s n is de noted by l and the class of functions they compute by thus if o id which is the assignment statements over which loop programs we originally considered by meyer and we then have that nw nl for all n and fi is the class of elementary functions moreover the equivalence problem lo d l are decidable of la n for n is undecidable whereas the equivalence problems for we mainly consider statements one of our particular we examine here aims the is to study ll of simple programs how changes in b affect over different the analysis bases of programs of primitive in lin the equivalence problems decision procedure involved of the classes lw for different ss and the difficulty of the questions of of the involved between different classes ll for different ds and the in these objective we discover of any program can be bounded above from its syntax assigned to programs in a natural manner that for come of these classes andor mathematical expressions the run can be uniformly by considering loop programs over different bases of primitive statements as explained above some of the issues raised here will be similar to those raised by and in except that they were dealing with programming languages in general whereas our particular focus is on classes of programs computing functions for which many of the problems are able and sometimes easily so iii results let l and l be classes of and tions they compute we say that l is effectively is a constructive way to obtain a program p g l classes func into l if for every program p e l there such that p and p compute the same function if there is in addition is a translation from l to l we shall use the notation l l effective we shall write l l where the may be replaced e according to whether the translation is the trivial map or produces which is of length at most linear polynomial or in the length and if the translation by c ti p r a program p e l of the original p e l a few comments are in order about the involved take size order whenever one of our translation procedures at meet linear or polynomial or exponential of the source program p of course the time less than that of the ie the object is q or p or e it time respectively but not complexity of a translation program p it writes out also happens that a function procedure cannot it will of the be of although we do not have optimality proofs for is no room for improvement on their from to linear in particular the nature of the programming that the translations labeled e cannot be replaced by will be in a subsequent report our translation procedures it seems that there exponential to polynomial and from polynomial languages considered in theorem below suggests equivalent polynomial translations this question n important to the sizes question which we have not investigated is to also of an original program c l and its translated version compare the run times p e l in ad clearly necessarily the implies l l is equivalent to the assertion c the opposite implication is not always but while l l some results are trivial eg if n n and others are by no means obvious and we list some of them next then ln ln theorem let b be any subset of c ifthenelse then for all n where the degree of the polynomial translation depends on and never that is for of depth or more the computational power of p sensitive to the addition of primitive statements other keep in mind the kind of additional primitive statements than x o and x we allow here eg using it is theorem we can easily show that if were allowed to include assignment instructions of the the theorem would no longer be true becomes in important to in x y x z then the situation is quite different for of depth let ml and ti be nonempty subsets of ifthenelse then where the of the polynomial w t translations depend on and but never l let and to be subsets of can be read off the following all diagram possible translations from e p n p ifthenelse n i ifthenelse id if an omitted arrow in the above diagram then it is a case of cannot which be obtained by composition also requires some proof from the arrows already drawn one conclusion of the preceding theorem is that in the equivalent features in that they add the same the case absence of loops where id does not add to ifthenelse does as seen from the next result presence of loops id computational power to the computational power and ifthenelse are this ie not of programs while theorem lo t n lo q o in ti ifthenelse in t ifthenelse ifthenelse again here if an omitted arrow is a case of is not by composition from the arrows in the diagram then it iv of some classes let fl f be from fl f will be denoted functions by ff the class l of all functions obtained through for the next theorem we need to define special functions on u lk and w xn o ux xn xi n integer division of x by constant k wx xl o o composition we have the following algebraic i proving the sets on the righthand is an easy programming exercise proving which consists in finding for every loop from the set on the righthand side side are included in the corresponding the opposite is the difficult program of the kind under consideration sets on the lefthand side part of the theorem a function it computes by theorem or by characterization expressed as obtained by ifthenelse in above may be replaced id also these three should be compared with the in proving the of which can be where remainder upon x by constant k for part of the next theorem we need to make the following restriction all assignment included in a base w as primitive statements can each be executed in one time unit all other statements statements are macros and the time cost the primitives furthermore of each is the time required to execute a macro definition if conditionals if xo then a else a are also primitive for it in terms of then the time re to execute each one of them the cost for xo of the two is executed of al or on which let us say a a that f k is linear ail ll r c q the function ae linear xi in xi i s k if for all sets of con is linear respect ae linear theorem we have the following alternative is ae linear in each of its variables all functions computable in linear time but properly is not equal includes it to the set of all functions f such that f is linear in each of its variables for the next the result holds even if in particular instructions the restriction introduced we do not assign a uniform of the form x for the cost of may be preceding one time assigned theorem unit to arbitrary may be lifted that is every primitive statement costs of polynomial order theorem let be a subset of functions computable time where the time complexity of function may be measured related to loop programs over the primitives on any other model of computation under consideration then which is poly v decision procedures using theorems characteristic and and the fact that predicate function is elementary the following result is immediate is elementary ie its let be any subset of all n the equivalence problem of is recursively theorem p is equivalent is let p p c and and pi to p is solvable solvable in linear in time proportional time be the to ip respective lengths of p and p that is the equivalence then for then whether problem of theorem the equivalence problem reduction to a problem of establishing of the is solvable in exponential of linear forms over time proved by in light of the next result it does not seem that we can cut the time complexity procedure in the preceding theorem down to polynomial order of the decision theorem the problem of is nphard satisfiability problem to the problem considered here proved by reducing the theorem the equivalence problem of and thus by theorem and that of exponential in the time required to arithmetic by the decision procedure for presburger arithmetic that each solvable proved of in time by reduction the best known bound for a decision of the procedure in theorem is procedure of presburger arithmetic the time complexity although a similar then it this complexity makes the decision procedure result in the next result cannot be improved by more than one additional shows that exponential it improves by one exponential if this bound can be improved level level further theorem the problem of deciding equivalence problem of iv the truth of presburger proved by using formulas is reducible to the the characterization of part in theorem meyer and the complexity of loop p proc nd nat conference acm the equivalence problem of simple programs jacm pp and jacm pp programming languages part efficiency and p structure jones and muchnick even simple programs are hard to analyze acm symposium record p jacm pp also nd simple programs realize exactly presburger formulas siam j comp dec no 