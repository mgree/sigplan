dependent information flow types and laboratory for computer science and de e de abstract in this paper we develop a novel notion of dependent information flow types dependent information flow types fit within the standard framework of dependent type theory but unlike usual dependent types allow the security level of a type rather than just the structural data type itself to depend on runtime values our dependent function and dependent sum information flow types provide a direct natural and elegant way to express and enforce fine security policies on programs including programs that manipulate structured data types in which the security level of a structure field may depend on values dynamically stored in other fields still considered a challenge to security enforcement in software systems such as applications we base our development on the very general setting of a minimal calculus with references and collections we illustrate its expressiveness showing how secure operations on relevant scenarios can be modelled and using our dependent information flow type system which is also shown to be amenable to algorithmic type checking our main results include and noninterference theorems ensuring that welltyped programs do not violate security policies categories and subject descriptors d programming languages language constructs and features d operating systems security and protection ­ information flow f logics and meanings of programs type structure keywords information flow dependent type systems introduction among the main challenges currently to software development one finds security enforcement particularly relevant for the construction of applications to be made available on the web or on mobile computing environments many reported security leaks in globally used information systems including email management or network systems turn out in many cases to result from programming errors introducing information flows in complex and heterogeneous software layers a relevant research issue consists on finding improved techniques to ensure confidentiality in the presence of and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm container sharing as eg when logically different security are not statically mapped to different physical or data structure but are instead dynamic and dependent on runtime data including on configuration parameters in this paper we develop the notion of dependent information flow types dependent information flow types provide a direct natural and elegant way to express and statically enforce fine security policies on programs including programs that manipulate structured data types in which the security level of a structure field may depend on values dynamically stored in other fields still considered a challenge to security enforcement in software systems such as applications in standard information flow type systems a type has the form s where the structural type is tagged with a security label s an element of a security lattice modelling an hierarchy of security or levels for example one defines int int as the type of a low security function that maps a high security integer to a high security integer however as already suggested it is often the case that the security level of data values depends on the manipulated data itself such dependencies are obviously not expressible by such basic security labelling approaches the key idea behind dependent information flow types is fairly simple we propose to extend dependent types in such a way that not only the structural type assigned to a computation may depend on values but also its security level expressed by associating to a data type a value dependent security label instead of a plain security label as described above to achieve this goal we present in this paper a novel theory of dependent information flow types within the framework of dependent type theory including sum and function dependent types to capture the general essence of value dependent security classification a simple example of a dependent function information flow type is one could assign such a type to the function that given a user name a string returns its password a string although the security level of user pat is public password itself belongs to the security level where is a value dependent security label for another simple example consider the following dependent labeled product information flow type uid string × this would type records in which the security level of field depends on the actual value assigned to the uid field value dependent security labels such as denote concrete security levels in the given security lattice along standard lines but allow security levels to be indexed by program values useful to express security constraints to depend on dynamically determined data values in such a setting we would expect the security levels and to be incomparable thus avoiding mation flows between the associated security representing the private knowledge of users and pat respectively in particular the security level of the password returned by the call is rather than say just which in our setting could be denoted by the label representing the security level of the information available from any user thus dependent types together with value indexed security labels allows secure computations to be expressed with extra precision other key feature of our type system is the way it allows us to capture general security constraints within data structures containing elements classified at different security levels as necessary to represent eg realistic rich security policies on structured documents or databases typically it is required to select and compose such structure elements during computations while enforcing all the intended information flow policies for example consider a global password file users modelled by a collection eg a list of records of dependent type the type assigned to such a collection would be users uid string × notice that s is the type of collections lists of values of type s then consider the following function let u foreach x in users with do if u then else the function extracts from the global data structure users the collection of associated to a user id the foreach iterator is a familiar functional collection fold combinator x is the current and denotes the value from previous iteration with initial value notice that although the collection users contains classified in different security levels the security level of the collection returned by the function is always with u the user id string passed as argument then the following typing holds we base our development on a minimal calculus with records general imperative references and collections although extremely we show that our programming language and its dependent information flow type system is already quite expressive allowing practically relevant scenarios to be modelled and against natural value dependent information flow policies although a substantial level of simplicity our type system relevant technical challenges necessary to handle classified data structures and security level dependency as in classical approaches eg both a type and a security label s are assigned to expressions by our typing judgment r s e s the fact that the value of e does not depend on data classified with security levels above s or incomparable with s where s is in general a value dependent label the analysis of implicit flows is also particularly interesting in our setting even if we adopt standard techniques to track the computational context security level r the program counter the additional component s represents a set of the equational constraints used to refine label indices and establish type equality we the contributions of this paper first we introduce and develop a typebased information flow analysis for a calculus with references and collections we build on a new notion of dependent information flow types developed along the lines of a standard dependent type theory but where the security level not just the structure of data types may depend on values section second we illustrate the expressiveness of our language and analysis using several examples section third we present our main technical results type safety preservation and progress theorems and and a noninterference theorem which together imply that welltyped programs do not break data confidentiality according to the security policies by dependent information flow types section after discussing algorithmic type checking section we overview key related work section and offer some remarks section dependent information flow types in this section we dependent function and sum information flow types by means of several examples providing an informal overview of the approach developed in the paper as in any information flow analysis we are concerned about flows that might arise during the execution of a program but not with how data is accessed which concerns access control our analysis associates security levels s to types to classify expressions e so typing an expression at security level s denoted e s means that data used or computed by expression e will only be affected by data classified at security levels up to s we proceed by our programming language a simple calculus with references using as example a typical data web application a conference manager in this scenario a user of the system can be either a user an author user or a pc member user the system stores data concerning its users information their and the of in database tables which we will represent in our core programming language as lists of references to records eg mutable lists as shown in figure d for the types declared in figure a users stores information for each user keeps track of each in the system by storing its id the authors id and the contents of the and stores information regarding the evaluation of each namely the id of the pc member the the id of the the comments for the other pc members and the comments and to be to the author the system offers operations to add new data as well as some listing operations we some of them example operation assigns a pc member to review a given the remaining fields let u s review in example operation iterates the collection to build a list of all records with a given author id let in with y do let tuple x in if then else y example operation simulates a join operation between collections and to obtain the list of assigned to the pc member with the given id let foreach x in with do let x in if then in with do let y in if then else else a def uid int × name str × univ str × email str a def uid int × int × title str × abs str int a def uid int × int × review str × int a purely structural types not expressing security levels b def uid × name u × univ u × email u b def uid × × title a × abs a × paper a b def uid × × pc × review a × a b standard security types for information flow eg we omit base types c def uid × name × univ email c def uid × × title abs × paper c def uid × × review a × a c dependent information flow types let users in let in let d declaration of mutable collections of mutable records replace · with a b or c for according type figure expressing security policies the foreach primitive computes the value of a lists elements for instance in count do count returns the number of of author with id our goal is to statically ensure by typing the confidentiality of the data stored in the conference manager system as in classical approaches eg both a type and a security label s are assigned to expressions by our typing judgment e s expressing the fact that the value of e will only be affected by computations at security levels s as is usual in information flow analysis a partial order the socalled security lattice relating security levels is defined and information is only allowed to flow in the order for the purpose of static code analysis the given security lattice could be declared as a to the code to be checked to specify security policies for our system we thus classify the data manipulated by our conference manager with security levels from a suitable security lattice data types when not necessary for simplicity we assume security lattices are bounded by a top and bottom element denoting the most restrictive no one can observe and most permissive public data can observe security levels respectively for the conference manager we can then specify say that information is classified in three additional security levels u for the data that can be to any user a for data observable to authors and pc for data that only members can see in such simple case we may let and specify the according security policy for each conference manager entity as shown in figure d for the types declared in figure b such policy states that a users information is observable from security level u meaning any user including authors and pc members can see it that the content of a paper can be seen by authors and finally regarding a review we have that comments to the pc are observable only to its members and and of the can be seen by authors this policy however is not precise enough to protect the confidentiality of the data an author who has at least the security level a is able to execute the operation example using a different id than his own which clearly violates confidentiality thus the security policy that we need is the following a users information is only observable by the content of a paper can be seen by its author as well as its reviewers and regarding a review we have that comments to the pc can only be observable to the other members that are also reviewers of the and that comments and of the can be seen by its author only to express these kind of policies and make sure that operations that depend on them are secure according to the given policies such as the operation illustrated above we introduce a general notion of dependent information flow type which builds on the notion of indexed security label using indexed security labels we may partition security levels by indexing labels with values v so that each partition v classify data at a specific level depending on the value v for example we can partition the security level u into n security each representing a single user of the system so security level u represents the security of the user with id of course one may also consider indexed labels of arbitrary arity for instance for security level a author we can index with both the authors id and id so a would stand for the security of data relating to author with id and his with id going back to our example we assume the following defined security levels for users with id uid for author of with id and whose user id is uid and for pc members assigned to review with id and whose user id is uid in general the security lattice is required to enforce v u w v w and v w v u w for all u v and w so eg for all uid we have u u we can see u as the approximation from above of any eg for the standard label u figure b levels a and pc stand for the security accessible to any author and any pc member respectively but a and pc respectively represent the containing the information of all authors and all pc members level stands for users with id uid that are authors a represents the security of authors of with id means a author with no authority over submitted papers and so on we define the declarations in figure d for the types declared in figure c and the partial order defining the sample security lattice by the following axioms quantifiers ranging over natural numbers we proceed our motivation of dependent information flow types with a series of code relevant for our conference manager scenario consider then the following code example let t in with y do let x in if and then else y in in with y do let x in if and then let in x in this example is a mutable collection of references of type c figure c the type c is a dependent sum type where the security level of some fields depends on the actual values bound to other fields as already explained in the introduction for example notice that the security level of the title field is declared as where uid and are other fields of the thus dependent record type also t gets security level a since we are a record with uid value and value to type the record the reference we need to obtain type which in turn needs to check the type of expression t for field title but since we know t has security level a and that and so fields uid and have value and respectively in we can secure the assignment on the other hand if we change the last conditional to be if then we would be to associate data of security level a value t within the security a for author with uid so in other words data from author s is being associated to of author an illegal flow of information for brevity as in the example above when writing new record values based on existing ones we just mention the fields being assigned a new value and a sample field indicating the record value from which the other values are to be copied for example in we mean that fields abs and paper are just copied from as eg etc consider now the following code fragment foreach x in with y do let x in if then uid title else y the result of evaluating this program is a collection of records of sum type resulting from part of records of type c the expected type given the definition of c is uid × × title however our type system can track value dependencies and constraints imposed by programs so a more precise type is assigned in this case namely uid × × title such ability to track dependencies is crucial to fine security policies for instance in order to check if pc member with id could observe the result of the above operation we need to establish that which would not be possible had we approximated the field with let us consider the following code for a function let in users with y do let x in if then else y function returns a collection of records of dependent sum type whose security labels on fields title abs and paper depend on the value of the parameter a precise typing for is notice that the return type depends on the value of the function argument so the type of is a functional dependent type then the expression has type u example the operation is used by the pc members to add comments to the types ensure that only pc members assigned to the particular paper will see such comments let foreach p in with do if then in with do let y in if then let in y function has type where type c is × example since there is no dependency not free in c we may abbreviate the functional type by int c thus identifier p has type c function comment returns a given papers pc comments and has type notice that its return type in the call has security label additionally we know has the type of the collections references type c of figure c so in order to type check the assignment expression y we need to check that has the same type as the type for the collections elements type c namely we have to check if has type as we said the type for has security label but since it has field dependencies we need to infer values for them in this case we cannot infer a value for field uid so we approximate to obtaining a however because we know by the conditional that we can index the security level by field instead which allows us to type the assignment operation since field is bounded by the dependent sum type of the record being used for the assignment then we can type with type a and thus due to a pc we can with notice that this is only possible to pc members assigned to the paper whose is so only those pc members will be able to see the added comment so we can finally type the record with the dependent sum type uid we refer back to this example in example where we detail the relevant steps taken by the system to typecheck the program without dependent types we would lose precision in the typing of obtaining a instead and not be able to raise the security level to the required level thus would not type check despite being secure after introducing our core language and dependent information flow types we now formally introduce its syntax and semantics e em let x e in e ee if c then e else e m e e ee e e e e e x v expression field access let application conditional record collection cons iteration reference assign deref identifier value v v m v x se true false l values collection record abstraction true false unit locations c v c c v v v v m v x se true false x vm conditions negation disjunction equality term terms collection record abstraction true false identifier unit field access figure syntax expressions values conditions terms core language our core language figure is a higherorder functional language with references and primitive collections primitive values v include abstractions booleans records collections lists of values also present in languages such as and locations we consider two values v u equal v u when they are the same up to reordering of record labels and assume intensional equality on lambda abstractions expressions e include conditional application field access cons operator to add an element to a collection collection iterator values variables locations references dereference and assignment these primitives are to be understood as usual namely the collection iterator foreach computes the value of a lists elements as showed in the examples of section for readability purposes we sometimes use the more natural concrete syntax adopted in the previous section we assume other basic data types integers strings and associated operations such as first and rest for collections but omit standard details to illustrate primitive types we will usually include just booleans in our formal presentation as for abbreviations we use an to represented indexed sets of syntactic elements concretely m e stands for me and e stands for e en logical conditions c are used in conditionals which we require to be pure sideeffect free we also consider terms v used in conditions eg terms are values that may be checked for equality pure expressions are those sideeffect free in concrete all expressions except assignment reference expressions and programs in our language are closed expressions the operational semantics is defined using a reduction relation defined by the rules in figure which basically extend the standard ones for a callbyvalue calculus reduction is defined between configurations of the form s e where s is a store and e is an expression a reduction step of the form s e s e states that expression e under state s in one computational step to expression e under state s a store s is a mapping from locations to values reduction rules follow lines we briefly comment on the less standard ones rules and reduce the first and second expressions of the list iterator operator respectively these rules together with rule foreach imply an evaluation order from left to right evaluation of store independent logical conditions is given by the map c c true false using an auxiliary evaluation map for closed terms t v v defined as expected see for more details type system as already discussed above our type system for information flow builds on fairly traditional concepts from information flow type systems but a notion of type dependency on security labels in a way that within a standard framework of dependent type theory with canonical dependent functional and sum types we assume a security approach that information into security according to some given security lattice and users access to data according to the security they as in typical type based information flow analyses types are annotated with a security label in our system we consider value dependent security labels v so our types take the form s where is a data type and s is a indexed security label v labels may be represented by if an expression e is assigned type s then the system must ensure that only users with enough permissions to read information at security level s have access to the value computed by e otherwise the result of e is assumed to be opaque and thus cannot be observed by such an user as for the attacker model we assume an attacker can observe information including stored data that has security level public and may be a user of the system so interaction with the system is possible using the core language we show here this view is extended to any given security level so that with access to data classified at security level s can only observe information classified up to s security labels and security lattice security labels which we consider in general to be value dependent have the form v where v is a list of security label label are given by v true v xm m label top true collection field selection field identifier false m v x bot false record variable we call concrete a security label if all of its is or a value v not a record field identifier m or a variable x as made clear below labels indexed by a simple field identifier eg m only make sense in the scope of a field m in a dependent sum type we consider a general notion of security lattice we require the lattice l elements to be concrete security labels with the top element the most restrictive security level and the bottom element the most permissive security level and denote the join and meet operations respectively the lattice partial order is noted and its strict part we write ss to assert that neither s s nor s s as suggested above dependent security labels and are interpreted as approximations to the standard dependent label we thus require that for any values v vn that make the label v vn concrete v vn holds in the given security lattice app s e s e s ee s ee s e s e s x s ee s x s ee s x s ev s cc c s e s e l doms s if c then e else e s e s if c then e else e s e s e s ref s e s ref s v s l v l assign s e s e s e e s e e s e s e s l e s l e l doms s l v sl v s e s e s e s e deref sl v s l s v s e s e s e s e s e s e s e s e foreach vl s v s s foreach v s v s e s e s let x e in e s let x e in e s let x v in e s s mv m s v record s e s e s me s me list s e s e s e s e s e s e s em s e m s e s e s ee s ee s e s e s ve s ve cons s vv vn s v v vn figure reduction s r t q s s v x sr qt m sr s ref st security label bool type dependent function type dependent sum type collection type reference type command type figure types l and that the ordering between labels is well defined and satisfies the lattice property ie well defined meets and joins etc we assume that the intended lattice required for each particular security analysis is specified by a list of assertions of the form x u v where the optional x may occur in u v we already gave examples of lattice assertions in section types the type structure figure includes boolean unit or command reference dependent sum dependent function and collection types in collection type s each collection element has type s we assume other basic types such as integers and strings with their associated operations not for the sake of simplicity but used in examples dependent sum types and dependent functional types assume a key role in our type system as they allows us to express runtime value dependency on security labels as already a dependent sum type has the form ms × × t where any of the security labels si with i may be dependent on previous fields via the field identifier for instance the type uid × is a dependent sum type where field name has the value dependent security level which is indexed by the runtime value in field uid a dependent functional type has the general form x sr qt where the security level of the codomain type q may depend on the value of the argument denoted by the bound variable x level r specifies a lower bound on the security level of the function effects writes if omitted it is assumed to be when x does not occur free in q we write s r qt for the type above or simply if r is notice that in source types and programs security labels may only occur in the context of dependent sum types and dependent functional types also even if types for collections are due to the presence of dependent sum types the system collections of elements containing data in different possibly incomparable security dependencies in security labels as stated earlier and for nat reasons the security lattice only relates concrete labels as such at some points our type system is required to approximate runtime values to eliminate dependencies occurring in security la for example should we project field name of a record typed with uid × name then we would need to eliminate the field dependency in the resulting types security la into either users if the actual name s can be from the computational context as is often the case or at least by user it may also be necessary to capture value dependencies in security labels eg if we declare a reference of type uid × name and then with a record with type uid × name user then we would need to introduce the field dependency in user we achieve such introduction and elimination of dependencies in security labels by tracking knowledge regarding dependencies in a constraint set s carried along in typing judgements using a equational theory to runtime values or dependencies depending whether we are eliminating or capturing dependencies in security labels a form s e is e a finite set of equational constraints of the are pure without sideeffects expressions we assume a decidable sound equational data such as booleans integers records theory about etc and write s e s v s ss s s s s v i t t m st m s t s s q q r r x sr qt x s r q t figure key subtyping rules we also the sense e as for purpose of this work we consider constraint solving issues inside a subject to the mentioned general requirements we do not specify any particular equational theory since its precise formulation is orthogonal to our analysis as long as it is decidable and sound the more complete the theory the better typing judgements and rules a typing judgment has the form r s e s it asserts that expression e has type s under typing environment given constraints s the label s states that the value of expression e does not depend on data classified with security levels above s or incomparable with s as expected from typebased approaches to information flow analysis our type system ensures that information only flows the security lattice eg only from a level l to a level h such that l h label r is concrete and expresses the security level of the computational context cf the program counter a familiar technique to prevent implicit flows typing declarations assign types to identifiers x s and types to locations l s a typing environment is a list of typing declarations in figure we show the typing rules the system also relies on a simple subtyping relation denoted which allows of security labels defined in figure rules rely on the lattice order where we consider s s to be an instance of a lattice assertion in rule we assume not to be dependent type we also define wellformed types and wellformedness definition of typing contexts denoted as as wellformed types are denoted by judgment n s stating that type s is wellformed under typing context given names set n the full set of rules defining wellformed types can be found in we avoid on typing rules standard for any typed calculus and focus on key typing rules specific to our system for simplicity and we consider in our presentation that security labels are indexed by a single label index assuming the obvious extension of type rules to deal with labels with multiple when necessary eg in examples in rule we require the security label of record values to be at most the greatest lower bound of all the security labels occurring in their fields otherwise implicit flows could occur on assignments of record values since a fields security label s may have dependencies we approximate the values they denote with via s notice that this allows but does not force records storing both private and public data to be classified as public such a scenario is in fact secure as will only leak at most information that a record is present but not the field contents except those classified as public we will get back to this discussion below rule is the expected rule for any value dependent function application where free occurrences of x in the result type are replaced with a value v in our system we approximate the argument value given the additional knowledge x v rule we require the security level of all sub expressions to be the same this is required to programs such as eg in which one could count the elements of a collection classified with a high security level and assign the result to a low level example suppose we have collection with elements classified at security level and consider the code foreach x in with count do count this code can only be typed as int if we allowed the body of the foreach loop to be typed at a level lower that we could type the result of the above program at security level since the computation only involves values at that level that however would represent an implicit flow since one could then observe some information about collection at level namely its number of elements noninterference on the other hand assume boxed to be a collection of records typed as boxed secret string all fields contents of the collections records are classified as high but the records themselves and the collection itself is classified as low in this case it is possible to type foreach x in boxed with count do count with type int this means that the collection and its records are visible entities at level while the actual record field contents are from the same level with this spec it would be allowed to a low to observe the collection size but not the contents of the secret fields preserving noninterference rule is as expected to prevent implicit flows from occurring we raise the security level of the computational context to the least upper bound of its current level with the logical conditions security level moreover we enforce the security level of both branches and the logical condition to be the same and track knowledge to the constraint set s about the conditions value in each branch rules and adequate to our dependent labeled sum types correspond to introduction and elimination rule for existential types rule potentially introduces a dependent sum type by indexing a label with field mj given that a concrete witness value v can be identified from mj via constraint entailment the converse is achieved with rule that is one may eliminate a field dependency and potentially a dependent sum type by replacing such a field with a concrete value witness derivable as discussed for the rule we illustrate with some examples example recall the from example let in with y do let tuple x in if then else y while typing expression while typing the then branch we obtain type uid × × × × however at this point we know that which was added to the con set s according to rule rule adding a fresh identifier x and s true x tuple to eliminate the field dependency uid in the security label ob the type uid × × × × r s e × s r s i r s ei r s × si r s e s m s r s e s i v i mj × s r s e × × mi i × s r s e × i s r s e s s s r s e s r r r s e s x s sr x e e s r s let x e in e s r s v x r s v e r s r r s ee t x s r s e q r s x se x sr q i r s ei s r s e en s sr sc true e r ss c r s sc false e s r s if c then e else e s r s e s r s e s r s ee s r s x e s s y s s s r s foreach e e s tor r s c r s c r s c c r s c r s r s v s r s v s r s v v r s true bool r s false bool r s cmd r s e s rs r s ref s e ref s r s e ref ss s s r s e s r s e ref ss r s e s r s s r s e e cmd l s r s l ref s figure typing rules finally in both branches y is typed as the collection type with element type the dependent sum type above since we are adding tuple to y and the conditional branches must have the same type so function is assigned type example we now refer back to example for clarity we abbreviate dependent sum types and mention only the record fields relevant for the discussion let foreach p in with do if then in with do let y in if then let in y to typecheck y we need to type with the declared type for the elements of collection which is type c in figure c as shown in example identifier p has type uid × × × the type for has level by the lattice order and by we get hence we may then type the record field with at this point we tracked the following knowledge via conditionals and into the following constraint set uid comment let us typecheck in the context of the assignment y after typing the record value we eliminate field dependencies adding to s the constraint x for a fresh x then we can derive the s x s x so we refine the type of the field to by and type the record bound to with the dependent type thus matching the expected type of reference y by allowing the and rules to approximate the security label to a field identifier of another record as we just did in example we essential precision in our analysis required to obtain the correct typing for and to typecheck function we briefly overview the remaining typing rules rule imposes a lower bound on the security level of the expression the reference allocation to the computational context security level otherwise illegal implicit flows could occur for instance in let x if high then ref low in x we would be able to observe that a new reference was allocated rule sets the references security level as the lower bound for the security level to prevent implicit flows since references are typed initially at security level but may raise to a different security level given the computational context for instance let x ref low in let y if high then x else ref in y would leak the value of high at low level but does not typecheck in we require that the least upper bound of the computational context security label and the references security level to be the lower bound of the contents security level this way one can safely type basic values and commands at the level even at higher computational contexts type preservation and noninterference in this section we present our main technical results theorem type preservation types are preserved by the reduction relation theorem progress welltyped expressions are either a value or have a reduction step and theorem noninterference welltyped expressions preserve noninterference our results establish that our system ensures that welltyped programs do not leak information under the security policy by the assumed security lattice in other words data does not flow from a security to another if they are or if it is a in the security lattice for detailed proofs see type safety we start by introducing some preliminary definitions definition store consistency let be a typing environment and s a store we say store s is consistent with respect to typing environment denoted as s if doms dom and l doms then r s sl l definition welltyped configuration a configuration s e is welltyped in typing environment if s and r s e s theorem says that welltyped configurations remain welltyped after a reduction step and possibly the final configuration is extended with new locations in the state lemma substitution lemma if x s r s e s and r s v s then r s theorem type preservation let fv e fv s vars s and if s e s e then there is such that r s e s s and r s e s theorem states that welltyped programs never get stuck theorem progress let r s e s and s if e is not a value then s e s e noninterference theorem to develop our main noninterference result we now introduce some relevant concepts the first is the relation of store equivalence up to a security level s auxiliary function s s returns the store obtained by replacing with a dummy value all stored values in s with security level higher than s or incomparable with s detailed definitions in two welltyped stores s s are said to be equivalent up to level s written s s s if s s s s definition store equivalence let s and s then s is equivalent to s up to level s written s s s if and only if s s s s example assume and let s and s be stores containing location also let have type uid × under typing ment which also types both stores then if and we have s user s since the values and classified as user are not visible at level user because however s and s are not equivalent at security level user s user s since the values and are visible at level user in fact eval r s v s r s v s r s s v s v s r s e s r s e s ss r r s s e s e s r s s sx e es e × mv j s e i i v v s r s s e s e × i s r s s e s e s s s r s s e s e s rr figure equivalence of expressions up to level s sample rules useful to of noninterference results is the introduction of a relation of expression equivalence relating expressions at the same type and security level technically program expressions e and e are equivalent up to level s if they only differ in sions classified at higher or incomparable security levels being to constrained to see only up to level s we say two expressions e e are equivalent up to a security level s by r s s e s e s if they compute the same result under all stores equivalent up to s definition expression equivalence expression equivalence of e and e up to s is by r s s e s e s notice that two expressions may be equivalent up to level s even if they are typed at a different level s we show key rules for expression equivalence in figure see for the complete definition we may now present our noninterference theorems lemma noninterference step let vars s s r s s e s e s if s e s e and s e s e then exists such that s s r s s e s e s proof by induction on the derivation of r s s e s e s lemma states that if two equivalent programs can both perform a step under stores that differ only on information with higher or incomparable security level than s then the resulting stores remain up to security level s and the resulting program residuals remain equivalent at the same level lemma let r s s v s e s vars s s and s s s if s e s e then there is such that s s s s s and r s s v s e s and we can then prove our noninterference theorem theorem noninterference let r s s e s e s with vars s s and s s s if s e m s v and s e n s v then there is such that s s s s s and r s s v s v s proof by induction on m n using lemma in the case m and n for m and n we rely on lemma suppose we apply theorem theorem to a program e e e so r s s e s e s holds by then if s s we must have v v since is not applicable to derive r s s v s v s one can thus conclude that an attacker located at security level s never distinguishes the result of a program executed under stores that only differ in data that should be considered for level s data classified at any level l such that l s we now illustrate our noninterference results example recall our conference manager from section and consider the following program that the profile of author with uid and then inserts a new profile in collection users using some of the information previously c def uid × name × univ email let users in let p in users uid name unit email users since the new record value is associating information of security level u value p with user id this program should be secure and the noninterference property checked we apply the theorem to check the evaluation of the assignment operation is the relevant part of this program since the program does not compute a value but changes the state at location users thus to illustrate the of the noninterference theorem we will just this part of the programs evaluation referring back to the assignment operation as expression e assume uu and let s and s be stores such that a a ab b b and c c cb b b we have s u s since the values ai and ci classified as u are not visible at level u by definition of store and uu also we have r s s let us then consider the reductions s e s and s e s then the resulting stores are the following and which means noninterference is satisfied because we have su su that is s u s so the effects of expression e are not visible at security level u as expected now consider a slight modification to the presented code where we replace expression e with another assignment operation which we shall refer as e users uid name unit email users using subexpression e instead of e in the main program will now associate the contents of the profile of author with id to a profile of author with id this clearly violates confidentiality among other things and is by the security lattice since uu so the program using this subexpression should be considered let us look this in detail again we have r s s e u e cmd after the reduction steps s e s and s e s we have and but now s u s since after executing e the values ai and ci of the new record are observable at level u this is captured by the notion of store equivalence because now we have su and su as expected the thesis of noninterference theorem is not satisfied of course programs like example are rejected by our type system in this particular case it would not be possible to give the perhaps expected dependent type c to record uid name univ email using rule because the security level of and is u but field uid has value algorithmic typechecking we briefly discuss a typechecking algorithm for a suitable version of our core language figure remaining cases in the algorithm already allows us to verify many interesting examples including those in paper and support a prototype imple for pragmatic reasons we require type annotations on reference creation record fields and bound variables leaving for future work possible inference we introduce type cast constructs of the forms se and se useful to manually primitive values and raise the level of the computational context respectively the algorithm depends on procedures to check sub typing which we represent by the solving procedure which we represent constraint tests the auxiliary procedure s ei eliminates field dependencies on the given possibly dependent record type and returns an record type by the most pre vi given by each the subtyping test essentially implements the subtyping rules given a suitable security lattice in our prototype implementation the security lattice can be userdefined in a to the code to be type checked as far as constraint solving is concerned our current prototype relies on an encoding of the required entailment checks on queries for the z smt solver the completeness of the algorithm is relative to the completeness of the required constraint solving problem related work languagebased information flow analysis has substantial research effort for a long time see eg in early works the focus was on imperative languages calculus objectoriented languages and concurrent languages more recently there has been a growing interest in studying secure information flows in the context of applications namely in web languages like javascript js as well as more generalpurpose data manipulation languages dml while the work in this paper is not focused on reasoning about information flow analysis for applications our core language can easily encode common dml highlevel operation and thus our analysis is general enough to ensure noninterference on such applications involving expressive security policies depending on runtime values as often required in realistic applications static approaches have also been employed for secure information flows in applications to a few of the relevant work ­ these works do not provide any kind of information flow analysis as we do here tc s r true def bool tc s r def int tc s r x def x tc s r se def if tc s r e s then s else tc s r se def if r s then tc s s e else tc s r x se def let t tc x s s r e in x sr t tc s r ee def if tc s r e x sr tq and ss s v and then r r then else t x else tc s r ei def let si × s s ei in a i si tc s r em def let s tc s r e in if then if sf e fn v then v else else tc s r if e then e else e def let s tc s r e in if bool then let let s s tc s tc s e e true r false r s e in s e in if then s s s else else tc s r e def let t tc s r e in if t s and r s then else tc s r e def let t tc s r e in if t t and t s then s else tc s r e e def let t tc s r e in let s tc s r e in if t t and r t s then cmd else figure typechecking algorithm two interesting ideas put forward recently are the specification of security policies that rely on runtime firstclass representations of principals by and and security labels that can dynamically change by and myers in the former is based on the label model introduced by myers and liskov in and presents a typed calculus where principals are values and thus can be used during program execution for eg for conditional testing increasing the expressiveness of the security policy model the authors also prove a noninterference result for an information flow type system using this notion of runtime principals although it is that some dynamically enforced form of value dependent security label could be encoded in some version of the eg using label passing in this work we focus on a direct and lightweight static approach the second work introduces a static typebased information flow analysis where security labels can change during execution time and are via a primitive this construction is used to add label constraints that are statically checked by the type checker in our work we do not consider runtime principals nor dynamically changing labels but instead use runtime values to index security labels to ensure data dependent security policies with our label model we are able to specify security labels that depend on the actual programs stored data to the best of our knowledge dependent information flow types in the sense introduced here leading to a general noninterference theorem are novel we have no perspective on how to and precisely express valued dependent security classification in existing dependent type systems several recent works explore applications of dependent types to languagebased security in the context of stateful static information flow in et al present fine a generalpurpose and very expressive dependently typed language based on and suggest several encodings in the language of highlevel security concerns such as information flow and access control policies to express an information flow analysis in such setting the programmer is required to the security labels as well as the lattice and all its meet join partial order relation etc into inductive types and logic formulae within a module that the intended information flow policy inside the framework in a value abstraction result is presented stating that code within a module does not interfere with another modules protected code which is different from the standard notion of noninterference used in our work and does not and explicitly address the fundamental notion of value dependent classification through dependent typing which is the core contribution of our work which in addition covers a language with general imperative features moreover the use of dependent types to express security properties in such line of work relies on refinement types and relative logical encodings of meta properties which is very different from what we do here that does not involve refinement types and a simple and primitive notion of value dependent classification directly at the level of the type structure leading to an absolute noninterference theorem in et al use a very expressive relational hoare type theory to reason about access control and information flow in stateful programs besides standard dependent types this work introduces a special dependent type to specify security policies via pre and postconditions using higherorder logic formulae capable of expressing heap union disjointness the type is used to type potentially operations but the relevant part wrt to information flow analysis is the postcondition that specifies the behaviour of two different runs of the program relating the outputs input heaps and output heaps of any two terminating executions of the program another interesting work based on and is rf where the authors introduce the notion of relational refinement types the key idea of relational refinement types consists in extending classic refinement types to relational formulae which in turn enables to relate the left and right value of every program variable in scope through projections l and r with this setting the authors type system is able to relate expressions at a relational refined type that can describe the results of both expressions a distinguishing feature of these latter approaches is that data is not classified with security labels as expected from traditional information flow analyses instead and similarly to the approach of the noninterference property is expressed directly in the postcondition via detailed assertions that relate the initial heap with the final heap as well as the output values for any two runs of the program while it might be in principle to express information flow policies in such a framework and in fact in any sufficiently expressive logical framework for imperative programs supporting general functional properties the goal of our work follows a much lightweight and tractable typebased approach and aims to single out and address in a direct and explicit way the core notion of value dependent information classification a concept of indexed security label was introduced in as an useful yet isolated feature to express security policies in a domain specific language with highlevel monolithic data manipulation operations much less general and expressive than what we achieve here the developments in this paper put forward in a way and for the first time the notion of dependent information flow in terms of a fairly canonical dependent type theory with firstorder sum and arrow types defined by a set of simple type rules and for a calculus with references and collections several proposals for dynamic information flow analysis on web languages have been put forward such as in this work we focus on static certification techniques developing the new notion of dependent information flow types in future work it would be interesting to study combinations of static and dynamic typing in the context of our dependent type system remarks in this paper we have motivated introduced and studied a novel theory of dependent information flow types which provide a direct natural and elegant way to express and statically enforce fine security policies on programs in our framework the security level of data types rather than just the data types themselves may depend on runtime values unlike in traditional dependent type systems we have illustrated including by means of many examples how the proposed approach provides a general expressive and fine way to formulate realistic yet challenging security policies our development is carried out on top of a calculus with general references and collections thus adding generality and application scope to the approach our main technical results are expressed by type safety and noninterference theorems which ensure the soundness of our value dependent information flow analysis welltyped programs do not information in ways the security reasoning about the identity of dependent security labels eg necessary to eliminate dependent sum type field dependencies or approximate dependent function argument values requires runtime values to be approximated by a given constraint system it may also be the case that the elimination of a dependent sum type results in replacing field dependencies with another dependent sum types field identifier eg an assignment operation in a conditionals then branch whose logical condition relates the field dependency with another record field instead of a value as long the final type remains wellformed the constraint system used to deduce approximations of runtime values can only contain pure expressions thus constraints containing dereferences however this is a natural restriction that in our experience does not seem to limit much the expressiveness of the approach but that further study we have also briefly discussed some algorithmic aspects of our approach that has led to a prototype implementation which can already be used to check examples including those in this paper adding variant types to our language is a trivial exercise and would be important also for practical reasons it would be interesting to investigate of our type system integrating notions of type refinement eg and type inference as another follow up topic as information flow analysis per se is not enough to ensure full data security guarantees we would like to investigate the combination of our dependent information flow types with an adequate form of access control acknowledgments we thank the anonymous reviewers for their comments and suggestions we also thank a and c for related discussions this work is supported by grant and grant by sa references m abadi a n heintze and j g a core calculus of dependency in popl o m d j k a and a c myers sharing mobile code with information flow control in ieee g m a d gordon c and d e semantic subtyping with an smt solver j program a static checking of security policies in applications in usenix b j n and m w security enforcement for web applications in acm int conf on management of data b and h chen information flow tracking via databases in usenix l m de and n z an efficient smt solver in tacas d e and p j certification of programs for secure information flow comm of the acm w p b l p j p m and a an informationflow tracking system for realtime privacy monitoring on in usenix j a goguen and j security policies and security models in ieee d and a sabelfeld informationflow security for a core of javascript in ieee n heintze and j g the slam calculus programming with secrecy and integrity in popl k honda v t and n yoshida secure information flow as typed process behaviour in esop lncs c m b b c pierce and g morrisett all your are belong to us in ieee p li and s practical informationflow control in information systems in ieee j m d k x qi l and a c myers a platform for secure distributed computation and storage in acm l and l information flow analysis for data security in a c myers jflow practical information flow control in popl a c myers and b liskov a model for information flow control in acm a a and d verification of information flow and access control policies with dependent types in ieee f pottier and v information flow inference for ml in popl a sabelfeld and a c myers languagebased informationflow security ieee jan a sabelfeld and d sands a per model of secure information flow in sequential programs higherorder and symbolic computation n b j and m a language for enforcing userdefined security policies in ieee n j chen and r enforcing stateful and information flow policies in fine in esop n j chen c fournet p k and j yang secure distributed programming with types in icfp s and s runtime principals in informationflow type systems acm trans program lang syst d m c e and g smith a sound type system for secure flow analysis journal of computer security h xi and f pfenning dependent types in practical programming in popl s and a c myers observational determinism for concurrent program security in ieee n s and d distributed systems with information flow control in usenix l and a c myers dynamic security labels and static information flow control int j inf sec g c fournet b p n and s z probabilistic relational verification for cryptographic implementations in popl l and l dependent information flow types technical report prototype 