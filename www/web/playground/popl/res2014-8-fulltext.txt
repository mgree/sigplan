a trusted javascript specification martin inria inria paris college london college london college london college london alan inria smith college london abstract javascript is the most widely used web language for applications the development of javascript was initially just led by implementation there is now increasing behind the process the time is for a formal specification of javascript to in the standards to serve as a trusted reference for highlevel language compilation and javascript implementations and to provide a platform for proofs of language properties we present jscert a of the current standard in the coq proof assistant and jsref a reference interpreter for javascript extracted from coq to ocaml we give a coq proof that jsref is correct with respect to jscert and jsref using test the test suite our methodology ensures that jscert is a accurate formulation of the standard which will only improve as time goes on we have demonstrated that modern techniques of specification can handle the complexity of javascript categories and subject descriptors d programming languages formal definitions and theory keywords javascript semantics coq introduction javascript is by far the most widely used web language for applications initially javascript development was entirely led by implementation with the first javascript implementation in and microsoft with their own version in the same year quickly that permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm was crucial client code that works on some of the main and not others is not useful the first standard appeared in now we have es and es supported by all there is increasing behind the process with for es and well under way javascript is the only language supported by all major web programs written for the browser are either written directly in javascript or in other languages which compile to javascript this fundamental role seems to change however javascript is very complex the standards by are large and full of corner cases despite the best efforts of their editors these documents are sometimes and in some isolated cases even inconsistent we believe the time is for a formal specification of javascript to in the standards to serve as a trusted reference for highlevel language compilation and javascript implementations and to provide a platform for proofs of language properties we introduce jscert a specification of es written in the interactive proof assistant coq we also introduce jsref an executable reference interpreter extracted from coq to ocaml we give a coq proof that jsref is correct with respect to jscert the correctness proof ensures that we can have full that a jsref program has the behaviour specified by jscert all our coq code is available at we believe that both jscert and jsref are necessary jscert unlike jsref is for developing inductive proofs about the semantics of javascript jsref unlike jscert can be used to run javascript programs our challenge is to ourselves and others that jscert is indeed an accurate formulation of the es specification we designed jscert to follow the structure of the es standard as much as possible whenever we found parts of es to be ambiguous we checked the browser implementations and were active on discussion groups such as we also ran jsref on the test suite test since jsref is correct with respect to jscert failed tests meant between es jscert and the tests using this methodology we were able to correct several bugs in jscert and jsref we also discovered and reported a number of bugs in all the browser implementations the standards and test we have demonstrated that modern techniques of specification can handle the complexity of javascript jscert we introduce jscert a coq specification of es in with mitchell and from stanford developed a smallstep operational semantics for formally describing the full behaviour of javascript following es except when the standard was incorrect or ambiguous apart from moving to es we also differ from in that we use a bigstep semantics to be closer to the style of the however the traditional bigstep approach would lead to many duplicated rules since the javascript control flow is quite complex we use a semantics an approach recently developed by a simple ml our work here demonstrates that the technique to a realworld standard and yields a close connection between es and jscert note that we are not trying to es which has an ease of readability that would be difficult to match with a specification we are for an accurate specification of es which can be used for when the es is by a team of coq and javascript we have been able to handle the size and the complexity of the javascript semantics as with most large specification projects a significant question is when to stop we have formally specified the core language where we believe most of the interest for our project lies we have not specified the command because in trying to do so we discovered that es and es are broken in this respect we have not specified the parsing of javascript source code which would be a challenging orthogonal task also our of native libraries is partial we have nearly all of the library functions that expose internal features of javascript with the exception of functions involving arrays which is future work in particular we have most of the functions from libraries object function boolean number and errors we are not to the other native libraries they contain of library functions that do not interact with internal javascript features in the sense that they could be implemented as plain javascript code jsref we introduce jsref an executable reference interpreter which we have proved correct with respect to jscert and tested using the test suite test by design jscert is not directly executable it is presented as an inductive definition essential for developing safety proofs and it matches the of features we therefore developed a computable coq specification and from this automatically extracted the corresponding ocaml code obtaining the executable reference interpreter jsref our computable coq specification follows the es as much as possible where the implementation details were left unspecified we made arbitrary but natural choices in fact we developed jscert and jsref in parallel this approach was when understanding an part of es we sometimes needed the broad intuition sometimes the pragmatic intuition about what was really meant recall that jscert specifies the core language of es but does not specify the parser nor many of the native libraries the same restrictions apply for jsref in particular we rely on an javascript parser taken from the closure compiler for parsing the initial source code and for implementing eval we have a bug report n of for es trust our methodology for obtaining trust in our semantics can be as follows correctness running tests es jscert jsref tests for jscert trust arises from the of jscert to es we can place the and the formal rules and compare the two one line of es corresponds to one or two rules in jscert if commands need changing as they will for future standards it is relatively straightforward to see which part of jscert needs changing for jsref we have a correctness proof that it satisfies jscert more precisely we prove in coq that if the execution of a javascript program in jsref returns a result then there exists a reduction derivation in jscert relating this program to this result because of the of es our interpreter cannot be proved complete nevertheless we believe that on the deterministic subset of es our interpreter is complete we trust the extraction mechanism of coq used to obtain the ocaml code of jsref since it is standard and eg in we also test jsref using test jsref successfully executes all the tests that we expect to pass given our coverage of jsref there are tests associated with the core language ­ we pass tests the others fail due to calls to libraries we have not specified or the parser we also use the ocaml tool to investigate the coverage of these tests our on testing provides a different level of trust from that usually found in coq development see related work which is perhaps more accessible to javascript and programmers it also provides a first step in the analysis of what it means to trust test as we were developing the proof of correctness and running the tests we found bugs in jscert and jsref it was necessary to go around the loop many times with the correctness proof and testing and so on our correctness proof guarantees that jsref is an accurate reference interpreter for jscert up to our trust of the coq extraction process however despite our development of jscert and jsref we cannot yet guarantee that jscert is bug free in the sense that there may well be with es a few will be due to the ambiguity of es the authors have been very to our queries on and it has always been possible to reach consensus other however will be due to in jscert we do believe that over time with more proof reading and testing by ourselves and with help from others we will be able to eliminate all the bugs applications there are many potential applications of jscert and jsref for example we can investigate properties of fragments of javascript used for secure by such as and several highlevel languages are compiled to javascript jscert provides a formal target to verify the correctness of the compilation a natural first language to explore in this respect is f compilation to javascript and back for full abstraction see related work javascript can compare their implementation with jsref for example a direct extension of our work would be to the differences between and jsref by running the test suite on jsref a is that our specification might even be used as part of the creation of future standards es is already taking shape but es is only just being this paper demonstrates that it is feasible to provide a coq specification of es together with a reference interpreter passing the es tests we are on es with bug reports it may not be beyond reach to provide a specification for es as part of the standard related work a realworld language specification can come in many forms an implementation of the as specification eg php an definition with varying of eg the c standard and es are fairly precise and complete a formal mathematical specification eg standard ml and specification our work on javascript is part of the established to existing realworld programming language specifications in this section we survey related work on the of programming languages in general and on various of javascript in particular specifications one of the most fully of a programming language is standard ml by milner tofte harper and macqueen a specification was given by lee crary and harper in the theorem prover unlike ml many realworld languages are designed without formalism in mind such languages provide a considerable challenge to there has been a wide body of work on language specifications in hol for example specifies a smallstep operational semantics of c in hol and proves substantial of the semantics formalism has not been tested for with implementations another example is sewell et als work on transmission control protocols tcp in they created a specification of tcp from several implementations an not so far off the creation of the original standard for javascript although not focusing on language specification their work is in the context of our work as it the specification against several test traces captured from implementations using a symbolic model checker above hol in the compcert project and leroy built a verified compiler for clight a significant fragment of c with a coq proof that the generated compiled code behaves exactly as by the semantics of the source program the compcert project major in coq some of which we substantially use in this project the aims of the projects are different clight was not intended to capture precisely the c specification also clight is not directly executable although it would be possible to obtain an interpreter without too much additional effort by the coq code extraction mechanism several substantial projects build on compcert verified software tool chain combining program verification with verified compilation project to an os kernel et als verified llvm which extracts an interpreter from coq code that is tested using the llvm suite out of tests and verifying compilation the x weak memory model the use of proof such as hol and coq requires quite a substantial learning curve researchers are beginning to explore how to make specification easier the k framework is designed specifically for writing and language definitions using a rewrite logic in particular and have defined an executable formal semantics of c in k their has been extensively tested against the gcc suite besides being executable their semantics also comes with an model checker their aim is to define an accurate reference interpreter justified by testing rather than provide a full semantics of the c standard their work is analogous to jsref in addition the tool provides a lightweight environment using notation for writing definitions of programming languages and calculi which automatically translate to hol and coq et al have developed a semantics of ocaml light using for space reasons we cannot detail all the interesting examples of specifications of programming languages there is a wide body of work on specifications of java and c eg hol semantics of and formal java semantics the executable of the c standard by et al using abstract state machines and the executable formal semantics of java in rewrite logic by et al we should also mention the formal semantics of et al on c concurrency which is currently having real impact on the c standard the work is currently not but considering the research group it will happen soon our specification of es shares many of the difficult challenges by the work described above and involves many new ones due to the complex dynamic nature of javascript they are detailed in § we now provide a more detailed survey on and the javascript semantics formal javascript specifications in et al and were the first to propose formal type systems for subsets of javascript to prove they of the language that abstracted away features not crucial for the type analysis at hand focusing instead on the challenges addressed by their analyses since then researchers have studied various typed javascript subsets and static analyses including ­ for example et al used abstract interpretation to develop a tool to infer abstract types for the full language although the formal theory only works for subsets others have studied information flow with proving their results in coq all these techniques have been helpful for addressing specific safety problems none provide generalpurpose analyses most do not work with the full language and of those that prove soundness all do so with respect to their abstract models rather than the semantics or an actual concrete implementation the security issues identified in demonstrate that the semantic of corner cases of the language matter moreover the empirical analysis by et al that some of the language features by construction from the work mentioned so far are in fact important for actual web programmers in and flanagan proposed a of the javascript semantics as a definitional interpreter written in ml their interpreter was the first executable formal semantics for a nontrivial subset of javascript the advantages of their approach were the ability to test their interpreter and the of their work to functional programmers the were a correspondence with the specification and implementation details that sometimes the semantics of the language features in mitchell and defined the first full operational semantics for the es language they covered the whole language apart from a few corner cases such as regular expressions and machine arithmetic the consists of a large set of smallstep operational semantics rules and some theorems about the and of the language this work has been useful to prove soundness of javascript subsets and the definition of further javascript for example the semantics of secure underlying and the bigstep operational semantics of core javascript proposed in and used in is based on this work this formal semantics it self from the work described above because its goals were to cover the entire language without features to serve as a basis for formal proofs of real language properties the main of this work is that since the rules are not the proof of language properties is the and extension of the semantics is not easy and a comparison with implementations is impossible in et al up with a completely different approach to developing language semantics they provide a translation from javascript to a executable language called js which has as its core a simple calculus with references their aim was to develop provably sound type systems to reason about the safety of web applications they target the implementation of es and validate their semantics by testing it against the test and test more recently js has been extended to model the strict mode of es and an unpublished coq of js has been on the plt the work on js has been in proving properties of wellbehaved javascript typed subsets where the programmer accepts restrictions on full javascript in exchange for safety guarantees for example et al define a type system for js that captures the informal restrictions enforced by a subset of javascript for web fournet et al define a translation between f a subset of microsoft f with refinement types and js they show that their encoding is fully abstract hence the safety properties by a source f program are preserved when it is translated to javascript and run on a trusted web page the has also been a significant source of for our development of our executable semantics jsref and our focus on testing we have tested jsref using the test tests and in future will use the test suite to compare jsref with the implementation our work is not the first to give a formal andor executable semantics to javascript however jscert is the first semantics for the entire language closely the standard which is both executable and in a proof assistant working with the source language itself and the structure of the specification has several advantages over a approach the javascript programmer intuition is better reflected the semantics is robust to local changes of the standard such as those for and and the correctness of the semantics does not rely on possibly unknown assumptions associated with translation throughout this project it has been important for us to establish trust in our semantics as jscert and jsref are explored by ourselves and other by people compiling to javascript by javascript and maybe even by authors so our trust will increase if questions our interpretation of es or if a test fails we know which part of jscert to check and alter building on much of the work detailed above we believe we have developed a methodology for providing a trusted specification of an language standard we do just if this methodology has been fully demonstrated before the javascript standard we give an overview of the semantics of javascript as described in the standard and implemented in current in order to prove the correctness of such a translation one needs a formal semantics for the source language in the first place in this sense our work will make it possible to prove the correctness of the encoding of javascript in js increasing in the validity of js or f safety properties on actual javascript programs § we introduce our running example § and identify the parts of the standard that have not been included in our specification § es is the current standard for javascript existing largely implement es but sometimes introduce custom extensions or make different choices in how to implement certain cases that the specification defines as implementation dependent in addition to the language es also describes a collection of native libraries which provide convenient functionality eg handling of regular expressions date formats as well as a few extra language features useful for reflection in this paper we focus on the language itself only specifying the native libraries necessary for the extra language features the grammar of javascript is divided into three main categories expressions statements and programs a javascript program consists of a list of statements the body of a function definition is a javascript program similarly the argument of the eval statement once parsed is a javascript program the result of the evaluation of an expression statement or program is a completion triple a completion triple is composed of a type a value and a label the type is one of normal return break continue or throw corresponding to the termination mode of the evaluation the value which can be empty describes the result of an expression or statement if the type is normal the value carried by a return statement if the type is return or the object describing the exception being if the type is throw the label which can also be empty is only used for break and continue types in order to the execution flow to the instruction annotated with the target label one of the reasons we were to study es is that it has not been defined with specification in mind the standard is not for and reuse it has a lot of which increases the of our the standard uses representations that are practical for eg vm but less helpful for reasoning for example completion triples have implicit invariants that for our purposes would be better captured with an inductive definitions also the standard becomes very particular when describing extensions and is not explicit about whether functions should have deterministic behaviours apart from this determinism issue we have found es to be precise and with two exceptions first the specification of data attributes used to represent parameters of properties object fields such as and enumerable flags has two different representations in different parts of the specification we give both representations in our specification and prove that they are equivalent so that we can follow es as closely as possible second the specification of from major issues related to the specification of the order of enumeration of the property names running example the while statement there are many interesting features in the semantics of javascript these include inheritance return value propagation through empty statements implicit type conversion which may result in arbitrary side effects the unique javascript approach to variable resolution and the with and eval statements all of these features are properly described by our jscert semantics since space is limited we chose just one language feature to demonstrate our approach and at least some of the of the javascript language our running example will be the while statement while expression statement is evaluated as follows let v empty repeat a let be the result of evaluating expression b if is false return normal v empty c let stmt be the result of evaluating statement d if is not empty let v e if is not continue is not in the current label set then i if is break and is in the current label set then return normal v empty ii if stmt is an completion return stmt figure semantics of while loops fig shows the specification of while exactly as it appears in the es standard the text should be interpreted as executing each statement in order the es specification of while is relatively short in comparison with other constructs such as switch whose specification more than one full page this es like a traditional imperative programming language leaves completely implicit three major aspects of the semantics the first aspect is divergence es never explicitly about programs but it should be understood that if the evaluation of a subexpression diverges then the parent expression will also diverge the second aspect is the of the mutable state es assumes that there is one global heap storing objects and that the instructions in the can modify such heap the third is the propagation of exceptions through expressions es describes the semantics of expressions in terms of the result of the subexpressions but does not recall every time that exceptions propagate from expressions unlike es our jscert specification is fully explicit about divergence mutation and exceptions we describe the from fig in more detail the basic skeleton is standard repeat the loop body until the loop condition becomes false or until the body of the loop produces a break a return or an exception step b is nonstandard one of the mechanisms necessary to interact with variable store the result of an expression is not necessarily ready to be used but may be a reference to a variable stored as a field of an object the internal function is used to dereference it in addition javascript uses the internal function to implicitly coerce the loop guard to a boolean before to test it a further comes from the fact that javascript allows labelled break and continue statements that may refer to an outer loop a current loop may be by such labelled break and continue operations just like it would be if an exception was in fig the current label set refers to the set of labels that are associated with the current loop since a loop might have several labels as in eg b finally notice that while loops have a return value in javascript the definition of the javascript syntax us from writing statements like however it does allow eval the assignments to the internal variable v in fig are at maintaining the value that will serve as the result of the current while loop the value v is in es the propagation of exceptions out of expressions is implicit whereas the propagation of exceptions out of statements is explicit this is not only it is also a potential source of this issue has been resolved in es where like in our the propagation of exceptions is always explicitly specified used in one of two cases a break or a continue has been for this loop or a break or a continue has been for an outer loop and does not yet carry a nonempty value without further details the reader may the complexity of javascript semantics with respect to output values of statements by looking at the following while loop examples which return the last value that was produced by a statement in their body if any while while break a undefined while while y break a while x while y break a while x while break a the most surprising example is the fourth one is returned because the statement x has completion value and the statement while break a has an empty completion value what we do not specify the es standard is a document of ranging over pages plus some additional it consists largely of in the style of fig with in the document includes the specification of parsing the specification of the syntax eg objects heaps environment records the describing the semantics of expressions statements programs and internal properties and the describing the semantics of native library functions we have given a coq specification for the important part of the language the syntax as an abstract syntax tree the semantics of expressions statements and programs and most native library functions that expose internal features of javascript in particular we have specified the object function and errors libraries with the only exception being functions involving the manipulation of arrays we also have specifications for the constructors and most functions from the libraries boolean and number for floatingpoint numbers we rely on the coq of ieee standard provided by the library we have not other standard libraries such as array string and date these libraries involve of functions the of them do not interact with any internal feature of javascript and could be implemented as plain javascript code the specification of these javascript standard library functions is orthogonal to the of the javascript programming language per se we also have not specified the parsing of javascript programs parsing is important because of eval statement which requires parsing source code at runtime the of the formal grammar of a programming language is more complicated than one might expect the parsing of javascript programs is made particularly by the treatment of implicit as it involves a one token lookahead we therefore leave the specification of parsing to future work and use the parser of the closure compiler in our reference interpreter jsref jscert javascript specification in coq our formal development in coq available from our projects consists of five main parts syntax of the language auxiliary definitions jscert semantics jsref interpreter proof of correctness inductive result type inductive result value value ref inductive result label string record res completion triple figure jscert completion triples the first part describes the syntax and data structures such as heaps and that are used to describe the formal semantics the second part contains a collection of auxiliary definitions such as functions used to convert a primitive value a value that is not object into a boolean a number or a string these first two parts are described in § the next two parts correspond to jscert § and jsref § the last part contains the correctness proof that any result computed by jsref is correct with respect to the semantics from jscert § syntax and auxiliary definitions we give a simple summary of the syntax and auxiliary definitions shared by jscert and jsref the full coq specifications are given in the file abstract syntax tree following common practice we do not model the parsing of language source code instead we work directly on the ast abstract syntax tree we obtain the ast by running the parser of the closure compiler extended with some additional interface code defined by us the grammar of javascript expressions and statements is defined in file through a conventional inductive definition that represents the abstract syntax tree this definition is relatively short since there are only kinds of expressions and kinds of statements we should note that we have similar forms of and using option types and that the definition of expressions depends on the grammar of literals null bool number string the grammar of the unary operators and the grammar of the binary operators a javascript program consists of a list of statements plus a strictness flag which the evaluation order of the list of statements the body of a function definition is itself a javascript program the argument of a call to eval once parsed is also a javascript program completions as we noted in § the result of the evaluation of an expression a statement or a program produces a completion triple as given in fig a completion triple type res is made of a type an optional value or reference if the expression is a variable name and an optional label the type is one of normal return break continue or throw corresponding to the control flow obtained from an evaluation the value if any is either a primitive value a literal or undefined or the location of an allocated object this value describes the result of a normal expression or statement the value carried by a return statement or the exception being in a throw result the optional label of a completion triple is only used for break and continue types in order to implement the break label and continue label instructions a number of invariants apply to completion triples for example if a completion triple carries a nonempty label then it must be of type break or continue in order to better capture all the invariants on completion triples we were to use a clean inductive definition with one constructor per type and different arguments for each type however recall that one of our goals is a direct correspondence between our jscert specification and the es standard a change in the representation of something as fundamental as completion triples would put considerable distance between the of the es and our of it forced to choose between a more elegant coq representation and a more direct correspondence with the standard we chose the latter program execution a javascript program is always executed in a given state and in a given execution context the state consists of the set of allocated objects the heap plus the set of allocated environment records the heap the javascript object heap is represented as a finite map from locations to objects an object is represented as a record with fields including the prototype object the class name a boolean extensible property an optional primitive value for objects of class boolean number or string the property map as well as internal methods such as get or put optional fields such as body and scope for functions and optional internal methods such as call or construct each internal method may have a small number of different behaviours depending on the object on which it is called arguments objects for instance have a different implementation of get we distinguish these different behaviours using a tag that describes how the internal method should be processed object properties the property map binds field names to property attributes rather than directly to values a property attribute is a record that contains a number of fields there are two kinds of property attributes data property attributes which have a value field a field an enumerable field and a field and data attributes which have a get field a set field an enumerable field and a field the es standard suggests that property attributes should be represented as a record with optional fields in particular the specification of the function involves the construction of a property attribute which explicitly records using arbitrary subsets of the optional fields at the same time in many other places the standard uses exactly fields making the assumption that particular fields are present and implicitly exploiting the fact that the property attribute is known to be either a data property or a data attribute from the context and implicit invariants since we to be faithful to the standard everywhere we chose to provide two distinct representations of data properties the first consists of a record with optional fields and the second consists of an inductive type with two cases one for data property attributes and one for data attributes both represented as records with exactly fields the overhead of defining conversion functions between the two forms was compared to the benefits of avoiding the of many rules with accesses to optional fields environment records recall that the javascript state consists of the heap and the set of allocated environment records we store environment records in a similar data structure to that used for the object heap using a pointer to refer to a given environment record an environment record can take one of two forms a declarative environment record which maps variable names to values and to flags or an object environment record which consists of the location of a javascript object and some flags declarative environment records provide the local scoping associated with function calls while object environment records provide the dynamic scoping associated with the with construct in addition there is always at least one object environment record which points to the global object to properly model function closures a given function object represents the environment it over as a lexical environment stored in one of its internal fields execution context the execution context is represented as a triple that consists of the scope both the lexical environment and the variable environment as specified by es the current this object and the current strictness flag we represent both lexical environments and variable environments as a stack a list of pointers to environment records jscert based on the syntax and auxiliary definitions described above the main jscert rules are defined in the file we the semantics of javascript statements using a judgement of the form s o where t denotes a statement s denotes the state the object heap and the environment record heap c denotes the context the lexical and variable environment the es this object and the strictness flag and o denotes the output we have similar judgements e i and p for expressions internal reductions and full programs for terminating computations the output is a pair made of the final state and the completion triple produced by the evaluation our jscert semantics expressed in style also captures computations using a coinductive interpretation of the same set of evaluation rules we discuss this further below one key to the of the evaluation rules is the definition of the output of an evaluation as a sum type shown below that describes either termination in a given state with a given result or divergence inductive out state res out out internal reductions however return results of many different types some for instance return property descriptors we thus use a more general return type t that is by the type t of what is returned to add further complexity internal reductions may call arbitrary user code which may terminate with an termination such as an exception or which may diverge their return type is thus not uniform it returns a modified state and a term of type t when the computation is successful it returns a term of type out when the computation diverges or results in an termination this behaviour is captured by the following type inductive t state t t out t semantics we express the jscert semantics using the operational semantics recently developed by the key difference between the traditional bigstep semantics and semantics is that we can decompose the evaluation of a single program construct using intermediate forms defined in which extend the grammar of program statements and can be evaluated just like any other program this style of semantics allows us to more effectively match the modularity of the es standard the advantages of the semantics have been described in here we only recall the arguments applicable to large existing language standards such as es nearly all standards for programming languages including es use of the form let r be the result of evaluating t these relate a term directly to its result just as a bigstep judgement would do because we want to be close to es we cannot work with a smallstep presentation as in with rules of the form to evaluate if e then t else t execute one step to reduce e into e and then evaluate if e then t else t if we attempt to use traditional bigstep semantics we quickly find that we have to duplicate a significant amount of material across several rules for example consider the loop t in bigstep we need a rule to handle the case where e evaluates to an exception another rule for the case where e evaluates to a value converted to the boolean false yet another rule for the case where e evaluates to a value converted to the boolean true and the body of the loop evaluates to an exception and so on the problem here is that the steps made by a bigstep semantics are too big to correspond to es as suggested by our example if we attempt to es into a bigstep presentation our of premises will lead to a quadratic explosion in the size of our rule set for an research programming language this sort of duplication may not present much of a problem however we soon that es in this way would quickly become this observation motivated the development of the semantics which has enabled us to write rules which very closely follow the structure of es semantics for while loops consider the es description of while loops given in fig the corresponding jscert semantics is given in fig notice the close correspondence between the steps of the es and the jscert rules step of the es says let the corresponding rule uses the notation l e t to refer to a while construct with guard e body t and label set l used for break and continue statements the rule says that in a given state the loop may evaluate to the output o if the intermediate form l e t also evaluates to o this intermediate form carries all the information of the original while construct and also carries the additional information that the value of v is which is our coq representation of the es empty value step of fig begins the loop in the es in our jscert rules we may loop back to this point at any time by using the intermediate form as a premise of a rule now let us consider steps a and b these steps represent a pattern which is very common in es first we evaluate some subexpression then we perform a and a type conversion on the result of that evaluation in this case we are converting to a boolean notice that a great deal is left implicit in the es which we wish to make explicit in our rules the subexpression or statement could diverge or throw an exception the type conversion could diverge or throw an exception and both the and the type conversion could have side effects on the program state this pattern occurs so frequently that we introduced a special intermediate form to handle this is actually not the case for conversions to booleans but it may happen in conversions to other types such as string or number l e t s o l e s o l e t rv s s s rv rv if r then r else rv l e t rv s o l e t rv s rc s o r r l l e t rv s o l e t rv s o r r l l e t rv s s rv r l e t rv s s r i y l e t rv s o l e t s o s o l e t rv s o l e t rv s s o r r l l e t s o l e t rv s o t some o t s o abort o r r l l e t rv s o l e t rv s o r l e t s o l e t rv s o figure jscert semantics of while loops it while making these side effects divergence and exception propagation clear the reader may see this special intermediate form at work in the rule here the intermediate form takes care of the evaluation of e its and its type conversion in this case we specify which type to convert to using the flag the remaining work of step b is performed by rule notice that since the may have side effects the rule takes its initial state s from the result of the type conversion as given by the intermediate form rule is a terminating rule since the corresponding es step says to return normal v empty in our the variable v corresponds to the variable rv since we do not mention a completion type our formalism assumes the completion type normal and since we do not mention a label set our formalism assumes the label set empty this is done in coq using a type coercion coercion rv rv step c which corresponds to rule follows the pattern evaluate some subexpression or statement in this case t and store the result in some variable each new variable becomes a parameter of a new intermediate form ­ in this case the o parameter of notice that the rules and both assume that the result of the performed by rule was successful in the event that the type conversion diverges or an exception that computation will be propagated by the general rule we handle divergence and we have similar computation rules for expressions internal reductions and full programs tional termination of the loop body statement in es and t in our formalism in exactly the same way the rule uses the function to extract the output from any intermediate form checks that this output is an one and checks that this computation should not be by a more specific rule for example in a while loop computation if an exception or divergence happens in step c instead of always propagating the in some cases we want to it that is the part of the definition of t is the case where t can be with l e t rv s r in this case the value of t is r l r r this condition checks for caused by continue and break statements that target the particular loop that we are currently evaluating and should be properly handled by step e below step d is another conditional assignment which we handle with a condition of our own in rule notice that we that we will only proceed with step d if our previous steps terminated this is encoded in our pattern matching for s r which is the result of a terminating computation the case in which the previous computation did not terminate is handled also by the abort rule which propagates results step e begins a nested conditional expression it is simplest to describe the false case first since this results in simply looping back to the beginning of step this case is handled by rule the first premise of which is the negation of the guard written in fig the second premise of this rule begins the next iteration of the loop by the intermediate form in the true case rule continues with a new intermediate form step ei is another conditional expression which we describe with two simple rules the true case which describes the terminating computation out of the loop corresponds to rule the false case which continues to step corresponds to rule finally we come to step another conditional modelled with a pair of rules the completion case which terminates the computation corresponds to rule the normal case which loops back to the beginning of step using the intermediate form corresponds to rule it is a simple matter to express the rules given above as coq definitions for example the rule can be written in coq as follows s c e t rv r o r s c e t rv o s c e t rv r o javascript challenges the first challenge with es is the size of the definition es consists of pages plus some additional of language and description while we do not aim to the parsing of concrete javascript syntax most of jscert and jsref cover and have a correctness proof for all of and except for the statement chapter array chapter and some type conversions chapter see for the current state of our jscert specification which will grow over time we choose not to at this stage because it is specified and broken based on the es standard and with es authors and browser we bugs in the current draft of the es standard bugs and of still it is an interesting challenge to give a more precise description of the semantics of and we leave it for future work chapter contains the native libraries and would be considerable work to specify in full we have jscert rules and jsref code but no correctness proof for those parts of chapter where the libraries expose important javascript features the inductive definition of jscert is sometimes a little as illustrated by the rules for while this is due to the fact that we closely follow es which is itself quite and we are being fully explicit about the evolution of the state and the context in contrast we shall see that the jsref fixpoint presentation is significantly more compact § despite its the inductive presentation of jscert is suited to formal proofs because it gives a finegrained view of the different steps allowing modular reasoning about the evaluation of a given javascript language construct moreover as we have with the verification of the code of jsref with respect to jscert the of the rules which never have more than two evaluation premises significantly the development of tactics that help formal proofs the second main challenge with es is the high complexity of the behaviour of a few features such as the representation of and variable lookup the representation of data attributes the treatment of function calls and arguments in our coq development we use a slightly different naming convention for the evaluation rules which we believe will be easier to maintain when from one version of the standard to the next that said for involving more than steps we left a comment next to each evaluation rule indicating its corresponding es step number object and the evaluation of several features introduced in es such as execution contexts and strict mode are throughout the specification and hence are nontrivial to capture finally javascript internal methods can return types not allowed to user code and yet may call user code we thus had to a definition that was flexible yet allowed for proofs to be automated as much as possible the next section on jsref illustrates how such an effort enabled us to much of the presentation using a monadic approach semantics of programs es never explicitly programs a program diverges as soon as the evaluation of any subprogram diverges even though we have not so far any formal reasoning related to divergence we could formally capture the semantics of javascript programs without requiring additional work the constant which we introduced in the grammar of outputs o divergence this constant is propagated through the evaluation rules just as exceptions are propagated we derive the judgement capturing the semantics of programs by considering a coinductive interpretation greatest fixedpoint of the exact same set of evaluation rules as we have for terminating programs additional details may be found in jsref a reference interpreter for javascript our goal in defining jsref is to obtain an executable javascript interpreter whose definition closely follows es and can be proved correct with respect to jscert note that jsref does not need to be fast it simply needs to be efficient enough to interpret programs such as those found in the javascript test host language for jsref we have chosen to write jsref directly in coq that is in a core language that admits only total functions we could have chosen to use an imperative language with implicit state in the hope that this would make translating es easier however this would have made the correspondence between our interpreter and our formal specification much more difficult to establish by using coq as a programming language we make state and exception propagation explicit which we consider an advantage and make the formal statement and proof that our interpreter is sound straightforward as described in § structure of jsref the interpreter consists of a record that contains functions for evaluating programs statements expressions function calls and so the record type slightly simplified for clarity appears below record type state expr result state stat result state prog result state expr stat result since our coq implementation must consist only of terminating functions we bound the number of steps that jsref may take in any given run a standard technique in acl and coq this is similar to decide in advance if it finished in ill the token is the result of a computation that was in this way in practice it is to observe because we can specify a very large bound on the number of steps we thus define our runs function as a fixpoint which takes an integer as an argument and returns a record of functions with the type of the record above fixpoint runs match with o fun s s fun s s fun s s fun s s s fun s runs s fun s runs s fun s runs s fun s runs s end definition a b type w a k a b b match w with a k a s s s s end definition a b type w a k state a b b w fun sp match sp with s a k s a o o fun o end each function in the record takes the record itself as its first parameter instantiated with one fewer step and all recursive calls are figure two jsref monadic operators through the record for example runs s c s eval the statement s in the state s heap of objects and ment records and in the evaluation context c used for variable definition runs s c rv e t result so long as the record runs contains functions for running runs s c e fun s v any kind of term programs statements expressions etc as a let b v in first approximation the reader may simply think of the projections as a direct recursive call to the function for evaluating expressions the function below uses a record runs built with a sufficiently large number to serve as a bound on our recursive calls since the bound is handled by this record it does not our main development if b then s c t fun s r let rv r then r else rv in let loop fun s c rv e t in r r definition runs p result p then r r then s rv an evaluation using a function from jsref returns a result else r which is either a completed computation or a special token that states the interpreter has reached an impossible state or that the computation did not terminate in the allocated time as with then s r else loop tt else loop tt else s rv jscert the type of the result may depend on what is being definition runs s c t result typically for internal reductions we thus define the following match t with polymorphic type ls e t inductive t s c ls e t t t figure jsref semantics of while loops state t the token is returned by the interpreter if an invariant of the javascript language is violated eg if the es internal method is called on a primitive value we claim that starting from a wellformed initial state the interpreter will never return because we conjecture than all invariants are preserved by execution as first approximation terminating programs have a result of type out as defined in § except that is never used whereas internal reduction have a result of type t for some t in fact for purpose of better code terminating programs have the following result type which is isomorphic to out inductive nothing type definition result nothing since there is no of the nothing type the only way to obtain a of the result type is through which carries a value of type out this approach guarantees that every result type is an instance of t t greatly simplifying the definition of monadic operators programming in jsref in order to avoid jsref is in a monadic style for example say we want to evaluate a composite expression e which contains subexpression e first we evaluate e if this evaluation terminates with a completion triple of type normal then we want to use the value produced by e however if the evaluation of e produces either or we want to propagate this result immediately without executing the rest of the code for processing e in jsref this pattern requires a simple use of the monadic operator s c s v where the contains the code for processing the result value v of e in the updated state s fig shows the definition of it depends on which first filters out the cases where the computation failed otherwise the continuation k is called on the result the function constructs such a continuation fun sp which ensures that the result of the computation is not an termination a result of the form o where o satisfies the predicate abort jsref function for while loops fig shows the function used to interpret while statements the three first arguments have been described before arguments e and t are respectively the condition and body of the while loop argument is a set of labels annotating the loop to deal with break and continue statements finally rv is the current value to return in the completion triple it corresponds to the v of fig intuitively calling this function amounts to executing the javascript statement starting from heap s and execution context c as we reuse this function for the next step of the loop we also need to carry around the last computed value rv as shown in the extract from rv is initially set to the empty value we now detail the code of the loop we first evaluate the condition e and capture its result using the continuation fun s v remember that this continuation runs only if the result of the computation is successful and if it is not an termination the value v is then converted to a boolean to choose which branch of the if to execute if it is false the else branch is taken line and the current state is returned with the last computed value rv to the triple otherwise the statement t is evaluated using the monadic operator this operator is very similar to except that it applies the continuation even if the result is an termination this allows us to check for a break or continue result from running the statement lines and update rv if the result value of the statement was not empty we then the termination type of the result to proceed line is taken if it is a continue with its label in otherwise if the result is a break with its label in then the computation terminates as a normal result line if the result is not normal eg a return or a break with a different label then it is returned as such line then branch finally if the result is normal then the next iteration of the while loop is run else branch note how the while loop code in jsref is more concise than that in jscert this observation applies in general to most parts of the definitions overall the full definition of jscert is lines of coq whereas the corresponding definition of jsref is lines running the interpreter the coq system provides a way to automatically extract ocaml code from the definition of computable functions this is crucial to our ability to run our interpreter and test it against existing test there are experimental tools that allow the extraction of ocaml code directly from an inductive definition such as the one of jscert we did not this approach for the following reasons these tools are not yet the development of jsref is independently interesting and this way we could make natural choices when es was at the of some trust coq provides the ability to locally the default mapping from coq values and types to ocaml values and types of course this feature should be used we use it in two ways first as previously explained we rely on an untrusted parser more precisely our development assumes the existence of a parser returning either some ast or none in case of a parse error axiom string option prog in order to run tests and execute the eval operator we provide an ocaml function that implements by calling an existing javascript parser and then translating the output to the ocaml representation of our ast for javascript code the second numbers in javascript all numbers are ieee double precision floatingpoint numbers in our we use the library to precisely model ieee floatingpoint numbers and their operations since the ocaml type float corresponds to ieee it is safe for us to extract javascript numbers directly to ocaml float similarly we provide direct ocaml implementations for other operations on numbers mentioned in es such as conversion to and from int types evaluation establishing trust an important aim for us was to design jscert and jsref in such a way that they could be evaluated and hence eventually trusted by eg authors of javascript virtual machines designers of secure subsets or compilers javascript and developers of javascript analysis tools in this section we describe our methodology for establishing trust how to extend our results in future to such trust and the bugs that we have found in es and es test and several major our methodology for establishing trust involves four components the standard es and the test suite test our work the specification jscert and the certified interpreter jsref are introduced in this paper we establish connections between es jscert jsref and test to justify our claim that jscert and jsref have been designed in such a way that they can be evaluated and trusted we also explore ways of establishing further connections in future we have constructed jscert to be as close as possible to es and have proved jsref correct with respect to jscert independently have developed test to cover as many aspects of es as they reasonably could we have been able to check that jsref behaves as expected on all the appropriate tests given our coverage of es jscert and jsref can therefore be through two distinct paths through the correspondence with es and through the execution of tests by our reference interpreter having these two independent paths significantly decreases the of bugs remaining in jscert connections to establish trust as discussed in § we have designed jscert to be as close to es as we can we follow the es data structures precisely every line of in es corresponds to one or two rules in jscert and our code is to make these explicit with basic training in reading coq specifications should be able to check the correspondence between the es and our jscert definitions we have chosen to differ from es at a few places we make explicit several constructs that are left implicit in es to help with the that jscert is a correct of es unlike es we treat the state exceptions and divergence explicitly we always mention the current evaluation context and strictness flag whereas es only describes places where they are modified moreover contrary to es in jscert we do not use a repeat statement but rely instead on an explicit controlflow jump we did experiment with an higherorder intermediate form to capture repeat loops in the inductive semantics however we that it the definitions and added for very limited benefit setting aside these differences in the style of presentation we believe that jscert is close enough to es that at least several authors should be able to proof read our definitions correctness we have formally proved in coq that jsref is correct with respect to jscert more precisely if the jsref interpreter evaluates program p to output o in a finite number of steps bounded by n then it must be the case that the program p is related to the output o by the inductive semantics of jscert more formally the coq statement of the theorem is theorem runs n p o p o where corresponds to the evaluation judgement p to the initial state the proof of this theorem consists of lines of coq and is relatively straightforward we the code of jsref line by line following the case analyses and the function call performed and showing that each of these operations corresponds to the application of one or two evaluation rules from jscert more precisely recall from § that jsref is written in a monadic style to step through the code of jsref we need to reason about the behaviour of the monadic operators to do this we prove for each monadic operator a lemma specifying its behaviour we then define a custom coq tactic that looks at the head monadic operator of the jsref piece of code at hand and automatically applies the corresponding lemma thanks to this tactic we are able to the reasoning on the termination cases as a result our proof script basically consists of case analyses and calls to our custom tactic with the names of the evaluation rules to be applied given as arguments as we were proving correctness we were able to detect and correct many and also a small number of more serious of es jscert and jsref were developed by different researchers despite close interaction between researchers there were in interpretation between jscert and jsref which were up during the course of proving correctness this proof is a of our work as it enables us directly to validate our jscert specification with testing tests we ran jsref against test the es test suite jsref successfully executed all the tests that we expected it to pass given our coverage of es in test there are tests by there are no tests for ­ and relate to the parser rather than the language chapter corresponds to native libraries and there are some additional test eg best practice and intl which we do not study there are main tests associated with ­ our of these we pass we have been able to check with the help of search tools that all the remaining tests fail because either they use or they use chapter library which we have not implemented or they fail due to the closure parser being slightly more permissive than es and hence not failing where expected running jsref over of tests has been very useful as it allowed us to detect and fix several bugs in jsref and jscert most of these bugs were simple but a few of them were more serious eg converting a record to a data property instead of a data increasing trust in jscert and jsref since we are discussing trust we to also recall that by design the correctness of our development relies on the formal tools formal libraries parsers compilers and glue code involved in our tool chain more precisely trust in jscert and jsref requires trust in coq extraction mechanism the ocaml compiler the closure parser our glue code for linking the parser to the extracted code of jsref and our glue code for binding boolean and floatingpoint javascript values to their ocaml counterparts there are three main ways in which we may further increase our trust in jscert and jsref by establishing for most of the evaluation rules for jscert by establishing the completeness of jsref with respect to jscert and by using a analysis of jsref to help us complete existing test so as to cover all aspects of es the last two correspond to the dotted arrows in the following diagram correctness running tests es jscert jsref tests completeness test generation es does not explicitly say that the semantics of javascript is deterministic yet it turns out that with the exception of the statement and constructs the standard only describes deterministic behaviour we should be able to prove this such a proof would ensure that jscert does not contain errors leading to more behaviours being accepted by jscert than es if jscert was erroneous in this way it could eg the verification of tools that compile other programming languages into javascript in future we would like to prove in coq that jscert is deterministic we have not to do this proof yet due to a limitation of the tactic of coq this tactic leads to an unnecessary quadratic explosion of the size of the when performing a nested case analysis on two derivations precisely what is necessary for proving we are waiting for the release of the new tactic under development which should enable us to build proof terms of size linear in that of the proof we would also like to prove the completeness of jsref with respect to jscert currently when executing a javascript program that terminates within a reasonable amount of time our interpreter might in theory return or instead of the expected result note that as established by the correctness result if jsref produces some result then it must be the right result in practice on all the tests that we considered we never obtained or this situation is very to happen because from looking at the source code of jsref it appears obvious that we never return except when the bound on the number of steps is reached and it is relatively straightforward to check we would only return if the invariants on the state eg there are no pointers were to be broken that said it would be more satisfying to prove in coq that if a program is related to some output using jscert then executing this program using jsref would produce the same output the reason we have not done it yet is because the invariants on the states involved are numerous and quite to define and because completeness is not critical to safety another way to increase the trust in jscert and jsref would be to extend existing test so as to include sufficiently many tests to cover all the paths of es with such full coverage we would significantly increase the degree of in the correctness of jsref through the testing path the community that the test coverage needs improvement and in fact has a open bug on the test need review of existing test coverage versus es using jsref in combination with a coverage analysis tool for ocaml programs called the tool we have been able to the lines of jsref that are never executed by any test program we therefore have at least some technology for the coverage of jsref and hence of es provided that jsref does not miss entire pieces of es we need more to extend test with the missing tests an alternative approach to producing tests manually would be to generate them automatically by using automated theorem provers to exhibit tests whose execution is able to reach a particular line of jsref code as these tests would be generated from jsref they would certainly not trigger bugs in jsref however if these tests were to fail on other javascript virtual machines then we would know that there is either a bug in jsref or in the virtual machines this alternative approach to producing tests would increase our trust in jsref by showing that it mainly behaves like existing javascript implementations on tests that cover all of its source code and by where it diverges from particular implementations bugs discovered through our work we have been trying to understand and express in coq the semantics of javascript including its to understand the semantics intended by authors and the semantics intended by of javascript virtual machines we not only at es but also at the next version of es at several test and at the behaviour of the major we bugs in all of these places obtaining from authors and javascript that they were indeed bugs in es we discovered three bugs ranging from simple to an informative algorithm which did not correctly implement the behaviour it was in test we discovered three bugs the most interesting being a test which contains code that seems to do nothing and whose purpose is unknown to the current v and implement enumeration in the presence of as used by this was discovered by and by ourselves all browser implementations give different incorrect completion values for finally also discovered in part by in addition we observed in v that dead code after a block may change the value that is returned by the block finding bugs in standards and tests was not the main motivation for the work presented here the bugs mentioned are simply a side effect of to understand es well enough to build jscert and jsref in future we hope to use jsref to construct more complete test for potentially detecting unknown bugs in existing conclusions and future work this paper a scientific method for developing a trusted specification of a programming language we focused on javascript because the language is and will continue to be used by many people the standards are quite and still and for many applications javascript programs need to be secure there are a few key tools used to support language see related work we used the coq theorem prover because it supports proof as well as specification and it has a mechanism for extracting executable ocaml code we have introduced jscert a coq specification of es and jsref an executable reference interpreter which is provably correct with respect to jscert jscert closely corresponds to es following its natural modularity jsref is tested against test our design methodology means that assuming you trust coq if you trust either the connection to es or the tests you can trust both jscert and jsref it remains to be seen what impact might be possible with the standards for es which is the end of its development we have bug reports and are having discussions with some of its authors for es our work demonstrates that it might be feasible for a coq specification to at nearly the same time as the standard one key question is what might we be able to offer the standards it is not our role to make key design decisions for we do however believe that providing an specification the standard would add significant value for tool developers and language moreover an executable reference interpreter that provably with the coq specification and passes the tests can help validate language implementations or optimisations by providing an oracle to define the expected results of new tests we have many future to begin with we would like to increase as much as possible the trust in our definitions as explained in § by and completeness in coq by running additional test eg tests and by designing new tests towards achieving full coverage of es then we would also like to extend our first it could be interesting to investigate the of parsing second we may want to behaviours third we would be interested in extending our work to es and es we are of course also interested in many of the practical applications of our work as discussed in § acknowledgements we are to the popl reviewers for their comments and suggestions we would like to thank our for help with testing and debugging and benjamin for his help in setting up the code coverage tool and are partially supported by the and are supported by grant and smith are partially supported by grant and grant is supported by an references j l s sarkar and p sewell in weak memory models in proc cav nd international conference on computer aided verification lncs pages ­ c p and s towards type inference for javascript in ecoop pages ­ springer a w appel verified software talk in esop pages ­ m s s sarkar p sewell and t c concurrency in popl pages ­ m m and a library abstraction for cc concurrency in popl k a and s languagebased against untrusted browser in usenix security symposium s m m p sewell m smith and k engineering with logic hol specification and testing for tcp implementations in popl pages ­ s and x leroy mechanized semantics for the clight subset of the c language j reasoning ­ e n g v and r f a highlevel modular definition of the semantics of c theor comput sci ­ c a semantics in esop pages ­ r and r jhala dependent types for javascript abs r j a r jhala and s staged information flow for javascript in pldi pages ­ acm x compcert team compcert d making javascript safe for http s and s is the java type system sound in international test c and g an executable formal semantics of c with applications in popl pages ­ a f chen j and g formal analysis of java programs in in cav pages ­ c fournet n j chen py and b fully abstract compilation to javascript in popl pages ­ free software foundation c language version html d test bug p s and g d smith towards a program logic for javascript in popl pages ­ acm inc the closure compiler s and v b mostly static enforcement of security and reliability policies for javascript code in usenix security symposium pages ­ s m o j s and r the world wide web from javascript in pages ­ a c and s the essence of javascript ecoop pages ­ y algebras in ifip pages ­ d and a sabelfeld informationflow security for a core of javascript in pages ­ ieee d and c flanagan status report specifying javascript with ml in ml pages ­ d and k pointsto analysis for javascript proc of page s h a and p type analysis for javascript in sas springer d k lee k crary and r harper towards a mechanized metatheory of standard ml in popl pages ­ s and a languagebased isolation of untrusted javascript in ieee s j mitchell and a operational semantics s j mitchell and a an operational semantics for javascript in pages ­ springer s j mitchell and a javascript with filters rewriting and wrappers in springer s j c mitchell and a object capabilities and isolation of untrusted web applications in security and privacy sp pages ­ ieee g for coq r milner m tofte and d macqueen the definition of standard ml mit press cambridge ma usa isbn automated javascript tests t l c and m a proof assistant for higherorder logic volume of lecture notes in computer science springer m c in hol phd thesis computer lab university of cambridge d s p and a lightweight self javascript in acm press c park h lee and s an empirical study on the of the with statement in javascript in c park h lee and s safe formal specification and implementation of a scalable analysis for in f pfenning and c system description a framework for deductive systems in pages ­ j g s a a and s typebased verification of javascript in usenix security symposium j g m j b s j and s a tested semantics for and eval in javascript sigplan not ­ oct j g b s h q de la t nelson a m and s mechanized js g c b and j the eval that do a study of the use of eval in javascript applications in ecoop pages ­ springer g and t f an overview of the k semantic framework journal of logic and algebraic programming ­ t convert some array to js implementations p sewell f z s g t s sarkar and r effective tool support for the working j program ­ d proving java type soundness in formal syntax and semantics of java pages ­ a Ú j c mitchell m s and j automated analysis of javascript in ieee symposium on security and privacy pages ­ the jscert team bug v issue es bugs test bug p towards a type system for analyzing javascript programs in esop pages ­ springer various developers bugs in es test and http ­ j v vafeiadis f s and p sewell concurrency and verified compilation in proc popl 