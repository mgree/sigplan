an abstract interpretation framework for termination cousot and inria france institute usa cousot and inria france abstract proof verification and analysis methods for termination all rely on two induction principles a variant function or induction on data ensuring progress towards the end and some form of induction on the program structure the abstract interpretation design principle is first illustrated for the design of new forward and backward proof verification and analysis methods for safety the safety collecting semantics defining the strongest safety property of programs is first expressed in a constructive fixpoint form safety proof and methods then immediately follow by fixpoint induction static analysis of abstract safety properties such as invariance are designed by fixpoint abstraction or approximation to automatically infer safety properties so far no such clear design principle did exist for termination so that the existing approaches are and largely not comparable with each other for we show that this design principle applies equally well to potential and definite termination the termination collecting semantics is given a fixpoint definition its abstraction yields a fixpoint definition of the best variant function by further abstraction of this best variant function we derive the termination proof method as well as new static analysis methods to effectively compute approximations of this best variant function for we introduce a generalization of the syntactic notion of structural induction as found in hoare logic into a semantic structural induction based on the new semantic concept of inductive trace cover covering execution traces by segments a new basis for program properties its abstractions allow for generalized recursive proof verification and static analysis methods by induction on both program structure control and data examples of particular instances include handling of loop cutpoints as well as nested loops assertion total correctness proof method and transition invariants categories and subject descriptors d verification d formal definitions and theory f specifying and verifying and reasoning about programs general terms languages reliability security theory verification keywords abstract interpretation induction proof safety static analysis variant function verification termination introduction program proof methods for invariance and termination have inspired most sound static analysis methods for static invariance analysis by abstract interpretation a key step is to express the strongest invariant as a fixpoint and next to approximate this strongest invariant to automatically infer an abstract inductive invariant using the constructive fixpoint approximation methods for static termination analysis the discovery of variant functions is either decidable in limited cases or else is based on the idea of variant functions into wellfounded sets work supported in part by the nsf in computing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm obtained by observing that strictly decrease within loops while remaining or so most termination analysis methods indirectly reduce to a relational invariance analysis hence can reuse classical static analysis methods the abstract interpretation design principle is instantiated with suitable abstractions for safety and termination analysis proof and either potential termination or definite termination for nondeterministic systems the first main idea for termination is that there exists a most precise variant function that can be expressed in fixpoint form by abstract interpretation of a termination collecting semantics itself abstracting the program operational trace semantics this yields new static analysis methods automatically inferring abstractions of that variant function by the constructive fixpoint approximation methods of abstract interpretation the second main idea introduced in this paper both for safety and termination is that of semantic structural induction including termination proofs over trace segment covers and their abstractions trace segments are more powerful than binary relations between states which have been used traditionally in program termination proofs for example the transition invariants used in are binary relation abstractions of the set of trace segments examples include structural induction on the program syntax including loop invariants à la induction on data à la burstall the covering of the transition relation closure by wellfounded relations à la their combinations and fixpoints fixpoint induction abstraction and approximation we express semantics as fixpoints of maps f a a ie elements x f a such that x a a on the f x we poset a f be than the least fixpoint of or equal to a a if any the dual notion is that of greatest fixpoint f we write lfp f if a is the of a and lfp f if the partial order is clear from the context by fixpoint theorem aa lattice a p f p a p exists for f increasing or on a cpo a a the fixpoint iterates are f a n n f n f f n which if f a is a and f not continuous iterations may have to be used f a a is increasing also monotone on a poset a if and only if x y a x y f x f y a complete lattice a is a poset s t any subset has a least upper bound lub hence a greatest lower bound a complete partial order cpo a is a poset a such that any increasing chain c a such that x y c x y y x has a least upper bound lub c hence has an for the empty chain f a a is continuous on a poset a if and only if for all increasing chains c a such that its lub c does exist then the lub f c exists and is such that f c f c x or x is the powerset of x ie the set of all subsets of a set x the or image of x a by a map f a b is f x f x x x b fixpoint induction follows immediately as a sound and complete proof method since for all s a f s p a a p f p p p s s is called a specification or invariant and p is an inductive invariant the idea is that to prove an invariant s one has to check in methods to guess in proof methods or to compute in analysis methods a stronger inductive invariant p following abstraction is formalized by galois tions that a a b b b between posets a and x a a y and b b x meaning y x y we write a b when the hence the concretization is injective when is injective hence is and when is abstraction a a is b b given a concrete fixpoint characterization properties on complete lattices or cpos a f a of program f a and an abstraction a b the sufficient condition f f respectively condition f f implies the fixpoint abstraction f f resp fixpoint approximation f f the condition can be restricted to the iterates of f from a or to the elements of a which are less that or equal to also best holds when is continuous abstraction similar results in absence can be obtained using only one of the abstraction or concretization functions transition semantics we consider a programming language with nondeterministic programs p the set of all states of p is p the transition relation p p × p describes the possible transitions between a state and its immediate successor states during program execution the program smallstep operational semantics is the transition system p p when restricting to initial states i p p we write p i p p the states are p s p s p s s p for brevity we write x for x p eg i or trace semantics traces we let n nn n and be the set of all finite traces of length n n nonempty finite finite infinite nonempty finite or infinite and finite or infinite traces over the states where is the empty trace we define the following operations on traces writing for the length of the trace n m n m for the n n of and for the concatenation of with and when we define the following operations on sets of traces writing s for the set of traces s made of one state of s for example the termination states s s s s can also be understood as traces of length one s s t for the set of traces t made of two consecutive states of the relation t × t t for the selection of the nonempty finite traces of t t t for the selection of the infinite traces of also introduced of abstraction using closure operators ideals etc and showed all of them to be equivalent to galois connections is the pointwise extension of a partial order to maps f g x f x gx t t t t t for the concatenation of sets of traces and t t s s s t s t for the sequencing of sets of traces t t partial and complete maximal trace semantics the partial trace semantics p p of a program p is a set of nonempty execution traces in particular the partial trace semantics generated by a transition system is ¨ p such that p n i n i i p n p ¨ p i n i i p p ¨ p ¨ p p n the complete or maximal trace p p and p semantics n p p are p obtained by the abstraction mm where mt t n n p t eliminates those computations that are not terminated fixpoint trace semantics the partial trace semantics of a program p can be given in fixpoint form ¨ p lfp ¨ p lfp ¨ p p p ¨ p lfp ¨ p p lfp ¨ p ¨ p t p t p t p t ¨ p t ¨ p t t p p t where is a complete lattice for the computational order t t t t t t and t t semantics of p p p t lfp p p p and p lfp p t p p where p t properties following properties are represented by the set of elements which have these properties so the properties of programs which semantics are sets of traces in are sets of sets of traces in the collecting semantics p is the strongest program property of a program with trace semantics p the trace property abstraction of program properties is such that p p and q q the traditional program properties are relative to the trace property abstraction of the collecting semantics p p some program properties are not trace properties an example is all program executions are deterministic which is n m n n m is the closed interval when m n while n m n n m is left closed and right when m n strongest in that the collecting semantics implies all other program properties where logical implication a b is interpreted as a b the corresponding trace property abstraction is which would allow any nondeterministic behavior so that determinism in the concrete domain is completely lost in the abstract domain for safety and termination and from now on we only have to consider trace properties which form a complete boolean lattice ¬ where the partial order is logical implication and the complement is ¬x x safety trace semantics we now illustrate the classical abstract interpretation framework by generalizing invariance verification and static analysis to arbitrary safety properties safety properties are abstractions of program trace properties essentially about liveness properties safety abstraction the prefix abstraction of a set t of traces is the topological closure pf pf t the prefix abstraction expresses the fact that program executions can only be observed for a finite period of time t the limit abstraction of a set of traces is the topological closure t n n n t the limit abstraction expresses the fact that when observing program executions for finite of time it is impossible to distinguish between nonterminating and unbounded finite executions the safety abstraction of a set of traces is the topological closure sf lm pf pf lm pf the safety abstraction provides the strongest program property resulting from finite observations of program executions the observation of infinite executions topological closures a a on a poset a tions a a a are safety trace properties the safety trace properties are sf sf p p p we have the galois isomorphism sf pf where and so safety trace properties can equivalently be represented by their finite prefixes in sect and safety semantics the safety semantics of a program p is its strongest safety property sf p p pf p fixpoint safety semantics it follows by fixpoint abstraction that the safety semantics of a program p with operational semantics is assuming inputs if any to be part of the states x y x x x y is the set difference a topological closure on a poset a with partialorder and lub if any is a map a a which is extensive x a x x idempotent x a x x and finite x y a xy xy this implies that is increasing a closure is extensive idempotent and increasing a is the identity map respectively relation on the set a mapping any element x a to itself ax x resp a x x x a sf p lfp sf p lfp sf p where p p t t t p p t forward trace transformer backward trace transformer proofs in the safety trace domain by fixpoint induction one immediately gets new forward and backward sound and complete safety proof methods generalizing invariance for all safety specifications s sf sf p s p sf p p p p p s p sf p p p p p s observe that forward and backward safety semantics and proof methods are respectively equivalent this property is preserved by relational abstractions in next sect but this is not the general case eg with abstractions of sect is an example of static analysis in the safety trace domain invariance reachability semantics is an abstraction of safety and so invariance proof methods are abstractions of safety proof methods relational abstraction the relational abstraction sf rr × such that rt n n n t rr n n n r abstracts traces by a relation between their initial and final states so that intermediate computations are lost in that abstraction relational invariance reachability abstraction applied to a safety semantics which is the relational abstraction provides a relation between initial and current states where in particular initial can be any state the abstraction r sf is therefore equal to the relational reachability abstraction that r t i n rr × i n n t such r r n n i n i r abstract traces by a relation between their initial and current states relational invariance reachability semantics the relational semantics of a program p is its strongest relational reachability property r p r p r p p r p p r sf p fixpoint relational invariance reachability semantics the condition applied to the transformer of the safety semantics sf p yields the fixpoint characterization of the relational reachability semantics of a program p with operational semantics where r p lfp r p lfp r p in case a temporal logic is used for expressing the inductive safety invariant this is relative completeness subject to an expressivity hypothesis of the temporal logic ensuring p sf to be expressible in the logic see eg the or of x a by a relation r a × b is rx y x x x y r also written rr p p r r r p p r forward transformer backward transformer relational invariance reachability proof methods applying fixpoint induction to the fixpoint relational reachability semantics we get sound and complete forward and backward proof methods for a specification s × respectively generalizing and r p s r × r r p r r s r × r p r r r s variations on invariance reachability proof methods further abstractions yield other classical proof methods it is pos to restrict to the initial states i × where × ii ir s s s i s s r and the final states f where × ff × fr s s s s r s f it is also possible to use an invariant so as to restrict to the reachable states × rr where r r s s s r combining and we get forward invariance while and the inverse of yield backward invariance called induction in proofs by ad are obtained by × × where r termination trace collecting semantics our objective is now to apply the abstract interpretation methodology of sect as illustrated in sect for the safety properties and their invariance abstractions to termination starting from a collecting trace semantics we define termination properties by abstraction derive fixpoint by fixpoint abstraction proof and verification methods by fixpoint induction and design static analysis methods by fixpoint approximation using widening termination property the termination property states either that all executions in the trace semantics p of a program p must always be finite p p definite termination or that the trace semantics p may be finite hence must not always be infinite p p potential termination the infinite extension abstraction t t t t is a topological closure and so where is the identity we have p p p p p p p p and so if necessary we only need to consider semantics closed by termination trace abstraction the termination trace abstraction eliminates the program execution traces not starting by a state from which execution terminate example consider the example of the nondeterministic program b with states b l e transitions b l b e l l and complete trace semantics be e b l e potential termination trace abstraction the potential termination or trace semantics eliminates infinite traces example the potential termination trace semantics of program b in ex is be e since an execution starting in state b may terminate by choosing a transition to state e the corresponding potential termination abstraction is and where t s and s the abstraction about nonterminating executions this abstraction corresponds to weakest precondition it is considered in together with backward reachability to automatically compute necessary conditions for termination in example this analysis would yield the potential termination states b e proving definite nontermination in state l definite termination trace abstraction the definite termination or trace semantics eliminates all traces potentially branching through local nondeterminism to nontermination example the definite termination trace semantics of program b in ex is e since in state b there is a possibility of nontermination by choosing a transition to state l a trace is in the definite termination semantics if and only if it is finite independently of the potential nondeterministic choices along that trace the corresponding definite termination abstraction is t pf mt is a and onto but not continuous however on the following we consider only transition closed semantics ie generated by a transition system see counter example example if t ab ba bb ba then ab ba bb and ab since pf for ab this abstraction corresponds to precondition that is to the definite termination analysis we are mostly interested in for transition systems termination trace semantics the potential termination collecting semantics of a program p is therefore defined as a r a b where b a is increasing and idempotent we write r a b when it is onto consider the increasing chain tn i i n n we have n while n i i n so that mt n tn a mt p mt p potential termination semantics while the definite termination collecting semantics of a program p is defined as mt p mt p definite termination semantics fixpoint termination trace semantics by abstraction of the fixpoint trace semantics of sect the strongest termination property of a program p with operational semantics p p and termination states p is mt p mt p t mt p lfp mt p p p lfp mt p t mt p t p p t ¬ p potential termination definite termination where the term ¬ p eliminates potential transitions towards nonterminating executions proofs in the termination trace domain fixpoint induction provides formal methods to check fixpoint either mt p s or mt p s yield necessary but not sufficient termination conditions which may introduce spurious infinite traces for which the proof cannot be done the proof method is therefore useful to prove invariance under termination assumptions but not for termination on the contrary termination proofs require fixpoint s mt p or s mt p yield sufficient but not necessary termination conditions and so may eliminate some termination cases for which the termination proof could have been done automatically fixpoint underapproximation proof methods have been proposed eg by sect and would yield the termination proof methods more we will for static analysis termination domain programs may not always terminate in all states so one problem is to determine for which states i do executions starting from these states terminate termination domain abstraction this termination domain semantics is provided by the weakest precondition abstraction of the termination trace semantics such that ww wt t precondition abstraction termination domain semantics p p p p potential termination definite termination using notations p p true and p wp p true fixpoint termination domain semantics by fixpoint abstraction of the termination trace semantics in sect using transformer we get fixpoint weakest termination precondition semantics eg for ex b e l is invariant b e is invariant under potential termination hypothesis and e is invariant under definite termination hypothesis the of y a by a relation r a × b is ry x y y x y r also written while x y y y x y r is p p r p lfp w mt p p p lfp w mt p weakest r weakest termination precondition p r p p r ¬ p proof and static analysis in the termination domain as was the case in sect fixpoint induction is useful for which can be automatically inferred by static analysis on the contrary termination proofs require sect proof methods although static underapproximation analysis is possible eg this is not the termination proof technique which is used in practice termination proofs for the trace semantics generated by a transition system in practice a termination proof is decomposed in two parts first a necessary termination condition is found by p or p then this necessary termination condition is shown to be sufficient by variant function method eg or eg this corresponds to different abstractions specific to the trace semantics generated by a transition system that we now elaborate termination proofs a program which trace semantics is generated by a transition system definitely terminates if and only if the program transition relation is wellfounded p p is wellfounded in practice one considers traces starting from initial states i eg i is the termination domain of sect in that case a program which trace semantics is generated by a transition system definitely terminates for traces starting from initial states i if and only if the program transition relation restricted to reachable states is wellfounded ii p p p is wellfounded where the initialization abstraction is i initialization abstraction t i r and the reachable states abstraction is r rt s s t reachability abstraction the termination proof method is sound and complete as in sect the precondition i can be inferred automatically by static analysis moreover an overapproximation r p p i of the reachable states can be computed by classical abstract interpretation algorithms a relation w × w on a set w is wellfounded if and only if there is no strictly decreasing infinite chain x x xn xn of elements x x xn xn of w w is called a wellfounded set a total is wellfounded total strict order relation the set of all wellfounded relations in w × w is written × w t is the reflexive transitive closure of a binary relation t transition abstraction if the program semantics system we might consider p is not generated the transition abstraction by a transition p where the transition abstraction is × t s s ss t transition abstraction but the following counterexample shows that the condition is sufficient but not necessary counterexample let corresponding transition t ab ba relation be semantics a b b the a generates the infinite trace and so the transition relation restricted to the reachable states a b is not wellfounded another counterexample is fairness in the following we equivalently t is closed by elimination of strict prefixes closed by extension by fusion and closed by limits th variant semantics it remains to design verification and static analysis methods to show that r is wellfounded where r p p i the reachable states there are two important remarks if r and r r is wellfounded then r is wellfounded r is wellfounded if and only if there exists a variant function w into a wellfounded set w which domain is r so for the traces generated by a transition system termination can be proved by mapping invariant states to a wellfounded relation which is the principle of variant function method variant function a variant function w is a partial function from the set of states into a wellfounded set w where is a wellfounded relation on the set w and is its nonstrict version with appropriate hypotheses on states and the transition relation the codomain of the variant function can be fixed a priori and the variant function can be found by constraint solving eg however these methods are not as general as method in mathematics the provide a standard wellfounded set thanks to ranking functions mapping each element of a wellfounded set to its rank so up to a ranking function the wellfounded set w can always be chosen as the class o of the intuition is that any execution starting in a state dom must terminate in at most execution steps while an execution starting in a state dom might not terminate we have s s s dom s s and this relation is wellfounded on states proving termination variant abstraction a variant function is an abstraction of a set of finite traces it is a partial function which domain is the set of terminating states its a b resp a b is the set of partial resp total maps from set a into set b we write dom f for the domain of a partial function f a b and f for its codomain if f a b then dom f a for a proof take w to be the o and to be the rank of elements of r for the wellfounded relation value is an upper bound of the remaining number of steps to termination it may be for unbounded nondeterminism with unbounded execution trace lengths let us define rk × o ranking abstraction when s s s r sup s s s r extracts the wellfounded part of relation r and provides the rank of the elements s of its domain vt does the same for the transition relation by abstracting the set t of finite traces v vt s w variant abstraction it follows that the abstraction w v v mt holds for potential termination and w v for definite termination these abstractions state by def of that adding finite execution traces or infinite traces can only by def of v augment the termination domain and maybe increase execution times it follows that the computational variant order is v dom dom x dom x x variant semantics a variant function can always be found by abstraction of the termination semantics into a variant semantics mv p p potential termination variant mv p p definite termination variant this yields new termination proof methods and static analysis methods by abstraction of this fixpoint definition fixpoint variant semantics by fixpoint abstraction of the fixpoint termination trace semantics of sect we get the fixpoint characterization of the variant semantics mv p lfp v mv p potential termination mv p s s p sup s s dom s s p mv p lfp v mv p definite termination mv p s s p sup s s dom s s p s s s p s dom example consider the trace semantics as represented on the right we have represented below the fixpoint iterates for the corresponding potential and definite variant functions states are outside the variant function domain potential termination this can be generalized from o to w using y w the partial map the conditional is true a b a and false a b b definite termination the potential variant can be used as a runtime check of definite nontermination since beyond execution steps termination is this general observation is not in contradiction with the fact that termination is not at runtime since here it relies on a prior static analysis considering all possible executions example the definite termination of the following program p variant semantics lfp v mv p int main int x while x x x is the limit considering of the iterates only one loop head n n control n point of so from state can be reduced to the value x of x we have mv p x x sup x x dom the equation x x x x x x n x x × n x ÷ x x x ÷ termination proof method the variant semantics is sound and complete to prove termination of a program p for initial states i since ii p p i p o lfp v mv p v i dom ii p p i p o lfp v mv p v i dom applying fixpoint induction to check for the least fixpoint over approximation we get a termination proof method we have o mv p v lfp v mv v mv p p v mv v p fixpoint semantics of sect v v fixpoint ind def v and choosing s s p s s s p s dom s s s p s dom s s s def mv p p s dom s s s p s dom v since s s dom s s s s p implies s s s p p s dom s s s p s dom dom s dom s s s p s dom s s s p s dom s joins partial functions with disjoint domains f fx fx if x dom f and f fx fx if x dom f where dom f dom f ÷ is the integer division def v for s dom s dom s s p s s s p s dom s s def sup w w s dom s dom s s p s s s p s doms s since an is the order type of a wellfounded set i w w s i s i s s p s s s p s i s s choosing i dom this design yields the following definite termination induction principle ii p p definite termination proof i w w i dom s i s i s s p s s s p s i s s a similar design yields the potential termination induction principle ii p p potential termination proof i w w i dom s i s i s s p s i s s p s i s s observe that the fixpoint variant semantics of sect is calculated backwards the variant function increases on previous steps but that the termination induction principles proceed forward the variant function decreases on next steps example a similar induction principle is proposed in ch for relational proofs a state must be reached that relates to the initial state as given by a specification relation the following example is used in ch to show that the invariant and variant function must also be relational that is relate the current and initial state i x x x x we can prove termination with assertions no relational invariants being needed for the above example choose i w this example shows that termination proofs are simpler than proofs example for the program of ex the definite termination proof for the simplified transition system p x x x x x requires i z w n x x x ÷ and proving x x z x x x x x x x x because method uses the reachability abstraction r of it is not possible to directly relate states occurring at different times during computations this is why the program is transformed by using auxiliary variables to relate the current values of the variables to their past values this induces a transformed transition system which under the reachability abstraction r is equivalent to the relational abstraction of the original transition system by the relational abstraction example ex the program is transformed into int main int x x while x x x x x which consists in reasoning on the transformed transition system the abstract domain is therefore the case of blocks with p x x x x x x x x p this is an abstraction × × such that for not in the domain and a x zn ji i in for unknown xi ji i a xj ji i x x x x x x x x ji mi the benefit is that a relational abstraction r used with is equivalent to a reachability abstraction r for however in both cases a limitation is that for a given control point it is only possible to refer to one past instant of time when control is at that program point which is a limitation when compared to the more flexible reasoning by induction on traces see sect i n i · · · ji i ··· mi i a j ji i qn ji mi xi ji i ji i a xj ji i ly q i the n ji mi are this classical abstractions of intervals variant abstraction analysis we get a termination static analysis by abstracting the variant seman tics we need an abstraction many abstractions of functions o v have been of functions that can be reused for termination static analysis as a simple example linear inequalities and segmentation an immediate generalization consists in using consecutive segments with symbolic bounds as done in for array content analysis a further generalization consists in using decision trees instead of a segmentation of the domain of the abstract variant function we consider a linear variant abstraction the purpose of linear variant abstract transformers this new abstract domain is to illustrate the abstraction of fixpoint definitions of variant functions with widening many more abstractions being necessary to cover all practical cases linear variant abstraction condition in tests may split the block into for which the let us consider a program with integer variables x x xn condition is true or false n we first apply an abstraction of states extracting the numerical example here is an example of first iteration of the backward variables in the form of an environment x x z so that by composition we are left with an abstraction x z o map using a encoding the partial in the domain map by a total and abstracting higherorder by eg in case of nontermination or unbounded nondeterminism we can choose x z n there is no loss of information for bounded determinism and unbounded executions are still allowed termination the exit enforces termination in steps the test splits the block into and xx i to nontermination ji ·· x of the example assuming and n i a x of the form linear expressions assuming is the and is ji i ji ji ii mi i n ji i ji i the so that the domain comparison of sect is ji i wa here the x q ka n or by the fact that the undefined is used outside this j ji i i i j ji i k for example in two dimensions example y m x x x a x a x a x m more we should write the dot product a · x x j n ji i x s i s s potential termination x x the blocks of the partition are therefore i choosing i dom s p s termination induction ji ji ii dom r do n ni i ji i x v a a a a a a v × xy x fixpoint relational variant semantics by fixpoint abstraction of the fixpoint variant semantics of sect we get by design the fixpoint definite and potential relational variant semantics p lfp × p potential termination p d r let d d p p d in d s s p s s s s p s d s r p lfp × p definite termination p d r s let d d p p d p d in d s s p s s s s p s d s r s s s p s d s r the overapproximation of d is classical in static analysis so we concentrate on the overapproximation of the relational variant r termination analysis we consider the case when states s consist of a pair µ of a control state used for state or trace partitioning and a memory state µ the memory state maps variables x x to numerical values µx z for simplicity all other types are ignored in the examples we consider a of the fixpoint relational relational we choose w n and adjoint an extra variable to contain the value of we can use polyhedra polynomials their numerous variants possibly partitioned on states traces or conditions of decision trees example consider the program of ex where a forward interval analysis has determined the invariants given as comments int main int x x while x x x x x x the abstraction of the fixpoint equations of sect is given below in logical form representing a set by its characteristic predicate with restriction to the reachable states by the interval analysis rx x x x x x rx the assignment yields the classical simplification rx x x rx partitioning into rx rx x and rx rx x the iterates for rx immediately converge while the iterates for rx abstracted with are the dual of y a by a relation r a × b is ry also written rx false rx x x rx rx x rx rx x x x abstraction of rx x rx rx x x x abstraction of x x widening with rx rx rx proving termination since strictly decreases around the loop and remains positive of course direct resolution methods would find the same result however tests are within loops in while the presence of tests is not the above abstraction or the linear variant abstraction of sect for example the loop body if odd x x x else x x with state partitioning on the conditional branches yields the same results semantic structural induction semantic structural induction is by induction on the structure of computations as opposed to verification based on an induction on the program steps as in method this point of view generalizes syntactic structural induction on program syntax as in hoare logic replacing the syntactic by a semantic point of view using the concept of structural inductive cover we start by the simple case of structuring states in next sect before generalizing to the more concrete trace computations in sect and their abstractions in sect inductive state cover many inductive formal definitions and verification methods can be formalized in a way by an inductive cover of the set of states examples are given in next sect definition an inductive state cover of a nonempty set of states is tree encoded as a set c c of finite sequences s of nonempty members b such that if s s c then s c if s c then s s s if s bb c then b b root if s bb c then b b cover s bb c by the condition def the inductive cover is a tree so that proofs based on the cover c are by case analysis on the tree width and induction on the tree depth by the root condition def the tree is rooted at which ensures that inductive proofs based on the cover c are valid for by the condition def the sequences s are necessarily finite so the immediate component relation between a node of the tree and its sons is wellfounded it follows that proofs on states can be done by induction on this wellfounded relation and by the covering condition def the states in a node are covered by the join of the states in its sons which ensures that proofs based on the cover c do not any possible case inductive state covers are abstractions of inductive trace covers introduced in sect but are introduced first for simplicity an example is e lf c e l cb b fp f ep lb e d f d c bc examples of structural induction a l p to strictly decrease at each program step a d l b db hs ll l hs hs ll l hs lp b b the inductive cover contains the pro hs but only once around each loop iterate this corresponds to a cover of the states of the loop according to their control component which induces a decomposition of executions into trace segments for the loop containing trace segments for the loop body considered as one step in the inductive reasoning on loop iterations a b cb cb cb a b cb cb cb c c c c d d gram p the p ic execution blocks p hs p hs p proofs by respective recurrence on and the with l l l l hs l observe that the termination analysis method of can be seen as implicitly relying on proof method variant function is used for each loop so that m is applied recursively for nested loops hoare logic inductive in the form of structural induction on the program syntax from axiomatic semantics denotational semantics and operational semantics hoare logic for a structured imperative language and its extension to total correctness can be understood as the inductive state cover based on the control states of a command ignoring its memory states for example a while loop can be covered by the states which control is in the condition and the states which control is in the loop body the states of the loop body can themselves be covered recursively by structural induction on the program syntax this structural induction on the program syntax can be understood as induction on a state cover which itself induces a cover of the execution traces by segments which states are in a block of the state cover a termination proof by structural induction on the program syntax has the advantage ao to be able to handle unbounded nondeterminism without requiring equivalent to a ordering on nested loops p e lp lf c e fl e pd p bl cf bc b f e b d c b db p pf pl ple ad ca c semantic structural induction the previous examples of sect show the need to go beyond purely syntactic induction and that induction on states can be generalized to induction on trace segments consequently we introduce a general form of inductive reasoning on the semantic structure of computations first starting by induction on blocks of trace segments and then their abstractions in sect trace segment abstraction we first observe that considering segments of traces is an abstraction the segment abstraction t t is the set of segments of traces of t if t t we define tt t t t t to mean that all traces of t are segments of the traces of t we define the join ti ti i in k n ik i i to be the set of all the traces made out of segments in the ti i inductive trace segment cover definition an inductive trace segment cover of a nonempty set of traces is a set c c of sequences s of members b of such that if s s c then s c if s c then s s s if s bb c then b b if s bb c then b b root cover s bb c example an example of inductive trace segment cover is trace partitioning burstall assertion proof method total correctness proof method can be understood as an inductive reasoning by recurrence on data as well as control as in and methods although proof method is equivalent in power to method it is much easier to use in practice the formalization of total correctness proof method in can be understood as a tree cover on both control and data the example below shows how execution hs and lemmas l l apply to a particular execution trace example a variant function n defines a trivial inductive trace cover each value v defines segments starting with states such that v of length at most v the following definitions are classical for trees c c b s s b c s s bs c b s b s s bb s c b b s s s bb s c the immediate component relation b c b b s s bb c is wellfounded so that proofs on segments can be done by induction on this wellfounded relation the component relation c is its reflexive transitive closure the blocks of a cover c are b b c state cover induced by an inductive trace cover given an inductive trace cover c c of def define the abstractions s c c s s s ts b b ts i i then is an inductive state cover in the sense of def trace cover induced by a inductive state cover given an inductive state cover c c of def define sts s sts s c sts sts b c s s b we have inductive trace cover of and is an syntactic trace cover similarly one can define the inductive state cover induced by the syntax of commands of a programming language by considering the states which control is in a given command this in turns induces a trace cover which is the basis for eg hoare logic or structural static analysis by induction on program commands as opposed to induction on program transitions as in dataflow analysis inductive proof method we have a sound and complete inductive proof method of a semantic property p p for an inductive trace cover c c p b p b basis b p b p b p p b induction in particular for termination p p with a trace cover c c p we get p b b basis b p b p b b induction example another form of decomposition of on termination is proposed by the transition invariants proof method of based on a relational semantics the transition invariants proof method of can be seen as the r abstraction of the above inductive proof method based on an inductive trace cover of height with root p and sons t tn where t tn p such that p p i n p ti the generalization by inductive trace covers is both on the use of trace segments instead of their relational abstraction of sect and the possibility of recursive application of the method by induction including on data à la burstall abstract semantic structural induction assume that we can prove a program trace property in the concrete using an inductive trace cover can we prove an abstract program property using the abstraction of the inductive trace cover we have seen an example in sect the question is whether this observation is general abstract inductive cover definition an inductive abstract cover of a trace semantics is an element c ac of an abstract domain ac such that ac c and is an inductive trace cover of a standard way to define such inductive abstract covers is to follow the example of sect generalized to a block we get the cover abstraction by generalizing ta to such abstract sequences as follows s s c s s ab c ab then ac is chosen to be the set of elements c ab of sequences s of members b of ab such that if s s c then s c if s c then s s root if s bb c then if s bb c then cover s bb c it follows that any c ac is an inductive abstract cover of the trace semantics in the sense of def example the transition invariant proof method of follows from the relational abstraction × where n n b n is limited to the trace covers of the form given in ex abstract inductive proof the inductive proof method of sect can be abstracted as follows at p c b b basis b at p at p c b c b b induction the proofs at p c b can be done in the abstract by fixpoint induction using a fixpoint abstraction of the fixpoint definition of the trace semantics p related work most directly relevant work has been in the text for programs with unbounded executions any finite abstraction must introduce a loop so that finite modelchecking or bounded modelchecking are or unsound to prove termination or nontermination nevertheless predicate abstraction remains applicable since it is a finite encoding of an infinite abstract interpretation with predicate abstraction the is left with the hard problem of providing candidate variant functions as in moreover shows that abstractions with as considered in this paper are definitely strictly more powerful than finite abstractions the computation of variant functions by abstraction is new and different from the counterexample ways to find disjunctive ranking functions used in tools like and derivatives conclusion abstract interpretation has established constructive principles for reasoning about semantics a semantics is a fixpoint so proving a semantic property at some level of abstraction consists in verifying properties of abstract fixpoints which have to be checked in methods in proof methods or automatically inferred or approximated in static analysis methods this principle was mainly applied in the past to invariance and indirectly to termination by reduction to invariance we have shown that the abstract interpretation principle directly applies to both safety generalizing invariance and termination moreover we have generalized the classical syntactic structural induction into the semantic concept of semantic structural induction based on abstractions of inductive trace covers which includes induction on syntax control states memory states and execution trace segments and thus generalizes all verification and static analysis methods this methodology allowed us to establish new principles for proving termination by abstract interpretation of a termination semantics it remains to design a suitable collection of abstract domains beyond the examples proposed in this paper and the corresponding implementations the present abstract interpretation termination framework has to be extended to liveness and more generally to under fairness hypotheses references i a pnueli and l modular ranking abstraction int j found comput sci ­ a a e clarke o and y bounded model checking advances in computers ­ r burstall program proving as hand simulation with a little induction information processing ­ northholland e clarke o and d model checking mit press m and f journal of computer security ­ b cook and e making with decision predicates popl ­ b cook a a podelski a rybalchenko and m proving that programs eventually do something good popl ­ b cook s gulwani t a rybalchenko and m sagiv proving conditional termination cav lncs ­ b cook a podelski and a rybalchenko summarization for termination no return form methods syst des ­ s cook soundness and completeness of an axiom system for program tion siam j comput ­ p cousot de construction et de points fi un de sciences math p cousot semantic foundations of program analysis program flow analysis theory and applications ch ­ prenticehall p cousot the design of a generic abstract interpreter m and r eds system design series f press amsterdam p cousot partial completeness of abstract fixpoint checking lncs ­ p cousot constructive design of a hierarchy of semantics of a transition system by abstract interpretation p cousot verification by abstract interpretation proc int symp on verification ­ theory practice lncs ­ p cousot proving program invariance and termination by parametric abstraction relaxation and programming lncs ­ p cousot and r cousot static determination of dynamic properties of programs proc nd int symp on programming ­ paris p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints popl ­ p cousot and r cousot static determination of dynamic properties of recursive procedures formal description of programming concepts ­ northholland p cousot and r cousot systematic design of program analysis frameworks popl ­ p cousot and r cousot constructive versions of fixed point theorems p j of math ­ p cousot and r cousot induction principles for proving invariance properties of programs tools notions for program construction an advanced course ­ cambridge university press cambridge uk p cousot and r cousot À la induction principles for proving properties of programs algebraic methods in semantics ­ cambridge university press cambridge uk p cousot and r cousot always recursion always on the equivalence of the and invariant assertions methods for proving properties of programs informatica ­ p cousot and r cousot abstract interpretation frameworks ­ p cousot and r cousot comparing the galois connection and approaches to abstract interpretation lncs ­ p cousot and r cousot inductive definitions semantics and abstract interpretation popl ­ p cousot and r cousot À la burstall assertions induction principles for proving ability properties of programs ­ p cousot and r cousot higherorder abstract interpretation and application to analysis generalizing strictness termination projection and per analysis of functional languages int conf on comp lang ­ p cousot and n automatic discovery of linear among variables of a program popl ­ p cousot r cousot and l a scalable decision tree abstract domain time for verification in memory of a pnueli lncs ­ p cousot r cousot and f a parametric segmentation functor for fully automatic and scalable array content analysis popl ­ p cousot r cousot and f precondition inference from assertions and application to contracts on collections lncs ­ r cousot des de et de de sciences math b and h introduction to lattices and order nd edition cambridge university press e dijkstra guarded commands and formal derivation of programs cacm ­ e dijkstra a discipline of programming prenticehall j the abstract domain lncs ­ r assigning meaning to programs proc symp in applied math vol ­ math s and h construction of abstract state graphs with cav lncs ­ m j and a podelski refinement of trace abstraction sas lncs ­ c hoare an axiomatic basis for computer programming communications of the association for computing machinery ­ z manna and a pnueli axiomatic approach to total correctness of programs inf ­ k and l invariants and abstract interpretation sas lncs ­ a the abstract domain ­ d automatic modular abstractions for template numerical con logical methods in comp sci j morris and b induction cacm ­ p proofs of algorithms by general bit ­ d a constructive proof of fixedpoint theorem for reported by in joins in the frame of applied categorical structures ­ g plotkin a structural approach to operational semantics technical report fn university a pnueli a podelski and a rybalchenko separating fairness and for the analysis of fair discrete systems tacas lncs ­ a podelski and a rybalchenko transition invariants lics ­ a podelski and a rybalchenko a complete method for the synthesis of linear ranking functions lncs ­ a podelski and a rybalchenko transition predicate abstraction and fair termination popl ­ x and l the trace partitioning abstract domain toplas d scott and c towards a mathematical semantics for computer languages tech rep oxford univ comp lab a a lattice theoretical fixpoint theorem and its applications p j of math ­ r turing checking a large routine con on high speed automatic calculating machines math lab cambridge uk ­ 