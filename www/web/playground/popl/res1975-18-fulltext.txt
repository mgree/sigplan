program schemas with concurrency execution time and department bruce p of engineering princeton university princeton nj abstract a class of program schemas with con is defined as a natural extension of the standard notion of sequential flow schemas the question is considered as to whether such a program schema may reach a termination or for some interpretation it is shown that in general this question is undecidable however it is shown to be decidable for the class of free program schemas and an algorithm for testing this property is presented with an upper time bound that grows linearly with the size of the schema several structural properties are shown to be equivalent to the for free schemas and we give method for computing the expected tion time of a program schema if the expected of choices at the branch points are known a the best parallel algorithm for a given problem is usually quite different from the best sequential algorithm for there is a parallel sorting algorithm which requires time but the sequential form of this same algorithm is actually quite inefficient and requires time so a programmer a sequential language would never this fast parallel method using choose in general the only way to take full advantage of concurrency in programs is to permit the explicit use of concurrency at the level for this purpose we need programming languages with control primitives that express concurrency but we will see that the use of such primitives by a programmer introduces the possibility of formed control structures that cause in the flow of control introduction there are two basic approaches to the introduction of concurrency into programs the first is to write the program with a sequential programming language and then some mechanical procedure to find potential concurrency rl in this way the programmer need not be aware of con however it has been found that t this research national science grant gj was supported by the foundation under research in this paper we will analyze this problem from a theoretical viewpoint using program schemas with concurrency we will see that for the general case it is undecidable whether a schema is for all interpretations however for the case of free schemas the problem is decidable in linear time and this decision procedure will suggest a sufficient tion which can be used in practice to guarantee that real programs do not schemas we will extend the definition of program schemas found in the use of fork and join concurrency these primitives to the fork and join instructions suggested by by are similar first for let us consider an alphabet gram schemas consisting of for pro variable nary symbols function x symbols f nary predicate symbols n p a schema is a finite ed with one of the following of statements associated with each such that there is exactly one start one stop statement vertex and j x i xk x k assignment w the fork and join statements are used to permit concurrency in the schema the fork causes execution of both output arcs and the join for flow of control on both inputs otherwise this definition of program schema is equivalent to the stand definitions found in and the merge i just to represent the point where two arcs come together the standard definitions of interpretation and execution can be used with only slight modification an interpretation i for a schema over a nonempty domain d has the properties for each variable for each function if x x d symbol f for each predicate symbol p tf execution since the schema has concurrency may be multiple execution points state of a schema is a pair w associates active or each arc and v associates a member with each variable x intuitively active arcs are the execution and for each variable xi is there the such that with of d the points the value of x value the initial state associates with all arcs and the initial of each variable x i is in for all statement except start and merge a statement is executable if all its input arcs are active start is table if it has been executed ie start executes only once and a merge is executable if exactly one of its input arcs is active the execution of a state ment except causes all input arcs to become and all output arcs active the execution of a selects one output arc to become active by applying the predicate to the current value of the variables also the execution of assign ment statements has the obvious effect of changing the value of variables appropriate ly a computation of a schema under inter i is any execution sequence from the initial state which ends with the first execution of stop or ends with no statements executable a computation results in a termination if it ends with one or more arcs in the active state a program schema is free all interpretations no computation in a termination ie if tion occurs then all execution in schema has been properly completed if for results t t by considering all possible computation we have avoided the question of this problem has been studied by others see ref our results hold for de terminate or schemas in figure we see an which is not make different choices however if we modify by changing px to example of a schema if the a the schema results slightly then it is now we will show that is in general an undecidable property f theorem it is not whether an arbitrary partially program decidable schema is show that for any schemas s s we can construct a pro gram schema p which is if and only if s and s are weakly lemma will then give us our result let us rename the variables in s as x and let kl be the maximum xn index of any predicate symbol in s or s then the needed schema p is shown in figure if both and are defined then the only way to avoid is for xx xn and n to have the same values ie qed s top figure schema with a program schema is if it has no fork or join statements a non parallel schema s with an interpretation i has only one possible computation let denote the final value of all the variables if the computation is finite otherwise is undefined from we have the following definition and lemma for schemas schemas s are weakly equivalent if for all interpretations i whenever both are defined lemma equivalence is for park weak not partially decidable schemas figure program schema p schemas although able we have a simple structural tion to guarantee this property sufficient condition we will condition below and show that tested in linear time is ie a state this it can be a block is a connected exactly one input and one output arc is one of the following types with which parallel block a with no directed circuits and an association of fork join or block with each vertex decision block a with an association of merge or block with each vertex assignment statement block an assignment a program schema is if it is of the following form start block stop a notice that is purely a structural property independent of the par assignments or decisions in figure we have an example of a block reducible schema the parsing of the statements into blocks is shown by broken lines there are two decision blocks and one parallel block plus numerous assignment blocks the of figure is not theorem a program schema it is is proof the proof is by induction on the nested block structure of the schema clearly every assignment block is this forms a basis for the induction the prove that a parallel block is blocks are inductive block if its step is or decision component qed to so we have shown is sufficient for now we will show that a condition is equivalent to new condition will suggest and this a method of test ing in linear time for this we need the concept of a current for each arc which is a nonzero linear tion of the independent ik such that for each merge or assignment the sum of the input equals the sum of the output for each fork or join all arcs have the same current the output of the start has the same current as the input to the stop rules and are identical to current law at those vertices this type of application of to sequential programs is wellknown and is discussed in and rule is not part of and is unique to programs with concurrency the role of these current laws in a more general framework of parallel computations is presented in a program schema with d state ments is balanced if there exists a current assignment with d independent the schema of figure is balanced a balanced current assignment for this schema is shown in figure notice that there are and so independent a sequential schema is a program schema in which all fork and join statements have exactly one input arc and one output arc a program schema is if it by sequential schemas ie it is the union of sequential schemas theorem a program e if it is schema balanced is proof b let us assign a unique independent current to the output arc of start and the t output arc of every applying rules and for this gives us a balanced current assignment start ao p a fi i fx i f x i x ­ join x x f x x x f t w m ii stop figure schema i figure balanced current assignment from theorem of theorem we have sequential and our using the properties of current flow in a schema we can establish that for each fork there is a pair of tial schemas whose union is as shown in figure the must be sequential from properties of we verify that s and s are disjoint and from so ie and can from o considering we can verify property all qed y of the schema from this s top figure union of sequential free schemas schemas intuitively a free schema is one in which the choice at every is al ways independent of any previous choices made by to define this formally we need the concept of a herbrand tation ih of a schema s as follows if s has variables x x x function symbols fl the domain d of over the alphabet ff i contains h z x x all strings xn for every variable x symbol xi i xi for every function symbol f an ie the concatenation arguments of f with its similar definitions can be found in and r a schema is free if for all herbrand interpretations the same predicate symbol is never applied to the same term more than once this definition is in analogy with the original definition of free sequential schemas found in it is interesting that our from section for general schemas becomes necessary and sufficient for free schemas theorem schemas equivalent for the class the following of free program properties are balanced and proof show let wa de note the current for arc a for a schema with arcs a a an the three current laws system of linear equations of the form if we count the number of times each arc is executed during a terminating execution sequence then these counts will also satisfy the three current laws so we have at least one solution to ba o the general tion to these will give us a current assignment by the properties of free schemas the on the t outputs of all must be so we have a balanced current assignment follows from theorem of from theorem we have and from theorem we have qed linear time algorithms from theorem we can an al rithm for testing block that has an upper time bound which is linear in the number of statements in the schema the main difficulty in testing is to know where one block ends and the other begins this problem is by the fact that all statements of the same parallel block have the same current a balanced current assignment can easily b found in linear time so we know exactly how the and the joins are divided into blocks using this information a simple linear search through the schema can test for block this algorithm is much better than any known techniques for parallel computations most of which require exponential time execution time in order to compute the expected ex time of any program we must have some a priori measure of the expected prob of choices at the conditional branch points these probabilities can be determined by simulation on test data or by a probabilistic analysis of the algorithm itself see pp of from references and there is a tech of calculating the expected execution frequency for each statement in a sequential program if the probabilities are known let executing and let p denote statement fi denote the probability j following the expected of statement execution i frequency of statement i then fi i where statement to the program and i and o otherwise clearly is the if letting f denote the vector of fn we have a tic matrix p from the p f pf s such that s f ip so we have a method of computing the expected of every statement tial program and the expected time is clearly zf where ti execution in a execution is the time of statement i t for parallel schemas the problem is more complex se we have concurrency in fact an exact analytic solution will be quite difficult as illustrated by some of the results in instead we will pre sent a simple method of the execution time of schemas t if we replace program block then the method the word statement in the above discussion is still valid by this method will introduce a slight negative over the exact probabilistic solution and thus gives a lower bound on the expect ed execution time let us associate a time with each assignment and which is its tion time the time for fork join or merge is zero and the time for each block is defined recursively as follows assignment block time is execution time of that assignment statement decision block time is where fi are calculated using method for sequential ti are times of vertices and parallel block time is maximum path length from input to output arc where path length is sum of times along the path theorem for a parallel schema the time defined above of its outermost block is a lower bound on the expected execution time the proof is by induction on the nested the time for assignment blocks is the basis and the inductive step can be verified from the definition of time for each block type qed summary in this paper we have shown that in general the property for parallel schemas is undecidable however is sufficient for and for free parallel schemas is necessary and we have outlined a method of testing this condition in linear time and we have given a technique for computing a lower bound on the expected execution time of any program from the decision probabilities t if we have times for all a decision block we can use the same method as for sequential programs of references rm parallel program and maximal parallelism ii tion of vol closures no journal pp of the october acm hs problems of parallel computation and parallel of sequential algorithms ed academic press new york bs parallel processing with perfect on computers ieee vo c no pp february dc park ms son on formalized computation pro grams journal computer and system sciences pp z manna program schemas in the theory of computing ed av aho prentice nj pp me a multiprocessor system design proceedings of ence pp rm and re parallel program journal of computer and system sciences pp y de knuth the art of computer pro gramming fundamental ri addisonwesley inc read ing mass pp n graph theory with ap to engineering and computer science nj pp bp balance property of parallel computations phd project mac dept of engineering massachusetts institute of technology cambridge mass february m analysis of production schema technical report project mac massachusetts institute of technology cambridge mass february m equivalence problems in a model cambridge of computation university phd m mathematical theory of global program optimization nj pp de martin and g models of computational graph systems cyclic transformations to transactions vol ec on electronic n pp computers february 