recursive proofs for inductive tree datastructures p university of illinois at usa abstract we develop logical mechanisms and procedures to facilitate the verification of full functional properties of inductive tree datastructures using recursion that are sound incomplete but terminating our contribution in a new extension of firstorder logic with recursive definitions called a restriction on pre and postconditions of recursive imperative programs using and a systematic methodology for accurately unfolding the footprint on the heap by the program that leads to finding simple recursive proofs using formula abstraction and calls to smt solvers we evaluate our methodology and show that several complex tree datastructure algorithms can be checked against full functional specifications automatically given pre and postconditions this results in the first automatic terminating methodology for proving a wide variety of annotated algorithms on tree datastructures correct including trees trees heaps and categories and subject descriptors f logics and meanings of programs specifying and verifying and reasoning about programs mechanical verification d software engineering verification assertion checkers general terms algorithms reliability theory verification keywords heap analysis recursive program tree smt solver introduction the area of program verification using theorem provers manually provided proof annotations pre and postconditions for functions etc has been a focus of research in the field of programming languages automatic theory solvers smt solvers that handle a variety of quantifierfree theories including arithmetic uninterpreted functions boolean logic etc serve as effective tools that automatically the validity checking of many verification conditions a key area that has the above paradigm of specification and verification is heap analysis the verification of programs that dynamically allocate memory and manipulate them using pointers maintaining structural invariants eg the nodes form a tree aliasing invariants and invariants on the data stored in the locations eg the keys of a list are sorted the classical examples of these are the basic datastructures in computer sci permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm ence and include linked lists queues binary search trees balanced trees tree structures like trees etc objectoriented programs are rich with heap structures as well and structures are often found in the form of records or lists of pointers pointing to other datastructures dynamically allocated heaps are difficult to reason with for several reasons first the specification of proof annotations itself is hard as the annotation needs to talk about several properties of an unbounded heap often requiring quantification and reachability predicates and needs to specify aliasing as well as structural properties of the heap also in with manual verification it has been observed that pre and postconditions get complex including large formulas that say how the frame of the heap that is not by the program remains the same across a function separation logic has as a way to address this problem mainly the frame problem mentioned above and gives a logic that permits us to reason with the footprint by the program and the frame it in most research on program logics for functional verification of programs can be roughly divided into two classes · logics for reasoning the most popular of these are the class of separation logics but several others exist see matching logic for example complex structural properties of heaps are expressed using inductive algebraic definitions the logic combines several other theories like arithmetic etc and uses a special separation operator to reason with a footprint and the frame the analysis is either manual or the latter being usually sound incomplete and nonterminating and proceeds by searching for proofs using a proof system unrolling recursive definitions arbitrarily typically such tools can find simple proofs if they exist but are and cannot produce counterexamples · logics for completely automated reasoning these logics from the smt satisfiability modulo theories and automata theory literature where the goal is to develop fast terminating sound and complete decision procedures but where the logics are often constrained on expressivity in order to reach these goals examples include several logics that extend firstorder logic with reachability the logics and csl and the logic that combines tree theories with integer theories the problem with these logics in general is that they are often not sufficiently expressive to state complex properties of the heap eg the of we do not discuss approaches such as shape analysis here as such approaches are towards less complex specifications and often are completely automatic not even requiring proof annotations such as loop invariants see section an tree or that the set of keys stored in a heap do not change across a program we prefer an approach that combines the two above we propose a strategy that a identifies a class of simple and natural proofs for proving verification conditions for programs on how people prove these conditions manually and b builds terminating procedures that efficiently and search this class of proofs this results in a sound incomplete but terminating procedure that finds natural proofs automatically and efficiently many correct programs have simple proofs of correctness and a terminating procedure that searches for these simple proofs efficiently can be a very useful tool in program verification incompleteness is of course a necessary tradeoff to keep the logics expressive while having a terminating procedure and a terminating automatic procedure is useful as it does not need manual help furthermore as we shall see in this paper such decision algorithms are particularly desirable when they can be made to work very efficiently especially using the class of efficient smt solvers for quantifierfree theories the idea of searching for only simple and natural proofs is not new after all type systems that prove properties of programs are essentially simple and often scalable proof mechanisms the class of simple and natural proofs that we identify in this paper is however quite different from those found by type systems in this paper we develop logical mechanisms to identify a simple class of proofs based on a deterministic proof tactic that a recursive terms precisely across the footprint b uses formula abstractions that replace recursively defined terms with uninterpreted terms to the verification condition in a quantifierfree decidable theory and c checks the resulting formula using an automatic decision procedure we this technique for the specialized domain of imperative programs manipulating tree datastructures developing an extension of firstorder logic with recursion on trees called to state properties of programs and building procedures based on precise and formula abstractions motivating formula abstractions when reasoning with formulas that have recursively defined terms which can be forever a key idea is to use formula abstraction that makes the terms uninterpreted intuitively the idea is to replace recursively defined predicates sets etc by uninterpreted boolean values uninterpreted sets etc the idea of formula abstraction is extremely natural and very often in manual proofs for instance let us consider a binary search tree search routine searching for a key k on the root node x the verification condition of a path of this program typically would require checking k k k where is a recursive predicate defined on trees that identifies binary search trees and keys is a recursively defined set that collects the multiset of keys under a node unrolling the definition of keys and gives the following formula below i s means that i is less than every element in s now while the above formula is quite complex involving recursive definitions that can be ad we can prove its validity soundly by and keys as uninterpreted functions that map locations to booleans and sets respectively doing this gives modulo some renaming and modulo theory of equality b b k k k k k kk note that the above formula is a quantifierfree formula over integers and multisets of integers and furthermore is valid since and k must be in k validity of quantifierfree formulas over of integers with addition is decidable they can be translated to quantifierfree formulas over integers and uninterpreted functions and can be solved using smt solvers efficiently consequently we can prove that the verification condition is valid completely automatically note that formula abstraction is sound but incomplete this idea has been explored in the literature for example et al have proposed abstraction schemes for algebraic datatypes that soundly but transform logical validity into much simpler decidable problems using formula abstractions and developed mechanisms for proving functional programs correct reasoning with in order to build the procedures for reasoning with programs manipulating trees using precise unfolding and abstraction we develop a new recursive extension of firstorder logic called that allows stating complex properties of heaps without to explicit quantification combines quantifierfree firstorder logic with recursive definitions and these recursive definitions themselves expressed in can capture several interesting properties of trees including their height the multiset of keys stored in them whether they correspond to a binary search tree or an tree etc the main technical contribution of this paper is to show how a corresponding to a basic path in a recursive imperative program we and demand all recursion be through recursive function calls with proof annotations written in can be expressed as a pair consisting of a finite footprint and a formula the finite footprint is a symbolic heap that captures the heap explored by the basic block of the program precisely the construction of this footprint and formula calls for a careful handling of the footprint defined by a recursive imperative program calls for a approach to unrolling recursion and involves capturing aliasing and separation by exploiting the fact that the manipulated structures are trees in particular the procedure keeps track of locations in the footprint corresponding to trees and precisely computes the value of recursive terms on the these furthermore the verification condition is accurately described by unfolding the precondition so that it is expressed purely on the frontier of the footprint so as to enable effective use of the formula abstraction mechanism in order to be accurate we place several key restrictions on the logical syntax of pre and postconditions expressed for functions we then consider the problem of solving the validity problem for the verification condition expressed as a footprint and a formula we first show a small syntactic fragment of verification conditions that is entirely decidable without formula abstraction by a reduction to the decidable logic although this fragment of is powerful enough to express certain restricted structural properties of simple tree datastructures like binary search trees and it is completely in verifying more complex properties of the above structures as well as properties of more complex tree datastructures such as trees heaps etc we turn next to abstraction schemes for and show how to abstract formulas into quantifierfree theories of of integers the latter can then be translated into formulas in the standard quantifierfree theory of integers with uninterpreted functions the final formulas validity can be proved using standard smt solvers and its validity implies the validity of the formula dir dir f df p loc true false i loc int si loc loc x loc variables j int variables q boolean variables s variables ms variables c int constant loc term lt lt lt x nil int term it it it c j it it it it it it term s it term m ms formula true q plt lt lt it it it it ¬ integer ix def nil six def nil def nil predicate px def nil figure syntax of finally we evaluate our logical mechanisms and procedures by writing several tree datastructure algorithms using pure recursive imperative programs annotating them using in order to state their complete functional correctness derive the verification conditions expressed as and formulae and prove them valid using the formula abstraction scheme much to our all verification conditions in all the programs were proved valid automatically and efficiently by our procedure we have verified full functional correctness of datastructures ranging from sorted linked lists binary search trees which are binary search trees on the first key and on the second trees and trees search trees and heaps this set of benchmarks is an almost exhaustive list of algorithms on datastructures covered in a first course on datastructures to the best of our knowledge the work presented here is the first methodology that can prove such a wide variety of algorithms on tree datastructures written in an imperative language fully correct using a sound and terminating procedure the logic for heaps the recursive logic over trees is essentially a quantifierfree firstorder logic over heaps augmented with recursive definitions of various types eg integers of integers etc defined for locations that have a tree under them while firstorder logic gives the necessary power to talk precisely about locations that are neighbors the recursive definitions allow expressing properties that require quantifiers including reachability collecting the of keys in a tree and defining natural metrics like the height of a tree that are typically useful in defining properties of trees given a finite set of directions dir let us define as finite trees where every location has either dir children or is the nil location which has no children we assume there is a single nil location binary trees have two directions dir l r the logic is parameterized by a finite set of directions dir and also by a finite set of df let us fix these sets let bool true false stand for the set of boolean values int stand for the set of integers and loc stand for the universe of locations for any set a let sa denote the set of subsets of a and let denote the set of all multisets with elements in a the logic allows four kinds of recursively defined notions for a location that is the root of a recursively defined integer functions loc int recursively defined functions loc recursively defined functions loc and recursively defined boolean predicates loc bool let us fix disjoint sets of countable names for such functions we will refer to these recursive functions as recursively defined integers recursively defined of integers and recursively defined predicates respectively typical examples of these include the height of a tree or the height of in the tree rooted at a node recursively defined integers the of keys stored at a particular under nodes recursively defined of integers and the property that the tree rooted at a node is a binary search tree or a balanced tree recursively defined predicates a formula consists of a pair def where def is a set of recursive definitions and is a formula the syntax of logic is given in figure where the syntax of the formulas is followed by the syntax for recursive definitions we require that every recursive used in the formula has a unique definition in def the figure does not define the syntax of the base and inductive formulas in recursive definitions eg etc we give that in the text below location terms are formed using pointer fields from location variables and include a special location called nil integer terms are obtained from integer constants of locations and from recursively defined integers and combined using basic arithmetic operations of addition and and conditionals stands for ifthenelse terms that evaluate to the second argument if the first argument evaluates to true and evaluate to the third argument otherwise terms that evaluate to a of integers are obtained from recursively defined of integers corresponding to a location term and are combined using operations as well as conditional choices formulas are obtained by boolean combinations of boolean variables recursively defined predicates on a location term and using various relations between set and multiset terms the relations on sets and multisets include the subset relation as well as the relation which is interpreted as follows for two sets or multisets of integers s and s s s holds whenever for every i s j s i j the recursively defined functions or predicates are defined using the syntax f x nil find where and find are themselves terms or formulas that stand for what f evaluates to when x nil the and when x nil the inductive step respectively there are several restrictions on these · has no free variables and hence evaluates to a fixed value for integers it is a fixed integer for of integers it is a fixed set for boolean predicates it evaluates to true or false · find only has x as a free variable furthermore the location terms in it can only be x and further dereferences are moreover integer terms are intuitively the above conditions demand that when x is nil the function evaluates to a constant of the appropriate type and when x nil it evaluates to a function that is defined recursively using properties of the location x which may include properties of the children of x and these properties may in turn involve other recursively defined functions we assume that the inductive definitions are not circular formally let def be a set of definitions and consider a recursive definition of a function f in def define the sequence as follows set f x obtain i by replacing every occurrence of gx in i by where g is any recursively defined function in def we require that this sequence eventually ie there is a k such that k k intuitively we require that the definition of f x be into a formula that does not refer to a recursive definition of x by getting rewritten to properties of its descendants we require that every definition in def have the above property example red black trees red black trees are binary search trees with nodes colored red and black with all the leaves colored black satisfying the condition that the left and right children of a red node are black and the condition that the number of black nodes on paths from the root to any leaf is the same this ensures that the longest path from root to a leaf is at most twice the shortest path from root to a leaf making the tree roughly balanced we have two directions dir l r and two data fields key and color we model the color of nodes using an integer color which can be black or red we define four recursive a predicate that checks whether the root of the tree under x is colored black this is defined as a recursive predicate for technical reasons the black height of a tree the multiset of keys stored in a tree and a recursive predicate that identifies trees def x nil true def x nil def x nil def x nil true the function definition says that the black height of a tree is for a nil node nil nodes are assumed to be black and otherwise the maximum of the black heights of the left and right subtree if the node x is red and the maximum of the black heights of the left and right subtree plus one if x is black the function says that the multiset of keys stored in a tree is for a and the union of the key stored in the node and the keys of the left and right subtrees finally the holds if the left and right subtrees are valid red black trees the keys of the left subtree are no greater than the key in the node and the keys of the right subtree are no less than the key in the node if the node is red both its children are black and the black heights of the left and the right subtrees are equal we can also express in our logic various properties of red black trees by including the above definitions and a formula like and using the procedures outlined in this paper check the validity of the above statement semantics the logic is interpreted on concrete heaps let us fix a finite set of program variables pv concrete heaps are defined as follows f a b denotes a partial function from a to b definition a concrete heap over a set of directions dir a set of df and a set of program variables pv is a tuple n nil pf df pv where · n is a finite or infinite set of locations · nil n is a special location representing the null pointer · pf n nil × dir n is a function defining the direction fields · df n nil × df z is a function defining the · pv pv n z is a partial function mapping program variables to locations or integers depending on the type of the variable a concrete heap consists of a set of locations with a function pf that maps locations to locations for each direction dir dir a function df mapping locations to integers for each df along with a unique constant location representing nil that has no or from it moreover the function pv is a partial function that maps program variables to locations and integers a formula with free variables f is interpreted by interpreting the program variables in f according to the function pv and the other variables being given an interpretation hence for validity these other variables are universally quantified and for satisfiability they are existentially quantified each term evaluates to either a normal value of the corresponding type or to undef a location term is evaluated by dereferencing pointers in the heap if a dereference is undefined the term evaluates to undef the set of locations that are roots of are special in that they are the only ones over which recursive definitions are properly defined a term of the form or will evaluate to undef if lt evaluates to undef or is not a root of a tree in the heap otherwise it will be evaluated inductively using its recursive definition other aspects of the logic are interpreted with the usual semantics of firstorder logic unless they contain some subterm evaluating to undef in which case they also evaluate to undef each formula evaluates to either true or false to evaluate a formula we first convert to its negation normal form and evaluate each atomic formula of the form plt first if lt is not undefined plt will be evaluated inductively using the recursive definition of p if lt evaluates to undef plt will evaluate to false if plt appears and will evaluate to true otherwise intuitively undefined recursive predicates cannot help in making the formula true over a model similarly atomic formulas involving terms that evaluate to undef are set to false or true depending on whether the atomic formula occurs within an even or odd number of respectively all other relations between integers sets and multisets are interpreted in the natural way and we skip defining their semantics we assume that the formulas always include a recursively defined predicate tree that is defined as def x nil true true note that since recursively defined predicates can hold only on trees and since the above formula holds on any tree holds iff x is a root of a programs and basic blocks we consider imperative programs manipulating heap structures and the data contained in the heap in this paper we assume that programs do not contain while loops and all recursion is captured using recursive function calls consequently proof annotations only involve pre and postconditions of functions and there are no the imperative programs we analyze will consist of integer operations heap operations conditionals and recursion in order to verify programs with appropriate proof annotations we need to verify linear blocks of code called basic blocks which do not have conditionals conditionals are replaced with assume statements basic blocks always start from the beginning of a function and either end at an assertion in the program checking an intermediate assertion or end at a function call to check whether the precondition to calling the function holds or ends at the end of the program in order to check whether the postcondition holds basic blocks can involve recursive and nonrecursive function calls we define basic blocks using the following grammar parameterized by a set of directions dir and a set of df bb bb bb return u bb return j bb bb bb u v u nil u v j u f u f j u new j assume u f v z zn j gv z zn j u v u nil since we deal with tree datastructure manipulating programs which often involve functions that take as input a tree and return a tree we make certain crucial assumptions one crucial restriction we assume for the technical is that all functions take in at most one location parameter as input the rest have to be integers basic blocks hence have function calls of the form f v z zn where v is the only location parameter this restriction greatly simplifies the proofs as it is much easier to track one tree we can relax this assumption but when several trees are passed as parameters our decision procedures will implicitly assume a precondition that the trees are all disjoint this is crucial our decision procedures cannot track trees that they track only equal trees and disjoint trees this turns out to be a natural property of most datastructure manipulating programs pre and postconditions of functions we place restrictions on annotations pre and that we allow in our framework and these are important for our technique and is the price we pay for automation recall that we allow only two kinds of functions one returning a location f v z zn and one returning an integer gv z zn v is a location parameter z zn are integer parameters we require that v is the root of a at the point when the function is called and this is an implicit precondition of the function called each function is annotated with its pre and postconditions using annotating formulas annotating terms and formulas are terms and formulas that do not refer to any child or any data field do not allow any equality between locations and do not allow we denote the precondition as a formula v z zn the postcondition annotation is more complex as it can talk about properties of the heap at the as well as the we allow combining terms and formulas obtained from the and the to express the postcondition terms and formulas over the are obtained using annotating terms and formulas that are allowed to refer to a variable old v which points to the location v pointed to in the these terms and formulas can also refer to the variable ret loc or ret int to refer to the location or integer being returned terms and formulas over the are obtained using annotating terms and formulas referring to old v and old except that all recursive definitions are renamed to have the prefix old then a formula combines terms and formulas expressed over the and the using the standard operations for a function f v z zn that returns a location we assume that the returned location always has a under it and this is implicitly assumed to be part of the postcondition the postcondition for f is either of the form v old v old z old zn ret loc or of the form old loc old v old z old zn ret loc where is a formula in the first kind v means that the function guarantees nothing about the location pointed to in the by the input parameter v and nothing about the locations accessible from that location and hence the caller of f cannot assume anything about the location it passed to f after the call returns in that case we restrict from referring to where r is a recursive on the in the latter kind old loc means that f at the point of return that the location passed as parameter v now points to a and this tree is disjoint from the tree rooted at ret loc in either case the formula can relate complex properties of the returned location and the input parameter including recursive definitions on the old parameter and the new ones for example a postcondition of the form v v loc says that the keys under the returned location are precisely the same as the keys under the location passed to the function for a function g returning an integer the postcondition is of the form v old v old z old zn ret int or of the form v old v old z old zn ret int the former says that the location passed as input continues to point to a tree while the latter says that no property is about the location passed as input same restriction on applies the above restriction that the input tree and the returned tree either point to completely disjoint trees or that the input pointer and nodes accessible from it are entirely and the returned node is some tree are the only separation and aliasing properties that the postcondition can assert our logical mechanism is for example of saying the the returned node is a reachable node from the location passed to the function we have carefully chosen such restrictions in order to simplify tracking and separation in the footprint in practice most datastructure algorithms fall into these categories for example an insert routine would the input tree and return a new tree whose keys are related to the keys of the input tree while a program will return a tree disjoint from the input tree describing the verification condition in we now present the main technical contribution of this paper given a set of recursive definitions and a pre bb post where bb is a basic block we show how to systematically define the verification condition corresponding to it note that since we do not have basic blocks always start at the beginning of a function and go either the end of the function spanning calls to other functions or go up to a function call in order to check if the precondition for that call holds in the former case the postcondition is a postcondition annotation in the latter case we need another form x¯ where x¯ is a subset of program variables the precondition of the called function implicitly assumes that the input location is a tree which is expressed using above and the precondition itself is adapted after substituting formal parameters with actual terms passed to the function and written as the formula this verification condition is expressed as a combination of a quantifierfree formulas that define properties of the footprint the basic block on the heap combined with b recursive formulas expressed only on the frontier of the footprint this verification condition is formed by unrolling recursive definitions appropriately as the basic block increases its footprint so that recursive properties are translated to properties of the frontier this allows us to write the strongest postcondition of pre on precisely the same nodes as post refers to which then allows us to apply formula abstractions to prove the verification condition also recursive calls to functions that process the datastructure recursively are naturally called on the frontier of the footprint which allows us to summarize the call to the function on the frontier we define the verification condition using two steps in the first step we inductively define a footprint structure composed of a symbolic heap and a formula which captures the state of the program that results when the basic block executes from a configuration satisfying the precondition we then incorporate the postcondition and derive the verification condition a symbolic heap is defined as follows definition a symbolic heap over a set of directions dir a set of df and a set of program variables pv is a tuple c s i cnil pf df pv where · c is a finite set of concrete nodes · s is a finite set of symbolic tree nodes with c s · i is a set of integer variables · cnil c is a special concrete node representing nil · pf c cnil × dir c s is a partial function mapping every pair of a concrete node and a direction to nodes concrete or symbolic · df c cnil × df i is a partial function mapping concrete nodes and pairs to integer variables · pv pv c s i is a partial function mapping program variables to nodes or integer variables location variables are mapped to c s and integer variables to i intuitively a symbolic heap c s i cnil pf df pv has two finite sets of nodes concrete nodes c and symbolic tree nodes s with the understanding that each s s stands for a node that may have an arbitrary under it and furthermore the separation constraint that for any two symbolic tree nodes s s s the trees under it would not with each other nor with the nodes in c the tree under a symbolic node is not represented in the symbolic heap at all one of the concrete nodes cnil represents the nil location the function pf captures the dir in the heap that is within the footprint and maps the set of concrete nodes to concrete and symbolic nodes the pointer fields of symbolic nodes are not modeled as they are part of the tree below the node that is not represented in the footprint the functions df and pv capture the mapping to integer variables and program variables restricted to the nodes in the symbolic heap a symbolic heap hence represents a typically infinite set of concrete heaps namely those in which it can be embedded we define this formally using the notion of correspondence that captures when a concrete heap is represented by a symbolic heap definition let sh c s i cnil pf df pv be a symbolic heap and let ch n nil pf df pv be a concrete heap then ch is said to correspond to sh if there are two function h c s n such that the following conditions hold · nil · for any n n c if n n then hn hn · for any two nodes n n cs and for any dir dir if dir n then dir hn · for any s s hs is the root of a in ch and there is no concrete node c c cnil such that hc belongs to this tree · for any s s s s s the rooted at hs and hs in ch are disjoint except for the nil node · for any location variable v pv if is defined then intuitively h above defines a restricted kind of homomorphism between the nodes of the symbolic heap sh and a portion of the concrete heap ch distinct concrete nodes are required to map to distinct locations in the concrete heap symbolic nodes are required to map to trees that are disjoint save the nil location they can map to the nil location as well the trees rooted at locations corresponding to symbolic nodes must be disjoint from the locations corresponding to concrete nodes note that there is no requirement on the integer variables i and the map pv on integer variables and the maps df and df note also that for a concrete node in the symbolic heap n the fields defined from n in the symbolic heap must occur in the concrete heap as well from the corresponding location hn however the fields not defined for n may or may not be defined on hn a footprint is a pair sh where sh is a symbolic heap and is a formula the semantics of such a footprint is that it represents all concrete heaps that both correspond to sh and satisfy of nodes in symbolic heaps the key property of a symbolic heap is that we can determine that certain nodes have rooted under them ie in any concrete heap corresponding to the symbolic heap the corresponding locations will have a under them for a symbolic heap sh c s i cnil pf df pv let the set of graph nodes of sh be the smallest set of nodes v c s such that · cnil v and s v · for any node n c if for every dir dir dir is defined and belongs to v then n v now define to be the directed graph v e where v is as above and e is the set of edges u v such that dir v for some dir dir note that by definition there are no edges out of u if u s as symbolic nodes do not have outgoing fields we say that a node u in v is the root of a tree in if the set of all nodes reachable from u forms a tree in the usual sense the following claim follows and is the of using the symbolic heap to determine of nodes lemma let sh be a symbolic heap and let ch be a corresponding concrete heap defined by a function h if a node u is the root of a tree in then hu also a tree in ch a proof is as follows first note that symbolic nodes and the node cnil are always roots of trees in and the locations in the concrete heap corresponding to them trees in fact disjoint trees save the nil location to concrete nodes we need to argue that if c is a concrete node in then hc is the root of a in ch this follows by induction on the height of the tree under c in since each of the dir children of c in must either be the cnil node or a summary node or a concrete node that is a the root of a tree of less height the corresponding locations in ch by induction hypothesis or by the above observations have suspended from them in fact by the definition of correspondence these trees are all disjoint except for the nil location since trees corresponding to summary nodes are all disjoint and disjoint from locations corresponding to concrete nodes and since concrete nodes in the symbolic heap denote the location corresponding to a concrete node in that does not have all defined in sh may or may not have a from it this is because the notion of correspondence allows the corresponding location to have more fields defined in the sequel when we use symbolic heaps for tracking such concrete nodes with partially defined dir fields will occur only when processing function calls where all information about a node may not be known initial footprint let the precondition be j jm where u is the only location program variable there is a rooted at u and j jm are integer program variables then we define the initial symbolic heap c s i cnil pf df pv where c cnil s n i i im pf and df are empty functions ie functions with an empty domain and pv maps u to n and j jm to i im respectively the initial formula is obtained from j jm by replacing u by n and j jm by i im and by adding the conjunct or f cnil for all recursive predicates and functions note that the formula is defined over the variables s i intuitively we start at the beginning of the function with a single symbolic node that stands for the input parameter which is a tree and a concrete node that stands for nil all integer parameters are assigned to distinct variables in i expanding the footprint a basic operation on a pair sh consisting of a symbolic heap and a formula is expansion let sh be c s i cnil pf df pv and n c s be a node we define expand sh n sh where sh is the tuple c s i cnil pf df pv as follows if n c the node is already expanded then do nothing by setting sh to sh otherwise · c c n where n is the node being expanded · s s dir dir n where each is a fresh new node different from the nodes in c s · i i if f df where each if is a fresh new integer variable · pf pf and dir for all dir dir · df df and f i f for all f df · pv pv the formula is obtained from the formula as follows pn fn p f n cnil n n c cnil s cnil cnil dir where are fresh boolean variables are fresh term integer set variables px def nil ranges over all the recursive predicates and f x def nil ranges over all the recursive functions intuitively the variables and capture the values of the predicates and functions for the node n in the current symbolic heap this is possible because the values of the recursive predicates and functions for concrete nodes are determined by the values of the functions and predicates for symbolic nodes and the nil node the formula is obtained from by substituting every location term of the form with for every dir dir and substituting every integer term of the form n f with if for every f df the term is obtained by the same substitutions the footprint on basic blocks given a symbolic heap sh along with a formula and a basic block bb we compute the symbolic execution of bb using the transformation function st sh bb sh the transformation function st is computed ie if bb is of the form stmt bb where stmt is an atomic statement and bb is a basic block then st sh bb st st sh stmt bb therefore it is enough to define the transformation for the various atomic statements given sh c s i cnil pf df pv and an atomic statement stmt we define st sh stmt as follows by cases of stmt unless some assumptions fail in which case the transformation is undefined we describe st sh stmt as sh as per our convention function updates are denoted in the form of arg new val for example n denotes the function pv except that maps to n formula substitutions are denoted in the form of for example denotes the formula obtained from the formula by substituting every occurrence of df with df the following defines how the footprint across all possible statements except function calls a stmt u v if is undefined the transformation is undefined otherwise sh c s i cnil pf df b stmt u nil sh c s i cnil pf df cnil c stmt u if is undefined or c and dir is undefined the transformation is undefined otherwise we expand the symbolic heap c s i cnil pf df pv expand sh now must be in c cnil and we set sh c s i cnil pf df dir d stmt j v f if is undefined or c and f is undefined the transformation is undefined otherwise we expand the symbolic heap c s i cnil pf df pv expand sh now must be in c cnil and we set sh c s i i cnil pf df pv j i i f e stmt v if or is undefined or cnil the transformation is undefined otherwise we expand the symbolic heap c s i cnil pf df pv expand sh now must be in c cnil and we set sh c s i cnil dir df pv f stmt u f j if or pv j is undefined or cnil the transformation is undefined otherwise we expand the symbolic heap c s i cnil pf df pv expand sh now must be in c cnil and we set sh c s i i cnil pf f i pv i pv j g stmt u new we assume that for the new location every pointer initially points to nil and every data field initially evaluates to sh c n s i i f f df cnil pf df n f df i f n n where pf and df are defined as follows · pf pf and dir cnil for all dir dir · df df and f i f for all f df h stmt j if pv is undefined on any variable in then the transformation is undefined otherwise sh c s i i cnil pf df pv j i i i stmt assume if pv is undefined on any variable in or in pv then the transformation is undefined otherwise sh sh pv j stmt return u if is undefined the transformation is undefined otherwise sh c s i cnil pf df loc k stmt return j if pv j is undefined the transformation is undefined otherwise sh c s i i cnil pf df int i i pv j we can show that for any atomic statement that is not a function call the above computes the strongest post of the footprint theorem let sh be a footprint and let stmt be any statement that is not a function call let sh be the footprint obtained from sh across the statement stmt as defined above let c denote the set of all concrete heaps that correspond to sh and satisfy and let c be the set of all heaps that result from executing stmt from any concrete heap in c then c is the precise set of concrete heaps that correspond to sh and satisfy handling function calls let us consider the statement u f v on the pair sh let f w be the function prototype and post its postcondition if or any element of pv is undefined the transformation is undefined we also assume that the checking of the precondition for f is successful in particular and all the nodes reachable from it are roots of trees recall that certain nodes of the symbolic heap can be determined to point to trees as discussed earlier for any node n c s let us define reach n to be the subset of c s that is reachable from n in let nc reach c cnil ns reach s intuitively nc and ns are the concrete and the symbolic nodes affected by the call let loc be the node returned by f let n be the set of nodes generated by the call n loc if post does not old w and n loc otherwise the resulting symbolic heap is c s i cnil pf df pv where · c c nc · s s ns n · i i · pf d pf d and dir is undefined for all the pairs n dir c nil × dir d where d c nil × dir is the set of pairs n dir such that dir c s · df df · pv loc intuitively the concrete and symbolic nodes affected by the call are removed from the footprint and get quantified in the formula with the possible exception of if post does not old w becomes a symbolic node the returned node is added to s the pf and df functions are restricted to the new set of concrete nodes and all the directions and program variables pointing to quantified nodes become undefined let post be the formula in post we define the following formulas pre call pre call rn r loc pre call where n ranges over nc ns r ranges over all the recursive predicates and functions pre call rn are fresh logical variables is obtained from by replacing with dir and n f with f for all dir dir f df and then by replacing rn with pre call rn for all n nc ns rn is the vector of all the recursive predicates and functions on all n nc ns intuitively in we add logical variables that capture the values of the recursive predicates and functions for the nodes affected by the call in we replace the program variables in the post with the actual nodes and integer variables and we replace the old version of the predicates and functions on old w with the variables capturing those values then the resulting formula is the case of j gv is similar example search in trees to illustrate the above procedure expands the symbolic heap and generates formulas we present it working on the search routine of an tree figure shows the find routine which searches in an tree t and returns true if a key v is found the precondition pre postcondition post and userdefined recursive sets and predicates are also shown in figure in figure we present how the symbolic heap for a particular execution path of the routine at each point of the basic block we also formally show the updated symbolic heap sh and the corresponding formula the postcondition finally after capturing the program state after execution bb by a pair sh we incorporate the postcondition post which contains the annotating formula and generate a verification con we compute the set of in the footprint sh and compute the recursively defined predicates and functions on them let sh c s i cnil pf df pv n tree c cnil vc vc rn where vc rn is fresh logical variables and are obtained from by replacing with dir and n f with f for all dir dir f df and then by replacing rn with vc rn for all n n intuitively n are the concrete nodes that are tree roots while vc introduces variables that capture the values of the recursive predicates and functions on concrete nodes let u and be the original program variables of bb let v and be the new program variables appearing in only when bb ends before a function call let n be the set of nodes that should be the roots of disjoint trees as required by post n if post n n loc if post old loc n n if post u if post u n loc or n depending on the basic block is within a function returning a location or an integer let vc int vc loc rn old rn rn where r ranges over all the recursive predicates and functions n is and are the initial node the variable capturing the and integer variables value of rn in the and rn the substitution of rn with vc rn is only performed for nodes in n we should verify that n n s cnil that is the nodes required by post to be tree roots are indeed tree roots reach n reach n cnil for all n n n such that n n sh vc vc that is the constraints on the current states imply the constraints required by the first two are readily the last one asserts that any concrete heap that corresponds to the symbolic heap sh and satisfies vc must also satisfy vc checking the validity of this claim is nontrivial undecidable and we examine procedures that can soundly establish this in the next section proving the verification condition in this section we consider the problem of checking the verification condition sh vc vc generated in section we first show a small syntactic fragment of that is entirely decidable without formula abstraction by a reduction to the powerful decidable logic we then turn to the abstraction schemes for unrestricted verification conditions and show how to soundly reduce verification conditions to a validity problem of quantifierfree theories of of integers which is decidable using smt solvers a decidable fragment of given verification conditions of the form sh vc vc where sh is a symbolic heap and vc and vc are formulas the validity problem is in general undecidable however decision procedures for fragments are desirable as when a program does not satisfy its specification the decision procedure would the program and it with a counterexample which helps programmers the code in this subsection we identify a small decidable fragment that is very restricted and practically useful for only a small class of specifications called we omit the proof of decidability in interest of space let us fix a set of directions dir and a set of df does not only restrict the syntax of but also restricts the recursive that can be defined we first describe the ways allowed in to define as follows · recursive integers are · for each data field f df a recursive set of integers fs can be defined as x nil x f · for each data field f df a recursive multiset of integers can be defined as x nil m x f m · recursive predicates can be defined in the form of px x nil true px where px is a local formula with x as the only free variable local formulas are formulas subset equality between locations positive of and and negative of between intuitively px is evaluated to true if and only if every node y in the subtree of x satisfies the local formula py which can be determined by simply accessing the data fields of y and evaluating the recursive for the children of y the exclusion of recursive integers prevents us from expressing which are required in many specifications there are however interesting algorithms on inductive data structures like binary heaps binary search trees and whose verification can be expressed in on the syntax of does not allow to refer to any child or any data field for any location ie terms of the form or lt f are difference operations and subset relations between are also overall is the most powerful fragment of that we could find that into a known decidable logic like however it is not powerful enough for the heap tion questions that we would like to solve this formula abstractions that we describe in the next section proving using formula abstractions in typical datastructure algorithms a recursive algorithm the datastructure for a few bounded number of steps and then recursively calls itself to process the rest of the inductive datastructure and finally the structure before returning as argued in section in recursive proofs of such algorithms it is very often sufficient to assume that the recursively defined predicates integers sets of keys etc are arbitrary or uninterpreted int t int v if t null return false tv if v tv return true else if v tv w r v else w r v return r pre post ht ret loc v def x nil true def hx def x nil def hx def x nil def figure find routine left prepost conditions and recursive definition of keys and h right graphical representation of sh formal representation of sh formula c cnil s n i i dir df pv t n v i assume t nil n c cnil s n i i dir df pv t n v i n cnil tv c cnil n s n n i i i i i dir n left n n right n df n value i n height i pv t n v i tv i assume tv n cnil i hn i i hn hn hn hn hn v hn n cnil n n n n n n n cnil i i v assume tv v w c cnil n s n n i i i i i dir n left n n right n df n value i n height i pv t n v i tv i w n n cnil i hn i i hn hn hn hn hn v hn n cnil n n n n n n n cnil i i i i i i r v return r c cnil n s n n i i i i i i i dir n left n n right n df n value i n height i pv t n v i tv i w n r i i n cnil pre call i hn pre call i i pre call hn hn pre call hn hn hn n cnil n n n n n n n cnil i i i i h n i i pre call hn i pre i call i i figure expanding the symbolic heap and generating the formulas when applied to the inductive hypothesis that the algorithm works correctly on the smaller tree that it calls itself on this is very common in manual verification of these algorithms and the footprint formula obtained in section the recursive properties expressed directly in terms of recursive properties on the locations that the program makes recursive calls hence in order to find a simple proof we can replace recursive definitions on symbolic nodes as uninterpreted functions that map the symbolic trees to arbitrary integers sets of integers multisets of integers etc which we call formula abstraction see ­ where such abstractions have been used to prove a verification condition sh using formula abstraction we drop sh and we replace recursive predicates on symbolic nodes by uninterpreted boolean functions replace recursive integer functions as uninterpreted functions that map nodes to integers and replace recursive functions with functions that map nodes to arbitrary sets and multisets notice that the constraints regarding the concrete and symbolic nodes in sh were already added to during the construction of the verification condition the formula resulting via abstraction is a formula abs abs such that if abs abs is valid then so is sh the converse may not necessarily be true checking abs abs is decidable and in fact can be reduced to qf the quantifierfree theory of uninterpreted functions and arithmetic the validity of the abstracted formula abs abs over the theory of uninterpreted function linear arithmetic and sets and multisets of integers is decidable the fact that the quantifier free theory of ordered sets is decidable is well known in fact et al showed that the quantifierfree theory of sets with cardinality constraints is npcomplete since we do not need cardinality constraints we use a slightly simplified decision procedure that reduces formulas with using uninterpreted functions that capture the characteristic functions associated with these we omit these details in the interest of space experimental evaluation in this section we demonstrate the effectiveness and of the logic and the verification procedures developed in this paper by verifying standard operations on several inductive data structures each routine was written using recursive functions and annotated with a precondition and a postcondition specifying a set of partial correctness properties including both structural and data requirements for each basic block of each routine we manually generated the verification condition sh following the procedure described in section then we examined the validity of using the procedure described in section we employ z a smt solver to check validity of the generated formula d formula in the quantifierfree theory of integers and uninterpreted functions qf the experimental results are in figure the datastructures routines and verified properties lists are trees with a singleton direction set sorted lists can be expressed in the routines insert and delete insert and delete a node with key k in a sorted list respectively in a recursive fashion the routine takes a list and sorts it by recursively sorting the tail of the list and inserting the key of the head into the sorted list by calling insert we check if all these routines return a sorted list with the multiset of keys as expected a binary heap is recursively defined as either an empty tree or a binary tree such that the root is of the greatest key and both its left and right subtrees are binary heaps the routine is given a binary tree with both its left and right trees are binary heaps if the property is violated by the root it the root with its greater child and then recursively that subtree we check if the routine returns a binary heap with same keys as that of the input tree the datastructure is a class of binary trees with two data fields for each node key and priority we assume that all are distinct and all keys are distinct can also be recursively defined in the routine the root of the input and joins the two subtrees from the left and right children of the deleted node into a single if the left or right subtree of the node to be deleted is empty the join operation is trivial otherwise the left or right child of the deleted node is selected as the new root and the deletion proceeds recursively the delete routine simply searches the node to be deleted recursively and it by calling the insert routine recursively inserts the new node into an appropriate subtree to keep the property then performs to restore the order property if necessary we check if all these routines return a with the set of keys and the set of as expected an tree is a binary search tree that is balanced for each node the absolute difference between the height of the left subtree and the height of the right subtree is at most the main routines for are insert and delete the insert routine recursively inserts a key into an tree similar to a binary search tree and as it returns from recursion it checks the and performs one or two to restore balance the delete routine recursively a key from an tree again similar to a binary search tree and as it returns from the recursion ensures that the tree is indeed balanced for both routines we prove that they return an tree that the multiset of keys is as expected and that the height increases by at most for insert can decrease by at most for delete or the same trees are binary search trees that are more balanced than the trees and were described in section we consider the insert and delete routines the insert routine recursively inserts a key into a subtree and the new node red possibly the tree property as it returns from recursion it performs several to fix the property if the root of the whole tree is red it is black and all the properties are the delete routine recursively a key from a tree possibly the tree property as it returns from recursion it again performs several to fix it for both routines we prove that they return a tree that the multiset of keys is as expected and the black height increases by at most for insert decreases by at most for delete or does not change the is a data structure that generalizes the binary search tree in that for each node the number of children is one more than the number of keys stored in that node the keys are stored in increasing order and if the node is not a leaf the key with index i is no less than any key stored in the child with index i and no more then all the keys stored in the child with index i for each node except the root the number of keys is in some range typically between t and t a is balanced in that for each node the heights of all the children are equal to describe the in our logic we need three mutually recursive predicates one that describes a and two that describe a list of keys and children the states that the number of keys stored in the node is in the required range and that keys and children list satisfies either the predicate if the node is not a leaf or the predicate if the node is a leaf the states that either the list has only one element and the child satisfies the predicate or the list has at least two elements the key in the head of the list is no less than all the keys stored in the child and no greater than the keys stored in the tail of the list the child satisfies data structure ints sets routine bb max nodes in footprint total time s time s per vc vc proved valid insert yes sorted list delete yes yes binary heap yes insert yes delete yes yes tree insert delete yes yes tree insert delete yes yes insert find yes yes yes heap yes merge yes total figure results of program verification see details at and the height of the child is equal to the height of the tail the height of a list is defined as the maximum height of a child the predicate is similarly defined we consider the find and insert routines the find routine iterates over the list of keys and into the appropriate child until it finds the key or it to a leaf the insert procedure is more complex as it assumes that the node it is inserting into is and prior to recursion it might need to split the child for both routines we check that the tree after the call is a that the multiset of keys has the expected value and that the height of the tree the same or increases by at most for insert as an advanced data structure the heap is described by a set of predicates defined mutually recursively and briefly a of order k consists of a of order k and a of order less than k a of order k is an ordered tree defined recursively the root contains the minimum key and its children compose a of order k satisfying the property a of order k consists of a tree of order k and a of order k the scheme represents each tree within a heap each node contains its key pointers to its leftmost child and to the sibling immediately to its right and its degree the roots of a heap form a list also connected by the sibling pointer we access the heap by a pointer to the first node on the root list the routine expects a nonempty heap and moves the tree containing the minimum key to the head of the list it returns the original heap if it is a single tree otherwise it calls on its tail list and the returned list to the head tree then if keys of the roots of the first two trees are unordered the two trees we check that returns a tree followed by a heap such that the root of the tree contains the minimum key and the head of the heap is either the first or the second root of the original heap the merge routine merges two heaps x and y into one if one of the two heaps is empty it simply returns the other one otherwise if the heads of the two heaps are of the same order it merges the two head trees into one merges the two tail lists recursively and returns the new tree followed by the new heap if not say then it merges and y the head tree of x and the new heap in an appropriate way satisfying the property we check that merge returns a heap such that the keys are the union of the two input heaps and the order increases up to the routine is nonrecursive it simply moves the minimum tree m to the head by calling and obtains two heaps a list of the of m and a list of the children of m finally it merges the two heaps by merge we check that returns a heap with the multiset of keys as expected figure summarizes our experiments showing the results of verifying basic blocks across these algorithms for each data structure we report the number of integers sets multisets and predicates defined recursively for each routine we report the number of basic blocks the number of nodes in the footprint the time taken by z to determine validity of all generated formulas and the validity result proved by z note that only the first three datastructures sorted list binary heap and fit in the decidable fragment described in section as they do not require recursively defined integers furthermore since the difference operations between are we can check all functional properties for these datastructures except checking that the set of at the end of the each routine is as expected we are by the fact that all these verification conditions that were generated by the methodology set in this paper were proved by z efficiently this proved all these algorithms correct to the best of our knowledge this is the first terminating automatic mechanism that can prove such a wide variety of datastructure algorithms written using imperative programming correct in particular heaps and the presented here have not been proven automatically correct the experimental results show that is a very expressive logic that allows us to express natural and recursive properties of several complex inductive tree data structures moreover our sound procedure to be able to prove many complex verification conditions related work there is a rich literature on program logics for heaps we discuss the work that is to ours in particular we omit the rich literature on general interactive theorem provers like coq as well as general software verification tools like that are not particularly adapted for heap verification separation logic is one of the most popular logics for verification of heap structures many of separation logic combine separation logic with inductively defined datastructures while separation logic gives mechanisms to son with the footprint and the frame it in proof for separation logic are often heuristic and incomplete though a of small decidable fragments are known a work that comes very close to ours is a paper by et al where the authors allow userdefined recursive predicates similar to ours and build a terminating procedure that reduces the verification condition to standard logical theories while their procedure is more general than ours they can handle structures beyond trees the resulting formulas are quantified and result in less efficient procedures is a coq library that aims at mostly automated but not completely automated procedures that requires some proof tactics to be given by the user to prove verification conditions in manual and approaches to verification of heap manipulating programs the inductive definitions of algebraic datatypes is extremely common and proof tactics these inductive definitions do extensive unification to try to match terms and find simple proofs our work in this paper is very much inspired by the kinds of manual heap reasoning that we have seen in the literature the work by et al is one of the first attempts at full functional verification of linked data structures which includes the development of the system that uses higherorder logics to specify correctness properties and puts together several theorem provers ranging from firstorder provers smt solvers and interactive theorem provers to prove properties of algorithms manipulating datastructures while many proofs required manual this work showed that proofs can often be derived using simple tactics like unrolling of inductive definitions unification abstraction and decision procedures for decidable theories this work was also an for our work but we chose to concentrate on deriving proofs using completely automatic and terminating procedures where unification unrolling abstraction and decidable theories are systematically exploited one work that is very close to ours is that of et al where decision procedures for algebraic datatypes are presented with abstraction as the key to obtaining proofs however this work focuses on sound and complete decision procedures and is limited in its ability to prove several complex data structures correct moreover the work limits itself to functional program correctness in our functional programs are very similar to algebraic inductive specifications leading to much simpler proof procedures there is a rich and growing literature on completely automatic sound complete and terminating decision procedures for restricted heap logics the logic offers such reasoning with restricted reachability predicates and quantification while the logic has extremely efficient decision procedures its expressivity in stating properties of inductive datastructures even trees is very limited there are several other logics in this being less expressive but decidable ­ strand is a recent logic that can handle some datastructure properties at least binary search trees and admits decidable fragments by combining decidable theories of trees with the theory of arithmetic but is again extremely restricted in expressiveness none of these logics can express the verification conditions for full functional verification of the datastructures explored in this paper acknowledgements this work is partially by nsf and contract hc references i a pnueli and l d shape analysis by predicate abstraction in volume of lncs pages ­ springer m by e r b and k r m leino a modular verifier for objectoriented programs in volume of lncs pages ­ springer j berdine c calcagno and p w ohearn a decidable fragment of separation logic in volume of lncs pages ­ springer j berdine c calcagno and p w ohearn symbolic execution with separation logic in volume of lncs pages ­ springer n and j linear functional in cav volume of lncs pages ­ springer a c c and m a framework for reasoning about composite data structures in concur volume of lncs pages ­ springer a r and z manna the calculus of computation springer wn c david h h and s automated verification of shape size and bag properties via userdefined predicates in separation logic science of computer programming in press a verification of lowlevel programs in computational separation logic in pldi pages ­ acm t h c e r l and c introduction to algorithms mit press third edition l m de and n z an efficient smt solver in tacas volume of lncs pages ­ springer inria the coq proof assistant url v r and p ordered sets in the calculus of data structures in csl volume of lncs pages ­ springer s and s qadeer back to the future precise program verification using smt solvers in popl pages ­ acm p and x efficient decision procedures for heaps using strand in sas volume of lncs pages ­ springer p g and x decidable logics combining heap structures and data in popl pages ­ acm s p lee and yk a tool for reasoning about shape and arithmetic in cav volume of lncs pages ­ springer g nelson verifying reachability invariants of linked structures in popl pages ­ acm p w ohearn j c reynolds and h yang local reasoning about programs that alter data structures in csl volume of lncs pages ­ springer z j d and a j hu an decision procedure for verification of programs with mutable data and cyclic data structures in volume of lncs pages ­ springer z r a j hu and a verifying programs in an smt framework in volume of lncs pages ­ springer s and c a theory of lists and its extensible decision procedure in pages ­ j reynolds separation logic a logic for shared mutable data structures in lics pages ­ g c and w matching logic an alternative to logic in volume of lncs pages ­ springer p m and v decision procedures for algebraic data types with abstractions in popl pages ­ acm k v and m c rinard full functional verification of linked data structures in pldi pages ­ acm k v and m c rinard an integrated proof language for imperative programs in pldi pages ­ acm 