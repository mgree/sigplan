induction variables in very high level languages c and jeffrey d princeton university princeton n j abstract we explore the notion of an induction variable in the context of settheoretic programming an definition we believe involves both the that changes in the variable around a loop be easily computable and that they be small we attempt to justify these requirements and show why they are independent next the of what operators on sets play the role of and for arithmetic languages is explored and several theorems allowing us to detect induction variables in a loop are given it is shown that most of the usual set operations do fit into the theory and help form induction variables the reason most variables fail to be induction variables concerns the structure of control flow more than it does the operators applied i b a c k g r o u n d reduction in strength that is the replacement of multiplication by addition in a and its detection and elimination of induction variables those w h o s e value a s s u m e s a n a r i m r r o g r e at a forms a key optimization for arithmetic languages like fortran recently there has been considerable interest in algorithms for performing this kind of optimization however in the fortran environment there is never more than a constant factor speedup available by these methods on the other hand recent proposals such as have dealt with reduction in strength applied to settheoretic languages in this context reduction in strength becomes a method for algorithms to improve their asymptotic running time and order of magnitude e n t is p o s s i b l e e a r l e y p r o p o s e s iterator inversion which is a powerful for improving o m a t i c a l l y u n f o r t u n a t e l y as admits it is not clear how to tell in advance whether a transformation is or the running time our answer to that problem is that a set of transformations must be built up from the bottom starting with a few obviously safe transformations and developing additional safe transformations r e c u r s i v e l y s c h w a r t z has a similar idea based on the notion of continuous functions where an expression x x is said to be continuous in x c h a n g e s in e s u m a b l y s e t v a l u e d v a r i a b l e x p r o d u c e s a c h a n g e in e which can be easily calculated from the old value of e and the old and new values of x we propose a related idea but one which we is more in its treatment of boolean valued opera on sets such as the relation of set inclusion and in its extension from ex to the model we assume a language such as setl the operations which we assume can be done in unit time are i a r i t h m e t i c on i n t e g e r s i n s e r t i o n of an e l e m e n t into a set work partially supported by nsf grant i d e l e t i o n o f an e l e m e n t f r o m a set s e l e c t i o n of s o m e m e m b e r f r o m a set tt t e s t i n g w h e t h e r an a t o m is in a set these assumptions are valid at least in an expected time sense if one uses a hash table representation for sets such as in with elements which are sets represented by pointers to their values w e t a k e it as a c o r o l l a r y to t h a t a set may be tested for time in unit it is assumed further that we are presented a program as a flow graph with basic blocks consisting of statements e g a b u c but not a b u c d which would appear as tc d a bu t g o a l s we are interested primarily in developing a theory of induction variables and reductions in strength for set theoretic languages that is analogous to the one for ones however in the environment of a settheoretic language where large amounts of time are already given up to system overhead it does not make sense to concern ourselves solely with constant factor as one does for fortran we our de so that induction variables are those for which an order of magnitude im in the running time of the pro gram is possible by properly evaluating its induction variables induction variables the canonical situation for a fortran level induction variable is a loop in which statements like ji appear if i is not changed elsewhere in the it is clearly an induction variable moreover j is an induction variable at least at the point immediately after j i we can a r r a n g e t o m a i n the value of j by additions and only if we create a temporary t w h o s e v a l u e is a l w a y s t w i c e that of i then follow i i by t t and where i is initialized outside the loop i n i t i a l i z e t to t w i c e i r e p l a c e j i b y t y i e l d i n g t h e s e q u e n c e in many cases we can with i andor identify j with t adding to our in any event we have eliminated the expensive multiplication at the cost of several copies and additions perhaps a change now lets repeat the above in the settheoretic context it is generally recognized that the basic role by statements of the form i i and i i in the arithmetic world belongs to s s u x and s s x in the set world see these statements are just and of elements operations which we have taken as tive we might see in a loop the pair of statements a a u x c a ub where b is constant within the loop for simplicity in our present informal discussion it is natural to suppose that we could create set t whose value will always be that of a u b then we could follow a a u x bv t t u x and initialize t to a u b outside the loop if we replace c a u b by c t we have a a u x t t u x c t have we saved significantly here the answer is that probably we since the operation o copying t and assigning the value to c takes the same order of time as c o m p u t i n g a u b of course it is possible that on ex of the entire loop we would find that c and t could be identified thus re placing the union of arbitrary sets a and b by the of one element x this would definitely be an order of magnitude however it is possible that the value of c is used in the loop in a way that makes its identification with t im possible in that case we propose the following definition a loop is a set of blocks with a which dominates all other blocks in t h e loop i e a c c e s s to the l o o p is via the header only d e f i n i t i o n d e f i n e a p for i d e n t i f i e r and point p to be the pair of sets a d and a p w h e r e a p is the set of elements added to a and not re moved from a since the last time control p a s s e d point p and za p is the set of elements removed from a and not added t h a t is za d and d are new set valued identifiers whose value it is to maintain every time control p a s s e s p o i n t p we set za n to and alter a d as the current v a l u e of a changes and as long as control does not again reach p definition call a an induction variable of loop l at point p if there is a constant upper bound on the work necessary to m a i n t a i n the v a l u e of ka p b e t w e e n any two consecutive times that control passes p o i n t p s t a y i n g w i t h i n loop l returning to our informal example of the statements a a u x c a ub we may let d be the point immediately o w i n g c a u b if the o n l y a s s i g n m e n t to a in the loop is a a u x then s u r e l y a p can be m a i n t a i n e d in constant work by writing the piece of program as if x not in a t h e n za d a p u x a a o x c a ub aa p a o if b is a constant within the loop we can use xa p to s i m u l a t e the a s s i g n m e n t c a u b t e c h n i c a l l y w h a t h a p p e n s is this we observe that since b does not change the change in the expression a u b from point p is almost the same as a p in particular o a a p b and d xa p b if both i a d and a d are b o u n d e d as they are in this e x a m p l e then p is easy to compute in general if a and b vary in the loop we can c o m p u t e p from a p and a b p p r o v i d e d both are small now we assume that c is only assigned at c a u b within the loop therefore c p a u b p and we can r e p l a c e the above program by if x not in a then aa p k p u x if x not in b then a u b p ÷ a u b p u x c c u p a u b p z a p a p k p k p note that the s can be ignored here but were included for form also depending on what goes on elsewhere in the loop we may d r o p c o n s i d e r a t i o n of a d or even of a itself we see that in the above simple case we have been able to replace a union of arbitrary sets a and b by unions and differences of sets that remain small in fact they have at most one element thus an asymptotic order of magnitude has been achieved we would now like to formalize further the two important factors in this type of code i m p r o v e m e n t i the a b i l i t y to e f f i c i e n t l y m a i n t a i n fe p for e x p r e s sions e and the b o u n d e d n e s s of these sets definition we use e p for expression e and point p to stand for the pair e p and e d p represents the set of elements added to the set denoted by e and not removed from that set since the last time control p a s s e d p o i n t p e p r e p r e s e n t s the set of elements removed from and not added to that set since control last passed p note that this definition coincides with the earlier definition of in the case e is a single identifier we of loop between as long say e is an i o n expression l at point p whenever we can main p with a b o u n d e d a m o u n t of work successive times through point p as control does not leave l definition let us say an expression is of limited at point d in loop l i and e are of bounded size as as control within loop l it is important to note that the notions of induction expression and expression of limited are not the same nor does one imply the other for e x a m p l e ke p m i a h t be known to be either or a but we have to solve the halting problem for turing machines to tell which thus an expression could be of limited yet not be an induction expression conversely consider the situation of fig i where a could be q ia bu c p r la d u ei t h e o r e m i if in l i d e n t i f i e r a has assignments then it is an induction variable and is of limited at all points in l where there is a bound on the number of assignments to a encountered going from p to p in l proof the size of za d and ia p changes by at most one and can be updated by a bounded amount of work each time an assignment of a is encountered since there is only a bounded number of assignments of a from p to p w i t h i n l the size of t a p and l a p and the total work i n v o l v e d in m a i n t a i n i n g a p from p to p are also bounded hence a is an induction variable and is of limited p e r t u r b a t i o n at p f i g u r e i assigned either b u c or d u e before control reaches point p then if b u c and d u e are induction expressions at points q and r respectively we shall see that a is an induction variable hence an induction e x p r e s s i o n at p o i n t p yet b u c and d u e can differ by arbitrary amounts and we might a path such as q p r p so p is s u r e l y not of limited b u i l d i n g i n d u c t i o n v a r i a b l e s and we shall now develop the mechanism induction variables can be detect ed in a manner and tion in strength performed on them where possible the that what changes to the are made will actually improve things the theorems presented here most of the set the implication is that the reason reduction in strength can not be performed in many cases has to do with the structure of control flow in the program rather than the properties of the operators used in calculation the example in figure shows a situation where a is not an induction variable and is not of limited at a point p in loop l even though all assignments to a in l are t h e o r e m if in l a and b are induction variables and of limited at point p then a u x a x a u b a ii b and a b in g e n e r a l any b i n a r y b o o l e a n o p e r a t i o n on a and b are induction expressions and of limited at p proof we shall show that if e is one of the e x p r e s s i o n s a u ix a x a u b a ii b a b then r e p and e p are bounded in size and can be obtained from a p and ib p using a b o u n d e d amount of work hence e is an induction expression and is of limited at p first let e be the expression a u x t h e n e p can be c a l c u l a t e d from a p by the f o l l o w i n g p r o g r a m the first theorems enable us to construct new induction variables and expressions from old ones these theorems will all be stated in a simple form that ignores the possibility that two or more variables could be mutually dependent induction variables e g in a loop containing assignments a b u x and b a u y both a and b might be induction variables once the principles are understood this type of extension is easy definition call an assignment if it is of the form a a u x or a a x f i g u r e o e p xa d p p if x in a d t h e n ze p p i s e if x nt in ie d t e e n z e p z e x d u x s i n c e a o and a p are bounded in size and can be maintained us a bounded amount of work e p and e p are also b o u n d e d in s i z e and can be obtained using a bounded amount of work e u b f u a f u a e u b lemma i let d a r de points in loop l suppose control passes from p to g through path ii then from g to r through path l e t ii be the pair a p at a a f t e r c o n from p to q through path ii l e t zx be the pair a at r a f t e r c o n passes from q to r through path l e t zx be p at r a f t e r c o n t r o l d to r through ii followed by then if we write each i as the ordered pair similarly let e be a x ie can be calculated as follows e p xa p ie d a p if x in z e d zi then ie p e p x e l s e if x not in ie p t e n ie p ie d u x p let e be a u b then ze p a d u b d and e d a p v b u s p v a where va and vb denote the current value of a and b respectively n o t e that b o t h xa p vb xb p va may be o b t a i n e d in p r o p o r t i o n a l to the s i z e of a p s p and time and for example let c a p vb c can be obtained by the following piece of code c for x in a p do if x not in vb then c c u x since we have assumed that membership testing and insertion can be performed in unit time c can be obtained in time proportional to the size of a p let e be a jj b h e n e d a a p jj vb u a b o j va and e p k a p u fi b p let e be a b t h e n xa pe v b u and zx p a ii vb u ea i b p jj via b p u i via b e f o r e on to t h e o r e m we need some definitions of operations on the definition let be sets def i n e ab cd to be the pair ad u cb da u bc definition let a b e f be sets define ef ab to be the pair a i i i p r o o f t h e p r o o f of i is s t r a i g h t f o r is omitted here to d r o v e let i o be b c d and e f r e s p c t i e l v i e ad u cb a by f bc u da we c l a i m t h a t c e u b f u a ie c ad u cb u b bc u da u a ad u c u bi bc u d u a let t ad u c u b and let t bc u d u a we shall show that c is a subset of t t and t t is a subset of c for all x in c x is in ad u c u b ie x is in ti obviously x is not in bc also x is not in d because c and d are disjoint by definition of again x is not in a because a end c are disjoint due to the fact that ii and are consecutive paths hence x is not in bc u d u a ie not in t therefore x is in t t ie c is a subset of t t to that t t is a subset of c suppose the contrary ie there exists x in t t which is not in c since x is in t ad u c u b and not in c x must be in either or in bc in both cases x is in bc u d u a the assumption that x is not in t hence t t is a subset of c therefore c t t t h a t d f u a e u b c a n be proved in similar fashion theorem suppose there is a unique assignment a e which is always the last assignment to a before control reaches p and that there is a bounded number of assignments to a going from assignment a e to point d if e is an induction expression and of limited at the point of assignment a e then a is an induction variable and of limited p e r t u r b a t i o n at p proof let q be the point of assignment a e we want to show that a p is of bounded size and can be obtained using a bounded amount of work consider the path as control passes from p the ith time to p the time since q is always the last assignment before control reaches p we can consider the following three paths ii followed by followed by where i is the path f o l l o w e d as c o n t r o l p a s s e s g to p the ith time o is the path followed as control passes from p the ith time to a i is the math followed as control q to p the time let d e n o t e the v a l u e of a q after control from a to a math followed by i is bounded in size nd can be maintained using bounded amount of work because a is an induction variable and is of limited at g let d e n o t e the v a l u e of za q at p control passes from q to p through path z is b o u n d e d in size and can be maintained using a bounded amount of work because there are only a bounded number of i n c i d e n t a l a s s i g n m e n t s b e t w e e n q and p h e n c e b v of lemma i a p at a after control from p to a through path is given by z a let d e n o t e the v a l u e of a a q at p control passes from g to p through path i by i of l e m m a i za p when passes from p to p path followed by is given by z a z which is bounded in size can be obtained using a bounded amount of work theorem illustrates a situation in which a can not be identified with the expr e s s i o n e in the loop l and shows how it can be handled without using a temporary the size of a or copying between a and the we can extend part of theorem to the common case where a has a value outside l and the first time point p after entering l the external assignment to a is the most recent as in fact a far stronger result is possible as far as induction variables are concerned t h e o r e m s u p p o s e at p o i n t p in loop l there are k possible assignments to a say a e a e a e w h i c h could be the ast n o nz e n t a l k a s s i g n m e n t to a and suppose all e i for which a e i is actually in loop l are induction expressions and of limited at the point of assignment let qi be the point of i g n m e n t a e i s u p p o s e there is a bounded number of assignments of a g o i n g from qi to p s u p p o s e further that there is a bound on the number of assignments to a encountered going from p to p in l t h e n a is an i n d u c t i o n v a r i a b l e of l at p proof intuitively the value of a at p switches among k expressions each of which is an induction expression if k copies of a are kept where the ith copy has the value of a after its most recent assignment to e i za p may be represented by a switch an integer and the list e p e k p the switch is set to i to indicate that the ith copy of a is currently applicable ie any reference to a should be made to the ith copy f the last assignment to a before reaching p is a e then e p e o if there is n a s s i g n m e n t s to a b f w e e n g and p if there are assignments to a b e t w e e n a and p e i p may be o b t a i n e d as in t h e o r e m e are reset only if assignment to a before p is a e the work to maintain the switch and al the zs is b o u n d e d since each of the s is maintained in bounded time and the switch is changed a bounded number of times by the hypothesis of the theorem note that we are missing from theorem a statement about a being of limited p e r t u r b a t i o n of l at p the reason o b v i is that one cannot always conclude such a statement and fig provides the canonical example why not thus while one can between theorems and to find more and more induction variables and expressions within a loop one cannot do so b e t w e e n t h e o r e m s and we can however extend the idea of the switch to a g e n e r a l i z a t i o n of t h e o r e m t h e o r e m c o n s i d e r a point p in loop l and suppose that the finite collection e all the formulas for the v a l of variable a at p in terms of the values of variables the previous time t h r o u g h point p if each of the e s are induction expressions and of limited per at p then a is an induction variable at p proof there are only a finite number of different sequences of assignments which can affect the value of a as we from p to p within l or else the set of expressions for a would be infinite r e p r e s e n t a p by a s w i t c h and the set of e ps for all i k k of a have to be kept so each e o r e p r e s e n t s the change with respect to the ith copy of a b o o l e a n v a l u e d e x p r e s s i o n s while we have stated our theory of induction variables in great when it comes to specific operators that held form induction we have only mentioned union intersection and similar operations in fact the theory does extend to the usual set theoretic relations such as inclusion when dealing with an expression like a c b w h o s e v a l u e is b o o l e a n the n o t a tion and the notion of limited are and in fact the actual value of the expression is no harder to maintain than it is to increment thus we define a boolean valued expression to be an induction expression of l at p if its value than ts increment can be maintained with a constant amount of work from p to p w i t h i n l t h e o r e m if a and b are i n d u c t i o n v a r i t h e n a c b and a b as well as a variety of similar relations are induction expressions proof c o n s i d e r a c b by t h e o r e m a bs an i n d u c t i o n e x o r e s s i o n and of l i m i t ed the value of a c b can be maintained bv computing a b and testing it for emptiness when it changes a task we assume takes unit time per change in the actual implementation however only the c a r d i n a l i t y of a b whose value is if and only if a c b need be maintained t h e o r e m b o o l e a n o p e r a t i o n s on b o o l e a n valued induction variables yield induction expressions a p p l i c a t i o n s to i t e r a t o r s we would like to extend the notion of induction variable to interesting iterators as d i s c u s s e d in s let us c o n s i d e r the set former x a i sx to be specific now in the intermediate code we use this iterator is actually a loop of its own in which x runs through every element of a since x is not an induction variable here the e x o r e s s i o n x c a i sx cannot be an induction expression for this loop except under the most trivial of thus the set former cannot be an induction expression in a loop outside its own internal loop there is on the other hand a fairly broad condition under which we can prove an order of magnitude improvement in the calculation of the set former is possible theorem let l be a loop c o n t a i n i n g set former x c a l sx at point p suppose a and x for all x which could ever be members of a are all induction expressions and of limited o e r t u r b a t i o n at p in l then the value of x a i sx can be m a i n t a i n e d w i t h w o r k p r o p o r t i o n a l to where by we mean the work necessary to compute x for any x that may be in a note that the straightforward evaluation of the set former r e q u i r e s work proof between any two consecutive executions of x a i x the number of x in a such that the value of x changes is bounded by since each sx is an induction expression and is of limited at p the total work involved in maintaining them is bounded by between any two consecutive executions of the set former the number of new elements added to or deleted from a is also bounded because a is an induction variable and is of limited at p the work involved in the addition and deletion is proportional to hence the total w o r k n e c e s s a r y is p r o p o r t i o n a l to theorem let l be a loop containing the predicate pa at p where pa is vx g a x or x c a x suppose a and x for all x which could ever be members of a are all induction expressions and are of limited at o in l t h e n the v a l u e of pa at p can be m a i n t a i n e d w i t h w o r k p r o p o r t i o n a l to where is the work necessary to compute x for any x that may be in a the s t r a i q h t f o r w a r d evaluation of pa r e q u i r e s in the worst case proof let pa vx a x the value of pa at p can be obtained by computing t the c a r d i n a l i t y of the set x c a l not x which can be maintained w i t h w o r k p r o p o r t i o n a l to by t h e o r e m s and pa is true iff t a g a i n in actual i m p l e m e n t a t i o n t rather the set itself is maintained similarly if pa x g a x its value is true iff the set x a i x is nonempty in the actual only r those x in a such that x has actually changed should be updated if the size of ii this subset of a is considerably smaller t h a n and that t h e m a p p i n g to o b t a i n this subsets can be outside the loop it may be desirable to have this mapping available in some cases this mapping always maps to a subset of a of constant size then the total work in in maintaining the set former is proportional to we shall this with examples i c o n s i d e r px e b fy x if b and f consider a function as a set of ordered pairs with distinct first elements are induction variables and are of limited at p then the value of px can be maintained by maintaining the value t cardinality of the set y c b i fy x as follows for y in b p do if fy x the t t for y in d do if fy x th t t a change of f say fy z is rewritten as if y is in b then begin f fy x then t t if z x then t t end fy z c o n s i d e r e x e a i x c b if b is an induction variable and is of limited at d then x x c b is an induction expression and is of limited at p for all x in a if a is also an induction variable and is of limited at p then e is an induction variable and is of limited at p let tx let x a i y x e p c a n be c o m p u t e d as f o l l o w s e p e p for y in e d f e d o v for y in a p do begin compute ty if ty then e p ee p end u y for y in p do for z in do begin if tz then e p e tz tz end end p u z for y in p do begin for z in do begin tz tz if tz then e p i e e end end d o z if find is computed outside the loop then the work necessary to obtain e p is p r o p o r t i o n a l to c c o s t a x where c is an upper bound on the size of for any y in a and x is in the worst case c is er if c is a constant independent of t h e n e p c a n be c o m p u t e d u s i n g work proportional to i f e allen program optimization in annual review in automatic vol pp f e allen and j a of optimizing transformations in design and optimization of compilers r ed hall pp j and schwartz programming languages and their compilers institute new york a v and j d ullman the theory of parsing translation and ii hall f e allen j and k kennedy reduction of operator strength tr dept of math sciences rice univ aug j and k kennedy an algo rithm for reduction of operator strength tr dept of math sciences rice univ march a c j b and j d application of lattice algebra to loop optimization proc acm sym on principles o programming languages j high level iterators and a method of automatically designing data structure representation computer science division univ of cal if berkeley j t schwartz on method of iterator inversion setl no j t schwartz on programming i and ii and 