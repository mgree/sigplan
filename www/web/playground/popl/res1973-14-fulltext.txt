actor induction and peter richard smith should not only work but they should appear to work as well the project ia research in natural and effective means for embedding knowledge in procedures in the course of this work we have in unifying the around one fundamental concept the actor intuitively an actor is an active agent which plays a role on to a script we use the actor to emphasize the of control and data flow in our model data structures functions monitors ports descriptions nets logical formulae numbers identifiers contexts and data bases can all be shown to be special cases of actors all of the above are objects with certain useful modes of behavior our formalism shows how all of these modes of behavior can be defined in terms of one kind of behavior to actors an actor ia always invoked uniformly in exactly the way regardless of er t as a recursive function data structure or process it is to multiply entities william of beyond need is the answer the unification many benefits and simplification for us in particular of the formalism for the procedural embedding of knowledge has a great it enables us to properties of procedures more easily furthermore the of properties of procedures is made easier and more uniform every actor has an intention which checks that the and the context of the actor being sent the message are the intention ia the contract that the actor has with the outside world how an actor its contract is its own by a simple bug we mean an actor which does not satisfy its intention we would like to eliminate of actors by the nf show that they satisfy their by this we do not necessarily mean a in the first order for inputoutput assertions written in the firstorder calculus the rules of deduction to that satisfy their essentially take the form of a high level interpreter for abstractly evaluating the program in the context of its this process called can be justified by a form of induction in general in order to a property of the behavior of an actor system some form of induction will be at present actor induction for an actor configuration with e can be described in the following manner the actors in the e satisfy the of the actor to which they send messages and for each actor a the intention of a is satisfied for all actors sent messages by a are satisfied the therefore the of all actions caused by e are satisfied ie the system behaves correctly computational induction manna structural induction burstall and induction are a special cases of actor based have the advantages the intention is from the actors it describes of concurrent actions are more easily we can more write for between actors the are written in the same formalism as the procedures they describe thus can because protection is an property of actors we hope to be able to deal with protection issues in the same straight forward manner as more conventional of data structures are handled by the same machinery as for all other actors syntactic sugar the good of north and and lines so the would and the would reply they are merely conventional lewis thus far in our discussion we have discussed the semantic issues intuitively but we would now like to proceed with more precision unfortunately in order to do this it seems necessary to introduce a formal language the precise nature of this language is completely so as it is capable of expressing the semantic meanings we wish to for some years we have been constructing a series of languages to express our understanding of the above semantic issues the of these is called variables will be we shall assume that the reader is familiar with advanced pattern matching languages such as a and we shall use a w to indicate sending the message m to the actor a we shall use fst o sn to denote the s s sn a sequence s is an actor i is element i of s for example a c b is c we will use to the simultaneous synchronous transmission of more than one message so that al a an will be defined to be a a an the expression al a an read as al then a finally send back an will be evaluated by evaluating al a and an in sequence and then sending back the value of an as the message identifiers can be created by the prefix operator for example if the pattern is matched with v then a new identifier is created and bound to v but doesnt mean a nice argument alice when i use a word said in rather a it means just which i choose it to more nor less the question is said whether you can make words mean so many different things the question is said which is to be all lewis two criteria on the rules for names each actor has complete control over the names he uses all other actors must respect the meaning that an actor has chosen for a name we are to note that in addition to satisfying the criteria of our names also satisfy those subsequently proposed by and the default is not actor extend the scope of a name to any other the right to access a name is by mutual between the actor and each accessing actor an access right to an actor and one of ts is it is possible to distinguish different types of access the definition of a name access to a name and allocation storage are of the use of the prefix does not imply the allocation of any storage one of the simplest kinds of a cell a cell with initial contents v can be created by evaluating cell v given a cell x we can ask it to send back its content by evaluating contents x which is an abbreviation for x contents for example contents cell evaluates to we can ask it to change its contents to v by evaluating x c v for example let x be cell and evaluate x we will subsequently find that contents x will evaluate to the pattern p matches object e if the pattern p matches cell e ie a cell see below which contains e thus matching the pattern x against s the same as binding x to cell ie a new cell which contains the value of the expression e we shall use read message to mean an actor which is of the actor in the lambda calculus for example x body is like body where is an identifier an expression pattern body is an abbreviation for pattern body where receive is a more actor that is capable of elements of the action in addition to the evaluating pattern ie sending pattern body will attempt to match against pattern if is not of the form specified by pattern then the actor is e if matches pattern the body is evaluated evaluating cases fl f message arg and if s not applicable then it will send f the message arg etc until it is the not applicable is sent back if none were applicable evaluating cases fl f fn fl the message arg and send fn the message arg concurrently the following be used to improve readability send rules object clauses for where object body for for example where tj x x is let xo c ex xl xn expression for fo xl n expression for example let x y the worlds a the a state which and nature do with actors fill thomas conceptually at least a new actor is created every time a message is sent to a target a message a continuation consider send message continuation the transmission t m is an abbreviation the the following for the above where is to be the caller if receive message continuation the then evaluated in an environment where is bound to m and is bound to c we define an be a of the form ct m n where the continuation of the caller the target m the message thereby creating a new actor n we define a be a strict partial order of events the transitive closure of the partial read as cl tl ml nl c tm n if nl c t m is the above definition states that one action another if any of the actors generated by the first event are used in the second event the relation can be thought of as the arrow of time notice that we do not require a definition of global ie we do not require the two arbitrary events be related by we define the a history with respect to an a set of actors e to be the consisting of those an element of the e the of a configuration of actors is the set of all behaviors of the configuration for all interpretations of the actors in the the a configuration defines what the configuration does as opposed to how it does it two configurations of actors will be said if they have the same we can name an actor the name a in the body b by the notation label a h b more precisely the the actor f e n b is defined by the fixed point of f ie the minimal f in the case where f happens to define a will be the case that the f is isomorphic with the graph set of ordered pairs of the function defined by f and that the graph of f is also the least fixed point of park and scott many returns many actors who are executing in parallel can share the same continuation they can all send a message return to the same continuation this property of actors is exploited in meta evaluation and synchronization an actor can be thought of as a kind of virtual processor that is never in the sense that it cannot be sent a message the basic mechanism of sending a message preserves all information and is entirely free of side effects hence it is most suitable for purposes of semantic of special cases of invocation and for debugging situations where more information needs to be preserved however if fast memories are developed then it would be suitable to be implemented directly in hardware the following is an overview of what appears to be the behavior of the process of a running actor r sending a target t the message m specifying c as the continuation if c is not explicitly specified by r then a representative of r must be constructed as the default call the of r to the of by the caller the will probably eventually send a message to the scheduler of t the scheduler will probably eventually send a to the monitors oft the monitors will probably eventually send a message to the of t the of t will probably eventually send the message m co t t will finally attempt to get some real work done there are several important things to know about the process of a message to an actor conceptually at least whenever a target is passed a a w actor is constructed which is the target instantiated with a message when possible we reuse old actors where the reuse cannot be detected by the behavior of the system sending messages between actors is a universal control sense that control operations such as function invocations resource scheduling synchronization evaluation of expressions are special cases the coroutine and continuous actors can their directly with each others have to set up some such as ports or possibility lists and which act as must be they do not and mitchell which sending a message to an actor is entirely free of side effects such as those in the message mechanism of the current l talk machine of alan the port mechanism of and and possibility lists being free of side effects allows us a maximum of parallelism and allows an actor to be in several at the same time without sending a message to an actor makes no that the actor sent the message will ever send back a message to the continuation the nature of messages enables us to define iteration monitors etc the is not an model such as the a continuation is a full actor with all the and it is ma program counter there are no instructions in the sense of present machines in our model instead of instructions an actor machine has certain primitive actors built in hardware data structures the list nil static data structures are special cases of actors for example consider the nil cases comment to print nil print the string list to stream out stream list it is empty x ord x true else structure is a structure true next the definition of we also define the function output x stream stream output the above is an operational definition of nil which is the null list for example nil structure is true evaluating output nil s will cause list to be to the stream s however from an operational point of view nil is not very interesting because it is completely static what we need to ask what are the useful modes of behavior that are in the usual notion of a list structure and define an object which behaves in this way so let us try to an operational definition of an arbitrary list in order to do this we need to be able to make in the world we will use the primitive actor cell to realize these changes definition of list cases th first element of the list is contents of contents rest the rest is contents of contents first list rest constructor a constructor for this kind of behavior is list list structure contents r first x contents rest x contents out out to print the list first print print that it is a list list print the first element contents print the rest of the elements in the list contents the function is defined below print the close structure true empty false the above definition is much more interesting for one thing there is a subtle in that if is implemented as a lambda calculus closure then it will onto too much storage since any actor which onto a piece of list structure will onto the of that list structure we will deal with this bug later but lets see how it works let x be nil thus x is n in the definition of with the name of a new cell which contains and the name of a new cell which contains nil now x first evaluates to but suppose we execute x first b causing first b to be matched against the patterns in the it matches first now x first evaluates to b the reason is that there is a side effect in the evaluation of x first b which changes the first element of x to b we can define a function which will print the elements of objects as follows which behave like lists supply else let element be the next element and be the remainder of the supply stream element out print element if the supply is do nothing nothing the function next calls up the supply and it for the next next i next note that to get the second and subsequent elements out of a stream the continuation received next sn must be used let nil the following expression will create a circular structure when evaluated w rest w output w s the will look like list to s and will never the the reader might be why we proceed in this way rest which takes the rest of a list like any ordinary it will never get to print why dont we write a function does for example rest b nil would be list b people who have taken the approach of to define such functions have come to realize that it is desirable to have some independence in the representation of data objects so they have tried to define rest as a polymorphic operator this means for example that attempt to operate on vectors as well as lists but then in any modeling situation in which a kind of object is desired for which we would like to be able to compute the rest the functional definition of rest would have to change the definition of rest must keep changing in a way in order to add new knowledge for example we might create strings and want to be able to take the rest of a string of course the following definitions of rest and first as functions will work rest z rest first z first these are in fact the definitions that we use note that we have two semantically related names rest and rest we use rest as a message and rest for the function which sends the message rest to its argument making the above definitions of first and rest and them instead of directly passing the messages first and rest does however increase the modularity of our formalism and so we shall adopt them for example the definitions of first and rest enable us to monitor these operations the reason that we have discussed the actor in such detail is that it provides a paradigm for the way in which we will define actors in general for example our definition of eval the actor which evaluates forms is x in other words eval passes the to each kind of expression which is expected to either know how to evaluate itself or to further the there remains the problem of up the and knowledge in a reasonable way at this point we have only a few heuristics to offer we hope to become more as we ain more practical experience with actors in general we program each actor to field those requests for which it qualified because the information needed is most immediately at hand for example we have not included length among messages by but rather have to write length supply message length al stream the answer is length if the supply is oj then there is a complete duality between operands and operators in the actor formalism in many cases the precise organization seems more a matter of then else the data type is the class of all actors that have the behavior defined above certain properties of the data type can be derived immediately from the definition for example where xy z first z is x where xy z where xy z z first x is z and z is equal to x y where z z rest y is z and z is equal to x y has given the above formulas as for lists in his system the data type list is the class of all structures that the above axioms however if nothing is known about the actor then xy z z first z first x is unknown the reason is that may have the list z and passed it to some actor which is still concurrently thus we dont know that the first of z is x even we just stored x there now any object which behaves like a list can be used in place of a list for example we can con struct an object which is from an arbitrary list z except that it will print out when ever its first element is to do this we will give a definition of a monitor monitors every actor can have monitors which get to read every message that is sent to the actor are mainly useful for and debugging a monitor can be constructed by monitors in going message out s what where pattern is the specification of the tor which by the way is optional an for can define a monitor for factorial that keeps one to the contents of every time that factorial is called and out the input output pairs on the stream for each call m cons monitor message i al output out print input output the system actor used to a new monitor in an actor for example factorial as a new monitor for factorial after which if factorial is evaluated then the contents will be increased by and the stream will be sent l l then and finally iteration iteration is a special case of sending messages to with inputs on one side and outputs on the other we a finite state machine initial input m he the the iteration statement is due to and has the syntax iterate e for example an iterative m factorial program can be written as n counter rules counter en counter counter notice that there are no assignment statements in the above program the behavior of is the same as if it were defined as follows n label receive message counter continuation c else send l counter counter continuation c we use cycle name t as an abbreviation for is the process of binding actors to their and then evaluating the actors abstractly on abstract data using actor induction we will show that if the of a configuration of actors succeeds then the of the actors will be satisfied in the subsequent execution of the configuration if the cannot proceed it will cannot that an actor always satisfied its intention and ask for help several possibilities stop at the point where it at this point there are there really is an inconsistency the inconsistency is between the way the actor is being to be used and its intention the inconsistency is between the intention of the actor and its actual implementation the for a configuration of actors are not mutually consistent there is no inconsistency but there are hidden assumptions being made about actors that should be made explicit there is hidden domain dependent knowledge that the actor is which should be made explicit the are not being sufficiently expected to be satisfied explicit as to why they are convergence can be used to show that certain inputs must eventually generate outputs the basic technique is the principle of induction over wellfounded partial orders v and formalized by john von the technique is a special case of actor induction at present actor induction for an actor configuration with input i and output o can be described in the following manner there is a wellfounded inputoutput partial order p that is there is no sequence s of distinct elements of p such that for every i we have s i p i the actors in the input i an element p of p to each input message m me will denote this by the notation for each actor a if mp is received by a then a must send a such that ppp therefore every message from the input must eventually result in a being sent to the output a simple example how a can we would like the of writing for the for follows to give a simple concrete example to illustrate our techniques in action consider a program to shift the of a with a manual transmission we introducing new syntax but the following concepts are crucial to the discussion which definitions x y body is actor syntax which at a intuitive level means called with an argument to which is bound executes define an actor x which when it is rules es yl y roughly means take x and if it matches y execute l execute body etc otherwise if it matches y x intention n il is an elaboration of meaning that when is called with then il is the intention the incoming call and i is the intention when calls out again our first try at a shift procedure might be of when called with a target checks to see if it is or and calls the appropriate select or respectively now we consider the various select incoming intention that the do the selecting when a selector to that selection routines and their each of the select functions has an be furthermore each of them has code delimited by to calls out we fully intend for the to be in the appropriate intention intention l ht intention f intention our notices that for each one that there is a physical constraint that the must be before he queries us this and so we decide to modify the function primitive to first the how the code for and finally the is to first the we also write functions to intention and the then do the as before intention now our is however the dealing with the transmission come to us with some additional constraints for example to select third the constraints are now that the must be and the must be in either second or fourth the other constraints are similar or i l intention and or the new requirements say that at least the has to be to shift into no can be in while running note you can shift directly from any the is so we have to write some new procedures to meet these new our toplevel function and to first if we now write when called with a target considers in order the rules for the if it is first a first if it is either one greater than the current or one less than the current then do a the target if it is greater than the current then and then the target one less than the target if it is less than the current then one greater than the target and then the target greater less we ask our to our program it for a while and two problems it can only shift to if the is it should not be to shift to the that it already is in the procedure does not work if it is to shift to the current we decide to give the following intention to if the is first then the must be otherwise the must be or and not be the current intention or current else to summarize we have used in the following somewhat distinct ways as a contract the contract that the actor has with is its own as a formal contract statement of the conditions its external environment under which the actor how it carries will its the above example does not deal with all of the computational issues that our will be with for example it does not have sophisticated data has no concurrency or parallelism we deal with these problems in the technical report acknowledgements everything of importance has been said before by who did not discover it north this research was by the mit artificial intelligence laboratory and project mac under a contract from the of research we would be very of any comments or suggestions that the reader might care to offer address them to room technology square mit artificial intelligence laboratory cambridge massachusetts the topics discussed in this paper have been under investigation by a number of re for a in this paper we have merely to construct a coherent formalism that the ideas that are currently in the we would like to the help of the following who the truth all along a data structure is nothing but a programming alan whose and small k machines have our work alan the crucial importance of de of data structures and of passing messages to them this paper the consequences of generalizing the message mechanism of smalltalk and the port mechanism of and mitchell and the previous call statement of a universal communication mechanism alan has been extremely helpful in discussions both of overall and technical details for his very iterate statement and for us to find a fast net for our john for making the first circular definition of an effective problem solving formalism and for the importance of the problem for artificial intelligence for his little for computation allen whose kernel approach to building software systems has here perhaps been carried to its extreme along one dimension david whose questions led us to further bob and mitchell who introduced the notion of a we have generalized into an actor robin milner is the problems of lvalues and processes from the point of view of the lambda calculus he has the practical as well as the theoretical implications of fixed point operators over the meaning of equality for processes led to our definition of behavior dijkstra for a discussion mitchell has explained the systems imple language bruce and showed us how to clean up and generalize certain aspects of peter and john reynolds for the importance of continuations for defining control structures who up and generalized the means of integrating editors and in higher level languages peter and john reynolds for the importance of functional data structures and who an implementation method that down on some of the overhead we have simplified their scheme by eliminating the reference counts and all of their primitives car hoare is independently monitors for data structures for sharing many of our same goals in his for his on logical clarity of definition and the importance of parallelism for our notation on the conventions of the values of cells and for being a strong of in language pitts and richard have given us valuable help and advice on systems aspects bruce and for implementing previous of these ideas in addition to their own for the im of procedure calls for the notion of a and and for the questions which led to our criteria for separating an actor from its base richard for out that are also considering the possibility of procedural semantics for logic he is doing some very interesting research in the much field of computational logic bob and others who made valuable suggestions at a which we gave at mit john for us to a of bugs from this document greg bruce bruce allen horn david and richard made valuable comments and suggestions on previous versions of this paper r m method for dynamic communication and job control the rand peter data types for programming generality ms june mit d and a model and stack implementation of multiple environments march burstall rm proving of programs by induction computer journal vol pp pj f gl concurrent control with readers and writers comm acm pp oct bruce automatic generation of compilers from interpreters ms a pop school university of edinburgh lp an interactive program verifier phd university of california at june relational level data structures for programming languages march ew foster jm gray hh and am a programming language based on sets motivation and example machine intelligence university press ae algorithmic language a reference manual and dept of engineering mit da control structures for programming languages phd carnegie r w assigning meaning to programs mathematical aspects of computer science cd math pp island induction ti proofs about programs project report synchronization of communicating processes comm acm pp march c and m record of project on con current and parallel computation june available from acm c p and r a universal modular for artificial report december revised march and june c p and r a universal modular actor formalism for artificial iii stanford aug hoare car an axiomatic definition of the programming language pascal february alan c private communication r systems programming or program made easy first usa computer conference october pj the next programming languages comm acm march pp manna z ness s j inductive methods for proving properties of programs pro of an on proving assertions about programs january j paul w daniel j p and michael i lisp programmers manual mit press j definitions of new data types in algol x algol oct milner r private communication mitchell a unified sequential control structure model morris j h protection in programming languages cacm jan p of programs by general bit a p d and g the kernel approach to building software systems university computer science research park d fixpoint induction and proofs of program properties machine intelligence edinburgh university press s closure properties of of determinate systems project on concurrent systems and parallel processing june aj the of algorithmic systems jacm jan reynolds jc language based on the principle of completeness and the reference concept cacm reynolds jc definitional interpreters for higherorder programming proceedings of convention f ja and r j qa a procedural calculus for intuitive reasoning phd stanford scott d data types as lattices notes amsterdam june t a data definition facility for programming languages phd carnegie r actors ms r private communication wang a and o coroutine sequencing in a structured environment bit r and milner r programming semantics and correctness in a mechanized logic first computer conference october w and global considered university pittsburgh pa sigplan 