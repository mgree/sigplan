the tree width of auxiliary storage p university of illinois at usa and university of paris france abstract we propose a generalization of results on the decidability of emptiness for several restricted classes of sequential and distributed automata with auxiliary storage stacks queues that have recently been proved our generalization relies on reducing emptiness of these automata to finitestate graph automata without storage restricted to monadic secondorder mso definable graphs of bounded treewidth where the graph structure encodes the mechanism provided by the auxiliary storage our results outline a uniform mechanism to derive emptiness algorithms for automata and simplifying several existing results as well as proving new decidability results categories and subject descriptors f theory of computation models of computation automata d software engineering verification model checking f theory of computation formal languages decision problems general terms algorithms reliability theory verification keywords model checking automata decision procedures bounded treewidth introduction several classes of automata with auxiliary storage have been defined over the years that have a decidable emptiness problem classic models like pushdown automata a stack have a decidable emptiness problem and several new models like restricted classes of pushdown automata automata with queues and automata with both stacks and queues have been proved decidable recently the decidability of emptiness of these automata has often been motivated for modelchecking systems software models can be captured using automata with auxiliary storage as stacks can model the control recursion in programs while queues model fifo communication between processes in modelchecking data domains get abstracted from programs resulting in automata models eg the slam tool builds pushdown automata models using predicate abstraction and the tool both and automata models the emptiness problem for these automata is the most relevant problem as it directly corresponds to checking reachability of an error state however the various identified decidable restrictions on these automata are for the most part in their definitions eg emptiness of pushdown automata where pushes to any stack is allowed at any time but is restricted to the first nonempty stack is decidable yet these definitions to more natural ones seems to either decidability or their power it is hence natural to ask why do these automata have decidable emptiness problems is there a common underlying principle that explains their decidability we propose in this paper a general criterion that uniformly explains many such results several restricted uses of auxiliary storage are decidable because they can be simulated by graph automata working on graphs that capture the storage as well as their sequential or distributed nature and are also of bounded treewidth more precisely we can show using of known results on the decidability of satisfiability of monadic secondorder logic mso on bounded treewidth graphs that graph automata on graphs of bounded treewidth are decidable graph automata are finitestate automata without auxiliary storage that accept or reject graphs using of the graph using states where the restrictions on tiling determine the graphs that get accepted the general decidability of emptiness of graph automata on graphs follows since the existence of acceptable is we proceed to show that several automata with an auxiliary storage we consider stacks and queues only in this paper can be realized as graph automata working on single or multiple directed paths augmented with special edges to capture the mechanism of the storage intuitively a symbol that gets stored in a and later gets can be simulated by a graph automaton working on a graph where there is a special edge between the point where the symbol gets stored to the point where it gets a graph automaton can the symbol at the point by using an appropriate tiling of this special edge the idea of converting automata with storage to graph automata without storage but working on specialized graphs is that it allows us to examine the complexity of storage using the structure of the graph that simulates it we show that many automata with a tractable emptiness problem can be converted to graph automata working on mso definable graphs of bounded treewidth from which decidability of their emptiness follows we prove the simulation of the following classes of automata with auxiliary storage by graph automata working on bounded treewidth graphs permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm pushdown automata with bounded this is the class of automata where each tion of the automaton can be divided into k stages where in each stage the automaton only one stack proved decidable first in we show that they can be simulated by graph automata on graphs of treewidth ok pushdown automata with bounded phases these are automata that generalize the ones the computations must be into k phases for a fixed k where in each phase the automaton can push onto any stack but can pop only from one stack proved decidable recently in we show that graph automata on graphs of treewidth ok not ok as in the above case can simulate them ordered pushdown automata the restriction here is that there is a finite number of stacks that are ordered and at any time the automaton can push onto any stack but pop only from the first nonempty stack note that the computation is not divided into phases as in the above two restrictions we show that automata on graphs of treewidth on · n where n is the number of stacks can simulate them distributed queue automata on architectures distributed queue automata is a model where finitestate processes at n sites work by communicating to each other using fifo channels modeled as queues it was shown recently that when the architecture is a ie the underlying network graph of the architecture is a forest the emptiness problem is decidable and for other architectures it is undecidable we prove that graph automata working on graphs of treewidth in fact n where n is the number of processes can simulate distributed queue automata on architectures distributed queue automata with stacks on forest architectures when we each process in a distributed queue automaton with a local stack it turns out that if the automaton is and the architecture is a forest the emptiness problem is decidable the condition demands that a process may from a queue only when its local stack is empty furthermore it is known that simply the condition or the condition that the architecture be a forest makes emptiness undecidable we prove that graph automata that work on graphs that simulate both the local stacks and the queues can capture these automata and for automata over forest architectures the graphs are of treewidth on where n is the number of processes the graphs on which the graph automata need to work to realize the above automata are also surprisingly uniform for the first three classes of automata the graphs are simply a single word with a set of nesting edges relations one relation for each stack for distributed queue automata the graphs are composed of n distinct linear structures one for each process with queue edges connecting vertices to vertices and if the processes have stacks have nesting edges at each process to capture the local stack the for these graphs as well as the proofs that the give bounded treewidth for the restrictions are involved and are to exploit the restriction placed on the automata the idea of interpreting stacks as nesting edges was motivated by the work relating pushdown automata with nested word automata ­ where nesting edges capture a visible stack our work is also motivated by the work on automata in which we were involved where were used to show decidability of emptiness the other known decidable automata restrictions led us to this uniform framework for proving decidability the automata variants we study were often first proved to be decidable by different means bounded automata were shown to be decidable using of tuples of reachable configurations ordered automata were shown decidable using of associated grammars followed by a parikh theorem and distributed queue automata with stacks were shown decidable by reductions to automata our theorems also lead to new consequences first automata with are decidable when their graphs are restricted to graphs of bounded treewidth and in fact even bounded graphs this result generalizes all the above sequential automata second several of our results extend to automata over infinite behaviors for example it follows easily that ordered bu¨chi or parity automata on infinite words have a decidable emptiness problem third several variants of the restrictions can be proved immediately decidable for example suppose we restrict automata to k phases where in each phase there is only one stack that is pushed into but arbitrary of stacks are allowed then it easily follows that emptiness is decidable as the graphs corresponding to these automata are precisely the same as those of bounded phase automata save for the of the linear and nesting edges and hence has the same treewidth section gives a summary of consequences of our general result due to the variety of automata models we consider we do not give all definitions and proofs in the main text the proofs for the of treewidth for various restrictions of pushdown automata are given in the appendix while the proofs regarding distributed queue automata can be found in the technical report logics graphs graph automata treewidth and emptiness we start by defining in this section graph automata that work on finite directed graphs and show that the emptiness problem for these automata is decidable over any class of graphs of bounded treewidth this result is derived from classical results on interpretations of graphs on trees and we sketch the derivations here monadic secondorder logic on graphs fix a finite alphabet set a labeled graph is a structure v where v is a finite nonempty set of vertices and each ea v × v is a set of directed edges we will assume throughout this paper that for any vertex v there is at most one incoming edge and at most one outgoing edge we view graphs as logical structures with v as the universe and each set of edges ea as a binary relation on vertices monadic secondorder logic mso is now the standard logic on these structures we fix a countable set of firstorder variables we will denote these as x y etc and another countable set of set variables denoted as x y etc mso is given by the following syntax x y eax y x x ¬ x x where a the semantics is the standard one with firstorder and set variables interpreted as vertices and sets of vertices we say a class of labeled graphs c is if there is an mso formula such that c is the precise class of labeled graphs that satisfy graph automata fix a class of labeled graphs c a graph automaton ga on c is a tuple q type where q is a finite set of states each ta q × q is a tiling relation and type q × is the note in the literature a variant of mso called mso has been considered where both vertices and edges are in a universe and are related by an relation that version is stronger than ours but we shall not need it for our intuitively a graph automaton will accept a graph if there is a way to tile label the vertices by states so that the tiling relation is satisfied by vertices adjacent to each other and further satisfies the the associates each state to a pair in out of sets of labels and in order for a state to a vertex we require its type to match the edges on it ­ the labels of incoming and outgoing edges must be precisely in and out formally we say that a graph automaton q type accepts a graph v if there is a map v q that satisfies the following conditions · for every u v ea with a u v ta · for every u in out where in a v v u ea and out a v u v ea the language of a graph automaton ga over a class of graphs c denoted is the set of graphs in c that it accepts note that the notion of an automaton running over the graph has been replaced by tiling constraints also we have done away with initial or final states we will capture these when needed using labeled edges in the sequel our notion of graph automata is motivated by definitions of automata on graphs through in the literature graph automata can in fact be defined more see however for our purposes the above definition will suffice most of our results will carry over to of the above definition treewidth we recall the definition of treewidth for graphs see the treewidth of a graph intuitively captures how close a graph is to a tree formally a of a graph v e is a pair t bag where t n is a tree and bag n v is a function that satisfies · for every v v there is a node n n such that v · for every edge u v e there is a node n n such that u v and · if u and u for nodes n n n then for every n that lies on the unique path connecting n and n u the width of a tree decomposition is the size of the largest bag in it one ie the treewidth of a graph is the smallest of the of all of its tree it is easy to see that the treewidth of a tree is while the treewidth of a is k emptiness of graph automata on graphs of bounded treewidth we now show that emptiness of graph automata is decidable when evaluated over graphs that are definable in mso and are also of bounded treewidth first we recall a classical result that the satisfiability problem for mso is decidable on the class of all graphs of treewidth k for a fixed k classic theorem shows that checking if a particular graph g of treewidth k for a fixed k satisfies a fixed mso formula is decidable in linear time this result works by defining the graph in a labelled tree by mso formulas and by translating the mso formula about graphs into one about trees and using a for the mso formula to check if the corresponding tree is accepted it turns out the same proof can be used to prove the satisfiability theorem that we refer to above as well intuitively we can interpret all graphs of treewidth k by using a uniform set of labeled binary trees whose labels only depend on k translate the mso formula on graphs to these labeled trees and use the fact that satisfiability of mso on trees is decidable theorem the problem of checking given k n and m so over labeled graphs whether there is a labeled graph g of treewidth at most k that satisfies is decidable note that the above certainly does not imply that satisfiability of mso is decidable on any class of graphs of bounded treewidth take a nonrecursive class of for a counterexample however an immediate corollary is that satisfiability of mso is also decidable on any class of graphs c of bounded treewidth if c defines the class of graphs and is the mso formula we can instantiate the above theorem for c corollary let c be a class of mso definable labeled graphs the problem of checking given k n and an whether there is a graph g c of treewidth at most k that satisfies is decidable we can now prove that the emptiness problem for graph automata is decidable when restricted to bounded treewidth graphs over an class of graphs intuitively we can write an mso formula that checks whether there is a proper tiling of a graph by the graph automaton that respects the tiling and typing relations this formula will essentially use an existential quantification of a set of sets xa for each a to guess a tiling and check whether the tiling and typing is proper using universal firstorder quantification on vertices we can then instantiate the above corollary with this formula to show decidability of graph automata emptiness in fact using a direct automaton construction on trees we can show the complexity of emptiness as well see for a of proof to obtain our result theorem let c be a class of mso definable labeled graphs the problem of checking given k n and a graph automaton ga whether there is some g c of treewidth at most k that is accepted by ga is decidable and decidable in time the above theorem will be the key result we will use to uniformly prove decidability results in this paper for various restrictions of sequential and distributed automata with auxiliary storage we will translate them to graph automata over graphs show that the relevant graphs are of bounded treewidth and use the above theorem to prove decidability of emptiness pushdown automata in this section we will show the decidability of emptiness of various restricted pushdown automata bounded bounded phase and ordered by showing that they can be simulated by graph automata working over word graphs that are of bounded treewidth for any n n let n denote the set n a pushdown automaton is an automaton with finite control and equipped with a finite number of stacks a transition of this automaton consists in or a symbol from a specified stack and changing its control or simply an internal move that affects only the control state without of the stacks contents definition pushdown automata for a fixed n n an pushdown automaton is a tuple m q q qf where q is a finite set of states q q is the initial state is a finite stack alphabet qf q is the set of final states and push pop int where · push q × q × × n is the set of push moves · pop q × × q × n is the set of pop moves and · int q × q is the set of internal moves a pushdown automaton is an pushdown automaton for some n n a configuration of an m q q qf is a tuple q s sn with q q and sj is the content of stack j for every j n let c q s sn be a configuration of m then c is the initial configuration if q q and sj for every j n moreover c is a final configuration if q qf and sj for every j n given two configurations c q s sn and c q s sn there is a transition from c to c on the action act from the behavior set bn int push pop denoted c act c if one of the following holds push onto stack j act and there exists such that q q j push sj sj and sh sh for every h n j pop from stack j act and there exists such that q q j pop sj sj and sh sh for every h n j internal act int and q q int and sh sh for each h n a run of m is a sequence of transitions of m c act c cm where c is initial and cm is final for each such run of m we associate the behavior word and define the set of behaviors of m as the language is a run of m note that the behaviors capture the way the automaton handles the stacks noting the push and pop operations and the stack on which they are performed the emptiness problem for an m is the problem of checking if is empty or equivalently whether there is a run of the words in the following we show that can be naturally encoded as graph automata on a class of graphs that we call multiply nested words and the emptiness problem on the former reduces to the emptiness problem on the latter we start by defining multiply nested word graphs definition multiply nested words for a given integer n an word is a tuple n v init f l ej jn where · v is a finite set of vertices · l v × v is a successor edge relation such that l is a linear ordering l on the vertices of v · if x is the minimum element wrt l then init x x if x is the maximal element wrt l then final x x · ej v × v is a nesting relation for every j n a nesting relation ej is a relation that satisfies the following properties for all u u v v v and j j n if v then u l v holds if v and v then v v and if v and v then u u if v and v and u l u then either v l u or v l v holds if j j v and ej u v then u v u v are all different a multiply nested word mn w is an word for some n n init e final e figure a nested word graph figure illustrates a nested word intuitively are meant to capture the behaviors of runs of where the stacks are compiled down to edges in the graph the relation l relates consecutive actions in the run while the nesting edge relation ej captures the matching relation of stack j for every stack index j n the edges init and final capture the initial and final vertex with respect to l the properties of multiply nested words definition can be easily stated in mso proposition for any integer n the class of is mso definable we can define a to function nw from the set of behaviors of the m to the class of given an m run with aa am the corresponding nested word graph n is as follows the set of vertices of n is v v v vm vm the relation l is such that vj holds iff j i the edge relation ej is defined as follows on the word there are relations that match corresponding pushes and of the same stack and since we assumed that all the stacks at the end of a run are empty we have that in every symbol is matched with a future symbol and thus the edge relation ej is defined as vh holds if and only if ai ah and the pair i h is a matching pair of push and pop actions in it is easy to see that this is a to correspondence given any m we can easily translate it to a graph automaton that accepts the corresponding to the behaviors of m intuitively whenever the pushes onto the ith stack the graph automaton the corresponding node in the nested word graph with the symbol pushed and when this symbol gets later the graph automaton using tiling conditions on the nested edge will recover the symbol hence by using on the nested edges the graph automaton can work without a stack and capture the semantics of the precisely we hence have lemma for every m there is a graph automaton ga on words such that hence iff note that are basic pushdown automata whose emptiness problem is decidable the emptiness problem for is wellknown to be undecidable when n thus lemma can be used to show that the class of with n have unbounded treewidth lemma the class of has treewidth for any integer n the class of has unbounded treewidth of multiply nested words in order to show restricted versions of have a decidable emptiness problem we will first define canonical for multiply nested words which we will use to prove bounds on treewidth and figure tree decomposition of the graph illustrated in figure hence prove emptiness for both automata as well as ordered automata it turns out that bounded automata have a simpler tree decomposition definition canonical tree of for any n v init final l the canonical of n t bag is decomposition t v bag defined as · the set of nodes of the tree t are the vertices v of the n · if v holds for any j n then v is the of u in t · if lu v holds and for all j n and z v v does not hold then v is the of u the function bag associates the minimum set of vertices to each node of t that satisfies the following · v for all v v · if u is the parent of v in t then u for every u v v · for u v v if lu v holds then u for all vertices z such that z is on the unique path from u to v in t figure illustrates a for the nested graph in figure in the above definition of the of an n the vertices of t are the same as the vertices of n the root of t is the minimum vertex in n according to the linear ordering induced by l the of any node if any is always its otherwise a vertex v is the of its linear predecessor notice that since for each node v there exists at most one pair u j such that v holds and at most one vertex u such that lu v holds the tree t is uniquely determined by n note that the tree t captures all the nesting edges in in fact if v holds then v must be the of u and hence u v the successor relation l is not always local as the relation is for example if lu v and v hold for some j and z then v is the of z and not the of u however the third property in the definition that all linear edges are captured by at least one bag and also the requirement that nodes whose contain the same vertex in a tree decomposition be connected hence it is clear that defines a unique tree decomposition for every though its width may not be bounded lemma for any multiply nested word graph n is a of n bounded emptiness we show now that the words that correspond to bounded runs of a automaton are of bounded treewidth and hence admit a decidable emptiness problem for any k n we say that a behavior word w bn is a word if it belongs to in other words w can be as at most k ww wh with h k such that each wi includes only actions of a single stack and internal actions let us define to be the set of all behavior words in the emptiness problem for restricted to k contexts is the problem of checking given an m whether the language is empty as in the general case the emptiness problem for restricted to k contexts can be reduced to the emptiness problem for graph automata where now the class of graphs to consider is that of restricted to behaviors for any k n n a word is a tuple n v init final l ej jn where n is a and is a behavior word the restriction on multiply nested word graphs is easily expressible as an mso formula this formula will express that the graph can be into k segments and only nesting edges of one stack are on vertices of a single segment along with the mso formula defining the class of defines the class of all moreover a where each stack is encoded as a subtree under the root in the usual way as in the canonical tree decomposition of nested words has width at most k see appendix a lemma for any k n n the class of graphs is mso definable furthermore for any there exists a of width at most k from the fact that the emptiness problem for restricted to is effectively reducible to the emptiness problem for graph automata over and using lemma we can instantiate theorem to show the following theorem for any k n the emptiness problem for restricted to k contexts is decidable and decidable in time om ok for a fixed k the emptiness problem is in the original proof of decidability of reachability of automata under a bounded number of was proved using tuples of automata to store the configurations of stacks the above proof is very different it shows that the graph that captures the storage ie multiple stacks with bounded has bounded treewidth and hence admits a decidable emptiness problem bounded phase emptiness now we show that the words that correspond to bounded phase runs of a automaton are of bounded treewidth in fact the canonical gives bounded treewidth and hence entails decidable emptiness a word w bn is a phase if it belongs to one of the sets int for some j n a phase j describes any sequence of actions in which only internal actions pushes to all stacks and from stack j are permitted a word w bn is a behavior word if it is the concatenation of at most k phases that is w k we define the set for a m as the set of all the words in the emptiness problem for restricted to k phase behaviors whether is an empty set restricted to bounded phases can be simulated by graph automata on a the class of bounded phase for any k n n a word n is an where is a behavior word lemma for any k n n the class of graphs is mso definable moreover the where n is any has treewidth at most k k from lemma and theorem to obtain the following theorem which also matches the lower bound for this problem theorem for any k n the emptiness problem for restricted to k phases is decidable and decidable in time m ok when the number of phases is fixed the emptiness problem is in proofs can be found in appendix b emptiness of ordered automata to the restriction on automata we show that the words that correspond to ordered runs are of bounded treewidth using the canonical and hence admits a decidable emptiness problem a run of an is ordered if whenever a pop action happens on the stack j n then all stacks of index less than j are empty if c act c cm then for every i m if and ci q s sn then sh for each h j the set for a m is the set of all the ordered words of the emptiness problem for restricted to ordered behaviors is the problem of checking the emptiness of for any n n an ordered word n is an in which is a ordered word lemma let n n the class of ordered graphs is mso definable furthermore the where n is any ordered has width at most from lemma and theorem we obtain the following theorem which also matches the lower bound for this problem theorem the emptiness problem for restricted to ordered runs is decidable and decidable in time m when the number of stacks is fixed the problem is decidable in proofs can be found in appendix b distributed automata with queues and stacks distributed queue automata with stacks is an automaton model composed of a finite number of processes and a finite number of fifo channels using which they communicate and where the local processes are with a single local stack each each fifo queue has a unique sender process that can onto it and a unique receiver process that from it definition distributed queue with stacks a distributed queue automaton with stacks is a tuple m p q sender receiver where p is a finite set of process names q is a finite set of queues is a finite message alphabet is a finite stack alphabet and sender q p and receiver q p are two maps that assign a unique sender process and receiver process for each queue respectively for ev process where sp is sp is the set p p a finite of final ap set of states where · set of send moves where · sp × × × sp is the set of receive moves where q q p · push sp × sp × is the set of push moves · pop sp × × sp is the set of pop moves · sp × sp is the set of internal moves for the rest of the section we fix m p q sender receiver to be a where ap sp sp fp p for every p p the semantics of is as follows a configuration of a m is a tuple ppp where for each p p sp sp and p are the state and the stack content of process p respectively and for each queue q q q is the content of q the configuration c ppp of m is the initial configuration if sp sp and p for each p p and q for each queue q q c is a final configuration if sp fp for every process p p and further all queues are empty ie q for each q q and all stacks are also empty ie p for each p p let the actions of process p be bp and b pp bp be the alphabet of all actions for any two configurations c ppp q qq and c ppp c act c if act b and one of the following holds send act and there is a move sp q m sp such that · for each p p sp sp · q mq and for each q q q q · for each p p p receive act and there is a move sp q m sp such that · for each p p sp sp · q qm and for each q q q q · for each p p p push act and there is a move sp sp a such that · for each p p sp sp · for each q q q · p ap and for each p p p p pop act and there is a move sp a sp such that · for each p p sp sp · for each q q q · ap p and for each p p p p internal act and there is a move sp sp such that p a b c d e f g h i j k l mn p p figure a graph · for each p p sp sp · for each q q q · for each p p p let w b a run of m on w is a sequence c act c cm where c is initial and cm is final the set of behaviors of m is the set of words w b such that there is a run of m on w a graph captures the behaviors of as a graph this graph captures the distributed behavior by modeling local behaviors of the process as disjoint linearly ordered sets of vertices with two additional kinds of edges edges that capture the nesting relation matching pushes and of the local processes like in a nested word and edges that match of one process with in others formally definition graphs a graph over p q sender receiver where p q are finite sets sender q p and receiver q p is a tuple vp i f lp ep pp where · vp i f lp ep is a nw for every p p · vp vp for all p p p with p p · eq vp × vp for some p p p with p p further for all u x vp and v y vp if u v eq and x y eq and u lp x holds then v lp y · any vertex v pp vp has at most one edge of pp ep on it figure illustrates a graph for three processes the properties defining graphs the definition above can be easily expressed in mso lemma for any tuple p q sender receiver the class of graphs over it is mso definable the class of graphs represent all potential behaviors of any the precise queue graphs corresponding to behaviors of a can be accepted by a graph automaton over queue graphs that each of these graphs with the states and checks whether there is a run of the corresponding to the graph let us associate a function that associates as a correspondence the graph corresponding to any behavior w then lemma for any m over p q sender receiver there is an effectively graph automaton on graphs over p q sender receiver such that graphs are complex graphs and several restrictions are required to make them tractable in fact they are of unbounded tree width lemma for any p q sender receiver where p and q the class of graphs over p q sender receiver has an unbounded treewidth the architecture of a m is the directed graph that describes the way its processes communicate queues p q q in it is proved that if the underlying architecture is a directed tree where each process hence has only one incoming queue and if the processes are then the emptiness problem is decidable for the assumption demands that each process may from an incoming queue only when its local stack is empty the graph in figure corresponds to such a behavior these properties and tree architectures can be expressed in mso furthermore we can prove that these restrictions cause the graphs to be of bounded treewidth this proof is quite involved and is given in the technical report the idea is to first define the notions of graph and their that extends the notion of if h is a class of graphs then a of a graph g is a graph h h where each node in h has an associated bag of vertices where every edge in g is in the union of two adjacent in h and where the nodes that contain a vertex of g are connected in h we then show that graphs over an architecture that is a directed tree can be decomposed with a small width onto a nested word this process relies on the observation that the global run can be always be executed in a particular order where messages in queues never go beyond length then by using the small treewidth of nested words we obtain the following result lemma the set of all graphs over a pair p q sender receiver whose underlying architecture is a directed tree and are is and furthermore have treewidth bounded by n where n is the number of processes from lemma we have theorem the emptiness problem for a m with is decidable the problem is decidable in time m on where n is the number of processes of m in fact the precise analysis of the treewidth that leads to the above theorem improves the complexity by one exponential over the one proved in which gives an algorithm exponential in n distributed queue automata without stacks distributed queue automata without stacks are the same model as that of except that the local stacks at each process are not present even in this restricted setting the emptiness problem is undecidable we can capture behaviors using queue graphs that are composed of n linear orders one for each process with edges connecting matching sends and receives figure illustrates a queue graph in general queue graphs of distributed queue automata without stacks are also of unbounded tree width formally we define queue graph as a stack queue graph with an empty set of stack edges definition queue graphs a queue graph over p q sender receiver is a tuple vp i p f i p f i p f figure a queue graph where vp is a stack queue graph where every ep for each p p the properties defining queue graphs can be easily expressed in mso lemma for any p q sender receiver the class of queue graphs over it is mso definable also let be a function that associates to every behavior of a distributed queue automaton the corresponding queue graph lemma for every m there is a graph automaton ga on queue graphs such that in it was proved that when the architecture of a is a the emptiness problem is decidable an architecture of a m is a if the underlying graph is acyclic to bound the treewidth of queue graphs of architectures we note that we can reverse any edge of the graph without changing its treewidth hence we can direct edges in a way to make the underlying architecture a directed forest note that since there are no stacks the assumption is satisfied see this resulting graph hence can be interpreted on a linear word using the same proof as for except that now the nesting relation is not needed hence we obtain the following lemma let p q sender receiver be a tuple where p and q are finite sets and sender q p and receiver q p then the class of queue graphs over p q sender receiver has treewidth even bounded by p furthermore from lemma lemma and theorem we can conclude theorem the emptiness problem for is decidable and decidable in time m on where n is the number of processes of m conclusions and further results the main contribution of this paper is to provide a uniform framework using which we can prove decidability of emptiness of a variety of automata with auxiliary storage in this sense our framework is the of several automata decidability results proved recently in the literature where complex but restrictions have been imposed to obtain decidability of emptiness we also believe that our results can help in the search of new automaton models that have a tractable emptiness problem using the principles outlined by our framework there are several other results that follow immediately from our work that we discuss below underapproximation of abstracted programs using treewidth the analysis of abstracted concurrent programs communicating through is in general undecidable these programs can be modeled as pushdown automata in the last few years syntactic restrictions on the behaviors of those automata have been considered with the aim of making the analysis of such programs decidable eg bounded etc since all the known syntactic restrictions correspond to graphs of bounded treewidth we can consider the treewidth as a natural semantic restriction to consider for given a automaton and k n the problem of deciding whether there is a multiply nested word of treewidth k that is accepted by it is decidable as shown in our framework and hence can be used as an underapproximation technique to explore the reached by a concurrent program note that this would cover all behaviors that explore k and more and yet has the same complexity improvement in complexity for as mentioned earlier theorem improves the complexity of the emptiness problem for a m with to one exponential in the number of processes the algorithm given in is exponential this upper bound complexity matches the for the emptiness problem on decidable emptiness problem for pushdown automata with bounded our framework shows immediately the decidability of other restrictions placed on automata with auxiliary storage for example fix k n and consider automata behaviors restricted to k where in each there is only one stack that is pushed into but arbitrary of stacks are allowed then it easily follows that emptiness is decidable for this class since the graphs corresponding to the runs of these automata are precisely the same as those of automata save for the of the linear and nesting edges and hence has the same treewidth a general parikh theorem we can prove a general parikh theorem for all classes of automata that can be compiled to graph automata of bounded treewidth the idea is to encode the graph into a tree using the with a unique vertex of the tree for every graph node since a depthfirst traversal of the tree can be captured by a pushdown automata we can build a contextfree grammar that generates the graph nodes in some order using the classic parikh theorem for contextfree grammars we can show that the labels of the graph nodes define a set this is a generalization of the technique using in where a similar argument was used for proving a parikh theorem for automata extension to infinite behaviors several of our results extend to automata over infinite behaviors for example consider ordered bu¨chi or parity automata on infinite words we can show that there are graph automata on infinite graphs with appropriate bu¨chi and parity conditions that can simulate these automata and further that these graphs have bounded treewidth this proves that the emptiness problem for this class of automata is decidable see for recent results in this direction similar results can be obtained by extending the tractable distributed automata presented in this paper to infinite words there are interesting temporal logics suitable for expressing properties of pushdown systems like the logic natural extensions of temporal logics like that allow to reason with pushdown automata are also possible and can be proved decidable for all automata whose runs can be modeled by graphs of bounded treewidth acknowledgments this work was partially supported by the nsf grant and the project references r and p pushdown languages in l editor pages ­ acm r and p adding nesting structure to words in o h and z editors developments in language theory volume of lecture notes in computer science pages ­ springer r and p adding nesting structure to words j acm r k and p a temporal logic of nested calls and returns in k and a podelski editors tacas volume of lecture notes in computer science pages ­ springer m f global model checking of ordered systems in k and m editors proceedings of the th conference on international proceedings in dec to appear m f b and p emptiness of automata is in m and m editors developments in language theory volume of lecture notes in computer science pages ­ springer t ball r majumdar t d and s k rajamani automatic predicate abstraction of c programs in pldi pages ­ l a c and s languages and grammars int j found comput sci ­ b the expression of graph properties and graph transformations in monadic secondorder logic in g editor of graph grammars pages ­ world scientific b and s upper bounds to the width of graphs discrete applied mathematics ­ b j a and u linear time solvable optimization problems on graphs of bounded theory comput syst ­ j and m parameterized complexity theory in theoretical computer science an series springerverlag new york inc nj usa a j a and g reachability analysis of communicating pushdown systems in ch l editor volume of lecture notes in computer science pages ­ springer j e hopcroft and j d ullman introduction to automata theory languages and computation addisonwesley s la p and g a robust class of contextsensitive languages in lics pages ­ ieee computer society s la p and g an infinite automaton characterization of double exponential time in m and s editors csl volume of lecture notes in computer science pages ­ springer s la p and g analysis of concurrent queue systems in c r and j editors tacas volume of lecture notes in computer science pages ­ springer s la p and g analyzing recursive programs using a fixedpoint calculus in m and a editors pldi pages ­ acm s la p and g modelchecking parameterized concurrent programs using linear interfaces in t b cook and p editors cav volume of lecture notes in computer science pages ­ springer p and g the tree width of automata with auxiliary storage in ideals technical report april r parikh on contextfree languages j acm ­ s qadeer and j model checking of concurrent software in n and l d editors tacas volume of lecture notes in computer science pages ­ springer d the structure of models of decidable monadic theories of graphs ann pure logic ­ w thomas on logics and automata in j l b and m editors icalp volume of lecture notes in computer science pages ­ springer appendix a treewidth of multiply nested words in this section we show that any multiply nested word graph has a treewidth by k lemma a for any k n the treewidth of any n is at most k the proof is simple and we sketch the main idea let us create a by creating a tree where the root has k subtrees each subtree corresponding to a stack for each stack s we take the contexts that involve the stack s remove the rest of the events and build the tree and the as in the canonical of a nested word of width at most these trees along with the root and the associated with the nodes capture all nesting edges and all linear edges except the linear edges that cross contexts which are at most k in number now for every pair of nodes u and v where v is the linear successor of u and where u and v are in different contexts let us add u to all nodes in the path from u to v clearly the increase by at most k and the resulting captures all edges and is of width at most k b on the treewidth of and ordered multiply nested words in this section we give an of the treewidth of both and ordered multiply nested word graphs for a given k and n the treewidth of any is ok instead the treewidth of any ordered is on · n we show such bounds by giving a general technique to the width of the canonical tree decomposition for any which is section b or ordered section b proof strategy our proof strategy is the following first notice that in any multiply nested word the canonical tree decomposition we defined has all edges except the ie edges u v where v is a for some stack other linear edges as well as all nesting edges are local in the tree decomposition we define first a notion of an extension of a multiply nested word which is the same as the multiply nested word except that every edge u v where v is a is replaced by a path of nodes which intuitively u to v by taking a backward path along the linear order all the way up to the v corresponding to v and then goes on to v the crucial property of this expansion is that all edges between u and v become local in the tree this backward path is constructed so that it nesting edges of the same kind as the stack v is from in order to reach v this extension of a multiply nested word will be used in both the proofs of bounded phase words as well as ordered words we show that this extension preserves the bounded phase property as well as the property the extension of a multiply nested word n then helps us build a new over the same tree as we need in the theorems ie using a different set of but over the same tree t deriving from we show that this certainly has width at least as the width of and hence establishing that the width of this tree decomposition is bounded by the appropriate bounds for multiply nested words and ordered multiply nested words is sufficient to prove our theorems we then define a notion of generator trees corresponding to every node of a multiply nested structure n intuitively the generator tree of a node v consists of the copies of the node v in the extension of n and a copy v h of v is the child of a copy v h if v h was created as a of v h in a backward path that replaced a the generator tree is a technical structure that has certain structural properties lemma b and lemma b that allows us to count the of the of both bounded phase words and ordered multiply nested words proof outline throughout the section every time we refer to n we mean the n v init final l moreover whenever we refer to the ordering among n nodes we always intend the linear ordering l we also consider an ordering on l edges if e a b and e c d with e e l then e e if b l c furthermore t is the tree obtained as t bag if u v ej with j n we say that u is a node v is a node and that u and v are matched moreover an l edge u v is called a edge if v is a node for any n we define an n v init f l called the extension of n as follows intuitively n is obtained from n by replacing all the pop edges with a sequence of nodes more precisely consider a edge u v and suppose that all the pop edges before u v have already been replaced with paths to create a nested word n then the pop edge u v is replaced with the of n starting from u and ending with the push node u that matches v the is built in the following manner suppose we have reached a node b now if b is a node notice that v is also a node then the next node in the is a where a is the node matched to b a b ej in this way we get closer to u which must occur before a and hence all nodes between b and a otherwise the next node in the path will be the l predecessor of b in other words the from u to u is formed by taking linear predecessors at each state except taking nesting edges for the stack j obviously all the nodes in will be renamed so that they will be unique in n now we formally define the extension of a multiply nested word n we do this by defining a function expand that takes the first in a nested word and replaces it by a we will first start with the nested word n with renamed vertices then we will apply expand to it repeatedly all are replaced and we reach a fixedpoint this fixedpoint will be the extension of n first let us define formally and extensions let n v init final l ej jn be a and let u v be a ie v is a and u is the linear predecessor of v let v v ej j n then v is the unique node sequence v vt such that · v u and vt v and · for every i t if vi is a node then vi is the corresponding ie the node such that vi vi ej otherwise vi is the linear predecessor of v ie the node such that vi vi l we now define the extension of a multiple nested word using a systematic replacement of every u v by a linearly ordered sequence of nodes formed by a from u to the v corresponding to v moreover in the linearly ordered sequence that replaces the no node will have nesting edges on it we will perform this on all going from the leftmost one to the rightmost this is important as for a may the extensions of that occur to the left of it let us fix a n v init final l ej jn the extension of n will have vertices of the form v i where v v and i n let n be the same as nested word n except that each vertex v v gets renamed to v in other words n v × init final l where the various edges in n are appropriately defined we now construct ni from ni using the following algorithm let ni vi li where vi v × n let u v be the first of its kind ie with indices in ni according to the linear ordering li if no such exists then we set ni ni and reach a fixedpoint then ni vi li is defined as follows note that the initial final and nesting edges do not change let the from u be u z h zt ht note that any node occurs at most once in the let us now this path so that the nodes zj get renamed to some zj so that they are not in vi and do not get repeated in the · · w x m w x m where m is the least positive integer such that x m vi and does not occur in let u z h zt ht then vi vi zi hi i t and the set li is li li u v zi hi zi hi i t u z h zt ht v intuitively we remove the linear edge from u to v and replace it with the backward path from u appropriately renamed we apply the above algorithm to systematically replace by a linearly ordered set of nodes left to right we reach a fixedpoint where there are no of the form u v the final multiply nested word will be the extension of n notice that n is the same as n except that pop edges of n are replaced by nodes that are neither the target nor the source of any nesting edges therefore if n is a then also n is and if n is an ordered then so is n lemma b let n be the extension of an n then n is iff n is n is ordered iff n is ordered it is easy to prove that if a i b j is an edge in n that is a i b j l hn eh then a and b are connected by an edge in t which means that either a is the parent of b or by using n we define a new tree decomposition of n whose underlying tree is t we define a map bag v v as follows map bag associates the minimum set of vertices to each node of t according to the following rules v bag v for all v v if u is the parent of v in t then u bag v for every v v if u v is a pop edge of n and u u h ut ht then u bag ui for every i t notice that the first and second condition defining the map bag see definition and the first and second condition in the definition of bag are the same they only differ in the third one if u is such that u v ej then condition three of definition says that u is added to for all nodes z along the unique shortest path in t between u and u similarly the third condition of the definition above adds u to the bag of all the t nodes along a path in t from u to u which may not be the shortest however that path has to pass all the nodes of the shortest path between u and u thus t bag is a tree decomposition of n and more importantly for us bag z for every node z of t therefore we can the size of by considering the size of bag u for every u v as stated in the next lemma lemma b let n be an word and t t bag then t t bag is a tree of n where furthermore for every v v bag v dv where dv v h v h n generator trees a convenient way to calculate dv in the above lemma is to represent the set of n nodes v h v h n as a tree for each v v let v h with h be a node of n and let u be the greatest push node of n that occurs before v h intuitively v h is one of the node of the path between that have replaced the pop edge u v of n by definition of n v h is generated because there is another node v h with h h in u we call v h the generator of v h note that for every node v h with h there is a unique generator of it though the does not hold definition b generator trees let n be the extension of an word n and let v be the set of nodes of n for every v v we define a tree tv as follows · v is the root of tv · if v h is the generator of v h then v h is a child of v h for every v v the tree tv is called the generator tree of v observe that for a given n node v all the nodes v h in n are also nodes of tv thus the value dv corresponds to the number of nodes of tv we can also associate a stack to every node of generator tree except the root if a node v is the first pop node after v h where h and if v is a pop node of stack j then we say that j is the stack of v h intuitively the stack associated with v h is the stack whose led to a that created v h in the following we give some properties of generator trees that will be instantiate later for the case in which n is and ordered intuitively fix a stack j then any node in a multiply nested word can be only once on a backward path that is caused by a pop of stack j except that when the node is a push onto stack j in which case it may be twice this is true because the backward path caused by a pop to stack j takes nesting edges of stack j as much as possible hence the nodes between the nesting edges it takes the first lemma states that if v is a push onto stack j the root of the generator tree of v namely v has at most n children at most two of these children may be of stack j and all the other children must be of distinct stacks lemma b if v v is a node then the root v of tv has at most two children of stack j moreover for every j j v has at most one child of stack j proof by contradiction suppose that v has at least three children of stack j since a goes always backward it contains distinct nodes therefore there must exist three edges in n say e u v e u v e u v such that v is contained in ui for all i suppose that e e and e in the order are the first three pop edges of n having the above property it is easy to see that v is the matching pop of v now u to reaches v must pass through v a always goes backward and since the ej relation is nested a can never jump in between v and v thus when u reaches v it goes directly to v this entails that the matching push of v occurs before v now u must pass through v to reach v but v is a node and thus the jumps directly to the matching push of v which comes before v since a goes always backward v can never be reached by u this is a contradiction in similar way we prove that if j j then v has at most one child of stack j by contradiction let e u v and e u v be the first two edges of n such that u and u contain v if u passes through v means that the node matched by the v must occur before v now u must pass through v and hence jumps directly to the matched node matched with v since such a node comes before v and never go forward we have that v cannot be reached by u the second property we need is that for any node v any node in the generator tree of v has children whose stacks are distinct from each other moreover if v is not a push then the root also has children whose stacks are all distinct from each other lemma b let z h n then if h or z is not a push node of n then for every j n the node z h has at most one child of stack j in tz proof if h then z h must be a node of a path that has replaced a pop edge say u v of n suppose that e u v and e u v are the first two edges in the order of n such that u and u contain z h thus z h l u l v l u since u passes through z h implies that the node matched by the v occurs before z h now u has to pass through v which is a node and hence jumps directly to the node matched to v such a node appears before z h and since only go backward we have that v is never reached by u which contradicts the hypotheses the other case in which z is not a push node is similar to the case above and we do not give it here b treewidth of multiply nested word graphs in this section we show that the treewidth of any n is ok from lemma b the extension n of n is also a thus we define to be the map that associates to every node v h of n its phase number the next lemma which is a refinement of lemma b says that for any v the phase numbers of the children of the root of the generator tree of v are not less than that of the root and further all phase numbers of the children of the root are distinct from each other save for one child this bounds the number of children of the root to k j if the root has phase j lemma b for every push node v v the phase of the children of the root v of tv is greater or equal to the phase of v moreover except for one child of v all the other children have different phase number proof if v h is a child of v then v l v h and hence v v h now if the stack number of v h is different from the stack number of v then v v h moreover if v h and v h are two children of v with different stack number then v h v h thus from lemma b we can conclude the proof by using a similar argument of the previous proof and lemma b we can show the following lemma which says that for any v the children of a node v h in the generator tree for v have distinct phases and have phases greater than the phase of v h moreover this is also true for the root v provided v is not a lemma b let v h n then if h or v is not a push node of n then for every child v h of v h in tv v h v h moreover for every phase number p v h there is at most one child v h of v h such that v h p by using the previous lemma we can the number of nodes of the subtree of tv rooted in any internal node of tv for every node v of n let f k n defined as f i k ji f j for every i k and f k by a simple calculation it is easy to prove that f i ki thus we can the number of nodes of any subtree of tv rooted in an internal node v h with f v h now by instantiating lemma b we have that b treewidth of ordered multiply nested word graph in this section we show that the treewidth of any ordered words n is on · n as in the previous section we prove such a result by the number of nodes of each tree tv for every node v of n in the following we instantiate lemma b for ordered multiply nested words we show that for any internal node v h of the generator tree of a node v the stacks of the children of v are strictly greater than that of v the reason why the stack of a child of v h cannot be lower than that of v is because of the of the stack accesses if the of a pop of stack j leads through a pop of stack j then we must have that j j the reason why it cannot j j is also argued below hence the depth of the tree gets bounded by the number of stacks n and each node has at most n children lemma b if v h n is a stack j node with h then the stack j for any child of the node v h is such that j j and the stacks for the children of the node v h are all distinct proof case follows from lemma b case is proved by contradiction and we distinguish two cases one when j j and the other one for j j let v h be a child of v h and suppose that v h is a stack j node since h h v h and v h are both on a two different paths that replace two different pop edges of n say e u v and e u v thus we have that v h l v l u l v h the fact that u has to visit v h to reach the matching node of v means that it occurs before the v now if j j it means that there is node that comes after a node that has not matched yet since j j this contradicts the property of n and hence n instead if j j then u will never visit v h because between v h and u there is a node whose matching pop occurs before v h for every i n let us define the map f n n as f i k ji f j if i n and f n notice that f i ni from lemma b it is easy see that f i upper bounds the number of nodes of any tv subtree rooted in one of its internal node which is a stack i node thus from lemma b we can conclude that the following the number of nodes of any tree tv n f n · n now from lemma b we can conclude with the main theorem of the section theorem b the treewidth of any ordered is at most n · n k dv f f i k k i and by lemma b follows that the width of the tree decomposition of n is at most k k theorem b the treewidth of any is at most k k 