van calcagno college london and meyer abstract is an algorithm that constructs a sound refinement calculus from a verification system under certain conditions in this paper a verification system is any formal system for establishing whether an inductively defined term typically a program satisfies a specification examples of verification systems include hoare logics and type systems first extends the term language to include specification terms and builds a verification system for the extended language that is a sound and conservative extension of the original system the extended system is then transformed into a sound refinement calculus the resulting refinement calculus can closely with the verification system Г it is even possible to reuse and translate proofs between them gives a semantics to refinement at an abstract level it associates each term of the extended language with a set of terms from the original language and refinement simply reduces this set the paper applies to a simple type system for the lambda calculus and also to a hoare logic categories and subject descriptors d software engineering verification d programming languages formal definitions and theory f logics and meanings of programs specifying and verifying and reasoning about programs general terms languages theory verification keywords formal systems proof theory refinement introduction many theories in computer science are presented or approximated by compositional verification systems in this paper a verification system is any formal system for establishing whether an inductively defined term typically a program satisfies a specification for example hoare logics and type systems can be viewed as verification systems in the case of hoare logics the system proves that a statement satisfies certain specifications given as preconditions and postconditions in the case of type systems the system proves that a term has a certain type in a type context refinement systems play a similar role to verification systems the main difference being that they relate terms to other terms instead of terms and specifications another difference is that they permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january Г pa usa copyright c acm typically include socalled specification terms intuitively a term refines another if it is better ie if it satisfies more specifications refinement calculi are formal systems for establishing refinements for example the calculus of morgan derives refinements between statements based on total correctness specifications starting from an appropriate specification statement one can derive a correct algorithm for computing the factorial of a number by applying refinement rules this paper from the observation that a hoare logic and a refinement calculus for a command language do not have to be independent entities once the hoare logic is extended with specification statements the two systems can be in a single theory moreover there is a strong relation between the two systems the paper explains that this relation is not a it is possible to analyze the structure of the inference rules defining a verification system and automatically generate a related refinement calculus is an algorithm that implements this transformation surprisingly is not limited to hoare logics but can be applied to any verification system whose inference rules satisfy certain conditions several refinement rules proposed in the literature in different contexts arise in this way the algorithm works as follows given a term language and an verification system v that satisfies certain conditions extends the term language with specification terms and builds a verification system v for extended terms the conditions on v ensure that it is possible to extend the terms without the inference rules v is consequently a sound and conservative extension of v moreover proposes a sound refinement system r that is in with v means that the two formal systems can it entails for example that a term satisfies a specification according to v if and only if it is possible to refine the specification into the term with r in fact proof translation between v and r becomes possible because is demonstrated internally constructs the refinement calculus by v in a series of steps the conditions on v ensure that successful linearization is possible according to the presentation below at most six steps are needed for this refinement of refinement systems the situation is summarized as follows sound conservative extension v r иии r v requires no human the conditions it imposes are by many program logics and type systems examples include hoare logic separation logic the simplytyped lambda calculus and system f defines the semantics of refinement at an abstract level it associates each term of the extended language with a set of terms from the original language and refinement simply reduces this set with tools that are based on verification systems can readily include refinement as a complementary or alternative development style provides correctness by construction for free outline section describes the algorithm which is applied in section to a simple type system for the lambda calculus and also to hoare logic section concludes with related work the inputs requires four things as input a set of constructors k the constructors give rise to a term language t where an arbitrary term t of t is defined by the grammar t ct tn where c k a set of specifications s a binary relation v sat between terms and specifications intuitively v t sat s denotes that term t t satisfies specification s s a formal system vk s v sat which consists of a set of inference rules for proving of the form t sat s each rule of v must have the form a or b a t sat s tn sat sn ct tn sat s provided s sn s b t sat s t sat s t sat sm provided sm s the ts ss and c in the rule forms indicate where the rules of v must use metavariables thus a rule of form a has only the freedom to choose a concrete n and a definition for its predicate pred the predicate implements the side condition of the rule based on the arguments c s sn and s a rule of form b is also a pair a concrete m and a definition of a predicate with arguments s sm and s requires that the rules must be sound with respect to the following semantics definition semantics of the inference rules for rules of the form a s sn s t tn t и v t sat s v tn sat sn v ct tn sat s for rules of the form b sm s t t и v t sat s v t sat sm v t sat s the rule forms that the rules of v must be highly compositional Г a requirement that will exploit for example rules cannot or constrain the ts that appear in premises this will allow to reuse the rules after specification terms are added to the term language consider the following three rules over k succ pred and s n where n is a metavariable nn n n n nn n provided rule can be written in form a with n by defining the s s as c succ s s n rule is because its premise the term and requires it to match rule is also because it the term in its it will become clear later that the structural rules of hoare logic such as the rule of consequence are examples of rules of form b other rules of hoare logic such as the assignment axiom and rule for sequential composition have the form a let v t sat s denote that t sat s is derivable with v the soundness of the rules with respect to the semantics of definition implies the soundness of v theorem soundness of v v t sat s v t sat s proof by induction on the derivation of t sat s и a rule of the form a was last applied assume s sn s and the induction hypothesis v t sat s v tn sat sn then v ct tn sat s by definition и a rule of the form b was last applied assume sm s and also the induction hypothesis v t sat s v t sat sm from definition follows v t sat s does not assume the completeness of v ie it never assumes v t sat s v t sat s the extended language and formal system this section extends the language t with specification terms that are useful for refinement it gives a semantics to the resulting language u and extends v in a sound and conservative way to prove of the form u sat s where u u the extended language u suppose k and s are disjoint if they are not then they can always be to become disjoint and do not contain a symbol the extended set of constructors k k s with arity n n n gives rise to an extended language u which can also be written as u cu un s u un a term of the form s is called a spec term and a term of the form u un is called the join of u un intuitively s is a generic term that satisfies s and u un is a generic term that satisfies any s that any of the u un satisfy although the details will become clear later the reasons for adding these terms are simple the refinement system should be able to refine spec terms into other terms for topdown development and join terms will be important for simplifying rules of the form b where m if there are no rules of the form b where m then join terms and their treatment can be omitted a of constructs are used for giving a semantics to u let x denote a subset of t and let y denote a subset of s is the set of all specifications that all the terms in x satisfy and is the set of terms of t that satisfy all the specifications in y definition and terms и def s t v t sat s и def t s v t sat s an galois connection exists between and terms lemma x y proof x definition of terms and t x и s y и v t sat s predicate calculus s y и t x и v t sat s definition of and y galois connections have several wellknown properties for instance terms and terms are extensive increasing and idempotent and therefore closure operators relies on the following properties their proofs appear in the appendix corollary x y the following auxiliary definition provides a shorthand for the set of all terms of the form ct tn where t x tn xn cx xn def ct tn in ti xi for example it yields a singleton set for constructors c i ti xi c true c the semantics of u is given by the function of type u pt ie every term in u denotes a set of terms from t definition semantics of u cu un def un s def u un def in ui if the relation v sat is wellbehaved in a sense that will be made precise later then u has a simple intuitive explanation it denotes the set of all primitive terms ie terms from t that refine u for a term cu un first consider cu un Г the set of terms of the form ct tn where t u ie t refines u and and tn un all the specifications that all these terms implement are then collected and any primitive term that satisfies all such specifications refines cu un the primitive terms that refine s are exactly those that satisfy s finally u un is refined by any primitive term that refines all u un for all u the set u is a fixpoint of terms and hence a closed element lemma u proof by induction on the structure of u и if u has the form cu un or s then u for some y and the result follows by corollary и if u has the form u un assume ui for all i n so u un in terms in by corollary and corollary concludes the proof also known as an or contravariant galois connection the rest of the paper introduces further properties of the semantics as needed extending v the next section will extend v to obtain a formal system v for proving of the form u sat s the aim is to construct a sound and conservative extension of v informally a sound extension of v must have equal or more power definition sound extension vk s v sat is a sound extension of vk s v sat if and only if v uses richer terms and specifications k k and s s v can prove everything that v can prove t t s s и v t sat s v t sat s v uses a richer semantics t t s s и v t sat s v t sat s v is sound u u s s и v u sat s v u sat s as a consequence t t s s и v t sat s v t sat s which intuitively means that v restricted to k and s is sound with respect to the semantics of v in a sound and conservative extension the converse of requirement also holds definition sound and conservative extension a formal system vk s v sat is a sound and conservative extension of vk s v sat if and only if v is a sound extension of v v and v restricted to k and s have equal t t s s и v t sat s v t sat s although a sound and conservative extension cannot prove more of the form t sat s it is still useful for extending the term language and a richer semantics it can also extend the specifications but the v of the next section will simply use s the extended formal system v the construction of v starts with the empty set of rules and proceeds in two steps for each rule of v replace ts by us and add the resulting rule this change of metavariables yields the rule forms a and b in v a u sat s un sat sn cu un sat s provided s sn s b u sat s u sat sm u sat s provided sm s add the following rules for spec terms and joins spec s sat s u sat s join u sat s by induction on the derivation v and v are equivalent with respect to on t ie v t sat s v t sat s so for v to be a sound and conservative extension of v it will suffice to v with a richer semantics and to prove it sound the sat relation between u and s is defined as follows definition extended satisfaction v u sat s def t u и v t sat s furthermore the of t contains t as an element lemma term embedding t t и t t proof by induction on the structure of t suppose t ct tn and assume t t tn tn so t ct tn which is a subset of tn by corollary therefore v t sat s v t sat s holds and the soundness proof of v establishes that v is a sound and conservative extension of v theorem soundness of v v u sat s v u sat s proof by induction on the structure of the derivation и for each rule of the form a assume s sn s and assume t u и v t sat s tn un и v tn sat sn so t u tn un и v ct tn sat s because the corresponding rule of the form a in v is sound with respect to definition so s un and hence t un и v t sat s и for each rule of the form b assume sm s and assume t u и v t sat s v t sat sm now t u и v t sat s because the corresponding rule of the form b in v is sound with respect to definition и spec t и v t sat s by definition и join assume t u и v t sat s if t u then t u and hence v t sat s extended satisfaction has an alternative characterization that will also use lemma v u sat s s proof v u sat s definition t u и v t sat s definition of s system v and refinement the next section will construct several refinement systems or calculi that are based on v these refinement systems are formal systems for proving of the form u u the definition of the refinement relation makes the semantics of refinement precise definition refinement u u def u u this definition leads to simple proofs and is equivalent to several other the following theorem states one such alternative and its proof others lemma equivalent characterization of refinement u u s и v u sat s v u sat s proof u u lemma corollary definition of s и s s lemma s и v u sat s v u sat s if v sat is wellbehaved then there is also another explanation for defining u u as u u u refines u iff every primitive term that refines u also refines u put differently u refines u iff u the set of eventual primitive terms that refinement can produce to the same or higher degree compared to u so u can be seen as a for any of the primitive terms in u and the role of refinement is to reduce the uncertainty many examples of refinements will follow later so here is a small one a join term implements the least upper bound join of its immediate subterms with respect to hence the name in particular i n и ui u un if i n и ui u then u un u the notation u u is a shorthand for u u which is equivalent to u u u u a refinement system r will be sound if and only if r u u implies u u in the next section will construct several sound refinement systems where each system r is related to v by the properties and below if v u sat s and r u u then v u sat s intuitively says that v contains sufficient machinery to prove the same properties about u that it could prove about u in other words r is not too powerful for v if v u sat s then r s u intuitively means that the refinement system r contains sufficient machinery to refine a specification into any term that satisfies it according to v in other words v is embedded in r and hence r is not too weak is stronger than the converse of theorem if v and a refinement system r are related by then r s u v u sat s proof assume r s u since v s sat s by spec it follows from that v u sat s a refinement system r is called iff it satisfies and refinement systems with v in fact the proofs of and in the next section are constructive in the sense that they enable proof translation given a of u sat s and an of u u they describe a of u sat s based on a of u sat s they show how to build an for s u since is established given an of s u the proof of theorem shows how to build a for u sat s the final refinement system that produces will also have a specific desired form this form guarantees that refinement proofs are linear developments where terms can be refined formally a refinement system has the desired form if the rules with premises describe either the transitivity or the monotonicity of refinement all the other rules must be axioms ie without any premise the refinement of refinement systems v can be in a series of steps to obtain a sound and refinement system of the desired form at most six steps are necessary according to this presentation Г the exact number depends on v the steps make it easy to prove and maintain soundness and which would otherwise be more complex to establish for the final refinement calculus many of the steps take a previously constructed refinement system and add or remove rules to obtain a new system if a sound and refinement system is extended with a rule that is sound and respects then the resulting system will be sound and there is no need to prove again because the new refinement system can still derive all that the old one could derive if a rule is removed from a sound and refinement system then the resulting system remains sound and will also be if it satisfies a simple way of showing that still holds is to show that any application of the old rule can be achieved by a combination of rules that remain in the system getting started r the first refinement system r is obtained from v by a simple syntactic transformation each sentence u sat s becomes s u r has rules of the form a and b a spec rule and also a join rule if join terms were needed a s u s sn cu un provided s sn s un b s u su sm provided sm s u spec ss join s su u v and r are isomorphic a proof of u sat s in v corresponds to a proof of s u in r and vice versa so v u sat s r s u the soundness proof of r relies on the following equivalence lemma v u sat s s u proof v u sat s lemma s lemma u theorem soundness of r r u u u u proof if r u u then u has the form s and v u sat s the soundness of v implies v u sat s and lemma in turn implies s u theorem r is proof holds by construction for assume r u u then u has the form s and v u sat s by tion that v u sat s ie v s sat s implies v u sat s for all s follows by induction on the derivation of s sat s и spec s and s are the same since v u sat s it holds that v u sat s и for each rule of the form b s and s are the same assume sm s v u sat s v u sat sm and by the induction hypothesis also v u sat s v u sat sm so the rule being considered is applicable and v u sat s hence v u sat s note if v has only rules of the form a where n andor rules of the form b where m then r is a refinement system of the desired form and stops adding transitivity r the refinement system r extends r with the rule trans which states that refinement is transitive trans u u u u u u trans is sound because is transitive and it maintains since implication is transitive so r is sound and simplification r the presence of spec and trans in r allows the simplification of rules of the form b with m b s s u u provided s for an arbitrary rule of this form consider the derivation spec b s s s s provided s by of having been derived the new rule b s s provided s is sound and maintains and can therefore be added to r to obtain a sound and refinement system in fact it can replace the old version without since removing the old version will not decrease the derivable set of every application of the old b can be changed into b s trans s s s u u since s is guaranteed the refinement system r is the same as r except that the rules of the form b with m are replaced by their simplified versions r is sound and note if v has only rules of the form a where n and rules of the form b where m then r is a refinement system of the desired form and stops adding monotonicity r all the constructors of u are monotone with respect to ie the following rules are sound ci ui ui cu ui un cu ui un ui ui u ui un u ui un moreover these rules maintain lemma ci maintains proof assume s и v ui sat s v ui sat s that s и v cu ui un sat s v cu ui un sat s follows by induction on the derivation of cu ui un sat s и a suppose v uj sat sj for j n and also suppose s sn s holds since v ui sat si the same rule a can be applied to derive cu ui un sat s и b suppose v cu ui un sat sj for j m and suppose sm s the induction hypothesis is the assumption v cu ui un sat sj for j m since sm s the same rule b is applicable and hence v cu ui un sat s lemma maintains proof assume s и v ui sat s v ui sat s that s и v u ui un sat s v u ui un sat s follows by induction on the derivation of u ui un sat s и join suppose uj sat s was the premise for some j n if j i then apply join to the premise uj sat s to derive the required u ui un sat s if j i then by assumption v ui sat s holds and the result follows by join и b suppose v u ui un sat sj for j m and suppose sm s the induction hypothesis is the assumption v u ui un sat sj for j m since sm s the same rule b is applicable and hence v u ui un sat s let the notation vu denote a term in u whose parse tree is into two parts a core tree v with a hole where the subtree for u the rule packages ci and in a single convenient form uu vu vu informally the rule allows refinement if u can be as vu and u refines u then vu refines u is sound and maintains because ci and are sound and maintain the refinement system r extends r with it is sound and simplification r the rule makes it possible to simplify и the join rule join s su u и rules of the form a with n a s u s sn cu un provided s sn s un consider the derivation spec s s join s s by of having been derived the simplified rule join s s is sound and respects it can replace the old version of join without decreasing because any application of the old version can be achieved by join s trans s s s s u u u likewise for each rule of the form a the derived rule a s cs sn provided s sn s is sound and respects it makes the old version redundant since any application of the old rule can be replaced by a s cs sn e en where ei is given by s cu ui si sn trans pi s cu ui si sn and pi is the proof tree si cu ui si sn ui cu ui si sn apart from these simplifications the refinement system r is the same as r it is sound and note if v does not include rules of the form b where m then r has the desired form and stops up r it remains to simplify rules of the form b with m b s u su sm provided sm s u if sm s then r can derive join s b s sm s join и и и sm s sm s sm the derived rule b s s sm provided sm s is therefore sound and respects together with the rule u u u which is trivially sound and respects it can replace the old b because any application of the old rule can be rewritten as b s s sm f trans fm su g where g is fi is given by i s trans u u si sm qi s u u si sm and qi is the proof tree si u u si sm u u u si sm i r is the same as r except that it includes and replaces rules of the form b where m with their simplified versions r is sound and of the desired form discussion r can be made more powerful in several ways for example the following generalization of join is sound and preserves join u u the same holds for the of refinement which generalizes spec and other rules such as u un u ui u ui un provided i n and ui u in specific applications of it might also be useful to add derived rules to r examples of this will follow later assumes as little as possible about v sat and is consequently very generic as one might expect additional as can help to construct more powerful refinement systems for example suppose plus is a constructor that is commutative in the sense that t t t s s и v t sat s v t sat s then u u because s u t u t u и v t sat s t u t u и v t sat s s u so u u and therefore the refinement rule u u is sound depending on the rules of v it might also preserve as mentioned before the semantic function and the refinement order have nice interpretations when v sat is wellbehaved here is the definition definition v sat is wellbehaved iff c k t tn t s s и v ct tn sat s t и v t sat s there is also an alternative characterization of lemma v sat is wellbehaved iff c k t tn t и tn proof ti for i n by corollary so ct tn hence by corollary in the appendix tn therefore v sat is wellbehaved c k t tn t s s и v ct tn sat s t и v t sat s c k t tn t s s и s tn s c k t tn t и tn by the reasoning above c k t tn t и tn the result then follows by corollary does not require of v sat but the next theorem shows that the behind the definitions are simple when v sat is wellbehaved for example theorem says that u is the set of all primitive terms that refine u theorem if v sat is wellbehaved then t t и t t t s s и v t sat s v t sat s t t u u и t u u t proof by induction on the structure of t suppose t ct tn and assume ti for i n then t tn induction hypothesis lemma tn v t sat s definition of s corollary in the appendix s theorem s lemma v t sat s the proof is trivial since t t for assume t u then by in the appendix and t u by theorem and lemma whether v sat is wellbehaved depends on the expressivity of specifications for example suppose k x e e is an arithmetic expression ie there is a constructor x e for all arithmetic expres sions e and a binary constructor for sequential composition sup pose s even x and v t sat even x holds iff if t is executed in any state where x is even then x is even in every resulting state so v x x x x sat even x but it is not the case that v x x sat even x in fact x x does not satisfy any specification this implies that x t so x x x x but v x x sat even x does not hold hence v sat is not wellbehaved even though v sat is not wellbehaved it is still possible to have inference rules that are amenable to for example x e sat even x t sat even x t sat even x provided e t t sat even x if s is instead a set of specifications of the form p q where p is a precondition and q a postcondition and v t t sat p q v t sat p r v t sat r q then it is easy to show that this v sat is wellbehaved the completeness of v is a sufficient condition for the well of v sat theorem if v is complete then v sat is wellbehaved proof if v is complete then v ct tn sat s v ct tn sat s the of v sat fol by induction on the derivation of ct tn sat s и for each rule of the form a assume s sn s and si for all i n so ti v ti sat si for all i n the rule is sound with respect to definition hence t t sat s и for each rule of the form b assume sm s and t t sat si for all i m the rule is sound wrt definition so t t sat s applications lambda calculus the top left corner of figure contains a type system for the lambda calculus by considering pairs of the form typing context type as specifications it is possible to apply and obtain a refinement calculus for extended lambda terms in the spirit of the inputs to are as follows k var x x var note that k defines the language t of lambda terms e x x e e e here and in the following x ranges over the set of variables var and e ranges over t s context type where context is the set of typing contexts and type is the set of types that contains the type constructor the intended representation of a typing context is a list of variable names with types variables may appear more than once in and variable lookup uses the rightmost occurrence in the following and range over type and ranges over context v sat is defined by и v x sat x и v x e sat и v e sat x и v e e sat и v e sat v e sat v shown in the top right corner of figure is obtained from by replacing e with e sat the rules var abs and app are all of the form a with n and respectively for example in the case of abs s s is defined as x и c x s x s since v does not contain rules of the form b where m does not add join terms to the lambda calculus the system in figure is v where f sat is written instead as f the system r shown in the bottom right of figure is the final refinement calculus that produces here is an example topdown typing derivation with r abs x x with abs x y x y with app x y x y x y twice with var x y x y x var x x e abs x e e e app e e x var x x f abs x f f f app f f spec v var x sat provided x e sat x abs x e sat e sat e sat app e e sat r var x provided x abs x x app spec trans f f f f f ff gf gf f figure and a typed lambda calculus since r is and v is a sound and conservative extension of v it holds that x y x y one might wish to extend r using knowledge particular to lambda calculus typing it is simple to show that v is complete so e v e sat v e sat furthermore by theorems and v e sat v e sat and because v is a sound and conservative extension of v v e sat v e sat consider the property of preservation definition a relation t О t satisfies preservation def e e и if e and e e then e theorem if satisfies preservation then if e e then e e if v e sat and e e then v e sat proof the proof of is trivial for e e и e e e e predicate logic e e и e e и e e e e и e e s s и v e sat s v e sat s lemma e e и e e e e so any relation that satisfies preservation contains only sound refinements that satisfy and can augment r to yield a sound and refinement system examples of relations that satisfy preservation include и the conversion relation и the reduction relation и the contraction relation so x e x e provided x does not appear free in e и the relation on closed terms where e e exactly when e has fewer types than e here is a small example that uses the contraction extension x y z x y z with contraction x y x y with contraction x x hoare logic the top left corner of figure contains system h a hoare logic for simple imperative programs p is a precondition q a postcondition and c a command in the hoare triple and is the usual partial correctness interpretation of by interpreting a specification as a prepost pair the rules of h do not fit the rule forms a and b since the of the command c to determine the variables that it writes and reads however if specifications also keep track of written and read variables then it becomes possible to apply to obtain a refinement calculus in the spirit of morgan here are the inputs there are constructors for assignments sequential composition conditionals and loops k x e x var e if b then else b while b do b a specification consists of two sets of variables and two assertions written in a notation specification statement s x y p q x y p q assertion in the specification x y p q the x and y are upper bounds on the sets of variables written and read by the command respectively the p is a precondition and the q a postcondition v c sat x y p q def x y v shown in the top right corner of figure has the following relationship with h v c sat x y p q x y note that и the rules of h have counterparts in v that the definitions of writes and reads for example the conclusion of cond reflects that b then c else c def and b then c else c def и the structural rules of h that c for its write andor read sets have counterparts in v that the specification instead see for example the of и consequence in v allows the of write and read sets this of the bounds is useful in refinement developments because then the resulting code is not forced to write and read all the variables that were originally available for writing and reading the of the structural rules of h are all of the form b for example m in the case of and m for the other rules are of the form a for example n in the case of cond and n for loop the systems v and r that produces appear at the bottom of figure r yields several derived rules that may be useful in practical refinement developments for example the rule x y p q z e provided z x and fve y and p can replace and is similar to the assignment law of morgan law on p of likewise the derived rule x y p q x y p z e provided z x and fve y is similar to the following assignment law of morgan law on p of here is an example showing that r can derive a correct factorial algorithm starting with its specification yz xyz true y x yz true y z yz xyz y z y x the first spec statement is refined as follows yz true y z y true y z y y z twice with consequence y y z y y z twice with y z and for the second spec statement yz xyz y z y x consequence yz xyz y z y z loop while zx do yz yz y z zx y z with while zx do z z y z zx z y yz z y z h v и и q provided v p cq consequence provided p p and q q p r provided p cq p p cq q ep qc r pc c r p p q cond b then c else c q i loop b do ci гb v s sat x y p q s sat x y v и p v и q provided v x y s sat x y p q consequence s sat x y p q provided x x and y y and p p and q q s sat x y p q s sat x y p r q r provided x s sat x y p q s sat x y p q s sat x y p p q q x e sat x fve p s sat x y p q s sat x y q r s s sat x x x x p r s sat x y p b q s sat x y p гb q cond if b then s else s sat x x y y p q s sat x y i b i loop while b do s sat x y i i гb spec x y p q sat x y p q s sat x y p q join s sat x y p q v c sat x y p q c sat x y v и p v и q provided v x y c sat x y p q consequence c sat x y p q provided x x and y y and p p and q q c sat x y p q c sat x y p r q r provided x c sat x y p q c sat x y p q c sat x y p p q q x e sat x fve p c sat x y p q c sat x y q r c c sat x x x x p r c sat x y p b q c sat x y p гb q cond if b then c else c sat x x y y p q c sat x y i b i loop while b do c sat x y i i гb r x y v и p v и q x y p q provided v x y consequence x y p q x y p q provided x x and y y and p p and q q x y p r q r x y p q provided x x y p p q q x y p q x y p q x fve p x e x x x x p r x y p q x y q r cond x x y y p q if b then x y p b q else x y p гb q loop x y i i гb while b do x y i b i spec x y p q x y p q join x y p q x y p q s s s trans s s ss ts ts s s s s figure and hoare logic with while zx do z z y z zx z y with consequence while zx do z z z z y with while zx do z z y since r yz xyz true y x y z while zx do z z y it is the case that v y z while zx do z z y sat yz xyz true y x and hence also z while zx do z z y x here is another example of using r it involves join statements the statement x y p q x y p q is the join of the specification statements x y p q and x y p q expressing it as a spec statement is simple because x y p q x y p q x y p q also p q where the definition of p q also p q taken from is p z p z q z q z where z is fresh r can derive both directions of refinement x y p q x y p q twice with consequence x y pz pz z qz qz z x y pz pz z qz qz z twice with x y pz pz z qz qz z x y pz pz z qz qz z twice with x y pz pz qz qz x y pz pz qz qz x y p q also p q secondly x y p z p z q z q z x y p z q z x y p z q z twice with x y p q x y p q leino and mention several uses of the join of statements discussion the type system considered above is very simple also applies to system f and other more sophisticated type systems although had only rules of the form a typing rules of the form b are quite common Г examples include rules for subtyping and intersection types sub e e provided inter e e e there is no for proof systems to make them amenable to however specifications andor terms might help the hoare logic example used specifications to keep track of write and read sets consider again the two problematic rules from before n n nn n provided rule can be by choosing s О n intuitively the specification s n tracks the fact that the outer most constructor is succ the rule then becomes n s n p n rule can be by choosing s n О n then the sentence n i n tracks the fact that term n denotes the natural number i the adapted rule is of the form a with n n i n i n provided i in some cases it might be useful to the term language for example consider the rule of concurrent separation logic that removes auxiliary commands ghost assignments auxiliary provided a and a this rule is not of the form a or b because it contains a in the conclusion however if the is turned into an explicit constructor and specifications track then the rule is of the form b with m and can handle it to get an approximate idea of what will happen when is applied to a separation logic consider the frame and concurrency rules frame p r concurrency p q a concrete setting and system will typically make syntactic tions on the commands in the triples so the specification statement p q might contain more components but will yield refinement versions of the rules that look roughly as follows frame p r q r p q concurrency p p q q p q p q related work in his work on refinement for the lambda calculus treats types as specifications and introduces a specification construct for each type conceptually corresponds to where the context is left implicit for example consider the term x in the context the inside the term corresponds to x also considers richer specifications for lambda terms in his phd thesis this results in a more powerful refinement calculus in which specification constructs can contain logical assumptions the specification statement x p q of morgan is analogous to x var p q since there is no restriction on the variables that the statement may read however his specification statement is a total correctness specification and the refinement calculus establishes total correctness similar refinement calculi for total correctness were proposed by back morris and the contain many examples of how correct algorithms can be constructed from their specifications via refinement leino and consider the join of specification statements x p q and x p q and mention several of its uses adds explicit constructors for joins and relies on the ability to join arbitrary terms from u in order to establish there is a relationship between observational equivalence of terms and the function because v sat gives rise to a notion of from the specification point of view in particular two terms t and t are observationally equivalent in this sense iff t t where t t def it is trivial to check that is an equivalence relation if v sat is wellbehaved then t t t t ie t t t t by corollary in the appendix and theorem acknowledgments van was supported by research grant calcagno was partially by references rj back correctness preserving program refinements proof theory and applications mathematical centre rj back and j von wright refinement calculus a systematic introduction springerverlag in computer science s a semantics for concurrent separation logic theor comput sci Г april e simplytyped journal of computer science and technology Г e a theory of program refinement technical report university of edinburgh e c r a practical theory of programming springerverlag new york inc new york ny usa k r m leino and r joining specification statements theor comput sci Г c morgan the specification statement acm trans program lang syst Г july c morgan programming from specifications nd ed prentice hall international uk uk j m morris a theoretical basis for refinement and the programming calculus sci comput program Г december m j parkinson and g m separation logic abstraction and inheritance in popl pages Г new york ny usa acm a galois connections lemma established that an galois connection exists between the functions and terms x y theorems derived from this equivalence come in pairs because of the symmetry between and terms here are a few wellknown ones together with their proofs corollary x y x x y y x x y y x y proof in instantiate y with x assumption x in instantiate y with if x x then holds by the result follows from from and follows instantiating y with in yields holds by from and by proof by indirect equality for arbitrary y y x by x x set theory x x by y y set theory y 