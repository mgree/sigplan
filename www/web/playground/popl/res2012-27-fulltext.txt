syntactic control of interference for separation logic s university of john c reynolds university abstract separation logic has success in recent years in reasoning about programs that deal with heap storage its success to the fundamental principle that one should keep separate areas of the heap storage separate in program reasoning however the way separation logic deals with program variables continues to be based on traditional hoare logic without taking any benefit of the separation principle this has led to proof rules from lack of clarity as well as questions surrounding their soundness in this paper we extend the separation idea to the treatment of variables in separation logic especially concurrent separation logic using the system of syntactic control of interference proposed by reynolds in we extend the original system with permission algebras making it more powerful and able to deal with the issues of concurrent programs the result is a presentation of concurrent separation logic whose rules are and soundness obvious we also include a discussion of how the new rules impact the semantics and static analysis techniques to infer the required permissions automatically categories and subject descriptors d programming languages formal definitions and f theory of computation computation by abstract of computation ­ parallelism and concurrency f logics and meanings of programs specifying and verifying and reasoning about of programs f logics and meanings of programs semantics of programming languages denotational semantics general terms program logic concurrency denotational semantics type systems keywords separation logic syntactic control of interference conditional critical regions fractional permissions static analysis introduction in reasoning about programs that alter the state one often side conditions that have to do with how variable symbols are used for example the invariance rule of hoare logic permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm or the rule in specification logic written as p c q p r c q r has a side condition that states that c should not modify any variables occurring free in r this rule becomes the frame rule in separation logic but the same side condition is similar conditions also occur in the rules for procedures in fact such conditions are not only employed in the proof rules for procedures but it has also been argued that programming requires to them even if no efforts are made at formal reasoning a procedure call p a is regarded as only if the procedure p does not modify any of the variables occurring free in the argument a and likewise the argument a does not cause state changes via the variables occurring free in p this is more commonly called aliasing control consider callbyname or parameter passing methods or higherorder arguments to see the full effect of this observation these observations are also made with additional force in concurrent programming hoare and have argued that parallel processes should not interfere with each other a process should not modify variables that are concurrently used by other processes unless the variables are under the control of resources enforcing mutual exclusion program logic proof rules similarly employ these conditions in their proof rules that essentially the same side condition arises in all such contexts reynolds formulated it as a uniform principle of noninterference two program phrases p and p are considered if the variables used in one of them for do not occur free in the other phrase this work presents a system of rules called syntactic control of interference sci which bring structure to the conditions employed in programming as well as the formal rules of programming logics these rules incorporate at syntactic level what we now regard as the separation principle the same principle that is responsible for the success of separation logic in reasoning about heap storage the sci system has been studied quite extensively since this early work ohearn rules in the notation of type systems or proof theory and noted its overriding similarity to linear logic formulated a novel semantic model for programs in the sci framework exploiting the noninterference property of the programs in a crucial way which turns out to be the first fully abstract model ever discovered for a higherorder imperative programming language the games models of abramsky et al generalize model to deal with interference and represent fully abstract models as well generalizing the sci framework ohearn and formulated type systems and the logic of implications the latter of which forms the foundation for separation logic in it is fair to say that sci has proved to be a deep foundational principle of imperative programs leading to numerous developments in our understanding of their structure despite all the background sci has not been used in separation logic itself we believe that this has led to proof rules with side conditions the problems become critical in the formulation of concurrent separation logic attempt to formalize such rules turned out to be with known counterexamples to their soundness in this paper we the rules of sequential as well as concurrent separation logic using the principles of sci to bring structure to their side conditions it turns out that the traditional sci is not quite adequate to the task it a limited treatment of passive or readonly uses of variables which is unable to deal with the more advanced usage of variables in concurrent programs we the traditional sci with the idea of fractional permissions from and et al to a more powerful variant this system is then used to create a formulation of separation logic while fractional permissions for variables allow a presentation of the proof rules and their semantics they would be an to use in practice a programmer should not have to explicitly annotate all the variable uses in processes and shared resources with fractional annotations to address the issue we a permission inference system which can take a separation logic proof outline without any permissions specified with shared resources and them in if at all possible according to the rules of the logic the effect is similar to that of hindleymilner type inference in programming languages like ml related work hoare and have formulated conventions for controlling variable aliasing in concurrent programs hoare also proposed proof rules for reasoning with conditional critical regions and generalized conventions as well as the proof rules ohearn extended the system to deal with heap storage a concurrent separation logic which is currently a subject of active study we refer to this logic as the system the main issue of our concern is how the variable usage is controlled across parallel processes and the between such control and the proof rules of the programming logic the original logic formulated by and employed informal statements of the form variable not modified by any other process such a statement is ambiguous eg does it include modification inside critical regions it is also checking if a proof is correctly constructed involves examining the entire program for instance the verification tool implements such global analysis it is also problematic in defining semantics of the programming logic and verifying its soundness two previous attempts have been made to the variable usage rules of concurrent separation logic formulated a compositional set of rules in his effort to prove the soundness of the logic however the rules generalize the original rules in new ways and their soundness is not obvious in fact subsequently has found counterexamples to their soundness in one particular case the second attempt was that of et al where they treat variables as resources similar to heap locations whose access is controlled via programming logic proof rules their rules do address the issue mentioned above and the soundness of their rules is more immediate however the rules are to use in practice because the normal of variable symbols as mutable variable and logical variables is not for instance a formula such as x x is true if x is a logical variable but not necessarily so when x is a program variable although we at our formulation via a different using the ideas of syntactic control of interference to formalize the original system our system can also be seen as a syntactic variant of the logic described in the benefits of using the syntactic approach are · the normal conventions of variable usage in logics are so in reasoning from treatment of variable symbols can be avoided · we are able to a compositional or modular static analysis system to automatically infer permissions required for variable usage · the system should be extensible to higherorder languages with procedures and objects for instance the methods of objects can be as active or passive even though we do not discuss the higherorder aspects in this paper the traditional principles of syntactic control of interference for higherorder procedures apply these principles however do not generalize to procedures as in ml so further work is needed to address such issues in recent work has independently a revised set of proof rules for concurrent separation logic using ideas ours his rules do not employ fractional permissions as ours do and the relationship to sci is less clear cut we do not know at present the precise relationship between his formulation and ours but we that the two are very close inference of fractional permissions has been studied by and and both these pieces of work address the permissions needed for heap cells which is a harder problem than that for variables however they do not deal with concurrency which is our main concern et al use a analysis to make the heap permission problem tractable which may be seen as a reduction to the corresponding problem for variable names the techniques employed in their work rely on sophisticated methods in contrast our permission inference algorithm a algorithm on the syntax tree similar to regular compiler analysis methods with only constraint solving issues the rest of this paper is organized as follows in section we informally the issues addressed by our formulation of separation logic the logical system itself is described in sections and we also include a detailed comparison with the proof systems of ohearn parkinson et al a comparison with original system is include in appendix b in section we describe the denotational semantic framework of the proof system and indicate how the soundness is proved finally in section we describe an algorithm to automatically infer variable permissions needed in the proof system motivation as mentioned in the introduction hoare and the of interference between concurrent processes as a good practice of programming that requires that in forming a parallel composition of commands c c one must ensure that c does not modify any variable that occurs free in c and vice versa we use the terminology used for variables that are used for any variables that are used only for reading the state are said to be used we first consider how to treat active free variables of phrases using syntactic control of interference using the notations of if a command c is formed using a set of active free variables it is described using a judgement of the form c comm x a b x a b a b resource rx a b x a b in begin a b with r do with r do a x a b b x a b x x x x a b a x a b b x a b od od a b end x a b a b x table example proof outline in concurrent separation logic now the wellformedness of an parallel composition in the sense of hoare and can be described by the rule c comm c comm c c comm notice that the active free variables of c and c are combined requiring them to be separate or disjoint thus the noninterference conditions of hoare and can be described in a symmetric fashion without side conditions the judgements used above describe the wellformedness of commands rules of program logic can be stated in essentially the same way the separation logic proof rule for parallel composition becomes p c q p c q p p c c q q each judgement in this rule asserts the wellformedness of a hoare triple specification as well as the truth of the specification once again no side conditions are required to describe a sound inference while reynolds only considered independent parallel composition it is possible to add shared resources eg resources and conditional critical regions in the same way a resource declaration command resource r in c should split the available active variable context into two separate parts for the variables in the resource and the remainder of the context for the body c a critical region command with r when b do c od should add the context of the resource r to the current context for the scope c all this seems essentially straightforward however it turns out to be in practice to see the problem consider the example proof outline shown in table discussed by and even though we use separating conjunction in assertions has the same force as the ordinary conjunction here because the formulas involved are pure the purpose of the proof outline is to argue that running x x in parallel with itself increments x by the variable x is placed in a resource r allowing it to be safely shared across the parallel branches notice that placing it in the resource it from being mentioned in the parallel branches outside any critical regions so it is not possible to write assertions that show that each critical region increments x to solve the problem and adding auxiliary variables a and b and using them to record control mation about the increment actions performed in the two processes the auxiliary variables are also included in the shared resource so a and b can only be modified inside critical regions the resource invariant x a b captures the control information recorded by a and b however notice that a and b need to be mentioned in as outside the critical regions and their proof rules to allow such usage we are entering here the variable x cannot be used outside critical regions whereas the variables a and b are allowed to be used the difference is that x is modified in both the processes making assertions about it in one of the processes would not be sound because the other pro can the assertions on the other hand the variable a is only modified in the left process so assertions a remain true independent of the progress of the other process thus as well as proof systems use a critical re proof rule which allows the variables owned by a resource to appear in local assertions of a process as long as they are not modified in other processes note that the notion of a variable being modified in other pro is quite subtle one might expect that neither x nor a should be regarded as being modified in the other process because the other process does not have direct access to them any modification happens only inside critical regions so the modification actions cannot be attributed to the process rather they should be to the resource with the understanding that entering critical sec tions adds the access of the resource to the process the pu syntactic control of interference framework we to above would treat the variables in that way to handle these issues we generalize the active versus passive free variable distinction inherited from to total versus par tial ownership of the free variables it has become tional to call such ownership constraints permissions we con to use that terminology even though we regard it as ing a total permission for a variable allows writing to the variable in other words an active use and a partial permission allows only reading a passive use in the algebra of fractional permissions a total permission is denoted by and a partial permission by some nonzero fraction the use of permissions gives us more powerful control over variable usage because fractional permissions can be combined possibly leading to a total permission which then allows writing returning to our example in table we can define the the re source r to contain the permissions x a b the entire pro gram is specified in the context x a b the remaining sions a and b are distributed to the two processes a to the left process and b to the right process this allows the two processes to use a and b in their local assertions because such usage is passive when the left process enters its critical region its local permissions are combined with those owned by the resource leading to the set of permissions x a b this allows the critical region to mod x and a while only reading is permitted for b the right process is similar this provides a compositional description of the variable usage in the example the references to other processes in the following sections we formalize the system of syntactic control of interference with permissions and use it to formulate the rules of sequential as well as concurrent separation logic in variant of the system a and b need not be included among the owned variables of the resource thus logic is more general than the original concurrent separation logic sequential separation logic our form of syntactic control is a modified version of reynolds sci using the ideas of permissions for readonly access we assume a permission algebra p ie a partial commutative that is has a distinguished element denoting full permission and satisfies the following axioms nonzero p p p p p p top p p p is undefined p p p p p p p p a significant case of permission algebras is that of fractional permissions the real interval with being the partial operation of addition and the idea is that a full permission in the fractional permission algebra allows an active usage ie both reading and writing whereas a partial permission represented by fractional values in the fractional algebra allows a readonly or passive usage a variable context is an unordered list of the form xp where x xn are variable symbols and p pn are permissions subject to the following condition · if the same variable symbol x occurs in multiple times with permissions pi respectively then pi · · · is defined we call a variable context welldefined when it satisfies this condition if the variables x xn are pairwise distinct then we say that the variable context is in normal form a form variable context can be normalized by replacing the multiple copies of each variable by a single copy and associating with it the permission pi · · · as above we denote the normalized version of variable context by norm whenever two variable contexts are combined as in one needs to ensure that the combination is welldefined we say that and are compatible and denote this fact by we assume that all the variable contexts appearing in legal are welldefined ie any inference that leads to an variable context is illegal formally our system of rules is a natural deduction system where the variable contexts are used as assumptions of the even though we use the notation of sequents for presenting the deduction rules it is not a sequent calculus the syntactic wellformedness of program phrases is expressed using a variety of judgements x var e exp p assert c comm these say respectively that the displayed phrase is a wellformed variable expression assertion or command in the variable context all these forms of judgements have a structural rule xp xq s contraction s this allows two copies of a variable x to be combined into a single copy or to split a single copy into two while keeping account of the permissions it is more conventional to require that all the variable symbols listed in a context are distinct it would be possible to formulate variants of our rules using such a convention but we feel that our approach is more intuitive the following rules will be admissible rules in our proof systems if the premises are derivable then so is the conclusion s weakening s e exp x p assert p ex assert the substitution rules allow a variable with a full permission to be substituted by an expression to use a variable symbol x as a variable phrase in a program thereby allowing assignments to it one needs the full permission for the variable on the other hand to use a variable as an expression any permission will do x x var xp x exp more generally for all expressions and assertions the requirement is that all their free variables must have some permission in we omit the formal rules for brevity we can write down wellformedness rules for commands as well but we will save a bit of work by combining the wellformedness of commands with program logic which we look at next for completeness we include the wellformedness rules in appendix a a judgement of sequential separation logic is of the form p c q which means that p c and q are wellformed phrases in the context and the specification p c q holds assuming a variable context the variables that are modified in the command c would be required to have permission in other variables which might be employed in c in a readonly fashion or employed only in assertions can have non permissions the rules for commands are shown in table since we incorporate the wellformedness of assertions and commands in specifications most rules have premises to do with wellformedness of assertions commands or components of commands in the rule for assignment we depend on the admissible rule which allows us to substitute for a variable symbol with the permission the rule for heap cell lookup illustrates the use of side conditions for specifying logical conditions about the occurrence of free variables as opposed to the conditions that are purely to do with wellformedness issues contrast this with the rule for local variable declaration where we require that e p and q should be wellformed in the outer variable context so they cannot have x occurring free this seems to be a reasonable choice because most programmers understand the scope of x to be command c so its free occurrence in other places would be considered odd the frame rule of separation logic gives us the first application of the syntactic control of interference p c q r assert frame p r c q r note that there is an implicit side condition for the rule that says that is a wellformed variable context since the variable contexts of p c q and r are required to be separate it is not possible for c to modify any free variables of r if c modifies a variable x then needs to include x but then xp cannot occur in for any permission p because p is undefined thus the splitting of the variable context into and has exactly the p q assert p c q if p p and q q p c q p assert x var e exp p assert p skip p p ex x e p x var e exp e exp ´ if x fv e e p e x e e x e p e e e exp e exp e e e e e p b c q p ¬b c q p if b then c else c q p q assert x p c q p local x in c q table proof rules of sequential separation logic x var e exp p assert assign p ex x e p p b c q p ¬b c q cond p if b then c else c q p c q p c q par p p c c q q p q assert p r b c q r r r p with r when b do c od q r assert r r p c q resource r precise p r resource r in c q r p q assert x p c q auxiliary if x is auxiliary for c p c x q table proof rules of concurrent separation logic same force as the usual side condition c does not modify any free variables of r in the conventional formulation of separation logic as an example using the fractional permission algebra we can derive the inference using frame x y y x y x y z y z assert x y z y y z x y x y z concurrent separation logic in this section we formalize the rules of concurrent separation logic treating resources and conditional critical regions the contextfree syntax of the commands is c x e x e e e skip c c if b then c else c c c with r when b do c od resource r in c note that the resource declarations include permission contexts for the variables associated with them the notation that of and and ohearn who list only variable names with resource declarations in section we present an inference algorithm that allows the resource declarations to be written simply in the form resource r in c and finds the appropriate permission contexts to be used with them avoiding the annotation burden for the programmer the wellformedness of commands is defined using judgements of the form c comm here is a variable context and is a resource context of the form r where ri are resource names i are variable contexts owned by the resources subject to the following conditions · the resource names ri are distinct from each other · the variable context n is welldefined a syntactic context satisfying these conditions is said to be welldefined note that only commands require resource contexts which get used in checking the wellformedness of critical regions variables expressions and assertions only need variable contexts just as in the sequential case our rules of the programming logic incorporate the wellformedness of commands so no special attention needs to be to their wellformedness the programming logic is formulated using judgements of the form p c q here is a variable context and is an annotated resource context where each resource is annotated with a resource invariant formula ri which is a precise assertion and satisfies i ri assert this means that a resource invariant for a resource can only employ the variables available in its variable context all the rules of the sequential separation logic can be lifted to concurrent separation logic by simply adding to all the specification judgements for example see the rules for assignment and conditional commands in table the resource contexts do not play any rule in the sequential fragment of the programming language the proof rule for parallel composition is the rule par as one would expect the variable context of the composite command needs to be split into separate portions and for the two processes the resource context on the other hand is shared the rule allows c and c to share readonly variables via separate copies with partial permissions however it is not possible for one process to modify a variable employed in the other process or its proof a resources variables can be imported when a critical region is entered the rule the body of the critical region c can use the combined variable contexts of the process and the resource and respectively however the precondition and the postcondition can only employ the variables available in the context this captures the requirement that they should only employ variables not modified by other processes the rule for the resource declaration is resource the variable context is out of the current context and to the resource r the resource invariant is based on these variables the body of the resource declaration c can only use the remaining context outside any critical regions finally the rule auxiliary which is similar to the rule for local variable declaration in its form allows a set of variables x x xn to be deleted from a command c along with all assignments to them provided they are auxiliary ie each free occurrence in c of a variable from x is in an assignment whose left hand side also belongs to x the notation c x denotes the command obtained by deleting all the assignments to variables in x note that all the variables in x are assigned the permission in the second premise this guarantees that the variables do not occur in or the permission contexts in comparison with system version of concurrent separation logic is based on the system as its underlying framework for variable usage in this system the free variables of the resource invariant must be listed in the resource similar to our resource rule the rules the variables of a resources are as follows if a variable x belongs to a resource r it cannot appear in a parallel process except in a critical region for r if a variable x is changed in process si it cannot appear in sj i j unless it belongs to a resource the rule is relaxed in our proof rules recall that our resources not merely variables but variables with permissions so if x belongs to a resource with permission then the restrictions on its usage in our rules are exactly the same as in the system however if x belongs to the resource with a partial permission then one or more processes can possibly use x in a readonly fashion using the remaining partial permission the rule is represented exactly the same way in our proof rules the rule is somewhat while it requires that a variable x belonging to a resource cannot appear in the code of a parallel process except in a critical region it nevertheless permits it to appear in the assertions of the process outside critical regions resource rp in resource rp in begin with r do with r do p od od with r do with r do p od od end table problematic program due to berdine and reynolds thus the proof outline of table is legal in the system however there is a to this in the proof rule for critical regions a variable occurring free in the assertions surrounding a critical region should not be changed in another process the as well as its are already covered in our relaxation of the rule above we treat the free occurrences of variables in assertions as well as readonly occurrences in code in exactly the same way a variable that is not modified in another process is available to the current process with a partial permission so it can use it in a readonly fashion in both code and assertions our relaxation of the rule leads to a simpler formulation thus all valid proof of the system remain valid proof in our logic with syntactic control of interference it is quite straightforward to come up with an assignment of permissions to the variables listed in a resource · if a variable appears in multiple processes either in code or assertions and modified in at least one of them then the resource should contain the permission for the variable · if a variable has readonly occurrences in one or more processes then then resource may contain any permission p for the variable and the complement of p should be distributed to all processes that use it outside critical sections · if a variable is used in only one process but possibly in assertions outside critical regions then the resource may contain any permission p for the variable and the complement of p is given to the process for the example in table the variable x appears in multiple processes so it gets the permission in the resource the variable a respectively b is used only in the left process respectively the right process so the resource is given permission and the process is given the remaining however our version of the concurrent separation logic is more expressive by associating permission contexts with re sources we make it possible for the permission to be combined in nested critical regions for example consider the program ment shown in table due to berdine and reynolds the purpose of the two resources r and r is to achieve mutual sion to a shared data structure in this case just the location if the specification has a proof in concurrent separation logic the property of the logic that only one pro can potentially access the memory location at any given time a proof can be given in our version of the logic using the following resource invariants r p p emp r p emp p note that r r is equivalent to so both the precondition and the postcondition can be rewritten to r r what makes the proof work is the idea that the permissions for the variable p are split across the two resources so a process can modify it only by entering critical regions for both the resources this form of for variables is not available in the system in his effort to prove the soundness of concurrent separation logic defined a variant of the original system which is more general unfortunately the generalization proved to be unsound however all the valid proofs that can be carried out in system can be represented in our system a detailed comparison with system along with soundness issues appears in appendix b comparison with variables as resource systems parkinson et al and define a general scheme of treating variables as resources with permissions in contrast to our approach of syntactic control the variable resources are included in program assertions through ownership formulas of the form and used with all the normal logical connectives so this approach can be logical control of interference for variables it is easy to see that the syntactic control system can be translated to the logical control system for every variable context xp there is an ownership formula o x · · · xn a judgement p c q of our system can be translated to a judgement o p c o q in the variables as resource system in fact parkinson et al give translations of this form for hoare logics it is not possible to go in the reverse direction the variables as resource system uses logical formulas to express ownership of variables so it can express a much richer set of ownership constraints than possible in the syntactic control system for example the formula x own y x own z does not correspond to any syntactic variable context thus the variables as resource logic is more expressive than the syntactic control system however we argue that the syntactic control system offers considerable simplicity and convenience in particular · there are no issues of in expressions and formulas so one does not need to write formulas of the form e e just to ensure that e is defined in the current context · substitution is a valid operation in expressions and assertions · the system has no logical eg the equivalence e e e holds in our system whereas the two formulas have different interpretations in the variables as resource logic · we need no special treatment of logical variables the of program variables as logical variables characteristic of hoare logics continues to work in our system semantics and soundness the standard proof of soundness for sequential separation logic is due to yang and ohearn et al have extended it to deal with permissions the soundness proof of the original concurrent separation logic was provided by using novel denotational methods has also used these methods to prove the soundness of the variables as resource system since then other proofs of soundness have appeared see for an overview we regard semantics as the canonical one since it is based and allows easy extensions and in this section we discuss how the presentation of separation logic using the sci principles the semantics we regard the sci judgements for phrases and specifications as a form of type system and use the approach of church typing to define the semantics ie we regard wellformedness judgement c comm and c comm as a form of typing for c and interpret c using denotations that are appropriate for the specified context it is also possible to of a curry typing semantics where the commands are interpreted without regard to their contexts of wellformedness and the wellformed judgements are given a logical meaning as properties of the untyped denotations however we follow the church typing approach here because it seems more natural sequential separation logic a state is modelled as a pair s h of a store and a heap which are finite partial functions from respectively variables and addresses to keep track of permissions we define them to map their arguments to pairs of values and permissions store vars val × p heap addr val × p we refer to such maps as permissive store and permissive heap respectively and both kinds of maps as permissive maps two permissive maps and are said to be compatible denoted if for all arguments common to both of their domains they agree on values and provide compatible permissions more formally iff x v p x v p v v p p is defined if and are compatible their joining operation is denoted · which combines permissions whenever both and are defined it is extended to states by defining s h · s h s · s h · h given a variable context with norm xp a store s is said to be of type if dom s x xn and the permission component of is pi for every i it is easy to see that whenever any stores s of type and s of type are compatible and s · s is of type a state s h is said to be of type just if s is of type the heap component of the state is unconstrained if s h and s h are states of of type and respectively and h h then s h · s h is of type the meaning of a command in the sequential programming language is defined in as a local state transformer ie a binary relation c state × state fault satisfying safety monotonicity termination monotonicity and the frame property it was extended to permissive states in while it is not stated there it is also easy to see that c always preserves the domain and permission structure of the store this allows us to define a typed semantics for commands if c comm is a wellformedness judgement then its meaning is a relation c consisting of just the pairs where both and are of type definition a judgement of the sequential separation logic p c q is valid iff for all states of type satisfying p · fault c and · if c then is of type and satisfies q theorem soundness every derivable judgement of sequential separation logic is valid the proof is by induction on the derivation of the judgement consider the frame rule as a significant example let be a state of type satisfying p r then can be written as · where is of type and satisfies p and is of type and satisfies r then by inductive hypothesis p c q is valid hence c is safe for and whenever c is of type and satisfies q so by the safety monotonicity and frame properties c is safe for and c implies is of type and satisfies q r concurrent separation logic the denotational semantics of commands in the concurrent programming language is given in two stages first commands are interpreted as traces ie sequences of actions second these traces are described by their effect on states as state transitions it is not possible to interpret the commands directly as state transitions because such transitions only relate initial and final states whereas parallel composition makes intermediate states visible trace semantics a or an untyped action is a syntactic token given by the syntax x v x v l v l v rel r abort as in is a or idle action x v denotes the action of reading the variable x x v denotes the action of writing to the variable x the actions l v and l v denote similar actions for heap locations the tokens and rel r denote the actions of to acquire a resource a resource and a resource respectively the token abort denotes the action of a computation in case of an error a is a possibly infinite sequence of actions subject to the · · · and · abort · · abort we model the actions and action traces appropriate for a syntactic context as a form of typing first of all the contexts enable certain actions and others a variable action x v or x v would only be possible in a context that contains x with permissions the resource actions and would only be possible in a context that contains a resource named r secondly as a result of an action the context available for the rest of a trace might change for instance has the effect of removing the resource r from the resource context and adding its variables to the variable context a rel r action has the opposite effect we represent these effects by a transition relation on contexts finally when a resource is acquired by a process it is not available for another acquisition until it is released at the same time the type information of the resource should continue to be in the context therefore we work with a form of extended contexts where the resources acquired by a trace are marked by enclosing them in square brackets as r an extended context is a context of the form r r such that · the resource names r rn r rm are all distinct and · the variable context n is welldefined a extended context satisfying these conditions is said to be welldefined we use the letter e to range over extended resource contexts where some of the resources are marked the notation e denotes the underlying resource context of e where all the are erased an action is a triple e e consisting of the initial and final contexts and a that leads from the former to the latter we write it using the notation e e the list of actions used in the semantics of the programming language are shown in table there are no constraints on the actions for reading and writing heap locations because the access to heap e e e xv e where xp for some p e xv e where x norm e lv e e lv e e r e r e r e r e r e r table actions used in traces locations is controlled in the programming logic rather than the syntax a trace is a finite or infinite sequence of the form e e e · · · if the sequence · · · is finite we use the notation e to denote the corresponding trace if it is infinite we use the notation e we also use the notation e · for both finite and infinite traces and say that the is enabled in the context e for defining the meaning of parallel composition we define an operation of interleaving two traces suppose and are two traces with enabled in a context e and enabled in a context e then e and e should have the same underlying resource contexts ie e e and they should mark disjoint sets of resources as then the resource context obtained by marking the resources of both e and e is denoted e e interleaving is only possible for traces and such that e and e are in this form and e e is welldefined two actions and are said to interfere written if writes to a heap location l and reads or writes the same location l or vice versa the set of mutex of e · and e · is a set of traces of type e e · given by induction on the lengths of and abort e e e e · such that e e e e · such that this definition is a typed version of the notion of mutex in note that the typing information of traces the need to consider possible interference via variable usage the definition is extended to sets of traces in the natural way if t and t are trace sets enabled in contexts e and e then the trace set t t obtained as the union of all for all t and t is enabled in the context e e a trace for an extended context e is either abort a finite trace such that e e or an infinite trace whose every finite prefix can be extended to a finite trace the terminology is motivated by of the and rel r actions as brackets a trace set t is a x x v v v value e e v v v e v e skip x e x v v e x e v v x v v e e e v v v e v e if b then c else c b true c b false c local x in c x cx c c c c with r when b do c wait enter wait where wait b false rel r enter b true c rel r resource r in c r cr table trace semantics of phrases trace set for context e if each trace in t is a trace for the context lemma weakening of contexts if is a trace for an extended context e and e e is a longer welldefined extended context then is a trace for e e lemma parallel composition preserves contexts if and are traces for extended contexts e and e respectively and e is a welldefined extended context then is a trace set for the context e all expressions and commands can be given a compositional semantics in terms of trace sets · the meaning of an expression e exp is a set of pairs v where is an action trace of type ie a context with no resources because expressions do not access resources and v is a value obtained as the result of evaluating e we denote it by e · the meaning of a command c comm is a set of traces for the context we denote it by c the semantics is defined in the standard fashion however it is defined by induction on the derivations of wellformedness judgements e exp and c comm instead of induction on the structure of terms we show the meanings of sample phrases in table the notation e v denotes the set of traces v e the notations x and r remove the actions x and r respectively from theorem type soundness of trace semantics the meaning of command c comm is a trace set for the context likewise for every v in the meaning of an expression e exp is a trace for the context local state semantics a state for a concurrent program is a triple s h a where s is a permissive store h is a permissive heap and a is a set of resource names to have been acquired by the process we also use an error state abort the types for states will be annotated extended contexts of the form e where the resources are annotated with resource invariants as in r r it is a characteristic of semantics for concurrent separation logic that the resource invariants play a central role in the state transition semantics a state of type e is either abort or a normal state s h a where s is a store of type h is a heap and a is a subset of the resources marked in e we can interpret actions and action traces of type e e as state transformations that transform states of type e to states of type e for actions of type e e where the state type is unchanged the state transformations are as follows s h a s h a s h a abort abort s h a xv s h a iff p sx v p s h a xv sx v h a iff v sx v s h a lv s h a iff p hl v p s h a lv abort iff l domh s h a lv s hl v a iff v hl v s h a lv abort iff l domh s h a s h a for an action of type e r r e r r the transformations are given by s h a s · s h · h a r iff s h r s s h h for a rel action of type e r r e r r the transformations are s · s h · h a r s h a iff s h r s h a abort iff h h h r the key property of these transformations inherited from is that the transitions for extend the current state with an arbitrary state of the resource satisfying the resource invariant r the condition s s ensures that the values of any common variables agree the transitions for rel r do the opposite they remove the state of the resource from the current state if and when the resource is in a future action the state of the resource obtained may bear no relationship to the state previously released in fact since other processes can in the nothing more can be assumed about the state of the resource lemma type soundness of traces given a trace of type e e and a state s h a of type e if s h a s h a then s h a is of type e soundness definition validity a judgement p c q is valid iff for all traces for the context in c all local states s h and of type s h p s h s h s h q theorem soundness every provable judgement of concurrent sci separation logic is valid standard semantics in addition to the semantics defined above which is with respect to a program proof traces can be interpreted as actions on global states the relation is denoted s h a s h a and is similar to an untyped version of the local state transition semantics except that the rules for and rel actions are modified as follows s h a s h a r if r a s h a r s h a r if r a this relation corresponds to running a process on the global state without any interference from any other processes the following result says that the standard semantics obtained by executing traces on the global state corresponds to the local state semantics defined above the notation inv stands for the conjunction of all the resource invariants in theorem let s h be a global state and a context suppose the state s h can be split as s h · s h where s h is of type and s h inv · if s h abort then s h abort · if s h s h then either s h abort or s h can be split as s h such that s h is of some type s h s h and s h inv permission inference in this section we investigate the problem of permission inference we construct an algorithm which given a program and a proof outline with no variable contexts listed with resources them in if at all possible in with the rules of sci separation logic we restrict our attention to the permission algebra of fractional permissions the real interval with addition as the partial binary operation for theoretical simplicity we extend the algebra to include as an permission value indicating that the resource or the process no permission for the variable and extend addition to in the standard way an element of is referred to as an extended permission a normal form context with n variables and m resources is of the form p r rm where each is an extended permission with the index i corresponding to the owner of the permission for the process or self n for the shared resources and the index j corresponding to the variable we represent all the data in the context by two finite functions vars owners resources invariant where owners self resources and satisfies v o the sets vars and resources include all the variable and resource names appearing in the program fragment being analyzed using these notations the proof system of sci separation logic can be rewritten using judgements of the form e exp p assert passive x var p c q active where the first three forms have the resource context added for in discussion for example the parallel composition rule is rewritten as p c q p c q p p c c q q if v o v o v o for all o self v self v self v self we also use abbreviated rules for the passive judgements e exp if v fv e v self p assert if v fv p v self define a as a proof where the side conditions of passive judgements are ignored since the passive judgements involve variable reading this means that the permissions needed for variable reading are not checked however the permissions needed for variable writing are still checked hence the name define a as a judgement with variable contexts erased ie a judgement of one of the forms e exp p assert passive x var p c q active a is an sci separation logic rule with variable contexts erased a is an instance of a and a is a derivation made up of the erasure of a judgement rule inference or proof x is a or respectively denoted x obtained by all the variable contexts in that case we say that x to x or x extends x the problem of permission inference is now stated formally as follows given a p is there a proof p whose erasure is p the algorithm described below answers the question moreover if the answer is yes it produces a permissive proof p max that extends p we regard proof trees as formal trees ie graphs satisfying the tree conditions labelled by judgements p and p are different of the same formal tree we use the notation p n and p n respectively to refer to the judgements labeling a node n of the formal tree we use a few auxiliary concepts · a permission restriction is an assignment v o vk ok where vi vars and oi owners we also feel free to treat as a partial function of type vars such a resource r in resource r in begin with r do with r do p od od with r do with r do p od od end table problematic program due to berdine and reynolds represents the condition that for each of the variables vi the owners in oi share the full permission for vi a variable vi will occur in a permission restriction exactly when the program phrase being described contains an assignment to vi the corresponding oi lists all the owners that can contribute permissions required for that assignment to be legal formally the tion of a permission restriction by a variable context is defined as vi oi vi o note that vi o must be for all owners outside oi there are no constraints on for the other variables not mentioned in · we define a permission ordering on variable contexts by the rule v o v o we say that is more permissive than the intuition is that has nonzero permissions for at least as many combinations as a permission restriction v o vk ok is satisfiable only if every oi is nonempty in that case a permissive variable context satisfying can be defined as follows o if v o o o max v o o if v dom o where s denotes the size of the set s in other words a full permission is among all the owners permitted by or if imposes no restriction then a partial permission is among all owners our algorithm for permission inference is a algorithm the first phase traverses a leaves to root bottomup in the syntax tree and computes at each inference step the permission restriction that must be satisfied by any if any permission restriction computed in this phase is unsatisfiable then there is no proof corresponding to the the second phase traverses the from the root to leaves topdown in the syntax tree computing variable contexts that extend the to a permissive in the sense of the preorder the permissive is then checked to verify that it contains nonzero permissions for all the passive uses of variables we illustrate the algorithm using the problematic program of berdine and reynolds in table for ease of reference let stand for the resource context r r r r the first phase of the algorithm traverses the leaves to root and computes at each inference step the permission restrictions needed to extend the to a write proof since the inference steps correspond to program terms we just show the terms involved in each case for the variable p ie the inference step p var the permission restriction is p self the total permission must be owned by self at this point in order to allow assignments to p for the command p the permission restriction is the same p self for the critical section with r do p od the permission restriction is p self r this means that both the process and the resource r could have nonzero permission for p since the critical section combines the permissions from self and r to execute the body this is the command does not write to any variables so its permission restriction is empty for the outer critical section p with r do with r do p od od r is added to the restriction p self r r the second process p similarly has the permission restriction p self r r for the parallel composition p p the permission restriction is p r r ie self is removed from the permission restrictions obtained from the component processes why in this phase of the algorithm we are only considering what permissions are needed for writing variables since both the processes have permission restrictions for p that means that they are both writing to p which is only possible if each of them has as the self permission for p if the first process has nonzero permission for p then since the second process has the sum of all its permissions for p to the total sum of the permissions for p in the parallel composition would which is forbidden all the permissions for writing to p in both the processes must be obtained by entering critical regions for the resources resource r in p p has the permission context p r self which is obtained by replacing r in by self this is justified by noting that the resource declaration allows the process to shift some portion of the permission for p from self to r since potentially requires a nonzero permission for p in r must require it in self resource r in resource r in p p has the permission restriction p self using the same reasoning as in the previous step the key observation is the fact that permission restriction for p p does not contain self this requires us to divide the full permission for p among only the two resources r and r since all the permission restrictions computed in phase are satisfiable we proceed to phase of the algorithm this phase moves topdown from the root to the leaves using the permission restrictions computed in the previous phase for the overall program the permission restriction is p self the permissive variable context satisfying is given by p self the last inference step is of the form r assert r r r resource r in p p r resource r in r r resource r in a r r p p where the s need to satisfy various side conditions detailed in the formal rules given below note that the permission restriction for the first premise is empty because it is a passive judgement we calculate permissive variable con and using obtained in the previous step and the permission restrictions for the premises and calculated in the first phase recall that p r self this implies that p should be of the form r self s for some nonzero and s such that s the pre do not matter just that they should be nonzero for instance we can pick s should be of the form p self because the permission allocated to self in the resource invariant should be the permission allocated to r in moving topdown in the we need to construct the inference r assert r r r r emp p p emp r r r resource r in p p r where p r self s is the variable context from the previous step similarly to the previous step we can calculate that the variable context in the ment should be of the form r r self s such that and s s however the permission re only lists r and r for p hence s should be and s if s was chosen in the previous step then we obtain we omit the remaining steps which are straightforward note that the main task of the algorithm is now accomplished the sions for p in the two resources r and r have been inferred they are each the algorithm for permission inference takes as input a pre proof p regarded as a labeling function p n of a formal tree of nodes in phase it traverses the tree and constructs a permission restriction n for each node n if the for p n is of the form x n sn · · · nk n sn then the algorithm computes the permission restriction n for node n as a partial function nk of the permission restrictions of its children of the satisfy ing property l if each dom ni contains exactly the modified free variables of ie that occur on the left hand sides of assignments then dom n likewise contains exactly the modified free variables of sn property l for every inference x that extends x x n sn · · · k nk n sn we have i ni n where n nk if on the other hand there exists no inference x extending x then only for the variable declaration rule lemma given a p if n is a family of of permission restrictions for the nodes of p produced in phase then for every p w that extends p the variable context n of p wn satisfies n the proof is by induction on the structure of the underlying tree of p thus the result holds for all of p as well in phase we construct a permissive that extends p by calculating for every node n for the root node we choose a permissive satisfying root then phase for each node proceeds from the root using the max of the to leaves the parent constructing of the and the permission restrictions computed in phase specifically given a x x n sn · · · nk n sn and satisfying n it computes for the child nodes of n of the as a function nk of the given and the permission restrictions n nk of the child nodes satisfying nk and the follow x max n sn · · · n nk sn moreover for any other legal inference x that extends x x n sn · · · k nk n sn such that i i ii ni and n we have lemma given a p a family of permission restrictions n produced in phase and a variable context satisfying root let p max be the on the same underlying tree of nodes obtained by using the given and contexts satisfying the property l then p max is a legal extending p if p is any other extending p using variable con n and root then n for all nodes n the proof is by induction on the depth of the nodes in the underlying tree of p we describe all these aspects by writing down the rules of sci separation logic using the notations of this section and the computations of both the phases of the algorithm we the judgements with permission restrictions s in order to refer to the permission restrictions computed in phase and used in phase the side conditions of passive rules are ignored in phase but used in phase some of rules are as follows the others are similar expressions e exp where v fv e v self phase is trivial phase checks to verify that max satisfies the side condition if and only if the side condition is satisfied the that extends p with max for this node will be a proof the rule for assertions is similar variable j x var where x o if o self otherwise phase x self phase computation is trivial because there are no premises sequencing p c q q c r phase p c c r where dom dom dom v if v dom dom v vv v if v dom dom if v dom dom phase max m ax max all other rules such as conditionals assignment lookup and mutation are similar to sequencing in that remains unchanged in the premises their phase and phase computations are exactly the same as for sequencing parallel composition p c q p c q p p c c q q where v o v o v o for all o self v self v self v self phase dom dom dom v v vv v self if v dom dom if v dom dom if v dom dom phase the pair m ax v o max v o is as follows · if o self it is max v o max v o · if o self and v dom dom it is max v self · if o self and v dom dom it is max v self · if o self and v max v self dom dom it is max v self · if o self and v dom dom it is max v self max v self the frame rule is similar to parallel composition critical regions r r p q assert p r b c q r r r p with r when b do c od q where v o v o for all o self r v self v self v r v r phase dom dom v o v o self o r self self v r self v phase · for o self r max v o max v o · max v self max v self max v r · m ax max and max v r resource declaration r assert r r p c q p r resource r in c q r where r is precise v o v o for all o self r v self j v self v r v o v r if o self otherwise phase dom dom v o v o self o r self self v r v phase the context max is defined as follows · for o self r max v o is max v o · the pair m ax v self m ax v r is as follows if v dom then it is max v self max v self if v dom if self v and r max v self v it is max v self if self v and r v it is max v self if self v and r v it is max v self if self v and r v it is max v self is the same as max v r for all o self max v o is variable declaration p q assert p c q p local x in c q where v o j v o for all v x x o if o self otherwise v o v o for all v x x o phase if self x or x dom then the computation is dom dom x v v for all v x if x dom and self x then phase fails ie there is no extending p phase · max x o is when o is self otherwise for all other v max v o max v o · max max it may be verified that all the phase and phase computations listed above satisfy the properties l and l respectively the proof of correctness conclusion we have provided a formulation of sequential and concurrent separation logic rules without side conditions for variable usage the rules are more expressive than the original system yet they retain the syntactic character of the variable conditions without adding proof burden in the programming logic itself this syntactic character is exploited in an algorithm to automatically infer the annotations required in resource declarations this should prove useful for separation verification tools like our work is also a contribution to the theory of syntactic control of interference which back to while the system has been studied from a semantics point of view it has not been previously applied to the formulation of programming logics which is somewhat given its natural fit with reasoning principles we have extended the traditional framework with permission algebras which should prove useful for further development further work along this line would include the extension of concurrent separation logic with higherorder features such as procedures and objects for which syntactic control of interference is acknowledgments we are to and her group for the session at college where this work was first presented peter ohearn has provided much and throughout the development of this work special thanks go to berdine and for making us aware of the technical problems with the earlier proof systems john work was partially supported by national science foundation grant references s abramsky and g linearity sharing and state in algollike languages ohearn and chapter s abramsky k honda and g a fully abstract game semantics for general references in lics pages ­ k r apt ten years of logic a survey acm trans program lang syst ­ oct j berdine and i variable conditions and csl private communication th april k api protocol in objectoriented software technical report university r c calcagno p ohearn and m parkinson permission in separation logic in acm symp on of program lang pages ­ acm press r c calcagno and h yang variables as resource in separation logic in proc nd ann conf on math found of program semantics main et al pages ­ j checking interference with fractional permissions in r cousot editor static analysis th symp volume of lncs pages ­ springer p operating system principles prenticehall p structured comm acm ­ july s d a semantics for concurrent separation logic theoretical comput sci ­ s d a history of concurrent separation logic in and pages ­ s d variables as resource for programs semantics and soundness in proc nd ann conf on math found of program semantics main et al pages ­ doi doi l and r milner principal for functional programs in acm symp on of program lang pages ­ jy girard linear logic theoretical comput sci ­ a j berdine and b cook precision and the conjunction rule in concurrent separation logic in and c a r hoare towards a theory of parallel programming in c a r hoare and r h editors operating systems techniques pages ­ academic press c a r hoare monitors an operating system structuring concept comm acm ­ oct b j c calcagno and p w ohearn modular automatic assertion checking with separation logic in f s de editor formal methods for components and objects th symp volume of lncs pages ­ springerverlag k k and u s fine concurrency with separation logic j logic ­ oct doi s m main a and m proc nd ann conf on math found of program semantics volume of notes in theor comput sci g a graph model for imperative computation logical methods in comp sci jan r milner a theory of type polymorphism in programming j comput syst sci ­ m and j editors proc nd ann conf on math found of program semantics volume of notes in theor comput sci p w ohearn resources concurrency and local reasoning theoretical comput sci ­ may p w ohearn linear logic and interference control in category theory and computer science volume of lncs pages ­ springerverlag p w ohearn and d j the logic of implications symbolic logic ­ june p w ohearn and r d algollike languages two boston p w ohearn a j power m and r d syntactic control of interference in s d m main a and m editors math found of program semantics ann conference volume of notes in theor comput sci as chapter of p w ohearn j c reynolds and h yang local reasoning about programs that alter data structures in l editor csl volume of lncs pages ­ berlin springerverlag s and d verifying properties of parallel programs an axiomatic approach comm acm ­ may m parkinson r and calcagno variables as resource in hoare logics in symp on logic in comput sci pages ­ ieee u s global state considered unnecessary an introduction to semantics j lisp and symbolic computation ­ as chapter of j reynolds separation logic a logic for shared mutable data structures in lics pages ­ j c reynolds a problematic program joint work with berdine presentation at the workshop on types logics and semantics for state j c reynolds syntactic control of interference in acm symp on of program lang pages ­ acm as chapter of j c reynolds algol and its specification logic in d editor tools and notions for program construction pages ­ cambridge univ press as chapter of v vafeiadis concurrent separation logic and operational semantics in and h yang and p w ohearn a semantics basis for local reasoning in pages ­ berlin springerverlag h and t polymorphic fractional capabilities in static analysis on static analysis pages ­ doi 