run your research on the effectiveness of lightweight john matthew a matthias felleisen robert bruce findler plt university il california state university san ca university boston ma university of ut university ut abstract formal models serve in many roles in the programming language community in its primary role a model the idea of a language design the architecture of a language tool or the essence of a program analysis no matter which role it plays however a model doesnt serve its purpose one way to eliminate from a model is to write it down in a mechanized formal language it is then possible to state theorems about the model to prove them and to check the proofs over the past years plt has developed and explored a lightweight version of this approach redex in a redex is a domainspecific language for semantic models that is embedded in the programming language the effort of creating a model in redex is often no more than it with the difference is that redex comes with tools for the semantics engineering life cycle in this paper we report on a validation of this form of lightweight the largest part of this validation concerns the formalization and exploration of icfp papers in redex an effort that in all papers the results suggest that lightweight modeling is effective and easy to integrate into the work flow of a semantics this experience also suggests for the developers of other tools categories and subject descriptors d programming languages formal definitions and general terms design reliability theory keywords lightweight semantics engineering the role of language models programming language researchers use formal models to communicate ideas in a concise manner many of their models explain a small piece of language design perhaps a new construct or a new type system other models express the essence of a compiler transformation the software architecture of an tool or the of a program analysis for researchers have permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright © acm used paper and to develop these models models come with however since models can lead to researchers state and prove theorems about models which forces them to the model some nevertheless this validation step and others are introduced during these become to communication for example martin from national university of recently shared with one of this papers authors his with a paper plotkin the readability is not by the fact that there are of eg page rule ii m n should be m m the rule ii on page is missing the subscript above the bar personal communication once the reader a model such is straightforward but during the initial with the paper rules may pose to the reader in contrast authors who have spent or years exploring the of their model are to the of and small even if readers report extreme over the past mechanized theorem proving has come into its own as one alternative to the approach et al in this world researchers program their models in formal languages state theorems and create proofs we consider this kind of theorem proving because it requires more explicit details than programming an alternative is to program models in functional languages such as haskell creating interpreters etc this approach provides important mechanical but the gap between the program and what appears in a papers figures to make the task and reduces the strength of the validation with these considerations in mind plt has developed redex et al felleisen et al an ex domainspecific lan guage for seman tic models the of redex is to treat semantic mod as software just like plain software systems as such semantic models have a life cycle and the life cycle idea for semantic models is similar to the one of software systems using redex a semantics for the syntax and semantics of the model creates test c e e e x x e callcc number x figure calculus plus callcc c e a e v x e callcc number e v e e hole define red domain e e a e e abort e callcc v e v x a e x fresh x callcc e x e v e subst e x v v e number e number figure the c reductions runs random tests on uses graphical tools for examples and debugging and automatically the model as a pdf it is our hypothesis that small redex efforts quickly pay off for the working semantics to validate our hypothesis we two case studies and this paper presents the results of these studies the first shows how redex helps test a language implementation with a language model the second shows that the redex methodology applies to a broad of research papers specifically the authors encoded icfp papers in redex equipped the models with unit tests translated formal and informal claims into and checked their validity in the process we found in all of the papers including one whose essential result had been verified in coq the next section the redex modeling language and tool suite from there the paper covers ten case studies our experience suggests for the authors of semantic models as well as the designers of validation tools we discuss these in the papers final sections along with related work to redex semantics use the redex language to write down the grammar reductions and for calculi or transition systems the language is a domainspecific language embedded in redex programmers inherit the a large standard library and a large set of libraries the redex covers a variety of tasks related to executing semantics definitions a for smallstep operational semantics for reduction graphs a unit testing framework a tool for randomized testing à la and hughes and automatic support from a perspective redex is a strict functional language with a powerful pattern and domainspecific constructs supporting operational semantics this section illustrates redex with a model of the calculus extended with callcc grammars the lefthand side of figure shows the grammar of the language and the corresponding redex code the latter binds the variable c to a redex language a series of nonterminals and alternatives in this case there are two nonterminals and the nonterminal has six alternatives the first application expressions uses an to indicate in this case the amounts to that each application expression consist of at least one subexpression similarly the third alternative uses an to indicate that expressions can bind an arbitrary number of variables the fourth and fifth alternatives are constants and leaving and two other nonterminals the nonterminal is builtin and matches arbitrary numbers the production for uses the special keyword it matches any symbol except and because they are used as terminal symbols elsewhere in the grammar to give a reduction semantics to c we add an alternative to and define two extra nonterminals the righthand side of figure shows both the mathematical extension and the redex code the first position in a form names the new language and the second names to the language nonterminals appearing in the body of replace those of the same name in the old language unless a appears in which case the nonterminal is extended in this case we extend with the expression form which we use to give a reduction semantics for continuations figure a of reduction the other nonterminals v and e for values and evaluation contexts respectively are used to formulate standard reduction rules the definition of e uses hole a pattern matching construct that represents the hole in a context our running example uses two alternatives for evaluation contexts the first a lefttoright order of evaluation by that evaluation can only take place to the right of values the second says that a context can be a hole reduction relations and figure contains the reductions for c on the left and the corresponding redex source code on the right a reduction relation is defined as a series of rules of the form pat pat where any expression matching pat is transformed into pat the domain keyword specifies a contract in this case that red relates terms matching the pattern e with e e a redex programmer specifies a context decomposition meaning the first rule aborts the computation by the context around expressions the second rule of red rewrites into an application of to a function that behaves like a continuation the fresh x annotation in the rule demands that the parameter of the new function does not appear anywhere else in the rewritten expression the lefthand side of the third rule uses with subscripts to specify that the lengths of the two sequences must match thus restricting the rule to applications without arity errors the rules righthand side to the subst which redex requires to be defined explicitly the keyword defines a the first two positions specify a language and a contract followed by the cases of the function each in a pair of square brackets the subst function on a list of bindings repeatedly applying a substitution function subst e x v e subst e x v x v subst x v subst e x v subst e e the substitution function is defined as usual the final rule to a this exploits embedding in number number number term number the righthand side begins with an written as a meaning that it is evaluated in and the expression is expected to return a term that is the result of the in this case the function exploits the representation of cs numbers as numbers to compute their sum the expression term number produces a list of the numbers supplied as arguments to in general term behaves like quote but also up the bindings of pattern variables number in this case and supports to indicate finally redex provides to experiment with reduction relations it accepts a relation and a term and returns a list of all contractions of the term red term a exploring examples redex provides tools for exploring the behavior of examples the traces function accepts a reduction relation and a term and shows the entire reduction graph of the term to demonstrate the value of these tools we our reduction system to model an unspecified order of evaluation in the spirit of c in this case it is an exact copy of the example models substitution function from the redex schemes unspecified order of evaluation is more sophisticated than cs but redex is up to the task and findler et al e e e e hole this extension replaces the nonterminal entirely allowing reductions to occur in any position inside an application expression next we use to replace the language of the reduction relation without adding any reductions define red that is this extension merely the existing rules with the new definition of this extended language does not satisfy the churchrosser property as a quick experiment with traces shows traces term callcc k k k figure a of the resulting window each box contains a term that the original reduces to and the arrows are labeled with the reduction rules name that the two terms the arrows connected to the term the cursor are to make them easier to pick out randomized testing randomized testing support follows a programmer writes down a property with and findler and redex generates instances of the property in an attempt to it specifically g n e tests the expression e interpreted as a predicate universally quantified over n by evaluating it at random terms generated from the nonterminal n of the grammar g for example we can test the property that every expression in c is a value or reduces to another expression to check whether an expression is a value we use which tests whether a particular term matches a given pattern to check whether an expression reduces we check whether result is nonempty e or v term e cons red term e counterexample found after attempts s of course there are a number of stuck states and redex quickly finds a simple one namely a free variable if we add an explicit reduction to error as a way to signal an error for a free variable e x error free variable and then iteratively run the test above errors as they are discovered eventually finds all of the known stuck states in the model redex provides automatic support which transforms a language reduction relation or a term into or pdf to be included in a paper indeed all of the versions of elements of the c model shown in this paper are generated automatically using redex this example shows support for a reduction relation red the main difference between this of the reduction relation and the one shown on the left in figure is that the rules are oriented instead of the is a matter of passing a flag to control the basic layout option in addition the substitution function is shown here using default for redex also provides for the of calls to which may be used to substitution in the conventional style when a reduction relation or a escapes to redex the code in a but with a background so it stands out redex programmers can then set to how such fragments are redex models for production systems redex can help language designers validate their implementations against their specifications with low cost to demonstrate this thesis we a case study using the model of delimited control by et al figure shows the models complete internal syntax including forms left out of the original papers presentation at the time of the publication of that paper the models authors had implemented a redex model built a test suite and mechanically generated their papers figures from the redex definitions they did not however employ randomized testing redex had no builtin support for it at the time this section explains how we that model to see if randomized testing could find more issues in a model it did we found in both the implementation and specification of delimited control randomized testing in redex the obvious use of randomized testing is to check a papers claims et al do not explicitly state any theorems but all is not do imply that the model is a faithful abstraction of the production implementation we can therefore test the claim that the implementation produces the result by the model e equal term e term e in this claim uses redex to reduce its argument to a value and evaluates the term via available online figure the syntax of the delimited control model unlike in where users specify test generators for the data types they define redex derives naive test generators automatically from the languages grammar in this case the derived generator has two immediate problems first grammar specifications do not address variable binding as a result the generator often produces expressions with free variables which statically second the nonterminal in figure includes syntax such as that programmers cannot write directly since our goal is not to prove a proposition but to it we begin with simple solutions to these problems a weak attempt one possibility is to discard test expressions that contain free variables and to avoid forms entirely e t equal term e term e expr expr define e this open expressions by identifier errors with an exception handler that reports the test as a success it eliminates uses of forms in the generated expression by rewriting them using which replaces expressions with one of their subexpressions or a random constant if there are no subexpressions this approach is naive but it reveals three previously unknown errors one in the portion of the semantics shown in the published paper and two in definitions the error visible in the papers figures is in the definition of evaluation contexts in figure a prompt expression has three subexpression a tag used by the other control operators to identify the prompt a body and a handler expression that receives values by expressions within the dynamic extent of the body the expressions should be evaluated from left to right but the definition of lacks evaluation contexts corresponding to the first and third see p of the icfp proceedings subexpressions for example this causes evaluation of the following expression to get stuck x x stuck the model defines function application with a rule like this one x e v subst x v e beta unlike the corresponding rule in section the have no subscripts thus the rule also applies to expressions with arity eg reducing this expression with redex raises a metalevel error because the formal parameters and actual arguments cannot be the reduction rule for expressions may also raise a metalevel exception the models redex encoding which represents numbers as numbers and primitive operators like as symbols to zero function to reduce redexes but the zero function carries a contract that restricts its application to numbers making reduction of the expression for example raise a instead of producing refining the test generator despite our initial success there is good reason to explore more sophisticated test generation strategies to start in one sample of expressions produced by naive generator only contain no free variables and only of those are not values we can avoid so many tests by a function close that replaces variables with random bound ones or constants when none are bound e equal term e term e compose close close expr define close e for this particular model though we do not discover any new errors this way test coverage tool suggests another improvement however executing one round of random tests fails to exercise of the reduction rules even once three more rules including the v rule shown in section only a few times each to exercise these rules the test generator must make several choices in the case of the v rule the generator must first choose to place an application expression in a position that will ultimately be evaluated second in the applications operator position the generator must construct an expression that evaluates to a function third in the operand positions the generator must construct expressions that do not result in runtime errors or discard the continuation containing the application fourth the generator must choose to construct the right number of operands we can these choices by providing the that it should use the rules lefthand sides instead of the more general pattern e as its basis for test generation the lefthand side of the v rule for example directly addresses the second and fourth choices above many of the patterns in the rules lefthand sides however refer to forms and so we must first replace the pass that removes expressions with one that transforms them into equivalent surface expressions for example expressions equivalent to values can be constructed from prompt and we implement this transformation as well as ones for the other forms for which it is possible see section using a function and supply it to along with the to use the reduction relation e equal term e term e compose close source expr expr define e this technique finds six more previously unknown errors two of these six are in the model made available with the paper though they did not appear in the publication the model includes a semantics for continuation marks a feature for associating pairs with continuation frames et al the expression marks the active continuation frame with key and value then applies the thunk the expression collects all marks for key on frames up to the ing prompt tagged with the models reduction rule for to a that traverses the delimited context to construct a list of its mark values this however lacks a case for contexts of the form making mark collection undefined within the dynamic extent of the test position of expressions for example evaluation of the following expression raises a metalevel error t if first x x the models definition of substitution is wrong to perform the substitution the model takes care to rename to a variable not free in but it fails to avoid choosing or the free variables of the remaining four errors are in the implementation of version these errors a test suite and years of production use but randomized testing finds them quickly continuation marks are not represented directly on continuation frames instead a stack of marks is kept in parallel with the stack that represents the continuation delimited continuations therefore capture parts of the mark stack and different slices of the stack involve different base offsets while part of a continuation to execute a one of the offsets is the resulting crash would only happen for a that is captured in a continuation that is itself captured as an extension of a composed continuation possibly with a few more we have yet to identify this error is similar to the previous one like continuation marks frames are kept in a separate stack that is synchronized with the continuation stack an offset connecting the two stacks is forced to an incorrect value when composing continuations in certain cases the produces a crash only after one more round of continuation capture and invocation continuations store a prompt tag and when they are invoked the implementation checks that the current continuation includes a prompt with the same tag composable continuations come without a tag the two kinds of continuations share much of the implementation infrastructure however and this shared implementation stores and checks prompt tags for composable continuations this error is similar to the previous one the implementation also performs a check after each the application of each during the process of applying a continuation for composable continuations the implementations should not perform such checks but once again the shared implementation performs these checks for both kinds of continuations at the time of writing we still do not fully understand the behavior of the test that discovered the first of these four errors making the of manually a test like it appear fortunately the repair was clear from the resulting core the implementations test suite contains tests that get close to finding these errors but the author did not have the to construct tests of the necessary complexity aside finding these errors seems to require a degree of that is difficult to achieve one of the first to apply randomized testing to the implementation of programming languages about his test generator for syntax although as a writer of test cases the syntax machine is certainly it is also it can test a language processor with many combinations that would not be thought of by a human test case writer errors in addition to these errors we found many more which we would have to in the specification relating the model to its implementation and errors in the passes we mention their discovery not as of randomized testing but as a of its cost formalizing the relationship between the model and its implementation with enough precision to test it is a nontrivial task the primary challenge is to decide which expressions from figure are wellformed for example the grammar includes continuation frames that contain two marks at a single key but such configurations should not occur developing a specification that includes these invariants takes some effort we used randomized testing to find expressions where violations of unknown invariants yield different behaviors in the model and implementation there is no guarantee that this sort of randomized development results in a complete specification but we are satisfied as long as the working draft avoids false positives in our tests the source of most errors was our implementation of the passes that enforce wellformedness of expressions transform wellformed ones into surface expressions and remove free variables together these passes lines of code an empirical study of icfp papers to improve our understanding of how lightweight metatheory can help authors with their papers we used redex to explore papers from the icfp proceedings the papers were chosen because we considered them suitable for in redex but some turned out to be challenges the papers include two which had already been mechanized we chose two such papers not really to find errors but to see if we would learn something about redex when implementing papers that already had a significant mechanized metatheory effort put into them we found in all papers with less effort in each case than in section we explain most of the errors we found below in the order in which the papers appear in the proceedings we omit some errors common to multiple systems eg the particular variable x with the metavariable v that ranges over variables the authors of the papers we studied have the errors described here the redex models are available online safe functional reactive programming through dependent types by and and define a functional reactive programming language embedded in agda the embedded languages dependent type system rules out domainspecific errors such as loops with immediate feedback and uses of uninitialized signals its operational semantics given as an agda function defining discrete evaluation steps carries a proof of type safety since agda accepts the function as total the paper does not show the agda definition it instead presents the semantics in the usual inference rules notation for bigstep semantics encoding the papers formulation in redex one error introduced in the manual translation of the agda code to nearly three full pages of figures specifically the conclusion of the rule in the papers figure applies to switch expressions it should apply to expressions this paper has since been revised commutative arrows and their optimization by and paul hudak et al define a class of recursive arrows that they call commutative arrows and show how they can be compiled into a single imperative loop our focus was the portion of the transformation that they describe formally a procedure for computing an efficient normal form they call commutative normal form the procedure takes the form of a normalization relation that reduces expressions bottomup using a relation based on the standard arrow axioms hughes for example the normalization rule for sequential compositions e e the subexpressions reduces the result then the e e e e e e e e e e ee using randomized testing to check whether is indeed a function with the domain and codomain found two problems in addition to arrow constructors the language on which is defined includes functions and pairs consequently some expression do not have arrow constructors at their roots the proof in the papers appendix that such expres sions must first be reduced but there are no corresponding steps in the definition reduction via the relation creates arrows built from the combinator defined in terms of the primitive constructors to account for expressions the relation includes the following rule f f i f e i f e ee for some f i f is already in normal form in these cases there is no e such that i f e leaving the rules second premise unsatisfiable and the implied procedure stuck this paper has since been revised et al partial memoization of concurrency and communication by kc and et al show how memoization can be applied in a concurrent language with synchronous primitives to show that memoization preserves meaning they define two evaluators for a concurrent language one that uses memoization and one that does not encoding these systems in redex exposed two the papers theoretical result is a safety theorem that when memoized evaluation takes a state p to a state p then evaluation takes t p to t p where the t the extra structure used for memoization as randomized testing quickly this theorem is false it fails to states in which the memo table the behavior of some function the correspondence appears to hold for executions beginning with the empty table the important case but the proofs inductive structure requires a generalized claim about states with nonempty but wellformed tables a proof typically gives this generalization explicitly since wellformedness conditions for such data structures tend to be complex the evaluator operates on program states p taken from the following grammar in which t ranges over thread identifiers and e ranges over expressions p p p te because a state p contain sat least one thread the following communication rule cannot apply in the absence of a third thread p p v t e p p t e v the same problem exists with the evaluator a concurrent ml library in concurrent haskell by describes a way to implement the concurrent ml primitives in a language that supports only firstorder message passing such as concurrent haskell jones et al he builds an abstract machine that abstracts the model common to concurrent haskell and other concurrent systems and then shows how programs using the concurrent ml primitives may be compiled into terms in his abstract machine while preserving safety progress and fairness we encoded this abstract machine source language and compiler in redex in addition to writing test cases by hand we used randomized testing to check a weak variant of the papers correctness theorem randomized testing did not produce any to the theorem but it did lead us to programs for which the abstract machine unbounded resources where proper concurrent ml implementations would not for example consider the following source expression in which c is a fresh channel c out c this expression blocks any thread that evaluates it because select cannot perform either communication in concurrent ml garbage collection this thread because no other thread can reach the channel the abstract machine on the other hand performs infinitely many steps for this expression effectively waiting for an event that cannot occur this error also shows up in the released implementation of the concurrent ml library for concurrent haskell based on the abstract machine automatically web applications marking modular continuations by extends a technique for implementing firstclass continuations via continuation marks et al adding support for source programs that themselves use continuation marks despite a proof of correctness a combination of manual and randomized testing found five errors in the translations specification as well as three errors in the semantics of its source and target languages the translation consists of four mutually recursive functions one for translating values and expressions that would be values if not for a variable in some component one for redexes one for evaluation contexts and a driver function that either to the values translation or the input and applies the translations for redexes and evaluation contexts this schema relies on a unique decomposition lemma that turns out not to hold due to four in the grammars for redexes and evaluation contexts the source and target languages are variants of form flanagan et al but the translation of evaluation contexts inserts applications in a position that does not allow them translation to preserve form seems to require the invariant that evaluation contexts translate to evaluation contexts rather than more general contexts which the translation for continuation values assumes in practice there is no need to translate such values since they do not appear in the source text of realistic programs in translated programs callcc produces a procedure that the current continuation using abort then calls a function resume for the captured continuation from a data representation of its frames a in the definition of resume however causes it to leave some frames out of the continuation the translations handling of continuation marks in the original program involves an additional mark on each frame this mark holds a data structure that records all of the other marks on the associated frame to maintain this mark the translated program first its current value using call with immediate continuation mark which has the following signature key this function the active frames marks and calls the provided function with the value associated with the given key or the provided default value if there is no such mark the translations call the third argument the translation lacks recursive calls for two of the three positions inside the e e e form used for continuation marks instead of including an explicit form for dereferencing store pointers the source language semantics has two rules for each form that demands its operand for example in addition to the usual v rule there is a rule that applies when the function position holds a pointer e v sl v where x e but with the usual definition of the authors intention this strategy does not handle pointers to pointers to functions the source language semantics lacks a rule like the following for indirect continuation application e v sl e v where e the source and target languages provide a form e for collecting continuation marks this form is similar to the operator explained in section but there are two differences first has no operand since the source and target languages do not provide delimited control second collects the marks for several keys at once its result should be a list of lists in which the inner lists contain the marks on each continuation frame as defined in the semantics however the marks for the final frame become the lists tail instead of its last element controlflow analysis of function calls and returns by abstract interpretation by jan and thomas p and systematically derive a sensitive controlflow analysis using abstract interpretation and then prove that their analysis is equivalent to a one from earlier work we discovered two problems with the paper the cps transformations domain contains expressions with constants but there is no case in the transformation functions to deal with the constants this leads to a problem in lemma which states that transforming a program to cps and then transforming it back results in the original program as stated this lemma is only true for programs that contain no constants the paper defines to be the least equivalence relation on expressions satisfying these two equations let x t in s s let x t t in s s and the analysis result includes a mapping from representative elements of this equivalence class to the values that the corresponding expressions have at runtime this definition of breaks the equivalence of the and cps analysis theorem specifically the analysis that id might be returned by the term let w fn n n n in let id fn x x in let id fn x x in let j fn t id id let d w w in id but the cps analysis correctly that it never returns the problem is the equivalence relation the two occurrences of id in the above program but should not this paper has since been revised and implementing firstclass polymorphic delimited continuations by a typedirected selective by and martin odersky et al describe an implementation of delimited continuations for scala they define a type system that distinguishes expressions with control effects allowing continuations to be implemented by a selective cps transformation that leaves expressions in direct style when they do not their continuations as we discovered while encoding the system in redex the paper merely the typing and transformation rules a redex model can close the gap between a sketch and a consistent description and our model a significant in the papers explanation the definition of the transformation function necessary recursive calls on subexpressions eg on the operand of shift we did discover one not arising from the rules informal nature the transformation which operates on expressions in form distinguishes two classes of calls that their where the expression e following the call also its continuation a behavior indicated in es type and those where e does not in the latter case the transformation has an optimization in an attempt to exploit the the definition of on the type of e instead of the type of e causing it to apply the optimization even when it is unsound a theory of typed coercions and its applications by michael and m et al define a proof system for particular program and give conditions under which various systems operate for all results except the ones on rewriting using polymorphic coercions they provide coq proof scripts we discovered two problems with an example in the section polymorphic coercions first one instantiation of a polymorphic coercion is missing second the example is based on the assumption that the rewriting process will leave one particular expression alone when in fact it might be rewritten complete and decidable type inference for gadts by simon peyton jones martin and et al define a type system for generalized algebraic datatypes gadts giving both a declarative specification and a sound and complete inference algorithm encoding the algorithm in redex three in the papers definition the type system that et al consider most natural for gadts is undecidable their key insight is that decidability can be by sets of unification variables called that may not be unified to solve certain constraints the rules for let expressions let expressions and individual case clauses introduce these variables which stand for unknown types the third of these three rules however the wrong variables as in an email exchange ­ mar the papers lead author stated that they did not intend their model as a precise description he also explained that they meant for the function to be applied by a driver function whose operation accounts for the absent recursive calls the paper does not mention this driver this author also reported that the scala implementation does not make the same optimization as the transformation sketch available online the rule for entire case expressions correctly that all of its clauses produce a result of the same type but instead of assigning the entire case the type the rule gives it the type a metavariable that does not appear anywhere else in the rule though the notation does appear the constraint solving algorithm lacks a rule for arrow types our effort § tests loc our case studies required two kinds of efforts first each had to understand his assigned paper to a sufficient degree so that he could formulate a model second the had to implement the model in redex the adjacent table the second kind of effort each row mean shows the number of lines of code the number of test cases and the number of properties tested for each of the models in the above on the average a model consists of lines of code including tests and three or four claims learned our experience suggests for the authors of programming languages papers for us as the developers of redex and for the developers of other validation tools for authors redex supports in a form that semantics and still common errors although we do not have precise effort for the case study of section we estimate that encoding and testing each model required less time than understanding the content of the paper as our case studies show lightweight reduces the number of in a model and thus increases its value as a communication aside we would not have to understand these papers without their models is too and frequently too brief to build more than a understanding for example one of the authors of the present paper would have an for the paper in section having seen the semantics for continuation marks many times and having with web servers despite this preparation he failed to understand the papers intuitive explanation of the system until he studied its formal model in such cases where the reader primarily relies on the model for explanation ones obvious to in become significant barriers to communication lightweight enables interactive exploration expanding the means with which authors and readers communicate in the case of every paper we found that executing examples improved our after we had already understood enough of the system to encode at least part of it in redex when we were if we understood a definition or if its implications appeared problematic we ran examples often the ones we choose would have been too tedious or too to work out by hand sometimes the experiment our hypothesis other times it a in our reasoning either way the exercise improved our understanding of the system for redex our experience suggests that redex is a technology but also in its redex offers little support for handling binding constructs in object languages it provides a generic function for obtaining a fresh variable but no help in defining substitution or equivalence three of the papers in section require definitions of one these concepts and definitions of these concepts facilitate testing in two other papers and the model of section in one case section binding in redex a significant portion of the overall time spent studying the paper redex should benefit from a mechanism for dealing with binding starting from the recently studied approaches and pitts pottier sewell et al next redex lacks direct support for relations such as the theory of et al and the declarative typing rules of et al when we modeled these systems we were forced to escape to host language or to adopt an elaborate encoding which we would not expect a redex user to be with extending redex with support for logic programming as in pfenning and prolog and or ml should solve this problem at present redex also provides no mechanism for specifying structural congruence this gap the encoding of transition rules such as those et al and define on concurrent programs we hope to adapt et al matching to notion of patterns finally while is often a that random test case generators require little programmer sometimes they are not as effective as they could be the generator derived from the grammar in section for example requires substantial to achieve high test coverage this is especially in the case of typed object languages where the code almost the specification of the type system the technique behind et al may be effective in automatically constructing tests from the original specification alternatively strategies and are possibilities with the addition of more declarative support for binding specifications and inference rules for developers of other tools last but not least our case study suggests several that should apply to all validation tools regardless of how much they differ from redex first the for authors concern developers too since authors require tool support to apply the in particular support for execution enables interactive exploration authors and readers second tests complement proofs we encountered five papers in which explicitly theorems are false as stated in three cases section section and section we could fix the problems in the others section and section we were unable to find and verify a fix in a time frame in every case though testing discovered errors with proofs indeed we claim that tests complement even proofs as one example two of the solutions that contain proofs of type soundness use callbyname beta in violation of the specification crary and personal communication we believe unit testing would quickly reveal this error see et al section for another example execution unit tests automated tests binding ml prolog k redex figure a comparison of lightweight semantics engineering tools even better one can sometimes test propositions that cannot be validated via proof our experience with the model of delimited control operators provides one example as no formalization currently exists of the more than lines of c and assembly in the implementation testing also removes another to proof the requirement that we first state the proposition of interest due to its nature testing can but desired propositions eg that threads block without waiting section this is especially true for and randomized testing to some degree the same is true of proving but testing seems to be more effective at covering a broad space of system behaviors many other validation tools provide some level of support for executing examples without requiring an algorithm to be specified separately prolog and go so far as to provide tools for automatically third mechanized avoids many errors given the apparent frequency with which we observed in icfp papers and their potential impact on communication mechanically generating figures from a source to some form of mechanical seems justified sewell et al and et al already support this workflow fourth example debugging we extensively on features while the described in section as well as the many more introduced by the manual process of translating figures to redex the features have been similarly useful in other efforts eg the formalization of typed and felleisen section we conjecture that all validation tools would benefit from components related work the form of related work would be other studies that attempt to validate semantics engineering tools on published formal models but we are of any such studies accordingly this section focuses on tools that could be used for such studies large formal models that have been to lightweight forms of validation and studies of the validity of research results in general other tools the development of redex from a system designed to provide software with a lightweight alternative to theorem proving with software build models of software systems and explore them with mechanical support redex to provide a similar experience to semantics the system for natural semantics supports a range of tools providing execution by compilation to prolog a debugger and mechanized and a from lightweight to validation these features and more in redex and other tools figure provides a comparison between redex and other modern lightweight semantics engineering tools all of ml prolog and k and sewell et al redex and dijkstra and provide support for executing definitions though in the case of the precise level of support depends on the particular proof assistant chosen as the prolog features an automated testing tool similar to but based on search rather than randomized testing similarly k can exploits model checker to check predicates k redex and all support mechanized but approach to the output write code to transform redex parse trees instead of annotating definitions with ml prolog k and provide the sort of binding support redex lacks only redex provides a library of domainspecific constructs for and interactive but k users can write tests thanks in part to the of the challenge et al semantics use proof et al pfenning and and the coq development team to validate semantic models these tools have various levels of support for executing examples but none share support for the semantics engineering life testing language definitions several groups report success with testing techniques where proof systems fail for example et al sarkar et al and and check that they have defined correct models of various assembly and machine languages by comparing their models answers to the answers produced by actual hardware or by compilers and employ similar techniques for c using k some of their efforts exploit randomized testing et al also use a randomized technique to compare a model of the virtual machine to the production implementation the formal model of the et al catch bugs in the informal specification research validity this paper reveals in our own work and the work of our while we did not discover any that the essential contributions of any of the papers we studied others have done so et al examine several systems and a number of published claims on the search cost their basic insight is that factors outside the control of an the search order for influence the performance of such tools similarly and a systematic review of the use of randomized algorithms in selected software engineering in and show that randomized algorithms are used in a significant percentage of papers but that in most cases is not properly for this casts on the validity of most empirical results randomized algorithms further studies concerning the quality of research results are common in the community et al for example write that an empirical evaluation of the papers on the effectiveness of published in highly visible in ­ showed that a of the and five of six studies had already been or found to have been by conclusion our validation project the lightweight conjecture specifically it establishes redex as an effective tool that can in mathematical models of programming languages the two case studies contribute two different insights with the survey of icfp papers we validate the claim that all mathematical papers contain our conclusion is not to blame the icfp authors or reviewers for these takes but to suggest the routine use of lightweight tools to write such papers every in a published model the communication channel between authors and readers conversely we can this channel when we papers with executable lightweight models that readers can easily explore with the case study of delimited continuations in production systems we illustrate how an can benefit from the designers lightweight model redex can help expose errors in an implementation even a one merely by testing the correspondence between it and a model this aspect of semantics engineering is and more attention especially for large languages that over many years acknowledgments thanks to michael thomas jan and for and discussions of their work thanks also to for helpful comments on a draft of this paper the authors support for this research from the nsf and and c a practical guide for using statistical tests to randomized algorithms in software engineering in proc intl conf soft pp ­ e matthew j foster benjamin c pierce peter sewell weirich and mechanized metatheory for the the challenge in proc intl conf theorem proving in higher order logics lecture notes in computer science volume pp ­ and automated testing based on java predicates in proc intl symp soft testing and analysis pp ­ a concurrent ml library in concurrent haskell in proc acm intl conf functional programming pp ­ james and mechanized metatheory modelchecking in proc intl conf principles and practice of declarative programming pp ­ james and prolog a logic programming language with names binding and equivalence in proc intl conf logic programming lecture notes in computer science volume pp ­ and john hughes a lightweight tool for random testing of haskell programs in proc acm intl conf functional programming pp ­ francisco and system in proc intl conf rewriting techniques and applications lecture notes in computer science volume pp ­ john matthew and matthias felleisen modeling an algebraic in proc symp programming pp ­ executable specification of static semantics in proc intl symp semantics of data types lecture notes in computer science volume pp ­ a formalism to implement natural semantics inria research report no dijkstra and s programming type rules in proc intl symp functional and logic programming lecture notes in computer science volume pp ­ matthew b person and g controlling factors in evaluating error detection techniques in proc acm symp foundations of soft pp ­ and an executable formal semantics of c with applications university of illinois matthias felleisen robert bruce findler and matthew semantics engineering with plt redex mit press flanagan bruce f and matthias felleisen the essence of compiling with continuations in proc acm intl conf functional programming pp ­ matthew robert bruce findler and matthias felleisen adding delimited and composable control to a production programming environment in proc acm intl conf functional programming pp ­ formal specification and verification of arm in proc intl conf theorem proving in higher order logics lecture notes in computer science volume pp ­ and o a monadic formalization of the instruction set architecture in proc intl conf interactive theorem proving lecture notes in computer science volume pp ­ j and andrew m pitts a new approach to abstract syntax with variable binding formal aspects of computing ­ pp ­ v automatic generation of test cases ibm systems journal pp ­ david s w smith and william d a robust machine code proof framework for highly secure applications in proc intl acl theorem prover and its applications pp ­ john hughes generalizing monads to arrows science of computer programming ­ pp ­ daniel a lightweight object modelling notation acm trans software and methodology pp ­ simon peyton jones andrew gordon and concurrent haskell in proc acm symp principles of programming languages pp ­ and robert bruce findler randomized testing in plt redex in proc scheme and functional programming pp ­ matthew and robert bruce findler the virtual machine and randomized testing matthew r an executable metalanguage for inductive definitions with binders phd dissertation university of cambridge and paul hudak commutative arrows and their optimization in proc acm intl conf functional programming pp ­ and paul hudak commutative arrows j functional programming pp ­ and robert bruce findler an operational semantics for scheme in proc scheme and functional programming pp ­ robert bruce findler matthew and matthias felleisen a environment for developing contextsensitive term rewriting systems in proc intl conf rewriting techniques and applications lecture notes in computer science volume pp ­ automatically web applications marking modular continuations in proc acm intl conf functional programming pp ­ jan and thomas p controlflow analysis of function calls and returns by abstract interpretation in proc acm intl conf functional programming pp ­ jan and thomas p controlflow analysis of function calls and returns by abstract interpretation information and computation c and proof assistant for higherorder logic springer verlag towards a practical programming language based on dependent type theory phd dissertation university of technology greg john and matthias felleisen continuations from generalized stack inspection in proc acm intl conf functional programming pp ­ frank pfenning and system description framework for deductive systems in proc intl conf automated deduction pp ­ gordon d plotkin callbyname callbyvalue and the calculus theoretical computer science pp ­ pottier an overview of cml in proc acm sigplan ml electronic notes in theoretical computer science volume pp ­ john h concurrent programming in ml cambridge university press and martin odersky implementing firstclass polymorphic delimited continuations by a typedirected selective in proc acm intl conf functional programming pp ­ and an overview of the k semantic framework j logic and algebraic programming pp ­ sarkar peter sewell scott thomas o and jade the semantics of multiprocessor machine code in proc acm symp principles of programming languages pp ­ simon peyton jones martin and complete and decidable type inference for gadts in proc acm intl conf functional programming pp ­ towards safe and efficient functional reactive programming phd dissertation university of and safe functional reactive programming through dependent types in proc acm intl conf functional programming pp ­ peter sewell scott thomas sarkar and effective tool support for the working j functional programming pp ­ and michael a brief overview of hol in proc intl conf theorem proving in higher order logics lecture notes in computer science volume pp ­ michael r matthew van richard william robert bruce findler and revised report on the algorithmic language scheme cambridge university press michael and m a theory of typed coercions and its applications in proc acm intl conf functional programming pp ­ encoding natural semantics in coq in proc intl conf algebraic methodology and software technology lecture notes in computer science volume pp ­ the coq development team the coq proof assistant reference manual version and matthias felleisen the design and implementation of typed scheme in proc acm symp principles of programming languages pp ­ s john pa and why current publication may science pp ­ kc and partial memoization of concurrency and communication in proc acm intl conf functional programming pp ­ 