proofs of the absence of common runtime errors m al laboratory stanford university stanford and division of engineering and applied school of end sciences university cambridge ma the verifier is a working system for proving the absence of common runtime errors the language accepted is pascal without variant records side effects in functions shared variable parameters to procedures or functional arguments the errors checked are accessing a variable that has not been assigned a value array out of range type error dereferencing a nil pointer arithmetic overflow and division by zero hoare and axiomatic definition of pascal does not reflect restrictions on computation that result from certain elements of the computing environment such as type definitions functions with limited domains and in the implementation of the language to unify the treatment of these restrictions huet and have developed an extended semantics of pascal in the extended semantics preconditions sufficient to guarantee error free execution are required before each program statement the run check verifier uses semantics based on this approach the semantics makes use of a special predicate which intuitively is true if its argument has been assigned an initial value to that the program does not evaluate an uninitialized variable v the extended semantics requires the precondition to be proved at every statement that evaluates v initialization checking applies to all data structures and permits for example verification of programs that operate safely on partially initialized data structures without accessing uninitialized portions the user programs with entry exit and possibly invariant assertions the system automatically applies four different methods for constructing or strengthening invariants making it unnecessary for the user to supply complete invariants the methods are analysis of arithmetic on numeric variables to find loops that initialize arrays propagation of assertions by the verification condition generator loop and procedure call rules and strengthening invariants by analysis of verification conditions results obtained so far are overflow not checked in some cases programs that can be shown free of runtime errors given only entry assertions include quicksort sort fast linear search and binary search given simple invariants the system can verify slightly harder programs including a spanning tree algorithm and the list marking algorithm this research was supported by the advanced research projects of the department of under contract c and by the national science foundation under contract programs such as find and list reordering and insertion with root and have been verified with more complex user supplied invariants the system always operates fully automatically the program is first passed through the documenter which performs a shallow semantic analysis of each loop to generate valid assertions about the simple numeric variables part of the documenter makes use cf and the simplifier the system simplifier is the simplifier component of the stanford pascal verifier it is a general purpose theorem prover since p rules have the effect of propagating assertions forward in the program and into loops invariants provided by the user or generated by the documenter need not be as detailed as would be required by other including the regular version of the stanford verifier the output of the documenter consists of the original program with added valid invariant called documenter comments attached to the loops after the program has been the verification conditions are generated using the extended semantics thus all of the error checking preconditions are included in the then the system attempts to simplify the if some of the cannot be proven this indicates either that the program is or that the assertions are too weak the vc analyzer the invariant assertions in an attempt to make the provable this process continues until the program is verified or the user to stop in sites presents techniques for proving termination with absence of ru errors for a class of flow graph programs his techniques have not been implemented and describe a special purpose system for checking that array subscripts are in the proper range our handles a range of runtime errors in the array subscript errors our system is considerably more general and can verify y programs that cannot be handled by the methods of inductive assertion generating methods are also discussed in the documenter and vc analyzer are based on some new methods and some refinements of earlier methods this paper is divided into five sections section describes the extended semantic definition used in in addition to def the predicates and which are useful for expressing error checking preconditions are defined the functions init and valid are mappings from pascal expressions to logical formulas containing def and init and valid are used to define the extended semantic axioms for assignment and while statements in addition to checking for error free execution the while rule has special features that facilitate proofs by reducing the level of detail needed in loop invariant statements invariant assertions are never needed for variables that are not changed on a loop assertions about the extent of variable initialization before the loop are automatically propagated for variables that are changed invariants may refer to the value of variables immediately before entering the loop as well as the current value thus the inputoutput specifications of a loop can be expressed con d y documenter comments are assumed true without proof in the the soundness of the analysis methods guarantees validity of these invariants section presents the program analysis methods for forming valid invariants the documenter processes a program in three phases phase constructs recurrence relations from symbolic execution of single loops and solves them our use of recurrence relations differs from previous work in that loops with conditional branching are analyzed to find bounds for variables in a report ii that available just before the completion of this paper and manna present rules related to the counter analysis rules that also handle conditional branching use of the initial value feature of the while rule construction of invariants in nested loops or with branching before the loop in cases where the efficient but specialized methods of phase do not produce assertions for a variable phase tries to form assertions by proving that a given set of properties are invariants of a loop the third phase generates in variants for a special class of loops that initialize arrays section describes the vc analyzer section discusses the use of the verifier as a tool for debugging programs with potential runtime errors section contains conclusions our invariant generating methods are compared to other methods o notation t reference class used to represent the set of values of a pointer of type tt value of the variable p where p has type tt set of all pointer values of type tt ao an identified names with suffix o l etc are used by the verifier to avoid name conflicts with identifiers appearing in programs a e value of the array a after assigning the value e in the ith position r f e value of r after r fe t cp e value of t after pe where p has type t functions that have a pascal type as their value the type of an expression e value is r if a has type of s function from function identifiers to types predicates on the type of an expression true iff e does not have a compound true iff e has an array type true iff e has a record type true iff e is a reference class true iff e is a constant type phrases used in a special sense the phrase simple variable is with both variable identifier and declared variable a selected variable is a component of a variable identifier eg a is a selected variable a is either a variable identifier or a selected variable when discussing a loop while l do b we refer to l as the while test and tl as the condition for the loop extended pascal semantics the presentation in this section is based on approach to extended semantics of we begin with an example which illustrates the general technique consider an assignment statement such as xy where x and y have type integer the familiar axiom defines the meaning of this assignment by the formula pl p the extended semantics adds a precondition states that the variable y must have a value before executing the xy p certain difficulties arise in extending the semantic definition to properly reflect runtime restrictions related to the type environment of a program it will be necessary in stating our semantic axioms to use the function whose value depends on the name of an expression x and the declarations but does not depend on the value of x similarly the values of and are determined by the program expression and not by its value in semantic definitions it is typical to use the names of variables to represent their values this is often convenient since it reduces the amount of notation in the definition there are however in which it would be natural to refer to the names of variables as distinct from values for various reasons we have not introduced distinct names in our semantics when a predicate or function symbol such as type has the name of an expression as its argument the symbol will be in lower case with this convention we must be careful not to substitute a value expression for a variable appearing within an formula to prevent such substitutions we will always immediately replace expressions by the values of the expressions without i examples this convention are given in section we assume throughout that only programs that meet all the syntactic requirements of pascal are being considered in our implementation the parser performs all of the required syntactic checking including the usual compiletime type checks so that programs never reach other parts of the verifier basic predicates of program states type type if type is a ab then else true the following axioms define the class of expressions satisfying a more discussion of the hk contained in is def note that axiom also checks for zero division since all expressions that are evaluated must be proven def no other rule for zero division is required in the extended semantics a op b where op is an operator in and or not div b where f is a function identifier in making this definition we assume that functions always terminate and return an initialized value if their arguments are initialized checking of function entry conditions is performed by the function call rule see section a where a is a pascal variable of an array type and i is an integer expression b where p is a pointer type pascal variable where e is an expression a type a vi where a is a pascal variable of type b where r is a pascal variable of a record type and f fn are the record field names c u vp c arrays is useful when dealing with partially initialized vi our use of the predicate in placed the explicitly quantified assertion is by the to make the system completely automatic at the present state of development in verification one must choose to have either generality in specifying properties of data structures or automatic simplification of verification conditions first order logic is convenient for specifying many properties of complex data structures but the performance of automatic theorem provers that deal with quantified assertions is for verification our choice is to define the most commonly used assertions as special predicates we provide the simplifier with inference rules that it can apply automatically to simplify formulas containing the special predicates the user can new predicates and supply additional inference rules should they be needed to specify a particular program the formula means b is at least as fully initialized as a if a is a compound object then that a and b have the same type the definition of consists of a base clause for simple types and is extended recursively to compound types z a o a vi a o a n a a vp c is helpful in making assertions about monotonicity of initialization since our assignment rule requires the right hand side of every assignment statement to yield an initialized value the extent of variable initialization cannot decrease during program execution without the assignment rule because we prove at each assignment that an initialized value is used it is safe to assume without further proof that variable initialization does not decrease over any sequence of statements formally this principle can be stated as a rule of inference p a true a where v is a variable identifier lo this rule of inference is used implicitly in the formulation of the semantic definitions of loop statements and procedure call basic functions for forming preconditions we will say that an initialization error occurs if a variable that not been assigned a value is or if an involving a function or pascal operator is evaluated and one of the arguments in uninitialized if a component of a compound variable is used in an expression the component must have been initialized to that a pascal statement executes without an initialization error we will require each evaluated expression contained in the statement including each evaluated subexpression to have a well defined value for a program expression p the precondition that p executes without an initialization error the formula is a conjunction of instances of def and for each argument t to a function or operator in p for example if a statement contained the expression we would require the precondition which is a a a a under our definition of initialization error a program expression such as xx cannot be evaluated unless x has a value this is because had we defined the precondition for absence of initialization error in the program expression xx to be merely evaluation of xx would have been permitted even if x did not have a the reason is that in the logical theory underlying the semantics x stands for the value of the variable x and xx is equal to o which is a constant therefore is always true but because the xx is not the same as the program expression o is true only if x has a value the full initialization precondition to be if a variable is accessed many times on a program path many instances of def will be produced by since it is desirable to keep the verification conditions short we have implemented a special simplifier for def which uses the axioms to eliminate many of the trivial this simplifier called is applied to the vc after vc generation is completed but before the full simplifier is called eliminates by traversing the vc in preorder and maintaining at each level of logical implication a list of expressions assumed to be def the list of known def expressions and the axioms are used whenever an assertion involving def is encountered clauses involving are also simplified does not attempt to simplify equality inequality or other operators and so the nontrivial parts of the precondition are left for the main simplifier here are some examples of and output def true ia i c if v has type of t n o va the function valid which operates on a pascal variable is useful in extending the semantic rule for assignment we will say that a variable is valid if it is a legal left hand side for an assignment statement any variable identifier is valid a selected variable is valid if all of the array indexing and pointer dereferencing needed to determine the variables address can be completed without a runtime error each array subscript in the variable must be able to be evaluated nw and the value must be in the proper range each that is must be able to be evaluated and be non null some examples of variables and their to be valid assume the variable a has type a of t a true ail ail nil note the functions init and valid can be defined precisely as recursive functions mapping expressions into logical formulas containing def and refer to for these definitions other preconditions on expressions overflow to absence of overflow in an integer valued arithmetic expression a op b en requires the precondition s a op b s the user must supply an entry assertion stating the value of see example section this approach can be extended to deal with floating arithmetic overflow and because there are some programs which one would not want to prove overflow free overflow checking can be omitted by the user for example in a numerical routine such as matrix multiplication one might choose to permit inputs that could potentially cause overflow and rely on the computer hardware to signal errors at runtime because the weakest sufficient preconditions on the input matrices are too to be useful function and procedure parameters checking of the range and initialization of actual parameters is included in the extended function and procedure call rules every value parameter must have a value def and be in the proper range variable parameters must be valid they do not have to satisfy def the checking of the body of a function or procedure is performed by the extended function and procedure declaration rules for further details of these rules and other aspects of the extended semantics refer to note since function calls are permitted in any expression the function call rule is incorporated in many of the other rules for purposes of we have simplified the rules by removing function call semantics thus the actual rules implemented in and described in are slightly different from the ones presented here assignment rule the extended semantic rule for assignment to a simple variable is va ve q the conjunct is included in case v is a variable that as of type checking performed by ke parser the assignment rule can assume e and v either have the same type or that the types differ only in that one or both is a numeric hence the check is sufficient at this stage to detect any remaining type for selected variables there are three cases q q examples type var var var of consider an assignment to the variable s i j q the expressions are replaced by their resulting in si q after simplification of the precondition by and elimination of we have q sj q when assigning to an element of the array a for both the index and the element types will be checked q after expansion of init and valid this becomes q while rule the while rule implemented in is best introduced by developing it from simpler rules to begin we assume the reader is familiar with the basic iteration rule p o i r i q p invariant i l do b this rule can be extended to the l always evaluates without a error one approach to forming the extended rule is to require that init e satisfied when the loop is entered initially as well as at ee of each iteration since this requires to be an invariant can be assumed to hold before each iteration and upon exit from the op the following adds to the users invariant it unnecessary for the user to state assertions by in his invariant p b q p invariant i while l do b q a b c d ru ie from the familiar frame problem assertions that hold before the loop cannot be used to prove b or e unless they are included in the invariant l to reduce this problem we using the basic while rule introduced by basic rule is n xv xv xv invariant while do xv where x is the set of variables that are not changed by the body b v is a set of variables whose value may change in b and v is a set of new unique variables the final rule is this is essentially the same as the rule presented in xv invariant while do xv where is a documenter comment and is the conjunction lv for the variable identifiers v in v the documenter comment is assumed true without proof in the because the documenter guarantees its validity the clause is justified by in this clause goes further than in eliminating the frame problem by using properties to propagate assertions before even for variables that are changed example the following program takes an array a of real numbers uses the variable s to sum the elements of a in the subscript range ni and then s by n the user has supplied an entry assertion stating i and n have before executing the program that and n is between and the last clause of the entry assertion sets n to n to be the legal range for arithmetic results without overflow the exit assertion states that t hm a value the users invariant assertion of true contains no semantic information ii is included only to satisfy the syntax requirements of the verifier the program to the verifier consists of the lines as shown below the lines in represent additions made by the throughout this paper we will follow the of the in tile has introduced a new variable for the value of i entering the loop note that although i is a v lz is m x variable the assertion states that the of i is increased by the loop assignment by the documenter will contain an arrow instead g the usual assignment operator to distinguish them from assignment statements that are part of the original program documenter assignments are present only for specification purposes they are not checked for runtime errors pascal type var var var var of real entry exit begin so i invariant while true s do begin end end after analysis by the documenter the program is to shown below is the verification after al a a fl a a a a a a ln a a a b a b a a b b a b c a c c c l d a d a d a d io a d a d e a a the lines have been for reference to groups of lines and for reference to individual lines that the verification condition has the form a o b c a d o e part a is the entry assertion the implications and are the for the path around the loop and the path to the exit respectively the atomic formulas involving and are for the vc analyzer and do not concern us here new variables io so il and sl have been introduced to represent the values of i and s inside and after the loop the new variables are def because i was initially def and s was assigned the value the assertions at i i i from simplification by of instances of ac h the while rule the assertion appears with i instantiated to i and i instantiated as either io exit path at or i loop path at lines contain the while test since i and s are def on the loop the only error checks remaining in the vc for the loop path are the array subscript at and the overflow check on the entire vc simplifies to true part of the definition of def to prove the documenter this section of the paper is divided into three corresponding to the three phases of the documenter the input program is first processed by the counter analysis phase then by the second or invariant phase and by the array initialization phase each phase applies a set of rules for generating valid invariants from the program and entry assertions the output of documenter consists of the program and the valid loop comments produced by each phase counter analysis counter analysis attempts to extract information from the assignments made to a variable on a single loop considering the initial conditions of the loop or the conditions controlling branching within the the first step in counter analysis is to introduce a new unique variable to act as an iteration index for the loop the variable is initialized to o immediately before the loop and is by at the end of the body example invariant true while do begin if pi then begin else begin index invariant true while qj do begin end index end end the second step in is to construct for each variable a which represents the effect on the variable of a single iteration m the body the change vector for a variable v for the possible values of v after a single iteration cf the body expressed in terms of at the beginning of the iteration there is one change in a change vector for each path through the body the paths are in a canonical order determined by the branching of the loop body in the previous example the change vector for i is ik and the change vector for m is m rj on the inner loop the change vector for j is j on the loop the change vector for j is j where is a that represents the value of j upon the the final step of counter analysis produces assertions by a small set of rules which permit to be inferred from the change vectors the currently in use have the restriction that they do not apply to a variable v if it is not possible to put all of its change expressions vi into the form vi ci where op is an arithmetic operation x div which is the same for all vi and each ci contains only constants and variables not changed in the loop in the previous example this restriction means that counter analysis would not produce assertions for the variable j on the outer but an assertion would be generated for the inner loop in describing the rules we will refer to variables v and w with change vectors v and w respectively the change expressions for the iq path will be vi and vi the variables v and w are but see section la in which these restrictions are removed the values of v and w immediately before entering the loop variables c ci and k stand for expressions whose values do not change on the loop the variable named is the loop index for the loop under consideration each rule consists of a condition that must be satisfied followed by the invariant that is generated on ch ex documenter comment a for all i b for all i or lc for all i div c vv div a for all i vv b for all i and where is defined by if xo then else c analogous rule for division for all i and if there are paths on which neither v nor w is changed delete elements from both change vectors corresponding to the paths on which neither variable is changed then introduce a new index to represent the number of iterations on which either v or w is changed and apply the other rules to form invariants when rule a is applied to a variable v the documenter eliminates the index from the program since index remark the current set of rules is not intended to be complete in any sense in practice the rules seem to be adequate for runtime error checking in situations where the rules do not the necessary invariants are often produced by another phase of the documenter or by the vc analyzer example invariant true while in do begin if pi then ii else begin jj end end change vectors i i i j j j documenter comments produced index i index ii a j a to analyze this example the system introduces an iteration index forms e change as za to i and j the assertions produced appear to be weak they do not give an upper m i or a an however inside the loop in is true j the while test this implies an upper bound for index index index ni the upper bound on index sets a lower bound on jj a the assertions constrain the value of j even in the absence of specific initial values for i and j for instance suppose the only assertions known true before entering the loop are io and so that j will have a lower bound of when in assert io a invariant true while do begin if pi then ii else begin jj end ii end the documenter does not attempt to use the assertions known before the loop to directly express the lower bound on j instead since the documenter comment is an assertion expressed in terms of i i j j and index and identifies occurrences of i and j preceding the loop with i and j the vc for the loop body will contain in its all the information needed to deduce any consequence of the bounds on j it is easier to construct assertions ing to the inputoutput characteristics of the loop than to form equivalent assertions that do not use i and j as variables example z for i to do begin if pi then jk else begin jl end mm nn end change vectors i il ill j jk jl m m m n n nl documenter comments produced i oi a i j min k i jj m a n a k ii since the variable i is by on each iteration the documenter can express the iteration index as ii the for loop assigns the value to i so thus i is substituted where index would have appeared in the documenter comments the invariants for j and m are produced by rule a evaluation of the terms min k and max ki is not by the documenter because the values are determined completely by the context before the loop and counter analysis is concerned only with inputoutput relationships since m and n are both unchanged on the first path through the body the documenter uses rule to consider the effect of the second path in this example the second phase of the documenter will propose in as a invariant if conditions before entering the loop allow in to be proven true initially the documenter will have established an upper bound on i for paths alone the number of executions of the second path can be expressed as mm this expression is used for the index in rule lb to form the invariant for n an invariant for n can also be derived from rule b but in cases where part or wk i is rule is not used example this program is a version of the user only an entry assertion saying that the array a m fully initialized the integer n is initialized and z and for overflow checking ma the documenter produces assertions sufficient to prove absence of subscript and overflow errors notice that it is nontrivial to check the array and a on the innermost loop because of the need for facts from the outer loops the range of i depends on j which depends in turn on k which depends on n and m var type of integer procedure entry exit true label var begin mn div in de xo mm invariant true mm while mo do begin a for j to k invariant lj do begin ij in sel true a invariant true i a while do begin if then go to w m in de x nd ex end end mm div in de end end on the outer loop the variable m is divided by on each iteration so rule ic is applied the upper bound for j of on the for loop is produced by a phase rule s in all for loops the documenter uses one of the original variables to express the iteration index the invariant for i on the inner while loop is produced by rule la with these assertions the system is able to prove absence of subscript and overflow errors la an extension of counter analysis the iteration index variables are not checked for overflow because they are present for documentation only one of the of counter analysis h that it does not make use of information from the program context it applies the rules for change expressions assertions known to hold before entering the loop previously known for the loop and predicates known to hold on paths within the loop all place constraints on the change expressions which may be useful m applying the rules for example consider the effect of the following pair of nested for loops which repeatedly adds y to the variable x x for to n invariant true a do begin xx for j to k invariant true xx a kj do end a since the inner loop increments x by y on each iteration rule la applies the change expression for the outer loop however is simply a new variable xo because x is changed on the inner loop on the outer loop the inner loop invariant and exit test can be combined to give a relationship between x and xo ly a a jk a once this relationship is known rule la can be applied to the outer loop because is of the xc rule la gives the invariant xx il the difficult aspect of this use of predicates is that simplification is needed before it is possible to determine which constants will allow the analysis rule to apply a specific goal for the simplifier cannot be stated we are currently designing an of counter analysis which the organization of the stanford pascal simplifier the in part by in a particular theory all of the consequences of a given set of assertions thus it be to of the analysis rules to change o the context by first to the al f the known to hold in the program context and the resulting simplifier database of consequences to the correct constants documenter second phase the second phase of the documenter attempts to extend the documentation on each loop by and testing for numeric variables each invariant proposed is tested by generating and proving verification conditions use of the general theorem prover makes the second phase slower but more than the phase two types of invariants are proposed during the second phase for each numeric variable that cannot be by the counter analysis rules phase two proposes stating that the value of the variable is weakly increased ie increased or left unchanged or by the loop even in cases the pattern of changes to a variable s relatively complicated may be possible to prove that its value on the loop is always larger or always smaller than the initial value the resulting assertions are often useful for runtime verification purposes certain other invariants are proposed depending on the form of the loop exit condition the remainder of this section presents the details of the in vari an ts proposed in each of the two categories a increasing or decreasing variable test to test whether a variable v changed by a while statement is increasing or decreasing the system attempts to prove the formula p vv invariant v r v d while l do b true where p is an assertion known to be true before executing the loop r is a relation sign either s or v represents the value of v before entering the loop d is a documenter comment already known to be valid the clause v r v is the invariant if the proof is successful the invariant is added to the documenter comment this test does not require v to be changed on every iteration it is sufficient for v to remain larger or smaller than v the proof of a invariant is done in a special documenter pascal semantics that does not check for runtime errors this approach is sound because the verifier proves absence of runtime errors after the documenter is finished whenever a invariant is proven valid there is a possibility that other invariants that previously failed to verify will be provable with the stronger documenter comment a new invariant on a loop w may other invariants either on w or on other loops contained in the body of w or on loops following w in the program to take advantage of a new invariant the documenter some invariants that failed previously since it is time to test invariants it is crucial to have a good mechanism for deciding which invariant to try next refer to for details of our implementation binary search in this example phase two proves that the loop increases the variable low and decreases the variable high so the assertions are added to the program type of integer procedure var y integer entry exit va r begin low low high high invariant true low slow a high high while do begin z if then low mid else high mid end if x then y low else yo end these assertions are sufficient to verify the absence of and overflow errors in the loop but verification of the if statement after the loop requires an additional assertion to show we will return to this example in section to show how the vc analyzer the invariant b extracting invariant from exit tests we have seen that counter analysis attempts to express the inputoutput relations of a loop without regard to the conditions under which the loop terminates typically the output of counter analysis contains assertions relating the values of program variables to a loop index representing the number of iterations of the loop with an additional assertion stating that the index is o the loop exit heuristics complement the other components of the documenter by to form invariants that are consequences of the termination condition at present the documenter has two rules for constructing invariants loop exit tests both are based the simple intuition that if a loop is caused to terminate by a certain expressions reaching a boundary value then it may be an invariant of the loop that the expression is always on one side of the boundary if the condition that causes a loop to be contains a numeric equality disjunct eo then the invariants eo are considered if the condition that causes a loop to be contains an inequality disjunct eo the documenter tries to find a constant expression c st ec is invariant one case in which there may be a c is when all of the change expressions ei for the expression e are functions of e and constants for all i ei i and each fi is increasing in e in this case our choice for invariant will be ci factor in our current implementation of the rule is that the system can determine that the ei are functions of e and constants only in a restricted case example quicksort pascal type of real procedure entry a exit true var x real var begin if lr then begin left left right right invariant true while left right do begin invariant true right while a and left right do right invariant true while and left right do left left end end end lr the user only an entry assertion saying that the array a has a value and that the integer parameters l and r are in the proper range if lr since l and r are value parameters they are assumed to be def at the beginning of quicksort and on each recursive call the for l and r are proven def the documenter comments right right and on the inner loops are by counter analysis using these assertions the increasing or decreasing variable test produces the assertions for the outer loop stating that left is increasing and right is decreasing the remaining assertions come from the loop exit test heuristic because the condition for the first inner while loop contains the disjunct and the change expression for is which is increasing in e the inequality fe e is tested as a invariant it is true initially each time the first inner loop is reached because the while test of the outer loop is left right therefore it is attached to the loop as a valid assertion on the second inner loop the same invariant is produced m exactly the same way and it s verified initially using the invariant of the first inner loop in example the assertions produced by the documenter are not sufficient to verify absence of runtime errors after an initial attempt to prove the the vc analyzer adds the conjunct to the outer loop the program is verified with this additional invariant documentation for array initialization thus far or presentation of the documenter has been concerned with generation of assertions for simple numeric as mentioned earlier the difficulty in dealing automatically with general assertions about data structures is currently a limiting factor in verification since we do not use explicitly quantified assertions documentation can be generated only for the existing set of special predicates at present the documenter has one rule for data structures the rule generates assertions for loops that initialize arrays as new classes of assertions about data structures become with defined predicates we add corresponding analysis rules to the documenter the rule attempts to detect assignment statements which alter consecutive elements of an array on consecutive iterations of the loop the particular rule we have implemented applies only in very limited here as elsewhere in the documenter more work is needed to develop general analysis procedures implementation details the rule considers one loop at a time and operates on the assignment statements of the form within a loop body the first step is to try to express the subscript i in the left hand side of an assignment in terms of variable values at the beginning of the body this is done for each assignment statement in the body the second step is to for each pascal array type variable v whose address is constant with respect to the loop and for each path through the body the set of elements of v that are on each path fin all y this information is tested to see if consecutive elements of a variable are initialized by the loop let v be a pascal variable whose address is a constant with respect to the loop and i be an integer expression let n be the set of paths of the loop which initialize vi where i is expressed in terms of variable values at the beginning of the path if i is unchanged over each path around the loop not in n and for each path in n is either unchanged or by then the assertion i v where i represents the initial value of i is a valid invariant similarly if condition is true but the expression i is by then i v can be example merging two arrays this program takes as input arrays a and b of length and transfers their contents into the array c which has length the user has supplied only an entry assertion saying that a and b are fully initialized and an exit assertion saying that c is fully initialized the interesting aspect of this example is that the of c takes place in two loops the first loop partially c elements from a and b until either a or b has been completely then the of c continues in either the second loop or the third loop the first loop is interesting in itself for the handling of conditional branching by the rule pascal type type var of integer of integer var entry exit begin i j sl jj invariant true a j a a jj a while and do begin if then begin end else begin jj end end invariant true de a s a while do begin end jj invariant true a a while do begin jj end end the documenter begins by generating inequalities for i and j applying the array initialization rule on the first loop the documenter notices assignments to on both paths in both cases the index is already in terms of variable values at the beginning of the body the system computes the change vector for the expression ij and finds that it is increased by on each path therefore the invariant ij c is added to the first loop the second and third loops also assign to c and receive assertions since variables cannot become less initialized during execution the assertion from the exit of the first loop will still be true after the second and third loops are finished thus at the end of the program can be proven by combining the effect of the first loop and the second two the vc generator will assert in the vc that the array c is more fully initialized on exit from each loop than it was on entry to the loop the vc will contain all the information needed to prove on exit the assertions are also sufficient to show that the program executes safely a a stronger axiom for array initialization this section presents an approach which is more general than the array initialization rule currently implemented in the documenter we that the extended semantic definition of pascal allows us to assume that a variable which becomes def at some point during execution of a program will remain def during execution even if it is assigned new values this property of def can be used as the basis of a general strategy for forming assertions about the extent of initialization the basic idea is that if the body of a loop a component of a variable on each iteration we can form a valid invariant expressing the effect of repeated execution of the body if the address of the component initialized on each iteration can be expressed as a function of the loop index consider a while statement contained in a larger program and with an invariant i which is valid in the context in which the while statement appears index o invariant i while l do begin b index end assume the formula b is true where v is a variable identifier is a pascal variable which is a component of v and is expressed in such a way that it depends only on v index and expressions c cn that are constant with respect to the loop then the assertion vj is a valid invariant of the loop in special cases can be reduced to an instance of vc analyzer after the documenter adds system calls followed by the simplifier if all of the are proven the verification is finished if some of the cannot be proven it indicates either that the program is or that the assertions are too weak the vc analyzer the invariant assertions in an attempt to make the provable then the system calls and the simplifier again this process until the program is verified or the user to stop let us return to the binary search example type of integer procedure var y integer entry l exit var low high begin low low low high high invariant true low slow a high high while do if x then low mid else end if x then y low else yo end high mid on the path that exits the loop it is necessary to prove i of this is the precondition for the array access a low i since the loop exit test is and the documenter comment low low to the precondition low is the vc analyzer the simplified from information in the it can determine the location in the program corresponding to the precondition it combines the loop exit test with the precondition to form the implication a this implication is to the invariant of the while loop intuitively the new conjunct asserts that low is s when the loop n new are generated using the stronger invariant and they simplify to true with stronger invariant the vc analyzer after one pass through type of integer procedure m var entry exit var low high mid integer begin low low low high high invariant true a low slow a while do begin if xa mid then low mid else high mid end if then y low else yo end in general the vc analyzer attempts to deal with any equality or precondition which is when a precondition appears in a vc it generally appears with variable substitutions resulting from the assignment rule to distinguish the original precondition from the version with substitutions in a vc we will refer to the latter as a goal the contain special atomic formulas involving the symbols and which allow the vc analyzer to determine the in the program corresponding to each goal in a vc the define the path that must be taken from the beginning of the program to reach the statement corresponding to each precondition every time the path passes a branch in the program a is added to the vc an is added each time a loop is entered or information associated with the tag identifies the particular statement involved see example section when it finds an goal the vc analyzer traces backwards in the program from the point at which the goal was a required precondition to find the last loop containing a statement that changes the value of one of the variables appearing in the goal the invariant of this loop must be if the vc is to be made provable the vc analyzer adds as a conjunct of the invariant the implication precondition the is the conjunction of branch tests the path from the loop to the statement containing the precondition the substitution represents the changes made in the values of variables along the path between the loop and the statement with the precondition the implication states that precondition will be true if the path m followed in the sense of the implication is the for verification of precondition if precondition is true for every execution of the program the implication must also be true on the loop the implication may however be too weak to be proven invariant without additional assertions on the loop in other words assertions produced by the vc analyzer are necessary for proving precondition but may not be sufficient if the program incorrect so that precondition can be false during an execution be false and is the invariants formed by the vc analyzer tend to result m some when are simplified it n common for one invariant to have many similar implications added because several preconditions are on one path or because one precondition is on many paths invariant formed by the vc analyzer are also somewhat redundant because an implication with a as antecedent m a useful assertion only on the one path for the holds on other paths it is trivially true to reduce the of invariants from the vc analyzer automatically applies two types of propositional transformations to the the merging transformations eliminate by combining similar assertions the distribution transformations eliminate assertions from paths on which they are useless it m interesting to note that the system is able to verify quicksort section b even if the documenter does not produce the assertion on the inner loops to verify the assignment statements and after the inner loops left must be s in the context after the inner loops the assertion left right left because of the inequalities on right if is missing from the inner loops the vc analyzer adds left to the inner loops and the program is verified this verification is slower than the one using the exit three iterations through the simplifier are required instead of two because lt relies on the general vc analyzer heuristic when the documenter the system can construct sufficient invariants in many situations that are too complex for the documenter to analyze a runtime error in an incorrect program when the verifier to prove a program correct lt returns simplified which the users attention to the specific part of the program that cannot be proven by studying the and the corresponding part of the program the user can decide whether it is the program or its assertions that is at fault the following example a version of the marking algorithm what happens when the verifier is given an incorrect program as input this particular example appeared m the literature where properties other than correctness were proven with an automatic program verifier the of this program which does not meet the runtime requirements of pascal m a argument for checking runtime errors as part of any verification it also demonstrates that the of the verifier is not to proving correct programs on the contrary the verifier is a very effective debugging tool for programs with potential runtime errors the user has supplied two invariant assertions with the program the verifier requires an assertion within each loop formed by goto but the assertion need not appear immediately after a label as it does here note that word a reference class name appears in the users assertions the assertion means that every allocated record of type word m fully example the transformations are defined in pascal label type list type word record fl integer m integer end var entry exit true begin assert if or then goto z ml w xz goto assert if then if then begin w xt goto end else begin w goto end end the vc generator produces three for this program one for the path from the entry and for each of the two assert statements a single vc for all paths starting from that statement the vc for paths starting at the assert at label is the only one that does not simplify to true simplified verification condition main a a at this point the user the simplified vc to decide whether it is the program or its assertions that is incorrect in this case the interpretation is straightforward on paths starting from label the precondition is added to the vc to ensure correct runtime evaluation of zt in the part of the if test if or then rules of evaluation require both arguments of the operator or to evaluate safely even when the first is true if the user had not recognized the error he would have allowed the vc analyzer to the invariants observe that requiring z nil at label causes the path from the entry to be thus the error in the program would be pushed back to the entry conditions and the process would require the user to add as entry conditions until he realized the error discussion the verifier is an example of an augmented program verifier by an augmented verifier we mean one that has special facilities for a particular class of proofs in this case proofs of the absence of common runtime errors but which also general purpose capabilities so that arbitrary user specifications can be verified as well this notion with the idea of a special verifier such as the array bound checker of and which is built around a domain specific theorem prover in for example the simplifier is limited to the domain of linear inequalities although the legal subscript condition for accessing is a pair of inequalities the verification conditions needed to prove that holds at a point in a program often fall outside of the limited domain this is typical when lemmas containing nonlinear assertions or assertions about complex data structures are needed to establish the value of a subscript an augmented verifier the general mechanisms needed to generate and simplify verification conditions for such lemmas two forms of are present in our system extended semantics which the users specifications to absence of runtime errors and the mechanisms for generating inductive assertions the concept of an augmented verifier can be applied to other areas of verification for other applications one might also extend the general purpose theorem prover to make it more powerful in relevant domains readers familiar with previous work on generating inductive assertions will recognize that while our methods are similar in form to earlier approaches they are significantly different in system operates completely there are some differences between the verifier and earlier work semantics invariant generation in the verifier benefits from being embedded in a logical system containing our while rule assertions that hold in a program are automatically available at points further into the program previous methods required assertions to be explicitly propagated forward in all cases with our while rule it is possible to introduce a new variable to stand for the initial value of a variable upon entering a loop previous methods difficulty when the initial cannot be easily expressed in terms of other program variables eg if conditional branching or another loop affects the initial value of a variable by forming assertions that express input output relations of a loop the documenter avoids some of the difficulties of expressing invariants directly invariant because a general purpose theorem prover must be used to test invariant rules that propose invariants are very expensive an earlier comment is worth in this even if assertions are always in a domain such as linear inequalities a general purpose theorem prover is needed to check the verification conditions our system forms invariants we do not have generalization heuristics which try to prove a assertion on a loop by a more general assertion these heuristics are one of the sources of invariants in previous approaches in in variants are formed by generalizing the assertion to be proven there are many instances in which the necessary invariants are not among the invariants formed by the generalization heuristic used in some such cases the documenter does form the necessary invariants during its routine analysis of the program vc the vc analyzer represents the approach of forming invariants by working backwards from the assertion to be proven without generalization we have started to investigate techniques by which this general method can be applied efficiently specialization of data structure documentation because our system is designed to in a specific type of proof we can identify commonly needed classes of assertions about data structures and develop specialized program analysis techniques eg documenter rule absence of infeasible methods some methods for generating inductive assertions are more suitable for hand simulation than automation because they rely on operations that are either difficult to implement eg symbolic manipulation of conditional recurrence relations or slow when performed automatically with adequate generality eg theorem proving in a nontrivial first order theory with full quantification we have avoided such infeasible methods to what extent is it practical to prove absence of runtime errors first of all the verifier is an effective tool for its is not limited to programs that are already correct on the other hand the inherent requirement that the user give specifications even if only an entry assertion means that using a verifier can never be as easy as for instance using a compiler in our view the primary limitation on the of runtime verification is the amount of user effort needed to specify a new program as the examples in this paper illustrate the effort is often minimal in other examples handled by the system but not shown here the specifications are more difficult to write eg because complex data structures must be described due to the augmented capabilities of the verifier and the possibility of at least developing standard approaches to aspects of the proving process are not fully automated verifying runtime properties is considerably easier in practice than verifying arbitrary properties of programs the author is for the advice and constructive of references n and z manna inference rules for program annotation al memo aim stanford university october b the generation of inductive assertions for proving program correctness stanford research institute stanford project july s m a system for automatically of common runtime errors stanford preparation proving the absence a memo in sm and b a synthesizer of inductive assertions ieee trans on software engineering se march pp hoare c a r proof of a program find comm acm jan pp hoare car and n an axiomatic definition of the programming language pascal acts informatica vol pp huet g d and d extended pascal semantics for proving the absence of common runtime errors stanford al memo k and n pascal user manual and report second edition springerverlag new york sm and z manna logical analysis of programs comm acm april pp knuth dc the art of computer programming vol i fundamental algorithms reading mass pp d and n automatic program verification v verification oriented proof rules for records and pointers stanford al memo aim march nelson c g and d a simplifier based on efficient decision algorithms these proceedings sites rl proving that computer programs terminate computer science department report cs stanford university may n automatic verification of programs with complex data structures phd dissertation dept of computer science stanford university n and k implementation of an array bound checker proc fourth acm symposium on principles of programming languages january pp b the synthesis of loop predicates comm acm pp n program development by refinement comm acm april pp n the root and program was suggested by n 