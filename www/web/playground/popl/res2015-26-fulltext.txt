a decision procedure for netkat foster cornell university kozen cornell university matthew cornell university university cornell university complete popl consist well easy to abstract netkat is a domainspecific language and logic for specifying and verifying network functions it consists of kleene algebra with tests kat augmented with primitives for testing and modifying packet and encoding network previous work developed the design of the language and its standard semantics proved the soundness and completeness of the logic defined a pspace algorithm for deciding equivalence and presented several practical applications this paper the theory of netkat including a specialized version of the derivative and presents a new efficient algorithm for deciding the equational theory using bisimulation the structure admits an efficient sparse representation that results in a significant reduction in the size of the state space we discuss the details of our implementation and optimizations that exploit equational axioms and structure to yield significantly improved performance we present results from experiments that our tool is with tools on several benchmarks including and translation validation categories and subject descriptors f formal languages classes defined by grammars or automata keywords coalgebra kleene algebra with tests derivatives automata network verification netkat introduction networks have received attention in recent years as a target for domainspecific language design the of sdn as a popular paradigm for network programming has led to the of a number of sdn programming languages including netcore maple and among others ­ the details of these languages differ but each to provide highlevel abstractions to simplify the task of specifying the packet permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm processing behavior of a network in addition to sdn languages a number of verification tools including and are also being developed as sdn is being in production data center and networks it is clear that sdn is the next major step in the evolution of network technology and is to have a significant impact previous work by et al introduced netkat a language and logic for specifying and verifying the behavior of networks netkat provides generalpurpose programming constructs such as parallel and sequential composition conditional tests and iteration as well as primitives for and modifying packet and encoding network the language allows the desired behavior of a network to be specified in contrast to approaches netkat has a formal mathematical semantics and an equational deductive system that is sound and complete over that semantics as well as a pspace decision procedure it is based on kleene algebra with tests kat an algebraic system for propositional program verification that has been extensively studied for nearly two several practical applications of netkat have been developed including algorithms for testing reachability and noninterference and a syntactic correctness proof for a compiler that translates programs to hardware instructions for sdn switches this paper the theory of netkat defines a new algorithm for deciding equivalence based on this technology and presents a full implementation in ocaml the new algorithm is significantly more efficient than the previous naive algorithm which was pspace in the best case and the worst case as it was based on the of a nondeterministic algorithm the contributions of this paper are both theoretical and practical on the theoretical side we introduce a new model of netkat including a specialized version of the derivative in both semantic and syntactic forms we prove a version of theorem for netkat that shows that the model is equivalent to the standard and language models introduced previously a of our theoretical development is a representation theorem showing that the derivative can be encoded in matrix form on the practical side we develop a new decision procedure for term equivalence based on our theoretical results along with a full implementation in ocaml the algorithm constructs a bisimulation between coalgebras built from netkat expressions via the derivative the matrix representation enables us to exploit to obtain a significant reduction in the size of the state space the implementation is very efficient in can verify reachability in a realworld network in less than a second on a we demonstrate the realworld applicability of our tool by using it to decide common network verification questions such as and translation questions in modern networks the results of experiments on these benchmarks demonstrates that our implementation compares with the state of the art the rest of this paper is organized as follows in § we briefly review the syntax and semantics of netkat in § we introduce netkat coalgebras along with a variant of the derivative in § we prove our main theoretical result on which the correctness of our equivalence algorithm is based a generalization of theorem relating netkat expressions and netkat coalgebras in § we discuss a representation of netkat coalgebras using matrices which is needed for our implementation in § we present the details of our implementation focusing on how we exploit the netkat axioms and structure to achieve significant performance improvements over the naive algorithm defined previously in § we describe three applications developed from our theory which are used in the evaluation of our implementation in § we report on the results of experiments in § we discuss related work and in § we present conclusions and identify directions for future research overview in this section we briefly review the syntax and semantics of netkat along with other results that are needed to understand our algorithm described in the following sections netkat is based on kleene algebra with tests kat a generic equational system for reasoning about partial correctness of programs kat is kleene algebra ka the algebra of regular expressions augmented with boolean tests formally a kat is a structure k b · where b k and · k · is a kleene algebra · b · is a boolean algebra · b · is a of k · the kleene algebra operators are choice sequential composition · which is often in expressions iteration fail and skip elements of b are called tests on tests choice sequential composition behave as boolean disjunction and conjunction respectively and and stand for and truth respectively the operator is the boolean negation operator sometimes written as ¬ the axioms of kleene algebra are as follows p q r p q r pq qp pq r pq pr pp p pp p p qr pr qr q px x pq x q xp x qp x where p q p q q the axioms of boolean algebra are a bc a ba c ab ba a aa aa a in addition to the axioms of kleene algebra above kat can model standard imperative programming constructs p q pq if b then p else q bp while b do p as well as hoare partial correctness assertions b p c bp pc bp rules become universal horn in kat for example the hoare bc p c c while b do p bc becomes the universal horn sentence pc bc ka and kat have standard language models consisting of respectively the regular sets of strings over a finite alphabet and the regular sets of guarded strings over disjoint finite alphabets of test and action symbols these language models play an important role in that they are the free models on their generators which means that they exactly characterize the equational theory there are other useful models including binary relation and trace models used in programming language semantics kat is complete for the equational theory of binary relation models the equational theories of ka and kat are both pspace complete netkat extends kat with primitives for modifying and forwarding packets along with additional axioms for reasoning about programs built using those primitives more formally netkat is kat with primitive actions and tests · x n assignment · dup duplication · x n test we also use id and drop for and respectively intuitively the assignment x n assigns the value n to the field x in the current packet the test x n tests whether field x of the current packet contains the value n the action dup the packet in the packet history which keeps track of the path the packet takes through the network as an example the expression switch port port encodes the command for all packets located at port of switch set the destination ip address to and forward the packet out on port the netkat axioms consist of the kat axioms as well as the following axioms which the behavior of tests assignments duplication and the interactions between them x n y m y m x n if x y x n y m y m x n if x y x n dup dup x n x nx n x n x nx n x n x nx m x m x n x m if n m intuitively the first axiom states that assignments to distinct fields may be done in either order the third axiom says that when a packet is duplicated the values of the fields in the head packet are preserved in the history the other axioms have similar intuitive interpretations there are many models that satisfy the netkat axioms but the standard model of netkat is formulated in terms of functions a packet is a record whose fields assign constant values n to fields f a packet history is a nonempty sequence of packets · · · k in which the head packet is operationally only the head packet exists in the network but in the logic we keep track of the packets history to enable precise specification of forwarding behavior involving specific paths through the network every netkat expression e denotes a function e h h where h is the set of all packet histories intuitively the expression e takes an input packet history and produces a set of output packet histories e the semantics of the primitive actions and tests are as follows for a packet history with head packet x n nx if x n x n if x n dup where nx denotes packet with the field x to the value n note that a test x n the packet if the test is not satisfied and passes it through if it is tests behave as filters on packets the dup construct the head packet yielding a fresh copy that can be modified by other constructs hence in this standard model the dup construct can be used to encode paths through the network with each occurrence of dup marking an intermediate the kat operations are interpreted as follows p q p q p · q q p p pn n ¬b if b if b the interpretation of sequential composition is often called composition as it is composition in the category of the powerset monad the operator actions thus the expression port port describes the behavior of a switch that outputs a copy of the packet on ports and note that this is a from the usual kleene algebra interpretation of as nondeterministic treats it as rather than disjunctive nevertheless it is not difficult to show that the axioms of kat and netkat are sound over this interpretation the proof of completeness is more difficult and uses a language model that plays a similar role as the regular sets of strings do for ka and the regular sets of guarded strings do for kat the language model for netkat consists of the regular sets of reduced strings of the form p dup p dup p · · · pn dup pn n where is a complete test x n · · · xk nk the pi are complete assignments x n · · · xk nk and x xk are all of the fields in some arbitrary but fixed order every netkat expression can be rewritten to an equivalent reduced expression note that we will use metavariables p to range over netkat expressions as well as complete tests the intended meaning will be clear from context in which every test is a complete test and every assignment is a complete assignment likewise every string of primitive actions and tests is equivalent to a reduced string modulo the netkat axioms the set of reduced strings is described by the expression at · p · dup · p where at is the set of complete tests and p the set of complete assignments the complete tests are the atoms minimal nonzero elements of the boolean algebra generated by the primitive tests complete tests and complete assignments are in correspondence determined by the sequence of values n nk it is straightforward to show that every netkat expression e can be interpreted as a regular set of reduced strings ge the netkat axioms can be expressed in a simpler form for reduced strings let p be the complete test corresponding to the complete assignment p likewise let p be the complete assignment corresponding to the complete test the netkat axioms for reduced strings are as follows dup dup pp p p qp p at see the previous paper on netkat for a treatment of the language model including proofs of the claims above netkat coalgebra coalgebra is a general framework for modeling and reasoning about statebased systems a central aspect of coalgebra is the characterization of equivalence in terms of bisimulation our work is motivated by recent with decision procedures for ka and kat however to apply these techniques to netkat we must first develop its theory this will provide a combinatorial view of netkat similar to classical automata theory for ka and automata on guarded strings for kat this section this theory which provides the necessary structure for our decision procedure for background on the general theory of coalgebra in modeling statebased systems see the survey article by the only general knowledge needed from this domain is the following coalgebras are usually defined in terms of a set of states along with observation and continuation maps the observation map gives information about each state while the continuation map specifies transitions from one state to the next the nature of these maps depending on the type of the system being modeled two states are considered bisimilar if the observation maps yield identical information for both states and the continuation map leads again to bisimilar states a homomorphism is a map between coalgebras that preserves the structure of observations and continuations there is often a final coalgebra into which there is a unique homomorphism from any other coalgebra of the same type two states are bisimilar if and only if this homomorphism maps them to the same state in the final coalgebra as an example a deterministic automaton over a finite alphabet is a coalgebra with an observation map s that indicates whether a state is an accepting state and a continuation map s × s that specifies the transitions of the automaton the final coalgebra is the powerset of the set of all strings over with observation and continuation maps given by the semantic derivative such that l if and only if l contains the null string and l a w aw l for a and w the unique homomorphism from an automaton to the final coalgebra takes a state s to the set of strings that would be accepted by the automaton if s were the start state there is also a syntactic derivative defined inductively on regular expressions exp over · e ee · · e da da b a ee ee ee · ee ee e e ea a where or according as is true or false respectively the map taking a regular expression e to the set of strings it represents is the unique homomorphism to the final coalgebra definitions a netkat coalgebra consists of a set of states s along with continuation and observation maps s s s for at a deterministic netkat automaton is simply a finitestate netkat coalgebra with a distinguished start state s s there are also corresponding notions of nondeterministic automaton and a procedure but we will not need these for our formal development in this paper the inputs to the automaton are reduced strings belonging to the set u at · p · dup · p that is u contains strings of the form p dup p dup · · · dup pn for some n intuitively attempts to consume p dup from the front of the input string and move to a new state with a residual input string this succeeds if and only if the reduced string is of the form p dup x for some x p · dup · p in which case the automaton moves to a new state as determined by with residual input string x the observation map determines whether the string p should be accepted in the current state formally acceptance is determined by a defined predicate accept s × u p dup x x p t a reduced string x u is accepted by the automaton if accepts x where s is the start state a netkat coalgebra is a coalgebra for the set f x × the continuation and observation maps the structure map of the coalgebra x f x one can see immediately from equation that and are isomorphic to the families of square matrices over x and respectively with rows and columns indexed by at indeed in § we will exploit the correspondence between p and at to express and in matrix form the reader familiar with coalgebra might notice that the final coalgebra of the above functor is not exactly reduced netkat strings however the semantics of a netkat automaton as of reduced netkat strings can be by doing a generalized powerset construction in which one of the atoms in the argument of is hidden in the state this is analogous to the situation for nondeterministic finite automata these are compact of languages which need to be made deterministic in order to recover language semantics as the canonical equivalence for space reasons and to keep the presentation simple we will not explain the generalized powerset construction involved in the language semantics but rather give the concrete definitions of the semantic map and syntactic structure on expressions the derivative this section a variant of the derivative for netkat the derivative comes in two versions semantic and syntactic the semantic version is defined on subsets of u and gives rise to a netkat coalgebra u the syntactic version is defined on expressions and also gives rise to a coalgebra exp d e there is a unique language interpretation g exp u language semantics the language semantics for netkat is given by the semantic derivative u u u a x p dup x a a p a syntactic coalgebra there is also a syntactic derivative d exp exp e exp where exp is the set of reduced netkat expressions it is defined inductively as follows dp db · d e e d e d e d ee d e · e e e · d e d e d e · e e e · d e ep p p eb b e dup e e e e e e e e ee e e · e e ee e e · ee note that the definitions for are circular but both are welldefined if we take the least fixpoint of the system of equations theorem for netkat in this section we prove that a subset of u is ge for some netkat expression e if and only if it is the set of strings accepted by some finite netkat automaton this result is the generalization of theorem which relates regular expressions and automata to netkat readers familiar with previous work on netkat may notice that the syntactic derivative is actually defined on a superset of reduced netkat expressions that includes arbitrary tests b the definition given here illustrates the connection to previous work on derivatives in the context of kat and remains correct when restricted to complete tests from automata to expressions let m s s be a finite netkat automaton consider a graph h with nodes s × at halt and labeled edges u v if u v u p halt if u we claim that for x p · dup · p t x halt x this can be proved by induction on the length of x for the basis t p halt t p for the induction step t halt u t u x halt u t u x x p dup x the set of labels of paths in h from t to halt is a regular subset of p · dup · p and is described by a regular expression et these expressions can be computed by taking the star of h considered as a square matrix by the set of strings accepted by m is the regular subset of u described by e · es as shown previously if re u where r is the canonical interpretation of regular expressions as regular sets of strings then re ge hence we have the following theorem theorem let m be a finite netkat automaton there exists a netkat expression e such that the set of reduced strings accepted by m is ge from expressions to automata for the other direction we show how to construct a finite netkat automaton me from an expression e the states of the automaton are netkat expressions modulo associativity commutativity and idempotence with e as the start state the continuation and observation maps are the syntactic derivative introduced in § lemma the set accepted by me is ge proof by lemma g is a coalgebra homomorphism from the syntactic exp d e to the settheoretic coalgebra u by induction on the length of the string we have the following p ee ge p ge p dup x x x x ge p dup x ge it remains to show that me is finite this follows from the fact that e has finitely many derivatives up to we defer the proof of this fact to lemma in the next section as it depends on some details of our data representation theorem for every netkat expression e there is a deterministic netkat automaton me with at most at · states accepting the set ge where is the number of occurrences of dup in e term and automata representations in this section we develop a collection of concrete structures that are useful for representing netkat automata and will lead to a practical implementation they also provide further theoretical insights into the structure of the netkat language matrices the reader has probably that many of the operations used to define the syntactic derivative d and e closely matrix operations indeed if we regard the types of the coalgebra operations as having the following types x x then we can view t as an at × at matrix over x and t as an at × at matrix over moreover if x is a kat then the family of at × at matrices over x again forms a kat denoted x under the standard matrix operations thus we have x x x so the syntactic coalgebra defined in § takes the following form dp db j de e de de de · ie ee · de de ee · de · ie where ie is the diagonal matrix with e on the main diagonal and elsewhere and j is the matrix with on the main diagonal in position and elsewhere similarly we have ee e ee ee ee · ee ee ee note that in this form e becomes a kat homomorphism from exp to likewise we can regard the settheoretic coalgebra presented in § as having type u u u again in this form becomes a kat homomorphism lemma i i ii a b a b iii a · b a · b iv a a proof these properties follow straightforwardly from the definitions in § for example for iii and iv we have ab p ab p a p b p a · p b a · b a · b a n an n an a here we the cases for tests b and complete assignments p the next lemma characterizes on the regular operators lemma i n an n an ii ab a · ib a · b iii a a · a · ia where ia is the matrix with the set a on the main diagonal and elsewhere and the matrix sum in i is union proof we argue ii and iii explicitly i follows from linearity ii by definition ab x p dup x ab to show that p dup x ab the string must be the product of two reduced strings one from a and one from b depending on which of these strings contains the first occurrence of dup one of the following must occur there exists such that p dup x p · p dup x with p a and p dup x b or there exist y and z such that p dup x p dup · z with p dup a z b and x z in the first case we have a and x b hence x a · b in the second case we have a and z b hence x y z a · b thus ab a · b a · b abstracting over indices we obtain the matrix equation ii iii from i and ii a aa aa a · ia a · a the derivative is the least fixpoint of this equation which by an axiom of kat is the righthand side of iii the following lemma says that g is a coalgebra morphism from the syntactic coalgebra exp d e to u lemma i ge ii ee ge where g is extended to matrices proof by induction on e i for primitive terms p b and dup g x p dup x p at p at gp g x p dup x p b p b gb g · p x p dup x p dup p at p dup p at the case e e is straightforward since g and d are linear for products using lemma ii · ie · de · · ge · ge · ge ge · ge e re r e r r e re r figure netkat for star the system defining de is de de · ie ee · de whose least solution is de ee · de · ie using lemma iii · de · ie · · ge · ge · ge ii for p b and dup ep p p p at gp eb b p b gb p dup p at the case e e is straightforward since g and e are linear for products using lemma iii e ee e e · e e ee · ee ge · ge ge · ge for star using lemma iv ee ee ge ge as was just shown matrices provide an elegant and compact way to express and encode netkat derivatives it turns out that the set of derivatives of an expression is finite and can be bounded as a function of the size of the expression itself to prove this we develop the notion of the of a term e and show that derivatives can always be represented as sums of in our implementation both of these representations are put to work we encode the derivative using matrices whose elements are sets of intuitively the of an expression can be obtained by the occurrences of dup and forming a pair of expressions built from the expressions appearing to the left and right of the dup the left component of the pair is called the left spine and the right component is called the right spine the are related to the derivative in the following way the left spine represents the expression that must be consumed before the occurrence of dup can be consumed itself and the right spine indicates the expression that remains after doing so for example the set of of the expression a · dup · b is just a b and indeed a is the expression that must be consumed before the dup and b is the expression that remains after it is consumed the inductive definition of the of e denoted is given in figure in many situations just the right are useful they can be defined more simply as follows to the notation we write a · e for de d a and e · a for ed d a where a exp and e exp e · e · e it is easy to show that every right spine in has the form · e · e · · · en where the ei are subexpressions of e and that there is one spine of e for every occurrence of dup in e the next lemma relates the derivative of e and its right lemma for any de r r e thus the derivative de is a sum of terms of the form r where r proof the proof is by induction on the structure of e notation slightly by representing sums of terms as sets we argue the cases for products and star explicitly for products we have the following equalities d ee d e · e e e d e r r e · e e er r e re r e r r ee r r e where we use the induction hypothesis in the second step for star we have the following equalities d e e e d e · e e er r e · e re r ee r r e the final lemma presented in this section shows that the of of e are themselves of e hence taking repeated derivatives does not introduce new terms lemma if d then this is a convenient which we take with as we are working modulo the representation of the derivative in this form is often called the derivative proof the argument for sums is straightforward for products d · e d · e or d d ce and c or d d ce and or · e · e or for star d · e d ce and c · e for dup d d note that we cannot have d or d since these sets are empty taken together these lemmas show that repeated derivatives of e can all be represented as sums of terms of the form d where d thus the number of derivatives of e is at most at · where is the number of occurrences of dup in e moreover these terms can be represented as a pair of an atom and a subset of using these representations to build netkat automata provides a foundation for building an efficient implementation as is described in the next section implementation we have built a system that netkat equivalence given two netkat terms it first converts these terms into automata using derivatives and then tests whether the automata are bisimilar our implementation consists of lines of ocaml code and includes a parser and a simple we have also integrated our decision procedure into the sdn controller platform this integration enables automated verification of important properties for realworld network and configurations our implementation a number of important and optimizations that avoid potential sources of combinatorial in particular the derivative and algorithms described in the preceding sections are formulated in terms of the netkat language model consisting of sets of reduced strings of complete tests and assignments building a direct implementation of these algorithms would require constructing square matrices indexed by the universe of possible complete tests and assignments which is exponential in the number of constants in the terms following such a strategy would be even for small terms instead our implementation uses a symbolic representation that exploits symmetry and and optimizations to away values that do not contribute to the final outcome although the algorithm is still exponential in the worst is as the problem is constrained nature of realworld networks allows our tool to perform well in many common cases data structures the foundation of our implementation is based on a collection of data structures that provide symbolic representations for building and analyzing netkat automata bases bases represent sets of pairs of complete tests and as symbolically typically avoiding having to enumerate every possible packet value let e be a netkat term and let x xn be the collection of fields appearing in it likewise let ui be the universe of all values associated with xi either by a test xi n or an assignment xi n a base is a pair of sequences x xm o om where the xi ui are sets of values and the oi ui are optional values the set represented by a base contains all tests where the value of the test for field xi is drawn from xi and the value for the assignment to xi is either ni if oi is defined and equal to ni or the same value as the test otherwise matrices using bases it is straightforward to build a sparse matrix representation in which the rows and columns are indexed by complete tests and assignments to encode a matrix we simply use a set of bases to encode a matrix over a set we use finite maps from bases to elements of the set for example when constructing the e matrix for a term e tests xi mi are represented by u ui mi ui un where denotes a missing optional value similarly assignments xi mi are represented by u un mi sums and products can be obtained using matrix addition and multiplication as implemented using base sets the product of bases x xn o on and y yn q qn is nonzero if there exists a complete assignment in the left base that matches a complete test in the right for each field if oi then the intersection of xi and yi must be nonempty otherwise the tests corresponding to the ith field will drop all packets produced by the left base on the other hand if oi then its value must belong to yi if these conditions hold the resulting product z zn w wn is defined as follows zi xi xi yi if oi if oi oi wi qi if oi and qi if qi if oi qi using the product operation on bases it is easy to build other matrix operations for example multiplication can be implemented by folding over the base sets and fixpoints can be computed using an iterative loop that at each step or by repeated algorithms the two core pieces of our implementation are i an algorithm that computes automata using derivatives and ii another that checks bisimilarity of automata derivative our implementation of derivatives uses the introduced in § recall that there is one spine for every occurrence of dup in e if denotes an occurrence of dup let and r denote the left spine and right spine respectively of that occurrence it is straightforward to show that de r an occurrence of dup e or more de e · j · ir to further the computation of de we can avoid adding the r term to de when r is zero or equivalently when there exists no element of gr of the form x let be a function that replaces all occurrences of dup with as follows p p b b dup e e e e ee e · e e e it is easy to show that for any the set x ge is equal to x ge hence x gr is equivalent to x gr moreover because r does not contain dup the set x ge is described by the lefthand sequences a an in the base set representation of er hence the derivative can be described as de e · e r · j · ir where e r is obtained from er by replacing each base a an k kn with a an this formulation which is used in our implementation has a number of advantages first it is expressed entirely in terms of simple matrix operations involving the e i and j matrices second it filters away intermediate terms that do not contribute to the overall result in particular if the entry of e is then the occurrence of dup indicated by does not contribute to the first dup in any reduced string denoted by e so the derivative is also third since the of of e are of e we can calculate the once and for all when we construct the term and subsequent derivatives are guaranteed to have the form of bisimulation the other step in our netkat decision procedure tests the bisimilarity of the automata constructed using derivatives once we have the structure this algorithm is fairly standard given two netkat terms e and e we first compare the matrices ee and ee and check whether they are identical returning false immediately if they are not otherwise we calculate all derivatives of e and e and recursively check each of the resulting pairs the algorithm halts when we have tested every possible derivative reachable from the initial terms the bounds derived in § guarantee that the algorithm terminates this coinductive algorithm can be implemented in almost linear time in the combined size of the automata using the data structure optimizations to further improve performance our implementation a number of optimizations designed to reduce the overhead of representing and computing with terms bases sparse matrices etc hash and memoization encoding realworld network and configurations as netkat terms often leads to many our implementation exploits this insight by using normalization and hash so that many semantically equivalent terms are represented by the same syntactic term for instance we represent products as lists which gives multiplicative associativity for free and we represent sums as sets which gives additive associativity commutativity and idempotence for free we also use smart constructors that recognize identities involving and along with several others to further optimize the representations of terms we calculate term metadata such as and the e matrix and store the results the term itself sparse multiplication the straightforward way to represent matrix multiplication in terms of base sets would be to use nested folds over the product of two base sets is simply their pointwise this naive algorithm gives performance and much of the effort is bases whose product is always we instead implement an algorithm which rather than over all pairs of bases instead filters the sets only elements which could produce a nonzero result this is done as follows i we first build an association from assignments to their bases from the left matrix ii for each base in the right matrix we all test value sets in this base with the set of all assignments in the left matrix per field we will call the result of this operation the set of potential matches iii we multiply each base in the right matrix with the bases corresponding to its potential matches to produce the overall product these operations allow us to associate each base in the right operand with a small set of left operand bases significantly limiting the number of pairs we multiply base compaction there can be many representations of a set of complete tests and assignments and as base sets are those representations tend to grow hence another key optimization for making matrix multiplication and many other operations fast is to compact the base sets whenever possible two bases can be merged when i one is a subset of the other or ii they are adjacent in the following the base b x xn o on is a subset of base b y yn q qn when for all fields i we have xi yi and oi qi in this case b and b can be replaced with just b the base b is adjacent to b if there exists a field i such that oi qi and for all other fields j both xj yj and oj qj the result of merging these two bases is y xi yi yn q qn although both of these merging optimizations require bases with identical assignments we can efficiently reduce the number of bases we attempt to merge by sorting base sets by their assignments this yields a fast optimization that the base sets that must be maintained in our implementation fast fixpoints the algorithm for calculating the e matrix presented in § uses a fixpoint which is a potentially expensive operation our implementation several optimizations that greatly increase the efficiency of calculating this fixpoint by exploiting the structure of terms encoding networks generally speaking network terms are of the form in · p · t · p · out where in and out are edge policies that describe the packets entering and leaving the network p is a policy the describes the behavior of the switches and t encodes the topology the edge policies are typically very small compared to p or t hence we can use the edge policies to cut down the size of the p · t term as we take its fixpoint we first unfold in · p · t · p · out to in · out in · p · t · out and then find the in · p · t fixpoint by calculating in · p · t in · p · t · p · t · · · in · p · ti when we have reached a fixpoint we have determined that when in and out are relatively small this process much faster than other techniques for computing fixpoints such as repeatedly the p · t term additional applications the utility of theory is not limited to checking equivalence via bisimulation the e and d matrices are also useful for solving many other practical verification problems directly this section discusses several such applications loop freedom and translation validation host a can communicate with host a fundamental property of a network indeed there are now many automated tools that can check reachability properties involving individual locations see § for a survey is a slightly stronger property that whether every host in a network can communicate with every other host in other words tests whether a network provides the functionality of one big switch that traffic between all of its ports as only about the properties of a network it is to paths hence it can be modeled in netkat by simply setting all occurrences of dup to using from § and checking the following in · p · t · p · out sw sw switch sw · port pt · switch sw · port pt where p encodes the switch policy t encodes the topology and in the sw pt and sw pt range over all pairs that is those adjacent to a host intuitively the lefthand side of the equation encodes the forwarding behavior of the that starts from a state matching in and traverses the switch policy and topology any number of times and eventually reaches a state matching the righthand side represents a specification of a network that directly between every pair because does not involve keeping track of paths it can be verified simply by checking equality of e matrices forwarding loops a network has a forwarding loop if some packets traverse a cycle repeatedly forwarding loops are a source of error in networks and have been identified as the cause of both in networks where loops are often produced by protocols for computing broadcast spanning trees and on the where protocols such as can easily produce loops during of making worse forwarding loops are often masked by features such as fields a runtime mechanism that enforces an upper bound on the length of any loop by a counter at each and the packet when the counter reaches to check whether a packet has a loop we need to determine if there exists a packet that can reach the same location with the same value twice one possible way to express this is with the equation in · p · tn where p is the switch policy t is the topology and n is the number of complete tests which occur in the program the intuition behind this equation is that there are only n distinct packet values so any packet that traverses the network more than n times must have been in some state at least twice and thus will loop forever however while this equation is correct checking it directly is inefficient as is an expensive operation to make the problem more tractable we can it into an equivalent formulation using a quantifier prefix in · p · t · · p · t · p · t · where prefix is the prefix closure operation this equation directly encodes a packet that the same state twice allowing us to avoid an expensive operation moreover it is not hard to show that the inner term is already as it ends with a star so we can our test to in · p · t · · p · t · p · t · after converting to matrices we obtain · p · t · p · t · p · t · we then observe that for any complete test and term x we have · x · if and only if ex this yields a fast algorithm for determining loop freedom we iterate through the sets of possible and with nonzero entries in · p · t and check the entry in ep · t · p · t if it is also nonzero then the network has a loop we have used this algorithm to check for loops time to solve s time to solve s time to solve s topology term size switches largest policy parse time loop freedom translation total term size a size b loop freedom figure topology experimental results total term size c translation validation in networks with containing of switches and configurations with of forwarding rules on each switch translation validation one technique for checking the correctness of a compiler often called translation validation is to test whether the instructions it have same semantics as the programs provided as input we can use translation validation to check the netkat compiler itself which is used by the controller unlike the applications just discussed which only depend on analyzing e matrices and do not require bisimulation translation validation uses the full netkat decision procedure this is due to the fact that it must check the equivalence of the paths generated by the compiler rather than just checking forwarding we have developed a simple application that uses bisimulation to validate the output of the compiler it takes an input policy p and invokes the netkat compiler to convert it to a sequence of forwarding rules one for each switch as was shown in the original netkat paper the language is expressive enough to encode these rules so we can reflect them back into netkat terms as nested of conditionals c if pat then acts else if then else where each is a positive conjunction of tests and each is a sequence of modifications to verify equivalence we simply check whether p c · t · c where t is the topology if this succeeds we know that the forwarding rules by the compiler encode the same paths as those specified in the program evaluation to evaluate the performance of our implementation we experiments on a variety of benchmarks these experiments were designed to answer the following questions can our decision procedure effectively answer practical questions about realworld network and configurations how does its performance scale as the inputs grow in size how does its performance compare to other network verification tools benchmarks we ran experiments on the following benchmarks · topology this public contains a collection of actual network from around the world mostly for and carrier networks the range in size from nodes to over nodes we generated forwarding policies by placing hosts into the topology at random and computing paths that forward between all pairs of hosts this benchmark provides the ability to experiment with a wide variety of ranging from trees to to and even random structures · these which are commonly used in data center networks consist of a hierarchy in which the switches at each level have multiple redundant connections to switches at the next higher level we a python script to generate for a given pair of depth and parameters as well as a netkat policy that provides between hosts this benchmark provides the ability to experiment with the scalability of our tool on a commonly used topology at varying sizes · stanford this includes the node topology of the stanford network as well as the actual configurations of each this benchmark provides an example of a complete realworld network and provides a means to compare performance directly against other verification tools such as header space analysis properties our experiments focused on checking the following properties and used the applications described in § · does the network establish between all pairs of hosts · does the network have forwarding loops · translation validation does the netkat compiler translate highlevel policies into equivalent forwarding rules for the stanford benchmark to facilitate a comparison with we also performed a reachability query from a source to single destination we omitted one topology which is the largest topology and significantly larger than the topology in the depth term size of switches largest policy parse time translation loop freedom time to solve s translation validation loop freedom term size a scalability tree benchmarks translation validation loop freedom b relative performance figure experimental results methodology we ran our experiments on a small cluster of r servers with four intel cpu e processors and gb of ram running lts we restricted each experiment to run on a single core we collected running times using the unix time command for total process times and the ocaml function for times in each experiment we the time required to parse inputs and generate policies and only report the amount of time used for the actual verification task results and analysis the results of our experiments on the topology and benchmarks are depicted in figures and we the running times of the benchmarks on inputs of varying size and also provide a sampling of data points in a table all times are reported in seconds for the topology benchmark we see that our implementation is able to check small with of switches and policies with of rules on each switch in of seconds and it to with of switches and policies with of rules without difficulty the graphs in figure the running time of all three applications against the size of the netkat input term note that the use a scale to show the overall the performance of loop detection is similar to the performance of translation validation is slower taking about an order of magnitude longer on large inputs taking of for with of switches this is expected as translation validation involves invoking the full bisimulation algorithm a step not required to perform most practical verification tasks however our tool is still able to complete and produce the correct result for the benchmark we measured the scalability of our tool as the size of the network increases from a small number of nodes to several nodes the graph on the left of figure the performance of all three applications against the size of the netkat input term we observe similar scaling as for the topology benchmarks small networks complete in seconds while larger networks can take up to several the graph on the right of figure compares the performance of our three applications giving the relative running time compared to the application loop of increasing size on small inputs all three applications take roughly the same amount of time whereas on larger inputs is loop detection is about half as fast and translation validation is again half as fast for our final benchmark we compared the running time of our tool against the network tool works by doing a symbolic simulation of the space of possible packet values through the policy it numerous optimizations to the space and keep the representation compact is able to answer simple queries like reachability and loop detection involving a single host or port but it does not check full equivalence unless one performs iterated reachability queries over the entire state space nevertheless for many properties of interest is able to produce an answer in a few seconds to facilitate a comparison with we made several further improvements to our tool first we a front end to parse configurations for the stanford second we a tool to convert configurations based on ip prefix matching into policies that only test concrete ip values this tool works by computing a partitioning of the space of all possible ip addresses that respects the constants mentioned in the program and then replacing each ip prefix with the union of of the equivalence classes it includes third we developed an optimization that statically analyzes netkat policies and determines which fields are static using the netkat axioms and partial evaluation to considerably reduce the size of the search space for example if a policy matches on ip destination addresses and never modifies those addresses then for any particular address we can partially evaluate the policy to obtain a smaller policy that is specialized to that host this analysis and optimization is integrated into our algorithm for constructing netkat automata and applied automatically during the computation of fixpoints for kleene star with these our tool is able to answer a reachability query involving a single source host in seconds note that this query is evaluated on the production stanford network with and of forwarding rules in the original paper the authors report seconds for a single reachability query we were able to this number on our own since their original paper the authors have built a version of in c that can answer the same query in seconds but we were not able to this figure at the time of the writing of this paper discussion overall our experiments demonstrate that our tool for deciding netkat equivalence is able to scale to realworld network and configurations and provides good performance on many common properties although the general problem of netkat equivalence is pspace complete our implementation is still fast enough to be used for offline verification of production networks and can answer simpler questions such as reachability in well under a second making it also suitable for more dynamic situations related work netkat is the in a series of domainspecific languages for sdn programming developed as a part of the project netkat largely inherits its syntax semantics and application methodology from these earlier efforts but adds a complete deductive system and pspace decision procedure these new results in netkat build on the strong connection to earlier algebraic work in ka and kat the present paper extends work on netkat further developing the theory of the language and engineering an implementation of these ideas in an ocaml prototype the overall result is the first practical implementation for deciding netkat equivalence the theories of ka and kat and related systems have been studied extensively in recent years strong relationships between the view of systems and the view we have exploited these ideas in the development of netkat coalgebra and netkat automata finally in our implementation we have many ideas and optimizations from the implementations of ka and kat and other related systems to provide performance making automated decision feasible even in the face of pspace completeness recent work by developed symbolic techniques for constructing kat automata and deciding equivalence using diagrams bdds it would be interesting to investigate extending these techniques to netkat in the future a large number of languages for sdn programming have been proposed in recent years applies ideas from functional reactive programming to sdn programming and focuses on making it easy to express dynamic programs using signals rather than event loops and callbacks as in most other systems an interface that allows individual hosts in a network to request explicit functionality such as increased for a large transfer or bounded for a call internally uses hierarchical tables to represent and the set of requests and a compiler inspired by netcore maple provides a highlevel programming interface that enables programmers to express network programs directly in java using a special library to match and modify packet under the the maple compiler builds up representations of network traffic flows using a tree structure and then these to forwarding rules several different network programming languages based on logic programming have been proposed including and the key difference between all of these languages and the system presented in this paper is that netkat has a formal mathematical semantics along with a sound and complete deductive that supports automated reasoning about program equivalence there is a growing body of work focused on applications of formal methods ranging from lightweight testing to verification to sdn the nice tool uses a model checker and symbolic execution to find bugs in network programs written in python automatic test packet generation constructs a set of packets that provide coverage for a given configuration the sdn system uses techniques inspired by debugging to reduce bugs to minimal sequences the system uses firstorder logic and a notion of admissible to automatically check properties it uses the z smt solver as a de procedure several different systems have proposed techniques for checking network reachability properties including work by et al header space analysis and these tools either translate reachability problems into problem instances for other tools or they use custom decision procedures that extend basic satisfiability checking or simulation with domainspecific optimizations to obtain improved performance compared to these tools netkat is unique in its focus on algebraic and structure of network programs moreover as shown in the original netkat paper many properties including reachability can be reduced to equivalence conclusion this paper the theory of netkat and a new decision procedure based on bisimulation the theory includes a definition of netkat automata a variant of the derivative and a version of theorem relating terms and automata a novel aspect of the theory is the concise representation of the derivative in terms of matrices and our implementation improves on a previous naive algorithm and initial experimental results are promising in the future we intend to continue to make further and perform extensive testing on additional practical examples a straightforward extension is to incorporate algorithmic to the bisimulation construction such as upto techniques we also plan to explore extending alternative algorithms for deciding equivalence of kat expressions another possible direction is to study nondeterministic netkat automata which could provide more compact representations or algorithms for deciding equivalence we also intend to our tool in the sdn controller acknowledgments the authors wish to thank our as well as andrew myers mark and the cornell for many discussions and helpful comments our work is supported by the national security the national science foundation under grants and the of research under grant n the research foundation under project numbers and a research and a from references foster kozen and david walker netkat semantic foundations for networks in popl pages ­ january thomas ball sagiv michael and towards verifying controller programs in networks in pldi pages ­ june m jan j m m and algorithm in logic and program to kozen on the of his th pages ­ april and checking nfa equivalence with bisimulations up to congruence in popl pages ­ january thomas and deciding kleene algebras in coq logical methods in computer science ­ and on the average size of and equation automata for kat expressions in pages ­ august peter and a nice way to test applications in april chen and a approach to kleene algebra with tests in pages ­ july kozen and smith the complexity of kleene algebra with tests technical report tr computer science department cornell university july andrew d chen and an api for application control of in pages ­ august foster michael j christopher and david walker a network programming language in icfp pages ­ september mark and foster network in pldi pages ­ june john e hopcroft and richard m a linear algorithm for testing equivalence of finite automata technical report university of california min and b experience with a software defined in pages ­ august scott david r v thomas and practical repair of persistent failures in pages ­ august and header space analysis static checking for networks in april ahmed matthew and p verifying invariants in real time in april s hx n r and m the topology ieee selected areas in communications ­ october peter paul andrew li scott alan and network in in april martin min and scott a distributed control platform for production networks in pages ­ october kozen a completeness theorem for kleene algebras and the algebra of regular events information and computation ­ may kozen kleene algebra with tests transactions on programming languages and systems ­ may kozen on the theory of kleene algebra with tests technical report computing and information science cornell university march kozen and smith kleene algebra with tests completeness and decidability in csl pages ­ september m ion and declarative routing extensible routing with declarative queries in pages ­ august christopher foster and david walker a compiler and runtime system for network programming languages in popl pages ­ january christopher foster and david walker composing networks in april tim nelson andrew d michael j g and programming and reasoning for networks in april pnueli michael and translation validation in tacas pages ­ march relational algebra and kat in coq february available at symbolic algorithms for language equivalence and kleene algebra with tests in popl january to appear m and jan j m m in pages ­ january jan j m m automata and coinduction an exercise in coalgebra in concur pages ­ september jan j m m universal coalgebra a theory of systems theoretical computer science ­ scott andrew or ahmed hb and scott sdn control software with minimal sequences in pages ­ august kleene coalgebra phd thesis university of position automata for kleene algebra with tests scientific of computer science ­ m and jan j m m logical methods in computer science and paul hudak functional reactive programming of networks in pages ­ january wang y richard yang and paul hudak maple simplifying sdn programming using algorithmic policies in pages ­ august g david a g and on static reachability analysis of ip networks in march and automatic test packet generation in pages ­ december 