for dimensional type theory daniel r robert harper carnegie mellon university abstract dependent type theory conventional dependent type theory with additional structure expressing equivalence of elements of a type this structure may be employed in a variety of ways to capture rather of elements such as a universe of sets considered modulo isomorphism equivalence must be by all families of types and terms as computationally by a program type theory has applications to code reuse for dependently typed programming and to the formalization of mathematics in this paper we develop a novel formulation of a type theory which a property a closed term of boolean type is equal to true or false is a necessary condition for a computational interpretation of type theory as a programming language and does not hold for existing axiomatic of type theory the method of proof is a generalization of the semantics interpreting types as syntactic rather than equivalence relations categories and subject descriptors d programming languages formal definitions and theory f logics and meanings of programs semantics of programming languages general terms languages theory introduction a growing body of work ­ on intensional dependent type theory the latent structure given by the intensional identity type the identity type m n is the type of evidence for equivalence of the objects m and n of type a the elimination rule for the identity type ensures that type families indexed by a respect equivalence at a if f is an family of types and m n then f m and f n are isomorphic types similarly families of objects indexed by a must respect equivalence this research was in part by the national science foundation under grant number and and by the mellon center for computational the views and conclusions contained in this document are those of the author and should not be interpreted as representing the policies either expressed or implied of any the us or any other entity permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm at a mappings are functional in their domain in that application to equivalent elements yields equivalent results objects of identity type are themselves subject to higher equivalences the iterated identity type m n and so on this structure is the key to establishing surprisingly close connections between type theory category theory interpreting types as and equivalences as morphisms and theory interpreting types as topological spaces and equivalences as paths the between these is a source of much current investigation however experience with intensional type theory both as a programming formalism and as a language for formalizing mathematics suggests that the general principles of equivalence originally proposed by are too restrictive for example equivalence at function types amounts to definitional equality whereas in mathematical practice one to identify functions functions are equal iff they take equal arguments to equal results equivalence of types themselves is similarly restrictive formally this is typically considered as equivalence for members of a universe which is a type whose elements themselves determine types the standard account of equivalence for amounts to equivalence of two types are equivalent if they are written the same way however it is common mathematical practice to identify isomorphic treat two sets as when there are functions back and that compose to the identity this extensions of intensional type theory with notions of equivalence et al hofmann investigate functional axiom goes further by treating elements of as equivalent whenever the spaces they determine are weakly equivalent in the sense of theory a particular case of considered here arises when considering the universe set of extensional sets two sets are equivalent iff they are isomorphic this amounts to introducing a new canonical form g of the identity type a b given by functions f a b and g b a and evidence and their inverse relationship to one another however this represents a more significant from the traditional view of equivalence than might at first be apparent since two sets can be isomorphic in many ways isomorphism must be treated as a computationally relevant structure imposed on two sets rather than as a computationally irrelevant property of them for example the set of booleans is isomorphic to itself both by the identity function and by the negation function which the two booleans thus the type is not a proposition but has real computational content a type is one such as set whose identity type has computational content type theory has several applications in programming and formal mathematics in programming that equivalence of sets is isomorphism has the consequence that all families of types respect isomorphism for example consider the family of types where a set representing monoids on a m a a a u a assoc x y z aid m m x y z m x m y z x aid m u x x x aid m x u x a monoid consists of a multiplication operation m a unit operation u together with proofs that these satisfy the monoid laws monoid structures are useful for a parallel reduce operator which schedules computation in an arbitrary way while producing a deterministic result in current dependent type theories a programmer must show that each individual type family such as respects a b entails this is particularly for dependently typed programming where isomorphisms arise frequently from type refinements eg if the type n vectors of length n then nn is isomorphic to the type list moreover it is unnecessary as there is in fact no way to define a family that does not respect isomorphism in contrast in type theory the elimination rule for the identity type induces a monoid structure on b from a monoid structure on a and shows that these structures are isomorphic using of m n c m c n given any g a b the term g induces an isomorphism between monoid structures the same idea also has applications to the formalization of mathematics a proof assistant based on type theory supports the common informal mathematical practice of identifying isomorphic sets another application is to the formalization of theory in type theory in which types are interpreted as topological spaces and equivalences as paths in the space under this correspondence a space may be inductively defined by giving generators for its points and for its paths for example the interval i may be specified by the i and the path between them similarly the s may be specified as having say two points s and two paths a ids and b ids the structure of type theory ensures for example that a family of types indexed by a space induces an action that objects along paths in the space these definitions have already been used to formalize some basic results in algebraic topology all higher groups are the fundamental group of the is isomorphic to suggest a new typetheoretic approach towards more sophisticated problems like determining the groups of the a fundamental question that arises in type theory concerns the computational behavior of identity elimination for example when we use g to construct a function what function does it construct the answer lies in the action of the dependent type constructors as expressed by hofmann and in this example the action of sends the unit to to its image under f multiplication with f and g to transfer back and between the two algebras and uses the of to validate the laws thus from a programming the main benefit of type theory is to every type and term in the language with their actions as a generic program this allows programmers to work up to isomorphism and other such structures code reuse for dependently typed programs these programs witness the process of points along paths in spaces however this computational behavior is latent in current of type theory which extend the canonical members of the identity type without extending the computation rules for its elimination form the standard computation rule for subst says that reduces to the identity function higher dimensional types add new canonical forms of equivalence such as g but in current no new computation rules this runs of the computational interpretation of type theory which demands that the elimination forms for a type be to the forms for example the term g gets stuck even though it is welltyped in logical terms the property of of observable types fails there are closed terms of say boolean type that are neither equal to true nor equal to false a weaker notion of has been but not yet proved in this paper we define a type theory tt and prove that it does tt is based on a rather than propositional account of its structure the key is to consider a judgement of the form m a n stating that is evidence for the equivalence of m and n as objects of type a the computational content of such equivalences is made explicit by operations that ensure that families of types and objects respect equivalence function and are naturally as rules of equivalence and the induced action accounts for the computational content of the equivalence proofs as we show in section the identity type is simply as an of the equivalence judgement that is as a the elimination rule is derivable from this interpretation using the for equivalence the formulation described in section is adapted from earlier work on the directed case we require that the forms of evidence include identity m a m composition if m a n and n a p then m a p and inverse if m a n then n a m corresponding to the symmetry and transitivity properties of an equivalence relation moreover these operations must satisfy the unit associativity and inverse laws on the in the case for a a category in which all maps are invertible preservation of equivalence amounts to the requirement that families of types be in their indices if m a n and f is an family of types then f m f n is the action of f on evidence for the equivalence of indices this action must preserve identities the null action and composition the composite action and hence the reverse action tt has a simple interpretation in the category of each type is interpreted as a with objects modeling terms and maps modeling essence tt constructs a typetheoretic syntax out of the interpretation of type theory to justify that tt solves the problems with the computational interpretation of type theory we prove in section showing that a closed term of boolean type is equal to either true or false the proof may be seen as a generalization of the semantics of the type theory in turn based on method in our proof types are interpreted as rather than as equivalence relations syntax framework as discussed above we achieve in tt using a presentation of equivalence first this means that starting from the usual judgement forms of contexts ctx dependent types a type where ctx and terms identity and composition for id subst id id refl refl resp assoc resp preserves refl resp for subst identity and composition for refl trans refl refl refl inverse refl resp refl composition for a type a type ctx c type m c a type m c a a subst aid a refl m m resp m m m refl m subst for map m resp refl x m resp for map m map c refl m def map for a composition for m a m a m a m a m m a m m m subst m id m m m resp m refl resp preserves refl m m resp for subst identity and composition for m a n m a m m a m m a m m a m m a m m a m trans refl refl refl inverse refl resp resp x m m an m a n omitted rules all judgements respect equality all equality judgements are resp xf derived forms m means means x f x ab x m figure presentation of equivalence empty context · ctx is the only canonical substitution is the only canonical equivalence · · term variables ctx a type x a m a x a ctx x a mx x a m a n x mx xa nx idx a mx x mx m x a id x x idx a x x x xa id x x idx a id xx id m x m x subst m x m x resp refl x refl x resp x x sym x x resp x x trans x x resp figure contexts a type x a b type x a b type x a m b x m x a b m x a b m a m m b m x x a m x b n x x m x a b n m x a b n m a n m m n n x m n m nx m x a b xm x x refl x m x a b n x x a b x a b x x subst map x a b m resp x m x x m m m x m m n x m x x m m x m m n subst subst resp resp x x x x refl sym x x x trans x a x a resp resp figure types m x c type m c m c m x c type x m m c type true false m m m c m x m m n reflection and are canonical m n m n true j false where j is any judgement if true m m m if false m m m m n el x if n m m true false x if m map m m subst resp true true false false c m m m c m m subst subst subst true false c m m m c m m resp resp resp refl is canonical trivial by if m if m resp figure booleans as an extensional set s set set type type m n m n m n set set subst el s m m resp for set laws plus below resp for is canonical trivial by m m bool set is canonical not bool set bool in m el bool out m out in m m in out m m true false false true if s not if s not resp resp bool bool in m in m out m out m bool not not not not subst subst subst resp sym resp figure universe m a where ctx and a type we add a judgement of term equivalences m a m where ctx and a type and m m a second this equivalence judgement is defined by rules specific to each type a including equations the meaning of identity refl and composition at each type third all families of types and terms respect equivalence as expressed by the following operations x a b type m a m m b m x ab m b m x m a n x a f b resp xf f mx b f nx map expresses that a family of types indexed by a respects equivalence at a given equivalent terms m and m map determines a function from to as we discuss below this function has an inverse given by so and are isomorphic similarly resp xf expresses that a family of terms of type b where x is not free in b with a free variable x a respects equivalence at a m computes on the structure of the family b while resp xf computes on the structure of the family f there is an additional operation which expresses that equivalences themselves respect equivalence to define these operations it is helpful to consider nary families such as x a x a xn an b to this end we present tt as an explicit substitution calculus with additional judgements for substitutions where ctx and ctx and equivalences between them where ctx and ctx and the treatment of dependent types in pitts s survey article provides an introduction to this style of syntax with an explicit substitution judgement and composition principles in full generality map and resp express respect for equivalence between substitutions for a whole context and are written m and m respectively an analogous operation expresses that equivalence itself respects equivalence while and extend these to substitutions for an entire context and equivalences between them the rules for this framework are presented in figure we present the definitional equality rules as equations eg as a notational shorthand for inference rules defining typed equality judgements eg by convention each equation implicitly has premises that each of the metavariables in the equation are welltyped and maintains the invariant that the of the equation are welltyped given these assumptions showing that the two sides of the equation have the same type sometimes involves definitional equality reasoning but the equation being defined is never necessary for showing that its have the same type the first three rules define identity and composition for substitutions to improve readability we make weakening admissible rather than using de bruijn form so the identity substitution id is really the composition of the identity substitution with projections that any number of variables we write to mean that is obtained from by some number of variables all judgements of the form j are if j and then j composition of substitutions which we refer to as substitution is standard in explicit substitution calculi the additional composition operation forces substitutions to respect equivalence analogously to resp for terms above substitution instances by equivalent substitutions are equivalent for this reason we refer to it as resp the first three equations say that substitution is associative and in the second equation id can in fact be a weakening in which case is in the righthand side the third equation only makes sense when id which we by id the next two rules say that resp associates with resp which is the analogous operation for equivalences defined below and preserves identities below the next four rules define identity and composition for equivalences equivalences are always reflexive refl symmetric and transitive additionally equivalences themselves respect equivalence which we call resp the equations say that transitivity is associative with unit refl and given by resp is also associative and with unit id id by above id equals the law relates resp and transitivity transitivity followed by resp is the same as resp followed by transitivity this is a coherence requirement between the two forms of composition in a category we discuss some special cases in the extended version of this article the rule resp at to resp we do not define subst directly as this composition is definable as refl next we define the corresponding operations for dependent types terms and term equivalences a dependent type a can be with a substitution written a and has a action m which expresses that families of types respect equivalence we refer to these as subst and resp the equations say substitution into types subst is associative with unit refl map is preserving and transitivity the next two rules define subst and resp for map which the with the resp the next rule defines map for a composition again by like all contextual judgements terms are closed under substitution m and respect equivalence m because terms are dependent on the context the latter requires m by so that it in the same type as m the equality rules are analogous to those for substitutions subst is associative and and resp is associative and preserves the rules for term equivalences are analogous to the rules for equivalences specifying transitivity and resp the equations say that transitivity is associative invertible and that resp is associative and and that the order of trans and resp can be the rule uses the derived form resp described above contexts the general methodology for defining a context is to specify a formation rule for a substitution rule and a hypothesis rule for one of the other judgements eg the term rule for x for the context former x a these function as the introduction and elimination rules for the context which are products of some sort eliminated by first projections which are implicit in id and variables representing projections an equivalence rule for equations defining for for identity id subst resp refl symmetry transitivity and resp in general refl and and are defined in a typedirected manner while the principles are defined in a syntaxdirected manner giving one rule for each syntactic construct in figure we carry out this methodology for the basic contexts the empty context has a trivial substitution into it and a trivial equivalence from this substitution to itself for the equations it suffices to that these are unique for context extension if a is a type wellformed in then can be extended with a variable of type a a variable can be used as a term the typing rule checks that the variable is in the context the substitution into an extended context x a is a pair of a substitution into and a term of type a by this is analogous to the usual introduction rule for a type an equivalence between such substitutions is a pair of equivalences one between the substitutions and the other between the terms by the first component as these substitutions and equivalences are pairs the first set of rules gives the expected rules for the projections given by id and variables the next rules define the identity composition and inverse operations types in general a type is specified by a formation rule for a introduction and elimination rules for terms defining m a introduction and elimination rules for equivalences defining m a m equations defining for m for substitution a resp m substitution m resp m transitivity and resp in figure we give the rules for dependent function types the formation and term rules are standard the equivalence introduction rule says that an equivalence at can be introduced by giving a family of equivalences that work for each function rule an equivalence is eliminated by applying to equivalent arguments yielding an equivalence between the results these rules have been considered in accounts of extensional propositional equality the rules are the expected rules for functions both at the term and equivalence levels we write m nx to abbreviate m id nx substitution into a type proceeds map xa b is given by pre and subst and resp are both defined as is resp the rule for refl defines the identity at function type in terms of the identity the rules for dependent pairs which are analogous to the rules for x a are presented in the extended version booleans in figure we give rules for a base type of booleans including the usual true false and ifthenelse constructs we additionally include an ifthenelse that eliminates towards equivalences equivalences to be defined by case distinction for simplicity we specify booleans as an extensional set corresponding semantically to the discrete with two objects this means that equivalent booleans are equal reflection and any equivalence is equal to finally we include a rule that true and false are not equivalent which would otherwise require large to prove these rules illustrate that tt is compatible with treating discrete types as in extensional type theory though a more intensional treatment of booleans is also possible the rules are standard for sum types resp is trivial because is a constant family the subst rules are standard the resp rule for if uses the ifthenelse and is welltyped because of reflection the resp rule for ifthenelse is analogous no specific equations need to be given for and because of sets and elements finally we need to the type theory with a base type with nontrivial equivalences and a family of types dependent on it to ensure that we have an example where map really has computational content a simple example is to consider a universe set that contains discrete types that is each term s set will determine a type whose elements have no equivalences between them however set itself is not a discrete type because equivalence between sets s and t may be given by an isomorphism between and elt f s t gt s x f gx x x x gf x x x g s set t then g asserts that all families of types respect isomorphism of sets in figure we define a simple universe of sets we make two simplifications first the universe contains a code for exactly one set booleans second equivalences are given explicitly by the two on refl the identity function and not the approach readily to a richer universe closed under and following our previous work and to isomorphisms given by g as we show in the extended version of this article the first four rules define the type set and the family el and give reflection and for el expressing of sets in the universe the equations for subst are compositional resp for set is trivial because it is a constant family for m el s resp generates an equation m m by reflection so no equations for m are necessary the next four inference rules specify the type is isomorphic to by in and out and their rules the two equivalences bool set bool are identity and not negation map not is computationally relevant as it true and false the symmetry rule says that not is properties consistency to show that the calculus is consistent we can adapt hofmann and interpretation to our formulation of tt we have given a proof for a similar formalism for directed type theory in previous work we interpret each judgement as follows is a category is a functor is a natural transformation a is a functor a where is the large category of and functors terms and term equivalences are interpreted as dependent functors and natural transformations because the details of this proof have been covered in previous work we do not review them here as a corollary of the interpretation we get various consistency results is the discrete category on two objects so the interpretation shows that it is not the case that · true false or that · true false moreover if the calculus is extended with an empty type interpreted as the empty category the interpretation implies that not all types are we do not attempt a proof of consistency of definitional equality eg using reduction or proving consistency using these approaches typically involves giving a decision procedure for definitional equality and equality for dimensional type theory is not decidable due to the equality reflection rules for identity types discussed in in section given this we also exploit equality reflection for and though these types could be treated in a more intensional way instead our main new result in this paper is to check a kind of completeness verifying that we have not omitted any necessary definitional equations for map resp etc specifically we show that the equations of tt are sufficient to a closed term of type to a value theorem if · m then either · m true or · m false this result fails for type theory based on the axiom due to stuck applications of as illustrated in the it is currently that every closed term of boolean type may be equivalent to a value in our setting we prove the stronger result that holds for definitional equality the proof is organized as follows first we define the semantic domains into which we interpret which consist of syntactically presented and functors using the usual terminology of logical relations we say that an expression is reducible iff it is a member of these semantic domains in a simple logical relations argument open terms are reducible iff they take reducible arguments to reducible results for dimensional type theory this generalizes to both taking reducible terms to reducible terms and taking reducible equivalences to reducible analogous definitions are necessary for dependent types dependently typed terms and equivalences next we show that the semantic domains are closed under the type and prove the fundamental theorem which says that all welltyped expressions are reducible finally we obtain as a corollary theorem statement syntactically presented and functors definition a g is presented by where ctx iff the set of objects of g written ob g is a subset of the equivalence classes of substitutions · modulo definitional equality due to the of brackets in the syntax of tt we write «» for the equivalence class of the set of morphisms «» g «» is a subset of the equivalence classes of equivalences · modulo definitional equality identity at «» is given by composition of «» and «» is given by « » and the inverse of «» is given by «» note that we choose of equivalence classes at various points in this definition these uses are welldefined by the congruence laws for definitional equality we write to mean some that is presented by and use the analogous notation for the other syntactic defined below analogously we define what it means for a to be presented by a closed type definition a g is presented by a where · a type iff ob g is a subset of the equivalence classes of terms · m a modulo definitional equality the set of morphisms g is a subset of the equivalence classes of equivalences · m m modulo definitional equality identity at » is given by » composition of «» and «» is given by « » and the inverse of «» is given by «» a functor may be presented by a term with one free variable definition a functor f a b is presented by m where x a m b iff for all » ob a f » for all «» a f «» let be the category of and functors between them a functor into may be presented by a type definition a functor f is presented by a where a type iff for all «» ob f «» is presented by a for all «» «» «» f «» is presented by x a x we write a for a functor presented by a observe that all of these definitions respect definitional equality for example if g is presented by and then g is also presented by reducible expressions given these definitions we can define the invariants about each syntactic category that are by the proof definition given and define the set reducible substitutions to be those substitutions such that for all «» ob «» ob for all «» «» «» «» «» «» necessarily preserves identity and composition by the corresponding rules of definitional equality thus if then we can define a functor using the given actions on objects and arrows definition given and and define the set reducible equivalences to con those such that for all « » «» «» « » « » « » as a special case this means that for any ob « » « » this family of morphisms is natural a consequence of the law rule of definitional equality consequently if is reducible then it determines a natural we write for when the contexts are unambiguous definition given a and a functor a define the set m a reducible terms to be those terms m a such that for all «» ob » ob a «» for all «» «» «» » m » a «» » we write m a for m a when the context is unambiguous definition given m n m a define the set m n reducible equivalences to contain those m a n such that for all «» «» «» «» m » a «» » theorem statement using these definitions we are in a position to state the fundamental theorem in the remainder of this section we will define partial functions and a such that theorem fundamental theorem if ctx then is a presented by if then if then if then if a type then a is a functor presented by a if a a type then a a if m a then m m a if m a n then m n the proof is by mutual induction on the given derivations as usual the interpretation is defined in terms of semantic counterparts of each type constructor · · x a r a x a b a b const set a a these should be understood as partial functions due to the typing constraints on the semantic type as described below the fundamental theorem states that they are defined on all welltyped expressions definitions of semantic contexts and types first we give the inductive steps of the interpretation of contexts and types describing the semantic analogue of each context and type constructor for each context we define a and for each type we define a functor moreover we prove that these constructions are presented by the appropriate contexts and types the typedirected definitional equalities for refl and as well as the equations defining are used in these contexts corresponding to the empty context let · be the with one object and one identity arrow » and all compositions and defined to be » observe that this is presented by · the objects are classes of closed substitutions the morphisms of closed equivalences identity is «» is «» by and similarly for composition for context extension given and a the construction constructs a from the total cat r a to given by a projection functor p concretely we define r a so that it is presented by x a an object « is the equivalence class of a pair where «» ob and » ob a «» a morphism « « r a « is the equivalence class of a pair where «» «» «» and «» a «» identity is defined to be « r a « to verify that this is a morphism we must show that it is the equivalence class of a pair of morphisms each in the appropriate category by definitional equality so it remains to show that «» «» » refl m » a «» » for the first because is presented is a morphism in and is in fact the identity for the second refl m » » by definitional equality and because a is presented a is presented by a and therefore » is a morphism and moreover is the identity the verification of the definition of symmetry by «» «» and composition by «» «» « » is similar the equations hold because they hold for definitional equality observe that r a is presented by x a because r a is only defined when the base is presented by a context and a the equation for x a has side conditions that is presented by and that a in the proof of the fundamental theorem we show that these are satisfied for wellformed syntax types we define to be the constant functor returning the the discrete with two objects and and only identity arrows and a priori it is not necessarily the case that all terms of type are objects of this the ones that are equal to true or the fundamental theorem will show that in fact they all are to see that this is presented by we must show that for any is presented by because presented by respects definitional equality and it suffices to show that it is presented by which it conditions on and composition follow from that for any the identity functor which is the action of a constant functor is presented by x again using respect for equality by the definition of map for it suffices to show that the identity functor is presented by it is using the rules for x and x similarly we define set to be the constant functor the set with one object and two arrows and such that is the identity and the definitions of the remaining compositions are forced by the laws the verification that it is presented by set is analogous to the above for for el first observe that because is a constant functor an m m determines a functor m set thus it suffices to define a functor el set and interpret by composition for our simple universe el is defined as follows on objects take to be the discrete with two objects and for a richer universe with more type constructors this definition would be extended to analyze the other possible codes for types a functor between discrete is de by a function between their sets of objects so for morphisms take to be the identity function and to be the function that and this is welldefined because by the semantic consistency argument true false and not so we can map these equivalence classes to different results it is simple to verify that this the functor laws it remains to check that » is presented by we have two obligations for all «» ob » is presented by el m because m is reducible » is an object of set and therefore equals this means that m bool so in the syntax we can derive that el m by the substitution inside and then using congruence and transitivity the verification that is presented by is analogous to the above for all «» «» «» is presented by x due to the morphism part is trivial so we show the objects which amounts to assuming » ob » we must show that n » ob » as in the first part we know that » and » are both and that el m el m moreover because m is reducible » is a morphism in set which means that it is either or in the first case x refl x xx by resp in the second x with the semantic negation function on and by resp for el to interpret a we f g to mean functor composition we verify that when a and a is presented by a first for an object « » we must show that a « » is presented by a by respect for equality it suffices to show presentation by a by definition of « » « » ob thus by definition of a a « » is presented by a as we needed to show second for a morphism «» «» «» we must show that a «» is presented by x this follows from the equation for map for composition it to refl x finally we come to a b first we interpret closed types given a a and a functor b x a we construct a a b which is the dependent analogue of the functor category b a an object is an equivalence class « x m » where m m x a b a morphism « x m » a b « x n » is « x » where m n identity at « x m » is x m » to see that this is a morphism we have to show that it is the equivalence class of a function whose body is reducible but x m » « x » so it suffices to show that m m by definition this means that for any x a » m » » but this follows immediately from m m b which is necessary for « x m » to be an object the definitions of inverse and composition are analogous the equations hold because they hold for definitional equality observe that a b is presented by x a b next for a functor b x a its restriction to «» ob is the functor b «» x defined by b b « b b observe that b «» is presented by b xx the restriction thus corresponds to holding the part of the functor fixed at a particular object now we can define the functor a b given a and b x a a b «» a «» b «» a b «» «» «» xa b x first observe that for each «» a is presented by x a b x a b x x second we must verify that xa b x is reducible for any so that it extends to a functor observe that the converse holds if the action on morphisms of a functor c is presented by then for any x is reducible thus by the assumptions about a and b and are reducible for any by the definition of map for we have that map xa b f x refl f x by respect for equality it suffices to show that the rhs is reducible this follows from the definition of and the of and using these definitions it is simple to check the cases of the fundamental theorem for parts and for parts and in each case the inductive hypotheses satisfy the preconditions of the designated semantic construction and we have already verified that these constructions define that are appropriately syntactically presented for parts and the congruence rules hold because the interpretation is defined the equivalence relation rules hold because equality in the metalanguage is an equivalence relation the only nontrivial equations between types are the rules that commute substitution with type eg x a b x a b x x which are simple to verify for the above definitions observe that the proof does not into equations between terms because the only source of dependency is where and m automatically respects equality in m of and equivalences finally we must show that each m and is reducible in general to show that an introduction forms is reducible we will argue that is defined to be intro forms whose subterms are reducible and that the subterms will be reducible by the inductive hypotheses to show that an elimination form is reducible we will argue that tells you that it suffices to check the that the result of reduction is reducible by induction and that the form is reducible because definitional equality contains reduction to show that the operations are reducible we will observe that syntactic presentation of ensures that all closed instances of these operations exist and that using associativity laws the definition of reduces to checking closed instances we show some representative cases for m and the other cases including those for are available in the extended version equivalences between substitutions the case for refl follows from and the case for reduces to symmetry of morphisms of and using the equation which is derivable from the case for is similar using to push the compositions the case for uses resp assoc to associate while the case for uses resp assoc to associate the case for x uses the definition of resp for such pairs terms case for m on objects we must show that m » ob ob a by subst for map it suffices to show that refl m » is this follows from the inductive hypotheses for m and which show that their instances by are a morphism and object of the appropriate categories and from syntactic presentation of a which shows that is and therefore reducible the argument for morphisms is similar using resp for map case for x m on objects we must show that « x m » ob x a b «» ob a b xx by def subst this equals « x m x x » so it suffices to show that xm mx a b xx the obligations for both objects and morphisms follow from the ih m mx a b holding the part fixed at the action on morphisms is similar using « x m » « x m x » case for m m on objects we must show that m » m » ob ob b m x by the inductive hypothesis we know that » « x m » where m is reducible and that » is an appropriate object thus « x m m » m » is an object of the result the morphism part is analogous because m m m m we omit the cases for m x bool true false if in and out equivalences between terms the cases for the framework operations refl m are analogous to those for substitutions above case for x given « x » « x x » so it suffices to show that is reducible a substitution the obligation is to show that « x is a morphism this holds by the substitution and then using the ih that is reducible case for pick «» «» «» to show « » m m bn x n n by equality this » the ih gives that are reducible so xa b m » xa » » m » a » to complete the case we show that if « » is a morphism of x y and « » is a morphism of x then « » is a morphism of y the argument uses expansion analogously to the case for application above deduce that map xa b m m m m the proof uses the definition of map for of map of and the def map for a this shows that « » is a morphism of the appropriate type we omit the cases for if and not here we check that theorem is a corollary of the fundamental theorem assume · m then m so m const by definition ob · so ob but m m and so » ob by definition of this means » or » which means that m true or m false identity types in this section we show how to the notion of equivalence as an identity type m n satisfying the usual rules the rules for the identity type are presented in figure in out and the rules for them state that the of the identity type m n are exactly the equivalences m a n the reflection and rules express equivalences themselves are equivalent only if they are equal and all equivalences between equivalences are the identity these rules express strict and are an inherent source of undecidability for a strictly dimensional theory discusses this point further the resp rule expresses the action of the given by pre and out m determines a cell from a and is the first mechanism in our calculus for introducing variable equivalences because resp is determined by the structure of the equivalence being substituted into out m is stuck until m is determined remains true in the presence of the identity type interpreting m n as the surprisingly we can derive the standard j elimination rule for the identity type in traditional of map which is usually called subst does not j in tt it does because of the following properties of the presentation of equivalence it the cell structure of types using the operations refl m and our derivation of j uses unit law equations for these operations refl refl m refl refl refl m m it the identity type as the our derivation of j exploits the action which defines m n in terms of pre and it the cell structure of types as context extension x a the derivation of j uses the pairing introduction rule for xa and the definition of refl x in traditional type theory this cell structure is instead derived from the identity type which requires taking j as a primitive rule we state j in the form a type m a x a p m x c type b c id m x p n a p m n jc b p c id n x p p jc b in b and define it by jc b in m x c out px in p b as has observed j can be defined in terms of map given for any a m n p as in the premises of j an equivalence mx p x ap m x nx pp this says that any path from m with a free endpoint represented by the pair n p is to the pair m refl of m itself and the trivial path m refl can be expanded to n p by m along p here we observe that this equivalence is in fact provable by out px in p using the rules described above because we work with total substitutions we show that out px in p id mx p x ap m x id nx pp so that the b to the appropriate type the pairing introduction rule for equivalence at x a our first goal personal communication a type m n a m a n m n type in m n m m n out m m a n is canonical if is p m n q p m n q p q out in in out m m m n m n subst in m n n p resp x out p resp m in in refl in in subst resp refl is canonical trivial by out m stuck until m reduces neutral resp figure identity types is to show that id id which it clearly does next the second component of the pair must have type m a n the m by the unit law for map which out p does our final goal is to prove m x out px in refl p in fact the is equal to the righthand so gives the result this follows from the fact that m x x q in out q ie map at this type is with the derivation is in the extended version the computation rule holds because jc b refl out in in p b which by for id and the definition of refl for x a is refl b which is b by the unit law for map conversely the operations on equivalence that we have taken as primitive here map m refl can be defined in traditional type theory using the identity type m n in place of the equivalence judgement m a n as consequences of j however many of the equations on these operations hold only as equivalences rather than as definitional equalities which breaks definitional a resolution of the conjecture that intensional type theory satisfies up to equivalence is an important area of future work related work type theory is based on a typedirected definition of equivalence including extensional equality for functions and the idea of defining equality in a type directed manner is central to type theory especially as presented in relative to the main benefit of a dimensional theory is that all types respect notions of equivalence such as isomorphism of sets this generalizes where equality is computationally irrelevant a similar contrast applies to in equality is a computationally irrelevant proposition so all types are is dimensional in contrast tt accounts for computationally relevant notions of structure for example in any term by any equality proof gives a result that is equal to the original term this is not true in tt because for example not true and false which are not equal hofmann and give intensional type theory a semantics in tt can be seen as an effort to read this semantics back into the syntax the type theory with a number of new equations such as the computation rules for map and resp and the typedirected rules for equivalences they use the interpretation to justify an axiomatic account of a universe of types modulo isomorphism but this extension does not seem to hofmann various extensional concepts such as functional and types by a semantics constructed in intensional type theory this construction to better with other typetheoretic features such as large is achieved by defining definitional equality as equality of denotations hofmann does not take this approach for the model because the model cannot be defined in intensional type theory without functional an alternative to our current work would be to parallel this approach and define a interpretation into extensional type theory and thereby inherit equality from the metalanguage the benefit of the approach we take here is that it provides a more direct description of the equational theory presenting it directly in terms of the source language studies a theory ml and shows it sound and complete for a class of categories ml introduced the identity types with reflection and for identity types only which we adopted in section it additionally included some new computation rules for types which in our notation would be written xa b x x and x m xa b n mx however it did not include eg the typedirected rules for map and thus would not in the presence of something like in future work we may consider identifying a class of that is sound and complete for tt axiom intensional type theory with full equivalence which includes isomorphism for sets equivalence for categories and so on however the axiomatic account does not satisfy for definitional equality that every closed term of type nat is equivalent using to one that does not use the axiom and therefore to a by for the base theory however this conjecture has not yet been proved and our work suggests an approach to it as we discuss below moreover that this can be computed which is not something we have yet established here our presentation here is based on our previous work on a dimensional directed type theory which generalizes equivalence to an asymmetric notion of transformation our presentation here avoids some of the of like the need to account for of type constructors but on the other hand shows that the style can account for symmetry the proof of and the derivation of identity types are novel to the present work we conjecture that our proof of could be applied to as well in concurrent work de and de have also developed a type theory with a notion of equivalence which has explicit evidence with a structure and which is by the identity type their type theory is weaker in the sense in that every equation is part of like rules which we treat as equalities however there is no account of a base type nor a claim of a number of equations on equivalences are oriented as rewrite rules which are proved terminating and confluent but it is what equational theory this interestingly fc the calculus used as an intermediate language in the haskell compiler ghc has some to tt while there are no types in fc type equalities are by explicit coercions written in programs using a construct similar to map and the class of coercions is closed under the category operations considered here such as refl and moreover ghc includes a coercion simplification algorithm whose purpose is to reduce the size of coercion terms which exploits many of the equations on these category operations an interesting application of tt would be to analyze this coercion simplification algorithm by translating its reductions into tt equations which might suggest some additional coercion reductions other related work concerns categorical or semantics of pure intensional type theory on the side and show how to interpret intensional type theory into abstract theory ie model categories and van and show that the syntax of intensional type theory forms a weak category and and shows that identity types admit a weak system conclusion we have presented a novel formulation of dimensional type theory tt based on a account of structure this account the structure of types and the actions of families tt a property for closed terms of observable type which we have proved by a style argument in which types are interpreted as rather than as equivalence relations the identity type can be defined by this notion of equivalence and the suffices to derive its standard elimination rule one direction for future work is to the theorem to state that · m bool evaluates to true or to false using a deterministic operational semantics the result given here leaves open the possibility that the derivation of m true or m false proceeds by a rule such as the various principles or an instance of equality reflection the consistency of the equational theory suggests that such a cannot be essential and hence only the like rules including those for map and resp are relevant to a possible to this result would be to define the interpretation in extensional type theory and then prove a computational adequacy theorem for this interpretation to obtain the result another direction for future work is to investigate for the many possible variations on tt for example we may extend tt with standard features in current proof such as inductive types another possible extension is an impredicative universe a third possibility is to consider directed type theory which has applications to generic programming with abstract syntax and directed theory more we may consider an extension to a fully dependent type theory for which remains an open problem by analogy with our formulation which the structure of a type we would present the syntax in such a way that it the weak structure of a type however an to this generalization is the complexity of the proposed definitions of weak and their adaptation to the typetheoretic setting acknowledgments we thank peter gordon plotkin and the anonymous reviewers for helpful about this work and feedback on this article references type theory web site t extensional equality in intensional type theory in ieee symposium on logic in computer science t c and w observational equality now in programming languages meets program verification work s and m theoretic models of identity types mathematical proceedings of the cambridge society r l s f allen h m w r j f r w harper d j t b n p p j t and s f smith implementing with the proof development system prentice hall r j g b de and a g de propositional equality identity types and direct computational paths july p and a normalization and partial evaluation in applied semantics international school volume of lecture notes in computer science pages ­ springerverlag september n and r the identity type weak system theoretical computer science ­ r models of type theory mathematical structures in computer science ­ m hofmann extensional concepts in intensional type theory phd thesis university of edinburgh m hofmann syntax and semantics of dependent types in semantics and logics of computation pages ­ cambridge university press m hofmann and t the interpretation of type theory in years of constructive type theory oxford uni press d r and r for dimensional type theory extended version technical report carnegie mellon university d r and r harper dimensional directed type theory in mathematical foundations of programming semantics p l weak categories from intensional type theory in international conference on typed lambda calculi and applications p an intuitionistic theory of types predicative part in h and j editors logic colloquium proceed of the logic colloquium volume of studies in logic and the foundations of mathematics pages ­ p constructive mathematics and computer programming transactions of the society of london series a mathematical and physical sciences ­ b k and j smith programming in martin type theory an introduction press c extraction de le des constructions phd thesis paris a m pitts categorical logic in s abramsky d m and t s e editors of logic in computer science volume algebraic and logical structures chapter pages ­ oxford university press m m m t s p jones and k system f with type equality coercions in acm workshop on types in language design and appendix at b van and r types are weak available from v foundations of mathematics talk at th workshop on logic language information and computation m a theoretic aspects of constructive type theory phd thesis carnegie mellon university 