fully abstract compilation to javascript fournet chen benjamin microsoft research and fournet abstract many tools allow programmers to develop applications in highlevel languages and them in web via compilation to javascript while practical and widely used these compilers are ad hoc no guarantee is provided on their correctness for whole programs nor their security for programs executed within arbitrary javascript contexts this paper presents a compiler with such guarantees we compile an mllike language with higherorder functions and references to javascript while preserving all source program properties relying on typebased invariants and applicative bisimilarity we show full abstraction two programs are equivalent in all source contexts if and only if their wrapped translations are equivalent in all javascript contexts we evaluate our compiler on sample programs including a series of secure libraries categories and subject descriptors d software program verification validation d processors compilers d operating systems security and keywords program equivalence full abstraction refinement types introduction many tools allow programmers to develop applications in highlevel languages and them in web via compilation to javascript these include compilers like for java and for f and dart as well as several academic efforts like links cooper et al and et al while practical and in some cases widely used these compilers are ad hoc no guarantee is provided on their correctness for whole programs nor their security for programs executed within arbitrary javascript contexts the lack of security against javascript contexts is of particular concern since compiled code is linked with libraries directly in javascript libraries like and prototype are widely used provide improved support for several core tasks but do so by making use of highly dynamic features of javascript eg by properties of objects less wellknown libraries are also included in pages often by simply including a pointer to the code from a potentially url it is also common practice to include rich content eg scripts in the same context as trusted javascript code in all those cases linking with a malicious or script can easily break invariants of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm f source f context formal light translation wrappers js context javascript informal light translation wrappers javascript context semantics via extended js figure architecture compiled code its security and in general any reasoning principles of the source programming language to the javascript code that is actually executed this paper presents a correct and secure compiler from a variant of ml with higherorder functions and references to javascript our main result is full abstraction two programs are equivalent in all source contexts if and only if their translations are equivalent in all javascript contexts full abstraction is an ideal compiler property as it enables local reasoning on source code without the need to understand the details of the compiler or the target platform in our case programmers can rely on their experience with ml with static and types or trust verification largely ignore the rather semantics of javascript which semantics for javascript compared to ml the semantics of javascript is there are several different standards and various implementations mainly by web that from the standard in ways et al give an operational semantics for the standard which while extremely detailed is also in that it is not easily amenable to formal proof or to testing an alternative approach is to give a semantics via translation to a simpler language and then to test this translation semantics for with browser implementations this is the approach of et al who give a translation of javascript into a mostly standard dynamically typed lambda calculus called js the translation semantics is convenient for our purposes eg it is executable and not necessarily less precise or more complex so following js we give a semantics to javascript by elaboration to f et al a variant of ml with richer types we intend this semantics to capture the main features of the standard including features like and that were missing in js our semantics also includes a number of experimental to features of javascript such as the arguments caller and callee properties a highlevel view of the paper figure our technical development on the left we have f a subset of f that includes higherorder functions mutable references exceptions and errors but polymorphism for simplicity its semantics is parameterized by a type signature that defines the basic constants available to a program on the right we have concrete javascript our compiler takes an f program with an arbitrary signature and javascript syntax in two phases the first phase the light translation is compositional and translates f constructs to the corresponding ones in javascript eg function closures to function closures yielding for code meant to be executed in untrusted javascript contexts we the light translation with carefully wrappers to import and export values at every source type while preserving the translation invariant to reason formally about our compiler we reflect its output within an arbitrary javascript context back into f specifically we employ a variant of the js semantics to translate javascript to js an instance of f with a signature that provides runtime support for js programs our proof of full abstraction relies on refinement typing to establish several key invariants of the translation for this typing we introduce a precise typed model of expressed using monadic refinement types in f then we develop a new variant of applicative bisimilarity for contextual equivalence in f and use it to show the main result of the paper ie that two f programs are equivalent with respect to an arbitrary f context if and only if their wrapped light translations are equivalent with respect to an arbitrary js context we summarize our main contributions below · we describe a compiler from f § to javascript including wrappers to safely interactions between translated programs and their context § · we introduce js a model of javascript within f that includes features of and popular javascript implementations § · we formalize our compiler as a translation from f to js we show that it is a forward simulation that preserves a typing and heap invariant this yields safety and correctness for translations of closed programs executed in isolation additionally by typing we show that the wrappers support safely values of various types with an untrusted context § · we develop a new coinductive proof technique for f with labeled bisimulations to capture the interactions of configurations of related terms with their abstract context such that bisimilarity coincides with contextual equivalence § · we prove our compiler from f to js fully abstract § · we close with a brief discussion and experimental evaluation of our compiler implementation § as usual full abstraction holds only within our formal semantics of javascript and various side channels may still exist in javascript implementations based for instance on stack or heap or timing analysis this presentation necessarily many details additional including a technical report with the full formal development an f implementation with a javascript sample source and compiled programs and an updated f theory in coq are available at related work programming language abstractions have long been recognized as an essential means for protection morris their secure implementations are often specified as full abstraction abadi abadi et al abadi and plotkin et al conversely many attacks can be interpreted as failures of abstraction and several counterexamples to full abstraction exist for example mitchell notes that lisp with has no abstraction contexts and kennedy points out the lack of full abstraction in translations from c to net many powerful coinductive techniques exist for program equivalence with various combinations of types higherorder functions private mutable state and exceptions and pierce as discussed in § ours combines their features so that bisimulations precisely capture the invariants of wrapped translation within untrusted javascript contexts although logical relations instead of bisimulations ahmed and also use typedirected wrappers to prove that typed closure conversion in the polymorphic calculus is fully abstract however unlike us they do not use the wrappers in the translation itself there has been recent work on javascript programs from malicious contexts for example et al apply a dataflow analysis to check that programs in a subset of s strict mode and do not leak private data to an adversary using this analysis the authors were able to prove the safety of idioms used by the framework that rewrites javascript applications to objects such as the dom behind object capabilities this property is related to the invariant enforced by our wrappers which we check by typing et al however do not deal with full abstraction challenges in secure javascript programming to illustrate the difficulty of writing secure javascript code we implement a protection mechanism around a trusted external function for messages to some target domain figure by calling we should obtain a function that enforce the following policy · send messages only to to avoid privacy leaks of at most characters to bound resource usage that includes a secret to identify the service users · do not leak the function or the secret to prevent our protection mechanism our implementation calls a function provided by some other trusted library as typical in javascript linking is performed dynamically through the global for simplicity we use our mechanism to protect an anonymous function that the message and its target on the the resulting protected send function is exported to the global and therefore made available to untrusted scripts send target msg msg to target in isolation our code seems to enforce our policy however we are going to demonstrate how by carefully manipulating the context a malicious script can our protection mechanism we do not claim any in describing these attacks et al and with these examples we aim at giving our reader a at the challenges met by javascript programmers as well as the ground for our wrappers in § attack global objects objects from the global is by definition every script has access to this for instance a script can the function right before calling the send operation function return msg too long to prevent this attack we must run before any script and store a private copy of as well as any other trusted library function it may call function var function msg msg msg if else return function return figure naive implementation of a secure send attack dynamic source code inspection hiding in source code is to be avoided that we to keep the secret a malicious script can use the method on the function to its content var targets targets s return a regular expression matching on the resulting string lets us extract the list of valid targets this is not as such a violation of the specification yet it is a rather feature attack object since javascript is a programming language one can dynamically modify properties of any object in the system in particular one can add a field to the prototype of the canonical object object hence extending the white list without even referring to itself true to this attack we must ensure that any given field is indeed part of the object and not inherited from its prototype chain to this end we could use a safe private copy obtained by starting first of the method attack implicit coercions part of the complexity of javascript comes from its treatment of coercions should the need arise objects are automatically at runtime instead of a string one can for instance pass an object with a method that returns a string in the on the first use and another string as the actual send operation is performed var count var target function return count msg to these implicit coercions we may explicitly check that the input arguments are of the correct type using the typeof operator alternatively we may force a coercion upon receiving the arguments and store the is the case for msg in figure attack the call stack finally outside standards most implementations of the function object provide a caller property that points to the current caller of the function being executed this mechanism any callback such as an implicit coercion or a grants access to the arguments of its caller including msg after concatenation with var c var target function c return msg this code enables one to the by matching the msg argument similarly one could any secret on the call stack to guard against this attack we must explicitly clear the caller field of our functions before any potential callback our proposal the examples above show that local reasoning about code in javascript can be through a variety of attacks hence writing secure code in javascript is a one must take a great deal of attack vectors into account and one ends up maintaining extremely programs which makes them more we propose that programmers instead use a source language with static types and to write code a compiler should then translate the source language to javascript the programmer from about the subtle semantics of javascript in this context ml appears to be a particularly effective source language it has static types and it is functional so we can rely on closures and higherorder functions also available in javascript and being impure we can adopt a programming style that approaches javascript in ml the example of figure can be written as shown below which clearly meets the stated security goals let let in fun target msg let msg secret msg in if mem target then target msg else rejected syntax and semantics of f in this paper we use f a fragment of f et al similar to ml with the syntax shown below and a standard smallstep value semantics see the full paper we have extended the original presentation and formal development of f with exceptions errors and primitive support for a mutable store values range over variables memory locations abstraction over terms and nary fully applied data constructors we add a form of results r which in addition to values includes exceptions raise v and error expressions are in a partial normal form with for instance function application e v requiring the argument to be a value we also have pattern matching reference allocation assignment and dereference and exception handlers syntax of f v x d values r v raise v error results e r e v let x e in e v v ref v v try e with xe match v with d ¯ x¯ e else e terms t t ref t t t types h · t v h h store f f v f t let x f in e exn ctx e e v e t let x e in e try e with xe eval ctx s · dt t s s signature · xt t type env an f runtime state written h e is a pair of a store mapping locations to values and a program expression the reduction relation has the form h e s h e where the index s is a fixed inductive signature that defines all constructors this signature includes at least a type exn for exceptions types ref t for references and unit we also freely use common primitive types like int and bool and expect these to be in the signature as well our syntax does not include a fixpoint form because recursion can be encoded with recursive datatypes in the signature we consider several instantiations of the signature s in this paper to define our source language § and to embed dynamically typed javascript within f § syntactic sugar we write applications e e as abbreviations of let x e in e x for some fresh x a similar transformation applies to pattern matching reference operations exception raising etc we write if e then e else e for match e with true e else e and e e for let e in e additionally in code we rely on the concrete syntax of f which closely ocaml and f plain types f includes various dependent typing features but we ignore this in f and restrict the types to a monomorphic subset of ml including function types t t references and recursive datatypes nevertheless we have extended our metatheory of the full f language to include exceptions state and errors and proved subject reduction for the reduction of open terms ie terms that may contain free variables which is used in § and § we present a specialized version of this theorem below where we use the type judgment for f runtime states this is written here as s h e t denoting that in an environment including the signature s free variables and the typed domain of h written h including t for each t v in h the store h is welltyped and the expression e has type t when the signature s is evident from the context we simply write h e t theorem type soundness for reduction given s h e and t such that s h e t either e is a result or e is an open redex ie e ex v x with ex v ex or there exist h e such that h e s h e and s h e t contextual equivalence we only observe welltyped terms and compare them at the same plain types following theorem we define basic observations on runtime states s s returns that is s s h r with three kinds of results any value written s any exception written s raise or an error written s error or s diverges written s when it has an infinite sequence of reductions or only in case s is open s reduces to a redex with a free variable in evaluation context we define contextual equivalence for closed values and expressions considering all typed evaluation contexts equivalence between open terms can be using closed function values definition contextual equivalence two closed typed runtime states s and s have the same behavior written s s when they either both return the same kind of result or both diverge two closed typed terms are equivalent written e e e when they have the same behavior in all evaluation contexts a compiler from f to javascript we present our compiler from f to javascript using the f program below as a running example let let log ref nil list string in let add x log cons x log in let iter f f log in add iter calls to return an abstract interface to a log with functions add and iter to extend the log with a string and to operate on its contents respectively reasoning in f it is clear for instance that the log only contains strings and that it grows in this section we illustrate informally how our compiler ensures that all source invariants are preserved in the translation to javascript in subsequent sections we justify it by formalizing our compiler as a translation from f to js and proving it fully abstract the light translation our compiler proceeds in two phases the first phase is compositional and purely syntaxdirected the translation function e shown in figure translates f constructs to their javascript counterparts following standard practice we assume uniqueness of variable names we also use an auxiliary function that collects the let and names not within additional s of expression e we translate functions in f to functions in javascript as follows local variable declarations in javascript always occur at the top of a function body so we collect the source and declare them when reading a variable x the second rule we simply lookup the javascript variable with the same name x in the third rule we translate to javascript sequence expres e where y¯ x x let x e in e x e e e v e v d d str i vi ref v ref v v v v ref v undefined v v ref error match v with d x¯ e else e v tag str v str i e e figure light translation from f to javascript sions javascript this expression evaluates e assigns the result to x and then evaluates e function application is straightforward we translate data values d v vn to objects with a tag field recording the name of the constructor as a string and with fields str n containing the translations of the str encodes its argument as a javascript string references have a single field ref when assigning a reference we update the ref field and then evaluate to undefined our representation of the unit value in javascript we model error in javascript by calling the function which up a in most browser other possibilities exist for modeling errors finally we translate matching to javascript conditional expressions observe that the only statement forms we use are within functions where we use var declarations and return by relying only on the expression forms of javascript we obtain a simple compositional translation for simplicity the input of the translation does not contain exceptions and their handlers but we still study their properties for all f evaluation contexts including exceptions technically we also require that f does not have ref unit and similar types whose values are all contextually equivalent in f but whose translations may be distinguished in javascript using untyped equality finally we do not formalize the translation of polymorphic data constructors although they are supported by our compiler implementation at top level our formalization applies to the translation of programs within a function our implementation this with simple handling for toplevel running this on the declaration of we obtain the following javascript where refers to the translation of the f function function u var log var add var iter return return x undefined return add iter typedirected wrappers providing a javascript context with direct access to is not fully abstract an adversary could for example call obtain iter and then call it with a function f that as in attack of § the stack accesses log directly from the arguments of and breaks its invariants to protect our code we apply typedirected wrappers that build a between the translated f code and its context our wrappers are javascript functions indexed by source types t they come in pairs a down wrapper written t takes a light translation of a source value vt and exports it safely to the context an up wrapper written t takes any javascript value supplied by the context and attempts to extract from it a value that is a light translation of some source vt this may fail in addition to ensuring that the translated f code and its context interact at the expected types the wrappers to enforce a strict heap separation between the code and the context specifically we function return x function return undefined function return x function return z true false function return x function return x function return function p return function return return function return function f return function z return f function return function f return function x var z x var y undefined function stub undefined undefined y stub return y figure selected wrappers in javascript ensure that the context never obtains a direct reference to an object that is used by the light translation references from f objects to objects owned by the context we call such objects untrusted or un objects are also problematic since the contents of un objects are eg they may change so access to f objects by the attacker and vice versa are by wrappers figure lists some wrappers used by our compiler for immutable base types shared between f and javascript such as strings the down wrapper does nothing whereas the up wrapper forces a coercion there are various javascript idioms that serve to induce coercions at particular types eg for booleans we use an explicit conditional expression for numbers we use unary addition for strings we with the empty string etc this ensures for instance that true and false are indeed the only imported boolean values problems like attack from § for datatypes such as pairs and lists and any allocated data we must ensure that preserves heap separation thus we allocate a fresh representation and recursively wrap their contents the up wrapper is safe even as its code accesses fields which may trigger callbacks to the context via implicit coercions or because the imported content is kept as a local value on the up wrapper stack our code includes wrapper generators for instance takes as parameter two down wrappers for types a and b and returns a down wrapper for pairs containing an a and a b for functions the situation is more complex since the up wrapper has no way to check that its argument is the valid representation of a source f function instead the is deferred the function corresponding to a b exports a function f by it with another function that first the argument x then applies f and finally exports the result in the other direction one might have expected for a b to be strictly dual to a b ie export the argument apply the function and import the result however this is as attack of § illustrates the javascript calling convention provides a function with access to the function object and arguments of its caller if a trusted function were to call an untrusted one directly the latter obtains a reference to the arguments of the former our heap separation discipline to this end following the code of in figure the wrapper for an untrusted function f the translation of an a b value is itself a function from any trusted context that first exports its argument into a local variable z then calls a fresh stub the stub makes the call to f on of the trusted code but before doing so it its own caller and arguments object when the call to f proceeds the context obtains a reference to the stub but cannot the stack beyond the stub and trusted code after the untrusted call completes up the result and stores it in y returning f up stub the value directly is since the attacker has a pointer to the stub closure so it may be able to call this closure later and receive the protected value after the stub completes the wrapper returns the contents of un down f the local variable y thus to an attacker that attempts up to traverse the call stack via the properties the stack growing downward appears as depicted upward stub objects stub un regions of the stack that transition from untrusted to trusted code additionally the up and down wrappers all calls across trust boundaries toplevel translation with our example we list below the script that makes available to an arbitrary javascript context after suitable rather than placing directly into the global ie the window object in a web browser our compiler generates a function init that takes the window object as a parameter defines the translated code of in a local variable and exports it to after unfolding and applying the unit string unit string unit unit after running our script init to prevent any later use such as function function light translation shown above and we briefly review potential to full abstraction and informally discuss how we handle them · modifying can the default behavior of objects eg when accessing their properties as an invariant translated f code never a prototype chain traversal so our translation does not depend on · by changing an adversary can code at function calls however states that this does not affect primitive function calls · returns the static source of a function closure as a string our wrappers ensure that for any function g to the adversary always returns the text of its down wrapper that is the constant string function z return f · implicit coercions are by systematically forcing coercions in up wrappers · stack via callee and caller properties are by the stub mechanism described above · some provide new which the current stack as a string assuming that our code runs first we it in the init function using the code below var var return x are these sufficient the rest of the paper with the main results of § provide a positive answer at least within our semantics of javascript a semantics of javascript in f we begin our formal development with a semantics of javascript by translation to js the instance of f with inductive signature described below this allows us to carry out our argument entirely within a single language we base our semantics on js a dynamically typed language to which et al translate javascript we extend js to include some features of that were missing in the original formulation which as well as features that are relevant for full abstraction concurrently et al have extended js to cover the strict mode of we focus on a few main features of js dynamic typing object properties function creation the calling convention control operators and eval we refer to our technical report for a complete presentation including a formal translation from js to js dynamic typing in order to type any javascript values defines dyn a standard type dynamic as follows type dyn null dyn undef dyn bool bool dyn str string dyn num float dyn obj loc dyn fun dyn dyn dyn dyn dyn and obj list string property and loc ref obj and property data dyn property dyn dyn property type exn break int dyn exn exn dyn exn return dyn exn the type dyn has a constructor for each javascript primitive type for instance the javascript string literal is represented as str dyn objects are references to maps from string property names to property the type of values or and their property attributes specify for instance whether they are or enumerable our translation does not rely on attributes for security and are treated as functions called to perform property or assignments functions in javascript are also may set properties on them writing for instance function foo to handle this we represent javascript functions as js values fun o f constructed from a function object and a closure f all functions in javascript receive an implicit this parameter and following js a single argument object with a field for each of their explicit arguments thus the closure f within fun o f has type dyn dyn dyn we discuss the three kinds of exceptions function creation and application while outside the specification most implement a in their calling convention functions f receive their variable number of arguments in single arguments objects these objects include a callee field that points to the function object of f conversely function objects include an arguments field that points back to the argument object of their last activation if any and a caller field that points back to the function object of their last caller this field may point to f itself if it makes recursive calls or be null for toplevel calls these fields are implicitly updated at every call in particular all javascript functions are recursive through the store since they are given access to their own object to model this calling convention defines several operations first a lookup function looks up the property name f in the map of an object for function values as well let lookup match d with obj loc fun obj loc assoc f loc none similarly a modify function updates properties within object maps in this section we use for these functions e f match lookup e f with x x undef e f e modify e f e to allocate functions defines as follows let code dyn dyn dyn dyn let o alloc in let f fun o code o in f str s f for instance we formally translate function x return x to fun o this args select o args where the first argument is a string literal that represents the source text of the function and the second argument is a js closure that receives three objects the function object o the this parameter and the actual arguments the call to allocates o partially applies the closure to o and sets various properties on o before returning f to call functions provides apply which receives four arguments caller the object of the calling function callee the function to be called a this pointer and an args object let apply dyn match callee with fun o f let caller in let args in try args callee f this args with break error e raise e finally caller args following the code apply calls f with argument this and args first however it the caller and arguments fields sets these fields for the current call and sets a pointer from args to callee conversely once the call returns apply the fields to their old value the derived f form try with finally detailed below ensures that the fields are even if the call raises an exception this reflects major browser implementations of javascript property access in javascript properties of objects are up first in the objects own property map then in the objects prototype stored in a special property proto the prototype chain as needed once found if the property happens to be a then the function is called otherwise its value is returned this is implemented by the select function shown below since calling the requires passing a caller object we write select caller l f to select field f from object l in the context of the function object caller recall that the translation of our example function included a call to select passing its object o as a parameter let rec match lookup l f with some p some p none match lookup l proto with some data l l f none none let select dyn match l f with g apply caller g l d d undef a similar function update caller l f v sets property f on object l to value v this function traverses the prototype chain looking for a for property f if a is found update calls it with caller and v otherwise it calls modify l f v exceptions and control operators we model exceptions and the other imperative control operators of javascript using f exceptions javascript has a return statement to end the current call and a break l statement to return control to the code location labeled l which must be defined within the same function body js both to a single form which we represent as the exception break l v additionally we use exceptions exn v for javascript exceptions and return v to encode finally clauses as follows try e with e finally e try try e with e finally e try e finally e try raise return e with y match y with return r e r e raise y dynamic evaluation does not support eval as this would involve parsing translating and loading js code at run time on the other hand js contexts can implement any primitive function eval using the datatypes of together with any values they obtain by interacting with our wrapped translation as such our result applies also to contexts that use eval typability we conclude this section with a simple result every js program translated to js is welltyped against in the statement below e is the translation of a js expression to js theorem typability of js translation for all js programs e with free variables x we have e dyn contextual equivalence in javascript discussion after translation to js we formally compare javascript programs using the contextual equivalence of § definition this equivalence relies on the observation of errors which are not primitive in javascript but informally account for any code with an immediate observable effect such as or this equivalence in js is also a priori than javascript equivalence as it over all welltyped js contexts not just those obtained by translating javascript contexts thus we err on the safe side most of our results would apply unchanged for variants and extensions of as long as its signature is unchanged for instance to model additional features of javascript implementations conversely § shows that translations of javascript contexts are complete at least for interacting with wrapped translated f programs a typepreserving simulation from f to js formally our compiler can be viewed as the translation from f to javascript § composed with the embedding of javascript into js § in this light its correctness is far from obvious for example even though we translate f functions to javascript functions several corner cases of their semantics the surface syntax as we have seen functional values translate to expressions that allocate several objects and are subject to a calling convention with sideeffects this section proves several safety properties for the compiler in order to carry out these proofs we use an alternative monadic type system for f due to and as well as an application of this type system to javascript provided by et al specifically we use a variant of with refined types that allows us to state and prove precise typing and heap invariants of js programs using this machinery we prove that the light translation preserves types and is a weak forward simulation additionally we prove that the wrappers successfully maintain several key invariants including separating un objects from the others while useful in their own right for whole programs eg we can prove that when a source f program has no assertion failures then neither does its translation these properties serve primarily as lemmas that facilitate the main results of § monadic f the type system of monadic f is based on a monad of predicate transformers called the dijkstra state monad the type of this monad is written dst t wp and stands for stateful computations yielding a t result and with specification described by the weakest precondition predicate transformer wp the transformer wp takes a postcondition formula post relating a result of type t and a final heap and returns a precondition formula pre a predicate on an initial heap given a program e dst t wp and a particular postcondition post to be proven the f type checker syntax of types in monadic f t t a t t xt at xt t xt dst t types ¬ xt xt formulas p xt a u e xt kinds u v t v v e v err sel u u upd u u u u u logic term builds a verification condition wp post and uses z an smt solver de and to try to the proof we give the syntax of monadic f types above as in § the type language is parameterized by a signature s that also defines a set of type constructors t types include variables a type applications t t refinement types xt and polymorphic types at data constructors are nary and are given pure dependent function types t general function types have the form xt dst t with a monadic codomain dependent on the arguments xt formulas include the usual connectives implication is written distinguishing it from the kind constructor discussed below predicates p may be interpreted eg equality although uninterpreted predicates can be introduced by the signature s formulas also include a strongly normalizing applicative language of functions over logical terms and other predicates we write xt and a for predicate literals or in the latter case for transformers from a predicate or type a of kind to formulas can be applied to other formulas or to logical terms u the type system is parametric in the logic used to interpret formulas by default we use a firstorder logic with uninterpreted functions and theories of functional arrays arithmetic datatypes and equality for example we use type heap and interpreted functions sel heap ref and upd heap ref heap from the theory of functional arrays to model the store logic terms also include three kinds of result constructors v v is a result value e v is an result and err is the error value we define v v v raise v e v and error e additionally we write result r as an abbreviation that x is valid when r v x we have two base kinds is the kind given to value types while e is the kind of types that stand for specifications with the relation e we include dependent function kinds both from types to kinds and from kinds to kinds in most cases unless we feel it adds clarity we omit writing kinds the main judgments in the monadic type system are s d v t for values and s d e dst t for expressions they rely on an auxiliary judgment s stating that formula is derivable from the logical refinements of context for example we can type the program x as int dst unit post v upd h x sel h x this is the type of a function from integer references x to unit where the weakest precondition for any predicate post relating a unit result to the output heap is the formula post v upd h sel h x indicating that the function always returns normally with and updates the input heap h with the contents of location x the judgments for typing terms extend naturally to a judgment on runtime states written s d h e dst t the soundness theorem for monadic f is a refinement of theorem it also applies to open reductions in its statement below we rely on a function that a store h as a value of type heap theorem monadic soundness given s h e t such that s d h e dst t and a postcondition such that s h is derivable either e is a result and s e h e is an open redex or there exist h e such that h e s h e s d h e dst t and s h we sometimes use a monad an abbreviation for the dst monad augmented with a heap invariant t wp is the type of a computation that when run with an input heap h satisfying h wp post h diverges or produces an output heap h and result rt satisfying h h h post r h we describe the heap invariants enforced by below referring to our online material for the full definitions a precise typed model of we now present a few key elements in an interface for written using the precise types of monadic f we start by showing how we recover the precision of the source type system by refining the type dyn introduced in § a central feature of this refinement is model of a partitioned js heap we conclude this subsection with a lemma relating to dynamic typing we structure our formal development by translating the types of f into logical formulas specifically we use a refinement of type dynamic developed by et al to embed the simple type language of f within the refinement logic of monadic f for example rather than typing str simply as dyn we type it as x string where typeof is an uninterpreted function from values to types we show a few cases in the definition of type dyn used in below the full listing of is available online type dyn str string obj l fun wp l l dyn wp o args this wp as in an object is a value obj l for some heap reference in addition the refinement on the obj constructor the refinement on the underlying loc the fun constructor takes two value arguments an object o and a function closure as before in addition it now takes a argument a predicate transformer wp for the function closure the refinement on the argument o requires it to be an object in addition to some other properties which we from this presentation the function closure is itself typed within the monad with weakest precondition wp the type of fun the predicate transformer of the closure in its result type ie typeof wp where wp is a typelevel coercion from the kind of wp to e invariants of a partitioned heap our proof strategy involves the type of heap references to keep track of a logical partition of the js heap into five this partition allows us to prove several invariants eg that there are no references from objects in the part of the heap to elsewhere these five heap are as follows inv the invariant heap variables arguments and data are immutable in f but are held in heap locations in js to keep track of these locations we place them in a logical called the inv heap a that we handle is that these locations are not strictly forces us to requiring a mutation after allocation and the calling convention also involves implicit effects still we prove that once set all the relevant fields of objects in the inv heap never change ref the heap of source references locations used to represent the translation of f values of type ref t are placed in the ref heap where an invariant ensures that the content of a ref heap cell once initialized always holds a translation of a source value abs the abstract heap of function objects recall that every function in js is associated with a object whose contents is updated at every function call we place these locations in the abs heap and ensure that translated source programs never read or write from these locations ie function objects are abstract un the untrusted heap this heap is used to model locations under control of the attacker our result relies on a strict heap separation to ensure that locations from the other never leak into the un heap with one exception discussed next stub the heap of function objects function objects corresponding to in the wrapper are allocated in a of their own these objects initially belong to the f translation but once used they become accessible from the un heap to this end we implement and type a logical declassification protocol allowing us to prove that as their ownership is to the attacker stub objects do not leak any information to keep track of these heap the representation of heap allocated objects with ghost metadata outlined below we have a tag for each the type which is a wrapper around the type obj associates it with its tag and a predicate p an invariant on the contents of the object type tag inv tag ref tag abs tag un tag stub tag type to e ref dom o p o t inv p t type loc tl e ref p t p t values of type are triples to p t o its third component o is typed as an obj that is a map from strings to properties refined with a formula stating for example that if the object is in the ref heap then it contains the ref field and that it satisfies the invariant p a similar but more complex invariant applies to objects in the inv due to object initialization and implicit effects the result type of to records both the invariant p and the tag of the object in the refinement the type loc is also a triple tl p t r where r is a reference to a tagged object we the tag and invariant of the content of r with the reference itself and the type of tl ensures that the tags of the content and the loc agree translation of types a source type t in f is translated to the refined js type t typed js values we d where t is a predicate on a few cases below where selects an object from the heap and selects a property string ref t o t o ref ref tt a p ht h a r h result r t p r h the translation for primitive types like string is simple the refinement formula string requires the translated value to be a str dyn the translation of ref t requires an object in the ref heap whose ref field satisfies predicate t the translation of function types tt requires the compiled value to be a fun wp term where among other requirements the predicate transformer wp requires its argument to satisfy t and requires proving the postcondition on a result r that satisfies t if it is a value interface of to enforce our invariants a monadic version of the interface to operate on un values for instance it provides aliases to the functions select update and apply of § an un value is either a primitive value or an object or function allocated in the un heap or a stub object the function allows a field to be selected from an un object its precondition requires both the caller and the object o to be and requires the postcondition p to be proven for any result and heap since via selecting a field can trigger arbitrary code the specification for updating an un object is similar calling an un function requires that the caller be an un value both this and args be un and ensures that the result is also un in all cases the use of the monad requires and ensures the heap invariant as well type x typeof x un x stub x type un x val caller un f dyn p h r h result r p r h val caller un f dyn p h r h result r p r h val callee un args un dyn p h r h result r p r h accessing the other heaps imposes requirements but also provides more guarantees relating and to relate our two interfaces we prove a lemma that shows that any js program welltyped against is also welltyped against as long as it only with the of to state this lemma and in the rest of the paper we use the following syntactic · we write s d e t for a computation with a trivial precondition returning a ie s d e t wp where s h wp h hh · s d h e t stands for s d h e t wp where s wp h h h h and h h · d is the lifting of function types in the context where a type t t is lifted to xt t wp when it is clear from the context we write types like t t leaving the lifting implicit · e is the runtime state obtained by adding to each object and constant in h e lemma universal monadic typability of js if h e t then d d e t we write d h e t for monadic typing leaving the signature of in the context implicit formal light translation of f runtime states we now formalize the light translation as a relation f h e t i h e for the translation of the f runtime configuration h e of type t into a js configuration i h e where h is the ref and i consists of both the inv and abs the subscript f is a js value representing the object of the function that e it is null at the toplevel figure gives five representative translation rules simplifying them by type arguments the rules are to be interpreted as inlining the definitions from into the translated term rather than leaving them as free variables the first rule translates a data constructor to an object literal which in is represented as an inv location that is allocated and immediately initialized with the contents of the constructor this is particularly alternative of allocating an object first and then setting its fields is not secure since in general this could cause a traversal of the prototype chain attacker code in case the attacker has a on the available in contrast the allocation of an object literal never causes a prototype traversal the second rule translates a let or bound source variable x to a js expression that selects from the field of an object stored in the inv heap whose location is bound to a js variable of the same name the invariant guarantees that the field is set in the immediate object again preventing any prototype traversal f t i f vi ti i ei i str i ei x t f x t i f x o e t i e xi ti src any string constant f t i src o xi in e f e v t f e t t i e f v t i v i f e global to inv v v obj tl inv f v t i v il to inv v f v t i t f v figure light translation from f to js selected rules the third rule translates a closure function objects in the light translation are always allocated in the abs heap so we use an alias of from called which builds the function object we translate the body of the function using the variable o as the caller object passed as an argument to an alias of for calling an abs function at every callsite in the body of e as shown in the next rule again the arguments are passed as an object literal the last rule is useful primarily for translating runtime expressions rather than source values f has an applicative semantics with a standard reduction rule however in js values are passed as pointers to the inv or sometimes abs heap without this last rule this would cause considerable technical difficulties in our forward simulation proof for example in f we may have xx x d s d d for some constructor d when translating the lefthand side we may allocate only one d in js whereas the translation of the righthand side would allocate two objects to reflect both possibilities the light translation is a nondeterministic relation on runtime states indexed by the js heap i representing data so in the last rule if we find a location in the i heap which already contains a value that is a valid translation of the source value v then rather than allocate a fresh location we may simply translate v to the expression that selects from as such our translation relation the details of data allocation and typed invariant and § show that those details are not observable correctness of the light translation we present our main results for the light translation first stating that it preserves the typing and heap invariants then that it is a forward simulation every f reduction is matched by one or more js reductions type preservation states that if an f state h e welltyped at t is translated to a js state h e with inv and abs heaps i then the js state is welltyped in the monad against the lemma ensures that when h the logical value corresponding to i and h satisfies the heap invariant the js state diverges or produces a result r and h where h satisfies the heap invariant and h h and that result r t is valid as a base case the heap invariant on the empty heap produced when translating a source program rather than an intermediate runtime configuration is trivially satisfied a technical requirement due to of local variables is that all the variables of the translated term already exist in the heap i lemma type preservation if f h e t i h e then for there exists such that d h i e dyn and for h i h if h and h then x h h h h result x t h our next lemma ensures that the formal light translation is a forward simulation that is every reduction step of an f program h e is matched by one or more reductions of its js translation we use an auxiliary function abs i for the set of objects that may be used as the caller object in js abs i null obj abs lemma forward simulation for any source reduction step h e s h e and any translation f h e i h e where f a abs i there exist translation g h reduction e ii and wrappers we now consider the properties of the second phase of our compiler ie the wrappers figure lists the js code of and is to compare with the javascript wrappers shown in figure this code is typed against making use of the variants of functions in this allows us to record the code positions that may trigger callbacks to untrusted code which leaks the callers object to the context specifically we use the following variants of apply select and update · in the abs heap and are created by they may be called with any caller using · are created by with an object they are called using that is only by callers with an un object since this object is possibly to the callee and un arguments similarly un objects are selected using possibly a callback to the context due to a · specifically support our wrapper they are created by with an object in the stub they can be called at most once by any caller using after which they are and released to the context prior to the declassification stub objects are safe they can be updated without callbacks · local variables and data constructors are allocated in the inv heap using and respectively these local variables may be set at most once using then selected many times using these calls never trigger callbacks · mutable references are allocated using and accessed using and locations in the ref are always welltyped and the accesses never trigger callbacks for a given source type t t is an that takes values of type t and returns values of type un conversely t is an that takes values of type un and attempts to return a value of type t to facilitate proofs of these typing properties we the js wrappers with calls to rather than as already noted additionally we require two verification in the code of first we add a call to a ghost function which is used to record in the refinement logic that the stub object has been released to the attacker and should be typed as un a precondition of u callee is that the all the fields of callee must already by as un hence we clear the contents of its caller and arguments fields however the callee object also has an internal field called code containing a reference to the function closure itself which the adversary can use to call the stub directly once it has access to the stub function object eg by using javascript provides no way to clear the code field directly to handle this case we carefully ensure that after declassification the function closure can be typed as a function from un to un thus the stub returns its result via a sideeffect to the reference by typing this idiom requires one level of indirection we initialize the reference by to none and each time the stub is called and successfully the translation of let fun fun fun un let up a u in let z u az in let x u up a global z in let f u af in let y u f global x in let down b u in u down b global y let fun fun fun let az in let by tag str none in let down a in let x o ax in o az o down a global x let stub stub fun un let callee u a callee in u callee caller undef u callee arguments undef u callee ghost let f u af in let z u az in let y u f global in let up b u in let b u up b global y in let tag str some b in u by ref o stub global o o by ref figure function wrappers in js most types a source value vb it updates by with the translation of some v in figure we the option reference into a single mutable location which is a simple semantics preserving transformation equipped with these types we show that a light translation has type un likewise we show that if an un value returns normally then it returns a value typed as the translation of its source type in the lemma statement we write t e for the application of a down wrapper to e ie abs t un e and t e is un t un e in conjunction with lemma this shows that a wrapped term can be safely embedded in any javascript context lemma typing of wrapped terms if d v t then dt v un if d v un then dt v t contextual equivalence by bisimulation in f contextual equivalence is a precise and intuitive notion of equivalence both in javascript and in f but it leads to complicated direct proofs as one needs to reason about any reduction in any context to structure our proof and to analyze interactions between translations of equivalent f expressions and their js contexts we develop a custom labeled bisimulation proof technique although formally independent of javascript the design of our bisimulation is by its application to source f and js in § · our bisimulation must support f types higher order functions mutable state exceptions divergence and errors · functions exported using down wrappers may share private state so we need to relate configurations of functions rather than single functions see also and pierce · our wrappers stop at imported and exported functions thus to extend from terms to configurations and maintain as a transition invariant we use a variant of normal form bisimulation our configurations have free variables for the functions imported from the context thus any callback yields a transition output with a continuation next we define these bisimulation configurations and we study their behavior first using concrete context closures then more abstract labeled transitions the main result of the section is that labeled bisimilarity coincides with contextual equivalence we use interfaces to specify how configurations may interact with their context an interface declares some exported functions previously sent to the context some imported functions previously received from the context some continuations for calls to the context and some memory shared with the context definition interface an interface i consists of heap types for the heap shared with the context and a type environment that binds variables to function types t each annotated with one of three sorts · z z t for functions imported from the context · x x t for functions exported to the context and · k k t for continuations of calls to the context we let z be the projection of on imported functions and similarly for x and k we often these annotations writing for instance y t for any binding of when y dom we write y for the prefix of such that is of the form y yt our configurations represent pairs of related f runtime states both waiting for their next interaction with the context we introduce notations for pairs of related terms in configurations for any phrase of syntax m we write m for pairs of ms and write m and m for their left and right projections respectively further we treat propositions with pairs min as mi mi mi mi in this section and § we omit the inductive signature s in typing judgments and write instead of to separate references from functions in typing environments definition configuration given an interface i a wellformed configuration c i written i c consists of two heaps i such that z i and two substitutions from every yt x k to values v such that i yz v t in the definition i is a pair of private heaps with i and i having possibly different domains both disjoint from the typing judgments imply dom dom i the substitutions map every variable in x k to functions in particular continuations are just functions the environment yz let us type them with free variables for functions next we lift the contextual equivalence of § from terms to configurations relying on generalized contexts and context closure definition configuration context given an interface a wellformed evaluation context e o z e t consists of · a heap o such that o and o x o · a substitution z from every zt z to a value v such that o zx v t · a a typed expression e t defined by induction on k when k the stack is any e such that o x e t when k k t o kx y t k the stack t ey t and e is any ek e t is a stack such for k that definition context closure given a context o z e t and a configuration i with the same interface and disjoint heaps we let e c o i e z be the two runtime states obtained by composing the context with both sides of the configuration and applying the substitutions and z in the order recorded in substituting first the variables these runtime states are closed and welltyped e c t definition contextual equivalence for configurations e i c such that e e c e c our definition generalizes plain contextual equivalences for instance contextual equivalence e on functions of type t coincides with e on configurations with signature x x t more generally we can reduce contextual equivalence of two open expressions xi ti e t to the equivalence of ti t labeled bisimulations to keep the context implicit we define interactions between the configuration and its context as labeled transitions of the form i c i c where and range over input and output labels respectively the input label eg a function call with parameters or returning a result to a previous call is provided by the context to the configuration and the output label is its response eg a returned value or a callback the transition occurs only if both terms in the configuration c have matching behaviors eg both return the same result call the same callback etc thus the transition relation characterizes pairs of f runtime states that have similar interactions with their context definition input label given an interface an input label z o y r consists of · a signature z disjoint from · a heap o such that o and o x z o · a value parameter v such that o z v t · a query q y r of one of the three forms below x r a call to any x t t x or k v a return with k k k t t or k raise v an exception with k k k t and t te such that moreover the values within o and v with a function type are pairwise distinct variables in z intuitively an input label represents a minimal open context that calls a function previously exported by the configuration or returns from a previous call from the configuration to the context o represents some shared heap and z some fresh variables for any function imported by this input from the context in combination we obtain a pair of welltyped open runtime states z z o i y v applying the function associated with y in to v in the last two forms of query the condition on k ensures that the context returns only at the top of the stack with a value or an exception the final condition ensures that no function values are passed directly to the configuration in particular the context cannot directly pass a function x previously received from the configuration instead the context can pass a fresh variable z and can later call x whenever z is called back definition output label given an interface and an input label z o y r t an output label is one of the following · error for failure · for divergence · x o v for normal returns such that x o v t · x o raise v for exceptions such that x o v te or · x z o t z t v t z for callbacks such that x o v t and in o the last extend three cases we require that x o with the locations reachable and from v be disjoint and o and that that all values within o and v with function types be distinct variables defining the domain of x for convenience to deal with both kinds of inputs we write k also y for when y x let abbreviate z y and for y z x in the when k k y interface after the we output as with input labels we require that v in output results do not contain names from x z in combination compatible inputs and outputs define transitions between interfaces transitions between configurations defined can be seen as their refinement of the form c o c a plain labeled simulation on pair of terms would require that for every transition on one side there exists a matching transition on the other side in our case since configurations already account for both sides we define transitions as a partial relation between configurations we have a transition only when both sides perform matching outputs for we use two additional terminal configurations error and with no input to represent the outcome of transitions that lead to failure and divergence respectively for a given configuration i c the additional locations in o in the input label may with the private locations of i our transitions implicitly assume that this is not the case as we can always pick another input label with fresh names and that the output label is wellformed definition transition given interface and input label z o y r t configuration transitions are partially defined below with one rule for each form of output ob ib yb v error for b i error error ob ib yb v for b i ob ib yb v s o b i b rb for b i x or i o b ib y b v s o b i b v b for b i k k t i k definition bisimilarity a bisimulation is a set of configurations closed by transitions for every i c with input label there exists an output label and i c such that i c i c applicative bisimilarity written a is the largest bisimulation as usual to prove c a for a given configuration c it suffices to build some that includes c and show that it is a bisimulation see the full paper for additional discussion and examples we now relate labeled transitions on configurations to the reductions of runtime states obtained by context closure lemma let c a the two sides of any context closure e c either return some identical result or diverge or reduce to some e c with c c and c a lemma for every transition i i there is a context et for i such that for any c i with input we have et c if and only if c performs this transition lemma for every transition i c i c and e c there is a context closure e c such that e c e c theorem e a full abstraction for wrapped translations we are finally ready to prove full abstraction relating contextual equivalences in f and js relying on theorem we use labeled bisimulations rather than contextual equivalences the main idea is to extend the wrapped translation from source expressions to source configurations and to systematically relate their source and target transitions we begin by establishing a corollary of type soundness for reasoning about untrusted callbacks then we establish operational properties for wrappers setting up notations for configuration translations definition untrusted callbacks as we import untrusted values callbacks by are since the context can provide arbitrary values to deal with them in the bisimulation we use a corollary of open subject reduction where we use i to refer to the union of the translation of the source ref heap h together with the inv abs and the private locations in the stub heap lemma untrusted callbacks for every typed open runtime state s z un or s s i e where z d s t and un one of the following holds n i ez un un sz properties of wrappers for functional types the full paper defines tx the js open function value obtained by reducing t x similarly tz is the function obtained by reducing t ter operation just up and down wrappers around the ar and return of z so the value always exists in both cases we remove the fun constructor and retain the function closure within the main operational property for down wrappers is that as we ex port a translation of a source value we obtain a un value that depends only on the source on the choice of its translation its proof is by induction on v relying on monadic typ ing § and is mutually inductive with the proof of lemma which reasons about values from the context for clarity we present the two lemmas separately lemma running down let x v t such that t is defined and and x binds the functions of v substitute tx for every let x x t un and v such that for any light translation x f v t i e we have i t e s i v and x d i v un intuitively is the new un memory allocated to copy the exported value while x declares the exported translations of the function variables in v the next lemma shows that up wrappers return at most light translations of a source value that depend only on the untrusted context besides those wrappers may trigger untrusted callbacks in the process diverge fail or raise an exception in addition to divergence in any callbacks that may be we may get divergence for instance as we try to import a circular list lemma running up for all values u un and states s n z h i t u h i v f h v t such that z d s t if s returns with final state t after any number of untrusted callbacks then i h v for some source runtime state h v candidate bisimulation we define the full translation of source configurations the full translation of programs is a special case as in § this translation is nondeterministic it includes consistent translations of every piece of the source configuration it is designed to be closed by js transitions to keeps track of all allocated it also includes the translation of an auxiliary store not present in the source configuration with one option reference for every stub as can be expected of a translation its interface consists entirely of untrusted locations and functions we refer to the full paper for auxiliary definitions of the evaluation contexts et for frames that transition from untrusted callers to translated ff for frames that transition from translated callbacks to untrusted for f stub closures with object s and reference r variable by in figure and u that ranges over their continuations after declassification this definition also functions eg tx applied to a this object and waiting for its arguments object definition configuration translation a translation of the source configuration c h is any configuration of the form i h such that for b we have hb ib hb for every x x t we have x b ib vb and x b for every k k t t we have k b ib eb using the light translation of expressions with an additional rule translating to and k b is et for some typed continuation u reachable from for every r v option t b also defines and any typed continuations u reachable from i h and are obtained from i h and by replacing every instance of z with tz for every z z t declares un objects including function objects for the exported functions x and the function objects s of the of declares z z t z z un un un x x t x x un un un or k k t k k un un for every declaration in and every definition of the lemma statements below account for the nondeterminism of our translation for soundness collects all configuration translations defined above for completeness collects all configuration translations without stub callbacks we obtain our main theorem for programs seen as singleton configurations lemma soundness if i c e then i c e lemma completeness if i c e then i c e theorem full abstraction for all translations v t e such that t is defined v e v in f if and only if t e e t e in js preliminary case studies and discussion although we leave an extensive evaluation of our compiler as future work we have already used it to program several small case studies available on the briefly describe two of these here secure a traditional challenge in javascript programming involves combining code from multiple mutually sources while maintaining a degree of control over the resulting one design towards this objective could be to implement a subsystem in f that interactions prove it correct using monadic f and then it using our compiler to illustrate our point we have implemented an local store on top of the object in html which offers a store per web page the challenge is that this resource is shared between all scripts running in a web page they can all read write and even clear the whole storage without any access control to enable to use local storage we implement a secure api and that access to while ensuring isolation javascript and propose a implementation of aspectoriented advice for javascript itself expressed as javascript code in preliminary experiments we have been able to implement policies in f being written in f makes the advice simpler we can prove correctness of the advice by contextual equivalence at the source level and unlike we do not require any browser modifications performance the benefits of running secure javascript come at a price as any interactions with untrusted code are by wrappers the cost of however is only to the number of boundary between trusted and untrusted code when executing within f there is little overhead due to security nevertheless we expect to improve our translation with an towards performance along several for example our current representation of datatypes is we might instead use which offers a data representation for the wrappers rather than data by copying we plan to investigate using a new feature that dynamically the fields of an object immutable we are also considering using a lazy semantics for the wrappers that import data possibly using of the es standard this would the callbacks in the source semantics as lazy may trigger callbacks to the context as imported data is read but the performance may make this a good tradeoff conclusions it is common for compilers to target javascript to a growing view of javascript as the assembly language of the web our work provides a foundation for such compilers particularly when compiled code must interact with code from other less sources relying on full abstraction developers who program in higher level languages such as ml can and their code without having to about the of javascript references m abadi protection in translations in icalp volume pages ­ m abadi and g d plotkin on protection by layout in ieee pages ­ m abadi c fournet and g secure implementation of channel abstractions information and computation ­ p r b and f secure compilation to modern processors in ieee pages ­ a ahmed and m typed closure conversion preserves observational equivalence in icfp attack vectors for url e cooper s p wadler and j links web programming without in l de and n z an efficient smt solver in tacas a c and s the essence of javascript in ecoop a kennedy the net programming model s eager normal form bisimulation lics s j c mitchell and a an operational semantics for javascript in j towards a mathematical science of computation in ifip pages ­ l a and v b specifying and enforcing finegrained security policies for javascript in the browser in ieee sp j c mitchell on abstraction and the expressive power of programming languages science of computer programming ­ j h morris protection in programming languages in cacm j m b j and s a tested semantics for and eval in javascript in c and n verification condition generation with the dijkstra state monad technical report mar m e and f a language for programming the web in oopsla companion pages ­ e and b c pierce a bisimulation for type abstraction and recursion in popl n j chen c fournet py k and j yang secure distributed programming with types in icfp n j c j chen and b towards javascript verification with the dijkstra state monad technical report mar a u j c mitchell m s and j automated analysis of javascript in ieee sp 