multiparty asynchronous global programming it university of copenhagen abstract over the last global descriptions have been successfully employed for the verification and implementation of communicating systems respectively as protocol specifications and in this work we bring these two together by a programming model we show a novel interpretation of and parallelism in a global setting and develop a typing discipline that verifies against protocol specifications based on multiparty sessions exploiting the nature of global descriptions our type system defines a new class of concurrent systems provides type inference and supports session mobility we give a notion of endpoint projection which generates correct entity code as calculus terms from a choreography finally we evaluate our approach by providing a prototype implementation for a concrete programming language and by applying it to some examples from and programming categories and subject descriptors d programming languages formal definitions and theory f semantics of programming languages process models general terms design languages theory keywords concurrency choreography types sessions introduction global descriptions represent a powerful paradigm for designing communicating systems where the programmer gives a global view of how messages are during execution instead of separately defining the behaviour of each endpoint entity then the local behaviour of each endpoint can be automatically generated by means of endpoint projection the paradigm has been studied in formal models standards and language implementations global descriptions have a great impact on the quality of software as they represent formal of how communicating systems should behave and offer a concise view of the message flows by a system in particular they i lower the possibility of introducing programming errors and ii ease the task both manual and automatic of detecting them global descriptions can be used at different permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright © acm of abstraction ranging from abstract descriptions of protocols to descriptions of concrete system implementations these different respectively two recent and successful development in the first methodology programmers design abstract protocols using global descriptions these are automatically onto abstract endpoint specifications which are finally used for the static verification of manually written endpoint code protocols protocol projection abstract endpoint validation endpoint code the approach above has the benefit of producing very clear protocol specifications however it the programmer from a global view of the system when dealing with its implementation a major consequence is that programming becomes when dealing with the actual interleaving of different protocol instances for example it can easily lead to systems the second methodology deals with system implementations using programmers can write a choreography and then automatically project an executable system from it choreography projection choreography endpoint code here the main advantage is the precise view given by on the possible system executions however lack in abstraction wrt global protocol descriptions and their programming needs to be with additional tools current disciplines for programming are based on writing abstract endpoint descriptions and then using them to check the behaviour of each endpoint directly on the choreography or its hence in these models we lose a global view of the system when describing its protocol specifications inspired by these observations and by private with our we ask can we design a unified framework that combines global descriptions of protocols and implementations clearly a positive answer would retain the advantages of global descriptions for both the writing of protocols and that of implementations moreover a natural following question is whether such a unified framework could offer more than just the sum of the parts are there other advantages that can arise from the combination of global protocol descriptions with in order to answer the questions above we build and a model for a fully global framework in our model developers design both protocols and implementations from a global viewpoint endpoint implementations can then be automatically generated global validation protocols choreography choreography projection endpoint code the challenge of reaching our objective is first since we aim at designing a model where can instantiate different protocols multiple times and their execution the model should ensure that these interleavings will not lead to bad behaviour second it is not clear how common aspects of concurrent systems such as communications are asynchronous and parallelism parallel executions should influence the interpretation of a choreography describe communications as atomic actions making concurrency less explicit main contributions we provide the following contributions multiparty we introduce a choreography model with multiparty protocol instances sessions as firstclass elements § and provide an that under simple restrictions correctly generates endpoint code from a choreography § and parallelism our framework gives a novel and concise interpretation of and parallelism by inferring the implicit concurrent behaviour specified in a choreography § typing and type inference we provide a type system § for checking against protocol specifications given as multiparty session types our type analysis plays a major role in ensuring the correctness of code interestingly due to the global nature of our framework can generate correct endpoint code that is not allowed by current multiparty session typings § typing expressiveness we also give a type inference technique supporting the opposite methodology ie extracting the protocols implemented in a choreography § type inference this is the first work to provide a choreography model supporting session a mobility mechanism for the continuation of a protocol § due to and parallelism typing § is nontrivial since messages prior to and after may be interleaved making it difficult to check that channel are consistently our framework guarantees deadlock freedom § corollary a hard problem in multiparty sessions types this feature follows from using a choreography as initial design tool implementation and evaluation we provide a prototype implementation of our framework § a programming language an and an that support the development of concurrent systems using our global methodology we use to evaluate our programming model against examples of different nature from to distributed programming § proofs and full definitions can be found in model in this section we give an informal description of our model whose key elements are protocols and a protocol is an abstract specification of the structure of some communications in a system whereas a choreography describes a concrete system implementing one or more protocols we represent protocols with global types global descriptions where entities are abstracted as roles that communicate following a given conversation structure example protocol in this protocol two b and b wish to share the of a product from a s b s string s b int s b int b b int b s ok b s string s b date end above b b and s are called roles b sends to a s a request of type string then s sends a quote to b and another potential b b tells b the amount she to contribute with b s of whether she has accepted ok or if so b sends to s a string address and finally s with a date of type date in this paper we introduce a choreography model for globally implementing protocols such as the one above its core elements are threads and sessions a thread represents a logical processing unit that executes a sequence of instructions each thread has its own local variables and can exchange messages with other threads by performing io communications threads can be to be already active or dynamically created at runtime a session is an instance of a protocol and implements communications between some threads sessions can be dynamically created by threads example choreography we give a choreography implementing the protocol in example bb bb start ss ak k k k k if z z b then bb ss k k else bb ss in line threads b b and thread s start a session k through public channel a roles b b and s respectively in lines b s for and gets back the quote which is also sent to b note that eg b uses its local variable y to receive the evaluation of then b tells b the amount she to contribute for the namely in line b evaluates the offer received by b in the guard z z b if positive b her decision with the selection bb ss sends her address addr and receives the date lines otherwise b aborts by selecting in line observe that the structure of session k in example is that of the protocol given in example the only differences are that data has become explicit and that we introduced the start primitive the latter allows threads to on a public name eg a and create new threads and sessions in line of example b and b are already active threads while s is a service thread ie a dynamically thread active threads appear on the lefthand side of the start keyword whereas fresh service threads appear on its righthand side role annotations eg bb relate each thread to the role it plays in a session example choreography can also describe multiple interleaved instances of multiple protocols we extend the choreography from example with two other sessions k and k that b and b will respectively use for getting help in the transaction as lines in example bb start hh bk k bb hh k done bb start hh bk z k bb hh k k bb hh k kb if zz h then hb ss k k else hb ss c c c the choreography starts with the first lines of that in example in block c b starts a new session with a h it to contribute for half of its part line and it that it does not need to do more line on the other hand in block c b does the same with another thread h until line differently now b h to continue session k by taking on its role line then it sends the total price received from s to h line and the session reference line finally in block c h completes the protocol instead of b checking that its own contribution is less than of the total price note that h and h are started through the same public channel b which acts as a shared channel in multiparty session types our model has two features that interestingly influence choreography interpretation in different ways parallelism thread executions may concurrently proceed without any ordering unless constraints are introduced secondly communications are asynchronous so a thread may send a message to another thread and then immediately proceed before the message has actually been by the network for instance in example the threads whose behaviour is described in blocks c and c are different b and h for c b and h for c therefore their executions may due to parallelism eg b and h may start session k before b and h start session k even more k may be completely executed before k is started hence the interpretation of c c should be equivalent to that of c c and in general to that of any interleaving of c and c furthermore in lines and of example where s sends the quote to b and then b it may happen that b line receives the quote before b due to asynchronous parallelism and are respectively handled by our relation and our asynchronous semantics both in the next section in general we say that our relaxed sequential operator the programmer from expressing the degree of concurrency and parallelism of a system indeed our framework will automatically infer the latter by looking at the thread identifiers we made this choice in of design and simplicity in real tools combining the sequential operator with explicit primitives for eg parallelism may be for clarity purposes we discuss this in § sequential and parallel operators with multiparty sessions we introduce the global calculus gc a choreography model with multiparty asynchronous sessions syntax the syntax of our calculus is reported in figure c c if e then c else c rec xx k c in c xe k r c sequence conditional recursion call restriction pe qx k p q kl p q k k p communication selection p start ak start figure global calculus with multiparty sessions syntax c is a choreography is a thread and k is a session identifier interactions between threads are specified by the term c which reads the system may execute the interaction and continue as c we distinguish four different kinds of interaction start communication selection and start denotes session ini threads i for i m start a new multiparty session through public channel a and tag it with a fresh identifier k called session channel the first n threads the active threads are already running while n m the service threads are dynamically created and started we assume that m a session has at least two participants and n a session is started by at least one running thread the denote the roles by the threads in the session communication denotes a communication where thread sends over session k the evaluation of a firstorder expression e to thread which binds it to variable x in selection to her selection of branch l through to over k her role p in session k gc also offers other standard programming language constructs in conditional expression e is labelled with a thread name indicating where it is evaluated recursion and call model standard recursive procedures where each variable in x or expression in e respectively is located at a thread in in call we assume that each expression can only be either a variable or a value restriction which is only used at runtime and cannot be used in programs models name restriction r for restricted name can be a thread or a session channel the term denotes termination in a term c can bind session channels threads and variables when is a start n are free while k and n m are bound since they are created if is a communication variable x is bound as usual r is bound in r c we often omit empty vectors and irrelevant variables in the remainder r rn is a for r rn semantics above we stated that the term c specifies a system that may execute the interaction and then continue as c threads however are assumed to run in parallel as a consequence some actions in c may be performed before for example blocks c and c from example describe the behaviour of different threads therefore as discussed in § in an actual system run of these threads their executions may due to parallelism to deal with such cases we define the congruence relation c which allows permutations of this kind of interaction sequences c is defined as the smallest congruence satisfying the rules in figure c terms with different threads the top rule two conditionals c and c are to preserve the semantics of the term wrt the evaluations of the conditions the rule two interactions and that do not share any thread names calculated by the rule an interaction out of a conditional if it prefixes both branches and does not involve the thread that checks the condition asynchronous can cause situations as the one discussed for lines and of example in § where s sends the quote to b then to b and b may receive the quote before b unlike for parallelism we address this issue directly in the operational semantics this is because is asymmetric even though the receiving actions may in a different order wrt that in the choreography the sending actions instead will happen in the specified order since the thread performing the outputs is the same this is different from parallelism where the ordering of both receiving and sending actions may change it is unsafe to manipulate the syntax of the choreography for simulating since when we will generate the code for the sender thread cf § the order of outputs will be important figure contains the rules defining the labelled reduction semantics for gc whose labels are defined as if r for clarity we annotate threads with roles this is necessary only for start since roles can be inferred from session identifiers in all other terms handling parallelism with a congruence simplifies our development since in a choreography do not influence the behaviour of its if e then if e then c else c else if e then c else c c if e then if e then c else c else if e then c else c c if e then c else c c if e then c else c figure global calculus with multiparty sessions swap relation c c act c com c async c if c ctx c res c eq selection start c r c r bn pe qx k c ve e v c r c c r c snd fn r bn fn r fn if e then c else c if ci i if e true i otherwise c c rec xx k c in c rec xx k c in c c c r c r r c c r c c c c r c c c r c figure global calculus with multiparty sessions semantics start a label is either an interaction an internal action if by thread conditional or another label with restricted name r when new threads or session channels are created rule c async captures the asynchronous behaviour of endpoint systems allowing a thread to send a message and then proceed freely before the intended receiver actually receives it in the rule the sender of performs the action in the continuation c without waiting for the message in to be we check that the receiver of is not involved in since otherwise causality between and would be violated finally is kept for the later observation of the message rule c act models interactions that are not communication in the if is a start then r contains the created service threads and the session channel for all other cases r is empty in c com we substitute variable x with value v the evaluation of the expression e in a system that we leave unspecified with the smart substitution which x with v only under the free name in c modelling local variables in rule c eq the relation r can be either the relation c or structural congruence structural congruence handles name restriction and recursion unfolding we just mention the rule for unfolding rec xx k c in xv k rec xx k c in c vx all other rules are standard and can be found in since every term but has a corresponding semantic rule that can reduce it formally theorem let c and contain no free variable names then there exist c such that c c typing we now present our typing system which allows to specify protocols in terms of global types and then check whether session behaviours in a choreography respect them syntax figure contains the syntax of global types p q u g abstracts an interaction from role p to role q with continuation g where u referred to as the carrying type is the type of the message u can either be a basic type s or gp communicating gp means that a sender role to another role her role p in protocol g in p q li role p can select one label li and continue as gi all other terms are standard g p q u g p q li end rec t g t communication choice recursion call u s gp values s bool int string sort figure global types syntax semantics we give a semantics for global types which expresses the abstract execution of protocols g g is the smallest relation on the of global types satisfying the rules given in figure a label shows which interaction is con since our discussion on and parallelism applies also to protocols we need to capture these aspects also in their se similarly to c async g models in global types by allowing a sender role to proceed before the receiver has actually received the message g does the same for branching observe that since we are allowing an asynchronous action from inside branch gj to take place we re strict the branching to the choice lj gj in order to the other branches in g swap the relation g for global types models parallelism and is defined similarly to c formally it is the small congruence satisfying the rules in figure the rules are similar to the ones for c where conditional is now replaced by branching type checking we now introduce our multiparty session typing which checks that sessions in a program choreography without restrictions follow the protocol specifications given as global types we use three kinds of typing environments service env a p q g x s x thread env kp session env k g a service environment carries the global type of each public channel specifying how a session has to be executed after in a p q p and q are the roles of the active and service g com g rec g p q u g p g t gt g rec t g g g g p roles q roles p q u g p q u g g branch g swap g p q li p gj g g g g g g g g gj gj p roles q roles p q li p q lj gj figure global types semantics gs gs gs p q p q p q u p q u g p q u p q u p q p q p q li p q u g p q u p q li p q p q p q li p q lj jj ii g p q lj p q li ii jj figure global types swap relation g threads respectively also keeps the sort types of variables and all environments necessary for typing recursive procedures a thread environment keeps track of which role each thread is in a session finally a session environment records the type of each running session k we assume that we can write a g only if a does not occur in the same holds for wrt sessions k further more we can write kp only if is not associated to any other role in the same session k in consequently a thread can in multiple sessions different roles but it cannot in the same session with more than one role typing judgements have the shape c intuitively c is welltyped provided that public channels are used according to threads play roles according to and session channels are used according to figure contains the typing rules rule gt start types a start term by checking that in the subterm c session k is used according to the type g of public channel a also each thread i is checked to play role pi in c when using session k we require all roles pi to occur in g enforcing that each thread at least once in the session we tion n m for checking that threads n m are not associated to any session in ensuring their freshness in gt com we check that given an interaction between and over session channel k i the global type for k in the session en requires a communication of type s between role p and role q ii plays role p and plays role q according to and iii expression e and variable x have type s according to rule gt sel deals with selection and is similar to gt com although we now check that the chosen label is among the ones allowed by the type gt addresses session it transfers the owner of role p in session k and checks that the carrying type in the session type of k is the type of the continuation of k gt rec types a recursive procedure and the choreography in which it is used the recursion body is checked using only the types of its stored in public channels and giving the possibility to invoke other procedures rec all other rules are standard for instance the protocol in example types channel a in example runtime typing for showing that welltyped programs never go wrong we need to extend our typing to runtime in particular we need to deal with two issues asynchronous and parallelism we give an intuition of these issues and how we deal with them see for details asynchronous we check runtime with new judgements of the form c the extra the environment contains information about channels that may have been already by rule c async eg consider the following choreography c pe qx k p q k kp pe ry k by c async c may execute before and reduce to when typing we need to remember the in since we cannot construct a thread environment for typing both and therefore the choreography would be well typed with but not with parallelism can actually make things worse eg a swap of is clearly still safe at endpoint since the output in has already been executed and thus will no longer use k our type system uses also to handle these cases to how we this mechanism we show the runtime typing version of rule gt com kp kp x s c k g e s pe qx k c k p q s g the rule above differs from gt com in figure only in the role checks for the two interacting threads given in the first two lines in the first line we check that thread plays role p in session k using or that has p to another thread using through the auxiliary predicate this covers our example above where c reduces to in the second line we check that plays role q as before in rule gt com for programs however now we also need to check that has not its role to another thread using another auxiliary predicate on this condition is necessary for that q is only by one thread in order to avoid races on the receiving of messages for q in session k parallelism consider the following protocol g p p int p p string gt start a p pn pn pm g p pm kp m c k g n m p start ak c gt var x end only xx k gt com e s kp x s c k g pe qx k c k p q s g gt zero end only gt sel kp c k gj ji p q c k p q li gt if e bool c c if e then c else c gt kp k p c k g k g k p p q k k p c k p q g p g k g gt rec x x k c rec x c k rec xx k c in c figure global calculus with multiparty sessions typing rules which can correctly type public channel a in the choreography c p p start p p ak pe px k pe py k since we can swap c with c such that c p p start p p ak pe py k pe px k public channel a in c does not have type g but c is clearly still correct since we can easily follow its swap from c in type g using for global types g g p q string p p int our type system however does not deal with in global types and would reject c we made this choice so that program do not need to think about the swap relations when writing programs which could make error messages in some cases however at runtime we must consider in order to pre serve wrt reductions subject reduction there our runtime type system rules gt start and gt for typing up to g properties we can now present the expected main properties of our type system in the sequel we say that k whenever k g is in such that g g and is the result of substituting k g in with k g also we write g iff dom dom and k g k for all k dom theorem assume c then · subject swap c c c implies c g · c c implies that there exists such that where subject reduction c for some session if is a communication on session k then k with and on the same roles else type inference we exploit the close correspondence between pro and to perform type inference of public chan thus we can automatically extract protocols from first we define subtyping as set inclusion on branching la similarly to the covariant typing of rule gt sel in figure then we modify our rules to determine the principal type of a choreography we discuss this aspect informally cf for the we change rule gt sel to require a sin branching type for the label of interest then gt if will have to compute the least upper bound lub of the session and for c and c in the branches by merging their branching types similarly rule gt start will need to update service types in with the lub of all the global types of each session started through the same public channel a recursion is handled in a standard manner for example from b in example we can infer the type b h int b h done end b h int b h as line in example b endpoint projection and its properties we now address endpoint code generation first we recall an endpoint model that we shall use as a target language then we show how to generate endpoint code for each thread in a choreography and finally how to obtain the code for the entire system our code generation the endpoint projection will satisfy the theorem which gives a correspondence between the asynchronous semantics of and the one of endpoint terms endpoint model we model endpoint code with the calculus for multiparty sessions whose syntax includes conditional parallel the process and recursion plus the following terms where unboxed terms denote programs p q ap p p cp e p p p cp c p k p p cp li cp l p c k h p q w · h w v l kp the first row contains the terms for implementing a session start request accept and replicated accept respectively request and accept are used by active threads while the latter models a process for service threads the second row concerns inputs of a value channel or label branching for c k kp is an input from role p over session k the third row has outputs where p in kp is the role the message is sent to example ps pb pb is an endpoint implementation of example where ps ask kb kb ok kb kb pb ab b sk ks kb pb if z z then ks ok ks addr else ks boxed terms are used only at runtime a session queue k h is a fifo queue h for session channel k a message in h contains the sender and receiver roles and the carried message w a value v a label l or a channel kp messages with different pairs of roles can be by structural congruence omitted simulating a queue per each pair of roles since messages in a queue have both a receiver and a sender role inputs and outputs are annotated with the executing role at runtime eg the term l p is an executing process which will put the message q p l in the queue k with sender q and receiver p figure contains a selection of the rules defining the semantics of terms where r jj qj i n and j n m the first rule a session creating an empty session queue k and substituting every occurrence of session channel k which will be restricted with where pj is the role that must be by process pj replicated services in r model of new processes the second rule puts value v the evaluation of e in the queue for k the last rule is about branching it a label lj from the queue and then continues as process pj labels denoted by µ annotate reductions to make their actions observable eg label p q k v denotes a communication from role p to role q on session channel k carrying v similarly the label for branching starts with a denoting input thread projection we denote with c the projection of the behaviour of a thread in a choreography onto an endpoint term a selection of the rules defining c is reported in figure thread projection adds no further adhoc communications wrt the choreography in a start we project the first thread to an endpoint request threads n to accepts and threads n m to replicated accepts for selection the sender is to an output and the receiver to a branching projections of communication and omitted follow the same principle in a choreography conditional is to a local conditional whereas for all other threads we require their behaviours to be merged by the merging partial operator p q is isomorphic to p and q up to branching where all branches of p or q with distinct labels are also included as a full example the thread projections of the choreography in example choreography are the processes reported in example linearity the expressivity of the start primitive may introduce races on public channels for example the choreography p q start ak p q start ak features four threads starting two different sessions on the same public channel if we run their projections in parallel we have a race between and and another between and for on a this may result in starting a session with and starting a session with the choreography in the sequel an interaction node denoted by n is an abstraction of a node in a choreography syntax tree n can either be n start n m a abstracting a start node or abstracting a session interaction we write n n c whenever n precedes n in the choreography c definition dependency we write n n c if n n c and either n n start n m a and n if i i m or n n start n m a and n n start n m a where i for i m and or n and n n c implies that the projection of for the node of n will not be enabled before that for n we use dependencies to define linearity definition linearity if ni i ni start ni mi a i n are in c and are not in different branches of a cond we say c is linear if either j nj m n j j n or j nj m n j j n linearity checks that for all start nodes n n c on the same a each active thread in n depends on some thread in n avoiding races between active threads this is not necessary for service threads since they will be merged by our linearity is preserved by our semantics and is decidable since a choreography is linear whenever its unfolding of is linear example in we cannot build any dependency unless eg and instead the following choreography is linear with dependencies between and and between and p q start ak p p k p p k p p k p q start ak since different service threads may be started on the same public channel and play the same role we use for merging their behaviours into a single replicated process we identify such threads with c a p the service operator we can finally give the complete definition of definition endpoint projection let c k cf where cf is ie there are no subterms r c in cf then the of c is c k cf k k i ii cf ap cf a p iii the of c is the parallel composition of i the projections of all active threads ii the queues for all active sessions and iii the replicated processes obtained by merging the projections of all service threads with same public channel and role note how has no influence on since we now have parallel composition at the endpoint level ie if c c c then c c example let c be the choreography from example since h and h are under c hb the of c will merge their behaviour into a single process say ph ie c c b c b c s ph where ph is done k bz k bk k bz k b if z z then ks ok ks addr else ks p start ep send ep branch ap p ii pi r k p ii jj qj kj k r e p k h p k h · p q v e v li k q p lj · h pj k h j i figure endpoint calculus selected reduction rules p start ak c i ap c c i i c i if i if i n if n i m c i otherwise l c if p q kl c kp l c if c otherwise if e then c else c if e then c else c c c figure thread projection selected rules if otherwise theorem we now present our theorem which for the relationship between the semantics of a welltyped lin choreography and the semantics of its without loss of gen we consider only strict reductions denoted by ie tions where restricted names not under a prefix are never renamed denotes the closure of the entailment µ checks that the endpoint actions µ implement the global actions cf theorem let c k cf be linear and welltyped with cf then completeness c c implies there exists p such that i c p and either ii c µ p where µ or iii c µ µ p where µ µ µ soundness c p implies there exist p and c such µ that i p p ii c c and µ µ and iii c p above the pruning relation p q is such that p q is bisimilarity and that p has some unused branches and replicated accepts point states that an can up to pruning all the reductions of its choreography on the other hand point says that an always eventually reduces up to pruning to the projection of a possibly reached after multiple reductions of its choreography both points ensure that the of a choreography and its are correctly related by theorems and we can our property below µ is the closure of µ corollary let c be linear and welltyped then for any p such that c µ p we have that either p µ p for some p µ or p moreover our code standard communication safety corollary safety let c be linear welltyped and c µ p then linearity p has no races on any a or k with same role p if p has an enabled input that can consume a message p q w from a session queue k h in p then w is of the same type of the input value label or channel typing expressiveness previously proposed typing disciplines for session types ensure properties similar to ours but performing type analysis directly on endpoint programs our typing discipline subsumes a larger class of safe systems by exploiting the extra information that we gain from defining implementations with in particular our typing system allows for two novel features wrt standard multiparty session typing coherence and partial protocol implementation let us discuss coherence consider the protocol g p q l r p int l r q int above p to q a choice between labels l and l in the first case another role r is expected to communicate an integer to p otherwise r will communicate an integer to q a potential use case for g could be that r some good and p where the good should be sent to p itself or q previous work on global types cannot type any system implementing g since g cannot be onto a correct set of endpoint types indeed in the protocol r is not of the choice made by p and thus cannot know whether it should communicate with p or q we refer to this problem by saying that g is not coherent for previous type systems based on global types in our framework we do not consider protocol coherence because protocols such as g above can easily be implemented by interleaving them with other ones for example consider the following choreography p start q r ak p q start bk if e then p q kl p q k l int px k else p q kl p q k l int k the choreography above can be typed correctly using g as type for a we omit the typing for b in order to role r of the choice performed by role p we make use of an additional session between and we use this session k after receives the choice from observe that the choreography is typable and can be correctly by our the key aspect of this example is that our framework leaves the task of defining a coherent system to the implementation the choreography hence protocols can be designed at a higher level of abstraction eg in g we do not specify how r is of the choice we call this aspect coherence since it is the composition of protocols in a choreography that is checked for coherence by checking whether its is defined and not each protocol by itself we now discuss partial protocol implementation with the fol choreography p q start ak p q start ak p q kl if e then p q k l else p q k l the choreography above is typable in our system as type is p q l end l end l end however the endpoint projection for would not be typable with standard contravariant input typing which requires that at least all the branches in the type are implemented again this is a consequence of using since in the choreography we know exactly which outputs will correspond to which inputs we can ensure that the protocol branches that does not implement will never be used implementation following our model we have implemented the programming language our implementation is open source and comes with a complete developed as an features all gc primitives figure an implementation of our typing discipline figure and an implementation for onto executable from § also provides some syntax extensions for eg protocols may refer to other protocols and allow local code for local state manipulation and user interactions we give an overview of the development methodology by our framework and detail some aspects of our implementation development methodology in the development methodology suggested by see figure developers can first use our to write protocol specifications and the programmer is supported by verification which takes care of checking i the syntactic correctness of program terms and ii the type of the choreography wrt the protocol specifications using our typing discipline program errors are reported using syntax allowing for an interactive programming experience once the global program is completed developers can automatically project to an endpoint implementation given in the programming language cf executable nevertheless is designed to be extended to multiple endpoint languages potentially each thread in a choreography could be implemented with a different endpoint technology we plan future extensions to support to eg java c or each endpoint program comes with its own information given as a term separated from the code implementing the behaviour of the thread this part can be by the programmer which can be useful for running the programs on some specific network or communication technology finally the endpoint programs can be executed as expected they will implement the choreography executable our implementation targets an language choosing has several reasons i offers constructs similar to those of our endpoint calculus eg communications and input choices making part of our straightforward ii has a formal semantics and a reference implementation which we used for implementing some abstract aspects of our model such as message queues and session channels and iii supports a wide range of compatibility with other as detailed below by default our endpoint programs will operate on top of however since also supports other communication ­ eg local memory and blue ­ and data formats ­ eg http and ­ programmers may information of each endpoint hence some may communicate over eg http while others eg using fast binary data formats additionally different end points may be in different machines andor networks notably the of an endpoint program does not necessarily require updating the code of the others sup this flexibility has required a careful implementation of sion starts rule ep start which are by special start services the endpoint projections of the active threads to start a session the appropriate start service then the start service the projections of the service threads by call ing the external services that implement them in every message exchange each endpoint the start service of the binding in formation eg ip address and data format on which the endpoint can be reached finally the start service all participants about all necessary bindings so that each party can dynamically update its references to the others eg connections another key feature concerning different communication tech is that our queue implementation is based on the cor relation sets implementation in sets allow to program incoming message by some data val inside messages with those inside of a thread local state our handles this programming to implement a separate queue for each role in a session as required by our model the programmer can for each fact for instance some threads may identify sessions using http as in common web applications while others may use as in the specifications session is a nontrivial mechanism at the level of endpoint implementation the main concern lies in updating channel references bindings for instance assume that a session k has some thread participants say and suppose now that its role on k to another thread through a different session in such a situation all the threads in need their external references to be updated for reaching instead of when communicating with the pair by in our endpoint model this is completely abstracted away by the on the message queues one per session however in our implementation message queues are completely distributed each thread a message queue which must be reached explicitly by other threads presents a survey of possible solutions to this problem in asynchronous scenarios the main challenge is that may send messages to before getting of the and must thus these messages to adding extra communications in our implementation each thread in knows when the will happen using the information from the choreography hence we are always in the optimal case where no messages are lost examples programming can have several applications ranging from programming to distributed web services below we present and discuss two possible example applications in this example we show how to combine two different protocols for implementing a streaming service for files we start by giving the protocol for streaming rec t s c bytes s c again t end end in the protocol above s is a streaming server sending byte packets to a client c after each packet s to c whether there are more bits to be sent or the stream is over choices again and end the other protocol for processing is code editing verification automatic endpoint endpoint programming optional programming optional execution execution figure development methodology with the language defined by the following global type rec t f a bytes f v bytes a s bytes v s bytes f a again a v bytes v s bytes t end end four roles in this protocol a f an a a v and a sink s the flow of information in this protocol consists of f sending the raw information to a and the raw information to v read from the file then both a and v send the processed information to the sink s the goal of this example is to show how to the two protocols so that the information produced by an implementation of is to a client eg a display as below a sc fv we implement such a system as follows cc start ss ss start ff aa vv rec stream f a v s c c in stream f a v s c the choreography above starts two sessions on a and b corresponding to the two protocols specified above note that the in the first protocol and the file system the and the in the second where chosen to be service threads the core of the choreography is the term c defined as kt kt kt kt stream if ff aa aa vv vv ss ss cc stream f a v s c else ff aa aa vv vv ss ss cc choreography c can be repeated several times lines describe how the sends and information to the threads implementing the and respectively then the and the processed information to the thread implementing the sink the same thread implements the in the other protocol and therefore sends to the client data obtained by composing the and this is like lines correspond to the where the file server will communicate to the other threads that there is more data to process similarly termination is to the other threads in the lines clearly the choreography above is welltyped wrt the two given global types as an example the following process is the for s bs f a rec stream again again stream end end in stream and we give an example using a variant of a protocol where a client called user to a server called relying party through a identity we define the protocol with the following global type u rp string rp ip string u ip string ip rp ok rp u ok rp u gc end fail rp u fail end above rp abstracts the relying party ip the identity and u the user first u sends her to rp which it to ip then u sends her password to ip which will rp of whether the are valid ok or fail finally rp the to u if successful rp also to u role c in a session of type g where g s c string this example with another protocol where a client c a log server s for either a secret or a public log finally s with the corresponding log content formally c s secret s c string public s c string now we can program our system as follows uu start k k k if uu if rpc start ss rpc ss k secret uu k k c msg k else rpc start ss rpc ss k public uu k k c msg k else uu where rp u ip and s are the of the system line describes the of a protocol instance between rp u and ip by means of the public name a in lines u sends its to rp and ip only to rp then ip checks the data received line and the outcome to rp lines and in both cases the selection is to u lines and in the rp checks the user access level if high it starts a new session log s line and for a secret log line consequently rp will its role in session k to the user u through session k finally u will get the log the system works similarly in the public log case lines we conclude by showing the for service thread s k c secret k c private msg public k c public msg note how the thread projections of s for the different branches of the choreography lines and would yield different code which is then merged into the one above other examples in the we provide other examples which can also be directly tested in the the examples include other applications of usage of the choreography language for programming a use case of the and other web services applications related work global methods for communicating systems occur in different forms including security protocols and automata theory however these works are not intended as programming languages since they do not deal with eg different layers of abstraction or value passing this is the first work an asynchronous semantics for a choreography language based on sessions to the best of our knowledge the notion of delayed input is the most similar result to the modelled by our semantics the work to ours is which proposes a synchronous choreography model without based on binary endpoint session types our framework shows that switching to multiparty asynchronous sessions with introduces more complexity but also that such complexity can be hidden from the programmer moreover has implicit threads and deals with a stronger sequential operator requiring two syntactic restrictions on ie and in contrast our approach needs no such restrictions because of explicit threads and a more relaxed sequential operator finally ensures correctness based on a type preservation result while we guarantee the same without the need for an endpoint typing multiparty session types have been previously used for checking endpoint systems we have shown that they can be adopted for typing defining a new class of correct welltyped endpoint systems through our global types as well as our endpoint model are taken by other works have given an asynchronous semantics to global types defines a semantics in terms of that of the projection of global types while global types as asynchronous communication automata our linearity notion is inspired by guarantees progress for multiparty sessions by building additional restrictions on top of endpoint session typing processes satisfying progress do not get stuck provided that they can be run in parallel with other processes that would unlock stuck states in our work progress implied by is an immediate consequence of our theorem yielding a simpler analysis discussion and future extensions we discuss some aspects of programming and future extensions in relation to the work presented in this article approach it may be how the approach may deal with standard aspects of programming such as choreography composition and endpoint code reuse choreography composition is fundamental for supporting distributed team development our framework supports it with i service merging and ii procedures i our merges service threads started on the same public channel and role into a single process this allows two to be composed into a system whenever their respective service threads are can be by using a design pattern ie enforcing service threads that need to be merged to start with distinct branches ii procedures can be written and typed separately so to create libraries that can be used by other code reuse as future work we plan to extend with a system to fully support this methodology endpoint code reuse may be necessary when parts of the system being designed are already implemented for instance we may want to reuse an existing identity service in § and our model does not currently offer a way of integrating existing endpoint code with the of a choreography we discuss some potential solutions which we leave as future work using bisimulation techniques we can verify some existing service code to be bisimilar to the code that would be generated by the alternatively we could use a type system such as multiparty session typing for that the existing code has a behaviour compatible with the choreography both the techniques mentioned above can be to allow for refinement ie the code may do extra actions as long as they do not interfere with the good behaviour of the choreography the resulting system would still guarantee communication safety and session protocol would also still be guaranteed provided that the code has been verified to be note that our implementation of § would need to fall back to the protocol presented in for those sessions whose behaviour is implemented by code since the latter cannot refer to the necessary information provided by the choreography gc features based on our with our we discuss some relevant aspects and extensions of gc sequential and parallel operators the relaxed semantics of our sequential operator allows our framework to express parallelism with a minimal syntax however an explicit parallel operator may make more readable we discuss here two possible extensions in this sense based upon a operator c c equipped with the classical interleaving semantics of parallel composition we use the following choreography as reference example pe px k pe py k whenever are all different can be encoded using our sequential operator pe px k pe py k in fact thanks to our swap relation c would behave exactly as if the two interactions in share a thread name eg the parallel operator would not be syntax sugar since the projection of would be a parallel composition of two input actions this also means that would no longer be a simple sequential thread raising the complexity of our framework and going out of the scope of the present work public channel passing we leave the treatment of public channel name passing as future work the main challenge is to statically establish where such channels can be located in the exceptions our language does not offer specific features for recovery a possible extension is to include exceptions in our choreography language in the spirit of what is informally suggested by for binary sessions dynamic join we plan to extend our model to allow threads to dynamically join and leave an existing session similarly to we conjecture that and parallelism will influence these extensions in a nontrivial way multiple roles in our model a thread can play only one role per session however there are cases in which multiple roles in a protocol may be implemented by a single thread which would be useful both for system simplification and resource we plan to extend our typing system to allow for this occurrences follow a similar direction but using endpoint implementations global projects programs with a default configuration that can be for each endpoint this may be for the programmer since a choreography may describe many participants therefore we plan to introduce a global language for from which the configuration of each endpoint could be automatically generated we that this extension could be relevant for checks on the correctness of a configuration of a system eg consistent io connections security global descriptions are particularly suitable for the study of aspects in distributed systems our give a global view of how sessions are interleaved and how their references are transmitted it would be interesting to see how this aspect may influence the security analysis of a system since in our model a protocol and a session behaviour in a choreography have similar structures we could implement a tool in our that given a protocol would generate a prototype choreography with dummy data that implements it then programmers would refine and different to obtain the desired behaviour conclusions we presented a model for defining asynchronous system implementations as global programs we developed a type system for checking against multiparty protocol specifications moreover through type inference developers can also use as implementation to infer new protocol standards our generates correct endpoint code ensuring nontrivial properties such as deadlock freedom and communication safety finally we provided a prototype implementation of our framework and applied it to some realistic examples acknowledgements we are to n yoshida j t c v and the anonymous reviewers for their comments the for science technology and supported references language specifications p l v t and h t a type system for flexible role assignment in multiparty communicating systems in proc of to appear l m l m d luca m and n yoshida global progress in dynamically interleaved multiparty sessions in concur volume of lncs pages ­ springer k r pm c fournet and j j cryptographic protocol synthesis and verification for multiparty sessions in proc of pages ­ s and u a formal semantics for protocol theoretical computer science ­ n r c r and g choreography and for system design in proc of coordination volume of lncs pages ­ springerverlag l and h t conversation types theoretical computer science ­ c l and d a on the semantics of specifications of security protocols theor comput sci ­ m choreography with exceptions in proc of places volume pages ­ m and f typed multiparty global programming technical report it university of copenhagen m k honda and n yoshida structured programming for web services in proc of esop volume of lncs pages ­ springerverlag programming language pm and n yoshida dynamic session types in proc of popl pages ­ acm pm and n yoshida multiparty session types meet communicating automata in proc of esop lncs pages ­ springerverlag the national for new energy and development x fu t and j su realizability of conversation protocols with message contents international journal on web service res ­ k honda n yoshida and m multiparty asynchronous session types in proc of popl volume pages ­ acm k honda a g tc chen and n yoshida interactions with a formal foundation in proc of volume of lncs pages ­ springer r hu n yoshida and k honda distributed programming in java in ecoop pages ­ international union z message sequence i c f and g the gap between interaction and in proc of pages ­ ieee m and d sangiorgi on in calculi mathematical structures in computer science ­ f and m programming services with sets in pages ­ f c and g composing services with in proc of pages ­ web services process execution language specifications b c pierce types and programming languages mit press ma usa by community wc working group web services choreography description language version n yoshida pm a and r hu multiparty session types in volume of lncs pages ­ 