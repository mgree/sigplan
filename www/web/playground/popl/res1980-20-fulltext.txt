efficient algorithms for structural similarity extended abstract of hb and dj dept of computer science at ny abstract efficient algorithms are presented for several grammar problems relevant to compiler tion these problems include i for a reduced contextfree grammar g and an invertible or h if g is structurally contained by h and ii testing for a reduced contextfree grammar g and a structurally unambiguous grammar h if g is reynolds covered by h or if there is an onto homomorphism from g to h related complexity results are presented for several problems for the regular grammars program schemes and monadic program schemes introduction a variety of binary relations on contextfree grammars have been defined in the literature these relations model some concept of similarity between two besides their mathematical interest concepts of similarity are relevant to compiler construction often one grammar ie used for expressing the sem of translation but a different grammar is used for parsing these two are called the semantic grammar and the parsing grammar res the reason for using two grammars is that while the semantic grammar is convenient for expressing semantics or calls on action routines it may be for a given parsing method which the compiler wish to use when the compiler involves two grammars it is helpful if the grammars are similar in some well defined way that permits a parse of the ing to be systematically converted into a parse of the semantic grammar or into an sequence of calls on semantic action routines for instance the two grammars may be structurally equivalent a structure generated by a grammar is a derivation tree with all non supported research ­ in part by nsf grant no in part by nsf grant no permission to make digital or hard copies of part or all of this work or nor copies are copies on e to to t to prior its date appear and no is by permission of the association for computing machinery to copy otherwise or to republish requires a fee and or specific permission acm terminal labels deleted structurally equivalent set of structures two grammars are if they generate the same however in practice it may not be necessary for the two to generate the struc ture or even the same language the language generated by the parsing grammar may be a superset of the language generated by the seman tic the grammar is said to be structurally contained by the parsing grammar if the set of structures generated by the semantic grammar is a subset of those generated by the parsing the two grammars if this relation holds then given a derivation between tree of the parsing grammar it can be efficiently whether the parsing grammar generates the same structure and if so appropriate nonterminal labels can be efficiently found to convert the structure into a derivation tree of the semantic grammar in particular if the parsing grammar is unambiguous as required by most parsing methods then an input string has at most one corresponding structure according to the parsing grammar and this struc ture can be converted into the corresponding semantic grammar derivation tree if any in practice the strings generated by the parsing grammar but not by the semantic grammar are likely to contain as a boolean partial result being an operand of an arithmetic operator that are easy to detect in terms of the nonterminal labels on the structure a special case of structural containment is known as reynolds covering rh gh reynolds covering is expressed in terms of a function from the nonterminals of the semantic grammar to the nonterminals of the parsing grammar such a func tion can be extended to a function actually a string from the of the semantic grammar to the strings strings of the parsing grammar if the extended function has the property that every production of the semantic grammar maps into a production of the parsing grammar reynolds cover then the function represents a to be precise a contextfree grammar is a four tuple n p s where n and x are disjoint finite sets of nonterminals and terminals the start symbol s is an element of n and p the set of productions is a finite subset of let g m z p s be the semantic and h n z q t be the parsing grammar let f be a function from m to n let be the of f from m u z to n z such that f is the identity on z let ax s in p then h reynolds covers g if fs t and p note if the reynolds covers the semantic then the parsing grammar struc contains the semantic grammar q if h reynolds covers g and in addition p q then is said ta be a g onto h in a compiler each production in a tree of h the parsing grammar would be replaced by an inverse image production under to obtain a derivation tree of g the semantic grammar thus there is no in having q contain productions that are not in tp and the two can be related by an onto homomorphism one to the use of a grammar and a related parsing grammar is that it is computationally difficult to test a pair of gram to determine if the previously mentioned relations hold between them for instance the problem of determining for two grammars whether the first reynolds covers the second is npcomplete furthermore this problem is np complete even for regular grammars also the set of grammar pairs related by an onto homomorphism is npcomplete even for regular grammars the problems of testing two grammars for structural equivalence or for structural containment for regular grammars these are two prob are the of these complexity results is if one has a specific semantic and a specific parsing grammar use of a general algorithm to test if any of the above mentioned relations grammars may require exponential more this exponential complexity regular grammars between time occurs the two for however here we show that the previously mentioned relations can be tested for in polynomial time when the parsing grammar has certain natural properties that help make the parsing grammar easy to parse the key point of this paper is that although these similarity relations are hard to test in general they do have efficient algorithms for some of the very cases of practical interest that the def of the similarity relations we assume that all grammars are reduced ie that each nonterminal occurs in some derivation of a terminal string since this some of the algorithms note that there are efficient the reader polynomial should time algorithms for reducing a grammar au lx for structural containment if the parsing grammar is uniquely invertible ie no two productions have the same right hand side or bounded right context mn then there is a polynomial time algorithm for testing if the seman tic grammar is structurally contained by the ing grammar as there are polynomial time algorithms when the parsing grammar is simple precedence uniquely invertible weak precedence uniquely invertible simple mixed strategy uniquely invertible extended precedence or bounded context for reynolds covering or onto homomorphism if the parsing grammar is structurally unambiguous ie each of the struc tures of the grammar exactly one derivation tree then there is a polynomial time algorithm for testing if the relation holds between semantic and the parsing grammar the thus for any class r of unambiguous there is a polynomial time algorithm for testing if the relation holds when the parsing grammar is a member of furthermore structural can itself be tested for in polynomial time related complexity results are also presented for several problems for the regular grammars program schemes and monadic program schemes for example we show that there is a polynomial time algorithm car testing for two program schemes s and t if the sets of not necessarily executable computation paths of s and t are equal finally we follow au for the definitions of the considered here and we follow ma and n for the definitions of schemes recursion schemes we abbreviate bounded context and bounded right con text by bc and respectively testing for structural containment in this section we show that there are poly time algorithms for testing for grammars g and h if g is structurally contained by h when h is an uniquely invertible or grammar thus there are polynomial time when h is a member of any subset of these three grammar classes eg the simple precedence uniquely invertible weak precedence uniquely invertible simple mixed strategy precedence uniquely invertible extended precedence ok the first theorem deals with the case when the parsing is for each k there is a polynomial time algorithm to determine for grammar g and grammar h if g is structurally contained by h but the of the polynomial that bounds the runtime of the algorithm grows linearly with k note that a compiler using top down parsing is only likely to use an lll or perhaps an ll grammar theorem ll k grammar by h for each k there is a polynomial to determine for g and h if g is structurally contained n we outline the algorithms and sketch the proof of their correctness let k let g and let h the algorithm for k involves processing a list of objects of the form where a c m b e n and w c here lk for language l and integer k denotes the set of strings obtained by each member of l to its first k processing an object results in either the algorithm halting with output no or the addition of possibly zero new objects to the list no object is ever deleted from the list if all on the list have been processed the algo rithm halts with output yes an object represents the assertion that for each derivation tree generated from a having a frontier whose first k symbols equal w the derivation tree is structurally equivalent to some derivation tree generated from b algorithm for k the list with the set of all objects of the form where w c mark each of these objects while an object is marked do following a choose an object say from the list that is marked b if no production b of q exists such that w lk then halt with output no c let bl n be this tion where each i e x u n since h ie at most one such production exists for each production an in p where each e z u m and such that w do the following i check that n m and that for each i either ai and pi are both nonterminals or both are the same terminal if halt with output no ii otherwise for each oi e m and each u c ek such that there exist c for which x e u c y c and w xk add ui to the list if it is not already on the list d mark the object processed halt with output yes sketch of correctness we claim that g is structurally contained by h if and only if the algorithm halts with output yes case suppose g is structurally contained by h by induction on the number of steps taken by the algorithm to place an object on the list each object placed on the list represents a true tion moreover the processing of an object repre a true assertion can not cause the algorithm to halt with output no case suppose the halts with output yes to see that g is structurally contained by h consider a derivation tree generated by g each nonterminal node of the tree is associated with a nonterminal a in m also if the nonterminal node a subtree whose frontier is x we associate the string xk with the node a member of n can be associated with each nonterminal node of the tree so as to obtain a structurally equivalent derivation tree of e as follows the nonterminal t is associated with the root of the tree let be a node associated with a c m b c n and w e a n be the sequence of labels z v m associated in lefttoright order with the immediate descendants of v then aa u is the production of g applied to v in the derivation tree by induction it can be shown that was en object on the list by the since algo rithm with only one production output b yes there is one and in q such that w g lk compatible with a a the immediate n descendants of v associated in lefttoright order with the in r theorem to determine grammar there is a polynomial time for grammar g and uniquely g is structurally contained algorithm invertible by h d we outline of its correctness h the algorithm let g the proof and let algorithm let s and t be symbols not appearing in g or in h construct grammars m ps and h where z m mu s n n ut and q q u t t p the set matched structures is the set of pairs ab such that a m b e n and there is a common structure generated by a and by b matched structures is constructed as follows initially it is empty the pair ab is added to matched structures if p has a production ak and q has a production bk such that identical nonterminals for s i k either ai and i are terminals and the or a and bi are pair has both already been determined to belong to structures if there is a production a u a in p ak and a string k such that for s i k either a and i are identical terminals or is in matched structures but there is no production in q whose right side is q k halt with output no otherwise halt with output yes to the production of a polynomial time bound for step should halt as soon as a required q is discovered to be missing sketch of correctness proof we note that g is structurally contained by h if and only if g is structurally contained by h the for executing step is g is not structurally contained by h if and only if th is a structure generated by some member of m that is not generated by member of n this need not be true for g and h one counterexample is when p and q a we also note that h is uniquely invertible by induction on the of structures it can be shown that for a uniquely invertible grammar each structure generated by a nonterminal of the grammar is generated by exactly one of the this if ab is in matched structures then a generates some structure nonterminal that is generated in n by b but by no other suppose g is not structurally contained by h let o he a structure of minimum depth that is generated by some nonterminal of gr but is not generated by any nonterminal of hr generated from nonterminal a using the production a p since o is of minimum depth for i k either ai is a terminal or else it is the root nonterminal of a structure that is generated by a in nt for each i let i be this terminal or nonterminal thus whenever a i is a nonterminal the structure it generate is generated by i and by no other nonterminal in n moreover if cl is a then the pair is in structures thus u is generated contains b fk by a nonterminal in n if and only if a production whose right side is since by assumption u is not generated by a nonterminal in n there is such production in qv thus while executing step the algorithm halts with output no theorem for each mn there is a time algorithm to determine for g and grammar h if g is structurally contained by h the algorithms of the algorithms presented here of theorem are extensions of theorem and will not be testing for reynolds covering in this section we show that is a poly time algorithm for for grammar g and structurally unambiguous grammar h if g is reynolds covered by h or if there is an onto homomorphism from g to h moreover reynolds cover or onto homomorphism if such a exists our algorithms output appropriate functions from the nonterminals of g to the nonterminals the class of structurally of h since grammars pro contains the class of unambiguous grammars polynomial any class time algorithms r of unambiguous exist when h e p for grammars thus poly time algorithms exist when h is a member of most of the grammar classes corresponding to parsing methods used in compilers first we present two relevant aspects of structural ambiguity proposition rithm to determine unambiguous there is a polynomial time if a grammar is structurally n algo since every uniquely invertible grammar structurally unambiguous and since there is for translating a grammar into a structurally equivalent uniquely invertible grammar mc following holds is a method the proposition algorithm equivalent there to translate that is an exponential a grammar into is structurally time a structurally the main result following of this section is the theorem there is a polynomial time algorithm for testing for grammar g and structurally h if h reynolds covers g more over if h reynolds covers g then this algorithm outputs an appropriate function of g to the nonterminals from the of h d sketch of algorithm let g and h the idea is to find for each a m a derivation tree generated by g containing a and a structurally equivalent derivation tree t generated by h since h is structurally unambiguous if there is a reynolds cover then a must map into the correspond ing node of c however these derivation trees are not tree is explicitly constructed in the sizes of represented since g and h without they may producing be each it in the algorithm consists of step of the algorithm consists of computing for each a e m a set defined in of a specific tree called that a generates bb c n and b a tree that is structurally equivalent to tree a the sets for a e m are in a manner related to the test for in the trees for a q m are not explicitly computed if has not already been computed and there is a production ak in p such that each ai is either a terminal or a nonterminal for which has already been computed then e n and there is a production b bk in q for which i equals a if ai is a terminal and i e otherwise step consists of for each a m an incomplete reachability tree for a ln incomplete reachability tree produced by g having s as its root and frontier nodes that are elements of z u m an incomplete reachability tree for a is an incomplete reachability a is one of the frontier nodes a reachability tree for each nonterminal of g can be found in polynomial time in a manner analogous to the reachability test in the number of productions used in each reachability tree is bounded by ml step computing for each a c m a set for candidate of a in n specifically the set is a subset of constructed as follows for each b g take the incomplete reachability tree for a label one occurrence of a on its frontier with b and label every nonterminal node a on the frontier with other compute the label of each interior node of the incomplete reachability bottomup manner each interior tree in a node ie labelled with for which i there the set of nonterminals is a production c fk in q the interior node k descendants such that for s i s k if the ith immediate descendant is a terminal then ps the same terminal and if the i immediate descendant is an element of the is a nonterminal label of that then i descendant if the root of the containing t then node b is is labelled with included in a because h is structurally unambiguous it can be shown that for each a e m the set at meet one member if the set y for some a c m then the algorithm halts with output no other candidate induces a map from m to n the algorithm checks that this map is a reynolds cover if so the algorithm if not the algorithm halts with output halts with output no we claim that input halts with covered by h and the algorithm given g and h as output yes if g is reynolds halts with output no other a an immediate corollary is the following corollary rithm to morphism structurally there ie a polynomial time determine if there exists an onto from a given grammar g to a given unambiguous h d additional following results obtained include the theorem there is that given a grammar h such that h is structurally a polynomial time grammar g unambiguous a h reynolds covers g and for any structurally unambiguous grammar h that reynolds covers g hs also reynolds covers h so that c theorem hr there are polynomial time to determine for grammar g if g is reynolds covered by for all k an grammar for all k an lrk grammar a simple precedence grammar a uniquely invertible weak precedence gram mar a uniquely invertible simple mixed strategy precedence grammar a uniquely invertible extended precedence and an operator precedence grammar moreover when such a covering grammar h exists these algorithms produce one such h and a mapping from the symbols of g to its symbols d some additional in this section several additional of the results in sections and are presented these show that there are polynomial time algorithms for each of the following problems the structural equivalence and structural containment problems for the classes in section for all k the equivalence and contain ment problems for the regular grammars the problem for program schemes k ie the problem of determining for program not necessarily s and t if the sets of all executable computation paths of s and of t are equal the isomorphism problem for free program schemes ie the problem of ing for free program schemes s and t if for all i the of instructions executed during the computations of s and of t under i are the same except possibly for statement labels one possible version of the isomorphism problem for the free monadic recursion schemes and the reynolds covering and onto homomorphism for the classes in section we also mention difficulty with extending the results of section to the lrk grammars theorem let r be a subclass of one of the ng grammar classes for all k the grammars the uniquely invertible grammars and for all mn the then there is a polynomial time algorithm to determine for g and h in r if g is structurally equivalent to h or if g is contained by h o proof the proof is immediate and since two grammars structurally equivalent if and contains the other from theorems g and h are if each m struc grammar classes p satisfying the conditions of theorem include for all k the and strong grammars the uniquely invertible gr the simple precedence grammars the uniquely invertible weak precedence grammars the uniquely invertible simple mixed strategy precedence grammars the uniquely invertible ex precedence grammars and for all mn n and n grammars since every uniquely structurally unambiguous theorem and proposition invertible a second is is corollary of the following theorem there is an exponential time algorithm to determine for grammars g and h if g is structurally con by h or if g is structurally equivalent to h for grammars mc g and h if lg lh or if lg lh for nondeterministic topdown tree automata t m and n if lm g ln or if lm ln and for nondeterministic bottomup tree automata ti m and n if lm ln or if lm ln d of these problems under deterministic and are are equivalent hs re a third immediate corollary and is the following of theorems theorem h for all k there is a poly time algorithm to determine for regular g and h if lg lh or if lg lh d proof ii for regular grammars s lh if and only contained by h and lg lh if and only equivalent to h n g and h if g is structurally if g is structurally as shown in h there are polynomial time algorithms to construct for program scheme s reg lll that grammars g and gs respectively s such i equals the set of all finite not executable computation paths of s and ii equals the set of all marked finite prefixes of computation sequences of s an analogous polynomial time algorithm exists re monadic recursion schemes to lll grammars z these algorithms together with theorems and can be used to show that several decidable problems for the program schemes free program schemes and free monadic recursion schemes have polynomial algorithms definition ma a program scheme s is to be free if and only if each of its computation is executable under some interpretation a monadic recursion scheme s is said to be free if and only if for no herbrand tation i of s does the computation of s under i the testing the same value of some predicate twice on two monadic recursion schemes are said to be isomorphic if and only if for all interpretations i the sequences of defining equations executed during the computations of s and of t under i are identical except for labels u theorem there are polynomial time algorithms to determine for program schemes s and t if s and t are for free program schemes s and t if s and t are isomorphic and for free monadic recursion if s and t are isomorphic schemes s and t n an immediate following corollary of theorem is the theorem let be a subclass of the struc unambiguous grammars then there is a polynomial time algorithm to determine for gram g and h in f if h reynolds covers g or if there is an onto homomorphism from g to h d any class r of unambiguous grammars satisfies the condition of theorem thus there are polynomial time algorithms to solve the reynolds covering and onto homomorphism problems for most of the grammar classes corresponding to parsing methods used in compilers the proof of theorem also shows the homomorphism and onto morphism problems for the deterministic finite automata and for the unambiguous nondeterministic finite automata are decidable in polynomial time the homomorphism and onto homomorphism problems for arbitrary nondeterministic finite automata are finally we have been unable to extend the results of section to the lrk grammars for any k it turns out that the structural equivalence structural containment and equivalence problems for the lr grammars are at least as hard as the equivalence and containment problems for the unambiguous nondeterministic finite automata formally the equivalence and containment problems for the unambiguous finite are deterministic polynomial time reducible to the structural equivalence structural contain ment and equivalence problems for the regular lr grammars we know of no polynomial time algorithms to solve the or containment problems for the unambiguous nondeterministic finite automata references ml h hs av aho and jd unman parsing translation and and and the theory compiling of nj e a manna and able properties of monadic jacm pp a pnueli functional jn and ma on the and reduction problems for contextfree grammars jacm pp covering hb of regular iii observations on the complexity expression problems to appear in hb iii and dj of similarity report proc of computer science pp a conference on theor hb and tg on the complexity of grammar and related problems proc of annual acm symposium on theory of computing pp hb iii dj and tg on the equivalence containment and covering problems for the regular and context free languages pp k dm kaplan regular expressions and the of programs pp pm lewis dj compiler design reading mass and re theory addisonwesley ma z manna mathematical theory of computation new york mc r pp pu mc and sh structural of contextfree grammars pp jc reynolds and r haskell unpublished manuscript t tree automata an informal survey in av aho ed in the theory of computing prenticehall nj pp z hp formal models for some standard features of programming languages proc of acm symp on theory of computing california pp 