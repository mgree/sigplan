an algebra of relations for machine computation hall ibm peter uk scientific co centre abstract this paper extends the relational algebra of data bases bv and others in four areas the first is the use of selector names to remove order dependencies from the columns of a relation this use of selector names enables us to define a more general class of operations which include the normal relational operations of union etc as special cases we introduce relations represented as well as by a stored set of tuples such computed relations cannot always be effectively as a finite set of tuples finally we consider relational expressions as algorithmic representations of relations and characterize their effectiveness motivation we may think of a relation as a table with rows and columns row ordering is but in the relational algebras developed so far a knowledge of column ordering has been necessary to specify certain operations when tables have many columns this can be tedious discusses the use of what he calls relationships where the components of a tuple or relation are identified by role name and not position formal details of relationships were not up by as he was only interested in the followed them for user convenience he does not seem to have considered relational the role names of the result expression this is not a of a straightforward problem for example given a relation with role names a and b identifying the columns if we use the project operator to define a new two column relation identical to the original which has both columns a column the role names cannot be simply inherited problems concerning the use of have not been fully in the literature let alone solved our solution involves generalizing the relational operations so that the use of the semantics of the operations the particular method we present below is one approach we have concurrently also developed an based on characteristic lambda notation functions and the second area we have has been that of including functional operations on relations we only consider here first order functions those which take a row of a relation and produce a row of a result relation as opposed to second order ones which act across tuples see such operations have been easy to specify in the relational calculus due to the ability to reason with free variables c abc consider b a d we would define such an operation on d by defining a relation using an algorithm and combine and d using one of our generalised operations while considering first order operations on relations we have also considered the storing of sets as procedures which would generate the elements of the set for example the set int of nonnegative integers algorithmic relations cannot be used as freely stored relations for example i a typical relation may only be used compute the given the but not the inverse ii the relations and int are potentially infinite and the evaluation of relational expressions involving them may not terminate as to relations with selectors we a precise notion of relation in normal usage this is done via set tuple and cartesian product we take a parallel approach via set tuple with selectors and cartesian product with selectors and define a relation with selectors which is equivalent to relationship because we deal only with tuples with selectors we will drop the with selectors after the initial we assume a universal underlying elements of u are called objects system we would further domains this gives additional with of operators will not consider here however multiple domains with respect to effectiveness in later sections set u the in a working objects into etc which we we will discuss their a t t with selectors s is a function s is the selector set for t and an element of s ia a selector name for t the elements of the range of t are called the objects of t ts is called the value of s for the tuple t d selectors selectors the cartesian s is the set s h product us of all tuples with of tuples relation cartesian a relation with selectors s is with selectors s equivalently with selectors s is a subset of product with selectors s fl a set a the cartesian number of the degree of a relation selectors elements of s d tuple s is the the cardinality of a relation the number of tuples in the relation is n example consider the relation r represented by the table no part no n tj the selector set for r is the degree is the cardinality r contains a tuple t which we can represent by no part no this tuple might mean that has ordered of part number the object for this tuple selector name because number we can identify using the it is important to note that not is the row ordering of the table representation of r the column ordering also does not matter it is not meaningful to talk of the third column of a relation with selectors rather we talk of the column also the column must be carried into a representation of the tuple the generalised operators we begin and then relational with a definition of all the operators explain them in terms of the usual operators finally we discuss the algebra induced by these operations for all the definitions we assume that the relations ri r q have selector sets s s p respectively notation t i s means function t restricted subset s of its domain ta is functional composition and is the function whose application to object x is equivalent t ax ss means the usual set intersection of sets s and s to the to generalised intersection t t in in r in r o r r t t generalised in us u union s in ri in r v n project let p be ed in s t t n generalised difference r r t t in r t ls s not in r ss n let q be selector t in rl n generalised a function set s project from selector t in there set p to exists t the generalised intersection is probably the most useful operator when r and r are of the same type ie ss the generalised intersection is set intersection at the other extreme if s and s do not overlap we have defined a cartesian product or quadratic join of r and r in between we have an of the two relations the joining components being the selectors common to both r and r ie s s generalised intersection can also cover the notion of select suppose we have a selection criterion or filter defined on certain selectors we can define a relation f possibly infinite with selector set containing just those selectors and whose tuples are just those tuples which the filter then the selection on a relation r using the filter is the same as the generalised intersection between the relation r and the relation f derived from the filter another use of intersection is functional application a relation viewed as a function a subset of its components to the remaining components can be applied to a set arguments to yield a set of results of generalised union to normal union when ri and r have the same selectors when the selectors are different generalised union seems to have useful properties related to undefined values and the merging of heterogeneous files we do not fully understand the implications of these yet generalised project has several uses it can be used to duplicate components but more to rename components that are to be used in a join it is informally called rename for example suppose we have relations one of which has a component and the other of which has a if we to join on these components to find which were returned on the last possible we would need to rename at least one component so that the names were identical generalised intersection would then perform the join project is a special case of the generalised project where q is the inclusion mapping of p into s we have included it for notational convenience finally we come to generalised difference once again if ri and r have the same selectors then this to set difference as an of its more use let ri and b represent a hierarchy with ri containing the tuples of the parent segments r the tuples of the child segments including the fully key of the parent the selectors corresponding to the fully are the only overlap of s and s then rr gives the parent records and rr gives the child records using these operations we can combine relations within expressions each expression defines a relation the selectors of this relation can be readily obtained from the selectors of the operand relations as given below selectors u selectors selectors u selectors p p selectors rr selectors selectors relations with selectors together with the binary operations generalised union intersection and difference form a boolean algebra to demonstrate this structure we a universal element a null element partial ordering relationships and must then verify the various and other algebraic laws for the universal element we suppose that all selectors are drawn from a set i of selectors when the universal element is u z the null element is the empty relation of no selectors u is the cartesian product of no selectors which is either empty or full these two conditions being effectively the truth values the ordering relationship is relation inclusion where a relation r contains another relation r if the selectors of r include the selectors of r and the difference rr is empty the various algebraic laws then follow with universal complement obtained from generalised difference the representation effectiveness of relations and their when we come to relations in computing machinery we find two at the one end of the we have relations which are stored explicitly as sets of tuples and at the other end we have relations which are pure predicates ie we can only if a given tuple is in the relation or not we do not consider those relations whose characteristic functions are not decidable in the preceding sections defining relations and the operations on them we do not distinguish between such relations however have very different properties when it comes to generating their contents as the following examples make clear what we wish to do in the following sections is to explore the different behaviour of such relations and expressions involving them when we try to generate them examples ex relation we can without relations relational if we are given a representation of a which is a table as in ex then generate all of the tuples in the table additional input these are the as they are usually in data bases ex we have a binary relation between an and its which is represented by a procedure to calculate the of a given we cannot generate the extent of the relation itself although we can generate the result of a relational expression which applies it to a finite set of we cannot however apply the representation of so that we obtain ex if we have a relation which is a pure predicate such as a test whether a given point is in a particular then we require that it is used in relational expressions as a pure predicate we call such representations of relations ex returning to ex we could consider the same representation augmented by a second procedure which computes the thus allowing the representation to be used in both directions note that this still does not give a generation capability we will use the term effectiveness to talk the generation properties of the representations of relations and relational expressions about we will the effectiveness of a representation in terms of a set of input sets we will call a subset of the selectors of a relation an input set for the representation if given values for these selectors we can then obtain a complete set of values we together all such input sets into a set of input sets which is the effectiveness of the representation note that if any set of selectors p is an input set then set containing p is also an input set returning to our examples above we now the effectiveness of their representations using sets of input sets the effectiveness of a representation of r as er we write relation ex for ex we have er o no part no no part no no part no no part no this reads given no inputs or any set of inputs we can obtain all the other components ex for ex we have k xx this reads given the value of the x we can obtain the value of the other component namely the sx of the or given both x and number sx we can test whether ex for ex we have point this reads given a point and a we test whether the point is in the can ex for ex we have x sx this reads given the we can compute the or given the we can compute the or given both we can test for membership to use effectiveness in a particular case we the set p of selectors for the input values p is in the effectiveness we know that the representation will be for this case find if the view of relations as mappings from a subset of the components to another subset of the components is by no means new it has even occurred within relational bases as the mapping concept of square and sequel where it is used as a language device and it has appeared as a means of representing constraints within functional the effectiveness of expressions when relations are combined by relational operators within an expression the result is also a relation if we have representations of the operands then the relational expression er with these representations forms a representation of the result given the effectiveness of operands we can the expression the representations of deduce the effectiveness the of we require for each relational operation to specify the effectiveness of the result as a function of the effectiveness of the operands in the following we will write the selectors rs the selectors rs so that the two relations ri and r have selectors sas the symmetric difference between s and s in common err p ps in er and er or ps in er and p ss in er err p psl and p contains sas er p qq contained in p and q in err e r if ss in er otherwise qp note that the last three operations all quantification and that in some cases possible that the operation is totally with no input sets at all involve it is to see that these meet our intuition concerning the relational operations we require some notion concerning the evaluation mechanism for relational expressions the evaluation would be done tuple at a time and given the values of some of the selectors the mechanism would attempt to find values for the remaining selectors by a complete tuple from one of the operand subexpressions and then use the extra information so to fill in the remaining values from the other operand ensuring that the constraints required by the particular operation are met before returning the completed tuple to the invoking procedure for intersection we could use the given values on either operand with equal effectiveness and the values from one operand can be input into the other to obtain the complete tuple ex we relation int with selector x and effectiveness x and relation as in ex then to evaluate which has selectors x and sx using no inputs we must look to either inl or for a complete tuple int can provide it and this value x can then be supplied to to obtain the sx value the effectiveness of from the formula above is o x sx x sx which tells us we have a generator and with the description of how we would actually evaluate the expression for union we are not able to carry from one operand to help us other operand and any input values used independently on both operands over values evaluate the must be ex relation suppose that in addition to the already introduced we have a relation with selectors x effectiveness x x with selectors x sx tuples where and cx and cx then and cx contains either all or to use this relation a value for x is not enough given the value of x we can find one tuple from the relation by applying and separately but we cannot find all the tuples with this particular x we only require that one of the two relations is satisfied so for example applying to x would fill in the sx value to which we would then need to add all possible values for cx we could do this last by using a representation of the underlying set this possibility will be investigated in the next section here we assume that the underlying set cannot be used and so we are unable to the relation given only an x value however if we supply a pair of values and sx then we may be able to fill in x everything if it happens that sx is not equal to then applying to x will complete the tuple but if we are back in the earlier the relation situation and cannot the only under which we can effectively use the relation is if we are given all three values and the relation is used as a pure from the formulae we find that the effectiveness of is x sx cx which tells us that we only have a there are examples where union does provide more than a such as the combination of and where the selector cx of has been renamed sx then has selectors x x x and sx and has effectiveness sx when generalised union to a normal union s s becomes the empty set looking at the definition of effectiveness of union we see that p always contains s as and the effectiveness becomes greater the end of the last example was a case in point difference project and generalised project can all involve existential quantification the evaluation mechanism for this would involve the values for the selectors and then applying the relation over which quantification is made to test for the existence of a member ex to illustrate how quantification would be handled let us take a very simple example let us find the set of numbers sx for which there is x such that we will use the relation from examples and the set that we want ia obtained by projection and is sx with selector sx su pose that has effectiveness sx x if we a re given a value of sx to this to find a value of x if we find one or more values of x then sx we can if any we know that one exists and the value of sx is in the set and if no values of x are found then sx is not in the set clearly then sx is effective as a and we are using an effectiveness sx however suppose that the effectiveness of is xx sx a value of x can be obtained we are from cannot be input and the only way to obtain would be to use a representation of the set the selector x possibilities in this direction are taken up in the next section without using the underlying set representation is and thus sx unless it a value the if was stored explicitly as a table then it would have effectiveness x sx x sx in which case no input would be necessary and we could directly generate the set required the effectiveness b would be sx in all cases these formulae are obtained directly n from the formulae given above as explained above our interest in the effectiveness of relational expressions on whether or not they represent relations which are generators the test for this is whether contains the empty set the process which computes he effectiveness of an expression should also record the way this was obtained and thus record the particular evaluation process the relation can be generated relations as mappings from one of their components to all the components when the relations are stored explicitly as sets of tuples can be viewed as access paths in the sense of r note however that here we have been considerably more general in that all the data need not be stored explicitly with access paths in complex expressions one finds that many combinations of paths will yield the same result a small extension of our approach in computing the effectiveness of an expression will develop particular choices of access paths and given that different access paths have different a direct application of dynamic programming principles will select the best combination of a problem similar to this has been by and but without the theoretical foundations note that such of best access paths can be very as has been pointed out by hall in the context of optimization two results that can be obtained with our theory are interesting these are stated below without proof proposition represents operand n proposition if a relational a generator then of the expression is expression at least one also a generator relational expressions that are equivalent within the algebra have the same effectiveness c so far we have ignored the problem of infinite or potentially infinite relations if we allow the generation of infinite or indeed large relations we three problems one is the of explicitly infinite sets the others are more subtle the result of a complete expression can be finite even though some intermediate result is infinite if we were to generate fully the intermediate relation we would never terminate in using a generator as a we must be able to terminate in the case that the element is not in the set the termination problem needs solving the at a time evaluation mechanism gives a better solution then the complete evaluation of intermediate results but this is not enough consider for example the intersection of the infinite relation int with the relation small of selector x which is a pure for numbers less than is then finite containing all the integers less than but evaluation of would have to continue generating integers using int ad just in case small accepts another one we must exploit further information in order to be able to terminate the generation of int the solution that we offer is to orderings either partial or total on all sets however these orderings must be reasonable in the sense that they will be useful in the solution to our problem not all orderings will be acceptable for example for strings the usual ordering would be while the interpretation of strings as integers base r where r is the number of symbols is reasonable these orderings then induce partial orderings on all relations now to control the termination of the evaluation of relational expressions we propose to use pairs as bounds for relations we can then test an expression to the bounds for all the intermediate results given the bounds for the operands the method is obvious if all proceed with respect to their respective orderings then the bounds can be used to enforce termination upon potentially infinite relations the conversion of an generator for an infinite into a terminating is a classical problem and is solved by the method above orderings of the sets to detect termination case of non membership set using in the using the underlying sets in the discussion above we have assumed that the objects from a single underlying set u in discussing the effectiveness of the representation of relations we have not assumed concerning the representations of the sets however it is well known from recursive set that if the underlying set is represented by a generator then any of a set can be converted to a generator bv generating potential members of the set and then testing for membership before the element this is true for relations but in order to discuss this we will suppose that we have a collection of underlying sets q ui i in some index set j the single set of objects u treated so far is simply the union of these underlying sets ui tie now associate a single underlying set with each selector with a mapping d q for each selector we will talk of the effectiveness of the representations of the associated underlying set writing eds for selector s we note that representations of some underlying sets are necessarily only for example the real numbers and all other infinite sets while other underlying sets may be represented by either or generators we express the effectiveness of a representation for the underlying sets in exactly the same way as before writing eds either as s or s as appropriate we will not consider the case where the underlying set is not effectively represented with eds cartesian still be something associated u this relational products of the sets would written as us but now these mean much smaller since each selector is with a subset of universe of objects in turn affects the definitions of the definitions to the representations of the us are obtained from the representations of the individual sets again the effectiveness of these representations would be expressed as a set of input sets and thus the underlying sets can now appear in relational expressions to convert all representations as to generators as possible we then simply relations with the cartesian product underlying them using generalised intersection ex we extend ex representation of the selector x if this is ux to exploit the set underlying the possible we have x if the set underlying x is the real numbers then we necessarily have x a pure for the reals substituting this in the formula for the effectiveness of the representation of we have x x sx which is the effectiveness we had in ex however if the set underlying selector x is the represented by a generator we x x sx x sx the representation of th relation has become a pure generator as a result of exploiting the representation of the underlying set find underlying sets can also be exploited within relational operations this is important within generalised union because as we saw if underlying sets are not exploited then in general only a results the general strategy is to combine the underlying sets into the expressions using generalised intersection let us look at the ex again ex using the relations and as n ex we now exploit the underlying sets given a value for x we can now apply to this x to obtain the sx values and then use the representation of to generate values for the remaining component and we can apply to x and then fill in the third component using the relational expression that we are in effect exploiting is which has effectiveness x x sx x cx x sx cx the effectiveness that we can achieve is given by which is a generator this method for generating the tuples of the relation generates the tuples of the underlying cartesian product and then uses the as a to select only those tuples that we want note that the inside the union gives us an effectiveness like that we would have obtained had we exploited the underlying sets in the representations of the operands but we do obtain extra power from using the underlying sets at the union clearly an important of the use of underlying sets is deciding just where to use their representations most effectively without it and ending up with trivial and inefficient evaluation strategies similar use of the underlying for the other operations and useful in handling sets could is possible be very conclusions and open problems the theory that we have presented here forms the basis for the abstract syntax and semantics for a relational data base system the extension of the language to include the usual arithmetic operations and comparisons within the concrete syntax are now trivial for example the relation small of numbers less than could be directly written as while the relation which takes two values x and v to produce a third z which is their sum could be the usual assignment notation the effectiveness of these could be directly from the surface syntax and we might have for example the effectiveness of the adding relation as x y x y z in this last if we permitted stronger the usual effectiveness algebraic could be a we are however left with some problems the generalised union suggests the use of representations placing a in the positions where elements of the underlying set would be placed this then gives a finite representation of infinite sets the would play a matches anything role in the manner that is traditional in computing practice but here we appear to have a theoretical this has yet to be explored the evaluation mechanism has been presented informally this needs a precise formulation for example by using the techniques of this would enable both the derivation of effectiveness from more primitive notions and the application of termination theorems such as those of park the of effectiveness the most powerful that we could use could imagine partial representations a set of input values could compute not all of the remaining components developing a formalism to with it on the propositional calculus is not and we which given some of but we are this details of the algorithms for most effective representation have not been filled in an concerned with the of relations is still open obtaining for an associated of the the expression problem cardinality acknowledgements the of which led to this paper with a technical note b concerning how to implement first order functions on relations within the current experimental relational data base system at the ibm uk scientific centre the current system is based upon the traditional relational algebra and it soon clear that a complete of this approach was necessary during the course of the we had numerous discussions with at the scientific centre in particular we ideas concerning role names and how to model these which from selectors in the spirit of and peter free variables and relations as predicates we also thank john for discussions which our references rf dd wf iii mm specifying queries as relational expressions square ibm research report rj rf query language march dd a structured ibm research report rj g a p a language for a relational data base management systems proceedings of the annual princeton conference on information sciences and ef a relational large shared data pp model of data for comm acm june ef relational completeness of base in data base editor prenticehall data ef further of the data base relational model in data base systems editor prenticehall j relational for programming languages pp level data structures acts informatica hall identification ibm report common subexpression in general algebraic systems august p fundamental relations ibm report operations on may p and park induction rules and termination proofs in automata languages and programming editor m pp p p h method and notation for the formal definition of programming languages ibm lab tech rep tr june j c decomposition files a basis for data storage and ibm research report rj may of pm data management vol no pa systems the computer journal pp 