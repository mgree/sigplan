or the of all structured recursion schemes wu department of computer science university of oxford building oxford ox qd abstract the past have an extensive study of structured recursion schemes a general scheme is the which captures the essence of a problem is broken into by a coalgebra are solved recursively the are combined by an algebra to form a solution in this paper we develop a simple for recursive coalgebras which by definition ensure that their equations have unique solutions whatever the algebra our main tool is the rule a generic rule parametrized by an and a pair of natural transformations we show that many basic induce useful recursion schemes in fact almost every structured recursion scheme seems to arise as an instance of the rule further we adapt our to the more expressive setting of recursive coalgebras where the original input is also passed to the algebra the formal development is by a series of examples in haskell categories and subject descriptors d programming techniques applicative functional programming d programming languages language functional languages f logics and meanings of programs semantics of programming approaches to semantics general terms languages theory verification keywords recursion schemes introduction over years hoare observed that there are certain close between the methods used for structuring data and the methods for structuring a program which processes that data these the relationship between data structure and program structure is often expressed via structured recursion schemes which are widely used in functional languages such haskell although such schemes are less powerful than general recursion their importance the that functional programmers who are not interested in recursion patterns are like imperative programmers who use goto instead of for instance permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm even in haskell writing a nonterminating dynamic programming algorithm is all too easy using explicit recursion when this can be by using an appropriate recursion scheme canonical examples are provided by folds which consume data structures and which produce them solutions h and k of the following recursion equations h · in a · f h out · k f k · c which are by a base functor f these recursion schemes arise from constructions in which in and out are initial algebras and final coalgebras respectively and each correspond to both existence and uniqueness of solutions to the equations above traditionally written h a and k c folds and have been studied and are now well understood and widely used but they are rather restrictive patterns of computation thus there have been many extensions and combinations in an attempt to improve expressivity ultimately most of these are variations on a single the which arises as a solution to the equation this generalization comes with a catch there is no guarantee that a solution exists for a equation with a given coalgebra c and algebra a let alone that such a solution is uniquely determined a candidate solution is a · c but this only works if the of initial algebras and final coalgebras coincide a number of to the catch have been proposed over the years one could work in an compact category such as cpo then the of initial algebras and final coalgebras do coincide but one has to relax uniqueness of solutions to ordering them for example the least solution similarly one could work in a category such as rel again the coincide this time because final coalgebras are exactly the of initial algebras but again one has to to least solutions and deal with inequalities rather than equalities alternatively rather than restricting the setting in such ways we can instead constrain the programs under consideration in particular we can restrict ourselves to socalled recursive coalgebras those that by definition yield unique solutions to the equation whatever the algebra we can work with algebras those that yield unique solutions whatever the coalgebra this is a tradeoff only certain coalgebras or algebras are admissible but in return there need be no restriction on the setting and no to inequalities rather than equalities the cost side of the tradeoff is by providing a of techniques for the admissible components rather than requiring their to be proved from first principles for example because an initial algebra in is an isomorphism it has an inverse in and this inverse turns out to be a recursive coalgebra with c in are just folds so by itself this is not very interesting it becomes more interesting when we develop a powerful theory of constructions on recursive coalgebras as we set out to do our theory is based on and of course it all to algebras perhaps surprisingly the entire theory is based on only two tools which we call the rule and the rule the former applies when the base functor the recursion is composed from two other functors and allows the two functors to be the latter allows us to functors between the producer and consumer parts of the the rule is parametrized by an and a pair of natural transformations in a sense the recursion scheme can be considered the of all recursion schemes as almost every recursion scheme can be as an instance folds and folds with parameters and and generalized folds recursion schemes from and adjoint folds this is not the first time this topic has been visited and indeed most of the results in section appear in et al using different and distributive with substantially longer proofs we demonstrate that each of their schemes also arises by instantiating the rule to an that generates the indeed in many ways the present work extends the unification of structured recursion schemes presented in which showed that recursion schemes from are subsumed by adjoint folds rather the generalization from initial algebras to recursive coalgebras many of the proofs a distinct advantage of over is that the former compose we can build advanced recursion schemes out of simple ones by composing the underlying section folds are equivalent to the of primitive recursion where the input is also passed to the algebra however when we generalize initial algebras to recursive coalgebras this equivalence no longer holds practical considerations suggest that providing the inputs is useful and this us to extend the theory to include socalled recursive coalgebras there is also a dual variation corresponding to which allow the coalgebra to stop the recursion early here is where we feel the benefit of a unified approach we show that the and the rule can be generalized to this more expressive setting generalizing all of their instances in one go there is only one exception see section in summary this paper makes the following novel contributions · we unify and substantially simplify prior work on structured recursion schemes · we identify two central techniques for proving the uniqueness of a wide range of recursion equations · we generalize these techniques to the more expressive setting of recursive coalgebras the rest of the paper is structured as follows section provides some background category theory with an overview of important in section we discuss and introduce the two of our theory the rule and the rule we provide all of the proofs as they serve as templates for the development in section we support our claim that almost all known structured recursion schemes can be expressed as instances of the rule we illustrate the schemes through a number of haskell examples as we go more elaborate examples based on dynamic programming are given in section we then extend the theory in section to cover recursive coalgebras in particular we adapt the and the rule to the new setting we follow this with further examples in section finally section discusses related work and section concludes background this paper assumes a basic knowledge of category theory the reader should be familiar with the notions of functors and natural transformations in this section we fix the notation and establish the concepts that will be used in the remainder of the paper for the most part this material is standard and can safely be over on an initial reading except perhaps the material on algebras and coalgebras algebras and coalgebras form the basis for the categorical description of structured recursion schemes given an f c c a socalled base functor an is a pair a a where a f a a is an arrow and a c is an object which are known respectively as the action and carrier of the algebra we a little from the standard notation a a in order to have a syntax that distinguishes algebras from coalgebras since the action determines its carrier it is often used by itself to refer to the an between algebras a a and b b is an arrow h a b c such that h · a b · f h fa fh fb ab ab h compose and there is an identity so and form a category which we call the initial object of this category if it exists is given by in µf and called the initial implies that to each a a there corresponds a unique a in µf a a called a fold the algebra in is in fact an isomorphism so µf is a fixedpoint of f in a certain sense the least fixedpoint this fact is known as lemma given an g c c a is a pair c c where c c is the carrier and c c g c is the action of the coalgebra a between coalgebras c c and d d is an arrow h c d c that satisfies g h · c d · h just as before a category can be formed from and the final object of this category if it exists is given by g out and called the final the unique homomorphism to the c c called an unfold is written c c g throughout we use haskell as a for categorical constructions however we are careful to distinguish between inductive and coinductive types which haskell example the semantics of the inductive datatype tree defined data tree empty node tree z tree is given by the initial algebra in where the base functor data tree tree empty node tree z tree abstracts away from the recursive occurrences of tree the haskell of the isomorphism in the action of the initial algebra amounts to a simple renaming of constructors the category has more structure than c the or underlying functor c about the additional structure a a a and h h an analogous functor can be defined for coalgebras c and a functor h is called a lifting of h c d iff h h for the action on the carrier and on homomorphisms is fixed the action on the algebra can be specified using a natural transformation h f g h then the lifting h is by h a a h a · a h a h h h h since we use the action of an algebra to refer to the algebra itself we often abbreviate h a · a by h a h is a of h c d iff h h given h f g h we can define a as follows h c c h c c · h c h h h h were introduced by and are so in the study of category theory that mac noted adjoint functors arise everywhere our work supports this view provide a unified framework for program transformation given categories c d we say that functors l c d and r c d form an written l r c d or l c d r iff there is a bijection between the sets of arrows c l a b da r b that is natural both in a and b we say that l is a left adjoint for r and r a right adjoint for l the isomorphism is called the left and its inverse the right that the and are mutually inverse can be captured using an equivalence f g f g for all f l a b c and g a r b d the properties of the are alternatively expressed as fusion laws f g a b an alternative definition of is based on the natural transformations id and id which are called the l r id and the unit id r l of the all in all an consists of six entities two functors two and two units each can be defined in terms of the others g f id id lh rk a example and products arise as left and right × of the diagonal functor c c × c defined by a a a and f f f c c c c × the express that pairs of arrows with the same target respectively source are in correspondence with arrows from a respectively to a product in the case of products the left f f f f is known as the split combinator and the arises from the projections f f · g f f g a note that the equation on the left in a product category for products the fusion law a to k × k · f f · h k · f · h k · f · h both laws will be frequently used in b example perhaps the example of an is a function of two arguments can be treated as a function of the first argument whose values are functions of the second c c p the right adjoint of pairing with p is the exponential from p the function curry corresponds to the left c a × p b c a bp in set the object bp is the set of total functions from p to b left preserve initial objects l right preserve final objects r in general left preserve and right preserve limits example possibly infinite trees with branching structure determined by g and labels drawn from a constitute the a which arises as the right adjoint of the underlying functor c the action of a g a tail a maps a tree to a of subtrees the head extracts the label of the root of a tree and a a a constructs a tree the bijection instantiating expresses that the tree for a given start state and a given function expressed as a coalgebra is uniquely determined by a mapping from states to observations f head b · g f · a g for all f a a b and g a a b adjoint final coalgebras arise as a special conversely coalgebras can be implemented in terms of final coalgebras t b tail b with head b t b b is a g coalgebra if and only if t b head b tail b is a final where gb x b × g x it suffices to show that h a t b with head b · h hd is a homomorphism if and only if it is a homomorphism the proof is standard but head b · h hd tail b · h g h · tl is an isomorphism a head b · h tail b · h hd g h · tl product fusion b head b tail b · h hd g h · tl definition of gb and product fusion b head b tail b · h gb h · hd tl note that every is of the form hd tl since c · c · c consequently g b x b × g x this implies that head b tail b is an isomorphism we use cons b to denote its inverse as an aside the g b can be seen as the type of generalized because the tail is a of streams rather than just a single one we obtain standard streams for g id at the of several of our core proofs are natural transformations just as natural transformations relate functors relate adjoint pairs of functors given the l r c d and l r c d and functors h c c and k d d the natural transformations l k h l and k r r h are written if one of the equivalent equations f h g a b holds for all f l a b c and g a r b d an important property is that each component uniquely determines the other recursive coalgebras or for short are solutions to a recursion scheme that captures the essence of algorithms such algorithms have three phases first a problem is broken into by a coalgebra second are recursively and independently turned into and finally are combined by an algebra to form a solution the recursive call structure of the is determined by the common base functor of the coalgebra and the algebra depending on the shape capture etc in fact practically any program can be cast into the form however there is no a priori guarantee that a solution exists for a equation with a given coalgebra and algebra let alone that such a solution is uniquely determined basic definitions let f c c be an let a a be an and let c c be an an arrow h a c is a or homomorphism h a a c c if it satisfies the control functor f the recursive call structure we use a a c c or c c a a to denote the set of all that satisfy example the functor a can be used to model tail recursion a loop either terminates producing an a value or it goes through another iteration programs are captured by h id id · a h · c h id h · c where id id a a a is the socalled unlike algebra or coalgebra homomorphisms do not compose so they do not form a category however they do compose with algebra and coalgebra homomorphisms a ac aa c c a c fa fa fc fc ff fh fg fa fc f thus the assignment c c a a c c a a can be turned into a functor of type op × set we are particularly interested in situations where has a unique solution in general the algebra and coalgebra work to achieve uniqueness however at the extreme uniqueness can be shown by focusing on either the coalgebra or the algebra recursive coalgebras a coalgebra c c is recursive or if for every algebra a a there is a unique a a c c we denote such by a c to emphasize the source of uniqueness this notation is of that of folds since a recursive coalgebra provides a kind of a with any algebra homomorphism h a a b b yields again a unique h · a c b c the full of of recursive coalgebras is denoted example lemma states that the action of the initial algebra in µf has an inverse which implies h · in a · f h h a · f h · in consequently µf in is recursive and a a in algebras an algebra a a is or if for every coalgebra c c there is a unique a a c c we denote such by a c to emphasize the source of this uniqueness the full of of algebras is denoted for example the algebras recall that cons b out g head b and cons tail b b g b are with these definitions in place we proceed by describing two fundamental techniques for establishing uniqueness basic lemma which we call the rule and a symmetric version of proposition of which we call the rule indeed we will be careful to emphasize symmetry even though our main focus is on recursive coalgebras rule we now consider algebras and coalgebras where two functors compose to create the base functor the rule allows us to swap the underlying functors and establishes a means of deriving new recursive coalgebras and algebras from old ones we start with the situation described in the following diagram l r r c url l d r url l l r a since the base functors are compositions the functor l not adjoint has a trivial to categories of coalgebras recall that we need a natural transformation of type the identity will do l and likewise r the rule establishes an correspondence between two types of theorem rule assuming the data in a there is a bijection between the sets of l c c a a c c r a a b natural in c c r and a a l proof the correspondence is by the functions and defined x r x · c and y a · l y these trivially form a bijection between of and of x x y y where y x and x y unrolling the definitions we obtain x a · l r x · l c y r a · r l y · c which shows that x l c c a a and y c c r a a the proof of is straightforward the correspondence b allows us to conclude that l c c is recursive if c c is thus the l preserves and the lifting r preserves l l r a r l r b final recursive coalgebras an important special case of the rule is where we substitute l r f id we use this to prove the following theorem the recursive coalgebra c c is final if and only if c is an isomorphism the unique homomorphism from the recursive coalgebra c c to the final recursive coalgebra is written c which that this into a recursive coalgebra proof the inverse of c is the unique coalgebra homomorphism c f c using the rule we know that f c is recursive if c is recursive a c c f c fc c fc fc f fc f c f f c c d cd c c d fc fd f c d now c · c id because c c is final conversely c · c f c · f c id see diagram on the left above if c is an then c d is the unique coalgebra homomorphism to c c from the recursive coalgebra d d see diagram on the right above hence c c is final corollary the final recursive is µf in corollary is an important result as it allows us to freely mix folds a as with recursive c as rule the rule can only be applied when a pair of functors form the base functor of the coalgebra we can lift this restriction to simple f c c and g d d when there is an between c and d given l r c d and l g f l g r r f we have the following situation r fc l dg r l a using the we l to categories of coalgebras and lift r to categories of algebras the rule uses an to establish a correspondence between and unlike the rule does not require coalgebras that involve the composition of functors theorem rule assuming the data in a there is a bijection between the sets of l c c a a c c r a a b that is natural in c c and a a using the is a natural choice just as adjoint functors determine one another up to so too do it is this property that allows us to move between algebras and coalgebras proof we have to show x a · f x · l c x r a · g x · c c where is the left of l r x a · f x · l c a l c definition of and are isomorphisms x is natural a x a x x definition of lifting x r a · g x · c r a c of b is inherited from the the correspondence b between what we call implies that l c c is recursive if c c is thus l preserves r preserves l r a b moreover using our notation for c gives a l c r a c r a c a l c a b data and control functors the rule involves six functors and two natural can be a little when the l r is fixed what remains is the choice of functors f and g and the often one of the functors can be identified as a data functor as it is either part of the input or output type of a then there is a canonical choice for the other functor the control functor that the recursive call structure focusing on the input the framework of the rule can be instantiated with the data functor g d and the control functor f c l d r with the following pair l d l d c l d r d r r c the control functor c is obtained by going round in a see diagram a it is canonical in the following sense any equation x a · c x · l c with l d c l is equivalent to one that uses the canonical control functor for this particular instance the rule can be simplified using it is straightforward to show that r a a and c x · l c l d x · c thus c becomes x a · l d x · c x a · d x · c we can focus on the output then the roles of f and g are we instantiate the rule to f g d c with the canonical control functor c r d l and d l l c d l r d c r r d to illustrate the of the rule we instantiate the rule to the discussed in section since we focus on recursive coalgebras we consider instances of the equation x a · f x · l c a x lc a l c f a f l c fx and of this equation which builds on the canonical control functor a x lc x a · l d x · c a l c l d r a l d c l d x we already know that both equations have unique solutions if c is recursive we shall see that each of the induces a useful recursion scheme in fact almost every structured recursion scheme seems to arise this way an obvious exception being schemes that make use of the rule but that do not involve adjoint functors the reader is to instance law id id as a consider the id id for this trivial case a pair is given by a natural transformation g f id g f id g id id f then a to the socalled law a c which allows us to shift a natural transformation between the algebra and coalgebra part of a instance mutual recursion × c × c c mutual recursion describes the situation where a number of functions rely on one another in calculating their results example an example of mutual recursion is the algorithm consider a game where starting at the root of a finite tree the players take it in turn to choose whether the left or right branch of the tree is taken the final score is the sum of all the nodes that have been visited before the final leaf the task of one player is to this score while the other player tries to minimize it the two mutually recursive functions are minimize tree z empty node l v r v minimize l max minimize r minimize empty minimize node l v r v l min r these functions rely on each others results before to the next step example perfect trees another example of mutual recursion is where the dependence is asymmetric consider the function perfect which checks to see whether a tree is balanced perfect tree b perfect empty true perfect node l v r perfect l perfect r height l height tree z height empty height node l v r height l max height r height r the calculation of perfect depends on height but the result of height is independent of perfect in both examples the mutually recursive functions have the same source type and both use the coalgebra in which suggests instantiating the rule to the × when we pick the canonical control functor we obtain mutually recursive or for short given x x x and a a a equation to x a · d x · c x a · d x x · c a c x a · d x x · c a c the algebras a d a × a a and a d a × a a can themselves of the results of both recursive calls the coalgebra has to be the same and it must be recursive a special case of the is the where only one of the algebras is dependent on both results a a · d here is an variation on the the diagonal functor satisfies a simple property d d × d let us instantiate the rule to f g d × d d with id d d × d d × × d × d note that d d then equation to x a · d × d x · id c x a · d x · c a c x a · d x · c a c we obtain a system of two independent functions which appears however we can invoke a which gives us a c a c a · d a · d c as × a a a · d a · d we obtain a generalization of law an important program optimization that replaces a double recursion by a single one the law is called because the fold brackets look like and is split instance × p p c c a useful form of recursion is where an additional parameter an is passed in for use by the algebra example append our first example of recursion with a parameter is in the definition of cat which takes two lists and them together by structural induction on the first list cat a a a cat ys ys cat x xs ys x cat xs ys the second parameter is not changed during the recursion and is simply passed through until the base case is reached example tree a slightly more elaborate example is an efficient version of a tree of values into a list the naive version both subtrees independently and the results since is of linear complexity in its first argument the following variant is more desirable tree z z empty xs xs node l x r xs l x r xs the function off two new invocations of itself but only in the second does the parameter xs remain unchanged the handling of parameters is a case for the curry varying parameters using the canonical control functor equation to the x a · d x · c × p a c × p this models the situation where the parameter during the recursion a d ap × p a receives a of variants of x and can supply each of them with a different argument constant parameters the case where the parameter is passed unchanged can be modelled using the socalled strength of a functor d d d p p d the strength a d a × p d a × p a value across a structure every on set has a canonical strength for this data equation to x a · d x · c · c × p a c × p the strength copies the parameter to each of the recursive calls instance recursion the one remaining introduced in section that we have not yet discussed is it turns out that this instance gives us recursion we a discussion of interesting programming examples until section where we look at various dynamic programming algorithms this instance is more challenging as it involves coalgebras over coalgebras consider the categories involved fg c f the data functor is now a functor over for example the f where fg gf the corresponding canonical control functor is f f f g for this data equation to x a · f x · c a c d f f x a · f x · c a c d x x · d and definition of x a · f g x · d · c a c where a f g a a and c c d f c d the coalgebra c in f it is an that is simultaneously a homomorphism if we wish to apply this instance of the rule we have to ensure that c d c is a recursive f coalgebra the following lemma shows that f is actually a weaker notion than lemma let d be a full of let f d d and let c d c f then c c c d c f proof we have to show that the equation in h h a · f h · c a b c d has a unique solution for each f algebra a a b an f algebra is also known as a f coalgebras have been called if c c is a recursive we know that has a unique solution in c since d is a full of it suffices to show that h is a homomorphism of type a b c d b · h h solves h solves a f a b a b g a · g f h · g c · d c c d f c d g a · g f h · c · f d · c is natural g a · a · f g h · f d · c since x g a · a · f x · c has a unique solution as c is recursive we can conclude that b · h g h · d combining the rule and lemma we obtain corollary let c d c be a f coalgebra then c c c f d · c f an important special case arises if we identify f and g setting f g and id f f f f since a c c g c is also a homomorphism c c c c c the nested coalgebra c c c is a for this special case we can further simplify equation to x a · g g x · c · c a c operationally g c · c tail c · c builds a table of all reachable arguments of x the current one the x is then recursively applied to all of these making the results available to the algebra a g g a a in other words a can access the entire computational history implementing recursion it may seem somewhat odd that a potentially infinite structure is used for even though we know that c is recursive we come back to this point in section efficiency equation specifies the notion of recursion however it does not serve as a for an imple as it the naive recursive definition which typ leads to an exponential running time a first step towards an efficient implementation is to define x in terms of its x head a · x where x a · g x · c the x c c g a tail a builds an entire bottomup using a g a · g tail a this is a improvement but we can do better still avoiding the costly g a using the fact that x is a homomorphism we reason x a · g x · c tail a · x g x · c law and head a · a a head a · x a · g x · c tail a · x g x · c is an isomorphism a head a · x tail a · x a · g x · c g x · c product fusion b head a tail a · x a id · g x · c head a tail a is an isomorphism x cons a · a id · g x · c thus x cons a · a id c and consequently x head a · cons a · a id c this implementation builds an entire invoking a exactly once per node note that this does not depend on laziness combining up to now we have considered various recursion schemes in isolation of course in practice more complex algorithms are composed by combining different schemes consider as an example two mutually recursive functions of which one has a parameter x a · d x x · c x a · d x x × p · c × p one of the features of is that we can easily combine simple to form more complex ones the recursion scheme above for instance is given by id × × p × id × p c × c c which combines pairing l × l r × r and composition of l l r r do not be by the four occurrences of × the formula involves products both in cat eg id × p and in c eg × p indeed all of the machinery introduced for adjoint folds is immediately applicable here application dynamic programming i we now discuss two examples of recursion introduced in section via dynamic programming algorithms the problem a classic use of dynamic programming is to solve the unbounded problem the goal is to the total value of elements that are placed into a with a fixed weight c the elements are represented as a list of pairs w v where w is the weight and v is the value elements are unbounded in multiplicity the problem can be solved with the following recursion where is implicitly provided n r c maximum v c w w v w w c the value of a is determined by finding the item in that the total value while also decreasing the of the the function maximum returns when given an empty list and otherwise returns the maximum value in the list dynamic programming equations like by replacing the recursive calls with into a since the guard w w c ensures that the recursive calls are always on smaller arguments this into the framework of equation the base functor is g nat defined data nat nat zero succ nat and c is simply the final recursive coalgebra in n nat n the seen as the in of type of nonempty generates the of all predecessors in decreasing order for example for we obtain the succ cons succ cons succ cons zero to values from the we use lookup n nat v maybe v lookup cons a just a lookup n cons a zero nothing lookup n cons a succ as lookup n as table lookup amounts to an where the is the and the recursive coalgebra is in n nat n from the specification of we extract an algebra named the same to their relationship but in a different by making a case distinction on the structure of the and replacing boundary guards with pattern matching nat nat r r zero succ table maximum v u w v just u lookup w table the effect of lookup i table is to return the result that was computed i steps before the current point of call thus the key difference to the specification is that recursive calls with absolute indexing i are replaced by relative table lookup c i table where c is the current input the call c w is turned into lookup c c w table lookup w table which works out as the original input c is actually not available to the algebra now if we capture equation as a higherorder function functor f f f a a c f c c a a c head · h where h cons · a id · fmap h · c then the efficient implementation of is a in from now on we just present the algebra and omit this final step numbers the numbers determine how many distinct wellformed can be made with a given number of pairs of matching parentheses they are given by a simple recursive equation the results of splitting the parentheses at all possible points and computing a of the results of independent solutions n n n sum i n i i n this is an example since it illustrates a of the recursion scheme the upper bound for i depends on the input parameter but the input is not available to the algebra we present a here and approach the problem in a more way in section the basic idea is to store the arguments in the we use where fc is defined in haskell by type fc x c f x instead show in of the coalgebra section that id in we use id in is indeed a in n n we recursive coalgebra the algebra can then be written as follows n n n zero n succ table sum xs reverse xs where xs take n table the key here is that the algebra knows about the current depth of its application which is held in n thus the appropriate number of values can be extracted from the and to form a solution the function take n v v which the first step has a straightforward implementation we have shown that the examples can be implemented using recursion but there are some remaining issues in particular the lack of an absolute reference point in the recursion has made the expression of the algorithms somewhat in we were that the indexing was essentially relative to begin with but this is not always the case the root of the problem lies in the fact that the original argument of the is not available to the algebra the next section introduces a which will also allow us to replace infinite by finite coalgebras as we have seen are restrictive since the algebra can in general not access the argument of the it can the argument only in the special case that the coalgebra has a left inverse and indeed for initial algebras folds and socalled are for practical considerations we ensure that inputs can always be and focus on coalgebras of the form id c as these have the trivial left inverse basic definitions have your and it too recall that fc x c × f x let a a be an and let c c be an an arrow h a c is a or for short if it satisfies h a · id f h · c h a · fc h · id c the argument is passed both to the coalgebra c and the algebra a this is closely related to haskells patterns but note the c is a standard whereas a is an coalgebras the c c is recursive or for short if equation has a unique solution for each a a in other words c c is a if and only if c id c is a recursive the full of of coalgebras is denoted a coalgebra that is is also is a simple application of the law with fc f the converse holds if c has a left inverse then the is equivalent to a consequently the recursive coalgebra µf in is also the notion of we replace the product in the source type of the algebra by a in the target type of the coalgebra this allows the coalgebra to stop the recursion early cf example dual to fc we define fa x a f x let a a be an and let c c be an an arrow h a c is an or for short if it satisfies h id a · f h · c h id a · fa h · c algebras the a a is completely iterative if equation has a unique solution for each c c next we adapt the and rules to the new setting recall that both rules capture symmetric situations showing that certain preserve and certain preserve now the symmetry is broken in that we need two separate proofs for reasons of space we concentrate on coalgebras rule our goal is to show that x a · id l r x · l c a l c where a l c × l r a a and c c r l c has a unique solution if c is we take the same approach as in section and write the righthand side of the equation as a composition of two transformations x x where x y a · id l y clearly solutions of x x are in correspondence to solutions of y y however it is not immediate that the latter equation is actually a equation lets calculate y y definition of and y r a · id l y · c assumption r is see below y r a · · r id r l y · c product fusion b y r a · · c × id · id r l y · c the last equation is indeed a equation however we have to assume that are that there exists a natural transformation r a × r b r a × b such that · id id r id id because of this implies · r f r g r f g many but not all functors are for instance id p and are but is not we have established theorem assume the data in a if r is then l l r final and coalgebras theorem the coalgebra c c is final if and only if c is an isomorphism proof the proof is exactly the same as for recursive coalgebras theorem except that the rule is used to show that f c is if c is id is trivially corollary the final is µf in just as final coalgebras can be generalized to coalgebras final coalgebras can be generalized to recursive coalgebras which we write b g b tail b the functor arises as the right adjoint of the functor u c u c we have characterized g as the type of possibly infinite trees whose branching structure is determined by g roughly speaking g is the finite counterpart of g so the head extracts the root label of a tree and a a a constructs a finite tree g b µ x b × g x g b x b × g x the proof of the isomorphism on the left is almost the same as the one for the isomorphism on the right example we prove that t b tail b with head b t b b is a if and only if t b head b tail b is a final it suffices to show that h a t b with head b · h hd is a homomorphism if and only if it is a homomorphism head · h hd tail · h g h · tl see example head tail · h ga h · hd tl as the arrows now range over a there is one additional proof obligation we have to show that tl is a if and only if hd tl is a lemma let f c d and let c c be an then c c c f c proof first of all note that fc c × f and c × d × f c × d × f the isomorphism is by x × y × z x × y × z which is natural in z that is the proof then amounts to a simple application of the law with · id f × id fc again we apply the law this time with c × fc the characterization of g implies that head b tail b is an isomorphism we use cons b to denote its inverse recursion u when we discussed recursion in section we noted the that a potentially infinite structure is used for even though only recursive coalgebras are involved the turned into a for the examples in section as many desirable functions such as reverse are not total functions on coinductive types using g we can the problem as usual let us first consider the categories involved fg u c f the data functor is now a functor over f do not automatically preserve so this entails a proof obligation for the user of the scheme see also below the rest is however routine equation to x a · f g x · d · c a c where a f g a a and c c d f c d as an instance of the rule lemma is applicable and we record theorem let c d c be an f coalgebra then c c c f d · c f the special case where we identify f and g also works out the rule instantiated to l r g id implies that preserves consequently x a · g g x · c · c a c has a unique solution if c c g c is the coalgebra c has to be because it is used as an argument of the algebra a g g a a now receives a of finite that record the entire computational history rule right preserve limits in particular binary products recall that the functor r preserves products if r b × b with r and r natural is a product of isomorphism this implies that r b × b such there that is a · f f f f for all fi a r bi because of the rule can be adapted without further theorem assume the data in a then l proof the calculation for theorem we reason x a · id f x · l c a l c definition of x a · id f x · c · l c and are isomorphisms x a · id f x · c · l c is natural a x r a · id f x · c · l c r preserves products x r a · · id f x · c · l c is natural a x r a · · id f x · c · c b x r a · · id a · g x · c product fusion b x r a · · id × a · id g x · c r a c the proof works by to work on the x the rule allows for a unified treatment of most if not all recursion schemes now we feel the benefit of this unified approach using the rule generalizing the different schemes to is a piece of table summarizes our there is only one exception recursion this particular instance of the rule relates in the ambient category to in the category of coalgebras however for we need products but these do not necessarily exist in categories of coalgebras fortunately there is an easy way out we the treatment of recursion until section and first turn our attention to the easy cases in their most general form the recursion schemes build on the canonical control functor for the induced pair l d d r the equation becomes x a · id l d x · c a l c where a cc a a and c c d c the definitions c l d r and fc x c × f x the algebra a is assigned the type l c × l d r a a the entries in table specialize the equation above to various there is a slight for we use instead of id otherwise a would receive p twice this is a change recursion it remains to show that x a · id g g x · c · c a c has a unique solution if c is the proof is inspired by the treatment of numbers in section we integrate the arguments of x into the using gc to convert between different types of we make use of a natural transformation that changes the base functor let f g then f g is given by cons · id × · head tail since cons is is uniquely defined if all the necessary coalgebras exist c c c c can be turned into a higherorder functor whose action on arrows is given by the transformation the functor fusion property c · c c · c the proof is left as the exercise for the reader using functor fusion we can rewrite equation into the standard form for recursion x a · gc g x · c · id c functor fusion and · f g g x a · gc g x · · id c · id c gc g is natural x a · gc · gc x · id c · id c gc is a functor x a · gc · gc gc x · id c · id c the results of section imply that the latter equation has a unique solution if id c is recursive that is if c is as an aside the information noting type c × g g c × a a it receives the original argument and a that pairs each prior argument with its result which has potentially useful applications using an entirely analogous argument we can also show that the variant that uses a finite x a · id g g x · c · c a c has a unique solution if c is only the reason why the equations are uniquely defined changes we essentially replace the statement is unique as the algebra a is by is unique as the coalgebra c is consider the base transformer f g given by cons · id × · head tail this equation uniquely defines as tail is using the analogue of functor fusion c · c c · c we have x a · gc g x · c · id c see above x a · gc · gc gc x · id c · id c note that id c is used as an argument to by lemma we know that id c is if c is recursion scheme equation algebra law id id mutual recursion § finite § × × p p u x a · id d x · c · c a c x a · id d x x · c a c x a · id d x x · c a c x a · d x · c × p a c × p x a · id d d x · c · c a c x a · id d d x · c · c a c a a a a c × d a × a a a c × d a × a a a c × d ap × p a a c × d d a a a c × d d a a table different types of building on the canonical control functor the coalgebra is c c d c in each case application dynamic programming ii numbers we have hard to make the implementation of dynamic programming algorithms simpler and now we can the for the numbers we replace nat the type of nonempty by nat the type of nonempty lists since nat is an inductive type we can actually convert into standard nonempty lists nat v v cons a zero a cons a succ as a as this allows us to frame as an instance of where the coalgebra is simply in n nat n and the algebra implements a using the law with nat the algebra can actually work directly on lists nat n n zero succ xs sum xs reverse xs chain matrix multiplication in chain matrix multiplication we must find the minimum number of scalar operations required to multiply a chain of matrices a an where each matrix ak has dimensions given by ak × ak a p × q matrix by a q × r matrix yields a p × r matrix we assume scalar operations matrix multiplication is associative of course but different can lead to different costs the recurrence that solves this problem works by considering all the different splits and the combined cost chain n n n chain i j i j i j minimum ai ak aj chain i k chain k j k i j the final answer for this is held in chain n where n is the number of matrices that are being this is quite unlike previous examples since the input type is not immediately inductive to work around this we can show that it is isomorphic to an inductive type some bounds checking reveals that the domain of chain is actually a subset of n n since the function is only defined when i j thus the algebra needs access to only a of previous values that can be represented as a set of pairs t i j i j it is easy to show that there is an isomorphism n t between the set of pairs and the natural numbers and this gives us that t is initial where · in · nat thus the coalgebra is and with appropriate choice of can be given by t nat t i j i j zero succ j otherwise succ i j here we record an efficient version of that is based on the formula for numbers t n ni i nn t n i j j j div j i the definition of the algebra chain requires particular attention to the relative indices the base case is straightforward but when i j we must calculate the offset carefully chain t nat nat n n chain i j zero chain i j succ table i j i j minimum ai ak aj u v k i j just u extract i k just v extract k j where extract r s lookup i j r s table this definition closely the specification given by chain except that rather than being results are now extracted from the lookup table using lookup n nat a maybe a which like its coinductive counterpart is an although we are certain to have a unique solution not all proof obligations are yet naturally the correctness relies on whether the appropriate elements are indexed in the intermediate table the two examples have shown that the arguments provided to the algebra by coalgebras are particularly convenient for dynamic programming algorithms with indices related work recursive coalgebras the study of recursive coalgebras goes back to the work of on categorical set theory where he showed that every wellfounded coalgebra of the powerset functor is recursive taylor generalized this result to set functors that preserve inverse et al further demonstrated that for finitary set functors preserving inverse recursive coalgebras are equivalent both to recursive coalgebras and to the existence of homomorphisms into the initial algebra completely iterative algebras are dual to recursive coalgebras and were investigated by where we can the dual of some of the technical material in section and on of recursive relational coalgebras including applications to equations rule the of the rule can be traced back at least to the work of freyd on complete categories which was later extended by et al to form the categorical fixedpoint calculus however they only considered algebras and analyzed proof of the iterated square lemma and that an correspondence formed a core part of the proof he calls the correspondence a as form a he further generalized a weak form of the square lemma to recursive coalgebras rule an early instance of the rule can be found in the work of and in order to show that generalized folds are uniquely defined they discuss conditions to ensure that the equation x · l in x or equivalently x x · l in uniquely defines x two solutions are provided to this problem the second of which requires l to have a right adjoint technically our work is to the paper by et al on using recursive coalgebras as a tool for structured recursion which is essentially a generalization of results in they introduce the rule but do not use it to full effect relying on and distributive laws instead we apply the rule more leading to substantially proofs we can do so because we use rather than as our building blocks are a more flexible concept as they can be easily composed et al instantiate their theory to two main examples the product which gives rise to and the which gives rise to recursion we saw in section that are a special case of mutual recursion from the × section demonstrated that recursion arises out of the based on f which is more general they also discuss the socalled theorem which corresponds to our development of recursion in section similarly the work of and discusses the g which we covered in detail in section as an aside precisely fall out of the uz pz c c z between c and the slice category c z where the pairing functor pz is right adjoint to the functor uz in fact whatever the n we can apply the machinery of the construction and use the un c cn to integrate the recursion scheme into our framework such an approach the techniques of et al which further shows that our theory based on subsumes the use of but not the other way round for brevity we have not shown all interesting for example natural between parametric datatypes arise from the p between and the right extension covering generalized folds recursion schemes in this paper we have particular attention to recursion which was first captured as this scheme was identified as an instance of recursion in the of for use in dynamic programming was out in detail by although in an compact setting this was later modified to the setting of recursive coalgebras in both of these works focus on the efficiency of these schemes conclusion we believe that this work is a significant step towards a unifying theory of programming it is quite that all of the structured recursion schemes can be as instances of a single construction the title of all structured recursion schemes acknowledgments we are especially to the reviewers for their detailed comments and suggestions this work has been by grant number references j d and s recursive coalgebras of finitary functors and applications vol no pp ­ r and h termination proofs theory of comput sys vol no pp ­ r m r van and j van der categorical fixed point calculus in category theory and computer science lncs vol springer aug pp ­ r and o de algebra of programming prentice hall r and r generalised folds for nested datatypes form comput vol no pp ­ v t and v recursive coalgebras from comput vol no pp ­ a morphisms electronic notes in theoretical computer science vol no pp ­ m m and the vol no pp ­ p freyd complete categories in category theory notes math springer vol pp ­ t category theoretic approach to data types phd dissertation university of edinburgh r adjoint folds and extended study sci comput program vol no pp ­ r and n wu and in workshop on generic program acm pp ­ r n wu and j unifying structured recursion schemes in icfp acm pp ­ c a r hoare notes on data structuring in structured programming studies in data processing academic press pp ­ z hu h and m deriving structural from recursive definitions in icfp acm pp ­ j and v recursion schemes for dynamic programming in math of prog construction lncs springer pp ­ d m adjoint functors trans am math vol no pp ­ j a fixpoint theorem for complete categories math z vol pp ­ s mac categories for the working nd ed in mathematics springer g algebraic data types and program transformation phd dissertation university of data structures and program transformation sci comput program vol no ­ pp ­ l form comput vol pp ­ e m and r functional programming with lenses and barbed in functional programming languages and computer architecture lncs vol springer pp ­ s completely iterative algebras and completely iterative monads comput vol no pp ­ g categorical set theory a characterization of the category of sets j pure algebra vol no pp ­ a generic in ifip tc working conference on generic program vol academic pp ­ p taylor practical foundations of mathematics cambridge studies in math cambridge university press no t and v coding recursion à la in workshop on generic program pp ­ primitive and informatica sci vol no pp ­ the recursion scheme from the recursive electronic notes in theoretical computer science vol no pp ­ math structured functional program t v and a recursion schemes from j comput vol pp ­ v and t functional programming with proceedings of the of sciences mathematics vol no pp ­ 