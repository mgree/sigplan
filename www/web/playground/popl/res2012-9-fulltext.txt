probabilistic relational reasoning for differential privacy software institute abstract differential privacy is a notion of confidentiality that the privacy of while allowing useful computations on their private data deriving differential privacy guarantees for real programs is a difficult and task that calls for approaches and tool support approaches based on linear types and static analysis have recently however an increasing number of programs achieve privacy using techniques that cannot be analyzed by these approaches examples include programs that aim for weaker approximate differential privacy guarantees programs that use the exponential mechanism and randomized programs that achieve differential privacy without using any standard mechanism providing support for reasoning about the privacy of such programs has been an open problem we report on a framework for reasoning about differential privacy built on top of the coq proof assistant the central component of is a quantitative extension of a probabilistic relational hoare logic that enables one to derive differential privacy guarantees for programs from first principles we demonstrate the expressiveness of using a number of examples whose formal analysis is out of the reach of previous techniques in particular we provide the first proofs of correctness of the and exponential mechanisms and of the privacy of randomized and streaming algorithms from the recent literature categories and subject descriptors d programming languages formal definitions and theory f logics and meanings of programs specifying and verifying and reasoning about programs f logics and meanings of programs semantics of programming semantics denotational semantics program analysis general terms languages security theory verification keywords coq proof assistant differential privacy relational hoare logic introduction when dealing with private data one is with conflicting requirements on the one hand it is fundamental to protect the privacy of on the other hand the is to the utility of the data by and partial or aggregate permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm information eg for statistics research or differential privacy is a quantitative notion of privacy that achieves an tradeoff between these two conflicting requirements it provides strong confidentiality guarantees yet it is permissive enough to allow for useful computations on private data the key advantages of differential privacy over alternative definitions of privacy are its good behavior under composition and its weak assumptions about the prior knowledge of adversaries for a discussion of the guarantees provided by differential privacy and their limitations see as the theoretical foundations of differential privacy become there is to prove privacy guarantees for real systems several authors have recently proposed methods for reasoning about differential privacy on the basis of different languages and models of computation eg languages higherorder functional languages imperative languages the framework and io automata the unifying basis of these approaches are two key results i the observation that one can achieve privacy by the output of a deterministic program by a suitable amount of and ii theorems that establish privacy bounds for sequential and parallel composition of differentially private programs in combination both results form the basis for creating and analyzing programs by composing differentially private building blocks while approaches relying on composing building blocks apply to an interesting range of examples they fall short of covering the expanding frontiers of differentially private mechanisms and algorithms examples that cannot be handled by previous techniques include mechanisms that aim for weaker guarantees such as approximate differential privacy or randomized algorithms that achieve differential privacy without using any standard mechanism dealing with such examples requires finegrained reasoning about the complex mathematical and probabilistic computations that programs perform on private input data such reasoning is particularly and and calls for approaches and tool support in this paper we the foundations of differential privacy and provide a framework for finegrained reasoning about an expressive class of confidentiality policies including approximate differential privacy and probabilistic noninterference our framework is built on top of a framework to verify cryptographic proofs in the coq proof assistant goes beyond the in three fundamental aspects first takes a foundational approach that allows reasoning directly about the outcome of probabilistic computations this is key to its flexibility rather than being limited to a fixed set of building blocks one can define and use arbitrary blocks second allows to construct proofs from first principles this is key to its precision proofs in can rely on sophisticated machinery without any limitation other than being from first principles third inherits the generality of the coq proof assistant and allows modeling and reasoning about arbitrary domains and datatypes this is key to its expressiveness instead of being confined to a fixed set of datatypes can be extended on demand eg with types and operators for graphs requires that all intermediate reasoning steps are justified formally so that proofs can be verified independently and automatically by the coq type checker in order to illustrate the applicability of we present the first proofs of three representative examples i we prove the correctness of the and exponential mechanisms ii we prove the privacy of a randomized approximation algorithm for the minimum vertex cover problem and iii we prove the privacy of randomized algorithms for release of aggregate statistics of data streams taken together these examples demonstrate the generality and of our approach the starting point of our technical development is the observation that differential privacy can be as a quantitative property informally a probabilistic computation c is differentially private iff given two initial memories m and m that are sufficiently close the output distributions generated by c are related up to a multiplicative factor exp and an additive term more formally a computation c satisfies differential privacy with respect to a relation on memories iff for every pair of memories m m related by and for every event e pr c m e exp pr c m e where pr c m e denotes the probability of event e in the distribution obtained by running c on initial memory m this formulation of differential privacy is slightly more general than the standard definition however the latter is by letting the precondition capture of memories ie letting relate memories at distance at most for some adequate notion of distance our definition of differential privacy has two natural the first reading is as an information flow property indeed if is an equivalence relation and the definition states that the output distributions obtained by executing c in two related memories m and m coincide that an adversary who can only observe the final distributions cannot distinguish between the two executions the second reading of the definition is as a continuity property in case models between initial memories the definition states that c is a continuous mapping between metric spaces with the understanding that the universally quantified inequality above provides a measure of of the two output distributions in this paper we on both to provide a fresh foundation for reasoning about differentially private computations as a first step in our formalization we introduce the notion of distance distance generalizes statistical distance with a parameter and enables us to cast differential privacy as a continuity property in particular we show that a computation c is differentially private wrt a precondition iff is an upper bound of the between the output distributions obtained by running c on two memories m and m satisfying as a second step we define an approximate probabilistic relational hoare logic following use of relational logics to reason about information flow judgments in have the form c c and capture that is an upper bound on the distance of the probability distributions generated by two probabilistic programs c and c modulo relational pre and postconditions and on program states for the special case where is the identity on states c c c and exp the above judgment entails that the output distributions obtained by executing c starting from two initial memories related by are at distance at most and hence that c is differentially private wrt as further detailed in section this intuitive understanding of judgments extends to the important case where is an equivalence relation such judgments generalize simultaneously differential privacy and information flow and can be used to model confidentiality for a large class of adversaries under the view that the equivalence relation captures their observational capabilities for the general case the interpretation of judgments is based on the novel notion of lifting of relations on states to relations on distributions the definition generalizes existing notions from probabilistic process algebra and good closure properties from which we derive the soundness of the logic summary of contributions our contributions are on the theoretical side we the foundations for reasoning formally about an important and general class of approximate relational properties of probabilistic programs specifically we introduce the notions of distance and lifting and an approximate probabilistic relational hoare logic on the practical side we demonstrate the applicability of our approach by providing the first proofs of differential privacy properties of fundamental mechanisms and complex approximation algorithms from the recent literature organization of the paper the remainder of this paper is structured as follows in section we illustrate the application of our approach to an example algorithm section introduces the representation of distributions and basic definitions used in the remainder section presents the semantic foundations of while section presents the core proof rules of the logic section reports on case studies we survey prior art and conclude in sections and the coq development containing proofs of the results and examples presented here and an extended version of this paper with proofs of the key results can be obtained from example in this section we illustrate the applicability of our results by analyzing a differentially private approximation algorithm for the minimum vertex cover problem a vertex cover of an graph g v e is a set of vertices s v such that for any edge v w e either v s or w s the minimum vertex cover problem is the problem of finding a vertex cover s of minimal size in the version of the problem the goal is to output a good approximation of a minimum cover while the presence or absence of edges in the graph contrary to other optimization algorithms where the private data only determines the objective function ie the size of a minimum cover in the case of the minimum vertex cover problem the edges in the graph determine the feasible solutions this means that no algorithm can explicitly output a vertex cover of size less than n for a graph with n vertices for otherwise any pair of vertices absent from the output reveals the absence of an edge connecting them to overcome this limitation the algorithm that we analyze outputs an implicit representation of a cover as a permutation of the vertices in the graph this output permutation determines an of the edges in the graph by considering each edge as pointing towards the endpoint appearing last in the permutation a vertex cover can then be e f ld gc h ab b g e h l k j i f d c a figure a minimum vertex cover vertices in gray and the cover given by a permutation of the vertices in the graph vertices inside the area the of the edges is determined by in a distributed manner by taking for each edge the vertex it points to fig the algorithm that we study shown in fig is based on a randomized not approximation algorithm from that achieves a constant approximation factor of it is that no efficient approximation algorithm for the minimum vertex cover problem can achieve a constant approximation factor better than the idea behind this algorithm is to iteratively pick a random edge and add one of its to the cover set both the edge and the endpoint being chosen with uniform probability equivalently this iterative process can be seen as selecting a vertex at random with probability proportional to its degree the algorithm in fig is obtained from this base algorithm by the distribution according to which vertices are by a carefully weight factor that grows as more vertices are to the output permutation in the algorithm in the figure at each iteration the instruction v e n i chooses a vertex v from v with probability proportional to wi where denotes the degree of v in e and wi n ni put otherwise the expression e n i denotes the discrete distribution over v whose density function at x is de x wi de y wi consider two graphs g v e and g v e t u with the same set of vertices but in exactly one edge to prove that the above algorithm is differentially private it is sufficient to show that the probability of obtaining a permutation of the vertices in the graph when the input is g differs at most by a multiplicative factor exp from the probability of obtaining when the input is g we show this using the approximate relational hoare logic that we present in section we here the key steps in the proof a more detailed account appears in section to establish the differential privacy of algorithm vertex cover it suffices to prove the validity of the following judgment e e e function e n v nil i while i n do v e n i v v v v e e v × v ii end figure a differentially private approximation algorithm for the minimum vertex cover problem where def v v e e t u def assertions appearing in judgments like and above are binary relations on program memories we usually define as using predicate logic formulas involving program expressions when defining an assertion m m we denote by e resp e the value that the expression e takes in memory m resp m for example the postcondition above denotes the relation m m m m to prove the judgment above we show privacy bounds for each iteration of the loop in the algorithm proving a bound for the ith iteration down to proving a bound for the ratio between the probability of choosing a particular vertex in the lefthand side program and the righthand side program and its we distinguish three different cases and use the fact that for a graph v e e and the inequality x to derive upper bounds in each case a the chosen vertex is not one of t u and neither t nor u are in x x de de x wi x wi de y wi de y wi de de x x n n n exp n x x b the vertex v chosen in the iteration is one of t u we analyze the case where v t the other case is similar t t t t wi wi de de t e n te n wi w exp c either t or u is already in in which case both executions are observationally equivalent and do not add to the privacy bound x x x x case a can occur at most n times while case b occurs exactly once thus the bounds over all n iterations pr pr v v exp n i n exp pr pr v v exp exp the above informal reasoning is captured by a proof rule for loops parameterized by an invariant and a stable property of the product state of both executions ie a relation that once established remains true we use the following invariant note that if precondition above holds the invariant is established by the initialization code appearing before the loop t u e e t u e e t u v v and the following stable property t u the application of this proof rule requires to prove three judgments as premises corresponding to each one of the cases detailed above we detail them in section probabilities and reals in the course of our coq formalization we have found it convenient to reason about probabilities using the axiomatization of the unit interval provided by the library of and their formalization supports as primitive operations addition inversion multiplication and division and proves that the unit interval can be given the structure of a cpo by taking as order the usual relation and by defining an operator sup that computes the least upper bound of monotonic valued sequences in order to the between the of the unit interval and of the reals we have an pair between them and built an extensive library of results about the relationship between arithmetic operations in the two types eg addition x y r y inversion x r x multiplication x × y x y division if y then xy distributions we view a distribution µ over a set a as a function that maps a random variable a function in a to its expected value when applied to an event e a represented by its characteristic function e a corresponds to the probability of e when applied to an arbitrary function f a µf gives the expectation of f wrt µ for discrete distributions µ corresponds to the probability density of µ at a and we denote it using the shorthand the connection between density and expectation is given by the following equation µf f a aa formally a distribution over a is a function µ of type a together with proofs of the universally quantified properties monotonicity f g µ f µ g compatibility with inverse µ f µ f where is the constant function additive linearity f g µ f g µ f µ g multiplicative linearity µ k × f k × µ f continuity if f n a is monotonic then µ sup f sup µ f note that we do not require that µ and thus strictly speaking our definition corresponds to distributions this provides an elegant means of giving semantics to runtime assertions and programs that do not terminate with probability one we let da denote the set of distributions over a and µ denote the null distribution distributions can be given the structure of a monad this monadic view eliminates the need of definitions and proofs involving and allows to give a continuationpassing style semantics to probabilistic programs formally we define the unit and bind operators as follows unit a da def x f f x bind da a db db def µ m f µ x m x f the unit operator maps x a to the distribution that assigns probability to x and to all other elements of a while bind takes a distribution on a and a conditional distribution on b given a and returns the corresponding distribution on b in the remainder we use the following operations and relations range p µ def f a p a f a µ f µ def bind µ x y unit x µ def bind µ x y unit y µ µ def f µ f µ f the formula range p µ states that elements of a with a nonnull probability wrt µ satisfy predicate p for a distribution µ over a product type a × b µ resp µ defines its projection on the first resp second component finally defines a natural order on da first principles distance of distributions in this section we define the notion of distance a parameterized distance between distributions we show how this notion can be used to express differential privacy differential privacy and statistical distance we begin by the standard distance between two real numbers a and b defined as a b b b a with a parameter namely we define the distance a b between a and b by a b def b b a note that is nonnegative by definition and that coincides with the standard distance between reals we extend to a distance between distributions as follows definition distance the distance µ µ between two distributions µ and µ in da is defined as µ µ def max µ f µ f f a the definition of distance universally over all functions the next lemma shows that for discrete distributions this definition is equivalent to an alternative definition in which quantification ranges only over functions ie those corresponding to characteristic functions of events lemma for all distributions µ and µ over a discrete set a µ µ max µ e µ e ea an immediate consequence of lemma is that coincides with the standard notion of statistical distance ie µ µ max µ e µ e ea differential privacy is a condition on the distance between the output distributions produced by a randomized algorithm namely for a given metric on the input space differential privacy requires that for any pair of inputs at distance at most the probability that an algorithm outputs a particular value differs at most by a multiplicative factor exp approximate differential privacy this requirement by additionally allowing for an additive the following definition captures these requirements in terms of distance lemma establishes the equivalence to the original definition definition approximate differential privacy let d be a metric on a a randomized algorithm m a db is differentially private with respect to d iff a a a da a a m a notice that differential privacy corresponds to differential privacy it is that for discrete domains the definition of differential privacy is equivalent to its pointwise variant where one over characteristic functions of singleton sets rather than those of arbitrary sets however this equivalence breaks when considering approximate differential privacy the following lemma provides a way to establish bounds for distance and hence for approximate differential privacy in terms of characteristic functions of singleton sets note that the inequality is strict in general lemma for all distributions µ and µ over a discrete set a µ µ aa we conclude this section by stating some important properties of distance these properties are used for reasoning about approximate lifting and proving the soundness of our logic all properties are implicitly universally quantified lemma properties of distance µ µ µ µ µ µ µ µ µ µ µ µ µ µ or else µ µ µ µ µ µ µ µ µ µ bind µ m bind µ m µ µ most of the above properties are we briefly the most important ones property generalizes the inequality with appropriate factors states that distance is with respect to states that probabilistic computation does not increase the distance which is a wellknown fact for statistical distance approximate lifting of relations to distributions the logic we present in the next section can be used to establish assertions about probabilistic programs wrt pre and postconditions on states in order to give meaning to these judgments we need to interpret postconditions as relations between distributions over states rather than as relations between states to this end we define the lifting of a relation to distributions intuitively two distributions µ da and µ db are related by the lifting of r a × b whenever there exists a distribution over a × b whose support is contained in r and whose first and second projections are at most at distance of µ and µ respectively definition lifting let r and the lifting of a relation r a × b is a relation over da × db defined as follows range r µ µ r µ def µ µ µ µ µ µ µ µ µ we say that a distribution µ satisfying the above conditions is a witness for the lifting the notion of lifting generalizes previous notions of such as the lifting from which is obtained by taking and and lifting which is obtained by taking the next lemma shows that lifting is monotonic wrt the the factor and the relation r an immediate consequence is that for lifting is more permissive than the previously proposed notions of lifting lemma for all and and relations r s µ r µ µ s µ we next present a fundamental property of lifting which is central to the applicability of to reason about distance and hence differential privacy namely two distributions related by the lifting of r yield probabilities that are within distance when applied to functions we say that two functions f a and g b are related by a relation r a × b and write f r g iff for every a a and b b r a b implies f a g b theorem fundamental property of lifting let µ da µ db and r a × b then for any two functions f a and f b µ r µ f r f µ f µ f in particular if a b and r is the identity relation µ µ µ µ theorem provides an interpretation of lifting in terms of distance next we present two results that enable us to actually construct such the first result is the converse of theorem for the special case of r being the identity relation we prove that two distributions are related by the lifting of the identity relation if their distance is smaller than this result is used to prove the soundness of the logic rule for random assignments given in the next section theorem let µ and µ be distributions over a discrete set a if µ µ then µ µ the proof is immediate by considering as a witness for the lifting the distribution with the following density function a if a a if a a the second result shows that compose this result allows to derive a judgment relating two programs c and c by introducing an intermediate program c and proving the validity of judgments relating c and c on one hand and c and c on the other this approach is used in the examples of section and more extensively in cryptographic proofs see eg theorem let µ µ and µ be distributions over discrete sets a b and c respectively let r a × b and s b × c for all r and µ r µ µ s µ µ rs µ where def max and denotes relation composition for the proof let and be witnesses for the judgments on the lefthand side of the implication then the distribution µ defined by the following density function is a witness for the lifting on the righthand side c b b b c we conclude this section with an observation on lifting for equivalence relations yi and show that for equivalence relations their definition of lifting coincides with the more intuitive notion that requires the two distributions to yield equal probabilities on all equivalence classes formally if r is an equivalence relation over a discrete set a then µ r µ a a µ a µ a where a denotes the class of a a this characterization extends naturally to arbitrary and µ r µ a a µ a µ a the characterization for arbitrary is more involved and is presented in the extended version approximate relational hoare logic this section introduces the central component of namely an approximate probabilistic relational hoare logic that is used to establish privacy guarantees of programs we first present the programming language and its semantics we then define relational judgments and show that they generalize differential privacy finally we define a proof system for deriving valid judgments programming language supports reasoning about programs that are written in the typed procedural probabilistic imperative language formally the set of commands is defined inductively by the following clauses i v e v de if e then c else c while e do c v pe e assert e c skip i c assignment random sampling conditional while loop procedure call runtime assertion nop sequence here v is a set of variable identifiers p is a set of procedure names e is a set of expressions and de is a set of distribution for the sake of readability we omit procedure calls from most of the we keep them in the description of the language because we use them to describe the algorithm in fig and its analysis skip m unit m i c m bind i m c xe m unit m e mx assert e m x µ m if e m true then unit m else µ bind µ m v unit m vx if e then c else c m c m if e m true c m if e m false while e do c m f sup n while e do cn m f where while e do c skip while e do cn if e then c while e do cn figure semantics of programs expressions the significant of compared to besides the addition of runtime assertions is that the interpretation of distribution expressions may depend on the program state this allows to express programs that sample from dynamically probability distributions such as the one presented in section the semantics of programs is defined in two steps first we give an interpretation t to all object types t these are types that are declared in programs such as the graph type in the example in section and we define the set m of memories as the set of mappings from variables to values then we implement dependently typed evaluators that give the semantics of an expression e of type t a distribution expression µ of type t and a command c respectively as functions of the following types e m t µ m d t c m dm informally the semantics of an expression e takes a memory and returns a value in t the semantics of a distribution expression µ takes a memory and returns a distribution over t and the semantics of a program c takes an initial memory and returns a distribution over final memories the semantics of programs with the expected equations figure provides an validity and privacy is an approximate probabilistic relational hoare logic that supports reasoning about differentially private computations judgments in are of the form c c where c and c are programs and are relations over memories r is the and is the in our formalization we use a shallow embedding for logical assertions allowing us to inherit the expressiveness of the coq language when writing pre and postconditions an judgment is valid if for every pair of memories related by the precondition the corresponding pair of output distributions is related by the lifting of the postcondition definition validity a judgment c c is valid written c c iff m m m m c m c m the following lemma is a direct consequence of the fundamental property of lifting theorem applied to definition it shows that statements about programs derived using imply bounds on the distance of their output distributions lemma if c c then for all memories m m and functions f f m m m f f c m f c m f the statement of lemma can be specialized to a statement about the differential privacy of programs corollary let d be a metric on m and an assertion expressing that dm m if c exp c then c satisfies differential privacy corollary is the central result for deriving differential privacy guarantees in using theorem one can prove the converse to corollary yielding a characterization of approximate differential privacy the logic can also be used to reason about more traditional informationflow properties such as probabilistic noninterference to see this let be an arbitrary equivalence relation on initial states and let be the identity relation on final states a judgment c c entails that two initial states induce the same distribution of final states whenever they are related by in particular this implies that an adversary who can observe or even repeatedly sample the output of c will only be able to determine the initial state up to its equivalence class in this way can be used for expressing finegrained notions of confidentiality including probabilistic noninterference our interpretation of judgments generalizes to arbitrary equivalence relations as postconditions in this way one can capture adversaries that have only partial views on the system as required for distributed differential privacy we finally show how can also be used for deriving generalized of probabilistic programs as a first step we show that valid judgments imply statements for input distributions that are related by lifting lemma if c c then for all distributions µ and µ of initial memories we have µ µ bind µ c bind µ c by instantiating pre and postconditions in lemma to the identity relation on memories and applying theorems and one obtains the following generalized for probabilistic programs on random inputs corollary if c c then µ µ bind µ c bind µ c logic this section introduces a set of proof rules to support reasoning about the validity of judgments in order to flexibility and to allow the application of proof rules to be interleaved with other forms of reasoning the soundness of each proof rule is proved as a coq lemma nevertheless we retain the usual presentation of the rules as a proof system we present the core rules in figure all rules generalize their counterpart which can be by setting and any valid derivation admits an immediate translation into we begin by describing the rules corresponding to language constructs the skip assert and rules are direct of the rules rule rand states that for any two distribution expressions µ and µ of type a the random assignments x µ and x µ are related wrt precondition and postcondition x x provided the distance between the distributions µ m and µ m is smaller than whenever m and m are related by the soundness of rule rand follows from theorem rule seq has tight connections to composition theorems for differentially private algorithms as further developed in sec tion rule cond states that branching statements are related wrt precondition and postcondition provided that the precondition ensures that the guards of both statements are equivalent and that the true and false branches are related wrt preconditions b and ¬b respectively the rule for loops may be best understood by taking in this case the rule while states that two bounded loops that execute in are n private when their bodies at each iteration are private and n is an upper bound for the number of iterations the rule while is sufficient for proving differential privacy of examples like the from where the remains unchanged at each iteration other examples like the ones discussed in the next section require applying more sophisticated rules in which the and the may vary across iterations for instance the rule shown in figure allows for a case analysis depending on a predicate p on program memories whose validity is preserved across iterations assume that when p does not hold the iterations of each loop can be related with a privacy factor of i in case p does not hold after their execution and with a privacy factor of in case it does furthermore assume that the iterations are observationally equivalent when p holds initially then the two loops are related with a privacy factor of in i intuitively as long as p does not hold the iterations of each loop are private while the single iteration where the validity of p may be established this occurs necessarily at the same time in both loops an ln privacy the remaining iterations preserve p and do not add to the privacy bound we continue by the structural rules given in figure the rule case allows one to perform a case analysis in the precondition of a judgment the weakening rule weak generalizes the rule of consequence of relational hoare logic by allowing to increase the and its soundness follows from lemma the composition rule comp permits to structure proofs by introducing intermediate programs as in the technique for cryptographic proofs its soundness follows from theorem together with rule it yields a rule for the case when and are partial equivalence relations which specialized to reads c c c c c c finally the frame rule allows one to the pre and postcondition with an assertion whose validity is preserved by executing the commands of the judgment in the figure the notation × is used to denote the product of two distributions sequential and parallel composition theorems composition theorems play an important role in the construction and analysis of differentially private mechanisms a central result states that an differentially private query followed by an differentially private query to the same corresponds to a single differentially private query an important variant of this result deals with the case in which both queries access disjoint parts of the this socalled parallel composition of queries leads to a stronger max privacy bound both composition results admit a natural interpretation in which we present below we begin by introducing additional notation that allows us to express independence of computations and observational capabilities of adversaries for a set of variables z v we define the m m def m e mx m e x e x e mx m m m m x µ x µ µ m x µ m x rand b b assert b assert b b assert c c c c c c c c seq skip skip skip c c b c c ¬b if b then c else c if b then c else c b b cond c c b b b b m m m m while b do c m while b do c nn while b do c b b ¬b ¬b while b do cn m while c c c c c c ¬ case c c c max c c c comp c c c c weak c c c c c c m m m m range c c c m × c m frame figure core proof rules of the approximate relational hoare logic b b p p i i m m m m while b do c m while b do cn m c assert ¬p j c assert ¬p b i j ¬p i j c assert p c assert p b i j ¬p i j c c b i j p i j p while b do c an ia while b do c i a ¬b figure generalized rule for loops relations z and z as follows m m zz m m def def y z m y m y z z m zz m note that m z m corresponds to dz m m where dz measures the number of variables in z in which two memories differ ie their distance using this notation we can interpret judgments of the form c exp c x y as a definition of a computation c on variables in x that is differentially private wrt adversaries that can only observe variables in y similarly we can interpret judgments of the form c exp c x x y as a definition of a family indexed by x of computations c on variables in x that are differentially private wrt adversaries that can only observe variables in y to emphasize the roles of the sets x y and y we say that c is a computation from x to y that is parameterized by y finally we interpret premises of the form c c x x c c x x as a statement that c does not modify variables in x note that this reading of premises is sound but stronger than the actual semantics the sequential composition theorem is a direct application of rule seq and is captured by the rule with the intuitive reading introduced above the rule states that the composition of an differentially private computation c from x to y with a parameterized differentially private computation c from x to y is an differentially private computation c c from x to y y provided that c does not modify variables in y and c does not modify variables in x the parallel composition theorem is captured by the rule c c c yx x x c c c c y x y c c yx x x x y y with the intuitive reading introduced above the rule states that the composition of an differentially private computation c from x to y with a parameterized differentially private computation c from x to y where x is disjoint from x is a max differentially private computation c c from x x to y y as a we require that c does not modify variables in x and is wrt input variables x and output variables y and that c does not modify variables in y and is wrt input variables x and output variables y case studies we illustrate the of our framework by formalizing two mechanisms namely the and the exponential mechanisms and proving their correctness from first principles we then apply these mechanisms to prove differential privacy for several streaming algorithms finally we detail the proof of differential privacy of the minimum vertex cover algorithm introduced in section exponential and mechanisms many algorithms for statistics and data are numeric ie they return approximations of real numbers the mechanism of et al is a fundamental tool for making such computations differentially private this is achieved by the algorithms true output with drawn from a distribution the density function at x of the distribution around r with scale factor is proportional to exp x r to transform a deterministic computation f a r into a differentially private computation one needs to set r to the true output of the computation and choose ie the amount of according to the sensitivity of f informally the sensitivity is a that captures how far apart f maps inputs formally the sensitivity sf is defined relative to a metric d on a as follows sf def max f a f a aa the justification for the mechanism is a result that states that for a function f a r the randomized algorithm that on input a returns a value from the distribution around f a with scale factor sf is differentially private one limitation of the mechanism is that it is confined to numerical algorithms the exponential mechanism is a gen mechanism for building differentially private algorithms with arbitrary but discrete output domains the exponential mechanism takes as input a base distribution µ on a set b and a function s a × b r intuitively values b sa b are the most output for an input a the exponential mechanism is a randomized algorithm that takes a value a a and returns a value b b that approximately the score sa b where the quality of the approximation is determined by a parameter formally the exponential mechanism maps every element in a to a distribution in b whose density function at b is given by b exp sa b µ b exp sa b µ b bb the definition implicitly assumes that the sum in the is bounded for all a a and show that is private where ss is the maximum sensitivity of s wrt a for all b in our proofs the exponential and mechanisms are defined as instances of a general construction · that takes as input a function f a b r and returns a function f a db such that for every a a the density function of f a at b is given by f a b f a b f ab bb we derive the correctness of the and exponential mechanisms as a consequence of the following lemma lemma let b be a discrete set and consider a function f a b r such that f is well defined let a a a be such for all b f a b f a b and f a b f a b then if moreover f a f a bb f a b bb f a b then f a f a using the construction · defined above the exponential mechanism for a function s base distribution µ and scale factor is defined as def a b exp sa b µ b whereas the mechanism with mean value r and scale factor is defined as lr def a b exp b a r the privacy guarantees for the exponential and the mechanisms are stated as the rules and exp in figure their soundness is a corollary of lemma above observe that the premise of rule requires to prove that the values around which the mechanism is are within distance k this is the case when these values are computed by a function starting from adjacent inputs which corresponds to the usual interpretation of the guarantees provided by the mechanism as a further illustration of the expressive power of we have also defined a mechanism ln for lists given r and a vector a rn the mechanism ln outputs a vector in rn whose ith component is drawn from distribution more formally we have proved the soundness of the following rule m m ai m ai m k in x k exp y k x y which we refer to as statistics over streams in this section we present an analysis of algorithms for computing private and statistics in a data stream as in we focus on algorithms for private and counting more sophisticated algorithms eg computing heavy in a data stream can be built using sums and counters as primitive operations and inherit their privacy and utility guarantees we consider streams of elements in a bounded subset d r ie with x y b for all x y d this setting is slightly more general than the one considered by chan et al where only streams over are considered on the algorithmic side the generalization to bounded domains is immediate for the privacy analysis however one needs to take the bound b into account because it conditions the sensitivity of computations this requires a careful definition of metrics and propagation of bounds which is supported by although in our implementation we formalize streams as finite lists we use in the for the sake of m m x lr k r m y r m lr k k exp x y m m d x a m y a m k x y exp figure rules for the and exponential mechanisms readability given an array a of n elements in d the goal is to release for every point in time j n the aggregate sum cj j i ai in a manner as observed in there are two immediate solutions to the problem the first is to maintain an exact aggregate sum cj and output at each iteration a version cj b of that sum the second so is to maintain and output a aggregate sum cj which is updated at iteration j according to aj b cj cj aj the stream c · · · cn offers weak because every element of a may appear in n different ele ments of c each with independent however each cj offers good accuracy because is added only once in contrast the stream c · · · cn offers improved differential privacy be cause each element of a appears only in one differentially private query however as shown in the sum cj yields accuracy because is added j times during its computation one solution proposed by chan et al is a combination of both basic methods of partial sums that achieves a good between privacy and accuracy the idea is to split the stream a into chunks of length q where the less accurate but more private method is used to compute the sum within the current chunk and the more accurate but less private method is used to compute summaries of previous chunks formally let st q i at q i be the sum over the chunk of a and let st lst b be the corresponding version then for each j qr k with k q we compute r k cj st i t i the sequence c · · · cn offers differential privacy intuitively because each element of a is accessed twice during computation moreover cj also offers improved accuracy over cj because is added only r k times rather than j qr k times we will now turn the above informal security analysis into a formal analysis of program code the code for computing st is given as the function in figure the code for computing c is given as the function in figure and the code for computing c is given as the function in figure we omit the code for computing c and the proof of its privacy bound we next sketch the key steps in our proofs of differential privacy bounds for each of these algorithms for all of our examples we use the precondition def a a i i ai ai b which relates two lists a and a whenever they have the same length differ in at most one element and the distance between the elements at the same position at each array is by b the proof of differential privacy of proceeds in two key steps first we prove using the fragment of that c c s s b function s i while i do s s ai i i end s ls b figure a simple differentially private algorithm for over lists where c corresponds to the code in lines in figure ie the initialization and the loop we apply the rule that gives a bound for the privacy guarantee achieved by the mechanism see figure to c s ls b the instruction in line and derive c exp c s s b s s using the rule for sequential composition applied to c and c we derive the following statement about which implies that its output s is differentially private exp s s our implementation of in figure differs slightly from the description given above in that we first add to the entire stream line before computing the partial sums of the stream lines this modification allows us to take advantage of the proof rule for the mechanism on lists by merging the addition of into the loop our implementation can be turned into an observationally equivalent implementation suitable for processing streams of data the proof of privacy for proceeds in the following basic steps first we apply the rule to the random assignment in line noted as c of we obtain c exp c a a ie the output a is differentially private at this point for lines denoted by c we prove using the fragment of that c c a a s s this is straightforward because of the equality appearing in the precondition this result can be derived using the rules but is also an immediate consequence of the preservation of distance by probabilistic computations see lemma finally we apply the rule for sequential composition to c and c and obtain exp s s which implies that the output s of is differentially private our implementation of the smart private sum in figure makes use of and as building blocks which enables us to reuse the above proofs in addition our implementation makes use of a procedure that given two lists s and x a constant c and nonnegative integers i q returns a list which is identical to s but where function a b s a i while i do si si ai i i end figure an differentially private algorithm for partial sums over lists function q i c while i do b x s x c iq q c c b i i end figure a smart differentially private algorithm for partial sums over lists the entries si · · · si q are replaced by the first q elements of x plus a constant offset c ie for i q we obtain s x c i q s x c i q s s we combine this result with the judgments derived for and using the rule for sequential composition obtaining c exp c s s where c denotes the body of the loop in lines to conclude we apply the rule for while loops in fig with i and exp this instantiation of the rule states that a loop that is in all but one iteration is differentially private if the loop iteration is differentially private more technically the existence of a single iteration is built into the rule using a pair of stable events for each command in our case the critical iteration corresponds to the one in which the chunk contains the position in which the two lists differ minimum vertex cover we conclude this section with a more detailed account of the proof of differential privacy of the minimum vertex cover approximation algorithm of section the main step of the proof is an application of the rule for loops in fig with parameters i exp n exp the following invariant t u e e t u e e t u v v and stable properties p p t u the first and second equivalences appearing in the premises of the rule are of the form c assert p c assert p for each of them we first the assertion immediately after the random assignment at this point the expression in the assertions becomes t u v in the case of the first premise and t v u v in the case of the second we then compute the weakest precondition of the assignments that now follow the assertions the resulting judgments simplify after applying the weak and frame rules to judgments of the form c c v v where def e e t u v v t u i i j for the first premise we have j and c v e n i assert t u v whereas for the second premise we have and c v e n i assert t v u v to establish the validity of both judgments we cast the code for c as a random assignment where v is from the interpretation of e n i restricted to v satisfying the condition on the assertion in the first case the restriction amounts to v u t whereas in the second it amounts to v t v u for each one of these cases we apply the rule for random assignments and are thus left to prove that the distance of the corresponding distributions is null in view of lemma this in turn amounts to verifying for each element x in the support of the distribution that the ratio between the probability of v being equal to x in the lefthand side resp righthand side program and the righthand side resp lefthand side program is bounded by which directly translates into the inequalities appearing in section technically these inequalities are proved by to a variant of lemma the proof in yields a bound of rather than the bound from this difference is due to the symmetric nature of our logic we believe that the optimal bound can be proved in at the cost of a more complicated proof by using rule comp to introduce intermediate programs or more by using an asymmetric version of see the appendix for a discussion on what it would take to build an asymmetric logic and how it could be used to improve the privacy bound from to just related work our work builds upon program verification techniques and in particular probabilistic and relational program logics to reason about differential privacy we briefly review relevant work in these areas differential privacy there is a body of work on differential privacy we refer to recent see eg for an account of some of the developments in the field and focus on languagebased approaches to differential privacy the privacy integrated queries platform supports reasoning about the privacy guarantees of programs in a simple language the reasoning is based on the sensitivity of basic queries such as select and the differential privacy of building blocks such as and and for their sequential and parallel composition these building blocks for distributed computations based on the linear type system of extends sensitivity analysis to a higherorder functional language by using a suitable choice of metric and probability monads the type system also supports reasoning about probabilistic differentially private computations as in the soundness of the type system makes use of known composition theorems and relies on assumptions about the privacy of nontrivial building blocks such as arithmetic operations conditional swap operations or the mechanism while the type system can handle functional data structures it does not allow for analyzing programs with tional branching work on the automatic derivation of sensitivity properties of imperative programs addresses this problem and can in conjunction with the mechanism be used to derive differential privacy guarantees of programs with control flow although this approach supports reasoning about probabilistic computations the reasoning is restricted to in contrast to supports reasoning about differential privacy guarantees from first principles in particular enabled us to prove rather than to assume the correctness of and exponential mechanisms and the differential privacy of complex interleavings of not necessarily differentially private probabilistic computations a recent approach considers the verification of privacy properties based on there the focus lies on the verification of the correct use of differentially private sanitization mechanisms within interactive systems where the effect of a sanitization mechanism is soundly abstracted using a single transition an early approach to quantitative confidentiality analysis uses the distance of output distributions to quantify information flow their measure is closely related to approximate differential privacy which can be about in more recent approaches to quantitative informationflow focus on measures of confidentiality based on entropy techniques for structural reasoning about these measures are developed in for an overview and a discussion of the relationship between measures of confidentiality and differential privacy see probabilistic and relational program verification program logics have a long and have been used effectively to reason about functional correctness of programs in contrast privacy is a safety property that is a universally quantified property about two runs of a program there have been several proposals for applying program logics to safety but these proposals are confined to deterministic programs and a paper a relational hoare logic for a core imperative programming language and shows how it can be used to reason about information flow properties of programs this line of work has been generalized to a probabilistic setting by which formalizes an extension of for probabilistic programs builds upon and significantly extends the most difference between the two frameworks is that supports reasoning about a wide range of quantitative relational properties whereas is confined to information flow properties although we make a use of this feature supports for a richer language the certified program transformations that are implemented in thanks to a recent development the construction of proofs in can be achieved efficiently using a frontend that generates automatically probabilistic derivations using smt solvers and a verification condition generator there are opportunities to exploit the between and as further discussed in section there is also a growing body of work that uses proof for reasoning about properties of probabilistic algorithms for instance and formalized in the hol system a theory for reasoning about a probabilistic extension of guarded command language and used it to prove the correctness of the test future work and conclusions is a framework that supports finegrained reasoning about an expressive class of privacy policies in the coq proof assistant in contrast to previous languagebased approaches to differential privacy allows to reason directly about probabilistic computations and to build proofs from first principles as a result achieves flexibility expressiveness and reliability and appears as a starting point for capturing and analyzing formally new developments in the field of differential privacy an immediate objective for future work is to use the technique from for verifying in the privacy of multiparty computation algorithms where one is concerned with ensuring privacy against computationally bounded adversaries that only have a partial view of the state concretely the local state of participants this objective is within reach since inherits from a formalization of probabilistic polynomialtime algorithms and can already capture this variant of differential privacy another for further research is to the verification of differentially private computations there are three to this work building an automated checker for derivations automatically inferring relational loop invariants and implementing a precise dependency analysis for an optimal usage of existing composition theorems provides an starting point for these tasks acknowledgments this work was partially by european projects fp and fp project project and project references p and c proofs of randomized algorithms in coq sci comput program ­ g and b bounds for differentially private mechanisms in rd ieee computer security foundations symposium pages ­ ieee computer society g b and s formal certification of cryptographic proofs in th acm sigplansigact symposium on principles of programming languages popl pages ­ new york acm g b s and s security proofs for the working in advances in ­ volume of lecture notes in computer science pages ­ springer a k and e distributed private data analysis simultaneously solving how and what in advances in ­ volume of lecture notes in computer science pages ­ springer m and p the security of triple encryption and a framework for proofs in advances in ­ volume of lecture notes in computer science pages ­ springer n benton simple relational correctness proofs for static analyses and program transformations in st acm sigplansigact symposium on principles of programming languages popl pages ­ new york acm th h chan e and d private and release of statistics in th international colloquium on automata languages and programming icalp volume of lecture notes in computer science pages ­ springer s s gulwani r and s proving programs robust in th joint of the european software engineering conference and the acm international symposium on foundations of software engineering acm d s and p a static analysis for information flow in a simple imperative language journal of computer security ­ m r and f b journal of computer security ­ j f and m approximate analysis of probabilistic processes logic simulation and games in th international conference on quantitative evaluation of systems pages ­ ieee computer society c differential privacy in rd international colloquium on automata languages and programming icalp volume of lecture notes in computer science pages ­ springer c differential privacy a survey of results in theory and applications of models of computation volume of lecture notes in computer science pages ­ springer c a foundation for private data analysis acm ­ january c k f i and m our data ourselves privacy via distributed generation in advances in ­ volume of lecture notes in computer science pages ­ springer c f k and a smith to sensitivity in private data analysis in rd theory of cryptography conference volume of lecture notes in computer science pages ­ springer a gupta k f a and k differentially private combinatorial optimization in st annual symposium on discrete algorithms pages ­ siam j a and c morgan probabilistic guarded commands mechanized in hol theor comput sci ­ b w yi and k g probabilistic extensions of process algebras in j a and s editors of process algebra pages ­ amsterdam s p and a smith a note on differential privacy defining to arbitrary side information report d and a no free in data privacy in international conference on management of data pages ­ acm press f and k mechanism design via differential privacy in th annual ieee symposium on foundations of computer science pages ­ ieee computer society f d privacy integrated queries an extensible platform for data analysis in th international conference on management of data pages ­ new york acm i o o and s computational differential privacy in advances in ­ volume of lecture notes in computer science pages ­ springer a d c and h approximate noninterference journal of computer security ­ l a simple probabilistic approximation algorithm for vertex cover technical report tr yale university n ramsey and a stochastic lambda calculus and monads of probability distributions in th acm sigplansigact symposium on principles of programming languages popl pages ­ new york acm j and b c pierce distance makes the types grow stronger a calculus for differential privacy in th acm sigplan international conference on functional programming icfp pages ­ new york acm i s t v a v and e security and privacy for in th usenix conference on systems design and implementation pages ­ berkeley usenix association a sabelfeld and d sands probabilistic noninterference for multithreaded programs in th ieee workshop on computer security foundations pages ­ ieee computer society r and a approximated computationally bounded simulation relations for probabilistic automata in th ieee computer security foundations symposium pages ­ t and a aiken secure information flow as a safety problem in th international symposium on static analysis sas volume of lecture notes in computer science pages ­ springer the coq development team the coq proof assistant reference manual version online ­ m c d and a formal verification of differential privacy for interactive systems electronic notes in theoretical computer science ­ a asymmetric logic asymmetric versions of can be obtained by distance as a b def a and in definition either of the inequalities µ µ µ µ the second inequality yields a logic for which the validity of a judgment c c implies only that for m m st mm and f f st f f c m f c m f application to the minimum vertex cover problem an asymmetric version of the logic would allow to prove in an independent way that for any permutation v exp is a bound for both the ratio pr v pr v and its each ratio could be bounded by applying an asymmetric version of the rule for while loops shown in figure and each application would in turn require to independently bound for each iteration the x x and x x this would allow to choose values for the parameters and in each case eg when bounding one could take i and whereas when bounding its one could take i and exp 