access permission contracts for languages university of germany inria and peter university of germany abstract the ideal software contract fully specifies the behavior of an operation often in particular in the context of languages a full specification may be to state and may not even be desired in such cases a partial specification which describes selected aspects of the behavior may be used to raise the in an implementation of the operation to a reasonable level we propose a novel kind of contract for languages that specifies the side effects of an operation with access permissions an access permission contract uses sets of access paths to express read and write permissions for the properties of the objects accessible from the operation we specify a monitoring semantics for access permission contracts and implement this semantics in a contract system for javascript we prove soundness and stability of violation under increasing aliasing for our semantics applications of access permission contracts include enforcing modularity development program understanding and testing with respect to testing and understanding we find that adding access permissions to contracts increases the effectiveness of error detection through contract monitoring by categories and subject descriptors d software engineering verification assertion checkers programming by contract d programming languages formal definitions and theory semantics general terms algorithms design languages reliability theory verification keywords languages contracts javascript introduction design by contract is a methodology for software development based on specifications contracts of operations the correctness of an implementation with respect to a contract may be statically guaranteed by program verification or it may be dynamically checked via contract monitoring as the latter variant permits more expressive specifications and puts less demands on the theorem proving of the programmer it is widely used in practice as by implementations of contract checking in various forms and for many languages ­ research was done while at university of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm figure example hierarchy originally contracts were meant to provide full specifications however contracts for partial specifications which only fix certain aspects of an operation also have their uses for example in a language like scheme or javascript a contract could have the form of an expressive type signature and impose restrictions similar to a type system contract monitoring for such type contracts detects type errors at operation boundaries a type contract has one important it only imposes restrictions on the values passed to an operation and returned from it in an imperative language like scheme or javascript many operations have an effect on the heap which is not captured by a type contract for those operations a contract that also specifies the effect would be more appropriate in the past this has driven the evolution of type systems towards effect systems that enable the specification and inference of side effects eg in analogy we propose to extend type contracts with a notion of effects and to check them with an notion of monitoring in this paper we develop a notion of effect suitable for languages and for javascript in particular the application scenarios that we have in mind are enforcing modularity development program understanding and testing effects for languages like other languages javascript implements an object as a reference to a map from properties to values where some of the values may be objects again every read or write access to the resulting object graph can be described by a base object a path a sequence of property names and a classifier indicating the operation on the last step of the path read or write this observation has lead us to define effects by access permissions that specify a set of paths that an operation may read or write relative to some base object in scope the base object may be this an argument of the operation or a global variable as an example consider a javascript implementation of the class hierarchy described by the class diagram in fig the layout operation computes the screen position of each it accepts a pair of absolute starting and returns the width and height of the as a side effect it stores the bounding box of each in its representation a programmer working on the code of this operation might like to that the layout computation only ever changes the bounding box properties of a by the following contract to the layout operation int int w int h int with this contract specifies an operation that accepts two integers returns an object with two integer properties named w and h and modifies at most the x y w and h properties of objects reachable through this furthermore the contract allows the operation to read all properties reachable through this a write path has to match the entire access permission whereas a read path is accepted if it matches a prefix of the permission more precisely this specifies the base object the path components matches any sequence of property names and is a regular expression that matches the names of the properties with write permission here are some further conventions for reading access paths parameters can be specified as base objects for a path by name or using a notation the symbol is short for the regular expression that matches any property name a path ending in indicates a readonly path application scenarios regarding the application scenarios contract monitoring for the layout contract is useful during the initial development of the code because any violation of the access permission an exception as part of a test run it is also useful for program understanding a programmer who would like to that the layout operation works in the outlined way would impose the contract and for failing test cases the access permissions also indicate what operations are independent of one another for example an operation that marks those which are visible in a given might have a contract like this vx int int vw int vh int any with the path grants read access to any property of the first parameter but no write permission only the bounding box of a may be read and only its visible property may be written only l and r properties may be traversed recursively along the last two paths in testing changes to the code that violate the contract are detected early in a run of a test suite assuming sufficient coverage last but not least modularity javascript programs often rely on a number of libraries and freely include code that may change arbitrarily between different program runs programmers do not want this code to their global variables or to arbitrary changes on their object structures a contract around the code these effects and guarantees the integrity of the programs state monitoring of effects there are two approaches to defining a semantics of monitoring for an access permission the semantics permissions to each object location it traverses the object graph starting from the base object according to the access paths and registers a read or write permission according to the paths classification for each object property along the path in contrast the semantics pairs each object reference with an access path and computes the permission at a readwrite access based on the path through which the object has been reached in the absence of aliasing the semantics is equivalent to the semantics in general however the semantics differ which indicates that they serve different purposes the following example the differences it is further in sec suppose an object is reachable from the base object via two different paths where one path grants write permission for property p but a second path only grants read permission to p with the semantics the path used to access the object determines the permission but which permission should be granted by the semantics if p gets write permission then an execution that at the object via the read path can write if p only gets read permission then an execution that at the object via the write path cannot write to prevent this behavior in the second scenario the semantics must assign the least restrictive permission of all paths reaching p a similar may arise between no permission and permission to read both location and semantics are nontrivial to implement efficiently with the semantics the of a contract requires that the locations of all objects reachable through the contracts access paths must be marked with access this marking cannot be delayed because aliasing may provide a into a data structure on which the contract grants read or write permission in the worst case the time needed to a contract is bounded only by the size of the entire object graph a read or write operation can be implemented in almost constant time in contrast the semantics requires time linear in the number of contracts for each read and write operation whereas the of a contract takes constant time read operations are a bit because they have to access paths in the right way see sec this paper the semantics because it is the semantics of choice for our intended application scenarios as explained in sec the semantics most likely has a role to play in monitoring access control in a security scenario but it is based on a different set of assumptions and a separate investigation is required to explore it contributions design of a contract framework with access permissions specification of a formal semantics of access permissions and their dynamic enforcement formal proof that the semantics guarantees stability of access violations under addition of aliasing subject to conditions prototype implementation of access permissions with monitoring in a contract and testing framework for javascript based on program transformation of the effectiveness of access permission contracts by observing the impact of random code modifications on case studies practical evaluation of the approach on different code bases a technical report extends this paper by an appendix with further examples proofs of all theorems a definition of the semantics a sketch of its application to the security scenario and additional information regarding the case studies outline in sec we explain the design choices underlying our contract framework with examples and explore some of the alternatives section presents a formal framework for reasoning about access permissions it presents an operational semantics of contract monitoring and formally defines and proves two properties that are consequences of the design choices section explains the basic approach taken by the implementation the evaluation in sec the effectiveness of access permission for detecting programming errors using mutation testing design choices for each programmer an access permission has an intuitive meaning that coincides with the intuition of other programmers in the of cases these differ when aliasing comes into play because each programmer has different application scenarios in mind each with its own requirements to the semantics as already indicated in the introduction our intention is to employ access permissions as partial specifications of a programs effect we regard it as a dynamic counterpart to previous work on static effect systems this intention the four major design choices we have taken for the monitoring semantics for access permissions access an access permission grants the right to read or modify a property of an object depending on the path through which the object has been reached dynamic extent an access permission for a function is in force for the of a function activation an access permission only applies to objects and paths in the heap at the time when the contract is update a property assignment keeps the access paths of the value on its righthand side the rest of this section explains the choices in depth gives a critical overview of the alternatives and thus provides a for the design of our framework access an access permission grants the right to read or modify a property of an object depending on the path through which the object has been reached this choice has two consequences reference permissions are attached to individual references not to heap locations that is if two variables or properties hold a reference to the same object then accesses through each variable may have different access stability of violation an access violation is preserved under increased aliasing see sec for a formal statement section already in of the semantics here we give a concrete example where the semantics behaves different from a static analysis c obj obj any with function hx y ya yb violation function h var o a b ho o any modular attempt to verify hs access permissions statically for example using the dynamic frame rule of and cannot assume that xy without this assumption the analysis would fail because the contract the access to yb in line the semantics is consistent with such an analysis any invocation of h in particular the call from h a contract violation regardless of the aliasing among the arguments we call this behavior stability of violation with the semantics h would not trigger a violation as x and y are aliased their underlying location would obtain permission to write properties a and b and the two assignments would go through without violation furthermore the semantics breaks stability of violation calling h without aliasing as in h detects a violation function h h a b a b in a security setting the semantics appears better suited because a permission like seems to rule out any access to the location property of the window object even if this object has been reached via some alias however the following example demonstrates that this is c obj any any with function kx y y violation function k as x and window are aliases of one another the permission x grants write permission for all properties of window and the permission grants write permission for all properties of window except location hence the semantics permits writing to in the body of k for the record the semantics does not trigger a violation either for all x any property of x may be read and written for window all properties except location may be read and written the body of k does not these permissions so no violation can happen dynamic extent an access permission for a function is in force for the of a function activation if a permission is attached to a function then each invocation of the function an instance of the permission and this same instance is at the matching function return as a consequence permissions get refined in a chain of function calls because an access permission expresses the that the function does not its permissions each additional function call can only restrict the accessible properties further for example consider these functions c obj any with xa function dx return xa violation if called from d c obj any with function dx return dx the contract of function d any access to its argument invoking d with any object a violation of ds contract when trying to execute line although this line is in d which has a more permissive contract as another consequence a closure returned from a function is not restricted by the access permission of the function for example consider the permission of f in this code fragment c obj any with xb function fx return function return xa xb function f var r f a secret b r running the function f which is unrestricted because there is no contract associated with f returns secret it does not violate the contract of f because the access to xa happens outside the dynamic extent of the call to f in line the choice for dynamic extent is inspired by the distinction between direct and latent effects in static effect systems evaluation of the function expression in line does not cause an access to xa or xb for this reason a static effect system this effect as a latent effect and places it on top of the function arrow in its type when the function is applied the effect is however at that point there is no contract in force that would restrict the effect on the other hand the following variant of the program fragment leads to a violation function gx return function return xa xb c obj any with xb function gx var r gx r violation as the invocation of r happens in the extent of the invocation of g its permission with xb is in force and the violation by accessing xa is detected in contrast the function g by itself does not impose any restriction on accesses to x so that a direct call to g does not lead to a violation an alternative design would consider access permissions as having static extent determined by lexical scope and have closures capture the permissions in force at their definition site this design seems more appropriate in a security setting and it would report violations for the examples involving functions f and g an access permission only applies to objects and paths in the heap at the time when the contract is one immediate implication of this choice is that the program can access and modify newly allocated objects without restriction as these objects are not present in the heap at time the the contract does not restrict access to them this behavior is analogous to the treatment of the clause and newly allocated objects in we see two alternatives to this design but consider neither to choose a different reference heap or to choose a different interpretation of access paths the only other reference heap for a contract would be the of a function that is the heap at the time the contract is however the final heap is not a sensible choice because the programmer expects the paths in a contract to refer to the situation at the time a function is invoked the final heap may exhibit very different paths another interpretation of access paths might consider the permissions as symbolic paths that may be traversed regardless of the changes in the underlying heap this interpretation violates the programmers intuition and it is inconsistent with static verification as the following example shows c obj obj any with xa ya function bx y ya xa allowed reading just the contract a programmer expects that does not change however the symbolic interpretation of paths would not flag the assignment in line which changes counter to the expectation of the programmer in contrast a static verification of access permissions keeps track that ya is really xa in line and the function the interpretation is consistent to static verification and reports a violation update a property assignment keeps the access paths of the value on its righthand side a property assignment of the form xp y where y refers to an object creates a new path through xp to the object graph reachable from y update means that the access information for y is kept along with the reference so that a subsequent access through xp is considered an access through y this choice is with the rule for assignment p xp y p for suppose that p is the predicate location is reachable from location via some path and y then a suitable candidate for p is location is reachable from location via some path and xp y here is an example c obj any with function lx xa xb function l var x a b lx in this code fragment line is clearly permitted as xa may be assigned to and xb may be read the following read access to xa in line returns the reference to the object that was accessible through xb when the permission was as this object is the one that was reachable via xb in the the access permission for xb counts so that the assignment to is by the path thus function l runs without violation things look different in a slightly modified version of the example that creates the alias before the permission c obj any with function mx var y xa ya violation function m var x a b xa xb mx in this case running m yields a violation while the first read access to xa in line is by xa the write access to property a of this object is not indeed this behavior is consistent with invoking m on an object without any aliasing which reports a violation under any semantics formalization a formal semantics of monitoring for access permissions is needed as the basis of an implementation that to the design choices for that reason we define the calculus as a callbyvalue lambda calculus extended with objects and access permissions for the semantics runs both examples l and m without a violation variable x var property name p prop access path path prop path language l path expression e expr x xe ee new ep ep e permit x lr lw in e figure syntax this calculus we specify the semantics including monitoring and prove that it to the properties stated in sec in particular and stability of violation lets fix some notation before we start given sets a and b we write a for the power set of a a b for the disjoint union of a and b and a × b for their cartesian product a b denotes the set of finite partial functions from a to b with for the empty mapping and if f a b then a denotes the domain of f and f a denotes the restriction of f to a a the updated function f f a b is defined by f a b and f a f a for all a a we also write a b a b for the singleton map with domain a if we write f a as part of a premise this use implies the additional premise a syntax figure specifies the syntax of the calculus extends a callbyvalue lambda calculus with object construction new creates a fresh object of properties reading of an objects property and an objects property the syntax is close to that of existing javascript core languages the novel construct of the calculus is the access permission expression permit x lr lw in e that restricts accesses through variable x during evaluation of e by the two languages lr and lw both languages specify a set of access paths sequences of properties starting from the object bound to x which must be in scope read accesses to descendants of x are limited to paths in lr whereas write accesses are limited to paths in lw evaluation of e stops if it tries to perform any access that is not permitted the read language lr should be prefix closed because it does not make sense to permit reading of without to read xa too similarly writing to is not possible without reading xa first so each path in the write language lw should extend a path in the read language by one property that is lw p lr p prop our implementation restricts lr and lw to regular languages so that the word problem is decidable for them furthermore contracts with access permissions can only be attached to functions and a contract can state multiple permits in one go semantics figure defines the semantic domains and the inference rules for a bigstep evaluation judgment of the form r w h u e h u v this judgment declares that given a variable environment and indexed collections r and w of read and write permissions the expression e transforms the initial heap h to the final heap h and returns value v furthermore it threads a time stamp u u stamp that is at each property write operation and at each permit expression the permission collections r and w are indexed by the time stamps of the heaps for which the permissions were granted the time stamp of a permission uniquely identifies different executions of permit expressions and determines their relative order with respect to heap modifications semantic domains loc infinite set of locations u stamp integer h heap loc obj obj prop stamp × val p r w stamp m n stamp path m ref loc × v val ref env × expr env var val checking permissions check permission u mu pu p evaluation rules var r w h u x h u x lam r w h u xe h u xe app r w h u e h u xe r w h u e h u v x v r w h u e h u v r w h u ee h u v new domh r w h u new h u put r w h u e h u m r w h u e h u v w mp h h h p u v r w h u ep e h u v get r w h u e h u m r mp r w h u ep h u mp h p permit ru lr wu lw h u e h u v x x u r w h u permit x lr lw in e h u v figure semantics a value v val is either a reference or a closure consisting of an environment and a lambda expression the representation of a reference is a pair of a heap address and a collection m of access paths indexed by time stamps the collection m records all permitted access paths that have been traversed during evaluation so far to obtain this reference value the indexing is again used for marking modifications with time stamps this representation is by the design choice of path dependency see sec a heap maps a location to an object and an object maps a property name to a pair of a time stamp and a value the time stamp indicates the time of the write operation that last assigned the property it is required to implement the update from sec the evaluation rules var lam and app for variable lambda abstraction and function application expressions are standard they m u v m u n if v n v if v ref m un u mn uu if u if u u u if u u u if u if u undefined if u v m n m if v n v if v ref n mu mu if u n u if u figure auxiliary definitions thread the time stamp and propagate the permissions r and w unchanged to their if any the evaluation rule new creates a new object in the heap the new object has no properties and its collection of access paths is empty the latter indicates that the newly created object is com unrestricted following sec any of its properties may be read or written the time stamp does not change when allocating a new object because no object in the current heap is modified the put rule specifies the operation that writes and if defines a property it first computes the location and the collection m of access paths of the object and then checks the write permission to the object with the premise w mp it the objects property with the new value and assigns it a new time stamp to implement the update sec hence the time stamp of a property is always the time of its last update the rule get defines the read operation of object properties it relies on some auxiliary operations defined in figure it first expects e to evaluate to a reference m which denotes the base object for the property read in this reference is the heap address of the object and m contains a collection of access paths for the object corresponding to heap traversals reaching this object one path for each active access permission the other premise r mp checks the read permission for these paths extended with property p this check is specified by rule check permission which requires that for each active access permission with time stamp u the current access path for u is an element of the set of permitted access paths for u ie pu if the read operation is permitted then there are two if the property contains a closure then this closure is the result of ep however if the property contains an object reference say n then this read operation has discovered that the paths in mp are also access paths for object the reference value returned from the read operation must merge the different ways to reach via n and via mp computing the desired collection of access paths depends on the last time u when the property p was updated this is required to to the property sec the operator in fig implements the required op its righthand argument the contents of an objects property u v where u is the time stamp of the last update and v the stored value its lefthand argument is the collection m mp of newly discovered paths to the property if v is not a reference then just returns v as already discussed otherwise v n in which case it returns the location with the collection of paths computed by the operator u applied to the new paths m and the old paths n in an application m u n the first argument m contains the access paths that were detected when checking the read access the second argument n contains the access paths as they are stored in the heap at location the subscript u is the time stamp of the last write to the property the definition in figure distinguishes three cases depending on when the property has been written last and what access paths were given to the written value let u be the time stamp of an execution of a permit expression the objects property value already has an access path for index u in n thus the property has been after the of u in this case a potential new access path for u in m is ignored instead the existing access path is returned according to the property sec as it reflects an access path at the time when the permission attached to u has been the objects property value has no access path for index u in n and it had been written before the permission with index u has been as can be seen from u u in this case we the new u path to the value this path is realizable in the at time u because the property has been written at u u that is before u there is no access path for index u in n and the property has been written after the contract with index u has been viz u u in this case no u path is attached because this property was not linked to the data structure in the at time u the examples in section illustrate these three cases the rule permit an access permission contract each such permission is bound to the time stamp u of the heap in which the permission is it increments the time stamp to avoid with the next permission then evaluation proceeds with the body of the but with an updated variable binding for x which records the time stamp u for the heap reachable from the object bound to x if any by u to it and updated read and write permissions which record the stated permission set lr and lw for the object network reachable from x an access permission has dynamic extent sec because the access permissions are propagated with the flow of execution and the rule check permission only considers the entry points in the domain of the current access permission p in particular access permission contracts are not captured by closures created while they are in force closure creation rule lam ignores the access permissions and function application rule app continues to use the current permissions with the body of the invoked function hence after evaluation of the body of an access permission is complete the information associated with its index u could be garbage collected both from the value and from the heap examples the code fragments in fig illustrate the different cases of the u operator the fragments a and b correspond to the examples l and m in sec they differ only in the placement of the permit expression the code fragment a the permission before creating an alias with the assignment xa xb whereas version b the permission in both cases let the permit expression be associated with time stamp u in fragment a the expression xb in line returns the location b with the map u b case of u u u because it was generated by the preceding assignment xb new this value let x new in xa new xb new permit x in xa xb let x new in xa new xb new xa xb permit x in a valid access b invalid access let x new in let y new in xa new permit y a a in permit x a a in xa y c nested permissions figure the definition of permit ru lr wu lw f h u e h u v x x u f if x m then f u h else f r w f h u permit x lr lw in e h u v figure information is written to xa the following access to xa returns b u b according to case of u which that the paths stored in the object take precedence over the actual path taken for the final write access the extended access map u ba is checked against the set of write permissions and succeeds in fragment b xa xb is executed before the permit expression hence xa contains b and the get rule makes it return b u a according to case of u for the write operation the extended access map u aa is checked against the set of write permissions and fails the code in figure c case of the definition of u after establishing the two permissions the environment is x x u y y u where the ui are sorted according to their i after the assignment xa y with time stamp u the object in location x is a u y u in line xa evaluates to u a u y u y u a u u y u observe that case of u applies because u u in consequence u from the domain of the map because the object that was reachable via xa before line has become garbage with this reasoning the update of is permitted because it is equivalent to ya and realizable in the heap after line our first technical result is a soundness results that that our semantics to the property sec it ensures that any value produced during evaluation contains correct path information with respect to all relevant in the following sense consider a reference value of the form v m where m is a map from time stamps to access paths for each time stamp u there is an access permission at time u for heap hu with base object u that affects the value v the information contained in m is correct with respect to u if there is a path from the base object u to along the properties of mu in the heap hu to formally define this notion suppose the information about the and the base objects of all contract is in a timestamp indexed map f stamp loc × heap it maps the time stamp u of the of an access permission to a pair u hu where u is the location of the base object and hu is the heap at that time definition let f be a map a value v is f path consistent if · v xe and is f path consistent or · v m and for all u if f u u hu then there is a path from u to along mu in hu an environment is f path consistent if for all x dom x is f path consistent a heap h is f path consistent if all values stored in all object properties are f path consistent that is for all domh and for all p domh if h p u v then v is f path consistent to the map a extended evaluation judgment r w f h u e h u v is required it records the base object and the heap at each successful contract in the map f fig contains the modified permit rule the remaining rules for the extended judgment extend the ones for the original judgment in fig by passing the map in exactly the same way as r and w showing to the property amounts to proving that an evaluation that starts on a path consistent heap and environment produces a path consistent heap and value theorem suppose that r w f h u e h u v if and h are f path consistent then so are h and v there is also an completeness result that guarantees that the m component of a reference value is nonempty if it has been accessed via a path stability of violation stability of violation is a property linked to the reference property sec it states that a violation of an access permission is preserved in a precisely defined sense when performing the same computation on a heap with more aliasing lets first fix what we mean with more aliasing if h and h are heaps then h has more aliasing if it identifies locations that are distinct in h and merges the contents of the objects in these locations that is if o and o are distinct objects in h which are merged to object o in h then o has all properties from o and o properties present in o and o must have related values that map into the same value in h we call h a refinement of h because it makes more between objects definition a heap h is a refinement of heap h written as h h if domh domh is a mapping between heap locations and domh o h o h rh objects in the refined heap have fewer properties and rh p op u u vu u v v a value is a refinement of another v v iff r w h u e h u m r w h u ep r r mp r w h u e h u m r w h u ep o r mp r w h u e h u m r w h u e h u v w mp r w h u ep e w figure essential rules rv v m and v m and and m m or rv v e and v e and and e e an environment is a refinement of another iff re dom dom and re x dom x x the reader might about the implication in rh this choice allows the heap h to contain a value which does not refine to all corresponding values in heap h for each object in h there may be any number of of this object in h rh says that such an object need not be consistent with all its this case can be detected by the condition u u the shared version of the object has been updated after one of its the remaining case u u can never arise we allow such in a heap refinement because they only influence the semantics of a program if there is a subsequent read operation that the inconsistency in this case the criterion u u detects the inconsistency having established the notion of heap refinement it remains to formalize running the same program on two heaps and compare the outcomes to this end it is not sufficient to consider successful terminating evaluations but also evaluations ending in a contract violation and evaluations figure specifies the key rules of three judgments of the form r w h u e i where i r w o each judgment formalizes an evaluation the r indicates violation of a read permission rule w indicates violation of a write permission rule and o indicates nondeterministically giving up on a read operation rule the remaining are straightforward variants of the evaluation rules in fig that propagate an error condition like an exception our theorem says that due to violated read or write permissions are preserved when more aliasing is added the main is that an inconsistent read operation in the sense discussed after definition in the version with additional aliasing may lead to arbitrary behavior of the program including nontermination therefore the theorem constructs a related execution up to the first inconsistent read its proof along with auxiliary definitions may be found in our technical report theorem if h h and and r w h u e i for i r w then r w h u e j ee ee e new for var i in e s function f x s e e e e e e e en e m e en e e en var o e for var i in o if s var f function x s figure transformation rules simplified any any with ab function fx var z xa return contract var f function fx var z return figure example of a transformation such that either i j or j o and the derivation of ends in an inconsistent read operation with respect to informally the proof constructs a derivation of by induction on a derivation of as h h it is either the case that always reads the same values from the heap as in this case the derivation of is isomorphic to the derivation of and i j otherwise there is an instance of a get rule in the derivation of such that applying this rule as part of would return a different value a sufficient criterion for this case is to check if u u when reading the property as shown in rh in this case we give up emit a rule instead of get and complete the derivation with propagation rules for o the theorem also holds in a language with conditionals as they can be simulated in the lambda calculus if the language were extended with pointer equality then a condition might turn out differently on h than on h however theorem would still hold if a rule analogous to were introduced that allowed us to derive a o judgment in instead of executing an inconsistent pointer equality implementation the implementation of the framework for monitoring access permissions is available on the web it consists of two parts the first part is an offline compiler written in ocaml the second part is a javascript library that handles the dynamic aspects of enforcing access permissions the implementation supports the javascript language according to the standard except for and the with statement as demonstrated in sec contracts can be attached to a function or method in a special kind of comment c the compiler transforms the annotated code such that it monitors access permissions at run time figure illustrates some of the transformation steps in a simplified form all operations that involve heap accesses like reading and writing of properties are to library functions that dynamically access permissions these library functions introduce wrappers for references that remember the access paths of the wrapped reference figure shows an example of a transformed function definition the library function creates a wrapper for f that generates a fresh time stamp each time a function is called and marks the parameters with the corresponding access path information at run time such that can check if it has permission to read a the library call to returns a wrapper with the access path a for z reading the property b of z uses the access path stored in the wrapper of z extends it to ab and checks if reading this path is permitted the permission is granted because the access permission attached to f is ab calls to native or code would fail if wrapped objects were passed because it is not possible to statically decide which function is applied at a call site the framework the access meta data from parameter objects before passing them to the function it stores the meta data on a global stack that is used to the objects if the callee itself is a transformed function this approach is compatible with uses of eval code generated by eval can execute but its read and write operations are not for with code it is also necessary to remove wrappers when storing object properties to this end an additional map is attached to each object this map stores the wrappers for each of the properties the function uses this map to wrapped objects if necessary as the library stores the access path information in the property of the objects this property must not become accessible to user code therefore we provide a substitute for that masks out the property we also transform the statement for var i in e s to ensure that internal properties used by the implementation do not leak out to the program technically this protection is achieved by changing the body s to if s the functions and also the special property if native code or code iterates over all properties of an object then it is not possible to hide the property we are not aware of any way to hide this property short of modifying the underlying javascript engine however in the case studies that we performed the special property caused no problem some features of javascript are not covered by the core calculus from sec most notably and the with statement in both cases it turns out that write operations are not a problem a property write never gets propagated to a prototype object and the with statement only changes the meaning of property reads a proper semantics of property reads in the presence of would first check the permission on the original object check the presence of the property and then recursively continue with the prototype object until the property is not found or there is no further prototype our present implementation does not implement this semantics it only checks the toplevel permissions and relies on the builtin prototype resolution to do the actual read operation thus it ignores restrictions imposed on a prototype object a proper semantics of with statements would have to proceed similarly but traversing the stack of objects associated with currently open with statements for each access to a local variable our implementation does not support with at all because our case studies do not require it while an extension of the transformation to support and the with statement is possible it does not appear sensible because it would require yet more details of the underlying execution engine possibly introducing hence we are working on an implementation inside a javascript engine where it should be simple to overcome the restrictions of our implementation with only a impact on performance for example hiding the metadata and ensuring that it does not affect program execution is straightforward similarly it is possible to monitor property reads and writes of native type contracts rejected contracts reason for a may be counted multiple times type contract failure error browser timeout read violation write violation readwrite violation table testing random for lists functions to fully support eval and dynamically loaded code due to the direct access to the scope chain the support for with statements is also simple inside a javascript engine evaluation how effective are access permissions for detecting programming errors to answer this question we the code of several libraries and applications with contracts and ran it with monitoring enabled we applied random code modifications to check to what extent the enforcement of access permissions detects changes in the programs behavior case study and doublylinked lists and trees the first case study a collection of libraries implementing data structures like and doublylinked lists and search trees the code sizes range from loc per library as the results are similar for all libraries we discuss the list implementation as a representative example the list interface one constructor for list nodes and six methods to operate on a list add remove item size and for each method we developed contracts with access permissions annotating the code and implementing a custom contract to the input generation took about one the code with all contracts is available on our from the implementation we derived about random and tested each against the original contracts the affected operators constants and variable names each of the six functions was tested with randomly generated test cases and was run in two configurations type contracts for integer lists without effects only violations of the type contracts are detected contracts for integer lists with effects type and access path violations are detected table shows the results of the test runs the row counts that are not detected because the all six contracts the rejected row registers that fail at least one contract these two rows indicate the effectiveness of effect monitoring adding access permissions to type contracts improves the detection rate for from to an improvement of the remaining rows break down the reasons for the failure of a as there are multiple functions in a there are multiple reasons why a single may fail so that the do not add to we manually the cases where the contract system did not detect a mutation in many cases the code is semantically equivalent to the original version for instance when xp was changed to xq where both properties p and q were always type type effect contracts rejected contracts reason for a may be counted multiple times type contract failure error browser timeout read violation write violation readwrite violation table testing random of the case study undefined in other cases the contract was by a because the modification did not change any property access or return value from a type perspective for instance return true is changed to return false while these change the semantics a type or access permission contract cannot detect such changes we also manually ten randomly selected that out in all cases the mutation caused an infinite loop case study and benchmarks a second case study was performed on the and benchmarks from the v benchmark suite the benchmark simulates the task of an operating system the code functions in loc a person without prior knowledge of the code under test provided the contracts and implemented custom generators in about four it took another two to develop the access permissions table shows the result of testing about versions these test runs executed tests per function for each to test for effect and contract violations we chose to run a smaller number of tests to reduce the overall run time and to check if a small number of test cases is sufficient to obtain a high detection rate of adding access permissions increases the detection rate from to which amounts to a improvement this increase is quite surprising as the of detected read or write violations are much smaller than in the case study in the application contracts in loc the access permissions led to an increase in error detection from to an improvement by in contrast to the other studies does not permit unit testing on a per function basis as it relies on global state further details may be found in the technical report performance evaluation all case studies and benchmarks were executed on a xs with a core processor with and gb ram running the browser on top of linux version generic in this setting a test run of a is about four times slower with monitoring enabled than without monitoring in both case studies to give numbers running tests for each of the six functions of the test suite takes about seconds with monitoring compared to seconds without for running tests for each of the functions takes seconds with monitoring compared to seconds without for the benchmark we the original code without mutation once with monitoring and once without to measure the for code that never violates the effect annotations this experiment masks out the effects of contract violations which c with this this root this figure contract of a binary search tree cause the program to stop earlier on than on correct code however the is similar running test cases for each of the functions took seconds with monitoring enabled versus seconds without a factor of example contracts for case studies figure contains a representative contract for an add method that inserts an element in a binary search tree the method adds new elements by creating a new node object that is inserted into the tree at the appropriate place its contract reveals that the method only reads and modifies objects reachable via this root and then following left or right properties it does not change the value property of any node that is already part of the tree but it reads this data to find the place for the new node related work access permissions are closely related to effect systems effect systems have been for functional languages to describe and infer the scope of side effects with the goal of detecting code fragments and improving memory management there are too many papers on effect systems to do them all here and introduce effect annotations for java which closely our contracts in contrast to our system effects are collected for regions which a set of objects their approach aims to track data dependencies of software components the main differences to our work are that most effect systems are integrated in type systems and thus towards static analysis whereas ours performs dynamic analysis and that our prime motivation lies in the detection of software the effect system proposed by and for deterministic parallel java relies on a very similar notion of effect based on paths over regions sets of instance variables they use the effect system to statically prove the absence of data races our system might be extended to check this property at run time the static verification system of and has a special acc predicate that helps simplifying proof obligations for the frame problem in method calls the argument to acc is an access path similar to but more restricted than the notion put forward in our work a preliminary investigation suggests that their static semantics with our monitoring semantics but further work is needed to work out the exact connection similarly related is work on ownership and aliasing control again with the exception of the dynamic ownership system of and most ownership systems statically impose ownership structures on object graphs the main difference to ownership types is that our system is entirely access whereas ownership types are furthermore some ownership systems the existence of references whereas access permissions the traversal of certain paths effective ownership does not restrict of objects but enforces the encapsulation of an objects representation by modifications to the owner and define a static checker for access permissions in java it combines typestate and object aliasing information to design and verify protocols for safe object access they also focus on the correct usage of single resources their access permissions are statically verified analysis for sharing and aliasing is also entirely based on access paths it is a static analysis as an abstract interpretation of a semantics runtime monitoring is an approach to providing safety and security guarantees provides an overview of such applications as a difference security monitoring is mostly towards eliminating sequences of uses of operations and can often be implemented by finite automata whereas access path monitoring rules out accesses and requires more specific implementation techniques to deal with aliasing provides runtime monitoring of javascript rewrites code to critical operations according to policies the project an online compilation process of javascript code to a safe subset named which enforces certain security policies and combine several isolation techniques for restricting heap accesses of code they eval function and constructor within untrusted code and also rewrite property accesses with wrappers to enable runtime checks these systems operate within the browser during interactive user sessions and provide complete in contrast our tool is focused on development and testing of applications and design a javascript heap analysis framework to detect information leaks to prevent exploits code is restricted to a name space by properties with a unique identifier in contrast we restrict accesses via path conditions enforces finegrained security policies at run time by modifying a javascript execution engine compared to our approach they have different goals and less overhead further related research deals with dynamic contract checking findler and felleisen develop dynamically checked type contracts for scheme in a similar way extends javascript with type contracts that are dynamically and can be used to automatically generate random test cases for functions our paper extends their work with access permissions to check side effects of a function program specification frameworks like spec or permit the formulation of access permissions as in pre and postconditions because specialized syntax is missing the annotation process is rather besides these frameworks are towards full specifications whereas we are partial specifications features an clause to specify which object fields may be modified during a method call similar to our write permissions read accesses cannot be restricted in contrast to our work is mostly towards static program verification of the approaches that employ for runtime checks that is contract monitoring only a few fully support and provide such an implementation of runtime checks their implementation relies on code rewriting but the main contribution of their work is an efficient check of clauses for dynamic data groups the semantics of these checks is of the semantics discussed in sec and define a static analysis for specifications they include alias information in their system by tracking what aliases are introduced when a field is modified their analysis also seems to implement the semantics conclusion we proposed a novel extension of software contracts with access permissions that specify the side effects of an operation in terms of access paths we implemented monitoring for access permissions in javascript by a program transformation and demonstrated that this implementation has an acceptable overhead as a theoretical basis for the implementation we developed a formalization that enabled us to specify the interaction of monitoring and aliasing to prove soundness of monitoring and to prove stability of violation our case studies showed that the specification of contracts with access permissions on an code base takes about per loc and that in return the number of bugs detected by contract monitoring increases between and which is a improvement on type contracts in each case the access permissions provided valuable insights in the behavior of the program hence access permissions could be a extension of testing frameworks a major design choice was the adoption of the semantics because it behaves consistently with respect to static verification it guarantees stability of violation and it is reasonably efficient although single read and write accesses are more expensive than for the semantics we believe that the potentially unbounded time for a permission is not by the subsequent exploration of the object graph we conjecture that only a small fragment of the objects affected by a contract is actually explored but we have yet to an empirical evaluation with realistic implementations of both semantics in future work we want to various directions we believe that our approach is more widely applicable to any language not just to languages but also to typed languages like java and c in the latter cases to avoid encapsulation it is likely necessary to introduce concepts like regions or data groups analogously to other work in this area in this context it would also be interesting to investigate a mix of static checking and dynamic enforcement as has been done in work on manifest contracts another obvious extension would be a special treatment for effects on the dom because dom structures are guaranteed to be trees no aliasing many of the complications of general object graphs do not arise in the case of dom structures we further plan to investigate the variant of the monitoring semantics in the context of security and access control for this application it appears that many of our design choices have to be for reliable monitoring of access control policies the semantics with lexical scoping of permissions along with a notion of path negative permissions seems to be a approach however the semantics can also be extended to access to certain objects as shown in our technical report in any case a implementation of access permission monitoring is required to further validate claims in this direction references p and m design by contract for java a ahmed r b findler j g siek and p wadler blame for all in proc th acm symp popl pages ­ austin usa jan acm press j and c chambers ownership domains separating aliasing policy from mechanism in m odersky editor th ecoop volume of lncs pages ­ june springer m k r m leino and w the spec programming system an overview in construction and analysis of safe secure and smart devices pages ­ springer k and j modular typestate checking of aliased objects in proc nd acm conf oopsla pages ­ qc ca acm press new york j j and w capabilities for sharing a of uniqueness and readonly in j l editor th ecoop volume of lncs pages ­ june springer r a r j and f g on test data selection help for the programmer computer ­ april a a model of aliasing and its abstractions using finite representations of equivalence relations in proc ieee international conference on computer languages pages ­ ca ieee t editor th ecoop volume of lncs springer w and p lightweight ownership for journal of object technology ­ oct language specification dec international th edition analysis design and programming language june international nd edition and f b enforcement of security policies a in proceedings of the new security workshop sept m m and f embedded contract languages in s y s m m j and cc editors pages ­ acm r b findler and m felleisen contract soundness for objectoriented languages in proc th acm conf oopsla pages ­ fl usa acm press new york r b findler and m felleisen contracts for higherorder functions in s editor proc icfp pages ­ pittsburgh pa usa oct acm press new york r b findler s and a lazy contract checking for immutable data structures in o z and v editors implementation and application of functional languages th international workshop number in lecture notes in computer science pages ­ springer m j and a preventing capability leaks in secure javascript subsets in proceedings of network and distributed system security symposium pages ­ society d and j integrating functional and imperative programming in proc acm conf on lisp and functional programming pages ­ a translator for web content m b c pierce and s weirich contracts made manifest in j palsberg editor proc th acm symp popl pages ­ jan acm press a and j an objectoriented effects system in r editor th ecoop volume of lncs pages ­ june springer a c and s the essence of javascript in p a and p access permission contracts for languages extended version technical report july p and p testing of javascript code in proceedings of the th international conference on objects models components patterns tools pages ­ june springer p and p types for analyzing languages in r j and a typed contracts for functional programming in p wadler and m editors proceedings of the th international symposium on functional and logic programming pages ­ springer r l b jr v s d s v s r j p h and m a type and effect system for deterministic parallel java in s and g t editors proc th acm conf oopsla pages ­ usa acm press new york r the java design by contract tool in proceedings of the technology of objectoriented languages and systems pages ­ ca usa p le r and l wc document object model aug g t a l and c ruby a notation for detailed design in h b and i editors behavioral specifications of and systems pages ­ h and p efficient runtime assertion checking of clauses with in d s and g editors volume of lecture notes in computer science pages ­ springer y lu and j representation with effect encapsulation in s peyton jones editor proc rd acm symp popl pages ­ new york ny usa jan acm s j c mitchell and a javascript with filters rewriting and wrappers in proceedings of the th european conference on research in computer security pages ­ france springerverlag b meyer applying design by contract ieee computer ­ oct b meyer objectoriented software construction prenticehall nd edition l a and b specifying and enforcing finegrained security policies for javascript in the browser in ieee symposium on security and privacy may p a and g t modular specification of frame properties in concurrency and computation practice and experience ­ j j and j flexible alias protection in e editor ecoop volume of lncs pages ­ july springer c j h j wang o and s of dynamic html acm trans web j b and f implicit dynamic frames combining dynamic frames and separation logic in s editor th ecoop volume of lncs pages ­ italy springer f and e static analysis of clauses international workshop on foundations of objectoriented languages jan jp and p the type and effect discipline information and computation ­ p wadler and r b findler welltyped programs cant be in g editor proc th esop volume of lncs pages ­ york uk mar springerverlag d n xu s peyton jones and k static contract checking for haskell in b pierce editor proc th acm symp popl pages ­ ga usa jan acm press t j palsberg and j lightweight for java in proc th acm conf oopsla pages ­ ca usa acm press new york 