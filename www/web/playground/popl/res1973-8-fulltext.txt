mathematical semantics of snobol rd department of computing and information science university abstract this paper analyzes the following the mathematical approach aims at a rather mathematical approach can provide practical programming language semantics proposed semantic a natural of the language snobol by d scott and c the study structure and at that the and usable formal specification of a key words and phrases store abstract syntax mathematical semantics pattern matching snobol environment continuation cr categories introduction overview a number of informal or descriptions of snobol have been published et all but the model of patternmatching by appears to be the only example of a formal specification of some aspect of its semantics since snobol is a language and the available descriptions are incomplete and easily a formal specification at a level higher than that of an actual implementation would be useful to programmers compiler writers and language designers specification definition in this report as proposed are we demonstrate by scott and by hoare and the feasibility of a mathematical semantic other a to language and and in the remainder of this introduction we summarize the characteristics of snobol which make it an especially interesting subject for semantic analysis and discuss concepts and notation we then present a formal specification of a large subset of snobol including pattern matching assignment transfers of control and functions in this paper trace facilities keywords mode of pattern matching and data structures are not discussed the semantic specification is then used as the basis for discussion of model and a recent proposal for additional pattern operations we assume a knowledge of snobol more precisely the language considered is that discussed in references and although we believe the specification to be consistent with these descriptions it is not an definition and snobol programmers may discover with respect to details that are unspecified in currently available documentation the defined attempt snobol is an especially interesting a mathematical semantic specification and challenging in particular language for which to i the applicative subset aspects having to do with expression evaluation and declarations is extremely limited in snobol there are no true identifiers and functions conditionals patternmatching etc are all highly imperative since the defining language is purely applicative there is a much greater than usual between the object and ii transfer of control is based on the concept of evaluation success or failure which in the case of patternmatching generalizes to a backtracking control structure builtin functions and operations provide the ability to compile text at runtime and allow evaluations and assignments to be deferred or made conditional upon an pattern match success iii the storage structure of snobol is quite in many respects two of the data types are used both as variables and as values so that successful expression evaluations must signal a return as being either by name or by value labels functions and operations are but by the use of builtin functions rather than the usual assignment operator developed unfortunately specifications despite these by scott and certain that are characteristics is facilities it such as will be seen that the to snobol without userdefined functions and conceptual difficulty require framework the defining language primitive domains and functions the mathematical due to which and topological structure continuous relative to this can be shown to satisfy the approach to semantics models data types so that computable structure all the of this is based by domains functions domains theory on a theory of computation having a certain algebraic may be to be and functions that we discuss some of the primitive domains we shall use are tt truth values ln integers q strings the notation implies used as a metavariable domains in every of nonterminating that the symbol t possibly with over the domain t of domain there is a special element erroneous or undefined computations or subscripts and similarly l which represents will be for the other the meaning primitive operations on t are conjunction a and disjunction v we use notation co for conditionals and the usual arithmetic and relational operators for integers for strings we use q for the empty string a for concatenation and for the substring of from indices ii to zero origin the length of a string is denoted so that and q o the derived domains and functions domains are and denoting cartesian product domain respectively and by to the right and that the precedence defined disjoint domain hierarchy by using union equations is as the domain operations and we assume that above from x function associates to lowest inspection for x yi projection and injection as follows we define the operations of i for any true if x corresponds to an element of yi false if x does not correspond to an element of i ii for any y if x corresponds to if x does not correspond to an element of ii iii for any y in x x where xx corresponds to y for any domain x we write x x x x xj v n times xn for and x for the limit of xl x recursive the body abstraction functions or by function hence may be defined by let or where auxiliary definitions the lambda notation ae where is the bound variable application associates to the left and takes precedence implicitly and e is over lambda that right useful fg if fx y and g z then their composition x note the order of application reading of complicated expressions a variant if fx y and y x z then z is x x form the is the function which makes possible of composition will function such that z such be semantic concepts in the mathematical approach the semantics of a programming specified by defining functions which map syntactic elements into their meaning in an appropriate model these definitions are syntaxdirected every production in a syntactic specification has a corresponding the semantic specification for that category of constructs language are abstract in that clause in to three typically semantic the interpretation constructs of a syntactic construct is specified relative i ii iii an environment into the value a function mapping every denoted by that identifier symbolic identifier a continuation a function representing a computation that to be done following the evaluation of the current syntactic is construct a store location location output essentially a function into the value currently other components may be and dynamic storage allocation mapping stored necessary every abstract as contents of to keep track storage that of input specified for example by a function the meaning of an expression in a typical language would be exp env k s s where the domains are as follows exp id env id d d l v e expressions identifiers environments values stores locations values expression continuations expression values the use of these constructs in semantic specification scott and r reynolds is and is explained in more detail in semantic specification abstract syntax id character identifiers operators expressions commands statements programs strings identifiers and operators will be considered to be components of the domain char elements than a alternative the following of a syntactic nonterminal constructions productions are in domain are denoted symbol brackets and a notation by the corresponding are used to literal in which arbitrary metavariables optional ig identifier iv us unary operation i cl h binary operation i function call ie array indexing i e parentheses rather and assignment pattern match replacement y e i e expressions there are no declarations in snobol so that an environment required however since an expression evaluation may fail a second be and we will also will not discuss inputoutput see that the store is more complicated and so we suppose that the of is the final state of the store then the continuation domains may follows component is not continuation must than usual we a program execution be defined as kk e s s expression continuations s s failure continuations where the domains of expression values e and stores s will be defined later the functionality hence if the evaluation applied to the resulting be applied to just the of the expression interpretation function of an value store expression and store e succeeds and otherwise the k continuation the failure is then will continuation be will even if an expression evaluation by name or by value hence the domains of locations l and domain values succeeds of expression v it may return its value values is partitioned then a return continuation e l v by name or by value is to an corresponding to an indicated element expression values by applying the expression of either l or v respectively either into a name a variable and so location may be either natural q nm ol q nm strings names locations a string or created the va include a so the other zn r ar tb uw xc df data types integers reals patterns arrays tables expressions code defined data types the domain of values is then the sum of ar tb w c df all of these values transfer strings functions and names are in both l and v and so it is possible v and l as follows to define in v var nm nm b as q in l where f as otherwise integer q is q if q but converts to a string similarly the suffix as n will denote the if bn or r and is i conversion of a value to an in e ambiguous omitted the standard notations for projections conversions of rather for values than strings can be simplified by for example writing vn n as n and in v in e respectively and names but our convention will be that v is always intermediate domain and as n and this is the an expression is not the continuations and store expression is passed to eval or encountered obtained by applying to an expression but these will be provided when the during pattern matching hence uw k x f s s expressions for code only the store needs to be provided xc s s code so we define a general functions and operations must evaluate domain of functions as follows their own arguments functions that is an element of f will will be discussed later be applied to a list of expressions and patterns we now consider l v component as usual the structure of s the domain but for the natural variables of stores there is an more is needed because functions and operations may be stored as attributes from the stored value there is also a label attribute to store the code associated with that variable if it is used as a label hence the domain of stores is constructed as follows os l v x q f x f x f x cl stores additional components names etc would be required to account for inputoutput allocation of the following functions to be accessed and updated allow values and the various attributes contents update l x v s s q x c s s q x f s s the meanings are evident from the and function is coerce k k defined as a very u ill in e o we may now specify exp k x f s s as follows the special brackets separate the object cl will be and used to syntactic constructs useful in order to in e where abstract strings q establishes the correspondence between syntactic strings the difference between the former returns by snobol are not inherently in char in l in e the interpretation value and the of latter symbols a literal by name as they string note are in and that most an identifier identifiers languages and is that in where abstract numbers vk n r establishes in e the correspondence between syntactic in char k the operation expression composition associated with c and the given operator similarly u in the continuations current store the store is applied is passed to the along by the and e in char k in char k nl k functions stored denote when the notation we shall use as initial contents or attributes the operation in program execution begins then to specify the of variables char values is where functions o is the and operations by having state of the store k in ee the operator returns the null string if evaluation of its operand is successful and fails otherwise the negation operator fails if its operand succeeds and returns the null string otherwise k in e the name operator transfers the value of its operand from l into v the indirect reference uk in eo operator transfers the value of its operand u ke in from v to l expression then where the the deferred evaluation operator returns u k in e its operand as an ke nw as q as suffix as exp converts a string into an expression parsing argument apply causes the application to the other arguments of the function attribute of its first as ui the function attribute of its argument and returns as the null in eo string functions and operations may be assigned by use of where where kz where k t as where as q as in e i op analyzing define arguments define obtains the defined functions its first argument the prototype l x l x l x q f is then invoked to name parameters we suppose that create the defined and by a function function where are the function name parameters and entry point the the defined and and the then these point when control function the current label attributes of the three are initialized appropriately returns the saved contents of system labels and control are the name return transfers in reverse parameters to the order and entry we use b and f to denote and map in respectively then in char in define a ji j aj du where where u let b u and u and and in in in v n n where e o i update u patterns char snobol modelled pattern we shall by functions matching discuss which is one of the most interesting and complex only the mode of matching patterns are applicable to the arguments i a subject string ii a cursor which is an index into the subject to indicate match is to be features in may then be where the hence iii iv v three continuations the subsequent and if the global to be applied if the local match if the local match is match is to be aborted the failure is successful the alternative continuation code for prior match succeeds conditional assignments to be evaluated and has this pattern as a component if the global the current and evaluation store to allow of for side effects expressions from immediate assignments np q x n x sb x x f x c ss patterns create a successful new alternatives local and n x match change might move the cursor the state of the store x c s s an alternative is simply applied s s to the current store the domain of code and failure xc ss ff ss continuations were previously add conditional assignments subsequent alternatives defined as code failure continuations we may now define some of the builtin pattern values fail l x e x x as follows a substring expression fails or is negative a typical builtin whose length is given by its it will be evaluated when the the subject is not long enough it is an error function operand match is the local is len if this is match fails len attempts to match an if this evaluation and if the integer where len in e w ill w coerce where k kx the other defined builtin where i n as n functions except for could be similarly be defined ie try conditional ie try conditions the fundamental as follows pattern operations of alternation and concatenation x x where k nl and if assignment try nz with the original cursor alternative cat l x ti ox where x n and if successful assignment try t with the new cursor alternative and may and these operations are invoked by the alternation and concatenation operators but implicit conversion to pattern values may be necessary and define the predicate q and the conversion suffix as p so we as follows j n v br as p bp fp bw where b and where l then where as q coerce n as xz p as as e concatenation is more complicated and the null string receives special treatment because strings may also be where cat it qo tq a t as q v a q m as q n r as q as p vz as p in e some of the patterns with implicit functions alternatives previously require defined recursive succeed as as in as p in ee where at as m definitions we use string after an the cursor assignment operator returns a pattern which assigning to its operand the current cursor position expression it will be evaluated during the match u k in eo where n n where kt in v matches the null if the operand is substring evaluated the immediate assignment operator returns matched by its first argument to its second during the match a pattern argument which which assigns the may have to be an as pn in where where x lx nw ti where update ll in v ix conditional assignments for a substring assignment is simply argument evaluation of the location fails the assignment is are deferred until the global match composed with the current conditional may also be deferred but if this succeeds code assignment evaluation as where where x where x x where i in v ft in e statements and programs applied we will matching commands are interpreted relative to two continuations to the current store in case of success or failure specify the most complex in mode case only a replacement command which are to be with pattern where where content lk as qo where l as p where replace where ki l x x t as q in where insert d do expression a goto and applying is interpreted it to the by obtaining current store the code attribute it is an error s s if of the value the evaluation of the fails the value of the expression in a direct go to should l be of type code applied a statement is interpreted if there is transfer relative to a code continuation of control s s which is to be and similarly xx where x fy x for the other possible a program is interpreted final state as result relative to the state of the store and yields the prog s s n ln end j where xo and xi and ij for o il n xn if the suffix as prog denotes the parsing of a string as a program ko as q as prog in e then discussion theory of patterns definition a pattern resulting the formalization of pattern matching in is based on the following is a function but is list of cursor positions in order of preference q x n n applied to only defines the patterns a subject string and a cursor that are potentially the for example the fundamental pattern operations defined as follows the limitations matching which cannot be abort and conditional side effects of this model are evident aspects of snobol pattern treated using the above definitions are the primitives and immediate assignments expressions and the proposition proposition it may be verified following are stated in concatenation is associative alternation is associative concatenation over alternation that they also apply in our much more from the right general model either fails further results or succeeds are based on the concept in just one way then of a pattern which always proposition if r is cat pr proposition the concatenation of is canonical form any pattern formed by concatenation and alternation of may be written as an alternation of of these results all some and may be applied and x either x in our model lx by defining l for for all a pattern t to be if for all and it fails or for and k n succeeds in just one way the canonical form is used by patternmatching algorithm that is the basis of there are expressions patternmatching form result is not applicable the general case using the model discussed in this to verify the correctness snobol implementations assignments etc the algorithm could be verified paper of a however canonical in the if semantics and language design scott and have suggested the design of programming languages in this this by analyzing a number of extensions of snobol that semantic modelling should influence section we consider a small example of functions that have been proposed as the original proposal was as follows matches strings matched by a and b not a matches null unless a would match in which case it fails this was then modified and as follows matches strings matched by a and b not a matches strings not matched by a and extends like fail a matches null unless a would match in which case it fails null a matches null if a would match else it fails there was some argument that not should be replaced by matches strings matched by a but not matched by b eventually the entire proposal was because of specify probably we can attempt these functions a more appropriate to the least name some light on the issues involved is fail originally in our model ex where t x also fairly straightforward is null which is useful for null x where lt x by called not to it should be noted that lookahead are discarded and null are is appropriate to have the alternatives and conditional this is not explicitly stated the pattern matching fail o fail just as c assignments in the proposal of the operators s created but t during the since fail and it the other functions are on a set of strings model of patterns for set intersection however as we have seen to specify an and function in our because they are based example and is intended to implement snobol patterns are far more complex model raises the following problems a i ii iii iv if the first argument matches and also creates new alternatives but the match of the second argument fails should these alternatives be ignored or into with the hope that side effects may occur to cause the second pattern to match if both patterns match but the subsequent alternative should be into fails which if both matches be recorded succeed which conditional assignments should if the patterns it a failure of should be applied begin matching match the conjunction and if not of different lengths is if so which alternative where should the subsequent described underlying practical hence however semantic situations null and fail seem welldefined the other proposed functions model is inconsistent with the following substitutions and could easily are the actual nature would be suitable be implemented because the of snobol in as most fail a for b or x b y for a for this has been a fairly small illustration but it demonstrates the potential of semantic analysis in programming language design the availability of method for precisely specifying the meaning of a proposed facility or comparable facilities in other languages can help the designer to his ideas and to discover simplifications and far than would otherwise be possible a references r j and prenticehall nj i the snobol programming second edition language p the structure of snobol technical science cornell univ report dept of computer sciences mc data structures new york and programming institute of math r the macro implementation of snobol san francisco j a theory of discrete cacm patterns and their implementation in snobol scott d and c towards a mathematical semantics for computer languages proc symposium on computers and automata institute of scott d mathematical conf vol concepts in programming language semantics proc laboratory c the of programming language technical oxford university computing hoare car pascal and n an axiomatic definition of the programming language p and k on the formal description automatic programming of annual review in i folds a declarative formal science report cs language definition system stanford computer scott d outline of mathematical theory of computation proc th annual princeton conf on information sciences and systems scott d lattice theory data types and semantics languages ed r in formal semantics of nj scott dr the lattice of flow diagrams ed e springerverlag in reynolds jc definitional interpreters proc th nat conf for higherorder programming languages cr another approach to jumps continuations unpublished illinois institute of technology illinois institute of r personal communication 