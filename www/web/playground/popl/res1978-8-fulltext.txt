conference record of the fifth annual acm symposium on principles of programming language symbolic program analysis in almost linear time john h reif department of computer science the university of abstract a global flow model is assumed as usual the flow of control is represented by a called the control flow graph the objective of our pro gram analysis is the construction of a mapping a cover from program text expressions to symbolic expressions for their value holding over all tions of the program the particular cover con by our methods is in general weaker than the covers by the methods of ki our method has the advantage of being very efficient requiring o extended bit vector operations a logical operation or a shift to the first nonzero bit on all control flow graphs whether reducible or not where a is the number of edges of the control flow graph l is the length of the text of the program and is function an extremely growing function introduction the flow of control through a program p is represented by the control flow graph f where each node n cn is a block of assignment statements and each edge mn ca specifies ble flow of control from n to m and all flow of control begins at the start block a in f is a sequence nodes in n linked by edges in a we assume that for each there is at least one path from s to n for m m dominates n if all paths from s to n con m m properly dominates n if in addition nm the dominator relation may be represented by a dominator tree such that m dominates n iff m is an ancestor of n the of n is the immediate dominator of n let be the set of program variables occurring globally within p a program variable is defined in some node if x occurs on the left hand side of an assignment statement of n for each and var we have an input variable x to denote the value of x on to n let exp be the set of expressions built from input variables and fixed sets of c and function o for each nn and program var defined in n let the output expression x be an expression in exp for the value of x on exit from n in terms of the input variables in block n is an output expression or a subexpression of an output expression for each such that n dominates m program variable x is defined between nodes and m if x is output on some path from an ­ immediate successor of n to an immediate predecessor of m otherwise x is between u for each let the set of program variables such that x is a text expression ie xn appears within an output expression of n the weak environment is a partial mapping w from input variables to n for each input variable xn such that xe is the ie to the start node s dominator of n such that x is between and n we now discuss various applications of the weak environment for each text expression t located at the birthpoint of t is the dominator of n to which the computation associated with t may be moved code motion is the process of moving code out of into new locations where the code is used less ly this code improvement requires approximate knowledge of as well as other know including the cycle structure of the control flow graph we may not wish to move code as far as the birthpoint since the birthpoint may be con in control cycles avoiding n see ca au e gr for further discussion of code motion optimizations in r it is shown that in the arithmetic domain the problem of determining is recursively ki present algorithms which may be used to compute approximate ie nodes which are dominated by the true birthpoint however the time cost of the best of these algorithms is by ia we may use the weak environment w to construct a function mapping text expressions to approximations of their respective for each text expression t is the as far as possible from the start node s node in is a text expression of t relative to the dominator relation thus for each text expression dominates an expression covers text expression t if e represents the value of t over all executions of the program the origin of e is the in the chain of nodes on the dominator tree occurring within e ie in the of the input variables contained in e a cover is a mapping from text expressions to covering expressions and is minimal if the origin of the covering expres sions in its range are in the dominator ordering ie as close as possible to the start node s note that for each text expression t the origin of the minimal cover of t is the birthpoint of t from the weak environment w we can compute the simple cover which is a cover such that for each text expression t t is derived from t by substituting for each input variable xn such that m properly dominates n note that this definition requires that x be defined at m if not we add at block m the dummy assignment xx so that is a new text expression at most ol dummy assignments must be so added see figure for an example of a simple cover ts y xy a further application of the weak environment involves the global value graphs of se to represent the flow of values through the program for certain special global value graphs the algo rithm of constructs a cover in time almost linear in the size of the global value graph by a simple but somewhat inefficient method we can construct such a special global value graph of size however by another method which the weak environment we can construct a value graph of size where d is a parameter of the program p which may be as large as iz but is often constant for programs hence the very efficient but weak symbolic evaluation of this section may serve as a preprocessing step to speed up a more powerful method for symbolic evaluation presented in ri the organization of this paper is as follows in the next section we define the relevant graph terminology in section we describe an algorithm which constructs a function giving those pro gram variables defined between nodes and their immediate dominators the computation is of a class of path problems that may be efficiently solved by an algorithm due to tarjan t on flow graphs we extend his algorithm so as to compute efficiently on all flow graphs section presents an algorithm for constructing the weak environment this algorithm requires the previously computed function and contains an interesting data structure for efficiently main multiple symbolic environments section concludes the paper with the construction of the simple cover from the weak environment as in ri we the dags labeled acyclic representing linear blocks of code into a global dag representing the simple cover graph theoretic notions consists of a set v of elements called nodes and a set ordered pairs of nodes called edges the edge uv from u and enters v we way u is an immediate predecessor of v and v is an immediate successor of u the of a node v is the number of immediate successors of v and the is the number of immediate predecessors of v a from u to w in g is a sequence nodes p where for all i the length of the path k of p is the path p may be built by composing vk the path p is a cycle if uw a strongly connected component of g is a maximal set of nodes such that any pair is contained in a cycle a node u is reachable from a node v if either uv or there is a path from v to u we shall require various sorts of special a rooted is a triple such that va and r is a node in v the root a flow graph is a rooted such that the root r has no and every node is reachable from r a is labeled if it is augmented with a map whose domain is the vertex set an oriented a with an ordering of the edges from each node a g is acyclic if g contains no es if u is reachable from v u is a of v and v is an ancestor of u these rela tions are proper if with no proper ancestors are called roots and nodes with no proper descendants are leaves immediate are called sons a ordering with either the descendant or the ancestor relation is a topological ordering of g a flow graph t is a tree if every node v other than the root has immediate the of v a topological ordering of a tree is a if it proceeds from the root to the leaves and is a if it begins at the leaves and ends at the root tree of a flow graph is a tree with node set v an edge set contained in e and a root r let be a flow graph a node u dominates a node v if every path from the root to v includes u u properly dominates v if in addition uv it is easily shown that there is a unique tree tg called the dominator tree of g such that u dominates v in g iff u is an ancestor of v in tg the of a node in the dominator tree is the immediate dominator of that node the computation we describe here an efficient algorithm for computing a function giving those program variables defined between nodes and their immediate dominators the computation is of a class of path problems that may be efficiently solved by an algorithm due to tarjan t on reducible flow graphs we extend his algorithm so as to compute efficiently on all flow graphs the essence of algorithm is to partition the nodes in n so that for each n n and m are in the same dominator strongly connected component iff n and m have the same immediate dominator w and there exists a control cycle con both m and n in the case where each contains but a single node then by the flow graph is reducible and algorithm runs in time otherwise algorithm must fall back on the less efficient node listing tech requiring time in the worst case quadratic in ini for our special problem the computation of the be solved efficiently yielding an algorithm of cost bit vector operations we now define the problem more formally let be the control flow graph and let dt be the dominator tree of f for each node let be the set of program variables defined at n and for each node m properly dominated by n let be the set of program variables defined between n and m also for each let be the immediate dominator of n and let ie the set of program variables defined between and n the above equation may be as follows fi i i where is the dominator chain from n to m thus given the dominator tree dt def and can be computed from each other the algorithm for computing proceeds in a leaves to root scan of the dominator tree dt of f we compute in one pass for all sons n of a fixed node w clearly this is trivial if w is a leaf of the dominator tree son and refer to the dominator tree dt otherwise a is formed by connecting together those sons of w in dt that are connected in f by paths that avoid w such paths pass through proper descendants in dt of w only the strongly connected components of this are may then be processed in topological order as each is processed it is identified with the parent node w itself thus when all sons of w have been processed all have been into w and the procedure may be repeated on the sons of some other node w to be precise a set of nodes is con by the following process ­ delete the nodes in s from the node set n and add in their place the set s which is considered to be a new node delete each edge entering a node in s and substitute a corresponding edge entering the new node s similarly substitute an edge from the new node s for any edge from an element of s finally delete any new trivial loops which both from and enter the new node s now let consist of the set of edges in a from a node other than w and entering a son of w such an edge must from a proper descendant of w otherwise the node it enters would not be dominated by w for each proper descendant m in dt of w let be the unique son in dt of w on the dominator chain from w to m ie w immediately dominates which dominates m let be a with nodes the sons in dt of w and edges saw it is easy to show that lemma for each nn a path in from n to n iff there avoiding path in f from n to n there exists exists a w note that by the above lemma each strongly connected region of gw is a the g derived from gw by each is called the of gw and is obviously acyclic we shall process each of gw in topological order of g from roots to leaves in the special case where each of gw consists of the singleton set then f is called reducible hu give various other tions of flow graph and algorithm runs in the however in the case that f is various will contain two or more nodes and algo rithm becomes considerably more expensive and complex the theorem below expresses in terms of def on previously computed domains this theorem holds even when the cardinality of a is greater than giving an efficient method for computing for all f both reducible and non reducible fix a topological order from roots to leaves of g and consider a of gw say s let be a descendant in dt such that is either in s or in some s of such that there is a path in from s to s ie s precedes s in the topological order then let be in case in case that is is just the unique son in dt of w which is an ancestor of m in dt unless s contains in that case is to be viewed as into w the partial function plays a critical role in the inductive correctness proof of our algorithm note that for each node and edge satisfies either or we wish to compute we may assume that due to previous computations is known in case l and the value is known in case our immediate goal is to relate to these previously computed values call a s of trivial if s contains a single node n and and otherwise non trivial now define q is trivial and otherwise if s is nontrivial et q also define qn theorem for each q note that this characterization of pro an algorithm for computing for all sons n of w by induction on the topological ordering of gj proof suppose so there is a path such that x for some case if ui ss then s must be nontrivial xc and case otherwise suppose let uj be the node occurring after ui in p such that uj ss then case then xc case otherwise suppose then s is some uj are descendants of uj u then q now we must show that implies xc for each ns if then x is output from some node n es and s be nontrivial since n is a son in dt of w there is a path in f from an immediate successor of w to n also since s is a nontrivial of gw there must be a path in from n to n so by lemma there is a path in f from n to n thus we can construct a path in f from an immediate successor of w to an immediate predecessor of n and so xc on the other hand if then xc for some mn and n es since w dominates also since there is an edge a finally since nn are both in s m thus and we conclude that x m case w is an edge of gw is an edge of dt cases and of the definition of hr m now we use the techniques of tarjan t to implement our algorithm based on theorem we construct a forest of labeled trees with node set n each edge nm has a label containing a set of variables in our implementation the set will be represented b a bit vector ini there is a forest of n trees each con of a single node ie shall require three types of instructions gives the root of the tree currently node n where is the unique path to n from the current root r of the tree containing n combines the trees rooted at n and m by adding edge nm so n is made the of m and sets to z tarjan t has shown that a certain algorithm for processing a sequence of r find and link in costs elementary opera tions this algorithm involves path compression on balanced trees and is frequently used in the imple of disjoint set operations also tarjan t gives an almost linear time algo rithm again path compression for pro a sequence of find link and eval tions given that the sequence is known except for the values which are to label the edges in the link operations the following algorithm for computing uses like the algorithm of t a preprocessing stage that executes all find and link instructions but not eval instructions this allows us in the second pass to efficiently process the eval as well as the find and link instructions algorithm a input program flow graph and out output yl declare sequence of integers nl compute the dominator tree lit of f number the nodes in n by a of dt scan the below so as to determine the sequence of eval find and the first two arguments of the link instructions for w to ini do y the empty set ll that i n add mn to add to ew comment end l let g be the of l each strongly connected component s of gw in topological order of g m comment q the empty set comment set q to q if s is nontrivial io for all do o on so forall do begin l comment apply theorem q end end end theorem algorithm a correctly computes proof sketch by induction in of dt initially each node is contained in a trivial tree with root n and gives the empty set suppose on entering the main loop at lo on the with iteration for any node m dominated we require a second induction this one on the computed topological ordering of we assume that just before processing the strong y connected region s in for each m dominated by w by the primary induction hypothesis l and clearly hold for the first of gw in the topological ordering we first set qs to q if s is trivial if s is nontrivial and then add to os the set w q hence by theorem for each is set to let s be the immediately following in the topological ordering after executing at l for each node m dominated w such that s now gives w and now gives qs s by thus the second induction proof furthermore just before node w we have visited all the elements of and so for each m properly dominated by w thus the first induction proof theorem algorithm a costs an almost linear number of bit vector operations proof the dominator tree may be constructed in almost linear time by an algorithm due to tarjan t now consider the iteration of the main loop let rw step l clearly costs or elementary and operations step l costs rw elementary steps to discover the strongly connected components of gw using an algo rithm due to tarjan tl plus time linear in rw to each strongly connected component of gw finally at step l we require elementary steps to sort the acyclic g by an algorithm due to knuth bit vector eval and link operations in the loop at l the total time cost of this execution of the main loop is this or bit vector eval link and find operations ut hence the preliminary scan of algorithm a requires link and find operations implementable in time almost linear in a by the method analyzed in t with the symbolic sequence of eval link and find operations now determined the second primary execution of algorithm a requires bit vector operations by the method of t o computing the weak environment we now present an algorithm for efficiently computing the weak environment w for each let be the set of program variables input at n for the moment it is useful to represent w by the set of partial functions n such that for each for all for each we have if xc if and m is the immediate dominator of n we shall process the nodes in n in preorder from root to leaves of the dominator tree note that for each we must store where i the chain of nodes on the dominator tree from the start node s to n to efficiently maintain these multiple environments we keep an array of stacks ws such that just before processing node n the top element of is for all xs a is required to that elements are not pushed onto these stacks the cost of this data structure for maintaining multiple environments is oj extended bit vector operations to that ws is not modified we compute rn those program variables x such that is an input variable for some node m properly dominated by n and such that x is from n to m intuitively rn is a set of program variables whose value is constant on exit to n to some node properly dominated by n we compute r by a of the dominator tree dt using the rule lemma rn the following lemma shows that to correctly maintain ws we need add node n to the stack just in case xc lemma there exists some m such that and x is input at node m iff proof by definition of r if then there s some node properly dominated by n x is input at node m and furthermore x is from n to m suppose and x is input at node m then clearly x is from n to m so but suppose then wx properly dominates n which contradicts our assumption that hence xc u the usual stack operations will be required gives the top element of stack s z as the top element of stack s the top element of s algorithm b input program flow graph in and out weak environment w ew compute by algorithm a as a side the dominator tree dt is constructed declare ws a vector of stacks length procedure effect all xe do m l for all l for all do l fi all end l for all n in of dt be in rn for all do n rn i l program variables xc l end theorem algorithm b correctly weak environment computes the proof it is sufficient to show that on each of at label ll for all xs this clearly holds on the execution of at l since at label l all program variables x have the top of set to s suppose that holds for a fixed nn ob serve that all nodes pushed in the stacks at l are out of the stacks at l with this ob we may easily show by a separate tion that the state of ws on exit of any call to just as it was on to the call the state of ws on to is the same for all hence by lemma the claim holds for m our induction proof we shall assume that a single bit vector of length zi may be stored in a constant number of words and we have the usual logical and operations on bit vectors as well as an operation which the bit vector to the left up to the first nonzero element this operation is generally used for normalization of floating point numbers here it allows us to determine the position of the first nonzero element of the bit vector in a constant number of such bit vector operations theorem algorithm vector operations costs bit proof each execution of requires ini opera and p z and so the total cost of all executions of is bit vector operations by theorem the computation of by algorithm a costs bit vector operations hence the total cost of algorithm b in bit vector operations is conclusion computing approximate and the simple cover given the weak environment constructed by algorithm b we can now easily compute approximate and construct the simple cover recall that an acyclic labeled di graph here we assume that the leaves are labeled with either constant or input variables the interior nodes of a dag are labeled with function for each the set of text expressions located at n are represented by the dag dn a dag is minimal if it has no redundant and if no proper may be replaced with an equivalent constant sign note that nodes of the dag dn represents text expressions whereas the nodes of the control flow graph f represent blocks of assignment statements here we wish to construct the function which as defined in section maps from text expressions to their approximate in n again for each we process the nodes of dn in topological order from leaves to roots let v to a node in dn if v is a leaf labeled with a constant then set to the start node s if v is a leaf labeled with an input variable of form xn then set to n recursively if v is an interior node with every son u previously visited set to the relative to the dominator ordering with the start node s first for any such son u we use a large global dag to represent the simple cover this dag is constructed as follows first combine the dags of all the nodes in n associate the singleton set v with each node v in the resulting dag next compute by algorithm b the weak environment w for each and input variable xn such that m properly dominates n the node corresponding to xn into the node containing x the output expression for x at m finally minimize the resulting dag the above construction takes time except for the construction of the weak environment which by theorem takes bit vector operations hence our method for construction of the simple cover requires bit vector operations s dn the dags of the program in figure vv v dag representation of the simple cover references au aho av and unman jd introduction compiler design to appear to el c some topics in code optimization jacm jan pp ea and unman jd application of lattice algebra to loop optimization conf record of the nd acm symp on principles of programming languages jan pp g cm global program optimization university phd thesis dept of computer science oct graham s and wegman m a fast and usually linear algorithm for global flow analysis jacm no jan pp ms and unman jd flow graph siam j computing no june pp hu ms and unman jd analysis a simple algorithm for global flow problems siam j of computing dec pp of and unman jd global data flow problems and iterative algorithms j acm jan pp ga a unified approach to program optimization proc acm symp on principles of programming languages boston ma oct pp knuth de the art of computer programming vol fundamental algorithms addisonwesley reading ma rl reif and lewis hr symbolic evaluation and the global value graph th acm symp on principles of programming languages jan r reif code motion conf on theoretical computer science university of r reif combinatorial ic program analysis university and applied aspects of thesis division of sc schwartz optimization of very high level languages value transmission and its computer languages pp tl tarjan re depthfirst search and linear graph algorithms siam j computing june pp t tarjan r efficiency of a good but not linear set union algorithm jacm april pp t tarjan r applications of path compression on balanced trees stanford computer science dept technical report august t r solving path problems on directed graphs stanford computer science dept technical report oct 