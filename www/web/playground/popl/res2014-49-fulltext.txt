symbolic optimization with smt solvers yi li university of university of software engineering institute university of university of abstract the rise in efficiency of satisfiability modulo theories smt solvers has created numerous uses for them in software verification program synthesis functional programming refinement types etc in all of these applications smt solvers are used for generating satisfying assignments eg a witness for a bug or proving eg proving that a subtyping relation holds we are often interested in finding not just an arbitrary satisfying assignment but one that certain criteria for example we might be interested in detecting program executions that energy usage performance bugs or synthesizing short programs that do not make expensive api calls unfortunately none of the available smt solvers offer such optimization capabilities in this paper we present symba an efficient optimization algorithm for objective functions in the theory of linear real arithmetic given a formula and an objective function t symba finds a satisfying assignment of that the value of t symba efficient smt solvers as black boxes as a result it is easy to implement and it directly benefits from future advances in smt solvers moreover symba can optimize a set of objective functions information between them to speed up the analysis we have implemented symba and evaluated it on a large number of optimization benchmarks drawn from program analysis tasks our results indicate the power and efficiency of symba in comparison with approaches and the importance of its feature categories and subject descriptors g optimization constrained optimization f specifying and verifying and reasoning about programs invariants keywords optimization satisfiability modulo theories invariant generation symbolic abstraction program analysis permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm introduction over the past or so we have an improvement in the performance of satisfiability modulo theories smt solvers and the range of logical theories they support these advances made smt solvers eg z etc names in the programming languages and verification creating an explosion in the range of applications in which they are and the way for that would not have been possible otherwise to mention a few in verification smt solvers have been used for device driver verification checking complex verification conditions and improving precision of invariant generation in testing and bug finding they have been in making symbolic execution and bounded model checking techniques practical in program synthesis they have been used to search for programs satisfying a given specification in functional programming they have been used to support strong typing guarantees with refinement types in all of the applications smt solvers are used for generating satisfying assignments eg a witness for a bug or proving eg proving that a subtyping relation holds to the best of our knowledge none of the available smt solvers support finding optimal satisfying assignments ie satisfying assignments that minimize or a given objective function in this paper we present symba an efficient optimization algorithm for objective functions in the theory of linear real arithmetic given a formula and an objective function t eg x y symba computes the smallest constant k such that t k specifically symba finds a satisfying assignment of that the least upper bound k maximum value of an objective function t in what follows we start by that such an algorithm has a wide array of applications in verification bug finding synthesis and others we then features and describe its highlevel operation applications of optimization we start by describing potential applications of symba in the following domains · numerical invariant generation numerical abstract domains eg intervals and are often used to generate numerical program invariants the main in such an analysis is the abstract transformer an operator that takes a set of initial states and an instruction or a basic block and com note that k is if t is unbounded in and if is unsatisfiable a set of reachable states often using convex optimization techniques since symba can optimize over arbitrary formulas optimization it can precisely compute abstract transformers over program fragments encoded as formulas without precision due to join or multiple applications of the transformer this problem is known in the literature as symbolic abstraction and has been studied for a number of domains by designing optimization algorithms that exploit the power of smt solvers we enable efficient implementations of precise abstract transformers for a variety of numerical domains we discuss this application in more detail in sec where we generate our benchmark suite from symbolic abstraction queries made by a program analysis tool a similar approach can be used for solving systems of clauses in which capture a large number of sequential and concurrent program verification tasks since horn clauses are represented symbolically in applying traditional numerical abstract domains for solving them is not a straightforward but symba can be easily used to build a fixpoint solver for such clauses · counterexample generation in symbolic execution and bounded model checking program executions are encoded as a formula an smt solver is then used to find a satisfying assignment of this formula that acts as a witness of an erroneous execution by the encoding with arithmetic cost functions we can use symba to find counterexamples that or minimize certain criteria for example we might be interested in finding performance bugs eg execution traces with the energy or memory consumption by assigning costs to program instructions and api calls we can detect such executions using an optimizing smt solver · program synthesis program synthesis involves generating a program that satisfies a given specification for example in nontrivial program are synthesized from specifications by using smt solvers to search through all possible combinations of operations instructions similar to the counterexample generation described above the goal is often to synthesize the shortest programs or ones with the smallest cost for example when the synthesized is part of a code eg as in the size of the synthesized and the operations it performs are crucial by formulas given to the smt solver with costs we can it to synthesize programs that minimize a given criterion · constraint programming in recent work et al proposed an smt solver into an extension of scala allowing constraint manipulation as part of the language one of the important constructs in their language is which returns the satisfying assignment of a constraint wrt to an objective function and enables elegant implementations of algorithms for problems like due to the of solvers with an optimization feature the authors use a simple binary search optimization algorithm restricted to bounded discrete domains the authors of also comment on the of smt solvers by saying we found that a number of features if supported by solvers could directly bring benefits to constraint programming these include support for enumeration of theory models and solving constraints while a given term symba is thus an answer to point for terms objective functions · interpolant generation craig interpolation has proved to be a powerful technique for software verification based on predicate abstraction interpolants are generated from proofs for linear real arithmetic this can be performed by constructing a system of constraints whose solution is a proof of and an interpolant as recently shown the simplicity of the proof can be crucial to discovering the predicates required for a safe inductive invariant finding simple proofs down to finding an optimal solution of the system of constraints using symba this can be automated without the need for the heuristics employed in symbolic optimization with symba given a formula and a set of objective functions objectives for short t t tn symba computes the strongest formula t k tn kn such that where ki r we call the optimal solution of t wrt in other words symba computes the least upper bound maximum value ki of each objective ti wrt the satisfying assignments of note that we are optimizing a set of objective functions as opposed to a single function as in traditional optimization problems this allows symba to reuse information computed for one objective in order to speed up the optimization of other objectives this feature allows incremental implementations of symba where we can ask for optimizing different objectives without previously computed information in a style similar to the interface implemented by most smt solvers the incremental interface is useful for example when computing an abstract transformer for the intervals domain where we need to find the maximum and minimum values of each live variable symba maintains both an under and an overapproximation of the optimal solution it works by sampling points models in in a systematic manner using an smt solver and adding the points to the underapproximation in order to extend it the process continues until the underapproximation is equal to the optimal solution the key insight underlying symba is how to carry out the sampling process in an infinite space of satisfying assignments while ensuring convergence to least upper bounds and discovery of unbounded objectives symba also maintains an overapproximation of when it terminates the two approximations are equivalent maintaining an overapproximation allows us to halt symba at any point and still compute an overapproximation of the optimal solution eg an overapproximation of the best abstract transformer this makes symba to smt solver failures and resource eg time another important feature of symba is that it treats the underlying smt solver as a using it to generate models and check validity this makes symba easy to implement allowing us to take advantage of the existing smt solvers without having to into their implementations and directly from future advances in smt solving our implementation of symba uses the z smt solver we have performed a evaluation of symba on a large set of realistic benchmarks drawn from program analysis tasks we have also compared symba against which is to the best of our knowledge the only other proposed optimization technique the technique of a single objective function and is built into the smt solver for a note that our goal is to find an optimal value for each objective independently using a different satisfying assignment of as opposed to a satisfying assignment ie a single assignment that all objective functions and cannot be improved upon son against symba we have also implemented a extension of the approach in in the z smt solver using its available source code and with various configurations our results demonstrate the efficiency and of symba against approaches and the effectiveness of its feature and our proposed implementation optimizations contributions we summarize our contributions as follows · symba a novel optimization algorithm for objective functions in linear real arithmetic with applications in program analysis synthesis etc symba efficient smt solvers as black boxes thus it is easy to implement and it directly benefits from future advances in smt solving moreover symba can optimize a set of objective functions information between them to speed up the optimization task · an extensive evaluation of symba against other proposed techniques in the literature on a large set of program analysis benchmarks our results indicate the power and efficiency of symba in comparison with approaches and the importance of its feature · an implementation of symba multiple implementations of the approach in and a large set of optimization benchmarks drawn from program analysis tasks our source code and benchmarks are available at organization in sec we demonstrate the operation of symba on simple examples in sec we formalize symba and prove its correctness in sec we describe our implementation and experimental evaluation in sec and we compare symba to related work and conclude the paper respectively symba by example in this section we illustrate the operation of symba on two formulas a dimensional and a dimensional one a dimensional example consider the formula y x x containing the real variables x and y and represented by the black boxes in fig suppose that our set of objectives is t y xy that is we would like to find the least upper bound for y and x y in note that if we want to find the minimum value for y we can simply add y as an objective to t in this example the optimal solution is y x y since x y is unbounded in formulas of the form t treated as true and t as false initially the underapproximation of is u y x y false are and the overapproximation is o y x y true symba maintains the invariant u o note that u is an under approximation of not necessarily and similarly with o symba between two main operations which is used to grow the underapproximation by sampling points models of that lie outside the underapproximation and unbounded which is used to detect unbounded objectives in this example is the upper bound for y and x y is unbounded first symba starts with a by an smt solver for a model of that is not a model of u ie lies outside the underapproximation suppose the solver returns the point p the underapproximation u is the strongest formula of the form t k tn kn that contains the set of points found by the solver ie a convex hull expressed in terms of the objectives so the underapproximation is updated to u y x y since the maximum values of y and x y seen so far are and respectively this is shown as the region u in fig unbounded p y symba now tries to prove that y is unbounded first we points into boundary classes as follows let e l k l k ie e is the set of all atomic formulas appearing in with the inequalities replaced by equalities in our example e x x x y y informally e represents the set of edges boundaries appearing in fig the boundary class p of a point p is e e p e ie the set of equalities in e satisfied by p for p p since p does not lie on any of the boundaries the intuition underlying unbounded is finding a r from a point p in such that a given objective t is increasing along r and r never any boundaries of ie completely contained in unbounded queries the smt solver for a point p st p p and where is the valuation of y at point p the point p satisfies this condition then unbounded queries for a point p st p p and if no such p exists then we know that y is unbounded intuitively we are whether we can keep increasing the value of y from p without a point p on one of the boundaries in e in this case such a p exists so it is added to the underapproximation as p in fig note that p the upper bound of y symba detects that and the overapproximation o to y after the point p u is updated to become y x y see region u in the figure second suppose that symba calls the result is a point in but not in u let p be the point found by as a result u is updated to y x y see region u unbounded p x y symba now applies unbounded to check if xy is unbounded suppose unbounded the point p first it finds a point p which increases x y and is in the same boundary class as p then it tries to find a point p that has a boundary class p p and has a greater or equal valuation of x y than p since no such point p exists symba concludes that x y is unbounded intuitively symba that it is possible to keep finding points along the boundary y that increase x y without any other boundary thus that xy is unbounded we formally specify and prove the correctness of unbounded in sec the underapproximation u is now updated to become y region u by the upper bound for x y at this point u o so symba terminates with the optimal solution y a dimensional example we now illustrate the operation of symba on the formula x z y x y x containing the variables x y and z and depicted in fig suppose for simplicity that we would like to find the least upper bound only for y ie t y y p p p u u u u x figure illustration of symba on a d example first similar to our previous example symba starts with u false and o true and uses to find the initial point suppose the smt solver returns the point p denoting values of x y z thus u y unbounded p y to check if y is unbounded symba applies unbounded starting from p since it cannot prove that y is unbounded it finds the point p where p p and ie a point showing that increasing the value of y from p can a boundary after applying unbounded to p symba can get the point p and then point p after applying unbounded to p as a result u y from point p symba cannot apply unbounded since there does not exist a point p where p p that increases the value of y intuitively p represents a local maximum second to escape the local maximum symba uses to query the smt solver for a point outside u in this case it might find the point p and thus u becomes y unbounded p y symba continues trying to prove that y is unbounded by performing unbounded from p leading to p and then p symba detects that p represents the maximum value of y in and terminates with the optimal solution y we have illustrated the of symba on two formulas representing shapes and showed how it an smt solver to find least upper bounds and detect of arbitrary linear expressions objective functions in the following sections we describe symba formally and discuss our implementation and experimental results symba the symbolic optimization algorithm in this section we provide definitions required for the rest of the paper and formalize symba as a set of inference rules definitions formulas let l be a ie all atoms are nonstrict inequalities subset of quantifier free linear real arithmetic qf defined as follows l true false p p p p p p atoms cx · · · k n n xi vars x xn where ci k r we use to denote the set of all satisfying assignments models of a model p vars r of denoted p y p p p p p z p p x figure illustration of symba on a d example is a valuation of the variables of such that p true where p is with every occurrence of a variable x replaced by px p is a point in rn and in what follows we use the terms model and point to refer to p we use atoms to denote the set of all atoms appearing in and vars to denote the set of all vars appearing in optimal solutions let be a formula in l let t t tn be a set of linear expressions objective functions where each ti is of the form cx · · · where ci r and vars x xm the goal of symba is to compute a vector k kn where each ki r such that for each ti ti ki and there does not exist ki ki where ti ki we say that k kn is the optimal solution of t wrt and denote it as we call each value ki the optimal value or the least upper bound of ti in given such a vector v k kn where n t we use v to denote the formula in ti ki given a model p of we use pt to denote the vector tp tt p given two vectors v and v of equal length we use v and v to denote the pointwise minimum and maximum of the two vectors respectively we say v v if each element of v is less than or equal to its corresponding element in v or if there exists a in v intuitively v v iff v v therefore we say that v is weaker than v if v v or v is stronger than v combinations of theories for clarity of presentation we restrict ourselves to applying symba to formulas in l it is important to note however that symba is applicable to quantifierfree formulas over any combination of theories t where t is an arbitrary combination of theories and is linear real arithmetic restricted to nonstrict inequalities the only restriction we require is that t and have disjoint signatures in other words atomic formulas should be over t or exclusively for example t can be the combination of the theories of and arrays perhaps for modelling program executions the rest of our presentation can apply directly to smt formulas over t without any modification symba formalized we now formalize the symbolic optimization algorithm symba as a set of inference rules shown in fig given a set of objectives t t tn and a formula in l symba computes the state of symba is a tuple m u o where m is a set of models of u is an underapproximation of ie u is invariant and o is an overapproximation of ie o is init p u m u o m p pt o u k kn p p p tip tip p · tip tip p p m ti t m u o m k ki ki kn o p p tip tip tip p p p m u o m p pt o m ti t o k kn m p m ti m t m u o m u k ki m ki kn figure inference rules used by symba invariant note that for clarity of presentation we treated u and o as formulas in sec whereas here we treat them as vectors and use v to convert a vector v to the formula it represents when symba terminates we know that u o initially as defined by the rule init m u and o the rules unbounded and are used to weaken u until it is equal to whereas bounded o until it is equal to finds a model of that is not captured by u ie lies outside the underapproximation and adds it to u to weaken it using max when the rule no longer applies we know that u note that applying this rule alone does not guarantee that u eventually reaches for two reasons since we are dealing with real variables might keep finding models that approach the upper bound of one of the objectives asymptotically cannot detect whether an objective is unbounded so it will keep finding models that increase the value of the unbounded objective to that end the rules unbounded and are used to detect unbounded objectives and help avoid asymptotic behavior unbounded takes as parameters a model p m and an objective ti t and attempts to prove that ti is unbounded as follows first it tries to find a point p such that p p and tp tp then it looks for a point p such that p p p and tp tp if no such p exists then t is unbounded in otherwise adds p to m the intuition here is as follows if we can find a model p then we know that t can increase along the in e if no point p exists then we know that we can keep increasing t without any of the boundaries in e that are not in p thus showing that t is unbounded this is analogous to the technique used by the method for showing that a dimension is unbounded in a convex polyhedron we further discuss the intuition underlying unbounded and prove its correctness in sec in addition to the rules the rule bounded detects whether a model p m the least upper bound of some objective t and the overapproximation accordingly note that the overapproximation is not required for the correctness of symba but its availability allows us to guarantee that symba maintains a sound approximation o of at every point of its execution this makes symba to smt solver failures and allows us to limit resource consumption when desired that is by terminating symba during its execution we can recover optimal values of some of the objective functions as maintained by the overapproximation example we illustrate the applications of the rules on the d example from sec and shown in fig assume that after the initial call to m p u y x y and o true applying to p m and y t adds p to m next bounded is used to detect that p the least upper bound of y and updates o so that o y assume that the second application of adds point p to m applying x y detects that x y is unbounded at this point u becomes y making therefore u and u o in what follows we discuss and prove soundness of symba and define terminating sequences of rule applications soundness we start by showing soundness of the unbounded rule a necessary and sufficient condition for proving that a given objective t is unbounded within is the existence of a convex polyhedron c eg a such that t is unbounded in c and c our solution addresses two problems how to restrict the space from which c is drawn while maintaining completeness ie ensuring that c is found whenever t is unbounded in how to check that c the idea we use here is to restrict c to formulas of the form e t k where e e and k r this space of convex polyhedra is sufficient for completeness for instance consider the example from fig to prove that the x y direction is unbounded we find a point p that lies on the boundary y e and ask whether c y x y is contained in furthermore we perform the containment check implicitly by checking whether there is a point in c along any direction that increases x y that a boundary of in our running example such a point does not exist see fig thus x y is unbounded for another example consider the point p since p does not lie on any boundary to check if x y is unbounded we ask whether c x y is contained in ie we check whether increasing x y in c does not boundaries in this is not the case and the counterexample is the point p shown in fig that lies on the boundaries x and y thm formalizes this construction using boundary classes and states its correctness for proving that an objective is unbounded in theorem soundness of unbounded given a formula in l and a linear expression t over the variables of then k r · t k ie t is unbounded if and only if there exist p p such that tp tp p p p · tp tp p p proof proofs are available in the appendix in other words if the unbounded rule was applied then c p t tp is contained in in the theorem conditions and imply that t is unbounded within c and condition implies that increasing t in c does not any boundaries of ie p t tp is subsumed by it follows from this theorem that unbounded maintains the invariant u since the optimal solution cannot have a least upper bound for t if it is unbounded ie the least upper bound of t is theorem soundness of symba if does not apply ie u false then u proof follows trivially from the invariant u termination we now discuss sufficient conditions for ensuring termination of symba for simplicity of presentation we assume that t contains a single objective t we start by defining a fairness condition on the scheduling of rules that ensures termination a fair scheduling is an infinite sequence of actions a a where ai unbounded and the following conditions apply appears infinitely often and if a point p is added to m along the execution sequence then both t and t eventually appear condition ensures that symba does not get stuck in a local maximum condition ensures that we visit every local maximum by every boundary class thus that either the least upper bound of t is found or it is proved unbounded recall the d example from sec where t y suppose our execution only applies the rule then u might grow asymptotically towards the least upper bound of y eg y y y etc never reaching y condition forces computing models that lie on one or more of the boundaries e thus avoiding this asymptotic behaviour but applying unbounded and alone without applying might get us stuck in local for example on point p in fig are condition ensures that we eventually find a model outside the current underapproximation see p thus the local maximum a for an objective t is a sequence of points p pk where i · pi pi pi and t fails to apply for example in fig p p p p is a since pi for a strictly grows in size and the largest boundary class has size at most atoms a is of length at most k atoms lemma states that the last model pk of a always the largest value of t in its boundary class pk lemma let be a formula and t be an objective bounded in then in every execution of symba the last element pk in every for t satisfies p pk proof according to the definition of a t does not apply since t is bounded premises of unbounded do not hold either combining premises of the two rules there does not exist pk pk such that thus p pk we are now ready to prove termination of any fair execution of symba we assume that symba terminates when is no longer applicable ie u theorem symba terminates after a finite number of actions in any fair execution proof we split the proof into two cases as follows case t is bounded within suppose symba is non terminating then in any fair scheduling infinitely many creates infinitely many following lemma there are infinitely many models p in the execution sequence such that p and tp p p we denote the set of such points by p in any fair execution must appear after p is added to m therefore there exists a point p p such that tp tp as a result there is a sequence of points p p in p such tp tp tp · · · hence i j · i j pi pj since the number of boundary classes is finite symba eventually finds the least upper bound of t and terminates case t is unbounded using the same argument as above symba eventually finds a point in an unbounded boundary class due to the finite number of boundary classes such that the three conditions in thm hold after that becomes implementation and evaluation implementation we have implemented symba in c using the z smt solver for satisfiability queries our implementation accepts a formula and a set of objectives t written in the standard format it then computes the optimal solution and returns the result we have made available the executable and benchmarks online detecting unbounded objectives our implementation of unbounded and exploits the incremental interface that most smt solvers supply moreover instead of implementing the bounded rule explicitly we show how to update the overapproximation for free as a side effect of applying the unbounded rules fig shows the procedure our implementation of the unbounded rules we assume that there is a global smt context in which the formula has been an active boundary class c and a objective ti are passed in as parameters u ti and refer to the ith element of the vectors u and o respectively sat and refer to the current state of the smt context and returns a model satisfying the current function pe ti t push u ti if then u ti pop return assert c if then pop return assert e c if sat then pop return else unbounded u ti pop return figure implementation of state of the context if one exists push and pop are used to store and restore the state of the context respectively we start by incrementally the conditions of unbounded implicitly given c and ti we know that there is a previously point p c such that tip u ti first in lines we check if there exists a model p such that tip tip and p p we do this in two stages we first check if there exists p such that tip tip if not we can update the overapproximation o accordingly line otherwise we check if there exists p in the same boundary class as p line if no such p exists then neither unbounded nor applies given that p exists we check for the existence of p in a stronger boundary class lines if p exists we apply otherwise we apply unbounded scheduling policy our implementation is a scheduling of rules fig that satisfies the fairness conditions in sec we start by applying the rule to obtain an initial point p we generate a starting at p for each t t by applying until either unbounded is applicable in which case the objective is unbounded or is not applicable in which case we apply to obtain a new initial point and start the process again it is easy to check that this is a fair sequence and therefore this process always terminates to evaluate variations of the scheduling policy described above we instrumented our implementation with a parameter balance which ensures that does not take more than balance of the total execution time specifically during execution if has taken more than balance of the time symba switches to applying the rule until the time taken by so far is less than balance of the time intuitively when balance is the deterministic schedule described above is in effect optimizations another effective optimization is to limit e to a relevant subset when applying the unbounded rule in our experiments we that the set e of equality constraints can be quite large which the smt solver removing irrelevant equality constraints decreases the size of the smt queries to find the set of relevant constraints we define a relation atoms × atoms as follows p p if and only if or p atoms · p p p p where is the set of variables appearing in p we then define the boundary class of p wrt t as pt a e p a t a removing constraints that are not related to t corresponds to carrying out our algorithm on the pro of variables of objectives of nodes in dag max min table aggregate statistics of our benchmarks of onto a space where the projection is guaranteed to have the same maximum value for t as thus correctness is not affected experimental evaluation our experimental evaluation is designed to compare symba against other symbolic optimization techniques and to the effectiveness of our different implementation heuristics we two classes of experiments a comparison with existing optimization techniques and an evaluation of the effects of different implementation heuristics as well as information reuse among multiple objectives on the efficiency of symba we describe these in detail below benchmarks as discussed in sec one possible application of optimization is computing abstract transformers for numerical abstract domains we have incorporated symba into the program analysis and verification framework and used it as an abstract transformer abstract post operator for the family of template constraint matrix domains a domain is parameterized by a set of templates t t tn which are linear expressions over program variables given an abstract state pre describing a set of initial pre states and a program fragment encoded as a formula lf the best most precise abstract transformer for a domain computes the strongest formula ti ki that is implied by pre lf thus we can use symba to compute the best abstract transformer by simply computing pre lf note that the domains a number of popular domains including intervals etc for instance by setting t to all live variables and their negation at the destination program location then we get an intervals domain since the result of symba can be interpreted as the minimum and maximum value of each program variable after executing the program fragment denoted by lf we generated our benchmarks from a set of c programs used in the software verification the programs cover a range of software from linux and windows device drivers to models of ssh and concurrent programs we the set down to c programs that were not trivially proved correct or incorrect by we instrumented to record abstract post queries in format and collected k queries made by on these c programs each abstract post query is represented by a formula encoding a set of initial states and a program fragment between two cutpoints as in large block encoding for the set of objectives we used all variables as well as their negation that are in scope at the destination ie an intervals domain from the generated queries we selected the benchmarks for evaluation which took symba more than s to process table shows the average maximum minimum and standard of the number of variables objective functions and nodes in the dag representation of the formulas in our benchmarks we all of our experiments on a machine running linux with an intel i processor and gb of ram we programs from the following categories and comparing with existing tools to the best of our knowledge the work of and is the only other smt technique that addresses the problem of finding optimal assignments for objective functions at a high level the technique works as follows a sample a satisfiable disjunct d from a given formula using an smt solver b since d is a conjunction of atoms the linear arithmetic atoms in d represent a convex polyhedron so use any linear programming lp solver to find the optimal value of a given objective function within the given disjunct c check using an smt solver whether the result is optimal for all of if not go back to step a and sample a new disjunct the process is guaranteed to terminate since there are finitely many we have acquired a binary of the implementation described in from the authors their tool is called as it is built in the smt solver there are two issues the validity of a direct comparison between symba and accepts a single objective function meaning that we have to call it multiple times per benchmark each time with a different objective since we do not have access to its source code we cannot tell if multiple calls to significant preprocessing overhead our implementation of symba uses z as its underlying smt solver whereas uses in order to avoid these issues and establish a comparison we have implemented two versions of the linear search ls algorithm proposed in and implemented in by accessing the available z source code we modified the linear arithmetic solver of z to allow optimization of objectives in the satisfying assignments a solver like z finds satisfiable conjunctions of atoms from a given formula and uses a theory t solver to decide the satisfiability of the atoms in our case linear constraints we instrumented zs linear arithmetic solver such that it does not terminate immediately after the first satisfying assignment is found but finds an optimal satisfying assignment for a given objective function this was implemented using the standard incremental solving procedure under exact rational representation we call the modified tool is an implementation of ls in z that uses as its lp solver this is analogous to the implementation described in where a modified version of linear arithmetic solver is used as the lp solver uses an lp solver as its convex optimization engine we have chosen two wellknown open source lp libraries the linear programming and the sequential objectoriented both versions of ls use z for sampling and checking optimality ie steps a and c above but different lp solvers for finding optimal values step b unlike both and accept multiple objective functions and optimize them simultaneously specifically in step b they make multiple calls to the lp solver to find an optimal value for each objective function we used v the solver implements the method based on floating point arithmetic we used v which uses floating point arithmetic symba configurations we use the following symba configurations symba with different scheduling policies where x specifies the value of balance same as symba but a single objective at a time that is execution is from for each objective function same as but uses z with the modified linear arithmetic solver we describe this in more detail below results symba vs other techniques fig a shows the results of running symba vs on the benchmarks with a timeout of seconds per benchmark each point on the graph represents a benchmark the correspond to the cpu time measured in scale taken by symba and the points above the diagonal represent problems where symba is faster points at the top right corner are cases where both and symba cannot complete the benchmark in the seconds has vs by symba our results clearly show that symba on our set of benchmarks in most cases the average and maximum speed up of symba vs are x and x respectively we now compare symba against our implementation of the linear search algorithm employed by fig b compares the execution times of symba vs the results clearly demonstrate the performance of most benchmarks are solved in less time by often by an order of magnitude has to understand the reasons behind these performance differences we took a closer look at the benchmarks where symba is significantly slower than we two problems for symba on these benchmarks the of the time is spent in the function indicating the expensive nature of calls and of our scheduling strategy when balance applications of make very small to the underapproximation u indicating that we prefer applications of to address point we that does not take more than of the execution time by setting balance to to address point we considered applying using described above instead of z that is instead of z for a point that lies outside the underapproximation u we made supply with one of the objective functions and whenever the zs solver finds a satisfiable disjunct with a point outside the underapproximation it finds a satisfying assignment that that objective function within that disjunct this causes the rule to produce models that are away from the current underapproximation convergence we call this configuration fig c compares the execution times of vs the results now show that on of the benchmarks with a x maximum speedup and a x average speedup per benchmark moreover solves all benchmarks without timing out we have also run the two other configurations of lin since accepts a single objective at a time we invoked it multiple times per benchmark giving it a timeout of seconds per objective if the total time for all objectives taken for a benchmark is more than seconds is considered to have out search and they exhibit similar behaviour to but are slightly slower we all results produced by different tools when they do not timeout and all of them match results configurations table summarizes the results of running all the algorithms and configurations on the same set of benchmarks with a timeout of seconds per benchmark the results of running symba are summarized in row of table symba was able to solve out of benchmarks in seconds in the process it made k smt queries using invocations of and invocations of rows capture the results of running where x is and respectively when x is time spent in is restricted to of the total time the number of calls goes up by about time is spent in making discovery rather than big towards the goal this even affects the number of calls slightly increases since more points are when x is it was only able to solve benchmarks for which the number of calls to goes above k while the number of calls to to k our experiments show that is the best value for balance when running conversely when running we found that we greatly benefit from a lower balance value balance gives us best performance since there the rule can discover unbounded objectives the on see row of table was able to solve problems in seconds uses the same configuration as symba except that it finds solutions for multiple objectives independently without models different objectives as symba does using causes the number of smt queries to go up by and the number of calls to increase by optimizing multiple objective functions simultaneously ensures that all objectives benefit from the models and potentially avoids expensive smt calls summary the experiments compare our proposed symbolic optimization algorithm with existing techniques and the effectiveness of various implementation heuristics and optimizations we compared symba with as well as two lp based implementations of its algorithm on a large set of benchmarks generated from program analysis tasks the results demonstrate the power of approach a configuration that both efficient scheduling policy and convex optimization them all and solves all the benchmarks our experiments also demonstrate the importance of capability related work our work with different areas of research in this section we compare symba with other optimization techniques in sat and smt solvers optimization techniques employed within the context of abstract interpretation linear programming techniques and classification techniques from the machine learning community optimization in within the smt and sat solving numerous forms of optimization have been proposed eg in the to symba is the recent of work of and similar to symba we omit symba and symba from the table as they exhibit similar performance to symba they propose an solution for optimizing objective functions in and to the best of our knowledge this is the only other work that addresses this problem as explained in sec this approach works by sampling a satisfiable disjunct convex polyhedron from a given formula using the smt solver as a black box then using any lp solver it finds the optimal value of an objective function in that disjunct it then checks if the optimal value is globally optimal again using the smt solver otherwise more are effectively this approach builds the dnf of a formula until the disjunct with the optimal value of a given objective function is found compared to symba does not require an lp solver or access to a modified theory solver within the smt solver instead symba offers a simple and elegant optimization algorithm that can be easily implemented on top of existing smt solvers without using any external tools moreover symba can simultaneously optimize multiple objective functions symba also maintains an overapproximation of the optimal solution allowing us to terminate it and still optimal values for a subset of the objective functions as we show in sec the feature can also be implemented within the approach of both symba and can apply to formulas over mixed theories in et al proposed a theory of costs for an smt solver with pb constraints at a high level their theory allows associating a cost with individual boolean constraints the goal then is to find a satisfying assignment that the total cost thus the theory of costs enables encoding weighted problems ­ in fact the two problems are equivalent it is easy to see that symba subsumes the weighted problem for example we can associate with each boolean constraint bi a cost ci and add a constraint ci ki ci where ki r then our objective is to minimize or the sum of all costs c cn another form of optimization in the smt framework is that of and their optimization technique extends the traditional algorithm for smt solving with extra rules for strengthening the theory t during execution eg a theory solver for linear arithmetic might be to find only assignments with values less than this allows the solver towards satisfying assignments that or minimize certain objective functions the authors show how to implement weighted in their general framework it is to us if their theory strengthening approach can be used to implement an optimization procedure for objective functions as in this paper moreover unlike symba their approach is not easily implementable as it requires deep modifications to an smt solver in more recent work et al consider the problem of finding most likely satisfying assignments in the presence of probabilistic constraints there an smt solver is used to handle axioms ie constraints with or probabilities and a relational solver eg is used to handle other probabilistic constraints it is important to note that the relational solver can be replaced by a weighted solver as noted in thus symba can be directly applicable to solving such problems we leave this interesting direction for future work optimization in abstract interpretation numerical abstract domains have been an active subject of research due to their importance in different program analyses as discussed earlier an important operation in such domains is the abstract transformer post which can often be as an optimization problem over formulas in as a result optimization has been a subject of interest within the program analysis community for example proposed an algorithm for computing best abstract transformers of template constraint matrix domains over code as discussed in sec x x x time of time of time of s time of s a time of s b time of s c figure performance comparison between a symba vs b symba vs and c vs configuration symba symba symba total times smt queries a solved a we do not count calls to lp solver including in step b table overall results for different symba and ls configurations as well as on the benchmarks domains are parameterized by a set of templates t or objective functions program segments along with a set of initial states can be encoded as a formula in then the problem of computing the best abstract transformer becomes that of computing this problem is known in the program analysis community as symbolic abstraction the approach in uses quantifier elimination which is admissible in in later work and attack the problem from a different using an smt solver to sample d of and using solvers to find the optimal solution d of each disjunct surprisingly this is done in the same manner as proposed by and for optimization in smt discussed above recently and reps proposed a generalization of sat solving method to richer logics the algorithm attempts to prove a formula unsatisfiable by iteratively refining an overapproximation of starting from true until at false they showed how the algorithm can be instantiated with abstract domains such as polyhedra and used to compute best abstractions of formulas in within the given abstract domain thus by instantiating their algorithm with a domain we can compute for in their approach is a general framework for symbolic abstraction that is applicable to a wide range of logics and abstract domains in contrast to these techniques our goal with symba is to bring optimization to an smt setting the power and generality of smt solvers and making optimization directly usable by researchers who are already familiar with and using smt solvers additionally with symba we do not only find the optimal value of a given objective function but also the satisfying assignment that results in such a value found in the set of models m this is a crucial requirement when eg searching for optimal counterexample witnesses where we need a trace of the counterexample ie an optimal satisfying assignment and not the optimal value of the given objective function linear programming in the field of linear programming the optimization problem over conjunctions and of convex polyhedra as in our setting has been known as linear disjunctive programming later linear generalized disjunctive programming was proposed there boolean variables are used to explicitly model discrete decisions and are equivalent to symba when it is applied to formulas over and propositional variables most approaches for solving problems carefully convert the problem to a mixed integer linear programming problem eg and use existing solvers to solve it in comparison to such techniques symba can handle formulas over arbitrary theories in combination with and can simultaneously optimize multiple objective functions additionally symba uses infinite precision rational arithmetic employed by smt solvers whereas solvers tend to use floating point arithmetic potentially precision classification and machine learning a fundamental problem in machine learning is classification given a set of positive and negative examples find a classifier that whether a given example is positive or negative for example using support vector machines one can compute linear inequalities separating positive and negative points in some space rn symba can be viewed as a sophisticated classification algorithm where positive and negative examples are models of and ¬ respectively the goal is to find the best classifier represented by a conjunction of linear inequalities objective functions that does not any of the positive examples ie is implied by symba only samples positive examples from and keeps weakening a classifier the underapproximation u until it all positive examples as reps et al point out in weakening an underapproximation by sampling more points is analogous to the approach of the simple learning algorithm finds finds a classifier starting from false by iteratively taking into account more and more positive examples conclusions and future work we proposed symba an efficient optimization algorithm for objective functions stated in the theory of linear real arithmetic symba efficient smt solvers as black boxes making it easy to implement without requiring modifications to existing smt solver implementations and enabling it to directly benefit from future advances in smt solving we have evaluated symba on benchmarks drawn from abstract transformer computations for numerical abstract domains our experimental evaluation indicates the advantages of our approach over other proposed techniques we see many for future work first the most natural next step is extending symba to integer arithmetic objective functions we believe this can be done by rules with new ones that introduce in order to infeasible solutions another interesting direction is handling nonlinear objective functions in order to model complex cost functions from an engineering perspective we would also like to study efficient parallel implementations of rules references on software verification http smt solver z source code a and k l interpolants in proc of cav pages ­ a a and m a framework for abstraction and software verification in proc of cav pages ­ e disjunctive programming properties of the convex hull of feasible points discrete applied mathematics ­ ­ t ball and s rajamani the slam in proc of cav volume of lncs pages ­ c a and c the standard version technical report department of computer science the university of available at c c m l d t a reynolds and c in proc of cav pages ­ c w r s a and c satisfiability modulo theories in of satisfiability pages ­ p a based enumeration algorithm for linear optimization technical report d a a m e and r software model checking via encoding in proc of pages ­ g m a d gordon c and d e semantic subtyping with an smt solver j program ­ n k and a rybalchenko program verification as satisfiability modulo theories in proc of smt c d and d r and automatic generation of tests for complex systems programs in proc of pages ­ a a a and s rajamani combining relational learning with smt solvers using cegar in proc of cav pages ­ a a a r and c satisfiability modulo the theory of costs foundations and applications in proc of tacas pages ­ a a b j and r the smt solver in proc of tacas pages ­ e clarke d and f a tool for checking programs in proc of tacas volume of lncs pages ­ march p cousot and r cousot static determination of dynamic properties of programs in proc of the la p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in proc of popl pages ­ l de and n z an efficient smt solver in proc of tacas lncs pages ­ r and k r m leino a typed procedural language for checking objectoriented programs technical report microsoft research b and l de a fast solver for in proc of cav pages ­ s f and c improved bounded model checking of c programs using llvm in proc of tacas pages ­ h g r a and c fast decision procedures in proc of cav lncs pages ­ p n and k dart directed automated random testing in proc of pldi pages ­ p m y and d a for security testing acm ­ r e outline of an algorithm for integer solutions to linear programs math ­ s n p c and a rybalchenko synthesizing software from proof rules in proc of pldi pages ­ s gulwani s a and r synthesis of programs in proc of pldi pages ­ a gupta c and a rybalchenko solving horn clauses over in proc of pages ­ a s and s efficient predicate abstraction of program summaries in proc of volume of lncs pages ­ w r s f and a gupta program analysis via satisfiability modulo path programs in proc of popl pages ­ t henzinger r jhala r majumdar and g lazy abstraction in proc of popl pages ­ t a henzinger r jhala r majumdar and k l abstractions from proofs in proc of popl pages ­ s s gulwani s a and a program synthesis in proc of pages ­ a s v and p constraints as control in proc of popl pages ­ k r m leino an automatic program verifier for functional correctness in proc of pages ­ a the linear programming h a look at the smallest program comput ­ oct a the abstract domain j higherorder and symbolic computation ­ t m mitchell machine learning inc new york ny usa d automatic modular abstractions for linear constraints in proc of popl pages ­ d automatic modular abstractions for template numerical constraints logical methods in computer science d and l using bounded model checking to focus fixpoint iterations in proc of sas pages ­ r and a on sat modulo theories and optimization problems in proc of sat pages ­ f c a and j scaling up statistical inference in markov logic networks using an proc of pages ­ r t and d separation logic using smt in proc of cav j c fast training of support vector machines using sequential minimal optimization in advances in kernel methods pages ­ mit press r and i modelling and computational techniques for logic based integer programming computers and engineering ­ t reps m sagiv and g symbolic implementation of the best transformer in proc of volume of lncs p m m and r jhala types in proc of pldi pages ­ a rybalchenko and v constraint solving for interpolation j comput ­ s h b and z manna scalable analysis of linear systems using mathematical programming in proc of pages ­ n w and i e a method for solving linear generalized disjunctive programming problems computers and engineering ­ r and s optimization in smt with cost functions in proc of pages ­ m and g a on proof procedure for propositional logic ­ a l r s a and v a combinatorial for finite programs in proc of pages ­ a v and t w reps a method for symbolic computation of abstract operations in proc of cav pages ­ a v m and t w reps algorithms for symbolic abstraction in proc of sas pages ­ r phd thesis berlin appendix lemma given an l formula c defining a convex polyhedron conjunction of linear constraints if p c p p tp tp and p c · tp tp p p then p c proof formula c p can be written as a system of linear inequalities as follows ax b a cx d b by definition p satisfies the system and eq a is a subset of p according to the definition of boundary class because p p p must satisfy eq a suppose p c then there exists some k such that ck · p dk and ck · p dk note that ck · p dk since ck · p dk and p p we now show that there exists a point pk p p in the convex hull of p and p st ck dk since tp tp it is easy to show that tp let dk dk where and and we have ck · pk dk we know that p pk because pk is in the convex hull of p and p and ck · x dk p ck · x dk pk suppose pk c ie there exists j st cj · pk dj we then repeat the above process each point pi found satisfies tp p pi we are guaranteed to find a point p in the convex hull st it is also within c because in each step we satisfy at least one more inequality this contradicts the condition p c · tp tp p p therefore p c proof of thm we prove this direction by contradiction first let p p be two models satisfying the three conditions of the theorem suppose there is a point p st tp is the upper bound for t in we show that there is always a point p st tp tp pick a point p st p p p p it follows that tp tp when p p p p the notation p denotes the vector representation px of the model p vars r where vars x xn let the formula define a convex polyhedron st p and let c p we know the following c defines a convex polyhedron by its definition p c · tp tp p p by condition of the theorem p p since p is in the affine set of p and p tp tp since following the result of lemma p is in c which is also in this contradicts the assumption that tp is the least upper bound for t therefore term t is unbounded in given that t is unbounded in we look for two models p p that satisfy the required conditions pick p p st p p tp tp and p is the most restrictive boundary class within which t is unbounded ie t is unbounded in p and there does not exist a boundary class c p st t is unbounded in c we know that such a class exists because t is unbounded in otherwise t is bounded in every boundary class and is bounded in other words since there are infinitely many models of with increasing values of t and finitely many boundary classes there has to be a boundary class p st t is unbounded in p and there doesnt exist a class c p where t is unbounded in c if there are no classes c p or for every c p c false then p and p satisfy the three conditions of the theorem otherwise let m where cp c ie all classes stronger than p we know that m is defined ie not because of our assumption on the class p if m tp then p and p satisfy the three conditions of the theorem otherwise since t is unbounded in p we can find two models p p st m tp tp and p p p as a result p and p satisfy the three conditions in the theorem 