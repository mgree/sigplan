record of the fifth annual acm symposium on principles of programming for denotational data flow semantics programs languages paul r ibm thomas j watson research center po box heights new york laboratory for computer science massachusetts institute of technology cambridge massachusetts keywords data flow programming denotational semantics abstract data flow programming languages are especially amenable to of their semantics in the denotational style of scott and however many real world programming problems such as ing systems and data base systems require a programming language capable of because of the behavior of their cal environment to date there has been no satisfactory denotational semantics of programming languages with this paper presents a straightforward denotational treatment of data flow programs as functions from sets of tagged sequences to sets of tagged sequences a simple complete partial order on such sets exists in which the data flow are continuous functions so that any data flow program computes a well defined function introduction in recent years a new class of programming languages called data flow languages has unlike most programs the execution of data flow programs is solely by the availability of data both input and computed rather than by the movement of one or more abstract of control one of the of data flow programming is that it allows parallelism to be expressed in a natural fashion furthermore the parallelism can be guaranteed determinate if desired the expression of parallelism is one of the early reasons researchers were to data flow however data flow is now known to have other advantages as well the two most important are locality of effect and applicative behavior applicative behavior means that data flow operators can be characterized as mathematical func tions locality of effect means that the mathematical tions for a data flow program can be derived simply by con joining the equations for the various parts of the program in an additive manner therefore data flow languages be analyzed almost as easily as languages eg pure lisp but are more powerful in that they provide parallelism and memory concurrent with the rise of data flow programming has been the development of mathematical approaches to the semantics of programs the success of syntax theory in making precise the syntax of programs led to attempt to describe the semantic behavior programs with equal precision there are three main approaches to precise semantics the operational the axiomatic and the tional or functional semantics the operational approach based on the notion of an abstract interpreter is the most intuitive of the three the denotational approach of scott and treats the semantic behavior of a program as a function from inputs to outputs a well known kind of mathematical object the axiomatic approach of and hoare views a program as relating in the sense the before state of the abstract machine to its after state in the denotational approach each primitive operation in the language is described by associating with it a semantic function which it computes thus a sequence of operations computes the function which is the composition of the component operations functions if the operations are performed repeatedly as in a while loop the function is not so easily determined such equations can be solved in certain by means of the y or fixedpoint operator contribution has been to show that there exist lattices called reflexive domains in which the y operator can always apply to give the unique minimal fixedpoint solution of such equations and that such do characterize programming languages reasonably well this approach can be used on applicative languages with relative ease since such languages are based on the ideas of functions and their composition a program is said to be if it does not always yield the same output when given the same input program behavior is necessary in order to deal with certain real world situations this classic example of this is the system the last on a given may be given to different depending on the time of the requests and not merely on the data representing those requests which is the same whether or not person a gets the programs are difficult to in the denotational framework this is because one must deal with sets of program states rather than the individual states which characterize determinate programs and it is difficult to construct a domain whose elements are such sets past attempts at constructing domains for programs have been rather due to their complexity overview of data flow programming languages a data flow programming language has the basic mathematical simplicity of applicative languages without most of their operators in func transform their inputs to their outputs without ever the state of the rest of the program since there is no control flow there is no goto in of this iteration may be as well as recursion most significant though is the fact that unlike ordinary applicative languages programs may exhibit memory behavior that is the current output may depend on past inputs as well as the current input memory in is not primitive but is like other operators its effects are local like those of other operators and it does not the se of programs a program is a directed graph whose nodes are operators and whose arcs are data paths data in are pure values either simple like numbers or compound like arrays or records an operator when its required inputs are available on its incoming paths after a amount of time it sends its outputs on its outgoing paths it is not necessary that all inputs be present before an operator it depends on the particular operator similarly not all outputs may be produced by a given many operators only when all their inputs are present and produce their outputs all at once they are analogous to subroutines some operators produce a time sequence of output values from one input value or conversely they are analogous to the operators in a program thus operate in parallel with one another subject only to the availability of data on the paths an operator may either be primitive or defined an operator is defined as network of other operators which are connected by data paths such that certain paths are connected on one end only these paths are the parameters of the defined operator a defined operator operates as if its node were replaced by the network which defines it and the parameter paths to the paths which were connected to that node recursive operators may be defined a defined operator for adding complex numbers is given in the appendix there are three classes of operators in simple operators including the usual arithmetic logical and gate operators eg construct and select stream operators including the primitive switch operators for conditionals and other data routing and primitive hold operator for memory and iteration and operators including the primitive arbiter for with the non determinate physical world simple operators all have the property that they demand ail their inputs to they produce all their outputs furthermore each is independent of any past that is the operator is a function from current input to current output stream operators sometimes do not all their or their current output may depend on past inputs thus we can not describe their functional be as simply as before not producing an output is not the same as producing a null output but we can describe their behavior if we view them as functions from streams sequences over time of inputs to streams of outputs not all computable functions from sequences to sequences de stream operators however the function must be that is the operator may never some output upon receiving further input operators produce any one of a set of output values according to or in a real tion timing considerations when presented with specified input values the primitive arbiter operator upon which other operators may be based takes as input two or more streams and produces as output a stream which is the result of merging the input streams in some arbitrary way operators may be viewed as relations from sequences to sequences or more as we shall soon see as functions from sets of sequences to sets of sequences another approach to the denotational semantics of data flow programs involving partially ordered events instead of sets of sequences where an event is either the production or consumption of a datum has reported by however this report does not provide a complete semantics a brief mathematical background a partially ordered set poset is a set with a relation which is reflexive a e a transitive a c b b l c implies al c and implies a b the relation may not be total that is neither a e b nor b g a may hold a set is the same as a poset with out a chain is a subset of a poset on which the relation is total that is either or an upper bound of a subset is an element in the poset not necessarily in the subset which every element of the subset is e to a least upper bound sup is an upper bound which is c all other upper bounds a chain complete poset cpo is one in which each chain has a sup since the empty set is a trivial chain its sup called or bottom must exist in a cpo and is z all elements of the poset a function f on a poset is called or less pre monotone iff for all x and y implies fx a function f on a cpo is chain continuous simply continuous iff for all chains c in the poset c sup fc it may be shown that any continuous function is also the theorem which results from all this is any continuous function on a cpo has a minimal fixedpoint that is there exists an x such that and for all y such that further more x can be found by taking sup fl which chain because lc fl tion and f is since it is continuous a partial order suitable f or data flow since determinate operators are characterized as functions from sequences to sequences the well known partial order on sequences namely the prefix relation is relevant if the infinite sequences are included the poset characterized by the prefix relation is chain complete all the determinate operators of if viewed as functions from sequences to sequences are continuous and therefore in this poset therefore the fixedpoint equations resulting from a determinate data flow program can be solved in the cpo of sequences where l is the empty sequence in operational terms an operator is iff it is and an operator is continuous iff it never for an infinite sequence of input data before it starts producing output unfortunately operators are best viewed as functions from sets of sequences to sets of se this demands that determinate operators be treat ed the same so that the domains and of all opera are compatible a partial order on sets of sequences has been a task for example milners ordering is really only a which means that the fixedpoint equations can only be solved to yield a con class of sets of sequences for at least such congruence classes have the property that one class contains two sets which are totally disjoint this means that certain fixedpoint equations can be solved only to the point of saying you either get this set or that set and they have no elements in common it is possible to obtain a straightforward partial order by considering sets of tagged sequences of data each datum in each sequence in the set has associated with it zero or more tags each of which identifies the sequence of arbitrary sions made by a operator which to the existence of that datum in that sequence a tag is a sequence of art arbiter name followed by numbers which denote the decisions made by that arbiter sets of tagged sequences are constrained in the following two ways first the tag set of a later datum in a given sequence must be an extension of a tag set of an earlier datum in that sequence where a tag set tz is said to extend ti if there is a injection from t to t such that each sequence in t is a prefix of its image this says that a later datum may never be the result of fewer decisions than an earlier datum second no tagged sequence in the set may be a prefix of another in that set where the prefix demands equality of corresponding tag sets as well as data this says that no sequence is merely an approximation to another two sets are compared by matching each sequence in the first set with a sequence in the second set such that the first sequence is a prefix of the second sequence this relation denoted l may be shown to be a true partial ordering of sets of tagged sequences and the resulting poset is chain complete if infinite sequences and sets are to prove that e is a partial order on we must prove that it is reflexive transitive and is obvious take the identity map as the injection of to since any is a prefix of itself we have e transitivity is almost as simple given an injective map ml from to and an injective map mz from to we know that the composition m o ml is an injection from to then since the prefix relation is transitive we know that every element in is a prefix of its image under mz o ml in thus e is transitive is the most difficult property to prove it is the property which the partial orders discussed earlier lack let ml be an injection from to and mz be an injection from to we can immediately conclude that and have the same cardinality and that mz o ml is a bijection from to itself each element of must be a prefix of its image in under m o ml but due to the constraint on no ele ment can be a prefix of another hence the image must be the element itself so mz o ml must be the identity now we observe that each element of is a prefix of its image in under ml and that element in is a prefix of its image in under m but the image under mz is the original element in so the element in is equal to the element in by of the prefix relation therefore u is equal to and e is to show that the partial order q is countable chain complete we must show that any countable chain has a sup let c l l be such a countable chain and let ml mz be the associated sequence of injective maps which specify the relations ml mz let s be an element of then the set s mn forms a chain under the prefix order and since sequences are chain complete this set has a sup which we call call the set of all such since all the ms are injective each element s of a belongs to exactly one such chain for each define to map each element s into the sup of its chain then we have that is an injective map which establishes that c but n was arbitrary so is an upper bound for the chain of if there were another upper bound call it for the chain of which was strictly less than then there would be an element sub in which was a strict prefix of an element of or there would be an element in which had no prefix in in the first case sub would be an upper bound of some chain but then sub is a strict prefix of the fact that was the sup of that chain in the second case there would be a chain of elements from the which had no sup in hence could not even be an upper bound therefore we may conclude the sup of the u that is indeed it remains to be shown that satisfies the extra conditions on namely that no is a strict prefix of another and that within an the on a later item in the must extend the on an earlier item we prove these additional properties by contradiction if one were a strict prefix of another ts then all the elements of the chain of which ts was the sup would be in the chain of hence could not be their sup u if the extension property were not then there would exist a in such that did not extend where jk but since is the sup of its chain of there would exist some which contained a ts a prefix of such that and ts sion property assumed for the u the therefore the is a proper and is the sup of the which means that the set of is a complete poset behavior of determinate operators any determinate operator whose functional behavior on simple data sequences is known may be extended to a function on sets of tagged sequences but not in the obvious way of applying the operator to all possible tuples of sequences in the cartesian product of the input sets and producing an set whose size is that of that cartesian product the problem with this obvious approach is that the operator may be applied to data which could never during actual execution because they were the result of decisions of the same arbiter the proper extension is as follows execute the on each tuple of input sequences in the cartesian prod of the input sets letting it consume an input datum whenever it and produce an output datum whenever it however while doing this join the tag set with the input datum with an tag set initially the empty where joining two tag sets is done by taking their union and deleting any tags which are prefix es of other tags furthermore whenever an output datum is produced it is tagged with the current value of the tag set the execution of the operator is before producing any further output whenever an tag set is an inconsistent tag set is one which has two tags with the same arbiter name but with decisions this rule that the operators function is never applied to input data which could never because they from different decision se of some operator after each tuple is processed in this way the output sequence is put into the output set and prefixes eliminated behavior of operators the only primitive operator is the arbiter which viewed as a function from sequences to sets of sequences produces the set of all possible ways of ing the input sequences such that each datum is tagged by the unique name of the arbiter which just tells which ter in the program it is and the sequence of decisions made so far for example if the input sequences a b and cd were merged would be by the arbiter named a the output set viewed as a function from sets of tagged sequences to sets of tagged sequences the arbiter is extended like any determinate operator except that the tag set always has a generated tag in it which tells the sequence of decisions made so far by the arbiter it is initially just the name and all possible merges are generated in parallel proof of continuity to prove that the extended determinate operators are we first prove a lemma concerning such extensions in general let f be a function which maps tagged sequences x and call its extension f then define f as follows where is a and and are tagged sequences i we now show that if then c pick an arbitrary then there exist and such that ts since e there exists such that ts is a prefix of which implies that ts is a prefix of since f is but either or was dis by the and there exists such that prefix of therefore so for all ts is a prefix of but ts was arbitrary there exists such that ts is a prefix of and hence since the sets are l now we may prove that such extensions are also continuous let be a chain whose sup is let f be a function on which is continuous and thus consider the sequence of image sets note that this is not the sion of f as above just the normal application of a function to a set of arguments if x where xe is a chain with sup x then fx fx is a chain whose sup is fx but although fx it is not necessarily the case that c however if then because means that for all is not a prefix of and vice versa and also that xj is a prefix of xl and y is a prefix of yl imply that is a prefix of and that is a prefix of thus is not a prefix of nor vice versa by the properties of the poset of sequences therefore every chain of an element of has a sub chain an element of so is a chain and is its sup u the detailed proofs of the of the determinate operators on are too long to be included here furthermore the proof of and continuity of the arbiter requires a somewhat different approach since it is not merely an extension of a determinate operator in fact it is a different recursion schema the appendix con the recursive definition of the arbiter and also a rep determinate operator the switch the other definitions and the complete proofs are presented in results since the determinate operators are and in the poset of data sequences they are and continuous in the poset of sets of tagged data sequences similarly the arbiter is and continuous in the poset of tagged sequences therefore any recursive system of equations involving these operators has a unique minimal first order fixedpoint in that poset this means that any program with or without iteration cycles in the di graph but without recursion corresponds to a well defined function from sets of tagged sequences to same and all such functions are themselves and continuous furthermore since the set of continuous functions from complete posets to same is itself a complete poset and since composition and the first order fixedpoint finding functional are continuous in this poset any system of recursive functional equations has a unique minimal second order fixedpoint which is a first order continuous function this means that programs with recursive operators correspond to well defined functions from sets of tagged sequences to same hence all programs correspond to well defined functions conclusions data flow programming languages have mathematical semantics than ordinary languages this is because they are basically applicative in nature and local in effect so the functions act solely on the data without states continuations or other complications the tags with the data sequences do of course but this complexity is for the purpose of dealing with non which is not addressed by states tions etc furthermore the tags serve double first they allow the construction of a straightforward partial or der second they are necessary to the specification of how operators transform input sets of sequences to output ones hence they are less than they might seem at first it seems reasonable to assume that the approach out above namely the use of tagged sets of objects is applicable to the of the semantics of non determinate programs in conventional languages however the details remain to be out references first version of a data flow procedure language mit project mac computation structures group memo pr a data flow programming language ibm research report rc march d scott outline of a mathematical theory of computation proceedings of the fourth annual princeton conference on information sciences and sys pp rd the denotational semantics of program ming languages communications of the a vol no august pp ff rw assigning meanings to programs pro of symposium in applied mathematics can mathematical society vol pp car hoare programming no october an axiomatic basis for computer communications of the acm vol pp gd plotkin a powerdomain construction journal on computing vol no september siam mb power domains conference on foundations of science po september pr mathematical semantics and data flow programming acm third symposium on principles of programming languages january rm denotational models with operators ifip working conference on formal de of programming concepts august g kahn a preliminary theory for parallel programs laboratory report january pr denotational semantics of determinate and data flow programs phd the sis mit laboratory for computer science in tion appendix notation subscripts select members of sets function arguments etc are only used to select elements from sequences brackets and build a sequence like lisp list the operator x an element to the beginning of a sequence like lisp cons the operator a the first element of a sequence like lisp cdr the operator joins two sequences together like lisp append the operators and test the obvious variants of the relation switch d i a e if port a then x if port a then otherwise arbiter i where u i tso i un tso if ts then if then datum ts i ts q a otherwise auxiliary functions v i d choice tg g i u tg choice i tg c a g ts tag r complex l multiply i z t l t rem i ii ii ii ix ui i i ii i i ii i i complex i i 