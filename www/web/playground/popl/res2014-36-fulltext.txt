sound input filter generation for integer overflow errors fan long mit martin rinard abstract we present a system sift for generating input filters that integer overflow errors associated with critical program sites such as memory allocation or block copy sites sift uses a static program analysis to generate filters that discard inputs that may trigger integer overflow errors in the computations of the sizes of allocated memory blocks or the number of copied bytes in block copy operations unlike all previous techniques of which we are aware sift is sound if an input passes the filter it will not trigger an integer overflow error at any analyzed site our results show that sift successfully analyzes and therefore generates sound input filters for out of memory allocation and block memory copy sites in analyzed input processing modules from five applications and these errors include six known integer overflow our results also show that applying these filters to realworld inputs produces no false positives the analysis and filter generation times are all less than a second categories and subject descriptors f semantics of programming languages program analysis d operating systems security and protection general terms security program analysis keywords integer overflow abstraction soundness introduction many security exploits target software errors in applications one approach to is to input filters that discard inputs that may trigger the errors we present a new static analysis technique and implemented system sift for automatically generating filters that discard inputs that may trigger integer overflow errors at analyzed memory allocation and block copy sites we focus on this problem in part because of its practical importance because integer may enable code injection or other attacks they are an important source of security previous filter generation systems standard filter generation systems start with an input that an error ­ they next use the input to generate an ex permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work must be for all other uses the popl january ­ san diego ca usa copyright is held by the acm trace and discover the path the program takes to the error they then use a forward symbolic execution on the discovered path and in some cases related paths to derive a signature a boolean condition that the input must satisfy to follow the same execution path through the program to trigger the same error the generated filter inputs that satisfy the signature because other paths to the error may exist these techniques are unsound ie the filter may miss inputs that exploit the error it is also possible to start with a potentially site and use a weakest precondition analysis to obtain an input filter for that site to the best of our knowledge the only previous technique that uses this approach is unsound in that it uses loop unrolling to eliminate loops and therefore analyzes only a subset of the possible execution paths and it does not specify a technique for dealing with potentially aliased values as is standard the generated filter execution path constraints ie checks from conditional statements along the analyzed execution paths the goal is to avoid potentially problematic inputs that the program would because of safety checks at conditionals along the execution path process correctly as a result the generated input filters perform a substantial between and number of operations sift sift starts with a set of critical expressions from memory allocation and block copy sites these expressions control the sizes of allocated or copied memory blocks at these sites sift then uses an interprocedural demanddriven weakest precondition static analysis to propagate the critical expression backwards against the control flow the result is a symbolic condition that captures all expressions that the application may evaluate in any execution to obtain the values of critical expressions the free variables in the symbolic condition represent the values of input fields in effect the symbolic condition captures all of the possible computations that the program may perform on the input fields to obtain the values of critical expressions given an input the generated input filter evaluates this condition over the corresponding input fields to discard inputs that may cause an overflow because sift takes all paths to analyzed memory allocation and block copy sites into account it generates sound filters if an input passes the filter it will not trigger an overflow in the evaluation of any critical expression including the evaluation of intermediate expressions at program points that contribute to the value of the critical expression as is standard in the field sift is designed to work with programs that do not access uninitialized memory our analysis therefore comes with the following soundness guarantee if an input passes the filter for a given critical expression e the input field annotations are correct see section and the program has not yet accessed uninitialized memory when the program computes a value of e then no integer overflow occurs during the evaluation no execution path constraints unlike standard techniques sift no checks from the programs conditional statements and works only with arithmetic expressions that contribute directly to the values of the critical expressions this design decision has the following consequences · sound and efficient analysis ignoring execution path constraints improves the efficiency of the analysis because it eliminates the need to track the different constraints that may appear on the many different execution paths to each memory allocation or block copy site indeed this efficiency is critical to the soundness of analysis in general there may be an large or even statically unbounded number of paths to a given memory allocation or block copy site to enumerate all of these different execution paths to derive the complete set of execution path constraints is clearly infeasible and a major source of the of previous techniques · efficient filters because sift ignores checks from conditional statements it generates much more efficient filters than standard techniques filters perform of operations as opposed to of or more indeed our experimental results show that in contrast to standard filters filters essentially all of their time reading the input as opposed to checking if the input may trigger an overflow error · accurate filters one potential concern is that the program may contain safety checks that enable it to safely process inputs that would otherwise trigger ignoring these safety checks may cause the generated filter to discard inputs even though the program can process them safely our experimental results show that in practice ignoring execution path constraints results in no loss of accuracy specifically we tested our generated filters on realworld inputs for six benchmark applications and found no false positives inputs that the program would have processed correctly we attribute this potentially result to the fact that standard integer data types usually contain enough bits to represent the memory allocation sizes and block copy lengths that inputs typically input fields with multiple instantiations input files often contain multiple instantiations of the same input field for example when the input file contains repeated components that have the same format sift works with an abstraction in which free variables in the propagated symbolic expressions and the final symbolic condition represent all instantiations of the corresponding input fields that they reference ie sift does not attempt to determine the precise correspondence between variables and different instantiations of the same input field this design decision simplifies and extends the range of the analysis all variables that reference the same input field are because they all represent all possible instantiations of the corresponding input field sift can therefore successfully analyze programs for which it is not possible to statically determine the precise correspondence between variables and different instantiations of the same input field this design decision also enables sift to analyze programs in which a single variable may reference different instantiations of the same input field over the course of the execution also enables a new expression normalization algorithm that variables during the analysis of loops to obtain loop invariant expressions see section these expressions soundly characterize the effect on the of e including the evaluations of intermediate expressions that contribute to the final value of the critical expression propagated symbolic expression of loops that may access multiple potentially different instantiations of the same input field one final consequence of this design decision is that the generated input filter must check all combinations of input field instantiations when it checks for potential see section our experimental results show that for our benchmark applications this approach causes at most overhead the generated filters essentially all of their time reading the input pointer analysis and precondition generation sift groups pointers into equivalence sets based on an analysis of the potential aliasing relationships between different pointers to analyze a load statement that loads a value via a pointer sift generates a new variable that represents the loaded value in the propagated symbolic conditions each such variable represents all values that may be stored via any alias of the pointer this decision produces an appropriately abstraction that enables sift to successfully analyze programs for which it is not possible to statically determine the precise value that each variable references it also enables sift to work with any sound pointer or alias analysis that provides sift with the aliasing information required to soundly update the propagated symbolic condition at statements that access values via pointers see section to the best of our knowledge this is the first paper to show how to soundly incorporate an arbitrary alias or pointer analysis into a precondition generation algorithm sift usage model sift implements the following usage model module identification starting with an application that is designed to process inputs presented in one or more input formats the identifies the modules within the application that process inputs of interest sift will analyze these modules to generate an input filter for the inputs that these modules process input statement annotation the the relevant input statements in the source code of the modules to identify the input field that each input statement reads critical site identification sift the modules to find all critical sites currently memory allocation and block copy sites each critical site has a critical expression that determines the size of the allocated or copied block of memory the generated input filter will discard inputs that may trigger an integer overflow error during the computation of the value of the critical expression static analysis for each critical expression sift uses a demanddriven backwards static program analysis to automatically derive the corresponding symbolic condition each conjunct expression in this condition specifies as a function of the input fields how the value of the critical expression is computed along one of the program paths to the corresponding critical site input parser acquisition the obtains typically from such as a parser for the desired input format this parser groups the input bit stream into input fields then makes these fields available via a standard api filter generation sift uses the input parser and symbolic conditions to automatically generate the input filter when presented with an input the filter reads the fields of the input and for each symbolic expression in the conditions determines if an integer overflow may occur when the expression is evaluated if so the filter the input otherwise it passes the input along to the application the generated filters can be anywhere along the path from the input source to the application that ultimately processes the input experimental results we used sift to generate input filters for modules in five realworld applications h a network player a lightweight web browser a player manipulation and generation and an image manipulation application together the analyzed modules contain critical memory allocation and block copy sites sift successfully generated filters for of these critical sites static analysis was unable to derive symbolic conditions for the remaining two critical sites see section for more details these applications contain six known integer overflow at their critical sites filters all of these analysis and filter generation times we sift to analyze all critical sites in the analyzed modules then generate a single composite filter that checks for integer overflow errors at all of the sites the maximum time required to analyze all of the sites and generate the composite filter was less than a second for each benchmark application false positive evaluation we used a web to obtain a set of at least realworld inputs for each application for a total of input files we found no false positives the corresponding composite filters accept all of the input files in this test set filter performance we measured the composite filter execution time for each of the input files in our test set the average time required to read and filter each input was at most with this time dominated by the time required to read in the input file contributions this paper makes the following contributions · sift we present sift a sound filter generation system for integer overflow sift modules to find critical memory allocation and block copy sites statically analyzes the code to automatically derive symbolic conditions that characterize how the application may compute the sizes of the allocated or copied memory blocks and generates input filters that discard inputs that may trigger integer overflow errors in the evaluation of these expressions unlike all previous techniques of which we are aware sift is sound because it takes all execution paths into consideration if an input passes the generated filter it will not trigger an integer overflow error at any analyzed site also unlike previous techniques sift generates efficient filters because sift ignores execution path constraints the generated filters perform of operations as opposed to previous techniques which incorporate execution path constraints and therefore perform of or more operations · sound and efficient static analysis we present a new static analysis that automatically derives symbolic conditions that capture as a function of the input fields how the integer values of critical expressions are computed along the various possible execution paths to the corresponding critical site unlike standard precondition generation techniques the sift static analysis does not incorporate checks from the programs conditional statements it instead works only with the arithmetic operations that contribute directly to the values of the critical expressions · input fields with multiple instantiations we present a novel abstraction for input fields with multiple instantiations this abstraction enables sift to analyze programs for which it is impossible to statically determine the precise correspondence between variables and different instantiations of the same input field with this abstraction all variables that reference the same input field are because they all represent all instantiations of that input field this enables a new expression normalization technique that sift to automatically obtain invariants for loops that access the values of input fields · pointer analysis and precondition generation we also present a novel abstraction for values that load statements access via pointers this abstraction enables sift to analyze programs for which it is impossible to statically determine the precise value that each pointer references we believe that this paper is the first to show how to soundly incorporate an arbitrary alias or pointer analysis into a precondition generation algorithm · experimental results we present experimental results that illustrate the practical of our approach in applications against integer overflow at memory allocation and block copy sites the rest of this paper is organized as follows section presents a motivating example that illustrates how sift works section presents the core sift static analysis for c programs section presents the formalization of the static analysis and discusses the soundness of the analysis section presents the experimental results section discusses related work we conclude in section example we next present an example that illustrates how sift an integer overflow in an open source player figure presents simplified source code from when an file with embedded it calls line in figure to each image in the file this function in turn calls the function line to read the image metadata and the function line to allocate memory buffers for the image there is an integer overflow at lines ­ where the size of the buffer for a image as at this program point equals while the rest of the expression equals where is the bit height input field value that reads at line and is the bit width input field value that reads at line is one of the sampling factor values that reads at line while is the maximum sampling factor value is one of the vertical sampling factor values that reads at line while is the maximum vertical sampling factor value malicious inputs with specifically values in these input fields can cause the image buffer size calculation to overflow in this case allocates an image buffer that is smaller than required and eventually writes beyond the end of the allocated buffer the loop at lines ­ reads multiple instantiations of the field and the field computes the c × × × × × × × × figure the symbolic condition c for the example subexpressions in c are bit vector expressions the indicates the bit width of each expression atom w is the signed extension operation that transforms the value v to the bit width w int dec dec void bits bits for i i i void int int int i for i i i for i i i int int malloc figure simplified source code input statement annotations appear in comments maximum values of these instantiations in the loop at lines ­ it then uses these maximum values to compute the size of the allocated buffer at each iteration in the loop lines ­ analysis challenges this example several challenges that sift must overcome to successfully analyze and generate a filter for this program first the computation of the expression for the size of the buffer uses the variable and the variable which correspond to the maximum values of all instantiations of the field and the field it is impossible to statically determine the precise instantiation that these two variables represent to overcome this challenge sift uses a novel abstraction in which variables in the propagated symbolic condition represent all instantiations of the corresponding input fields second the source code contains many statements that access values derived from input fields via pointers to reason soundly about these statements sift uses an abstraction that enables sift to incorporate an alias analysis finally reads the input fields lines and and computes the size of the allocated memory block lines in the loops at different procedures sift therefore uses an interprocedural analysis that propagates the symbolic conditions across procedure boundaries to obtain precise symbolic conditions sift also a combination of a fixed point analysis and a novel expression normalization technique to obtain loop invariants that successfully characterize the effect of loops on propagated expressions we next describe how sift generates a sound input filter to this integer overflow error source code annotations sift provides a declarative specification interface that enables the to specify which statements read which input fields in this example the specifies that the application reads the input fields and at lines ­ and ­ in figure sift uses this specification to map the variables and at lines and to the corresponding input field values note that the input fields and may contain multiple instantiations which reads in the loop at lines and compute symbolic condition sift uses a demanddriven interprocedural backward static analysis to compute the symbolic condition c in figure we use the notation in figure to denote that overflow errors should not occur in any step of the evaluation of the expression e subexpressions in c are in bit vector expression form so that the expressions accurately reflect the representation of the numbers inside the computer as bit vectors as well as the semantics of arithmetic and logical operations as implemented inside the computer on these bit vectors in figure the indicate the bit width of each expression atom w is the signed extension operation that transforms the value v to the bit width w sift also tracks the sign of each arithmetic operation in c for simplicity figure this information note that sift soundly handles the loops that access the instantiations of the input fields and in the resulting final symbolic condition c represents the instantiation of the input field that corresponds to the program variable while represents the instantiation that corresponds to the program variable sift does not attempt to determine the precise instantiations that and represent instead sift conservatively assumes that and may independently represent any instantiation of the field sift handles similarly c includes all intermediate expressions evaluated at lines ­ and ­ in this example c contains only a single term of the form in general however different program paths may compute different values for the critical expression in this case the final symbolic condition c will contain multiple conjuncts of the form each captures one of the ways that the program computes the value of the critical expression generate input filter starting with the symbolic condition c sift generates an input filter that any input that violates c ie for any term in c the input integer overflow errors when evaluating e including all subexpressions the generated filter extracts all instantiations of the input fields and these are the input fields that appear in c from an incoming input it then iterates over all combinations of pairs of the instantiations of the input fields and to consider all possible bindings of and in c for each binding it checks the entire evaluation of c including the evaluation of all subexpressions for overflow if there is no overflow in any evaluation the filter accepts the input otherwise it the input static analysis this section presents the sift static analysis algorithm we have implemented our static analysis for c programs using the llvm compiler infrastructure core language and notation s x x c x y x y op z x p p x p malloc skip s s if x s else s while x s s s s statement f x y z p var c int label figure the core programming language figure presents the core language that we use to present the analysis the language is modeled on a standard program representation in which nested expressions are converted into sequences of statements of the form x y op z where x y and z are either variables or automatically generated temporaries op represents binary arithmetic operations and all accesses to potentially aliased memory locations occur in load or store statements of the form x p or p x each statement contains a unique label label a statement of the form x reads a value from an input field f because the input may contain multiple instantiations of the field f different executions of the statement may return different values for example the loop at lines ­ in figure reads multiple instantiations of the and input fields labels and pointer analysis figure presents four utility functions statement statement statement label last statement label and labels statement label in our notations given a statement s s maps s to the first atomic statement inside s maps s to the label that corresponds to the first atomic statement inside s maps s to the label that corresponds to the last atomic statement inside s and maps s to the set of labels that are inside s s s s s s s otherwise the label of s s s s otherwise is the label of s s s s s s while x s if x s else s otherwise is the label of s figure definitions of last and labels we use and to denote the set of labels that correspond to load and store statements respectively label and label our static analysis uses the pointer analysis in combination with the basic pointer analysis pass in llvm to aliases at load and store statements our underlying pointer analysis provides two functions and × bool × bool we assume that the underlying pointer analysis is sound so that store load true only if the load statement at the label load will never a value stored by the store statement at label store store load true only if the load statement at the label load will always the last value stored by the store statement at label store see section for a formal definition of the soundness requirements that the alias analysis must satisfy intraprocedural analysis because it works with a representation our static analysis starts with a variable v at a critical program point it then propagates v backward against the control flow to the program entry point in this way the analysis computes a symbolic condition that soundly captures how the program starting with input field values may compute the value of v at the critical program point the generated filters use the analysis results to check whether the input may trigger an integer overflow error in any of these computations c c e e op e atom atom x c f id id id index x var c int f figure the condition syntax condition syntax figure presents the definition of symbolic conditions that our analysis and propagates a condition c consists of a set of conjuncts of the form each requires that the evaluation of the symbolic expression e including all in the evaluation see section should not trigger an overflow symbolic conditions c may contain four kinds of atoms c represents a constant x represents the variable x f id represents a value from the input field f and id represents a value returned by the load statement with the label abstraction for input field instantiations an atom f id in a symbolic condition c represents the value of an arbitrary instantiation of the input field f the analysis uses the natural number id to distinguish values of potentially different instantiations of f so all occurrences of a given atom f id in a symbolic condition c represent the same value if id id then f id and f id may f x c f x y f x y op z f s s f s s f if v s else s f if v s else s f if v s else s f while v s f while v s f p malloc f x f x p f p x c c c cy op zx c f s c c f s f s c c f s c f s c c f s c c f s c c c where s c c f s f s c c c c cf id x where id is fresh c c id x where id is fresh c c id x id x · · · n id n x for all id · · · n id n in c c if i where c i id i x cx i id i if ¬ i i cx i id i c if ¬ i ¬ i figure static analysis rules the notation ce e denotes the symbolic condition obtained by replacing every occurrence of e in c with e is the normalization function that transforms the symbolic condition c to an equivalent normalized condition represent different instantiations of f and may therefore represent different values abstraction for values accessed via pointers an atom id in a symbolic condition c represents an arbitrary value returned by the load statement at the label the analysis uses the natural number id to distinguish potentially different values loaded at different executions of the load statement our analysis atoms of the form id in the propagated symbolic condition when it analyzes the load statement at the label the analysis will eventually replace these atoms with appropriate expressions based on the aliasing information when it analyzes store statements that may store the corresponding value from the previously analyzed load statement at in our abstraction id represents an arbitrary value that may be stored via any alias of the pointer at during the execution from the starting point of the program to the current program point of the propagated symbolic condition c along any possible execution path see section analysis framework given a sequence of statements s a label within s and a symbolic condition c at the program point after the corresponding statement at the label our demanddriven backwards analysis computes a symbolic condition f s c the analysis ensures that if f s c holds before executing s then c will hold whenever the execution reaches the program point after the corresponding statement at the label see section for the formal definition given a program s as a sequence of statements and a variable v at a critical site associated with the label our analysis generates the condition f s to create an input filter that checks whether the input may trigger an integer overflow error in the computations that the program performs to obtain the value of v at the critical site analysis of assignment conditional and sequence statements figure presents the analysis rules for basic program statements the analysis of assignment statements replaces the assigned variable x with the assigned value c y y op z or f id depending on the assignment statement here the notation ce e denotes the new symbolic condition obtained by replacing every occurrence of e in c with e the analysis rule for the input read statement a new id to represent the read value f id because the variable x may get the value of a fresh instantiation of the input field f after the statement this mechanism enables the analysis to correctly distinguish potentially different instantiations of the same input field because values from potentially different instantiations have different id s if the label identifies the end of a conditional statement the analysis of the statement takes the union of the symbolic conditions from the analysis of the true and false branches of the conditional statement the resulting symbolic condition correctly takes the execution of both branches into account if the label identifies a program point within one of the branches of a conditional statement the analysis will propagate the condition from that branch only the analysis of sequences of statements propagates the symbolic condition backwards through the statements in sequence analysis of load and store statements the analysis of a load statement x p replaces the assigned variable x with a abstract value id that represents the loaded value for input read statements the analysis uses a newly id to distinguish values read on different executions of the load statement the analysis of a store statement p x uses the alias analysis to appropriately match the stored value x against all loads that may return that value specifically the analysis all id atoms in c that either may or must load a value v that the store statement stores into the location p if the alias analysis determines that the id expression must load x ie the corresponding load statement will always access the last value that the store statement stored into location p then the analysis of the store statement replaces all occurrences of id with x if the alias analysis determines that the id expression may load x ie on some executions the corresponding load statement may load x on others it may not then the analysis produces two symbolic conditions one with id replaced by x for executions in which the load statement loads x and one that leaves id in place for executions in which the load statement loads a value other than x we note that if the pointer analysis is the symbolic condition may become large sift uses the algorithm a contextsensitive pointer analysis we found that in practice this analysis is precise enough to enable sift to efficiently analyze our benchmark applications see figure in section analysis of loop statements the analysis uses a fixedpoint algorithm to synthesize the loop invariant required to analyze while loops specifically the analysis of a statement while x s computes a sequence of symbolic conditions ci where c and ci s c ci conceptually input original expression output normalized expression for a in do if a is in form f id then n n n f id else if a is in form id then n n n id for a in do if a is in form f id then id f id else if a is in form id then id id figure normalization function is a list that iterates over the distinct atoms in the expression e from left to right in order the introduces temporary atoms of the forms f id and id to avoid conflicts with existing original atoms in each successive symbolic condition ci captures the effect of executing an additional loop iteration the analysis terminates when it reaches a fixed point ie when it has performed n iterations such that cn cn here cn is the discovered loop invariant this fixed point correctly summarizes the effect of the loop regardless of the number of iterations that it may perform the loop analysis the analysis result f s c ci after each iteration for a symbolic condition c · · · the normalization of c is · · · where is the normalization of each individual expression in c using the algorithm presented in figure and removes duplicate conjuncts from the condition normalization loop invariant discovery for loops that read input fields or load values via pointers each analysis of the loop body during the fixed point computation produces new values f id and id with fresh id s the f id represent values of input field instantiations that the current loop iteration reads the id represent values that the current loop iteration loads via pointers the normalization algorithm appropriately these id s in the new symbolic condition so that the first of each id is in order this normalization enables the analysis to recognize loop invariants that show up as equivalent successive analysis results that differ only in the id s that they use to represent input field instantiations and values accessed via pointers the normalization algorithm is sound because all occurrences of f id f id k are and the normalization only the id id k the normalized condition is therefore equivalent to the original condition see section the normalization algorithm will reach a fixed point and terminate if it computes the symbolic condition of a value that depends on at most a statically fixed number of values from the loop iterations for example our algorithm is able to compute the symbolic f v call proc v · · · vk c where proc a · · · ak s return and id · · · n id n are all atoms of the form id in c begin c cv f s for ev in · · · do c f s safe id for e in · · · do · · · cn f s safe n id n for en in · · · do ev c e c · · · en c c c id · · · en n id n return c figure procedure call analysis algorithm returns the set of expressions that appear in the conjuncts of c for example e e c id s in e so that atoms of the forms id and f id will not conflict with existing atoms in c condition of the size parameter value of the memory allocation sites in figure the value of this size parameter depends only on the values of and the current values of and and the maximum values of and each of which comes from one previous iteration of the loop at line ­ note that the algorithm will not reach a fixed point if it attempts to compute a symbolic condition that contains an unbounded number of values from different loop iterations for example the algorithm will not reach a fixed point if it attempts to compute a symbolic condition for the sum of a set of numbers computed within the loop the sum depends on values from all loop iterations to ensure termination our current implemented algorithm terminates the analysis and fails to generate a symbolic condition c if it fails to reach a fixed point after ten iterations in practice we expect that many programs may contain expressions whose values depend on an unbounded number of values from different loop iterations our analysis can successfully analyze such programs because it is demand driven it only attempts to obtain precise symbolic representations of expressions that may contribute to the values of expressions in the analyzed symbolic condition c which in our current system are ultimately derived from expressions that appear at memory allocation and block copy sites our experimental results indicate that our approach is in practice effective for this set of expressions specifically because these expressions tend to depend on at most a fixed number of values from loop iterations interprocedural analysis analyzing procedure calls figure presents the interprocedural analysis for procedure call sites given a symbolic condition c and a function call statement v call proc v · · · vk that invokes a procedure a · · · ak s return the analysis computes f v call proc v · · · vk c conceptually the analysis performs two tasks first it replaces any occurrences of the procedure return value v in c the symbolic condition after the procedure call with symbolic expressions that represent the values that the procedure may return second it transforms c to reflect the effect of any store instructions that the procedure may execute specifically the analysis finds expressions id in c that represent values that the procedure may store into a location p that the computation following the procedure may access via a load instruction that may access a potentially aliased version of p it then replaces occurrences of id in c with symbolic expressions that represent the corresponding values computed and stored into p within the procedure the analysis the invoked procedural body s to obtain the symbolic expressions that corresponds to the return value see line or the value of id see lines and the analysis avoids redundant analysis of the invoked procedure by caching the analysis results f s and f s safe id for reuse note that symbolic expressions derived from an analysis of the invoked procedure may contain occurrences of the formal parameters a ak the interprocedural analysis translates these symbolic expressions into the name space of the caller by replacing occurrences of the formal parameters a ak with the corresponding actual parameters v vk from the call site see lines and in figure also note that the analysis the id s in the symbolic expressions derived from an analysis of the invoked procedure before the see lines ­ this ensures that the atoms of the forms f id and id in the expressions are fresh and will not conflict with existing atoms in c after propagation to program entry to derive the final symbolic condition at the start of the program the analysis propagates the current symbolic condition up the call tree through procedure calls until it reaches the start of the program when the propagation reaches the entry of the current procedure proc the algorithm uses the procedure call graph to find all call sites that may invoke proc it then propagates the current symbolic condition c to the callers of proc appropriately translating c into the naming context of the caller by substituting any formal parameters of proc that appear in c with the corresponding actual parameters from the call site the analysis continues this propagation until it has traced out all paths in the call graph from the initial critical site where the analysis started to the program entry point the final symbolic condition c is the conjunction of the conditions derived along all of these paths extension to c programs we next describe how to extend our analysis to real world c programs to generate input filters identify critical sites sift transforms the application source code into the llvm intermediate representation ir the ir to identify critical values ie size parameters of memory allocation and block copy call sites inside the specified module and then performs the static analysis for each identified critical value by default sift calls to standard c memory allocation routines such as malloc and and block copy routines such as as critical sites sift can also be to recognize additional memory allocation and block copy routines for example in bit width and sift extends the analysis described above to track the bit width of each expression atom it also tracks the sign of each expression atom and arithmetic operation and correctly handles extension and operations ie signed extension unsigned extension and that change the width of a bit vector sift therefore implements the representation of integer values in the c program function pointers and library calls sift uses its underlying pointer analysis to function pointers it can analyze programs that invoke functions via function pointers the static analysis may procedure calls for example calls to standard c library functions for which the source code of the callee is not available a standard way to handle this situation is to work with an annotated procedure declaration that gives the static analysis information that it can use to analyze calls to the procedure sift currently contains annotations for a small set of important standard library functions that influence our integer overflow analysis eg and if both the source code and the annotation for an invoked procedure are not available by default sift currently information that indicates that symbolic expressions are not available for the return value or for any values accessible and therefore potentially stored via procedure parameters code following the procedure call may load such values this information enables the analysis to determine if the return value or values accessible via the procedure parameters may affect the analyzed symbolic condition c if so sift does not generate a filter because sift is demanddriven this mechanism enables sift to successfully analyze programs with library calls all of our benchmark programs have such calls as long as the calls do not affect the analyzed symbolic conditions command line arguments at four of the critical sites in our analyzed benchmark modules the absence of overflow depends in part on the lengths of the command line arguments the generated final symbolic condition that sift uses to generate the input filter therefore contains variables that represent these lengths our currently implemented system sets these lengths to a specific constant value greater than the maximum length of the command line arguments of all benchmark applications in production use we expect sift to either check that the command line argument lengths are less than this constant value before the application or dynamically extract the command line argument lengths when the application is then provide these lengths to the filter annotations for input read statements sift provides a declarative specification language that developers use to indicate which input statements read which input fields in our current implementation these statements appear in the source code in comments directly below the c statement that reads the input field see lines and in figure for examples that illustrate the use of the specification language in the example the sift annotation generator the comments finds the input specification statements then inserts new nodes into the llvm ir that contain the specified information formally this information appears as procedure calls of the following form v w where v is a program variable that holds the value of the input field with the field name the width in bits of the input field is w the sift static analyzer such procedure calls as specifying the correspondence between input fields and program variables and applies the appropriate analysis rule for input read statements see figure input filter generation the sift filter generator any conjuncts that contain residual occurrences of abstract values id in the final symbolic condition c it also replaces every residual occurrence of program variables v with these residual occurrences correspond to initial values in the program state and in the abstract semantics see section after pruning the final condition contains only input field variables of the form f id and constant atoms in effect the pruning algorithm eliminates any checks involving uninitialized data from the filter sift filters are not designed to overflow errors that may occur when the program accesses uninitialized data which in c may contain arbitrary values the sift soundness theorem theorem reflects this restriction for languages such as java which initialize data to specific values the sift filter generator would not conjuncts involving references to uninitialized data it would instead protect against involving uninitialized data by replacing residual occurrences of abstract values and program variables with the corresponding initial values the generated filter operates as follows it first uses an existing parser for the input format to parse the input and extract the input fields used in the input condition open source parsers are available for a wide range of input file formats including all of the formats in our experimental evaluation these parsers provide a standard api that enables clients to access the parsed input fields the generated filter evaluates each conjunct expression in by replacing each symbolic input variable in the expression with the corresponding concrete value from the parsed input if an integer overflow may occur in the evaluation of any expression in the filter the input and raises an for input field arrays such as and in the example see section the input filter all possible combinations of concrete values see figure for the formal definition of condition evaluation the filter the input if any combination can trigger the integer overflow error given multiple symbolic conditions generated from multiple critical program points sift can create a single efficient filter that first the input then checks the parsed input against all final symbolic conditions in sequence this approach the overhead of reading the input in practice reading the input essentially all of the time required to execute the filter see figure over all of the final symbolic condition checks soundness of the static analysis we next formalize our static analysis algorithm on the core language in figure and discuss the soundness of the analysis we focus on the intraprocedural analysis and omit a discussion of the interprocedural analysis as it uses standard techniques based on summary tables dynamic semantics of the core language program state we define the program state inp as follows var var bool loc loc bool inp and map variables and memory locations to their corresponding values we use undef to represent uninitialized values we define that if any operand of an arithmetic operation is undef the result of the operation is also undef maps the input field f to the corresponding set of the values of all instantiations of the field f in the input file inp therefore represents the input file which remains unchanged during the execution maps each variable to a boolean flag which tracks whether the computation that generates the value of the variable including all generates an overflow maps each memory location to a boolean overflow flag similar to in the initial state inp and map all variables and locations to undef and map all variables and locations to false the values of uninitialized variables and memory locations are undefined as per the c language specification standard small step rules figure presents the small step dynamic semantics of the language note that in figure b op is a function that returns true if and only if the computation a op b causes overflow a main point of from standard languages is that we also update and to track overflow errors during each execution step for example the rule in figure appropriately updates the overflow flag of x in by checking whether the computation that generates the value of x including the that generates the value of y and z results in an overflow condition also note that the rule for the input read statement nondeterministically updates the value of x with an arbitrary element chosen from the set which contains the values of all instantiations of the input field f in the input file this semantics conservatively models the behavior of input read statements in c programs soundness of the pointer analysis our analysis uses an underlying pointer analysis to analyze programs that use pointers the underlying pointer analysis provides two functions and to our main analysis we formally state our assumptions about the soundness of the underlying pointer alias analysis as follows definition soundness of and given any execution sequence s s and two statements store p x and load x p we have store load i j store load ip j p store load i j store load store ip jp abstract semantics we next define an abstract semantics that allows us to prove the soundness of our static analysis algorithm there are two key differences between the abstract and original semantics first for if and while statements the abstract semantics conservatively ignores the condition and nondeterministically executes one of the two control flow branches second the abstract semantics conservatively groups values that load and store statements access via pointers into equivalence classes based on the aliasing information from the underlying pointer or alias analysis it then conservatively models reads via pointers as nondeterministically returning an arbitrary stored value from the corresponding equivalence class we adopt this abstract semantics because it more closely reflects how sift the underlying pointer or alias analysis and analyzes if while store and load statements abstract program state we define the abstract program state inp as follows var int var bool × bool intuitively and are the counterparts of and in the original semantics but and only track values and flags for variables that have integer values maps the label of each load statement to the set of values that the load statement may obtain from the memory in the initial state inp and map all variables to and false respectively maps all labels of load statements to the empty set c x c x false read x inp nil skip inp const x c x false x c inp nil skip inp assign x y x y x y inp nil skip inp malloc loc is fresh p p false p malloc inp nil skip inp seq nil skip s inp s inp p loc x x load x p inp nil skip inp s inp s inp seq s s inp s s inp p loc x x store p x inp nil skip inp y loc z loc b y z z op op x y op z inp nil skip x y op z x b inp x if x s else s inp s inp x iff if x s else s inp s inp x while x s inp nil skip inp x s s while x s while x s inp s inp figure the small step operational semantics of the language nil is a special label by the semantics if x s else s inp a s inp b y z z op x y op z op x y op z inp a nil skip x b inp iff if x s else s inp a s inp malloc p malloc inp a nil skip inp c b x c x b load x p inp a nil skip inp store satisfies p x inp a nil skip inp load load load x x x x load load ¬ load load ¬ load ¬ load figure the small step abstract semantics nil is a special label by the semantics small step rules figure presents the small step rules for the abstract semantics we omit rules for simple assignment statements while statements and sequence statements for brevity the rules for if while malloc load and store statements reflect the primary differences between the abstract and original semantics the rules for if and while statements iff and the omitted while statement rules in the abstract semantics conservatively ignore the condition and nondeterministically execute one of the two control flow branches the rule for store statements maintains the state according to the aliasing information the rule for load statements nondeterministically returns an element from the corresponding set in relationship of the original and the abstract semantics we formally state the relationship between the original and abstract semantics as follows theorem for any execution trace in the original semantics s s there is an execution trace in the abstract semantics s a s a such that the following conditions hold i x var ix int ix ix ix ix i si x p int the intuition behind the first condition is that i and i as well as i and i always agree on the variables holding integer values the intuition behind the second condition is that corresponds to the possible values that the corresponding load statement of the label may obtain from the memory when a load statement executes in the original semantics the obtained integer value is in the corresponding set in in the abstract semantics this theorem an arbitrary program execution in the original semantics to a corresponding execution in the abstract semantics an important consequence of this theorem is that the soundness of our analysis in the abstract semantics implies the soundness of the analysis in the original semantics see our technical report for the proof sketch of this theorem evaluation of the symbolic condition our static analysis maintains and propagates a symbolic condition c figure defines the evaluation rules of the symbolic condition c over an abstract program state inp the notation inp c denotes that the abstract program state inp satisfies the condition c the evaluation rule for op e checks that no overflow error occurs in any that to the final value of e op e in our abstraction each atom of the form f id corresponds to the value of an arbitrary instantiation of the input field f ­ ie f id corresponds to an arbitrary element of the set each atom of the form id corresponds to an arbitrary value that may be stored via any alias of the corresponding pointer ­ ie id c inp id inp c c b tmp c tmp b inp id tmp is fresh in c inp c inp c inp inp c inp e op false inp op e x false inp c c x x e op e e op e figure symbolic condition evaluation rules corresponds to an arbitrary element of the set the evaluation rules enumerate all possible bindings of f id and id to check that no binding causes an overflow the definition of the evaluation rules also ensures that all occurrences of f id which reference the same input field f and all occurrences of id from the same load statement are this ensures that the normalization algorithm in section is sound ie that id s in a symbolic condition c does not change the meaning of the condition therefore given symbolic condition c the normalization algorithm produces an equivalent condition soundness of the analysis soundness of the analysis over the abstract semantics we formally state the soundness of our analysis over the abstract semantics as follows theorem given a series of statements si a program point and a start condition c our analysis generates a condition f si c such that if i i inp f si c then si i i a sj j j a sj j j j j inp c this theorem guarantees that if the abstract program state before executing si satisfies f si c then the abstract program state at the program point after the statement at label will always satisfy c here the notation a denotes the execution of the program for an arbitrary number of steps in the abstract semantics soundness of the analysis over the original semantics because of the consistency of the abstract semantics and the original semantics see section we can derive the following soundness property of our analysis over the original semantics based on the soundness property over the abstract semantics theorem given a program s a program point and a program variable v our analysis generates a condition c f s such that if inp c then s sn n n n n sn n n n n nv int nv false this theorem guarantees that if the input satisfies the generated condition c note that inp is the constant initial state in section then for any execution in the original semantics here the notation denotes the execution of the program for an arbitrary number of steps in the original semantics at the program point after the statement of the label as long as the variable v holds an integer value not an undefined value due application distinct fields relevant fields figure the number of distinct input fields and the number of relevant input fields for analyzed input formats for the second column shows the number of distinct fields in embedded in collected files to uninitialized access the computation history for obtaining this integer value contains no overflow error experimental results we evaluate sift on modules from five open source applications h a network player a lightweight web browser a player manipulation and generation and an image manipulation application each application uses a available input format specification and contains at least one known integer overflow described in either the database or the paper all experiments were on an intel x machine running we focus on and browser applications client applications in our experiments due to the ease of obtaining inputs required to evaluate our system against false positives other types of applications eg server applications would require additional infrastructure ie recording network traffic to test by design sift is applicable to a wide range of applications methodology input format and module selection for each application we used sift to generate filters for the input format that the known integer overflow we therefore ran sift on the module that processes inputs in that format the generated filters not only the known but also any integer overflow at any of the memory allocation or block copy sites in the modules for which sift was able to generate symbolic conditions recall that there are critical sites in these modules in total input statement annotation after selecting each module we added annotations to identify the input statements that read relevant input fields ie input fields that may affect the values of critical expressions at memory allocation or block copy sites figure presents for each module the total number of distinct fields in our collected inputs for each format the number of annotated input statements in all of the modules the number of relevant fields equals the number of annotated input statements each relevant field is read by a single input statement we note that the number application module all all of ir k k k k k k total input relevant inside loop max condition size figure static analysis and filter generation results analysis time s s s s s s of relevant fields is significantly smaller than the total number of distinct fields the fact that typically only a relatively small number of fields in each input format may affect the sizes of allocated or copied memory blocks the maximum amount of time required to annotate any module was approximately half an the total annotation time required to annotate all benchmarks including was less than an this annotation effort reflects the fact that in each input format there are only a relatively small number of relevant input fields filter generation and test we next used sift to generate a single composite input filter for each analyzed module we then at least realworld inputs for each input format and ran all of the inputs through the generated filters there were no false positives the filters accepted all of the inputs and filter for each known integer overflow we collected a test input that the integer overflow we that each generated composite filter as expected discarded the input because it correctly recognized that the input would cause an integer overflow analysis and filter evaluation analysis evaluation figure presents static analysis and filter generation results this figure contains a row for each analyzed module the first column application presents the application name the second column module identifies the analyzed module within the application the third column of ir presents the number of analyzed statements in the llvm intermediate representation this number of statements includes not only statements directly present in the module but also statements from analyzed code in other modules invoked by the original module the fourth column total presents the total number of memory allocation and block copy sites in the analyzed module the fifth column input relevant presents the number of memory allocation and block copy sites in which the size of the allocated or copied block depends on the values of input fields for these modules the sizes at of the sites depend on the values of input fields the sizes at the remaining sites are safe sift verifies that they depend only on constants embedded in the program and that there is no overflow when the sizes are computed from these constants the column inside loop presents the number of memory allocation and block copy sites in which the size parameter depends on variables that occurred inside loops the sizes at of the sites depend on values computed inside loops to generate input filters for these sites sift must therefore compute loop invariants that capture the effect of the loop on the sizes that occur at these sites the column max condition size presents for each application module the maximum number of conjuncts in any symbolic condition that occurs in the analysis of that module the conditions are reasonably compact and more than compact enough to enable an efficient analysis the maximum condition size over all modules is less than application format of input average time ms ms ms ms ms ms ms ms ms ms ms ms figure generated filter results the final column analysis time presents the time required to analyze the module and generate a single composite filter for all of the successfully analyzed critical sites the analysis times for all modules are less than a second sift is unable to generate symbolic conditions for two of the call sites one in and one in the expressions at these two sites contain subexpressions whose values depend on an unbounded number of values computed in loops to analyze such expressions our analysis currently requires an upper bound on the number of loop iterations such an upper bound could be provided for example by additional analysis or annotations filter evaluation for each input format we used a custom web to and at least inputs in that format the web starts from a search page for the file extension of the specific input format then follows links in each search result page to files in the correct format figure presents for each generated filter the number of input files and the average time required to filter each input we present the average times in the form where is the average time required to filter an input and is the average time required to read in the input but not apply the integer overflow check these data show that essentially all of the filter time is spent reading in the input filter on each benchmark application contains a known integer overflow to that the generated filters operate correctly we obtained for each a malicious input that the integer overflow error we that the filters successfully identified and discarded all of these malicious inputs we also manually examined the root cause of each and that the generated filters completely the if an input passes the filter it will not trigger the overflow error that enables the see our technical report for the detailed case study of each discussion the experimental results the combination of properties that together enable sift to effectively potential integer overflow errors at memory allocation and block copy sites sift is efficient enough to in production on realworld modules the combined program analysis and filter generation times are always under a second the analysis is precise enough to successfully generate input filters for the of memory allocation and block copy sites the results provide evidence that the generated filters are precise enough to have few or even no false positives in practice and the filters execute efficiently enough to with acceptable overhead related work weakest precondition analysis et al present an approximate weakest precondition analysis to verify the absence of null dereference errors in java programs the goal is to verify that for each pointer dereference there are appropriate null checks within the program that guard the dereference to ensure that the program will never execute the dereference with a null pointer value the analysis tracks only pointer dereferences pointer assignments and conditions involving null pointer checks sift different challenges and therefore uses different techniques instead of using a finite domain to track pointers and pointer assignments sift must track potentially unbounded arithmetic symbolic expressions involving input fields and values accessed via pointers to successfully analyze loops abstraction and expression normalization algorithms work together to discover invariants for loops that may access a statically unbounded number of input field as long as the value of the analyzed expression depends only on a statically bounded number of input field instantiations flanagan et al present a general intraprocedural weakest precondition analysis for generating verification conditions for programs sift differs in that it focuses on integer overflow errors because of this focus sift can synthesize its own loop invariants flanagan et al rely on invariants in addition sift is interprocedural and uses the analysis results to generate sound filters that integer overflow errors detection detection techniques generate unsound input filters by learning properties of successfully or processed inputs two key differences are that sift statically analyzes the application not its inputs and takes all execution paths into account to generate a sound filter input input input constraints from training inputs it then monitors inputs for violations of the learned constraints instead of inputs that violate the learned constraints input modifies the input so that it satisfies the constraints the goal is to potential errors while still enabling the program to successfully process as much input data as possible because it the constraints from examples this technique is not sound the generated filter may miss some inputs that target the error it would be possible to combine sift with input to obtain a sound input technique runtime repair researchers have developed a range of techniques for dynamically detecting and errors in the programs execution ­ these techniques all change the programs semantics in an attempt to enable the program to successfully process inputs that it would otherwise be unable to process without error the goal of sift in contrast is to errors without changing the programs semantics by inputs that might trigger the errors static analysis for finding integer overflow and sign errors several static analysis tools have been proposed to find integer overflow andor sign errors for example analyzes individual procedures with the providing procedure specifications that characterize the value ranges of the parameters also avoids the loop invariant synthesis problem by replacing each loop with the loop body in effect unrolling the loop once despite substantial effort reports a large number of false positives sift addresses a different problem it is designed to not detect overflow errors in of this goal it uses an interprocedural analysis symbolic loop invariants and soundly analyzes all execution paths to produce a sound filter symbolic bug finding and validation dart and use symbolic execution to automatically generate test inputs that systematically exercise different controlflow paths in a program one goal is to find inputs that expose errors in the program and are symbolic execution systems designed specifically to expose integer overflow andor sign errors it would be possible to combine these systems with previous filter generation techniques to obtain filters that discard inputs that take the discovered path to the error as discussed previously sift differs in that it considers all possible paths so that its generated filters come with a soundness guarantee that if an input passes the filter it will not exploit the integer overflow error is a backward symbolic analysis engine for error validation the goal is to generate an input that can trigger a potential error identified by some other means as with other symbolic execution systems is designed to enumerate all potential paths that the program may take to reach the error if the number of paths is large or unbounded for example if the program contains loops it may be infeasible to enumerate all paths sift in contrast uses a precondition generation technique that can successfully analyze large programs while soundly taking all paths into consideration runtime checks and library support to the problem of false positives several research projects have focused on runtime detection tools that dynamically insert runtime checks before integer operations another technique is to use safe integer libraries such as and to perform checks at runtime using these libraries requires developers to rewrite existing code to use safe versions of integer operations however the inserted code typically imposes overhead when they detect an error these techniques typically generate a and terminate the execution effectively any integer overflow attack into a of service attack sift in contrast inserts no code into the application and integer overflow errors by inputs that trigger such errors integer in some cases developers may write code that contains integer a potential concern is that techniques that may interfere with the intended behavior of such programs because sift focuses on critical memory allocation and block copy sites that are to have such integer it is to integer and therefore interfere with the intended behavior of the program conclusion integer overflow errors can lead to security sift analyzes how the application computes integer values that appear at memory allocation and block copy sites to generate input filters that discard inputs that may trigger overflow errors in these computations our results show that sift can quickly generate sound efficient and precise input filters for the of memory allocation and block copy call sites in our analyzed benchmark modules acknowledgements we thank michael and the anonymous reviewers for their comments we note our earlier technical report this research was supported by grant references llvm basic alias analysis pass the llvm compiler infrastructure d t r johnson h lin and d rich automatically against department of and computing engineering page d h wang s and d creating signatures using weakest preconditions in proceedings of the th ieee computer security foundations symposium pages ­ dc usa ieee computer society c d and d and automatic generation of tests for complex systems programs in proceedings of the th usenix conference on operating systems design and implementation pages ­ berkeley ca usa usenix association e j m k and m using type qualifiers to analyze untrusted integers and detecting security in c programs detection of and pages ­ s s j and m a powerful approach to weakest preconditions in proceedings of the acm sigplan conference on programming language design and implementation pldi pages ­ new york ny usa acm r a b and s runtime environment driven program safety computer pages ­ m m l l and m software by blocking bad input in proceedings of acm symposium on operating systems principles acm m j m a l l and p containment of in proceedings of the acm symposium on operating systems principles acm w m and h j wang automatic data generation for unknown with in proceedings of ieee symposium on security and privacy ieee computer society w p li j and v understanding integer overflow in cc in proceedings of the international conference on software engineering pages ­ ieee press c flanagan and j b avoiding exponential explosion generating compact verification conditions in proceedings of the th acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm v t and m rinard directed in proceedings of the st international conference on software engineering ieee computer society d m k and d on program tracking for detection in proceedings of the th conference on usenix security symposium volume usenix association p n and k dart directed automated random testing in proceedings of the acm sigplan conference on programming language design and implementation pldi pages ­ new york ny usa acm m s m and m rinard infinite loop escape in in proceedings of the acm international conference on object oriented programming systems languages and applications oopsla pages ­ new york ny usa acm c and g detection of attacks in proceedings of the th acm conference on computer and communications security ccs acm c a and v making contextsensitive pointsto analysis with heap practical for the real world in proceedings of the acm sigplan conference on programming language design and implementation pldi pages ­ new york ny usa acm d integer handling with the c class microsoft f long v m s and m rinard automatic input f long s d and m rinard sound input filter generation for integer overflow errors r and r null dereference verification via weakest preconditions analysis in proceedings of the acm international conference on object oriented programming systems languages and applications oopsla pages ­ new york ny usa acm d x c li and d a dynamic test generation to find integer bugs in x binary linux programs usenix security j d and d x execution for exploit on software in g e d and b g automatically memory errors with high probability in in proceedings of the acm sigplan conference on programming language design and implementation acm press j h s s s j m c f s g wf y m d and m rinard automatically errors in software in proceedings of the acm nd symposium on operating systems principles pages ­ new york ny usa acm m rinard c d d m t and w s server availability and security through computing in in proceedings th symposium on operating systems design and implementation pages ­ m c rinard in the in proceedings of the nd annual acm sigplan conference on objectoriented programming systems and applications oopsla acm d sarkar m j and r flowinsensitive static analysis for detecting integer in programs in r the c secure coding standard addisonwesley w w l and z automatically detecting integer overflow in x binary using symbolic execution in th annual network distributed system security symposium k wang and s j network detection in x wang h chen z n and m improving integer security for systems with in usenix association x wang z li j xu m k c and j y packet exploit detection and signature generation ccs acm c t wang t y chen and w automatically fix at compiletime computer pages ­ 