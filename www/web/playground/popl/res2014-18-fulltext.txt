a approach to solving games on infinite graphs a rice university rybalchenko microsoft research cambridge and abstract we present a approach to computing winning strategies in graph games over the state space of programs such games have numerous applications in program verification and synthesis including the synthesis of reactive programs and verification of programs our method handles games with winning conditions given by safety reachability and general linear temporal logic ltl properties for each property class we give a deductive proof rule that provided a symbolic representation of the game players describes a winning strategy for a particular player our rules are sound and relatively complete we show that these rules can be automated by using an horn constraint solver that supports existential quantification in clause heads the practical of the rules is demonstrated through several case studies including a challenging game that allows infinite alternation of discrete and continuous choices by two players as well as examples derived from prior work on program repair and synthesis categories and subject descriptors d software engineering verification f logics and meanings of programs specifying and verifying and reasoning about programs keywords program synthesis games reactive synthesis proof rules static analysis horn clauses introduction many fundamental questions in formal methods reduce to computing winning strategies in graph games ie games where two players take turns in moving a token along the edges of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm a graph and a player if the sequence of nodes visited by the token satisfies a certain regular winning condition for example · to synthesize a reactive system from a temporal specification one constructs a graph game where the goal of one player is to satisfy the specification and the goal of the other is to violate it the desired system is realizable if and only if the first player has a winning strategy in this game · the problem of verifying a property of a system is naturally as a graph game here one player models the existential path quantifiers in the property the other player models the universal quantifiers the system satisfies the property if and only if the existential player has a winning strategy · graph games are a natural model for open systems that explicitly model interactions between a controller one player and its environment the other player to prove such a system correct we show that the controller has a strategy to enforce its requirements no matter how the environment behaves there is a rich literature on algorithmic approaches to graph games motivated by applications in formal methods the of these approaches focus on decidable classes of games such as games on finite graphs this focus limits the applications of these techniques for example an algorithm that requires a finite game graph can only be applied to the verification and synthesis of finitestate systems to use games in the analysis and synthesis of programs we need symbolic algorithms for solving games on the state spaces of such programs while a few such algorithms exist in the literature much more remains to be done on this topic this paper presents a new approach to this problem space our contribution is an algorithmic technique based on automated deduction for solving games over symbolic transition systems specifically we target three classes of games over infinite graphs safety games reachability games and linear temporal logic ltl games these games differ in the winning condition for the player for we are computing a winning strategy call this player the other player is called in a safety game a play an infinite sequence of nodes visited by the game token if and only if the play avoids a certain unsafe set of nodes in a reachability game a play is winning for if and only if it reaches a certain target set of nodes in ltl games a play if and only if the play satisfies an ltl property we note that ltl games parity games an important class of games where each node of the game graph is labeled with a color from the set n and a play is winning for if and only if the minimum color seen infinitely often in the play is odd the importance of solving the above types of games to formal methods is in the literature for instance the problem of solving a parity game over a programs state space is equivalent to that of verifying program properties written in the modal µcalculus note that the µcalculus subsumes popular temporal logics like ltl ctl and ctl the solution of ltl games is also at the core of reactive synthesis from temporal specifications reachability and safety games are important special cases of ltl games that are sufficient for many applications including program repair program synthesis synthesis of interface specifications and verification of the fragment of the µcalculus without alternation of fixpoint quantifiers for each of the above types of games we give a deductive proof rule that given a symbolic representation of the game graph symbolically represents a winning strategy in the game using quantified horn constraints the rule is then automated by applying the engine for automated deduction to understand how our rules work consider a safety game where the objective of is to satisfy the state property p at all points in all plays to find a winning strategy for our rule for safety games computes an invariant inv that describes the set of states from which can the game this invariant needs to satisfy the following criteria a the initial condition of the game implies inv b inv implies p and c for all transitions out of inv let us say to a destination state satisfies p and there is a transition from back to inv strategy computation in reachability games relies on wellfounded transition invariants to guarantee that a target state is reached after a finite number of of the game we solve ltl games with temporal objective by converting ¬ into a nondeterministic bu¨chi automaton then performing a fair termination check on the product of this automaton and the game graph all of our rules are sound meaning that if they derive a strategy for a player then the player actually under the strategy as well as relatively complete meaning that they can always derive a winning strategy when one exists assuming a powerful assertion language from a practical point of view the of our rules is that they the most recent developments in invariant generation and termination verification specifically our implementation our proof rules to the engine in the form of clauses in some cases with existential quantifiers in clause heads solving the game now amounts to these clauses to a bounded depth proving the of the the process and generalizing from proofs of to a solution for the original clauses does so using a combination of counterexampleguided cegar interpolation and smt solving and with help from templates that capture highlevel about the strategy we evaluate using several challenging case studies including the game an existing challenge problem for graph games that allows infinite alternation of discrete and continuous choices by the two players and games arising out of prior work on program repair and synthesis now we summarize the main contributions of the paper · we take on the problem of solving games over state spaces of programs using the power of modern automated software analysis technology · we present three deductive proof rules for solving such games under the safety reachability and ltl winning conditions our rules are sound and relatively complete and our rule for ltl games avoids the need to a bu¨chi automaton · we offer a prototype implementation of our rules on top of an existing automated deduction engine we illustrate the of the system through several case studies using examples in prior work this paper is organized as follows in section we describe the game as a motivating example section formally defines graph games and the strategy computation problem section gives our proof rules for solving games and proves them correct ie sound and relatively complete section the example from section and applies our rules to variants of it section presents applications of our rules to repair and synthesis problems from prior work section presents concrete experimental results related work is described in section we conclude with some discussion in section the game in this section we describe a synthesis problem that motivated this work and that we use in a case study later in the paper a version of the problem was previously by as a challenge problem for the software synthesis community see et al and et al for more on the problem the problem involves a game between the and her the the game involves five in a each bucket can hold up to c a constant units of initially all are empty in each round of the game unit of additional and splits it among the five if any of the overflow if not two adjacent if the game goes on forever we can model the game using the following symbolic transition system let v be a set of system variables that represent the amount of in the five v b b b b b all the are initially empty this fact is specified as the initial condition b · · · b the transition relation of represents a nondeterministic choice of in which unit of additional is added v v b · · · b b · · · b b b · · · b b the transition relation of the player represents a nondeterministic choice of two consecutive that are v bi bi i j i j i j bj bj the condition that one of the is described by the assertion overflow v b c · · · b c safety game we observe that in the above game wants to enforce a safety property specifically the property v in every play of the game this property is winning condition games are classified according to the winning condition of the player for we want to compute a strategy specifically suppose we want to compute a strategy for in that case we are trying to solve a safety game reachability game now suppose we want to compute a strategy for instead we note that the winning condition for is the reachability property f overflow v the game is a reachability game ltl and parity games it is easy to define of the game where the winning condition for a player is a general linear temporal logic ltl property such a game is called an ltl game ltl games are an extremely challenging class of games the problem of solving such games on finite game graphs is the intuitive reason for this is that it requires a conversion from an ltl formula to a nondeterministic bu¨chi automaton an exponential and then the of this automaton another exponential an important special case of ltl games is parity games here each state of the transition system is assigned a color a number in n and the winning condition for a play is that the minimum color seen infinitely often in the play is odd the condition can be stated in ltl in an obvious way in section we use on a parity game generalizing our original game discussion from the of the classes of graph games that we study it follows that for every value of c either or has a winning strategy in each of the above games now we give some about what such a winning strategy would look like in the game as originally stated the discussion of how to automatically solve the problem using is until section first note that if c units then her strategy is as follows in the first round she unit into two then no matter what does there will be a bucket with units at the end of the round and can cause a in second round by adding unit in that bucket if c units she can just select the in a order two in each round and this strategy is winning no matter what does the problem becomes more challenging for c we leave this case as a challenge for the reader it will soon be apparent that it is highly nontrivial in such cases fully automated strategy synthesis seems and proofs driven by or templates are more this is the strategy that our approach takes in this section we formally define games and strategies and also sketch the deduction framework used to them games syntax a graph game is a pair consisting of a symbolic transition system and a winning condition · we consider symbolic transition systems that are composed from two players and let v be a tuple of variables we assume that valuations of v describe states of the system under consideration for simplicity we do not distinguish between variables controlled by and we represent the initial states of the transition system by an assertion the transition relations of and are given by assertions v and v respectively · a winning condition obj for a game is given by a set of infinite sequences of system states a game is said to be a safety game a reachability game and an ltl game respectively when its winning condition is a safety property a reachability property and a general ltl property semantics we present the semantics of games in two steps first we define strategies of the individual players a strategy for is a set of infinite trees over the states of the system that satisfies the following conditions · the roots of trees in coincide with the set of initial states and are considered to be on the first level of the tree here the level of a node is the length of the path to the root plus one · the set of successors of each tree node s at an odd level consists of the following set of states s s s v · the set of successors of each tree node s at an even level consists of a nonempty subset of the following set of states s s s v thus a strategy for between universal choices of and existential choices of we call each infinite sequence of system states that starts at a root of a strategy and follows some branch a play determined by a strategy for is winning if every play determined by is included in the winning condition for the given system and a formula that describes a winning condition in some temporal logic we write v v when has a winning strategy we also consider perspective a strategy for is defined in a similar way the roots of represent a nonempty subset of between existential choices of and universal choices of if a tree node s is on an odd level then its successors form a nonempty subset of s s s v otherwise the set of successors is s s s v the engine our proof rules are automated using the engine for clauses extended with criteria we skip the syntax and semantics of the clauses by this system see for more details instead we illustrate these clauses with the following example x y x y rank x y y rank y z z rank x y y ti intuitively these clauses represent an assertion over the interpretation of query symbols rank and ti the predicate represents disjunctive and is not a query symbol the semantics of these clauses maps each predicate symbol occurring in them into a constraint over v specifically the above set of clauses has a solution that maps both rank x y and y to the constraint x y x clauses like the above using a cegar scheme to discover witnesses for existentially quantified variables the refinement loop collects a global constraint that determines which witnesses can be chosen the chosen witnesses are used to replace existential quantification and then the resulting universally quantified clauses are passed to a solver for such clauses at this step we can benefit from tools in the area of solving horn clauses over decidable theories eg or such a solver either finds a solution ie a model for uninterpreted relations constrained by the clauses or returns a counterexample which is a resolution tree or dag representing a contradiction turns the counterexample into an additional constraint on the set of witness candidates and continues with the next iteration of the refinement loop notably this refinement loop constraints that are obtained for all discovered counterexamples this way guarantees that previously handled counterexamples are not and that a wrong choice of witnesses can be for the existential clause above introduces a relation sk over variables x and y ie x sk x y x y rank x y in addition since for each x such that x holds we need a value y we require that such x is in the domain of the relation using an additional clause x y sk x y in the approach the search space of a relation sk x y is restricted by a template function x y in general a template is required for both the relation as well as for its guard for this paper templates for the guards can be derived automatically as the projection from the template of the corresponding relation therefore we omit them from our presentation proof rules for games in this section we present proof rules for three kind of games safety reachability and games these proof rules conclude that has a winning strategy by implication and conditions on auxiliary assertions over system variables for each proof rule we prove its soundness ie a winning strategy exists if the premises are satisfied by some auxiliary assertions and relative completeness ie if a winning strategy exists then auxiliary assertions satisfying the premises exist under an assumption that the assertion language of our choice is sufficiently expressive such correctness criteria are standard for temporal proof rules safety games we consider a safety game for which has a winning strategy if only states from are visited by all plays we present the corresponding proof rule in figure the proof rule relies on an invariant assertion inv v that represents a set of states reached by in a winning strategy we connect the invariant assertion with the reachable states by to reasoning by induction on the number of steps to reach a state the condition s requires that the initial state of the game are considered in inv v s represent the induction step here we require that for every step from inv v executed by there exist a step by that leads back to inv v of course since the winning condition requires that all states of a play need to satisfy we require that all states reached after made a step as well as inv v satisfy the assertion the former condition is enforced by a conjunct in the head of s the later condition is guaranteed by s theorem correctness of rule the proof rule is sound and relatively complete proof we split the proof into two parts soundness and completeness soundness we prove the soundness by contradiction assume that there exists an assertion inv v that satisfies the premises of yet the conclusion of does not hold that is there is no winning strategy for hence there exists a strategy for in which each play reaches a state that violates this strategy between existential choices of and universal choices of let aux v be a set of states for which provides existentially chosen successors wrt we derive a contradiction by relying on a certain play that is determined by the play is constructed iteratively we start from some root state s of which also satisfies the initial condition note that s inv v due to s and s aux v due to each iteration round extends the play obtained so far by two states say s and s we maintain a condition that each such s satisfies inv v and aux v let s be the last state of the play constructed so far due to our condition we have s inv v aux v then determines a successor state s such that s s v and s guarantees that there exists a state s such that s s v and s inv v furthermore s satisfies aux v due to finally from s and s follows that s and s respectively by iteratively constructing using the above step we obtain a play that satisfies the strategy thus we obtain a contradiction since according to our construction all states in satisfies however guarantees that each play eventually reaches a state that violates completeness assume that has a winning strategy say ie the conclusion of holds we prove the completeness claim by showing how to construct inv v that satisfies the premises of this strategy between universal choices of and existential choices of let inv v be a set of states for which provides universally chosen successors wrt since is a winning strategy all states satisfying inv v also satisfy ie inv v satisfies s inv v satisfies s since guarantees that from every initial state now we consider an arbitrary state s that satisfies inv v guarantees that for every successor s of s wrt there exists a successor s wrt such that s inv v furthermore since is winning we have s thus we conclude that inv v satisfies the condition s as well reachability games in contrast to safety games the winning condition of reachability games ensures that a certain set of states called is eventually reached by each play reasoning about such properties demands the use of wellfounded orders we present a rule for proving that has a winning strategy for a reachability property given by an ltl formula f in figure requires an invariant assertion inv v together with a binary relation round v v similarly to we use inv v to keep track of states that are reached by this is captured by r and a part of r to ensure that makes progress when at the set we keep track of pairs of states towards reaching it in round v v see the last conjunct in r we note that the proof rule only imposes conditions when is not yet reached as encoded by the second conjunct in r finally to ensure that is eventually reached by each play we require that round v v represents a wellfounded relation thus it is impossible to return to inv v infinitely many times theorem correctness of rule the proof rule is sound and relatively complete proof we split the proof into two parts soundness and completeness soundness we prove the soundness by contradiction assume that there exist assertions inv v and round v v that satisfy the premises of yet the conclusion of does not hold that is there is no winning strategy for hence there exists a strategy for in which each play never reaches a find assertion inv v such that s inv v s inv v v v v inv v s inv v v v g figure proof rule for a safety game ie the winning condition is given by a formula g find assertions inv v and round v v such that r inv v r inv v v v v inv v round v v r well round v v v v f figure proof rule for a reachability game ie the winning condition is given by a formula f state that satisfies this strategy between existential choices of and universal choices of let aux v be a set of states for which provides existentially chosen successors wrt note that the implication aux v is valid since no play determined by we derive a contradiction by relying on a certain play that is determined by the play is constructed iteratively in a similar way as done in the proof of theorem we start from some root state s of which satisfies the initial condition note that s inv v due to r and s aux v due to each iteration round extends the play obtained so far by two states say s and s we maintain a condition that each such s satisfies inv v and aux v let s be the last state of the play constructed so far due to our condition we have s inv v aux v then determines a successor state s such that s s v and r guarantees that there exists a state s such that s s v and s inv v furthermore s satisfies aux v due to finally from r also follows that s and s s round v v by iteratively constructing s s using the above step we obtain a play that satisfies the strategy thus there is an infinite sequence of states s s s that takes states occurring at odd positions in such that each pair of consecutive states si and si is connected by round v v for i the existence of such an infinite sequence contradicts the condition imposed by r completeness assume that has a winning strategy say ie the conclusion of holds we prove the completeness claim by showing how to construct inv v and round v v that satisfy the premises of the strategy between universal choices of and existential choices of each play s s s elements to inv v and round v v as follows let k be the position of the first occurrence of a state in that satisfies ie we have sk and si for each i k such position exists since the play satisfies f then for each i such that i k we add the state si to inv v furthermore for each i such that i k we add the pair of states si and si to round v v we note that the above construction ensures that for each pair of states s and s such that s s round v v holds i we have s and ii there exists a state s such that s s s v and s s v we observe that inv v satisfies r since guarantees that from every initial state now we consider each pair of states s and s that satisfies the left hand side of r guarantees that there exists a successor s wrt regardless whether s the above construction guarantees that the righthand side of r is satisfied by assigning s s and s to v v and v respectively now we show by contradiction that round v v is wellfounded assume otherwise ie there exists an infinite sequence of states s s induced by round v v as noted previously for each pair of consecutive states si and si there exists an intermediate state si such that the sequence s s s si si si is a play since this play does not visit any state that satisfies we obtain a contradiction to the assumption that has a winning strategy hence we conclude that r is satisfied ltl and parity games now we show how to solve ltl games and as a special case parity games to state the parity winning condition we assume that the set of all states is partitioned into n subsets that are denoted by the assertions pv pn v thus pv · · · pn v is valid and for each i j n we have that is unsatisfiable without loss of generality we assume that n is an odd number the parity condition states that the system the game for a given computation if among the subsets pi v v that are visited infinitely many times by the computation the minimal identifier is odd ie ik is odd we can represent the parity condition by the following ltl formula gf pv gf pv f pv ··· gf pn v f · · · the first disjunct states that pv is visited infinitely often while the second disjunct states that pv is visited infinitely often and there exists a suffix that neither pv nor pv the last disjunct states that pn v is visited infinitely often and there is a suffix that no other subset to solve games where the winning condition is an ltl formula we and apply a standard technique eg for translating ltl formulas to bu¨chi automata on the resulting ¬ let b be the obtained automaton we represent b using assertions over the program counter of the automaton and the system variables v let the initial condition of the automaton be given by we represent the transition relation of b by v this transition relation the value of the program counter of the automaton while taking into consideration the current state of the system given by a valuation of v finally we assume that represents the accepting states of the automaton given a sequence of states s s we define a run of b on to be an infinite sequence of automaton states q q q such that q init and qi si qi v for each i a run is accepting wrt the bu¨chi acceptance condition if it contains infinitely many states that satisfy the automaton b accepts a play if there exists an accepting run on note that our construction ensures that if b accepts then a proof rule for ltl games based on the above approach is presented in figure requires that the negation of the winning condition is translated into a bu¨chi automaton b which together with the system description appears in the proof rule an interesting property of this proof rule is that it relies on a nondeterministic bu¨chi automaton representation of the winning condition and does not require any via or acceptance conditions we consider a synchronous parallel product of the transition relations of the players and the transition relation of the bu¨chi automaton which is expressed in the proof rule by appropriate conjunctions we use w v to refer to the vector of the system variables and the program counter of the automaton the existence of a winning strategy for depends on the identification of auxiliary assertions inv w aux w w v round w w w and fair w w as follows inv w keeps track of the system states reached by similarly to and to deal with the nondeterminism in the transition relation of the automaton we introduce an intermediate assertion aux w w v which allows us to the treatment of the automaton state q from the selection of s round w w w contains all triples of adjacent program states occurring in plays here it is more finegrained than the counterpart in as we keep track of intermediate states visited by instead of only considering the combined steps visited by for keeping track of acceptance fair w w contains all pairs of program states that describe play segments bu¨chi accepting states at least once we derive fair w w from round w w w using transitive conditions b and b finally the condition b shows that accepting states cannot be visited infinitely many times theorem correctness of rule the proof rule is sound and relatively complete proof we split the proof into two parts soundness and completeness soundness we prove the soundness by contradiction assume that there exist assertions inv w aux w w v round w w w and fair w w that satisfy the premises of yet the conclusion of does not hold that is there is no winning strategy for hence there exists a strategy for in which each play violates this strategy between existential choices of and universal choices of we derive a contradiction by relying on a certain set of trees whose branches are sequences s q s q that are determined by and the assumed assertions via the branches are constructed iteratively in a similar way as the play construction is done in the proof of theorem we start from some root state s of which satisfies the initial condition then the play is extended from a state s by considering an existential choice s by that is followed by an existential choice s by b we obtain appropriate runs q q by applying b b and b for values of v v and v determined by currently considered s s and s respectively since the automaton b is nondeterministic for each s s and s there is a set of appropriate automaton states considering each choice leads to a tree construction as described below first we consider s and b and for each q such that there exists q with s q we add a s q as a root to our tree we remember the state q that was used to create each s q then for each tree leaf s q we perform the following tree expansion first we consider the state s that provides as a successor of s then we rely on b and for each q such that s q holds we add s q as a child node of s q furthermore for given s and q and each s and q we take s such that s aux s q s q s now we rely on b and for each q such that s q holds we add s q as a child node of the corresponding s q by applying the above tree expansion steps we construct a set of trees where every branch is a sequence s q s q that comes with the corresponding initial automaton state q note that s s is a play determined by hence it violates thus there exists a branch for which the sequence q q is an accepting run of b for the corresponding play determined by the branch let si qi si qi be a subsequence such that for each j then each pair or its visited by to fair w w thus the condition b is violated completeness assume that has a winning strategy say ie the conclusion of holds we prove the completeness claim by showing how to construct inv w aux v w v round v w w and fair w w that satisfy the premises of the strategy between universal choices of and existential choices of each play s s s elements to inv w aux v w v and round w w w in the following way through an appropriate sequence of automaton states q q q since we note that is not accepted by b hence either there is an infinite run q q q that is not accepting or the exists a finite run q qn that cannot be extended ie there is no automaton find assertions inv w aux w w v round w w w and fair w w where w v such that b v inv v b inv w v v v v aux w w v b aux w w v v inv w round w w w b round w w w fair w w b fair w w round w w w fair w w b well fair w w v v figure proof rule for an ltl game ie the winning condition is given by an ltl formula from ¬ we obtain a bu¨chi automaton b with an initial condition a transition relation v and accepting states state qn such that sn sn in either case for each i and i n if the run is finite we let si qi be an element of inv w si qi si qi si be an element of aux w w v and si qi si qi si qi be an element of round w w w then we define fair w w for the obtained round w w w as the least solution of b and b since the run is not accepting it accepting states only finitely many times hence fair w w is wellfounded case study games in this section we illustrate our approach to solving games applying it to the game introduced in section we consider five variants of this game corresponding to different winning conditions in section we report on running times required for solving these games using games with safety objective in these games we attempt to obtain winning strategies for in her attempt to keep the from the winning condition for is g v as mentioned in section the player has simple winning strategies for bucket c for values c the strategies are more involved for values c there are no strategies for the player to the game round strategy we define the first game using the value c for the bucket a winning strategy might follow an alternation of consecutive that are accordingly we use an auxiliary variable r for a pair of to be to remember the previous choice made by the player the tuple of game variables contains the five bucket variables from v and is extended with the round variable r as follows w b b b b b r the initial states assertion sets the round variable to r we let play the role of and therefore the transition relation of is based on the assertion v v while the transition relation of is given by v both constraints are given in section init w b · · · b r w v w v v r r considering the safety condition obj w v we instantiate the proof rule from figure as follows w w obj w there exists a strategy for provided that the premises of the proof rule are satisfied these premises are horn clauses over the auxiliary assertion inv w we apply a solver eg to find a solution for the auxiliary assertion the clauses s and s are universally quantified over the game variables while the existentially quantified clause s is in the approach we use the relation sk w w w to denote the witness constraint corresponding to the existentially quantified variables w inv w v v r r sk w w w v inv w requires a template for the relation and we present below the intuition behind this constraint for each of the five from v transition relation we add guards one guard exclusive to the others and update the value of the round variable we use cv v to cv v to denote the five from the transition relation of the player introduced in section we obtain the following template constraint w w w r r r r r r r r r r cv v cv v cv v cv v cv v the template parameters are denoted by variables and different subscripts indicate distinct template parameters our approach is able to synthesize automatically the values used to update the round and implicitly the order in which the player should alternate the returns the solution corresponding to this solution the strategy for the player consists of a sequence of three player moves since initially r and the first disjunct is enabled decide to empty and and update the round variable r since the disjunct r r is enabled decide to empty and and update the round variable to r since the disjunct r r is enabled decide to empty and and update the round variable to r after these three moves r has value the first disjunct is again enabled and the strategy will continue with the first above this strategy ensures that the player often enough all the and therefore the player cannot enforce an overflow this game is by the player based on the round strategy described above second strategy we show how our approach can be used to obtain a strategy for the case of the game that is more difficult for to ie c we fix the roles of the two players similar to the previous v v and v v v to explain the behind the decisions for this case we refer to the proof rule from figure we repeat the second clause s instantiated for the two players of the cs game inv v v v v inv v to change the state of the system from v to v the strategy for the player takes into consideration her previous move reflected in variables v and the reply by reflected in variables v therefore the template for the strategy considers five cases depending on which the player may have in the previous turn v v v b b tv v b b tv v b b tv v b b tv v b b tv v the conjuncts refer to knowledge and relate to an invariant stating that each pair of should have total contents at most the first part of the template ie t is based on the intuition that if in the previous round and b b then during the next round she will decide to empty another pair of that is either the pair of and b b or the pair of and b b will be however the condition on which to decide if to empty and or and is not straightforward we use template parameters and leave the decision to be automated by our game solving approach the formula t is provided as follows tv v b b b b b b b b following a similar argument we obtain the formulas that complete the definition of the template v v v tv v b b b b b b b b tv v b b b b b b b b tv v b b b b b b b b tv v b b b b b b b b the template parameters are marked as before by variables and we aim to obtain solutions for the five template parameters our approach is indeed able to synthesize automatically values for these parameters the tool returns the solutions the resulting strategy for the player guarantees that no state with overflow can be reached for a different perspective we refer the interested reader to an article on reasoning and invariants needed to establish strategies for the game similar to the ones we synthesize game with reachability objective we continue our approach with the game this time based on a reachability objective the winning condition for the player requires that a state with overflow is reached obj v f overflow v for this game we use the bucket c a value for which the has indeed a winning strategy to derive this strategy we instantiate the proof rule for the reachability game as follows b · · · b v v v v v next we provide a template corresponding to the existentially quantified clause the insight behind the template is that the of from each bucket increases during the turn of but without specifying the amount ie bi i v v v · · · bi i i our approach computes the auxiliary assertions that are required by the reachability proof rule and a witness for the existential quantifier the witness the template parameters and represents the strategy to ensure that the eventually overflow no matter what moves are made by the player sk v v b b b b b b b b b b in this case since the addition of is done in eg b and b eventually the game reaches an overflow state and the is the player to this game games with ltl objectives apart from games with safety and reachability objectives our approach is able to handle games with more general ltl objectives for this game we use the following player roles b · · · b v v v v v we use the value c for the bucket similar to section as already explained with this value has a strategy to the game with the objective v f overflow v consequently does not have a strategy to the game with the objective set to the complement formula ie g v for this section we formalize a winning condition that is a weaker logical formula than for which has a winning strategy the objective constraint gf v states that an overflow state does not occur infinitely often in the plays of the game more generally we use color to indicate the most significant bucket for which an overflow occurs · a state without overflow color · a state with overflow such that i is the smallest index of those that correspond to that have color i we group the states of the system based on the truth value of the predicates color i as follows pv color b · · · b pv color b pv color b b pv color color color a winning condition corresponding to a value i ensures that states from occur infinitely often in the plays of the system and that i is the smallest value for which states occur infinitely often i gf f g ji our approach for solving games with ltl objectives proceeds in three steps complement the ltl formula representing the winning condition construct a bu¨chi automaton corresponding to the formula ¬ instantiate the proof rule from figure using the bu¨chi automaton representation ltl game for the first ltl game we define the objective for the player obj v gf pv we complement the objective formula to obtain f g f g overflow v then construct the bu¨chi automaton correspond ing to the formula as follows init next v overflow v overflow v we instantiate the proof rule from figure as follows v v obj v there exists a strategy for provided that the premises of the proof rule are satisfied these premises are horn clauses over the auxiliary assertion inv w aux w w v round w w w and fair w w we apply to find a solution for the auxiliary assertions the clause b is an existentially quantified clause by of the existential clause b we obtain the following inv w v v v sk w w v v aux w w v using the template described in the second strategy from section our approach is able to derive solutions for the auxiliary assertions and the following template parameters we conclude that is the player to this game and that her strategy ensures that states without overflow occur infinitely often in the plays of the game ltl game for the second ltl game we define the objective for the player the objective for the player is the formula corresponding to the objective gf pv gf pv f g f g the formula is ¬ f g f g gf pv gf pv the bu¨chi automaton corresponding to the formula contains distinct control states from which two are accepting states using our proof rule we are able to compute automatically auxiliary assertions and obtain that the same second strategy is winning for the player note that for the player the ltl game with objective is easier to than the ltl game with objective however the relation between the two objectives is not immediately usable in a deductive approach like ours we presented both ltl games and since our approach based on the proof rule from figure constructs different automata and different auxiliary assertions for the two objectives case study program games in this section we illustrate how our approach to solving games applies to the synthesis of reactive programs from temporal specifications we consider synthesis problems obtained from program repair questions see section and section as well as inference of thread synchronization see section in section we report on running times required for solving these games using program repair game with safety objective we model program repair as a game following that is given a set of statements we look for a modification of those program statements such that the modified program satisfies its specification for the first repair game we assume that a program is given by a tuple v error v that represents initial states a transition relation and error states respectively as an example we consider the program shown in figure in the program has three program variables v l gl pc the variable l models a lock the variable gl is used to keep track of the status of the lock while the variable pc is the program counter variable the initial states of the program are gl l pc we show the controlflow graph of the program below the transition relation is defined as follows v v pc pc l l gl gl v v pc pc l l gl gl v v pc pc l l v v pc pc gl l l gl gl v v pc pc gl l l gl gl v v pc pc l l gl gl v v pc pc l l v v v · · · v v note that in v v and v v the variable gl is assigned a nondeterministic value since it is not constrained by the corresponding assertions the execution of the program enters an error state at location if the lock variable l is held and at location if the lock variable l is not held ie we have error v pc l pc l we instantiate the safety game proof rule such that the system role is by the program transition relation and the environment role is to provide inputs to the program in this case the pro gram does not expect any inputs v v v v obj v g v a repair of the program restricts the transition relation of the program such that g v holds to this end we provide a template corresponding to the existentially quantified clause of the proof rule v v v pc pc gl pc pc gl our algorithm returns the witness for the existential quantifier clause that the template parameters and this corresponds to a program that assigns the value to gl at location and assigns the value to gl at location we obtain the same program repair as the solution originally presented in concurrent program repair games with safety and response objectives we illustrate how our approach can be applied to concurrent program repair problems and in particular to repair problems under fairness assumptions we use the critical section example from figure in for this purpose in this example the assignment false at location is the goal is to repair this assignment and hence the entire program by checking if there exists an assignment to the variable from its domain true false such that the resulting program satisfies certain temporal properties these properties are used in the repair process towards the correct version of the program let fa fb tb fa fb tb be abbreviations of original variable names we encode the original program over variables v pc pc x y fa fb tb fa fb tb using an initial condition such that fa fb tb fa fb tb pc pc and a transition relation v since the program is multithreaded with two threads we give v as a disjunction of transition relations of individual threads v pc pc v pc pc for the first thread we define note that we assignments of a nondeterministic value to a variable z by z nd and we omit equalities for variables that do not change hence each variable z that does not appear in z is constrained by z z next v v pc pc fa pc pc tb nd pc fb tb pc pc fb tb pc pc pc fa pc tb pc fa pc tb pc pc pc tb pc fb tb pc pc fb tb pc pc pc fa pc pc note that the second disjunct above leaves the value of tb unrestricted as denoted by tb nd for the second thread we define next v v pc pc fb pc pc tb pc fa tb pc pc fa tb pc pc pc fb pc pc tb pc fa tb pc pc fa tb pc pc pc fb pc pc fb pc pc in the original problem there are two properties directed by which the program should be the first property requires that the two threads do not enter their critical sections at the same time this property is specified with the following ltl formula v g pc pc pc pc the second property requires that neither of the threads can be in a deadlock state this property is specified as follows v g pc f pc pc f pc pc f pc pc f pc safety game doing the program repair using the first property amounts to applying the safety proof rule from figure to find inv v since there is no interaction with the environment v will simply be equivalent with v to apply our proof rule we use v for v and v as the winning condition obj we use the following template for the existential clause v v v tb computes the solution and we obtain a modified version of v where the nondeterministic assignment tb nd from the second disjunct is replaced by tb fair ltl game the second property relies on fairness assumptions to deal with the fairness we apply a transformation technique from that reduces fair parallelism semantics to the usual parallelism semantics the idea is to use the equivalence p fair if and only where p is the original program is the fair transformation function is the transformed program with embedded tracking of fairness and is the property to check the transformation does not change the initial states of the program but it significantly modifies the semantics of the transition relation of the program a counter variable is introduced for each thread from the program and the first statement of each loop is by adding a guard and an update involving the counter variables see for details for our example program the transformation · introduces the counters k and k · adds the guard k k and the update constraint k nd k k to the first third and disjunct from v · adds the guard k k and the update constraint k k k nd to the first third and disjunct in v let v k k be the initial condition of the transformed program we refer to the transformed transition relations as v k k v k k and v k k v k k and present them below v k k v k k pc pc fa k k k nd k k pc fb tb pc k k k nd k k pc fb tb pc k k k nd k k v k k v k k pc pc fb k k k k k nd pc fa tb pc k k k k k nd pc fa tb pc k k k k k nd the second property is more complicated than the first property since it involves nesting of temporal operators like the case for the first property we assume v to be equivalent with v we make v v to play the role of v and g pc f pc pc f pc pc f pc pc f pc is now a winning condition obj we reuse the template used for the previous game and we get exactly the same solution that is we determine tb nd to tb in the second disjunct of v k k v k k synthesis of synchronization game with safety objective synthesis of synchronization in multithreaded programs can be automated using our approach for illustration we use the example program from figure in and represent it using a tuple v error v for the case when three threads are involved in computation the program variables are v x y y z pc pc pc the initial states are described by init v x z pc pc pc the transition relation of the program is v v pc pc pc pc next v v pc pc pc pc next v v pc pc pc pc such that v pc pc x x z y z pc pc x x z y z v pc pc z z y y pc pc z z y y v pc pc x y y z pc pc x y y z pc pc x x y y z pc pc y x y z pc pc y y y y z different interleavings of the three threads lead to different values of y and y an assertion in the third thread at location requires that the values given to y and y are not equal ie we have error v pc y y for the given program some interleavings lead to the values of y and y being equal while other interleavings lead to distinct values for the two variables the goal of is to add synchronization to the program such that the assertion holds on all executions to apply our proof rule to this problem we encode the choice between executing a single step and executing an atomic section using auxiliary variables the transition relation of the program is augmented with guards deciding a single step or an atomic section based on the values of the auxiliary variables for our example we use four auxiliary variables c c c c we obtain an extended tuple of variables w v c c c c a constraint is used in thread i to decide that the control flows from location j to location the transition relation of the first thread is augmented to w pc c pc x x z skip pc c pc x x z skip pc pc x x z skip the transition relations of the second and third thread are instrumented similarly we instantiate the safety game proof rule such that the system role is by the instrumented program transition relation and the environment role is to provide inputs to the program similar to the previous case this example program does not expect any inputs init w w w w w w w furthermore we represent the search of initial parameter values using a strengthening of the original initial condition with an assertion mid w t such that t mid w t mid w t w w g w we use and provide the following template for the existential clause involving the initial states w t c c c c name g g g g g g g g g game c c c c c player p program program program program objective for player p g g f overflow g g g at p f p g result time z s ms s ms s s s s to time s ms ms s s s ms s table statistics for case studies a stands for time out after a solution to mid w t sets the auxiliary variables to target program locations so that the objective of the game is satisfied ie the error states are not reachable returns the following witness for the existential quantifier clause sk w t c c c c we note that our proof rule does not represent an optimization problem the solutions we obtain correspond to a synthesized program that is not necessarily the most efficient one ie the longest atomic sections may be instead of smaller steps dealing with optimality is a subject for future work experimental results in this section we describe how we used as a implementation of our proposed approach to solving games is implemented in prolog and is a solver for horn clauses over linear inequalities the implementation uses two smt solvers for handling nonlinear constraints the z solver and the solver for our experiments we used a computer with an intel core cpu and gb of ram table shows the results corresponding to the case studies described in the paper games with safety objectives g and g with reachability objectives g and with more general ltl objectives g and g we show results on the program games g g g and g for each game we report the player and the objective for which we synthesize strategies see columns and column shows the result obtained from our tool an mark stands for a strategy successfully synthesized by our tool using either z or as solving in one case g due to the general ltl objective we obtain a large bu¨chi automaton our normal encoding for both z and however can synthesize a winning strategy quickly if we exploit an optimization where we treat infinite datatypes symbolically using a decision procedure and finite domain datatypes explicitly without abstraction because the control locations of the bu¨chi automaton range over a finite domain this optimization allows the tool to track the states of explicitly and this simplifies the proof obligations we believe our approach will benefit from future improvements in constraint solving the cases when either z or times out are challenging smt problems and of potential interest to the community related work there is a rich literature on decision procedures for graph games with application to formal methods in particular many techniques both and symbolic are known for games on finite graphs decidability results are also known for games on certain restricted classes of infinite graphs such as pushdown graphs and graphs known approaches to games on graphs that represent state spaces of general programs can be divided into two categories those based on symbolic execution and those based on de et al offer an example of the first kind of approach in this work a symbolic is used to explore the state space of the game directly in contrast we reduce the problem of solving a game to horn constraint solving leaving the constraints to be solved by a solver relying on cegar and interpolation the second category of methods ­ lift predicate abstraction and cegar originally proposed for safety verification to games the core idea here is the use of abstract transition systems where may and must transitions are permitted and which are against properties with valued semantics in contrast to existing approaches of this sort we do not directly construct a program abstraction with or valued semantics instead we use a relation that is iteratively refined moreover our solver uses wellfounded transition invariants to resolve liveness goals for players which so far as we are aware existing approaches do not do this algorithmic difference has a significant impact in practice our approach is perhaps more closely related to a recent paper by cook and which uses a combination of cegar with a form of for verification of properties of programs however this method only studies verification of ctl the class of properties that we handle is significantly larger eg it includes the full µcalculus games have a particularly close connection to program synthesis and repair areas that have seen a of activity in the last few years however in recent as well as classical algorithms in these areas the focus is to be either on finitestate systems or on functional rather than reactive programs in contrast the natural application of our approach is in the repair and synthesis of reactive programs finally our work here was inspired by the rich of on deductive program synthesis the main difference between this line of work and ours lies in our focus on automation for example also offers a deductive rule for games with response objectives however the proof rule demands global ranking functions and and assumptions which are known to be difficult to automatically conclusion we have presented a constraint based approach to computing winning strategies in games the approach consists of a set of sound and relatively complete proof rules for solving such games and automation of the rules on top of an existing deduction engine we demonstrate the practical of our approach through several case studies using examples derived from prior work on program repair and synthesis many for future work remain open the system we have presented is a prototype much more remains to be done on engineering it for greater scalability in particular we are especially interested in applying the system to reactive synthesis questions arising out of embedded systems and on the theoretical end exploring opportunities of between our approach and and approaches to games remains a open question acknowledgements this research was supported in part by the project by the and by nsf and references r p p and w synthesis of interface specifications for java classes in popl pages ­ t ball and o an framework for systems in lics pages ­ ieee t c and a rybalchenko solving existentially quantified horn clauses in cav m c v f g and h versus the in ifip pages ­ m r a e and a the smt solver in cav pages ­ c s a e and a sat modulo linear arithmetic for solving polynomial constraints j reasoning ­ j r bu¨chi and l solving sequential conditions by finitestate strategies trans math ­ t symbolic strategy synthesis for games on pushdown graphs in icalp pages ­ t uniform solution of parity games on graphs electronic notes in theoretical computer science ­ k and l energy parity games b cook and e reasoning about nondeterminism in programs in pldi l de t henzinger and r majumdar symbolic algorithms for games in concur pages ­ springer l m de and n z an efficient smt solver in tacas e a emerson and c tree automata and in pages ­ ieee h and m predicate abstraction for branching time complete incremental and precise in pages ­ springer h and s local for the µcalculus ­ p and d fast ltl to bu¨chi automata translation in cav pages ­ e w thomas and t editors automata logics and infinite games a guide to current research s a gupta n p c and a rybalchenko a software verifier based on horn clauses contribution in tacas s n p c and a rybalchenko synthesizing software from proof rules in pldi a r and b cook repair of boolean programs with an application to c in cav pages ­ springer o m m and s dont know in the µcalculus in pages ­ o m m and s when not is better than winning abstraction and refinement for the full µcalculus information and computation ­ a and m why a good abstraction in tacas pages ­ a m and py a new algorithm for strategy synthesis in ltl games in pages ­ springer t a henzinger r jhala and r majumdar counterexampleguided control in icalp pages ­ k n and l m de z an efficient engine for fixed points with constraints in cav pages ­ a j c c a j and g j how the bucket game and ever after mathematics pp ­ b a and r program repair as a game in cav pages ­ m small progress measures for solving parity games in pages ­ v m r and p complete functional synthesis in pldi o and m y robust satisfaction in concur pages ­ z manna and a pnueli the temporal picture theor comput sci ­ z manna and r a deductive approach to program synthesis toplas ­ d martin the of mathematics ­ er and k r apt fairness in parallel programs the approach toplas n a pnueli and y synthesis of reactive designs in pages ­ a pnueli and r on the synthesis of a reactive module in popl pages ­ acm a podelski and a rybalchenko transition invariants in lics m control rules for reactive system games in symposium on program synthesis a l r s a and v a combinatorial for finite programs in pages ­ s s gulwani and j s foster from program verification to program synthesis in popl pages ­ w thomas on the synthesis of strategies in infinite games in pages ­ m y verification of concurrent programs the framework ann pure logic ­ m t e and g synthesis of synchronization in popl i pushdown processes games and modelchecking information and computation ­ w infinite games on finitely graphs with applications to automata on infinite trees theoretical computer science ­ 