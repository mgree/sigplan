geometry of synthesis iii resource management through type inference r smith university of uk abstract geometry of synthesis is a technique for compiling higherlevel programming languages into digital circuits via their game semantic model first presented the key idea then and smith gave a provably correct compiler into asynchronous circuits for syntactic control of interference sci an version of algol affine typing has the dual benefits of out race conditions through the type system and having a finitestate model for any term which leads to a natural circuit representation and simpler correctness proofs in this paper we go beyond sci to full algol with concurrency and and compiling proceeds in three stages first an intermediate type system called syntactic control of concurrency scc et al is used to statically determine concurrency bounds on all identifiers in the program then a program transformation called is applied to the program to translate it into an equivalent scc program in which all concurrency bounds are set to the unit finally the resulting program can be then compiled into asynchronous circuits using a slightly version of the ii compiler which can handle variables used in contexts categories and subject descriptors f logics and meanings of programs studies of program structure general terms theory languages keywords automatic synthesis event logic syntactic control of interference game semantics geometry of synthesis the problem of hardware compilation digital circuits from behavioural specifications written in higherlevel programming languages turned out to be surprisingly difficult although the work of van and and page and et al promising initial results more than a later this technology has yet to enter the supported by an advanced research permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl ­ january austin texas usa copyright c acm of digital design several compilers are available as commercial products from such as and others but they all share a common providing support for handling of functions and procedures at least when compared with modern conventional software compilers the role of functions and related concepts such as procedures subroutines methods etc in modern languages and compilers is essential in several different ways through the functional interface a program will structure itself into components interact with code written in other programming languages function interface and interact with runtime services of the operating systems application binary interface the functional subset of a modern language will usually be a variant of a typed lambda calculus and can handle functions as arguments higherorder functions anonymous functions abstraction and partial application starting with algol at least in the form of reynolds such features are common enough to be taken for granted in most languages and compilers however this is not the case in hardware compilation these considerations are by the geometry of synthesis approach is concerned with this situation by compiling higher level languages into hardware in a way that is consistent with a modern functional infrastructure having functional interface capabilities the approach starts from the widely accepted premise that circuit diagrams that are graph isomorphic should be equal at the right level of abstraction and builds on the work of and and their results regarding the representation of diagrams in the language of compact closed categories function objects can be encoded in the language of compact closed categories using just a of boxes and so the first key new insight provided by is that function definition and linear application can be represented in hardware in a purely static way by an of circuits which is consistent with this discipline the second insight is that in order to compile conventional programming languages their imperative features and especially contraction which allows multiple occurrences of identifiers can be represented at the circuit level using game semantics in fact the hardware compilation process is to a reification of game semantics into hardware contribution in this paper we address what we to be a key in the approach namely restrictions on contraction in concurrent contexts we want to allow the programmer to write programs such as f xf x f x or f xf xf x however the type system which forms the basis of the programming language allows contraction only in sequential contexts hence the first term is but the second is not the programmer needs to the term by hand writing some thing like in complicated terms this quickly becomes very difficult to handle this becomes even more difficult if we want to apply this function to terms which themselves require transformation for example if applied to which needs itself to change to the original function should actually be in this paper we give a systematic method of obtaining such terms which we then know how to compile into hardware type systems in this section we will present a realistic higherorder concurrent programming language with synchronisation primitives and give several typing systems for the language the first type system is concurrent algol the most general one which is essentially the simplytyped lambda calculus with special constants for state manipulation and concurrency it represents an extension of the algol language proposed by reynolds with parallel composition and and the next typing system basic syntactic control of interference sci is an affine version of in which contraction is over function application and parallel execution sci was initially proposed by reynolds as a programming language which would facilitate correctness reasoning because interference between terms is reynolds sci turned out to be semantically interesting and it was studied extensively ohearn et al the restriction on contraction in sci makes it particularly well suited for hardware compilation because any term in the language has a finitestate model and can therefore be compiled as a static circuit and smith the third type system syntactic control of concurrency scc is a between the unrestricted and the constrained sci et al in scc contraction is allowed in all contexts but static bounds on the number of contractions in contexts are enforced through the type system in fact scc with all contraction bounds set to unit is equivalent to sci scc has been initially proposed as a framework for model checking concurrent programs because this language also a finitestate model property at all terms and this property it as a more flexible alternative to sci for hardware compilation shared memory concurrency and cannot type in sci because they require contraction in contexts but can be handled by the scc system concurrent algol the primitive types of the language are commands memory cells and expressions for simplicity we only consider boolean expressions but expressions can be added in a conceptually straightforward manner com var sem exp the type constructors are product and function × terms are described by typing judgements of the form x xk k m where we denote the set of identifier type assignments on the left by by convention if we write it assumes that the two type assignments have disjoint sets of identifiers the term formation rules of the language are those of the simply typed lambda calculus identity x x m weakening x m x y m contraction x m xy x m xm abstraction m n application mn mi i m m × product the constants of the language are described below exp are the boolean constants skip com is the only command constant var × exp com is assignment to memory cell denoted by when used in infix notation der var exp is dereferencing of memory cell also denoted by seq com × com com is command sequencing denoted by when used in infix notation seq com × exp exp is sequencing of command with expres sion denoted by when used in infix notation resulting in an expression with side effects par com com com is parallel composition of commands denoted by when used in infix notation exp exp is boolean negation or exp × exp exp is boolean disjunction if exp × com × com com is branching while exp × com com is iteration sem com is semaphore release sem com is semaphore release var com com is local variable declaration in block command var exp exp is local variable declaration in block expression sem com com is semaphore declaration in block command sem exp exp is semaphore declaration in block expression rec is a fixpoint operator local variable and semaphore binding is presented with a type in order to avoid introducing new variable binders in the language local variable declaration can be into a more familiar syntax as x in m the language is a highly expressive programming language in which a large variety of algorithms and programming constructs can be coded its operational semantics which defines the imperative and concurrency primitives in the usual way in the framework of a callbyname lambdacalculus along with a fully abstract game semantic model are given by and syntactic control of interference sci sci is the affine version of it has the same type structure as however since contraction in concurrent contexts is not allowed can play no meaningful role and can be omitted from the definition of the language the only changes as compared to are the removal of explicit contraction and a new rule for function application m n application new m n the immediate consequence of this restriction is that nested application is no longer possible ie terms such as f com com f f skip are illegal elimination of nested application means that the usual operational unfolding of recursion no longer preserves typing therefore the rec operator must be also eliminated a restricted recursion operator can be but we will not consider it here the second consequence of this restriction plays out in conjunction with the chosen types of sequential and parallel composition seq com × com com par com com com the type of seq allows the typing of normal imperative programs because contraction can be achieved via product formation terms such as cc c are possible but are not despite its restrictions sci is still expressive enough to allow many interesting programs its finite state model makes it suited for hardware compilation and smith syntactic control of concurrency scc the scc type system allows contraction in all contexts but only when static bounds on the numbers of contractions are the types of the language are given by the grammar com exp var sem n n n × if a bound in n is unit we may omit it scc types have the following subtyping relation n n n n type judgements have form x xk k m if a type assignment we define environment is xi ini i k n · def xi i k the typing rules are like in except for the management of bounds in contraction and function application plus a new rule for subtyping x m y n m contraction new x mn m xy m n n application new n · m n m subtyping m note that is in scc but the type is not the same as for cc c par par c d com par c c com c c as in sci a general fixpoint combinator cannot be typed all other constants are inherited from and receive where needed unit bound except that and are replaced by a family of constants which can accept a local variable semaphore respectively for any given bound com com exp exp com com exp exp the scc type system can be used to write a large variety of imperative concurrent or higher order programs such as and in practice the restriction is mainly because general recursion is out and in the definition of higherorder functions where concurrency bounds must be specified by the programmer without type inference the programmer needs to specify guarantees as well which is and will be also addressed in this paper consider for example a program where the producer and the consumer are given as arguments in such a program would have signature prod exp comm whereas in scc it must be given as for example prod exp comm which means that any argument consumer is not allowed to use its own argument more than once in contexts example f x com x f x com com xf x com com ff f skip com com in the above n is a positive integer constant which must be provided by the environment the user the term of concurrency bound is meant to two kinds of runtime interleaving the first is the concurrency expressed in a term such as f xf x and the second is that occurring in a term such as f f x we feel justified in calling the latter concurrent because the computations associated with the two instances of f are interleaved during execution in fact in loc it is shown how a term of that form can be syntactically apart using and sideeffects into a term of shape · · · f · · · · · · f · · · · · · x · · · which has precisely the same interleaving of effects as the original note that some terms are not for example the application of term to term above many programs have scc typing in fact all form programs and all programs with of first order or base types are scc et al lemma loc also gives a fully abstract game semantic model of scc type inference for scc scc is an type system where the assume bounds must be provided by the context but the guarantee can be computed via type inference rather than being supplied by the programmer in this section we will give a decidability result for scc type inference without loss of generality we will restrict the algorithm to higherorder closed terms typing can be determined with a variant algorithm and we assume it it is well known that affine typing plus explicit contraction is as expressive as conventional typing and we will assume our type inference algorithm uses this strategy the details of such an algorithm are standard and will be omitted we further assume that each type is with a fresh variable n as in n to form a skeleton for an scc type for instance the type com com com will be annotated as com the variables which occur in covariant positions in the type of the term are called assumes and those that occur in contravariant positions guarantees once this annotated type expression is constructed the next step is to obtain a set of numeric constraints on the bounds this is done by defining a function recursively on the derivation tree which produces a set of constraints as a result first we define the constraints at the level of the type system n n × in fig we show an example annotated derivation tree for the term f xf f x given a closed term m and its derivation tree let cm be the constraint system generated from the conjunction of all the annotations in the derivation tree for the example in fig cf xf f x is n n n n n · n n n n n · n n n · n n n n we say that a constraint system is solved for a given mapping of assumes into nonnegative integer constants if constant bounds for all the guarantees consistent with the constraint system can be found if they exist the mapping of guarantees into nonnegative integers is the solution of the system the first result of this paper is theorem for any closed term m it is decidable whether cm can be solved in which case a solution can be constructed proof this theorem is proved by giving an algorithm for solving the constraint system then showing that the algorithm terminates we start by substituting all assumes with the provided constants note that all in the constraint system have one of the following forms n n n n n n n · n n n n k k n n n n n x x the notation can be extended to in the obvious way the required constraints are indicated as annotations on the derivation rules we define the relation n n if n appears on the left on a constraint and n on the right in what follows the order of arguments to and · is irrelevant for the purpose of working out if a constraint is of a particular form the algorithm is construct the set s of solutions of the system in the abstract domain of positive integers formed by z over the equivalence relation a b a b a b defining · on this domain in the obvious way x n x n k v n n m c x n m x m c x m for all constraint systems in s repeat a replace all variables assigned respectively at with respectively b add equations n or n respectively for each such replacement c delete all of the form n · n and replace all of the form n n and n · n with nn mi i ci m m × the key rules are for contraction x n y n m c x n m xy n n n and application d construct the relation on its set of variables e repeat until is well i pick a cycle n n · · · nj n or a single variable n where n n treating it as a cycle ii if the system contains any of the form n n n n n k n n · n or n n · k where n n n are variables involved in the cycle and k is a constant discard the current solution and break to m k c n c m n b b n k · xn a xn note that the environments and in each rule above differ only in the choice of variables used as bounds iii pick a fresh variable n iv replace all occurrences of ni with n adding equations of the form ni n for each such replacement v delete all of the form n n f repeat until all of all equations are constant expressions i choose a minimal element n ii let e be the set of of having n on the lhs and which are all constants iii replace all occurrences of n on the rhs of any equation or with the maximum element of e g report the resulting set of equations and as one possible solution to the constraint system correctness the key point of the correctness argument is that at step e all remaining constraints of the form n n n and n n · n imply that n n and n n and thus n n implies that n n this has two consequences · in any cycle n n · · · nk n all variables are greater than or equal to each other and so must be equal hence step · constraints as in step cannot be satisfied and so show that the solution to the constraints in the number system that is currently being tried is impossible if the dependency is well then given the form of the in the system we can proceed to variable elimination via substitution in a straightforward way termination the algorithm contains three loops the outside loop always terminates because it iterates over a finite set and the inside loops always terminate because they always reduce either the number of variables or the number of constraints we take the empty relation to be trivially well in our running example suppose we take the assume to be n ie function f can use its argument in two concurrent contexts solving the system of constraints gives the following typing where the guarantees n n are given the smallest possible values f x com com com com this means that the term will use f in at most contexts and x in finally note that a purely symbolic solution of the constraint system which does not require the assumes given as constants is not always straightforward so types cannot always be presented as in ex the reason is that for some terms giving the type symbolically would require a large number of cases there are even terms that type in some such cases but not others one such example is the term comm com which types only if m mapping to scc using we know how to compile into hardware terms that only use contraction in sequential contexts and smith however contraction in concurrent contexts cannot be compiled and must be replaced by systematic replication of resources we do that by translating any term into another term in which all bounds are set to the unit value we call this type system scc perhaps surprisingly this is actually possible provided that we introduce new multivariate binders for variables in this section we present the translation which we call because it results in a term in which all identifiers are used sequentially first an informal introduction that we want to compile the term in our running example f x we know that if f com com then the term has type com com com com ie it uses instances of f and of x in hardware contraction is used to access to a shared piece of from several points in a client when sharing is not possible then a circuit can be replicated as much as needed we will take the same approach in the programming language by identifiers with bounds larger than the unit the scc bounds in fact tell us precisely how many instances of an identifier must be generated because the bounds represent the maximum number of identifiers used in parallel at any given moment at the level of types n becomes · · · note that the expanded type must not be × as product allows contraction this means that our argument f must be changed to have type com com com and we will need three instances of it f f f the type of x does not change but we will need instances of it x x the form of the term is an in the way of a straightforward transformation is the existence of storage types var sem which can be used from contexts for example how can the term xx x com x com be when the obvious of the body of the loop is x we can do that simply by the local variable binder itself and allowing it to bind several identifiers to the same memory location we can now define the transformation in a systematic manner inductively on the scc type derivation inferred in the previous section we denote the transformation operation by and we define type level translation as n n × × for constants we define k k except for com com com com var · · · var com com z n times similarly for the other binders we need an transformation in cases when multiple variables could be assigned different scc types a simple example is because both occurrences of g must be assigned the same scc type so its arguments have to have the same scc type as well because the second argument is transformed to the first argument must receive a dummy variable and be rewritten to the subtype construction inserts dummy variables whenever needed def m m def m m def x subtype x subtype m def x m x xn g g com n x x com f f com n g x gx com n n · n f g x f gx com n n · n n n n n · n f x f f x com n n n f xf f x com true figure annotated scc derivation tree for f xf f x n g com com g g com com com g x com x x com f com com f f com com com f g com com x com gx g com com com x x com f com com g com com x com f f x f g g com com com x x x x com xx f com com x com f f x f f f com com com com x x x x com f xf f x figure of f xf f x x subtype m def subtype subtype m ´ we define the transformation as follows x n x x x k k m m x n m x xn m x n m x xn m xm n x · · · n mi i mi i m m × m m × m m m subtype m x n y n m x xn y yn m x nn m xy x m · · · yn m n m n n n n · m n n m n · · · n n in we the last rule understand given an identifier type assignment an identifier type assignment isomorphic by to k where all the identifiers are fresh the substitution n k replaces all the identifiers in n which occur in dom with the as theorem if m is a valid scc term and m m then m is a valid scc term moreover if m is a program then m may terminate if and only if m may terminate proof the proof of the first part of the theorem is by structural induction that of the second by showing that any sequence of reductions in the operational semantics of an scc term corresponds to a sequence of reductions in the corresponding scc term and vice versa the smallstep operational semantics of is given in and and is the obvious one we do not include it here for lack of space scc and sci have essentially the same operational semantics as typing as our induction hypothesis we take the following stronger hypothesis for m a valid scc term and m m then m is a valid scc term and is with all variables x n replaced with at most n copies of xi it is first necessary to prove that for any scc type is an scc type but this is obvious from the definition of type level translation because it cannot produce any bounds greater than the base case is trivially true by definition for the second rule for the first rule the knowledge that the lhs is typed correctly implies that n is at least and thus the typing is correct via the identity axiom by definition and the use of copy of x the requirement to have at most n copies with n in the case of contraction note that n k must have the same scc type as n because it is a replacement of variables in m is n the type of m n is n etc until the type of m n n is which proves the case of contraction the key cases are subtyping and application for application observe that n k must have the same scc type as n because it is a replacement of variables in n with other variables of free variables with the m same type none by definition and share m is n the type of m n is n and so on until the type of m n n is proving that the rule creates a correctly typed scc expression correctness of subtyping is proved by induction on the ie cases in note that the the definition of on scc types with the third and fourth cases being special cases of the fifth needed to make the recursion wellfounded and thus the is is defined whenever true the fifth the case base case is true by definition and the second third and fourth cases are obviously true if the type of x is taken to be and respectively it is important to note also that this transformation is compositional on the syntax ie for any term m and context c such that cm com if m mf there exist context c such that cm com c m com soundness the following uses the operational semantics os of scc which is essentially the same as that of the obvious combination of lambda calculus simple imperative language and parallel execution and the reduction rules are smallstep and the semantics is nondeterministic because of possible race conditions by termination of a program closed term of com type m we mean ie the existence of a chain of reductions leading to skip we do not define the os for lack of space the first step of the proof is to eliminate the multivariate binders from the scc term m we do that simply by replacing all terms of form with where x is chosen fresh we can do this because of the previous result the correctness of typing the resulting term is not pure scc but it must be operationally equivalent by the very definition of the multivariate binder we denote this transformation by mf we define a logical relation m rm between scc terms such that there exist such that m mf for programs m if and only if m if and only if mf this is lifted to open terms in the usual manner ie for all command contexts c which accept a term of type and trap free variables in cm if and only if c mf we can write this because of and because there is no point in using multivariate binders in the context so we eliminate them only in the original term we on the reduction rules of the operational semantics the base cases for identity and constants are true by definition as the transformation in those cases does not change them or their behaviour the only new construct the multivariate binder has been syntactically eliminated most reductions are also trivial in fact this is also the reason why the rules of the os can be omitted because this proof is entirely parametric on them the only interesting case is function application when the function has been reduced to a normal form xm n s m nx s the term is x · · · ´ n · · · nn where each changed nk is a copy of the same term but with free variables an argument on the definition of subtype will show that it is semantically only introducing dummy variables and so that the types match then we notice that the only difference between the two is that reduction executes one reduction consisting of n substitutions whereas reduction executes n reductions consisting of one sub each the of f xf f x is shown in fig with term types omitted for brevity compilation and correctness here we will discuss compilation into asynchronous circuits using the geometry of synthesis approach consider the typical implementation of a digital a b s c the inputs are a and b and outputs sum s and carry c s a b c a b suppose that the circuit is in an initial state where a b c s and we want to change the input values to a b in a synchronous circuit the system clock has a period longer than the propagation delay of signals through and and values are only considered meaningful on the or raising edge of the clock giving them time to at the correct values of s c however in an asynchronous circuit the new input signals will propagate along the and reach the four gate inputs at different times depending on the relative delays there are different orders in which this can happen the two will see a sequence of four distinct inputs and produce the corresponding outputs before on the correct values as inputs change from to on its inputs the outputs of the and gate are the sequence which corresponds to a clean transition from to however on the gate as the inputs change from to the outputs will see the sequence before on the correct value of the circuit shows a spurious value of a socalled if this is connected to other circuits then these circuits will consider the value as a value and propagate it leading to more spurious values and ultimately a rather circuit behaviour in a this is the main problem of asynchronous circuit design and there exist a variety of theoretical and practical approaches to it event logic a particularly interesting and clean solution was proposed by in his turing lecture at the foundation of his approach lies the observation that boolean logic is not particularly well suited to implementing asynchronous circuits instead an event logic a logic of pure control dealing not with true and false but with the more fundamental notions that something or nothing the basic logical functions on events can be efficiently implemented as special or modules at the level of physical implementation an event is either a or a transition edge on a the socalled event encoding provides an function for events producing an output event when an event on any of the input ports c is the socalled a fundamental gate in asynchronous design it has an functionality on events producing an output when events arrive on both input ports events to its outputs starting with the dot select its input event to the the output according to the value of input s call which client r or r called more recently and it the matching d back to d or d as is the a b a b c a r z d xy a r d xs select true false r r xy figure logic modules for events compiling sci into event logic the game model for sci can be represented using only the call arbiter g d event logic composition of circuits is because the interaction between traces we illustrate this with the a x y z f ex pexp propagated to between the two is unsafe x the next output on y it outputs on z ay is bu interactions are by a sequence there are no safe interactions this can model of and smith of be events a · at t proved t t to on the other hand we can show that f c f behaviour as a connecting input a and output z and all interactions in the composite circuit are safe parallel and eager sequential operators raise certain technical problems discussed in and smith note that this way a x z of encoding boolean values using different ports called dual is standard in asynchronous circuit design and can be extended to integers given a set of plays p we denote closure under prefix and saturated strategies and strategies form a cartesian closed category in which i the circuit connecting the argument to the function is in loc variable contraction can only be done in a sequential the evaluation morphism the uncurrying of the identity at type setting the diagonal var var var × var is shown in fig the entire construction can be expressed in the language in the new setting we do not have contraction of of compact closed categories in a canonical way function identifiers in the syntax but the simultaneous binding of several tion is the of ports discussed earlier and free identifiers to the same memory cell amounts to the same thing in identifiers are the identity the implementation if the identifiers belong to sequential contexts a simple but useful program which illustrates the compilation this is not the case in contexts because the call of open higherorder programs is map which applies a module cannot handle concurrent request which amount to a race function f to all elements of a data structure modifying them in condition the standard solution in asynchronous design which place consider an iterator over some data structure provided with we will apply is to guard the call modules by using the following interface to all inputs such circuits are not basic event init more com seq wh seq f next ev al de ref curr fq ff ft fa ft fq figure map overall structure and implementation wt wf ok wt wf ok call call wt wf ok call rd t f c rd t f call rd t f figure event logic implementation for sequential contraction var var var × var logic but can be constructed from the way in fig we show a standard way arbiter construction due to more efficient can be designed however directly rather than from smaller martin the new multivariate binding circuit is represented in fig we will not provide implementations for noting that they can be implemented in the language using shared memory in standard ways eg the algorithm as points out the firstclass semaphore provided in the original is needed mostly for arbiter arbiter arbiter figure a way arbiter technical reasons related to and not algorithmic considerations the correctness of the compilation is as in and smith the correctness of representation of the game model in event logic theorem let m com be an scc term and k its representation correctness if k receives an input event on its q port it will produce an output event on its a port iff m terminates safety circuit k is proof the proof of this theorem is a corollary of thm in loc which is essentially proving a logical relation between the inputoutput behaviour of any circuit and the game semantic model of the corresponding term since we are still within the scc game semantic model the proof stands but it has to be extended with a new case the family of variable binders for multiple identifiers because of the type of the multivariate binder var var com com the concurrent usage of the variables does not violate the constraint of the game model def in loc the arbiter then ensures that the underlying contraction circuit is actually used sequentially because all read and write requests to the variable are the two take mutually exclusive input events therefore they are always used safely wt wf wt wf rd rd arbiter wt wf ok wt wf ok wt wf ok ok ok t f rd t f rd t f t rd t f f figure event logic for contraction in concurrent contexts this together with the correctness of type inference from to scc thm and program transformation from scc to scc thm lead to the main result theorem programs in which have an scc type can be effectively mapped into circuits example we show the compilation of three terms with identical types but distinct scc and versions the terms the inferred scc types and the scc versions are given below assuming f com com f xf f f xf x f f xf x f x f xf xf fx the compiled versions are in fig the actual circuits are inside the grey box the circuits marked fi xi f x are instances of the argument that must be supplied by the designer to create a working circuits or equivalently arguments for f x to lead to programs note the tradeoffs in the last two designs the second circuit contains two fairly expensive diagonal circuits but it only requires one instance of f and x while the third consists only of but requires two instances of each of f and x related and further work there exist other higherlevel approaches to hardware synthesis or hardware compilers based on process calculi such as van et al or higherorder structural languages such as et al these are interesting and useful but conceptually different ways of vlsi design hardware compilation in the behavioural style we are in has a substantial literature which we cannot discuss extensively some entry points to the literature are and et al this line of work is in some sense parallel with ours and focuses almost exclusively on optimisation techniques such as automated whereas we are concerned with problems of a structural nature this difference of focus is discussed extensively in type inference for sci has been studied before but for a richer version of the type system which we do not need yang and a program transformation similar in spirit with our is due to the first main difference is that every variable occurrence without contraction at all the second one is that replication of variables of higherorder type does not have to be uniform but can result in occurrences with different types the first difference is conceptually significant but technically rather minor whereas the second one is conceptually minor but perhaps surprisingly technically significant resulting in the existence of normal forms which can be but cannot be from the point of view of compiler support for separate compilation function calls and runtime services we consider it crucial to offer a consistent interface between a term and its context hence our decision also note that the soundness argument of thm is simplified by the fact that is uniform across copies of identifiers leading to a very simple inductive step in the proof however inside the term itself perhaps a more flexible approach which and linearization could be used at the of some in the algorithms even so it is worth noting that terms are somewhat and to be found in relevant programs combining with a selective form of linearization can lead to interesting optimisations techniques various performance parameters can be calculated at compiletime eg footprint number of or longest delay of an identifier makes a tradeoff between arguments to functions and using expensive contraction as can be seen in fig in this sense is the extreme scenario in which contraction is always before replication introducing a controlled form of linearization will be investigated in further implementations of the compiler finally the approach here can be extended to synchronous circuits using the round abstraction methodology for encoding of asynchronous specifications into synchronous circuits and this is work references per and hardware design in haskell in icfp pages ­ and compiling hardware in pages ­ and a impact of loop unrolling on area and clock frequency in c to compiler for in arc pages ­ r geometry of synthesis a structured approach to vlsi design in popl pages ­ r function interface models for hardware compilation types signatures protocols abs r and n on the compositionality of round abstraction in concur pages ­ model def in the arbiter then sequential contraction circuit is actually used all read and write requests to the variable are se take mutually exclusive input events always used safely take mutually always used safely always used safely x example example we show the compilation identical types but distinct scc and f x and f xf x f x f com com x f xf f x com com com com f xf x f x com com com com f xf xf x com com com com es ­ northholland d r and a angelic d r l syntactic reynolds syntactic control pages ­ applied logic a g a graph model for imperative com yang p w and r d control and of interference part a full abstraction without j c reynolds in popl pages ­ ­ 