compositional compcert gordon andrew w appel princeton university popl consist complete well easy to abstract this paper reports on the development of compositional compcert the first verified separate compiler for c specifying and proving separate compilation for c is made challenging by the of compiler optimizations such as register that introduce private memory regions into function stack frames and cs local variables which may leak portions of stack frames to other modules when their addresses are passed as arguments to external function calls the compcert compiler as by leroy et al ­ has proofs of correctness for whole programs but its simulation relations are too weak to specify or prove separately compiled modules our technical contributions that make compositional compcert possible include linking a new operational model of linking that supports strong semantic contextual equivalences and structured simulations a refinement of et als logical simulation relations that enables expressive invariants on the state between compilation units at runtime all the results in the paper have been formalized in coq and are available for together with the compositional compcert compiler categories and subject descriptors f specifying and verifying and reasoning about programs mechanical verification general terms verification keywords compcert compiler correctness introduction verified separate compilation is the process of independently translating a programs components in a way that preserves correctness of the program as a whole in the most general case a verified separate compiler supports heterogeneous source programs in which some modules are written in a highlevel source language like c while others are written in a language such as assembly a verified separate compiler in this context is one that preserves the behavior of the entire source program the c and modules when the c code is compiled separate compilation has numerous practical benefits it up development cycles by enabling recompilation of just those permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january copyright is held by the publication to acm acm calls fc gc source compositional compcert fs compositional compcert gs target figure compositional compcert source modules that have been by the programmer it enables shared compiled modules mapped at runtime into the virtual address spaces of multiple processes it modularity in the large by enabling programmers to write applications containing logically distinct translation units each composed at a different level of abstraction or even in a different programming language but perhaps equally important are applications of verified separate compilers to modular verification proving a whole program correct by specifying and verifying its modules independently with respect to the specifications of the other modules compiling verified modules with a separate compiler results in correctness not only of each compiled module but also of the target whole program linked and running on the machine in this paper we present compositional compcert a fully verified separate compiler from leroy clight language to x assembly each phase uses the exact same compilation function as compcert but a significantly specification that supports verified separate compilation of programs in contrast original specification is limited to whole programs and fails to account for general interaction that is compcert is not certified for calls to other modules especially if two modules might access the same memory locations we the correctness of such calls compositional compcert builds on work of et al which showed how to adapt compcert to support interaction between a single compilation unit and its environment under the restriction that the environment was not itself compiled the technical that enabled the adaptation to shared memory were first a novel of operational semantics called interaction semantics core semantics in et al for modeling a modules interactions with its environments and second a new proof method called logical simulation relations for proving correctness of compiler phases with respect to the interaction semantics interface supported reasoning between the source intermediate and target languages of an optimizing compiler by modeling all languages uniformly as interaction semantics also composed or which made it possible to break down the correctness proof of a compiler into proofs of the individual compiler phases original compcert was also compositional but only because memory was not observable the main of was that they did not compose it was not possible in general to infer correct compilation of a whole program from the correct compilation of its modules the reason was that like original simulation relations imposed assumptions relies on the evolution of memory over external function calls such as local variables are but did not show that compiled code preserved the corresponding guarantees this between relies and guarantees made whenever a module and its environment were both situation that occurs not only when libraries are compiled but also whenever there is a cyclic dependency between the modules of a program contributions in compositional compcert we overcome these difficulties and achieve compositionality with the following over previous work linking is an extension of interaction semantics that gives the operational interpretation of composition by abstracting from the details of how modules are implemented or even in which language they are implemented linking models the interactions of modules in different languages even those with different calling conventions structured simulations refine to support the relyguarantee relationship necessary for composition while maintaining vertical compositionality the key of structured simulations are finegrained invariants on the state between modules at runtime and a leakage protocol that ensures that structured simulation proofs respect the reachability relation induced by c pointers compositional toplevel correctness theorem is a variant of contextual equivalence between source and compiled programs in which contexts are specified semantically as nearly arbitrary observations on the memory state at external call points contexts are not limited to programs in c or x but include mathematical relations expressed in in addition to formal results that relate linking semantics structured simulations and contextual we outline the instantiation of interaction semantics to the source and target languages of our compiler clight and x and present an overview of the adaptation of the relevant proofs of the compcert phases all results in this paper have been proved formally in coq and are available along with the compositional compcert compiler itself on before with the technical details we briefly discuss some key aspects of the above key ideas linking provides a generic operator l for composing interaction semantics independent of the language level of individual modules our statements of separate compilation and contextual equivalence sections and are in the sense that they apply even to the situation in which a source program is compiled to a target program informally imagine a source program ps consisting of source modules s · · · sn each in a different language then if target modules pt t · · · tn are shown related to s · · · sn eg by n different structured simulations the results of sections and give us that the target linked program pt is contextually to the source linked program ps under certain restrictions on the si and ti explained in section for a strong semantic notion of program context of course its not clear a priori what it means to link programs at least not in any opera tional sense this question is the subject of the first part of section in principle these results mean that the target mod t · · · tn need not be generated by any particular compiler our contextual equivalence results depend only on the existence of the simulations in practice in compositional compcert the si are programs in clight or assembly while the ti are x assembly programs structured simulations from by lifting the tion to fixed environments in two steps first we impose a rely guarantee discipline inspired in part by the relyguarantee used by et al et al to prove refinement of concurrent programs on the interactions of pro gram modules the relyguarantee discipline ensures that module compilation preserves the same properties that modules themselves assume about the behavior of external functions those defined in other modules this in turn makes it possible to implement ex functions or libraries with code that is itself compiled as in figure second we the simulation relations with additional ownership data which makes it possible to distinguish memory regions that are during compilation of distinct tion units for example the portion of the stack frame for during compilation of a function af can be distinguished from the region for a second function b g defined in a distinct translation unit b a key insight here is that the invariants that apply to distinct regions of as the regions by the compiler for af s and b gs function af can write to its own but not to b gs and vice versa for b g with respect to af s structured simulations deal with this by an us vs them discipline on compiler correctness invariants each structured simulation dis the parts of the state that it the us from the parts of the state controlled by the environment the them this discipline is in some ways of and concurrent separation logic and though here we apply a relyguarantee discipline to the invariants used to prove compiler correctness rather than to the verification of concurrent programs to ensure that structured simulations validate contextual and thus are in many different program contexts we make them parametric in nearly all state updates that can occur to the them portion of the state at external call points another is a leakage protocol which ensures that the views of the memory state imposed by the compiler invariants invariant reachable give from exclusive control of all the memory ie following pointer chains rooted this condition represents the guarantee that while later af can still by changing parts of the state reachable the order in which memory regions are allocated they cannot remove these memory regions entirely eg by dead analysis the existence of the memory re in question has been to the environment similarly at external function return points memory regions reach able from the return value are in to the callers tion the rely that these regions will never later be removed by compilation of the environment our language independent linking semantics and contextual equivalence proof ensure that these conditions are in relyguarantee relation interestingly this leakage protocol much in common with the semantics of and and there and define a game semantics for a language that avoids socalled combinatorial ie syntactic restrictions on the moves of the environment by applying what they call restrictions instead these conditions which parallel our leakage conditions allow the environment to update the state in nearly any way as long as the updates are to memory regions to the environment during previous interactions with the client program this leads to a strong semantic notion of program context similar to the one we develop in section while and were interested in modeling open programs and their environments not compiler correctness in this setting we view the of our leakage conditions with their semantics as evidence of the of our leakage protocol section overview we begin by interaction semantics an operational model of module and thread interaction section interaction semantics to define the operational semantics of linked programs and semantic contextual equivalence then we introduce structured simulations in section section presents the main theoretical results vertical and compositionality and contextual equivalence for compcert section describes the compositional compcert compiler itself with a discussion of the effort required to port existing languages and proofs to structured simulations interaction semantics interaction semantics called core semantics in et al are a operational semantics of thread interaction for modeling both concurrent and programs interaction semantics from the insight that interaction between concurrent threads or between modules can be viewed as exclusively at external function call points that is via calls to functions declared in one module but defined in another this gives a compiler or weakly consistent memory model the freedom to optimize between interaction points here we give a brief overview of interaction semantics which we build on in later sections to model linking first we describe the interaction semantics protocol then we give representative encodings of interaction semantics in this case of clight and x assembly languages in compositional compcert all language semantics are encoded in this way as interaction semantics protocol in a concurrent program threads are take normal ie steps yield at synchronization points eg call to unlock and eventually halt or diverge the same protocol applies to module interactions a c program is initialized by a new thread with a function pointer to main this sequential thread which we sometimes call a core takes normal steps by evaluating main or by calling other internal functions defined in the same translation unit yields to the environment by calling external functions defined in other modules blocks until the external function returns and halts or just as a concurrent thread does at our model is designed to support concurrency although this paper does not yet do concurrency programs can be proved in concurrent separation logic and from such proofs we can derive virtual permission changes at interaction points appel et al ch programs can be as long as can be modelled via permission changes future work running interference semantics g c m type type initial core g v list v option c at external c option f × list v after external option v c option c c option v g c m c m prop figure interaction semantics interface the types g global environment c core state and m memory are parameters to the interface f is the type of external function identifiers v is the type of compcert values tion points nearly anything can happen for example the shared memory state might be updated arbitrarily by an external function figure summarizes the protocol each interaction semantics is parameterized by five types g is the type of global ments c is the type of internal or core states core states can be instantiated to eg the register file instruction stream and flags for a language like x or to local variable environment and control continuation for a higherlevel language like c m is the type of memories in the models of the compcert languages that we employ in compositional compcert m is instantiated to mem the type of compcert memories in semantic models of pro gram logics such as the verified software c appel et al m is instantiated to a stepindexed model of state used to model function pointer specifications and other higher order features f is the type of external function identifiers v is the type of values v is usually just value type the five functions at the bottom of figure together with a few axioms not shown encode the interaction protocol above new the v is a value typically are initialized with a function pointer initial while ini tial arguments to v initial core may fail with none when eg the function is not defined in the global environment ge at external core state c to determine whether c is blocked at an external function call interaction point when at external succeeds it does so with the name of the external func tion being called of type f and the arguments of type list v the after external function is used to the return value of an external call into the calling at external core state producing a new core state as result c returns some v with return value v if c is otherwise none gives the smallstep internal transition relation of the interaction semantics we use the syntax ge c m c m to denote this relation examples clight x assembly figures and give the syntax of clight and compcert x assembly the source and target language of compositional compcert respectively both languages are adapted from original clight and x and have straightforward operational semantics which we do not present here but see the code that this paper for the complete definitions here we focus on the required to turn these two languages into interaction semantics first we give the core or internal states for each language then we provide an overview of the definitions of the interface functions eg at external and after external statements s a a id a a a f a temp function call s s sequence a s s conditional s s infinite loop s continue statement switch s l s l internal external functions int long ptr · · · c types · id typing environments fi v function return type function parameter typing local variable typing t temporary variable typing f s internal fi continuations s s s fi v t safe termination sequential composition loop continuation catch switch break catch function return core states v · id loc × v addressed var environment t · id v t temporaries environment c fi s f v v t v figure syntax and semantics of clight continuations and core states appear only in the operational semantics registers ri eax integer registers rf · · · floatingpoint registers zf cf pf sf of control register state r pc ir ri fr rf st cr ra rs · r v rs register environments instructions p ri ri ri i · · · moves l id cond l · · · jumps calls id ri ret · · · · · · moves with conversion integer arithmetic etc core states d v rs normal states args in args out figure syntax and semantics of compcert x assembly core states appear only in the operational semantics types used for value are int float long or single language of expressions statements internal function definitions and external function declarations is given in the top half of figure statements s are as in compcert and rely on a language of expressions a that includes the usual binary and unary operators c controlflow constructs like while loops are derived forms not shown the semantics of clight depends on tions described in the figure and core states c which come in three normal states fi s k v t model the run states of a clight program during evaluation of anything but function calls and consist of the name of the current function be ing executed fi the function body s the control continuation and two environments v for mapping stack variables to t for mapping temporary variables models clight programs that are either internal v or external with arguments gives the state that results after returning from function calls either internal or external v is the value returned by the callee is the continuation to be executed after the call returns clight to the interface is straight forward for example here is the definition of clight after external cl after external c case c of f v case f of internal none external case of none some some v some v none first we check whether c is a with continuation if it is and the function that was being called was external then we produce a with return value whenever was none and v whenever was some v in all other cases we just the return none definition of initial core ge v v is simple since function arguments are passed not on the stack but abstractly without refer which immediately steps to the body of function fi with the initial that maps the functions the definitions of initial formal core in languages below clight follow a similar the way down to linear language which uses an environment of ab locations such as incoming parameter stack slots to represent the state of the stack and registers x assembly figure is a bit since ments must be passed concretely on the stack the same applies to language as we will see in section we use the initial core function of the interaction semantics interface to model both program initialization ie by the and the function calls that occur at function invocations if we that all modules in our program were written in x as and used eg the standard calling convention then modeling invocations would be less of an issue the shared calling convention would mean that arguments to one func tion say b g would be placed by a caller af on the stack or in registers exactly as expected by b g but the restriction to a shared calling is rather limiting we want to be able to model at least abstractly the in of modules in a variety of languages at both higher and lower levels of abstraction to this we apply a new x core transformation calling function stack growth c c c m c cm figure call case of the linking relation the outer boxes are core state c is at external calling function assuming l plt some idx and ge some bf module idx with function pointer bf results in initial core c being pushed onto the stack state v which immediately steps to a run state as a side effect of this step however we allocate a dummy arguments we store the incoming as expected by comp and gcc performs the symmetric step of arguments out of memory concretely for x modules all sharing the same calling con this modeling step does not occur on a real machine nor does the compiler output any code but by ing to the abstract calling convention imposed by initial core in which values are passed abstractly instead of in memory and registers according to a particular calling convention we gain to model the interactions of modules in a wide variety of languages not only clight and x but also x modules following different calling conventions such as eg and microsoft linking and contextual equivalence in the previous section we introduced interaction semantics as a means of interpreting the behavior of isolated modules in this section we define an abstract operator l s s sn over interaction semantics that defines the linked behavior of a set of interacting modules as given by a program p s s · · · sn as input l takes n interaction semantics each with perhaps a different global environment and core state type ie modules in perhaps different languages the output of l is a new interaction semantics p l s s sn that models the execution of the linked program by maintaining as its own core state a heterogeneous stack of the modules core states each frame on the stack corresponds to a runtime invocation of one of the modules in the program function calls result in new being pushed onto the stack initialized via initial core returning from such a function the top core from the stack and the return value into the state of the caller using after external the modules si are written in different languages whose states may have different coq types in order to treat these modules uniformly in l we wrap their interaction semantics by existentially over the core state types of each module an operation we in the type f v c type ge f v sem semantics f v c mem in this dependently typed record the types of ge and sem depend on f v and c this module is written in programming language f eg clight or x whose global variables have language v eg clight types or unit and whose core states have type c eg clight and control stack or x register we also existentially bind the global environment ge that was statically initialized for this module it maps addresses to global variables and the final component is sem an interaction semantics it defines the interface functions initial core at external etc as well as a step relation ge c m c m modules in the same language will typically have identical · · · relations specialized by different ge components that map disjoint sets of addresses to internal function bodies as opposed to external function declarations in what follows we use · to refer to the interaction semantics of modules and their wrappers the output of l is an interaction semantics in the language is parameterized by modules a map from module indices in the range n to module semantics where n is the nonzero number of translation units in the program core n pos modules in idx in core c modules idx core models the runtime state of a sequential execution thread in is the dependent type of integers in range n the idx of a core is the index of the module from which the core was initialized the runtime state of a linked program is then n pos modules in plt option in stack stack core n modules the two fields of are the procedure table function names type to the indices of the modules in which the functions are defined if any option in and a stack of we model the plt as a field in the record as opposed to deriving it from n and modules to retain flexibility to do dynamic linking in the future the stack is always nonempty all except the one are at external c pop stack at external c some figure gives the step relation there are three rules the step rule deals with the case in which the core on the call stack c l stack takes a normal internal step c m c m is the global environment associated with the module from which c was initialized in this case we just propagate the new core state c and memory m to the result state of the overall linking judgment the notation l with stack push c pop l stack updates the core state on the stack for readability we the operations required to propagate the idx field of core records the core on second rule call handles the stack is at external at the case external in c making a function call in this case we use the initial core function of the module semantics that defines function l plt some idx to initialize a new the function call initial core modules idx core state bf some c the core c is then pushed onto the stack l with stack push c l stack to become the new running core the return rule models external function returns here the core state c is with return value v l with stack push c l stack to resume execution we use the after external function exposed by the callers semantics c pop l stack to the return value v after external some v c all the inputs to l must have ge functions that map exactly the same global addresses modules that fail to declare some unused external global variables or functions can always be made to do so by safety monotonicity ge c m c m c l stack c m c m ge l m l with stack push c pop l stack m step c l stack at external c some v l plt initial core some modules idx idx ge bf v e c ge l m l with stack push c l stack m call size l stack c l stack c some v c pop l stack after external some v c some c ge l m l with stack push c pop pop l stack m return figure relation of program linking semantics l some c state c is then from the stack and state c is updated to c l with stack push c pop pop l stack the stack is an abstraction of the stack of a c or assembly program internal calls within one module do not push on our stack they transition from one core and memory to another core and memory within the same top stack element but of course this may be the of and activation records different modules may or may not share a real stack the final piece of linking semantics is the definition of the interface functions initial core at external after external and we do not have space to give the full definitions here they are in the coq code instead we briefly describe them a linking semantics is initialized initial core by a new core to handle the entry point function that was called the linking semantics is at external when the core on the stack is at external calling a function defined by none of the modules otherwise we would have initialized and pushed a new core to handle the function to a return value into states after external we the value into the core state on the stack after external c some c finally a linking semantics is when the stack contains a singleton core state c and size l stack ie the core is but has no return context contextual equivalence linking semantics leads to a natural notion of semantic context take program contexts c to be arbitrary module semantics then the application of a program context to an open program p is just the semantics that results from linking the program with that context lc p this notion of is quite general it supports the definition of program contexts in arbitrary languages eg clight and x but also it is straightforward to define an interaction semantics whose step relation is an arbitrary coq relation the code that this paper includes one such example some details related to global environments and memories contextual equivalence of two open programs ps and pt may be defined as in interaction initialized at matching entry all contexts definition contextual equivalence ps pt c lc ps lc pt the context c the state of memory and the arguments to external calls when the program with the environment to distinguish ps and pt c can eg get stuck as opposed to safely terminating at one of these interaction points if the memory state and arguments fail to satisfy a specified predicate structured simulations section showed how to define the semantics of open programs and what contextual equivalence meant in that setting now we show how to prove contextual equivalences for compcert we briefly review logical simulation relations et al and then show our new structured simulations established compiler correctness by showing that compilation preserved the protocol structure of interaction semantics using original match relations f with memory f to relate source and target states for internal execution steps they followed forward simulation proofs for external calls they that the two modules call the same function with related arguments and that the simulation relation is at return points whenever the environment provides related return values subject to a few constraints on how memory could over the external calls the two most crucial of these constraints were that in the source execution external calls did not modify any memory region the compiler to remove and that in the target execution external calls did not modify locations that were unreachable from the source memory an unreachable target location is one that does not correspond to a readable location in the source memory condition in particular enabled the proof of compiler phases such as which introduces new unreachable locations into a target programs stack frames a of simulation proofs and of was that they assumed conditions and at external calls but did not prove that these properties were preserved by compilation directly constraints and onto the simulation clauses for internal steps does not work however a compiled function should be allowed to write to its own not to those of its caller to capture the difference in perspective between caller and callee we make three to the framework first to index the match relation we use structured µ instead of original f the additional structure in µ maintains the ownership information necessary to tell a or other blocks apart from caller blocks second we the internal step relation of interaction semantics with modification effects e such that locations not contained in e are guaranteed not to be modified ie written to or by the step in question third we impose a restriction axiom onto that ensures compilation invariants depend only on memory regions either allocated by the module being compiled or to it via pointers returned from external calls the details are as follows structured in compcert memory is allocated in regions or blocks within each block memory bytes are addressed using integer offsets pointer arithmetic is allowed only within blocks memory f block for example if a variable is represented in memory on the stack and in the translation to intermediate language the compiler chooses to use a register local variable instead then we say this memory region is removed by the compiler ownership none µ type block ownership block ownership block option block × z block option block × z b b i s t b b i s t i s t f x b if b x then f b else none µx µ with x x figure structured option block × z relate source and target memories for example the memory injection that maps b to some b associates source address b with target address b structured µ figure memory injection relations with additional ownership structure they have four components two ownership functions block ownership which map blocks in the source and target memories respectively of a related pair of program states to values of an inductive ownership type and two memory and records the mapping of blocks that were allocated by the current module maps external blocks those allocated by other modules the ownership modes are for memory regions blocks allocated by the module being compiled but which been to the environment for allocated blocks that have been at a previous interaction point for blocks into µ at external calls for blocks that have been allocated by another module but not in and none for blocks that may not yet have been allocated a block is locally owned by µ in the source or target memory when b resp b is either or external blocks in source and target are those mapped by to or likewise a block is shared if its ownership is either or the visible source blocks of µ are those in the set and likewise for we use notation and to denote the blocks with and public ownership respectively we track ownership of blocks rather than ownership because the compcert languages and memory model permit pointer arithmetic within blocks once a location within a block has been made public the whole block is made public as well the data in figure are axioms that ensure proper interaction of ownership leakage and compilation these axioms not shown enforce that and operate exclusively on blocks of appropriate ownership ie only maps owned blocks to owned blocks and similarly for and external blocks and are total on their portion of shared blocks must map all blocks and must map them to blocks and similarly for and the result is that blocks which have been the environment in one compilation stage cannot be removed by later stages at interaction points between a module and its environment we the structured so that at these points the shared regions are closed under pointer arithmetic and dereferencing there are no pointers from the shared to the region we maintain as an additional invariant that the source visible set is always closed under pointer dereferencing and pointer arithmetic simulation structures figure presents the two core clauses of structured simulations those for internal ie internal steps c m µ d tm c m es c m d tm µ µ us µ separated µ µ m tm locally allocated µ µ m tm m tm c m µ d tm et get d tm et d tm es µ a et µ b bt zt bt zt et bt µ bs some bt bs zt es external steps environment vs vt m tm them separated m tm valid m tm vs vt m tm forward m m forward tm tm unchanged on b z b m m unchanged on local out of reach m tm tm µ leak in vs vt m tm c d after external vs c some c after external vt d some d c m µ d tm figure structured simulations internal and external step cases steps internal steps and for external interactions with the environment external steps the clauses for initial core at external and are not shown in the figure µ is existentially quantified there is no single definition of µ but instead one per compilation defines the laws that each such µ relation must satisfy the structure of the internal diagram which is simplified in the figure to stuttering source steps is familiar from traditional forward simulation proofs assume we are in matching initial states c m µ d tm and we take a source step c m es c m with effect es then there exists a matching d tm and structured injection µ such that get d tm et d tm and c m µ d tm clause kripke extension µ us µ says that µ may map more owned blocks than µ in order to deal with allocations but otherwise is equal to µ clauses and are side conditions that are not important for understanding the key ideas clause is the guarantee condition clause a asserts that the target effects et are contained in µ assuming that es in most compositional compcert phases the µ relation is equality up to the injection of memory regions the addition removal and merging of certain memory regions and invariants on private memory regions as in original compcert we say that values such as integers are related only if they are actually equal private private public public private public figure graphical representation of the structured injection leakage operations the black arrows are pointers in memory the white private and light gray public boxes are owned us blocks the gray boxes are them blocks the box is an memory region that was allocated by another module but not yet in the operation marks the reachable region as the operation marks as public a private region reachable from a public pointer µ in other words the compiler preserves the property of writing to and only visible locations clause b guarantees that writes to and of memory locations in the target that are not owned by µ bt µ can be tracked back to corresponding writes and in the source bs some bt and bs zt es of locations in blocks owned by the module being compiled are always permitted which enables the compiler to introduce code for variables or to add function code that registers the es and et that appear in clause and in step judgments are effect annotations for example c m es c m means configuration c m steps to c m writing to or exactly the locations es locations not contained in this set are guaranteed not to be modified we state these does not modify guarantees in this way as effect annotations in order to prove vertical composition the problem with a more extensional interpretation of effects eg as unchanged on conditions is that effects no longer decompose if a program takes two steps from m to m with effect set e and from m to m with effect set e with overall extensional effect e it may be the case that e e e if for example the second step a value that was by the first step decomposition is used in the internal step case of the proof that structured simulations compose we track only write and free effects and not read effects because compiler correctness invariants do not in general depend on which locations another module merely reads proving more general program refinements eg between multiple implementations of an adt or that the compiler does not introduce additional memory property useful in security contexts would most likely require a generalization to read effects the external step diagram the bottom half of figure it relates an at external configuration pair c m µ d tm with the after external configuration pair c m µ d tm that results from making an external call the basic premise is for any return values vs vt return memories m and tm and structured injection satisfying the listed conditions its possible to vs and vt into states c and d resulting in the new states c and d which match in µ m and tm c m µ d tm the them is dual to the us condition used in the internal step diagram it says that may reachability reach mem set block list block set block reach m r nil r reach m r b z l b b reach m r l m b z readable z mb z b z reach m r b l b reach m r l µ b µ with b if b b then else µ b i s t µ b µ with b if b b then else µ b i s t leakage leak let out ls µ vs vt m tm reach m vs µ lt µ reach tm vt µ µ in exports µ ls lt leak in µ vs vt m tm let ls reach m vs µ µ lt reach tm vt µ µ in µ ls lt figure reachability and leakage map more external blocks than in order to deal with allocations performed by the otherwise is equal to the other conditions are adapted from compcert and fol low in our coq proofs directly from symmetric conditions on the relation and the internal step diagram the conditions listed in together compose the structured simulation rely the predicate unchanged on u m m that memories m and m are equal same contents and per at the locations in set u in the source execution we use unchanged on b z b m m to en sure that m and m are equal at locations in the private blocks of the injection which is built from µ by updating leakage information as described below the condition unchanged on local out of reach m tm tm says that tm and tm are equal at owned target locations that either do not to readable source locations or are mapped from private source locations by using unchanged on here we the conditions of the rely the structured injection is built from injection that originally related at external states c m µ d tm using the leak out function depicted in figure and defined in figure the idea is leak out leaks to the public other mod from blocks that were previously shared µ this is a condition it says that structured simulations may not assume anything about the contents of blocks the unchanged on conditions that form the rely satisfied by the environment apply only to private blocks the functions reach and reach defined at the top of figure calculate the transitive closure of the points to relation on compcert memories in the definition of leak out we use the auxiliary function export to update the ownership func tions of an injection µ to map blocks in the reachable set to the leak in function used to define µ at the end of the external step diagram plays a role analogous to that of leak out except that here we are into µ new blocks reachable from the return value vi of the external call likewise the import function is almost equivalent to export except that it updates the ownership functions of a structured injection to map the block set b to as opposed to restriction the final consistency condition is the simulation relation µ is independent of the and none blocks this condition is used eg in the proof of vertical composition transitivity theorem technically we enforce by requiring that µ be closed under restrictions to of the visible blocks an operation defined in figure as µ x with x a block set µ x denotes the structured injection obtained by restricting the maps and to the domain x the closure condition says that if c m µ d tm then c m µ x d tm for any block set x that contains at least and is closed under pointer dereferencing and arithmetic in m main results compositionality and contextual equivalence vertical composition transitivity one can compose compiler phases figure the proof that structured simulations compose follows the same outline as that of et al as discussed in section the proof of transitivity of the diagram is dependent on our treatment of effect annotations proving transitivity of the clause lower half of figure requires the construction of an after external memory m in the intermediate execution between source and target theorem transitivity let l l and l be interaction semantics if l l is a structured simulation from l to l and l l a structured simulation from l to l then there exists a structured simulation l l from l to l composition linking the second kind of compositionality is we would like to know that composing the simulation relations established by independently compiling the modules in a program results in an overall simulation between the linked source and target programs we give the theorem statement first then explain some of the in particular the restriction to source semantics which enforces the conditions corresponding to the structured simulation guarantees of section and to valid target semantics a technical property related to the compcert memory model explained below theorem linking · if ps s s · · · sn is a program with n translation units each of which is and · ps is compiled to pt t t · · · tn possibly by n different compilation functions such that si ti for each pair and each of the ti is valid then · there is a simulation relation l ps l pt between the source and target programs that result from linking the si and independently linking the ti the in the theorem denotes forward simulation on whole programs whole program simulations are as in figure but without clauses in the internal step diagram without clauses for at external and after external and without effects as corollary will show establishing is sufficient for proving contextual equivalence of open programs a valid semantics is one that never stores invalid pointers into memory invalid pointers in compcert are those that refer to memory regions that have not yet been allocated pointers are never invalid all compcert x programs are valid in this way validity is required in the proof of theorem to maintain the invariant that the set of valid target blocks is semantics the restriction to semantics figure is best motivated with an example consider the program module a void void x void int a if a ha g void module b g g popl ret in which af calls assembly function bg passing no arguments the bit is bg all it does is write the value into memory at address which just happens to be the address at which local variable a is allocated on the stack in windows now imagine we compile module a through a compiler phase like dead code elimination which results in a which was previously addressed in dead code if and therefore being removed from memory since is as address before dead code elimination the program above does not get stuck the write succeeds to location a without significant effect after optimization the program will fail probably because the write to a now the return address stored in gs stack frame this program succeeds when compiled with gcc o but under gcc o this is not a bug in gcc instead it is evidence that the gcc developers agree with us that module b is an program context one might object that if is actually not dead code because it results in a being which in turn results in the safe execution of the overall program but that way lies the point of a compositional compiler is to enable local modular compilation which should depend only on analyses correctness of optimizations like dead code elimination should be independent of the larger program context in which a module is executed the challenge then is coming up with a characterization of the source modules s s · · · sn that does admit linking as in theorem we do this in general for arbitrary interaction semantics by observing that the write to is not because it goes wrong though it will lead to going wrong in most program contexts but because its a write to a location that the assembly program have known about in the first place put another way address was not reachable via pointer arithmetic either from gs initial arguments from global variables or from the return values of external calls g may have made previously this writes or to locations that are not the analogue of the es µ in clause of figure but stated as a property independent of any particular structured injection µ we formalize the notion of a semantics that respects this characterization of visible locations as an extension of interaction semantics called semantics defined by the existence of an invariant r satisfying the laws in figure from the perspective of compiler correctness proofs the it might seem to say not reachable via pointer arithmetic in the context of an assembly program since in most assembly models the entire address space is reachable here we mean not reachable in the instrumented semantics of x assembly used by compcert in which memory is allocated in blocks as in clight and pointer arithmetic is invariant r c mem set block prop initial core e c step roots ge g b set block ge b r c m b ge c m e c m e reach m roots ge b r c m reach m m m reach m roots ge b after external at external c some v after external c some c let b case of none b some v v nil b in r c m b figure semantics maintain an additional internal invariant r on states c memories m and block sets b that satisfies the laws above the definitions are parameterized by types g and c by a global environment ge g and by an interaction semantics of type semantics g c mem that defines step relation and functions after external and initial core at external and are restriction to contexts is what enables program transformations it would be unsound for example to remove a dead memory allocation if the larger program context on it as in the example program above the r invariant of semantics over core states of the argument semantics c c the memory m mem and a set b that records the blocks exposed to the semantics at interaction points via pointers in the initial argument list in the return values of external function calls and by local allocation we use the notation for semantics to denote a semantics sem that such an r the roots of a block set b and global environment ge are the union of b and the global blocks of ge the conditions of semantics are those that characterize the step relation clauses and in particular clause which ensures that semantics satisfy the structured simulation guarantees of section the step relation of the underlying semantics with the additional condition that the effects e produced by the step above clause are a subset of the locations reachable in m from the current roots clause asserts that the invariant can be after the step for the blocks reachable in m from newly allocated blocks m m if any as well as from the blocks that were originally reachable in m reach m roots ge c this last condition ensures that the reachable set grows at each step by not locations that were previously reachable the other interface laws modify b as specified above for example the clause for after external asserts that r can be for b equal to b union the blocks exposed by the return values of external calls v nil initial core asserts that the invariant can be established initially with b equal to the blocks exposed in the initial arguments at external and not shown assert that the arguments to external calls and return values respectively are not undefined as a corollary of theorem we get the following contextual equivalence result when the source modules are stated in terms of a variation of definition in which contexts satisfy a few additional properties definition contextual equivalence ps rc pt crc c c c valid c safe lc ps lc ps lc pt corollary simulation implies contextual equivalence let · ps s s · · · sn and · pt t t · · · tn for source modules s s · · · sn and valid deterministic target modules t t · · · tn if for each i si ti then ps rc pt in the above we assume closing contexts c those that do not themselves call external functions not defined by any of the modules callbacks into ps and pt are permitted c must also be valid safety of the source linked program and determinism of the target modules are required to prove the backward direction of the equivalence the forward direction holds without these assumptions the c c condition says that c with memory if c is initialized twice with injected arguments both executions either go wrong or with injected results although this condition follows directly from the form of theorem it is strongly motivated we should not allow contexts to distinguish source and target programs based solely on of memory blocks exposed to the context pointer arithmetic is not allowed between blocks only within blocks the consistency conditions on structured and simulations that we described in section mean that in the proof of c c the context may assume that all public blocks by the program are mapped from source to target they are never removed during compilation of the program nor is the reach closure condition imposed above an proof obligation one can show for example that all clight programs satisfy the restrictions imposed in figure theorem safe clight programs are there exists an r specialized to clight states c and the clight step relation that satisfies the laws given in figure the proof of this perhaps theorem relies on the fact that clight programs never nonnull pointers eg by an integer to a pointer and then dereferencing it even in standard c an integer to a pointer or vice versa is only implementation defined except when the pointer is null see eg the c standard c the main difficulty in proving theorem and corollary is in a simulation invariant to relate the runtime states of the linked programs ps and pt the situation is presented in figure in the source linked program we have a stack of core states growing with c in callee position with respect to a direct or indirect caller core c which may be implemented in a different language we must relate this stack of to the corresponding stack in the target linked program we use µ to denote the structured simulation that relates the c and d and to denote the injection that relates callers c and d for simplicity we the memories for callers the memory at the call point is existentially quantified a caller core may be a callee with respect to another caller higher on the stack growth source stack target stack c d µ cd figure representation of the linking invariant the inner white boxes are core states source core c and target core d are at the bottom of the related by structured injection µ memory is c and d are caller related by the key condition is to ensure that blocks labeled as or by callee µ are always labeled as public by caller µ from the fact that source modules are es reach m roots ge b we then can show that the memory effects of the running callee core at the top of the are confined to owned and blocks this implies that private caller memory regions in which are disjoint from the blocks marked as public by remain a difficulty here is how to relate the root sets of source modules to the visible sets used in the simulation relations we do this by maintaining the following two invariants roots ge b µ reach m µ µ invariant says that the root set of the source semantics is a sub set for of the visible source blocks in µ this incoming block set reach m roots is maintained at external function calls and returns condition which we maintain as an invariant of all structured simulations says that the visible set is closed under reachability these two con plus and monotonicity of the reach relation imply that es is a subset of µ this fact together with condition above is sufficient to prove the unchanged on relies of figure at the point at which the running core returns to its calling context compositional compcert the phases of the compositional compcert compiler are shown in figure with optimization phases in gray the main differences with standard compcert are we compile clight to x assembly whereas standard compcert a slightly higherlevel language compcert c to multiple assembly targets x and arm and standard compcert includes three additional optimizations common subexpression elimination constant propagation and function inlining the adaptation of their proofs is work the toplevel theorems we prove are the following inlining which merges function stack frames requires a slightly more general simulation relation than that of figure without separated we have done this generalization in a way that supports inlining and all previously proved phases but have not yet completed this proof in coq theorem compiler correctness let compcert denote the compilation function that the phases in figure in order if some t for clight module s and x module t then s t proof by transitive composition of the simulation proofs for the individual phases in figure using theorem corollary compositional compiler correctness let s s sn be a set of clight modules such that some ti for each i then s s sn rc t t tn proof by corollary theorem theorem and determinism and validity of compcert x assembly the process of making the proof of a transformation phase compositional typically as follows we refined internal notion f and the auxiliary relations for activation records frame stacks etc to relations µ indexed by structured in particular because external function call interactions may introduce memory regions related by memory in compositional compcert the simulation relations of passes that were previously proved as memory equality or memory extension phases had to be as injection phases particular care was needed to assign correct ownership and visibility information to memory blocks in addition we had to add to each µ relation the clauses is closed under reachability and the relation µ is closed under restriction to the visible set µ to ensure that global blocks were always mapped by each compiler phase we treated them as to all modules while the addition of these extra invariants in a mostly uniform manner across all phases the refinement of f to µ was due to the considerable internal differences between the various compcert passes an issue that required special attention was the treatment of compiler here we had to the distinction between on the one hand bit and functions are typically and should never yield at external despite being as external calls by true external functions which are never on the other to this distinction we modified the definition of the language to ensure that the calls to bit were all in all the compcert phases in figure to structured simulations took approximately much of this time was spent at the boundaries of the proof updating the interfaces that connected our linking semantics and proofs to structured simulations in general the time as as the project on the first few phases of the compiler took a few to a per phase whereas the later phases much more quickly a or two per phase this was due in part to greater with compcert but also to the of a library of generalpurpose lemmas that will remain useful as we continue to adapt the last few optimization passes as another measure of effort we give for representative files in the development figure proofs of individual phases new were on the order of by contrast compcert s old proofs are about × smaller the increase in proof lines is due mostly to the additional invariants we prove however we have not yet applied much proof automation at all so we believe there is room for improvement the increase in specification size is due to the use of duplicate language definitions in order to add effects to the compcert languages we duplicate the step relation of each semantics once with and once without effects then prove that the two semantics coincide this results in specification counts that are larger than necessary clight cminor selection rtl ltl linear csharpminor allocation x assembly figure the phases of compositional compcert boxes in gray are optimization passes outer boxes indicate source languages compiler phases theories structured § structured § transitivity § linking § § old new proofs old new figure lines of code for selected parts of the development related work compiler verification is one of the big problems of computer science as by the large body of research it has in the years or so since and and we cannot hope to give a complete survey here see instead we focus on the most closely related work verified compilers moore moore was one of the first to mechanically verify a programming language implementation a compiler for a language called the most wellknown work in this since moore is compcert c compiler in coq leroy upon which compositional compcert is based has also built verified compilers in coq first from lambda calculus to assembly language and then later for an impure functional language but both and compilers were limited to whole did not provide correctness guarantees as we do in this work about the behavior of separately compiled programs compositional compilation benton and were two of the first to explicitly do compositional specification of compilers and lowlevel code fragments first for a compiler from a simply typed function language to a variant of machine benton and then for a functional language with polymorphism benton and benton and work was followed by a string of dreyer and that in refinements of the basic techniques stepindexed logical relations and the refinements included extensions to stepindexed kripke logical relations for dealing with state in the context of more realistic mllike languages and dreyer and more recently to relation transition systems et al and the related parametric tions et al demonstrated that it was possible to do reasoning in the style of kripke logical relations and state transition systems parametric bisimulations refined by removing some technical restrictions both parametric bisimulations and compose like our structured simulations but unlike kripke logical relations although the context of their work is different some of the techniques used by benton dreyer and their draw interesting in our own work our us vs them protocol is at least similar to the local vs global knowledge distinction made in one difference is we distinguish between local and external invariants on the state shared by modules whereas in the local vs global distinction is really about different notions of term equivalence also our them invariants which one structured simulations view of the memory regions allocated by external not quite global in the same sense as et als global knowledge perhaps more one can view interaction the structured simulations that are indexed to interaction an analogue of the type structure used to index standard logical relations but here applied to imperative languages with type systems c x and the other languages of compcert as in kripke logical relations structured simulations use possible worlds to model eg memory allocation an alternative to interaction semantics is semantics ahmed and which combines several languages of a compiler into a single host language via syntactic boundary casts in the of and findler and findler this makes it possible to state the correctness of a separate compiler as contextual equivalence in the combined language as and ahmed have recently done for a compiler from system f with existential and recursive types and ahmed but where and ahmed define contexts syntactically as terms in the combined language we define contexts semantically as interaction semantics variation of and approach replaces explicit boundary conversion with conversion expressed as terms of the combined language but considers only a single transformation closure conversion recently wang et al wang et al built a compositional compiler from a restricted language to in contrast to our work compiler correctness in wang et al is to the of the program logic concurrency et als work et al on verifying concurrent program transformations inspired our use of a relyguarantee discipline but the complexity of stack frame management and block coalescing in compcert made it to apply their ideas directly in our setting and and which we mentioned in the introduction used relyguarantee invariants on auxiliary state to verify concurrent programs such as parallel increment later work by et al extended the techniques to support verification of finegrained concurrent programs et al these invariants made their proofs robust to the thread structure of the environment our us vs them invariants serve a similar prevent structured simulations from being sensitive to the exact composition of their environment other modules verified a compiler for multithreaded java et al built et al which adapted correctness proofs to in order to reason about compilation of c code framework models optimizations as rewrite operations on parallel control flow graphs specified using temporal logic formulae while all three of these projects are there are some with our work for example both and lift program refinements from individual threads to whole programs as we do for interacting modules under certain noninterference conditions on shared state a difference from our work is that and state the noninterference conditions as invariants our composition results instead rely only on a characterization of noninterference in the form of semantics that said it would be interesting to investigate whether the compositional compilation approach we could be applied to compilation with weak memory models conclusion compcert is one of the great of formal methods for software verification but as the authors of compcert put it formal guarantees of semantic preservation apply only to whole programs that have been compiled as a whole by the compcert c compiler leroy we overcome this restriction acknowledgments we thank the popl anonymous reviewers the members of the princeton and yale pl groups ahmed robert leroy and david for valuable feedback we especially thank for numerous this material is based on research by under agreement number fa the us is to and for purposes any copyright notation the views and conclusions contained are those of the authors and should not be interpreted as necessarily representing the policies or either expressed or implied of or the us references a ahmed and m an cps translation via semantics in icfp the th acm sigplan international conference on functional programming a w appel r a l j g s and x leroy program logics for certified compilers cambridge n benton and ck and compiler correctness in icfp the th acm sigplan international conference on functional programming n benton and ck realizability and compositional compiler correctness for a polymorphic language technical report microsoft research l g r and a w appel verified compilation for c in esop the rd european symposium on programming c c draft standard april a a certified typepreserving compiler from lambda calculus to assembly language in pldi programming language design and implementation a a verified compiler for an impure functional language in popl the th acm symposium on principles of programming languages m a compiler verification a software notes d and n a game semantics in the th conference on the mathematical foundations of programming semantics c d dreyer g and v vafeiadis the of bisimulations and kripke logical relations in popl the th acm symposium on principles of programming languages c g d dreyer and v vafeiadis parametric bisimulations a logical step forward in popl the th acm symposium on principles of programming languages ck and d dreyer a kripke logical relation between ml and assembly in popl the th acm symposium on principles of programming languages x leroy formal verification of a realistic compiler communications of the acm ­ x leroy the compcert c compiler r and a auxiliary state for concurrency in popl the th acm symposium on principles of programming languages h x and m fu a simulation for verifying concurrent program transformations in popl the th acm symposium on principles of programming languages a a typesafe model of java concurrency language virtual machine memory model and verified compiler phd thesis july w e specifying and verifying program transformations with phd thesis university of illinois j and r b findler operational semantics for programs in popl the th acm symposium on principles of programming languages j and j correctness of a compiler for arithmetic expressions mathematical aspects of computer science m compiler correctness via contextual equivalence thesis carnegie mellon university may j s moore a mechanically verified language implementation journal of automated reasoning ­ a r i and g a communicating state transition systems for finegrained concurrent resources in esop the rd european symposium on programming j t and a ahmed verifying an open compiler using semantics in esop the rd european symposium on programming j v vafeiadis f z s and p sewell a verified compiler for concurrency j acm p wang s and a compiler verification meets linking via data abstraction in oopsla proceedings of the acm international conference on object oriented programming systems languages and applications 