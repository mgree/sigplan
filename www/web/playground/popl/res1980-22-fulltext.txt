as a language principle alan demers james computer science department cornell university new york the problem expressive of languages is that their parts have so little john in his recent turing lecture john a argument for the proposition that programming languages are in claims this to be the develop ment of algollike languages must lead to this state because it begins from tions a less interpretation of the of language design is that we still do not understand the fundamental principles that should guide our design efforts the machines we use limit our results but our has far greater effect as evidence to support this we can the difficulties of building successors to algol and pascal both languages permission to copy without fee all or part of r or r are copies r full rt o to prior machinery to copy m requires or specific permission a fee and have been as but it has proved extremely they right difficult to capture just thus hoare has what that j was not only a great improvement on its predecessors but also on nearly all of its suc a the recent that the same may ada design pascal suggests in this paper we expand on an idea of to develop an important principle of program ming languages we argue that application of this principle is an effective tool in understanding problems of programming language design in particular allows us to point out many of the and in existing languages s we can know what not to repeat and provides a framework for the design of languages or language families that have wide variation in their parts below we present the principle of type this work supported by national science acm foundation grant completeness and its for language for each type in the type structure of the design we then discuss some common examples of incompleteness found in existing algollike languages and we end by presenting the type structure of the programming language russell which has been designed by the as we show the flexibility provided in russell by the combination of a small rich type structure and assertion of inherent of languages language it ie to write a expres sion in the language having this type any expression can be parameterized with respect to any free name having any type in the expression to yield a function of an more complex type implies that func tions must be able to have parameters of any type and to produce results of any type probably the simplest e of a type l complete language is tbe typed lambda calculus the framework of the lambda calculus consists of to design a language with many parts it is necessary first to design a language the type structure grammar given by the following simple framework that specifies how the parts must behave and how they may be composed the idea of type is to require that this framework consist of a type structure which specifies the legal uses of names or what kinds of parts can be later added and a very few uniformly applicable composition rules which specify meanings of composite expressions the and in terms of the type i n b type type and the for application and lambda tion the only composite expressions in the language this framework covers the entire language types and meanings of their components we will say that a language is if and only each lambda expression has a type in the type structure given above if the following three conditions hold each name ie identifier or operator sym and each expression in the language has a type the type of any composite expression is from the types of its components the type of a name or expression may not depend on the context in which the name or expression appears for example the type of the of composite expressions are com from the types of the components eg the operator and operand of an application without regard for surrounding context and we can always produce a more complex expres sion of higher type by lambda abstraction of any free identifier an identifier may not depend on whether it appears on the left or righthand side of an in fact languages this framework describes that differ in the choice a family of of base types assignment statement and constants that are built in requiring a language to be ensures two basic properties of its design it that and application are universally applicable in the language any name can be a parameter a ter can be of any type and an argument can be con that can be bound to any parameter it is important not to place any constraints on the forms of parameters and arguments because is the fundamental tool in any program ming language for providing parts in a program if we want to use the same program for many different values of x we can do so by making x a parameter guarantees that this can always be done no matter how x happens to be used in the program secondly allows us to define all forms of declarations in terms of the basic binding semantics ensures that declaration and are equivalent in their scope of usage any name that can be declared can also be a parameter thus by principle of correspondence which states that and declaration are semantically equivalent we can capture all the naming tions of the language by a few basic notions without regard for what is being named the observation that allows a major simplification in describing the naming rules of a language points out a serious fault in the requirements the requirements clearly state that the language should not con unnecessary yet type completeness is specifically out by require ment d procedures functions types labels exceptions conditions and statements shall not be computable as values of expressions or be usable as parameters to procedures or and in ada which require ment d exactly one finds different forms of declaration each with slightly different syntax and slightly different meaning in russell by way of contrast the syntax and semantics of su declarations can be described in less than one page of text with a single syntactic rule and semantic interpretation an important point to be drawn here is that simplicity is sometimes better provided by gen rather than by restricting as has been done in ada and placing bounds on the legal forms of parameters prevents us from giving one uniform semantics for two obviously related mechanisms and declaration moreover as we discuss below lack of type completeness also forces the introduction of mechanisms to handle other cases where common combining forms would suffice by itself does not a useful programming language even though the typed lambda calculus is the simplicity of its type structure makes it able for many purposes however the idea of using the type structure of a language as its framework suggests a novel approach to language design instead of designing by adding new features we should attempt to make systematic to the underlying type structure and to add new general combining forms only when necessary below we discuss two obviously needed additions to the simple lambda calculus type structure given above in both cases we show that the simple measure of the type structure allows a few generalpurpose mechanisms to provide more facility than many language features l p structure one of the most obvious but least under properties of algollike languages is that programs refer to variables names in a program can be bound not only to values but also to holding values while the variable with a name cannot be changed the value held in tbe variable can be changed during tion of a program as variables are fundamental to our understanding of algollike languages it seems natural that the type structure of such a language should incorporate the notion of vari indeed all algollike languages partially incorporate variables into their type structures they make between variable and value parameters and between left and righthand sides of assignment statements however our notion of requires more than this in par functions must be able to produce vari ables as results as well as being able to have variable arguments this idea first one as probably unnecessary and possibly but as lan suggests there seems to be configuration ie composition however it might seem when that will not turn up quite naturally pg and we find that several features of existing languages turn out to be nothing more than weak special cases of this more fundamental facility the first of these was by in his discussion of algol name parameters name parameters in algol behave like variable returning type how ever the analogy fails for two reasons procedures are not part of the type of algol ie they can not be written by the user and because of an property of the algol syntax procedures are not legal arguments to procedures an occurrence of pn as an argument is taken as were the analogy exact the ability to pro as arguments in algol would the need for callbyname one of of existing languages is the introduction of mechanisms our contention is that such mechanisms are of the language designers not of the basic properties of machines secondly failing to incorporate the notion of variable into the type structure makes it necessary to introduce special composite of names to provide for common operations like field selection and if variables are part of the visible type structure ie if it is possible to write func tions then no such special forms are needed the mechanism any language must provide to apply an operator to an operand suffices to handle this additional case this is one of the aspects of algol which allows reference returning functions but treats them differently from component selectors the revised report does not describe re of x as the application of the func tion function re to the reference xn but says instead that x must have a re aside from the unnecessary use of special syntactic forms the failure to allow variables as results of functions also forces the introduction of special features to handle cases where it is necessary to modify the means of accessing a variables components eg the array feature of algol or ada to illustrate this idea consider the following russell program to assign zero to each element of an array x n sub i m the parameters of the procedure include a variable to be modified and an infix function which produces an integer variable when applied to a t variable and an integer index value within dimensional the procedure x looks like a one array to access one of the components of x we apply the sub function with a single integer argument however an array argument actually provided to the procedure could well be a array ie an array from which components would normally be extracted by using a operator of a different type the declaration of the parameter x says nothing about what kind of an array it is or even that it is an array for instance we could use this procedure to zero only the diagonal elements of a two dimensional array by passing to the procedure the following operator m x w t i y integer w integer x sub where we assume the existence of an operator named sub that takes a type t variable and two integer indices as arguments and produces an integer vari able as a result obviously to make full use of this sort of flexibility it is to make the array type itself a parameter of the pro so the use of the procedure is not limited to arrays of a single type this point is discussed further below by allowing the user to apply any of the gen combining forms to compose functions a language can provide a smaller but much richer set of selectors than would be allowed by any special array slice mechanism thus by the type structure of a language to include a treatment of variables we can build a simple language with a range of flexibility than much larger languages with many special features and this simplicity benefits both the user and the language designer the user has fewer new constructs to and the designer knows that only a few combining forms will suffice thus his concern about what should or should not be added to the language this idea of using func tions as the means of manipulating complex data structures appears in the language as reynolds notes approach ensures that any process which accepts some data structure will accept any logically equivalent structure regardless of its internal pg above to make full advantage however as noted of this functional data approach for statically typed languages it seems necessary to allow types to be legal parameters but our preceding discussion of us to the same conclusion if we can give a name to a type then we must be able to make that name a parameter a data it has become to design languages with data type definition facilities to simplify the creation and manipulation of complex data structures recent work in programming eg abstract data has led to increased concern about the design of such in the eg or the data type definitions have become rather complicated in form and meaning however looking at the data type definition facilities of most languages in terms of type completeness shows that they are not integral parts of their respective language common characteristics of the treatment of data type definitions shows the nature of the special status they are most languages give a special for the interpretation of type declarations rule in algol or for example a type identifier is taken as a for its definition ie type declarations are treated as a syn tactic shorthand but this is the only sort of definition for which this rule applies the algol revised report describes the action performed and the result for every form of tion except for a mode type declaration which involves no action no result pg also languages that allow type tions do not allow type parameters thus even though it is possible to introduce new type in a program it is not possible to a program with respect to one of these type identifiers recently clu and ada have to this however their features fail to allow the generality allowed by in each case type parameters are viewed as a compiletime feature ie aa using the simple meaning of type declaration used in pascal or this is most obvious in the explanation of the ada feature however the more ambiguous descriptions of the meanings of types in clu and the same treatment of type parameters treating type parameters as macro names fails to generalize naturally we have no notion of the meaning of a construct that has a type parameter only a meaning for the application of a particular data type argument to the construct so we have difficulty interpreting how we could make type parameterized constructs themselves parameters as is in a language in this case a means of the success can serve as of a language design effort demands that a data type definition facility should use the same rules for defining the meaning of names as any other definition in the language the benefits of ensuring the of treatment of data type names are exactly those above for languages the parts of a program or programming language would now include even the data types of the language and the same general combining forms used to pro other sorts of values could be used to pro types thus for example there would be no need for special forms of parametrized data because the general form of functions that yield types would suffice and most probably would provide a richer form of expression below we present the type structure of the programming language russell which has been designed by the authors demers in russell the type structure includes both of the extensions we suggested above variables and data types are both incorporated into the russell notion of and the language framework uses only a few basic combining forms even though the russell framework is small the language is able to many extensions and provides more expres than many much larger algollike languages k framework russell is a algollike pro gramming language with a simple but extremely rich framework each name in a russell program ie each operator symbol or identifier has a type or in russell terminology which is an element of the following grammar signature i i opera id l signature signature id id l l where a simple signature specifies whether the name is a value or a variable and gives its data type a is any denotation ie expression having a signature a procedure and function signature specifies the names and signatures of the parameters and the result sig nature of a function a type signature specifies the names and signatures of the operations the type the remainder of the includes combining forms of russell framework application and abstraction denotation into a function statement into a procedure both to turn a and to turn a conditional evaluation selection of a component of a data type and to turn a set of operations into a data type as discussed below in each case the meaning of a combining form can be given independently of the signature of the result produced by evaluating the form or of the signature of any free identifier appearing in com denotations thus the framework of russell is really quite small nevertheless the framework is rich due to some of the ideas we have discussed above of primary importance in the russell type structure is the fact that functions can have parameters of any signature and can produce results of any signature thus field selectors in russell are functions that take variables as arguments and yield variables as results parameterized types in russell are functions that yield types as results and may take types as arguments also the effect of lambda calculus callbyname can be achieved by using functions as ments ie functions with signature russell passing uses callbyvalue as the parameter mechanism of the language framework this same binding mechanism is also used to describe the meaning of all declarations in a russell program the generality of the function mechanism also makes possible the treatment of data types used in russell a data type in russell is a set of operations that provides an interpretation of values so the signature of a data type is simply the set of signatures of the operations the type the of functions in russell allows us to specify the meaning of such primitive operations as taking type tn and the value of a variable of a new variable of type t as functions that are components t with signatures of the data type and t respectively additionally the structured types of russell include selector functions as part of their meanings as was discussed above thus the only new notion introduced by data types is that of a set of operations together as a data type the operations them are ordinary in their signatures and are treated no differently from operations that happen not to be part of a data type indeed in many cases the decision to make an operation part of a data type is purely a matter of the fact that data types in russell are integrated into the signature structure of the language in this straightforward manner has several important consequences it makes the rules by which type correctness is determined simple to present even though russell places no restrictions on the sig nature of any parameter of a procedure or func tion this point is discussed in much greater detail in the other paper by the authors in this proceedings also the nature of data types makes it possible to leave out of russell many features that are commonly built in to algollike languages they can easily be provided by the user as he fit lie give two simple examples first we need not introduce arrays in russell because they can be easily com from arrays a two dimensional array that is an array that is sub as in russell applications a sub i j can be produced by first of the array composing function provided eg array array in i and then by the operator of the resulting type to he the composition of the operators of the array types that were composed thus the user of the resulting type would write instead of a sub i j a sub i sub j this is not a matter of syntactic shorthand as it is in pascal of using the basic tion operators of the language to produce exactly the form of expression that the user this same mechanism also allows a user to define a operator for a one dimensional array which allows a simple tion of structures and hand matrices secondly unlike all other algollike languages of which the authors are aware russell requires no special syntactic form or semantics interpretation for variable declaration cation each data type in the language and provides a function new with signature that returns a ew of the type so one declares new variables simply by binding a name to the value of an application of new this function can be composed with any of the combining forms to produce new useful functions that are not built in for instance the function xc n integer w j x b xn result x q integer performs allocation with initialization note that demands the existence of functions with signatures like that of new and these functions have a natural interpretation a more fundamental consequence of the mi ty of naming conventions in russell is that russell provides a particularly view of data types in a russell program any two tions with the same signature and the same meaning can be used in u contexts thus any two type denotations that have the same signature and the same logical properties can be uniformly substituted for one another in pro gram ie the meaning of any program can depend only on the signature and meaning of a type and not on the identity how the type was pro so a change to a type that does not affect its signature or logical properties is guaranteed not the affect the meaning of any pro gram using the type the same properties of russell that provide this abstract treatment of data types allow us to the distinction between what is built into the language and what is later added by a user of the language each name in a russell program has only a signature and a meaning there is nothing one can do with a name in any russell program that depends on how the signature or meaning bound to the name were produced thus the user of the type color declared by color u red white blue has no way of knowing how this type to be declared many other types can be produced that have the same signature and logical properties as this one in fact it makes no difference to the user whether color to be declared as above or was provided as part of the built types included in an implementation of russell by that and values behave the same we provide the of russell with wide in deciding what he to include in the built parts of an implementation something may be built in because it is necessary eg booleans and integers or because making it part of the implementation provides certain time or space to the user all that is necessary is that the particular parts are consistent with the russell framework this means that they must be given signatures and they must be semantically consistent with the remainder of the language for example callbyvalue must be the parameter passing mechanism used by any new functions pro the particular conditions necessary to ensure semantic consistency are out in demers and the rich structure of the russell framework ensures that a broad range of values can be added to the language within the framework for instance the russell report describes a very high language that allows recursive union types as in and functional and data types vari ables may be declared in this language how static preserved typechecking is still a more russell func tional data types and type variables which in the implementation uses a nonrecursive union function and introduces a reference data type to build the structures previously allowed by recursive unions the signature of this reference type is given in demers it is interesting the signature of the union to note that function in russell is independent of whether the union is allowed to be recursive to make russell look more like a systems programming language it is necessary to introduce a data type like a machine word and to introduce a certain number of functions that allow us to the distinction between words and integers for example in russell such coercions can be performed through the introduction of functions of signature like w w integer that simply the argument as being of different type and return it these func tions obviously cannot be written in russell if they are not built in but there is ing in the framework that prevents a implementation of the language from including them if they are needed the handling of or machine dependent records are that can be provided by a particular implementation from our remarks above about we see that a users program cannot tell aside from time or space whether records or arrays are stored in any particular fashion thus we can reasonably regard russell as a very family of programming languages conclusion raises some fundamental about the current structure of algollike program ming languages these cannot be met by adding new to languages this simply the basic problems of the size and com of our languages instead we must either accept claim that the situation is hope less or return to first principles and try to dis where past attempts have failed this paper one such principle of language design and shows that its application many of type complete languages can have simple parameter passing and declaration rules while allowing wide flexibility in the behavior of parameters and declared names and allow the designer to build families of languages with widely varying able moreover the focus on type changes the fundamental role of the language designer from one whose is to put together a large number of to one who must a rich but small type struc ture and who is then forced to live within its constraints this change should make programming languages much harder to design but much easier to understand re j can the its algebra of programming style a be functional style from and pp demers a russell department and j report cornell tr university revised report on computer science hoare design gramming car on programming acm symposium on principles languages pp l language of pro hoare report science car recursive data structures department of computer stanford university james james mitchell and g programming language sigplan london on the and pj a correspondence lambda pp between notation algol gm languages pj q the next programming pp liskov liskov b a r abstraction mechanisms pp and c in clu reynolds reynolds j a language based on the principle ness and the reference pp simple of concept complete w a et al revised the algorithmic language algo notices pp report on s w et al preliminary an informal definition of department of computer science carnegie mellon university 