in system u palsberg popl consist complete well easy to abstract in pfenning and lee studied whether system f could support a typed they that typed for system f seems to be impossible but were able to represent system f in f further they found that the representation of f requires kind polymorphism which is outside f in and that the representation of terms would require another higher form of polymorphism is this a case of infinite we show that it is not and present a typed for system u the first for a calculus with decidable type checking system u extends system f with kind polymorphic terms and types we show that kind polymorphic types ie types that depend on kinds are sufficient to tie the ­ they enable representations of kind polymorphic terms without introducing another form of polymorphism our supports operations that iterate over a term each of which can be applied to a representation of itself we present three typed operations a that a term from its representation a predicate that tests the intensional structure of a term and a typed cps transformation ­ the first typed cps transformation our techniques could have applications from typepreserving to typed languages to more efficient categories and subject descriptors d processors interpreters d program verification correctness proofs formal methods general terms languages theory keywords lambda calculus self representation types introduction typed is the problem of representing a statically typed language in itself it can be seen as the intersection of two lines of research which generally studies representations of untyped or dynamically typed languages in themselves and typed representation which studies techniques for defining typed representations of statically typed languages that ensure only welltyped programs can be represented permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm in general the techniques required for building a representation depend upon both the metalanguage in which the representation is defined and the object language which is represented representations of expressive object language features tend to require even more expressive metalanguage features in the case of a the metalanguage and the object language are the same the key challenge of typed is to identify a single typed language that is expressive enough to represent each of its own features without additional expressive power language representation in our case we are interested in typed calculi with decidable type checking it has been an open question since whether a typed calculus with decidable type checking can support a meaningful notion of typed self representation and have many important applications a can be used to grow a language from a small core implemented in some other metalanguage one can use similar techniques to implement and compilers as well as and macro systems a similar idea is the reflective which uses an infinite of to add reflective capabilities to a language there are many examples of in the literature including ones for calculus haskell javascript lisp python ruby scheme standard ml and many others in each of these the representations are untyped in the sense that it is possible to build representations of illtyped terms and all representations are either untyped or else have the same type typed representation we can contrast this with typed representations which have two essential properties only welltyped terms can be represented and the type of a term is reflected in the type of its representation in the sense that the former can be determined by the latter this provides important correctness guarantees for an immediate consequence of is that a cannot produce illtyped terms we can also ensure that the types of its input and output terms are related in a particular way for example we can ensure that a preserves the type of its input or that a transformation modifies the type of the input program in the expected way there are many examples in the literature of typed representations in most cases the techniques rely on the fact that the metalanguage has a more powerful type system than the object language typed the goal of typed is to combine the benefits of and typed representation it the best of both worlds on the one hand it the expressive power of to the world of statically typed languages on the other hand it the correctness guarantees of types to a robust typed would support typed variants of the kinds of applications enabled by it would also narrow the expressiveness gap between dynamically typed languages and statically typed languages allowing more classical programs from dynamically typed languages to be statically type checked what does it mean for a language to support typed we have adopted two primary requirements that our language be a typed calculus with decidable typechecking and that a representation support operations that iterate over the structure of the term further we want to allow operations that produce results of different types possibly related to the type of the input representation we target a typed which is a that a term from its representation the idea of a was first studied by kleene in for an untyped calculus there are several examples of typed and that are implemented by iteration iteration is desirable because it can be supported by languages that dont include recursion an operation that iterates or folds over the term is defined by cases ­ one case for each syntactic form in the case of a pure calculus that contains only abstractions applications and variables we have identified a core challenge that is related to typed the polymorphic application problem is to define a polymorphic application function for each form of application in the language for example system f terms can be applied to terms and to types the problem for system f is to define a polymorphic application function that can apply terms to terms and a polymorphic application function that can apply terms to types in section we present a general technique for implementing functions by types in subsequent sections we this technique to represent terms and types history typed of calculi has been studied since at least when pfenning and lee considered whether system f could support a typed pfenning and lee that the problem seems to be impossible but were able to implement a typed for system f representations in f furthermore they were able to implement f in f which extends f with kind polymorphic terms they did not study representation of f in and studied the representation of kind polymorphism and that it would require another higher form of polymorphism their solution was to combine the categories of types and kinds so that kind polymorphism is represented in the same way as type polymorphism they demonstrated the first typed and first typed for a calculus though their calculus does not support decidable type checking in and palsberg implemented a typed for a combinator calculus with system f types they implemented a and the first typed a that implements reduction on typed representations like type checking is undecidable in their calculus their representation technique was designed for combinators and does not appear to be easily translated to a calculus the a challenge of representing a typed calculus is to find techniques for representing each form of abstraction and application in the language without adding any new ones pfenning and lee represented system f type abstraction and application using the higher order types of f in particular they used higher order types to represent system f type abstractions and applications f f f u figure four typed calculi denotes represented in we can demonstrate their technique using a polymorphic type application function a type application function for system f type applications should map a polymorphic term and a type to the application of the term to the type for example given a term of type and a type the type application function should return a term of type we can define the type application function for this case as x x a polymorphic type application function for system f should be able to apply any polymorphic term in other words it should be polymorphic in the type of the term and the type of the term must itself be polymorphic what is needed is a way to abstract over exactly the polymorphic types of system f monomorphic types like this is beyond the capabilities of system f type abstraction pfenning and lee solved this problem by encoding quantified types as secondorder types in system f for example the type can be encoded as the secondorder type the types of f are classified by a family of kinds firstorder types like have kind and secondorder types like have kind type abstractions in f range over a particular kind that is specified by an annotation we can abstract over encodings of system f quantified types using a type abstraction annotated with kind this enables a polymorphic type application function for system f quantified types to be implemented as x x in f the type of this term is the type represents an arbitrary quantified type substituting with an encoded quantified type the quantified type for example substituting with yields which is equivalent to note that is the f version of since every system f quantified type can be encoded as an f type of kind this type application function can apply any polymorphic system f term it can only apply polymorphic terms because no substitution for can make into a monomorphic type pfenning and lee used this technique to represent system f in f they were unable to represent system f in itself but did achieve a representation of f in f which extends f with kind abstraction and application in terms it is easy to imagine that this is a case of infinite that representing will require another extension which will also need to be represented if we hope to achieve the system f type application function discussed above already at the question of infinite it can apply any polymorphic term in system f but is not itself in system f on the other hand it is in system f but can only apply some of the polymorphic terms in f in particular it cannot apply itself this the following question which we name the polymorphic application problem is it possible to define a set of polymorphic application functions in a particular language one for each form of application in the terms of that language eg for applications of terms to terms terms to types terms to kinds etc we conjecture that a language that supports typed can also support polymorphic application in section we formalize the polymorphic application problem and present a solution for system u in later sections we use our solution to define our typed for system u our result is summarized in figure pfenning and lee were able to represent system f in f and f in f we show that f can be represented in system u and that system u can represent itself system u system u was first introduced by girard in his phd thesis in which he also introduced system f girard used system u to formalize a version of the showed that system u is not strongly normalizing and that every type is thus as a logic system u is inconsistent system u is a pure type system that lies outside the and that does not include dependent types it is an extension of f and every legal f term is a legal system u term the terms of system u consist of variables and abstractions and applications of each of terms types and kinds the types of system u consist of variables and abstractions and applications of each of types and kinds intuitively the types of system u are the terms of system f in section we show that system u can support a polymorphic application function for each form of application a key property that makes the possible is that system u does not have higherorder kinds as a result there is no type system for kinds all kinds are classified by a single sort this is analogous to the types of system f system f does not have higherorder types and all types are classified by a single sort since system u has only one classifier of kinds a representation of system u does not need to abstract over of kinds representation and operations we represent both terms and the types of terms we call our term representation procedure in section we define a metalevel process of which formalizes what it means for one term to represent another in the diagram above our function quote maps a typed term to its representation unlike the other operations in the figure quote is defined outside the language itself q quote cps eb e we support operations that iterate or fold over the representation in section we present three example operations defined as folds a that a term from its representation a predicate that tests the intensional structure of a representation and a typed continuationpassing style cps transformation cps transformation is often used in compilers of functional programming languages our results we identify system u as the first known typed calculus with decidable type checking that supports typed we represent both terms and the types of terms which enables operations that transform the type of their input type representations are essential to our implementation of the first typed cps transformation the result type of the cps transformation is a function of the intensional structure of the input type our type representations are types of a particular kind u type representations are used to type check term representations for example suppose that e is a term of type that q is the tion of e and that is the representation of then the type of q is exp our a term from its representation so that q e the type of is u exp uid in pure type systems is analogous to the quantifier of system f and f the type uid is an operation on type representations that a type from its representation for example uid rest of the paper section gives an overview of pure type systems section describes system u section defines our representation of types section defines our representation of terms section presents our example operations section discusses our implementation and experimental results section contains a comparison with related work section discusses future work and section concludes proofs of theorems stated throughout the paper are provided in the appendix of the full paper which is available from our pure type systems we use formalization of system u as a pure type system pts this section gives an overview of some important aspects of for the reader but does not include a detailed pure type systems have a uniform syntax which helps to both the presentation of our techniques and a comparison between system u and other pts instances like system f and f the comparison serves to explain what parts of system u are important for achieving a a pure type system is defined by a set of expressions t and a specification the expressions are defined by the grammar t v c v t t t t v t t here v ranges over a countable set of variables and c ranges over a set of constants we use x y to range over variables c to range over constants and a b a and b to range over expressions are introduced by the form and eliminated by application the form v t t introduces a product which is used to classify the notation a b denotes that a reduces to b in one step of reduction similarly a b denotes that a reduces to b in one step of reduction and a b denotes that either a b or a b the relation denotes the reflexive transitive closure of and denotes the least congruence relation generated by the relations and are defined similarly a specification of a pts consists of a triple s a r the first component s is a subset of c called sorts we will use s to range over sorts in the systems we consider all constants are sorts the second component a is a set of axioms of the form c s where c is a constant and s a sort the third component r is a set of rules of the form s s s for some sorts s s and s we use the shorthand s s to denote s s s the specification and a set of derivation rules determine the derivable typing judgments a b in a judgment of the form a b we call a the subject and b the classifier of a if a b can be derived using the rules in figure with the specification of a particular pts then a is legal in that system some authors call the set of legal expressions the terms though we will use term to refer to a subset of the legal expressions defined below we call a product derived with the rule s s s as its an s s s product the rule ensures that a s s s product will be classified by s a product x a b is called a dependent product if x occurs free in b it is standard to abbreviate products x a b as a b when x does not occur free in b it is sometimes possible to determine that an arbitrary s s s product can be written in this abbreviated form for axioms cs a cs start as x a x a weakening a a bs x b a a product a s x a b s x ab s s s s r x a b b x ab s abstraction x ab x ab f x ab a a application f a bx a ab conversion b s ab b b figure the rules for a pts example in system f a product has the form x a b where x ranges over terms and a and b are types since system f does not include dependent types x cannot occur free in b so x a b can be written a b to demonstrate the of pts syntax consider the system f term x x which has the system f type the symbol denotes a type abstraction the type variable is not classified since system f does not classify types the symbol denotes a term abstraction and the term variable x is classified the universal quantifier forms the types of abstractions and forms the types of abstractions in pts syntax the term is written x x and the type is written x here the same symbol is used for the both abstractions and the type of each abstraction is a product since x does not occur free in we can also write the type as theorem subject reduction for if a b and a a then a b theorem churchrosser for if a b and a a and a a then there exists a such that a a and a a while the focus of this paper is primarily on system u we also discuss systems f f and f the pts specification of each system is listed in figure the sorts of each is a subset of we divide the legal expressions of each pts based on these sorts the sort corresponds to the terms the sort corresponds to the types and the sort corresponds to the kinds more precisely suppose a legal expression a is derived by a b if b then a is a term if b then a is a type if b then a is a kind the axioms a of a pts instance defines how the different sorts are related to each other the axioms of each pts instance listed in figure are a subset of the axiom means that is the classifier of and that types classify terms the axiom means that is the classifier of and that the kinds classify types we call the classifier of a term its type and the classifier of a type its kind the rules r determine which products are legal in a pts instance the rules r of each pts instance listed in figure are a system f system f system f system u s a r s a r s a r s a r figure pts specifications of key calculi subset of the rule derives terms that abstract over other terms the types of which are products the rule derives terms that abstract over types the types of which are products the rule derives types that abstract over other types the kinds of which are products the rule derives terms that abstract over kinds the types of which are products the rule derives types that abstract over kinds the kinds of which are products in each pts of figure legal products are either types or kinds a product type is a legal product that is a type it is necessarily a s product a product kind is a legal product that is a kind it is necessarily a s product we adopt a naming convention to help distinguish between terms types and kinds names starting with letters such as e refer to terms names starting with letters and the letters and refer to types letters and refer to kinds systems f and f are part of the while f and u are not because of the rules and all except system u are strongly normalizing thesis proved that system u is not strongly normalizing in particular there exists a legal term in system u with the type that does not have a normal form however the types and kinds of system u are strongly normalizing type checking is decidable for each of system f f f and u this relies on that each system is injective a technical property of pure type systems an injective pts also has the property that types are unique none of the pts instances shown in figure have dependent types eg types that abstract over terms which require the rule a consequence of this is that any product x can be written types cannot depend on terms so x cannot occur free in system u in this section we define a decomposition of system u product types and use it to solve the polymorphic application problem for system u the ideas in this section throughout the paper in the definition of type representations in section in the decomposition of type representations in section and in the definition of term representations in section product types in a pure type system products are always classified by a sort the sort of types is so product types are products classified by the product types of system u are formed by and in general if a product x a is formed by s then is classified by ie is a type and a is classified by s system u products formed by and by are special cases a product of the form x is special because the bound variable x cannot occur free in ie types cannot depend on terms products formed by are special because the only subject classified by is theorem in system u if a then a proof by induction on the height of the derivation assume a we proceed by considering the last rule in the derivation if the last rule is axioms then a a the only possibility is so a as required if the last rule is start then s a contradiction if the last rule is weakening then x c and a by induction a as required if the last rule is product then there exist sorts s s such that s s r contradiction if the last rule is abstraction then x ab contradiction if the last rule is application then bx a there are two cases either b or a if b then x a must be legal this in turn requires a sort s and an axiom s contradiction if a then there must exist a term a such that a contradiction if derived by conversion then there must exist a sort s such that s which in turn requires an axiom s contradiction in words theorem states that system u does not include a type system for kinds the situation is similar for the types of system f as it does not include a kind system which is a type system for types in the pts formulation of system f the only subject classified by is as we will see theorem is a key property of system u that enables theorem if and is a normal form then is of one of the following forms a an where is a type variable where where since we are only interested in product types and not applications of the form n we only consider the last three cases we begin by defining a constructor for each case of product corresponding to the rule s that forms the product definition constructors for product types we define the following constructors for product types it is straightforward to check that the product type constructors have the types given by the following judgments every product type formed by s can be equivalently expressed as an application of the constructor s this is to a higher order abstract syntax encoding of product types theorem decomposition of product types for any legal product any legal product and any legal product we have below we define the components of a product to be the arguments of the constructor that yield an equivalent type definition components of products · the components of a product type are and · the components of a product type are and · the component of a product type is the following theorem states that the components of a product are always legal in the same environment as the product itself theorem types of product components if x and then if and then if then as stated earlier the key properties of system u that enable our technique are that product types can be and that terms and types can abstract over the components the components of a product are two types and can be abstracted in terms and types by the rules and respectively the components of a product are a kind and a type and can be abstracted in terms by the rules and and in types by and the single component of a component is a type and can be abstracted over in terms and types by and these properties will play key roles in our solution of the polymorphic application problem section and in the representation of types section and terms section polymorphic application we can now formalize the requirements of a polymorphic application functions and state the polymorphic application problem for a class of pure type systems definition standard pts a pts s a r is standard if · the designated sort s the types of terms · for each sort s s s a · if s s r then s the first condition of a standard pts establishes as the sort corresponding to terms the second condition states that terms do not classify anything the third condition states that if a term is an abstraction then its body is also a term the systems listed in figure and those in the are all standard definition polymorphic application function let s a r be a standard pts let s r and let p be a legal closed term we say that p is a polymorphic application function for the s products of s a r if it satisfies the following two conditions · p is of the form x a xn an x b b b b x b for some x xn a an b b b such that x a xn an b s · for every closed s product of s a r there exist legal expressions a an such that p a an the first condition defines the form of a polymorphic application function for s products the n outermost abstractions are what make it polymorphic they abstract over the components of such products the term under the n outermost abstractions x b b b b x b should be an application function for an arbitrary s product the second condition states that we can obtain an application function for particular closed s prod by n applications definition polymorphic application problem for a standard pts s a r we say that s a r supports polymorphic application if there exists a legal polymorphic application function for every rule s r for example a solution of the polymorphic application problem for system f requires two functions that are legal system f terms a function to apply terms to terms and a function to apply terms to types we conjecture that no legal function exists for system f and therefore that the polymorphic application problem for system f is impossible we now show how to solve the polymorphic application problem for system u the solution consists of three application functions and later we will use the techniques from this section to define our representations of types and terms term applications our first polymorphic application function applies terms to terms terms that can be applied to other terms have product types of the form where an application function for terms of type will have the type and can be implemented as f a f a by theorem we have that therefore we can make this polymorphic by abstracting out and the resulting function implements application of functions f a f a the abstractions of and are type abstractions formed by the type of is lemma is a polymorphic application function for products in system u proof we have already seen that is legal it is easily checked that it has the required form and that let be closed a product in system u by theorem the components and are both closed types of kind therefore as required type applications our second polymorphic application function applies terms to types terms that can be applied to types have product types of the form where ranges over types of kind and is a type based on the type rules in figure an application function for terms of a particular product type should have the type here denotes the type obtained by substituting for in the syntax is not part of our language of types but can be expressed as letting denote we can write as we can implement a polymorphic application function for products by abstracting over and which are the components of theorem states that has sort and has kind f f the first two abstractions of bind the components of an arbitrary product type the third abstraction binds a term of the corresponding product type the final abstraction binds the type argument the type of is lemma is a polymorphic application function for products in system u proof we have already seen that is legal and has the required form it is easily checked that let be a closed legal product in system u then is closed and classified by by theorem we have that is closed and has kind it is easily checked that we can derive as required kind applications our last polymorphic application function applies terms to kinds terms that can be applied to types have product types of the form where ranges over kinds and is a type an application function for terms of a particular product type should have the type this type is similar to with one important difference whereas the type variables and are classified by an arbitrary kind the kind variables and can only be classified by by theorem we express the substitution as letting denote we can write as theorem states that has kind therefore we can implement a polymorphic application function for as x x the first abstraction of is a type abstraction that binds the component of an arbitrary product type the second abstraction binds a term of the corresponding product type the final abstraction binds the kind argument the type of is lemma is a polymorphic application function for products in system u proof we have already seen that is legal and has the required form it is an axiom of system u that is classified by let a be a closed legal product in system u then a is closed and classified by by theorem a by theorem we have that is closed and has kind it is easily checked that we can derive as required it is that the definition of uses every rule of system u the abstractions over x and are formed by and respectively the type constructor is typelevel function formed by and the kind of is formed by theorem system u solves the polymorphic application prob lem proof lemmas and show that there exist legal polymorphic application functions in system u for each of its s rules and our functions we rely on two properties of system u that we can decompose product types theorem and that is the only subject classified by theorem system u appears to be a local minimum the trivial pts with r each of the rules is important for our solution system f system f system f system u × × × table polymorphic application functions in our polymorphic application in other systems that is the only subject classified by is a key to solving the polymorphic application problem for system u it avoids the need to abstract over which is impossible in system u however there is more to the ­ in system f is the only subject classified by and yet it appears that polymorphic application is impossible in system f the question of whether a pts supports polymorphic application seems to require consideration we do not know of a simple test that can answer this question for an arbitrary pts and leave the formulation of such a test for future work we conjecture that polymorphic application is not possible for system f f or f table summarizes the polymorphic application functions that can be implemented in each system using the techniques of section cells marked with indicate that a function for s products can be defined in the system cells marked with × indicate that the definition of in that system seems to be impossible empty cells indicate that s products are outside the system the first column shows that polymorphic application functions for products can be implemented in all four languages this is because a product can be decomposed into two types of kind and each language includes terms that abstract over types of kind via the rule system f does not support a function for applying terms to types in system f products ie quantified types requires higherorder types which in turn require the rule system f can implement a polymorphic application function for system f products but not for its own products since all system f types have kind all products in system f have the form these can be decomposed into a single component which has kind in f since f includes higher kinds a function for f should abstract over the kind as we did in the for system u since f does not include the rule needed for kind abstraction in terms it cannot implement system f can implement because it includes the rule however it cant implement because product types cant be decomposed in f products requires types which in turn require the rule the techniques used to implement these polymorphic application functions can also be used to build typed representations thus we can interpret the results of table to mean system f can be represented in f f can be represented in f f can be represented in u and u can be represented in itself in sections and we will use the techniques from this section to build representations of types and terms representing types in this section we define a process for representing types of kind type representations are themselves types we are primarily interested in term representations and the purpose of type representations is to enable more typed operations on term representations ­ in particular operations like cps transformation that transform the type of a program in a nontrivial way since the purpose of type representations is to support typed operations on term representations we only represent types of kind which are the types of terms we do not represent higherorder types like which has the kind we only represent types in normal form ­ products variables and applications of variables to one or more types while the terms of system u are not strongly normalizing the types are this ensures that any type of kind can be normalized and represented while we only represent closed terms it is important that we can represent open types this is because we will represent not only the type of the toplevel term being represented but also the type of each of its subterms type representations should support type functions that depend on the intensional structure of their inputs these play an important role in the implementation of our typed cps transformation in section we summarize the requirements for our representation of types below definition the requirements for our type representation procedure are · only legal types can be represented · every legal type of kind can be represented · type representations support operations that fold over the structure of the type constructors for type representations we represent types using higher order abstract syntax hoas inspired by and type representations are types of kind u which is defined inductively from four constructors theorem states that a type of kind is either an application of a type variable to zero or more arguments or a product derived from one of the rules or our type representation includes a constructor for each case definition constructors of type representations the kind u is defined inductively by the constructors var u prod u u u prod u u prod u u the constructor var builds representations of type variables applied to zero or more types the constructors of prod prod and prod build representations of and products respectively their types are similar to those of the constructors and defined in section except that they construct types of kind u instead of types kind the body of this paper will keep the definitions of u and its constructors abstract the appendix of the full paper gives concrete definitions of u and its constructors as system u terms building type representations the procedure for building type representations is defined in figure it takes as input the derivation of a normal form type of kind and outputs a representation of the type the representation of a product type depends on whether it is a product a product or a product an application of a variable to zero or more types is represented by applying the constructor var to it a product formed by has the form where and are each of kind it is represented by applying the constructor prod to the representations of and a product formed by has the form where has kind and may occur free in we build the representation of in the environment and abstract over in the representation the result has kind u in the environment we then apply the constructor prod to the kind and the resulting abstraction a product formed by has the form a an var a an prod prod prod figure type representation procedure where has kind and may occur free in we build the representation of in the environment and abstract over in the representation the result has kind u in the environment we then apply the constructor prod to the resulting abstraction theorem kinds of type representations if and then u example the type of the polymorphic identity function is represented as prod prod var var when context of the derivation is clear we write to denote the type such that folds over type representations our type representation en ables operations that fold over the structure of the type a fold is defined by case functions for each case of the structure of types of kind variables or type applications with a variable in function position products products and products case functions for type variables have kind variables are the base case for our inductive type representation the fold function maps an input variable to some type of kind since we only represent types of kind the input type variable must have kind case functions for products of the form have kind its two arguments of kind correspond the results of folding over and case functions for products of the form have kind an argument type of kind will be the result of folding over a type in which a type variable of kind can occur free case functions for products of the form have kind an argument type of kind will be the result of folding over a type in which a kind variable can occur free definition suppose var prod prod and prod satisfy var prod prod prod then prod prod prod denotes the type f such that f u and f var if is of the form a an f prod f f if f prod f if f prod f if our first example of an operation on type representations is listed in figure uid a type from its representation the uid fold figure a function that a type from its representation case function for variables is the identity the case function for each product type is the corresponding constructor theorem if then uid we define the components of type representations similarly to the components of types definition components of product representations · the components of the representation of a product type are and · the components of the representation of a product type are and · the component of a product type is representing terms in this section we define a process that builds representations of terms we begin by establishing the requirements for our representation first and should be able to represent every legal term in the language and representations should themselves be legal terms all representations should be strongly normalizing even if they represent a term in order to be considered useful we require our representations to support operations that fold over the structure of the term we summarize our requirements typed representation of terms below definition requirements for term representation · only legal terms can be represented · every closed legal term can be represented · all representations are strongly normalizing · representations support folds given these requirements what is required to type check representations since a representation has different semantics than the term it represents we expect its type to also be different on the other hand we expect the types of a term and its representation to be related this allows typed operations with result types that depend on the type of the input term representation using we represent terms using typed parametric higher order abstract syntax the use of allows our representation to support multiple operations with different result types recall that our type representation which uses a simpler hoas only supports operations that produce results of kind in each case we choose the simplest representation for our needs our representations have types of the form exp where is a type representation the type exp is defined in figure it is parametric in a type r of kind u which is supplied by each operation and determines the result type of the operation instantiating a representation of type exp with a result type r yields the type pexp r which can be read exp specialized to parameter r the specialized representation type pexp is inductively defined by the constructors listed in figure there is a constructor for each form of the terms of system u system u terms are either variables abstractions or applications the abstractions and applications can be formed by the rules or our procedure is defined in figure it relies on a procedure defined in figure given a term r u u r pexp r r u u u r pexp r pexp r prod r u u u pexp r prod pexp r pexp r r u u pexp r pexp r prod r u u pexp r prod pexp r r u u pexp r pexp r prod r u u pexp r prod pexp r exp u r u pexp r figure representation constructors e q r u q figure of type the produces a term of type pexp r then simply abstracts over r in the result the type representations within term representations this is a key to supporting operations like cps that transform the type of their input as is common in hoas representations we use abstractions to bind the free variables of a representation for example if e q then may occur free in q we close q by abstracting over if q has type pexp r then q has type pexp r this reflects that the representation has a free variable and enables substituting for by application the first rule of handles variables representations of variables are constructed using variables are represented that is using other variables in particular a variable of type is represented using a variable of type r abstractions formed by bind term variables in terms and have types of the form their representations are constructed using the types and are the components of the premise x e q builds a representation of the body in the extended environment x the abstraction x r q binds the free variable x in the representation of e applications formed by apply terms to terms an application e e where e has the type is represented by applying the constructor to the components of and the representations of e and e abstractions formed by bind type variables in terms and have types of the form their representations are constructed using the kind and type are the components of the premise e q builds a representation of the body in the extended environment x r x x e q x e r x r q e q e q e e r q q e q e r q e q c e c r q e q e r q e q e x r q figure the abstraction q binds the free variable in the representation of e applications formed by apply terms to types only the term is represented the type argument is not represented even if it is of kind the constructor is applied to the components of the the representation q of the term e and the type argument the result is a term of type pexp r a coercion c of type pexp r pexp r is generated by the binary operation coercions are discussed further below and full detail is given in the appendix to the full paper abstractions formed by bind kind variables in terms and have types of the form their representations are constructed using the type is the component of the premise e q builds a representation of the body in the extended environment the abstraction q binds the free variable in the representation of e applications of products formed by apply terms to kinds again only the term is represented the constructor is applied to the component of the representation of the term and the kind argument example let id x x r u r r x r r x in bottomup order the term corresponds to the output of the on the derivation x x the term to the output on x x and the term to the output on id at the toplevel abstracts over r in the of id for convenience we define a notation e as we did for type representations though its definition is slightly different when e is a term e denotes its which allows us to use e even when e is not closed e q fu e qr f we allow the environment and the result type function f to be implied by the context since variables are represented by variables with different types we define a representation environment in which are legal we define inductively by the following rules we allow the result type function f to be implied by context definition representation environment x x f if if we now formalize the types of and theorem if e pexp f e and f u then theorem types of if q then q exp e and theorem if q then q is strongly normalizing authors traditionally define a representation in calculus to be a normal form we follow pfenning and lee and define constructors for our representation which allow us to abstract away the details of our encoding representations built from our constructors are not normal forms but reduce to normal forms in a few steps we provide an example in the appendix to the full paper it is also possible to define a that produces closed normal forms the theorem states that our procedure is complete every legal system u term can be represented we achieve using the techniques developed for our solution to the polymorphic application problem in section the type of each function is related to the types of the corresponding representation constructors and each polymorphic application function abstracts over the components of s product types we can use uid to define a version of that abstracts over the components of s type representations for example could be defined as u x uid prod x the application of x to is legal because uid prod is equivalent to uid this version of can have either of the following equivalent types · u uid uid prod · u uid prod uid if we replace uid with pexp r in the first type and abstract over r we get the type of the same operation on the second type yields the type of we summarize the results of section section and section as follows every form of product type in system u can be decomposed and we can implement a polymorphic application function by abstracting over the components further every form of product type in system u can be represented type representations can also be decomposed and the components can be also used to define a polymorphic application function finally we can combine our polymorphic application functions with standard representation techniques to achieve abs r u u u r r r prod app r u u u r prod r r abs r u u r r prod app r u u r prod r abs r u u r r prod app r u u r prod r figure types of case functions folds over term representations our representation of terms is designed to support operations that fold over the structure of the term a fold is defined by six case functions one each for abstractions and applications formed by and the result of a fold is defined by induction on the structure of the term for each term the corresponding case function is applied to the the results of folding over its subterms this is made formal below the types of the case functions of a fold are defined in the types app app and app and are similar to the types of our polymorphic application functions and from section each types and the type of each function relies on the idea of decomposition the difference is that the types deal with components of type representations while the types of the functions deal with components of product types the specification of an operation on term representations consists of a result type r a witness of type witness r and six case functions the witness ensures that for all types and such that and the can synthesize a of type pexp r pexp r these coercions are necessary in order to represent type applications the semantics of a coercion thus depends on the witness which gives us the flexibility needed to support multiple operations on a single generic representation we will say more about the coercions for each of our operations in the following section witnesses and coercions are described in greater detail in the appendix to the full paper definition suppose f w abs app abs app abs and app satisfy f u w witness f abs abs f abs abs f abs abs f app app f app app f app app f then w abs app abs app abs app denotes a term f such that f f f and for any context term e and type such that e we have that w witness uid id u u x uid uid x id u x uid x id u x uid x w id id id id id id figure definition of if e is a variable then f e e if and e x e then f e abs x f f e if e e e e then f e app f e f e if and e e then f e abs f e if e e and e then f e c app f e for some coercion c if and e e then f e abs f e if e e and e then f e app f e definition states that the operation specified by w abs app abs app abs app has the semantics expected of a fold the cases are mutually exclusive and exhaustive a term in system u is either a variable an abstraction or an application abstractions and applications can be formed by one of three rules operations in this section we show how to program three benchmark operations on our representation the first called is a typed ­ a that an term from its representation the second called is a simple example of an intensional predicate it tests whether its input represents an abstraction or an application the third and most complex is a typed cps transformation our is defined in figure it produces results with types determined by uid each case function in the definition of is an identity function if a term e has type then a representation of e produces a term of type uid theorem states that uid is equivalent to theorem type of u exp uid folds identity functions over the term the result is equivalent to the original term theorem correctness of if e and q then q e the coercions produced by the witness for are always identity functions consider the type uid uid which is the type of an arbitrary coercion for this type is equivalent to our second benchmark operation is shown in figure tests if its input is a representation of an abstraction this demonstrates that we can define operations on a representation that bool true t f t false t f f u bool w abs app abs app abs app witness t t f bool t t f bool e bool false f e bool true f e bool x false t e bool true t e bool false w abs app abs app abs app figure specification of cannot be defined directly on the represented term the result type of is the constant bool function each case function in the definition of is a constant function it the result of folding over its subterms since we are only interested in the outermost constructor of the representation the case functions for abstractions are constant true functions and the case functions for applications are constant false functions theorem type of u exp bool the application of to the representation of a term of type produces a term of type which is equivalent to bool like those for uid coercions for types are identity functions consider the type which is the type of an arbitrary coercion for since is a constant function this type is equivalent to bool bool theorem correctness of if e and q then · if e x ae then q true · if e e a then q false continuationpassing style in this section we implement a type callbyname continuationpassing style cps transformation on our representation cps transformation is commonly used in compilers for functional languages it makes the evaluation order callbyname in our case explicit and eliminates the need for a there are examples of typed cps transformations in the literature though ours is the first that is we extend the typed cps transformation of which operates on typed representations of simply typed calculus to transform abstractions and applications of types and kinds we extend the technique used by morrisett et al to transform system f type abstractions and applications the result of applying the cps transformation to the representation of a term of type is a term of type cps the type cps is shown in figure cps is defined via a fold cps and a function ct the itself is defined in figure theorem type of cps cps u exp cps coercions for cps types are not identity functions unlike those for uid and types as a simple example note that for type variables and cps is not equivalent to cps the former simplifies to cps var ct t v t v v var prod ct ct prod ct prod t ct t cps prod prod prod cps t u ct cps t figure the result type of cps transformation w witness cps abs u u f cps cps v k cps cps v k f app u u f cps prod x cps v k cps v f v g cps cps g x v k abs u e cps v k cps prod v k e app u e cps prod v k cps v e v e cps e v k abs u e cps v k cps prod v k e app u e cps prod e v e cps e v k cps w abs app abs app abs app figure specification of cps and the latter to cps prod var var coercions for cps types add and remove continuations as necessary we dont attempt to formally verify the correctness of cps though we validate it by testing it on the functions from section experiments we experiments using an implementation of system u which is available from our we implement a parser in a domain specific language for writing parsers and the successor to the parser generates abstract syntax for our haskell implementation of system u which includes type and term a validity checker an evaluator and an incomplete equivalence checker we have used the implementation to mechanically check that all system u terms types and kinds presented in the paper are legal and to verify the equivalence theorems we have verified that of and cps are legal and have normal forms furthermore of is equivalent to itself and of evaluates to the church boolean true q u exp uid q s f a r figure pts specification of f q u exp q true we have validated cps by applying it to each of our functions from section related work the problem of typed has been studied since when pfenning and lee considered whether system f could represent itself they found that seems to be impossible for system f however they developed several typed representations of one language in another ­ system f in system f and f in f their representation technique inspired our own they use higher order abstract syntax similar to ours with two important differences they dont represent types and their does not change the types of variables each of these is important for our typed cps transformation the key idea of decomposition of product types is already present in pfenning and lee the idea throughout the literature on typed hoas representations in the setting of pure type systems the pattern becomes more clear we identify position of product types and abstraction of the resulting as key requirements for typed representation of a pure type system and defined the first typed self representation and which they called eval they study a language f defined in figure like f system f contains the rule which allows formation of higherorder types unlike f which types using a family of kinds induced by the sort and axiom system f adds an axiom which forms types that classify other types types that classify other types play the role of kind in system f this is sufficient to tie the abstractions formed by can abstract over both types and kinds in terms similarly can abstract over both types and kinds in types our type representation is inspired by that of which represents the types of simply typed calculus in f they use type representations in a representation of simplytyped calculus in f which supports a typed cps transformation our of system u and cps transformation are also in by their representation and cps transformation of simplytyped calculus like system u system f is not normalizing unlike system u type checking of f is undecidable due to the rule we conjecture that system u can be embedded into f but that system f cannot be embedded into system u our representation of types is also inspired by et al they study intensional type analysis for i which like system u includes type and kind polymorphism they encode base types of kind analogous to in system u using hoas the kinds of their hoas type constructors parallel the kinds of the constructors of our type representations i kind system u kind prod prod u u prod u u despite notational differences there is a direct correspondence between the kinds of the constructors for i types and our type representations the binders and play the same role in each calculus furthermore in system u u is shorthand for u since does not occur free in u a subtle difference is that there is no classifier for the kinds of i they use a wellformedness condition while in our pts formulation of system u all kinds are classified by et al include a type operator typerec for intensional type analysis of base types based on folds they support fold operations that produce results the typerec operator is primitive which avoids the need for type representations they did not study of system i and it is an open question whether it would be possible we conjecture that system u can be embedded into i but i cannot be embedded into system u typed representation has been extensively studied and is still an active area of research chen and xi studied typed representation and typed and use typed representation to build interpretations achieved a representation of dependently typed languages in agda developed a technique for building generic composable typed representations as a solution to the expression problem each of these is important related work and we have learned from and been inspired by them even though they did not study future work size our representations do not support operations that measure the size of a term this is a limitation of our higher order abstract syntax representation abstractions in the representation particularly type abstractions can block access to the size of subterms assuming the size operation should produce results of some closed type nat we would need a way to convert a term of type nat to nat the quantification is redundant since does not occur free in nat in order to recover the nat we would have to apply the term of type nat to a type of kind this is not always possible since not all system u kinds are in this was addressed by adding a type constant which could be used to apply these abstractions beyond kind our representation of types is limited to types of kind full representation of types is desirable as it may eliminate the need for coercions and the witnesses that enable coercions full representation may also enable more operations it is an open question whether full type representation is possible in system u without type representation at the other end of the type representation we can consider representation of terms that dont require representation of types we represent types in order to support our typed cps transformation in particular type representations allow us to give cps the polymorphic type cps the input and output types exp and cps are both defined in terms of the quantified variable our other operations and do not require any representation of types it is possible to define a simpler representation type exp of kind and a procedure that represents terms of type with terms of types exp the representation type and would be similar to those from in particular we would no longer require coercions strong normalization of the two calculi system f and system u known to support typed neither is strongly normalizing it is an open question whether a language with decidable type checking and strong normalization can support typed representing open terms our changes the types of variables which is important for our cps transformation but also limits our representations to closed terms pfenning and lee did not change the type of variables which enabled them to represent free variables ie those bound outside the representation in the same way as bound variables it is possible to extend our representation type with a new constructor for representing free variables with the type r u pexp r var to represent a free variable of type the would first apply this constructor producing a term of type pexp r var then it would synthesize a coercion to change the type to pexp r note that var and that dependent types we can extend system u with dependent types by adding to r the rule that forms types that abstract over terms the resulting system still supports polymorphic application which indicates that it might also support compared to the functions for system u the only change required is to since products can now be dependent for example in a product type x formed by the bound variable x can now occur free in the function for the extended system could be defined as x x y y note that the kind is formed by we still have the property that is the only element of which is key to the however the addition of dependent types would raise two challenges for type representation the first is due to the introduction of types eg because types can contain terms our type representation in this paper only applies to types in normal form second the type representation must consider how to represent types that depend on terms conclusion the question of whether a meaningful notion of typed is possible for a language with decidable type checking has been open since we answer in the by presenting the first typed for a calculus with decidable type checking our calculus is system u which was introduced in phd thesis we embed representations of types into representations of terms which enable operations like cps transformation that change the type of a term our representation supports operations that iterate over the term and we provide three example operations a typed that a term from its representation a predicate that tests the intensional structure of a term and a typed cps transformation ours is the first typed cps transformation we have validated our results by experiments using an implementation of system u in haskell acknowledgments we thank john and the popl reviewers for helpful comments discussions and suggestions this material is based upon work supported by the national science foundation under grant number references the this paper is available at the full paper with the appendix is available there as are the source code for our implementation of system u and our operations and structure and interpretation of computer programs mit press a generic abstract syntax model for embedded languages sigplan not ­ september barendregt in lambda calculus j program ­ hp barendregt of logic in computer science vol background computational structures s ed chapter lambda calculi with types oxford university press inc new york ny typechecking injective pure type systems j program ­ november a recursion theoretic self interpreter for the lambdacalculus and a of lambda calculus having a normal form in csl pages ­ and finally partially evaluated staged interpreters for simpler typed languages journal of functional programming ­ chen and xi through code representation in proceedings of the acm sigplan international conference on functional programming pages ­ august chen and xi through code representation journal of functional programming ­ parametric higherorder abstract syntax for mechanized semantics in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm and modular proof of strong normalization for the calculus of constructions j program ­ jan logics and type systems girard et des de phd thesis paris vii and palsberg typed by pattern matching in proceedings of icfp acm sigplan international conference on functional programming pages ­ september c kleene and math j pages ­ and daniel b a very short november but meaningful dependent typesafe syntax and evaluation in proceedings of the th acm sigplan workshop on generic programming pages ­ new york ny usa acm john recursive functions of symbolic expressions and their computation by machine part i acm ­ april efficient in lambda calculus journal of functional programming ­ see also report of the pure lambda calculus higherorder and symbolic computation ­ greg morrisett david walker karl crary and from system f to typed assembly language acm trans program lang syst ­ may matthew evaluating haskell in haskell the ­ frank pfenning and peter lee in the polymorphic calculus theoretical computer science ­ and typed in proceedings of pldi acm sigplan conference on programming language design and implementation pages ­ june john c reynolds definitional interpreters for higherorder programming languages in proceedings of th acm national conference pages ­ acm press the paper later appeared in higherorder and symbolic computation ­ and shao intensional analysis of quantified types acm trans program lang syst ­ xu and the in lambda calculus theoretical computer science ­ march john binary lambda calculus and combinatory logic in complexity and applications a revised version is available at philip wadler the expression problem and an objectoriented language for pattern matching in proceedings of the symposium on dynamic languages pages ­ new york ny usa acm and weirich boxes go encoding higherorder abstract syntax with parametric polymorphism in proceedings of the acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm and robert a reversible programming language and its invertible in proceedings of acm symposium on partial evaluation and program manipulation 