decidable logics combining heap structures and data p university of illinois at usa and university of paris france university of illinois at usa abstract we define a new logic strand that allows reasoning with programs using deductive verification and smt solvers strand logic structure and data logic formulas express constraints involving heap structures and the data they contain they are defined over a class of r defined using relations over trees and are of the form y where is a monadic secondorder logic mso formula with additional quantification that combines structural constraints as well as but where the are only allowed to refer to x and y the aspects of the logic are a the logic is powerful allowing existential and universal quantification over the nodes and complex combinations of data and structural constraints b checking for linear blocks of statements with preconditions and postconditions expressed as boolean combinations of existential and universal strand formulas reduces to satisfiability of a strand formula c there are powerful decidable fragments of strand one semantically defined and one syntactically defined where the decision procedure works by combining the theory of mso over trees and the quantifierfree theory of the underlying we demonstrate the effectiveness and of the logic by checking verification conditions generated in proving properties of several programs using a tool that combines an mso decision procedure over trees with an smt solver for integer constraints z categories and subject descriptors f logics and meanings of programs specifying and verifying and reasoning about programs mechanical verification d software engineering verification assertion checkers f theory of computation models of computation automata general terms algorithms reliability theory verification keywords heap analysis smt solvers monadic secondorder logic combining decision procedures automata decidability introduction a fundamental component of analysis techniques for complex programs is logical reasoning the of efficient smt solvers satisfiability modulo theory solvers have significantly advanced permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm the techniques for the analysis of programs smt solvers check satisfiability in particular theories eg integers arrays theory of uninterpreted functions etc and are often restricted to quantifierfree fragments of firstorder logic but support completely automated and efficient decision procedures for satisfiability moreover by using techniques that combine theories larger decidable theories can be obtained the framework allows generic combinations of quantifierfree theories and has been used in efficient implementations of combinations of theories using a sat solver that queries decision procedures of component theories satisfiability solvers for theories are tools that advance several analysis techniques they are useful in generation where the solver is whether there exists an input to a program that will it along a particular path see for example smt solvers are also useful in based on abstract interpretation where the solver is to compute precise abstract transitions for example see slam for predicate abstraction and for solvers are also useful in classical deductive verification where that state preconditions and postconditions can be transformed into verification conditions whose validity is checked by the solver for example and use smt solvers to prove verification conditions one of the least understood classes of theories however are theories that combine and the data they contain analysis of programs that manipulate dynamically allocated memory and perform destructive while maintaining datastructure invariants like a binary search tree requires reasoning with heaps with an unbounded number of nodes with data stored in them reasoning with heap structures and data fundamental challenges due to the of the datastructures first for a logic to be useful it must be able to place constraints on all parts of the structure eg to say a list is sorted and hence some form of universal quantification over the heap is necessary this immediately rules out classical combinations of theories like the scheme which only to quantifierfree theories intuitively given a constraint on heap structures and data there may be an infinite number of heaps that satisfy the structural constraints and checking whether any of these heaps can be extended with data to satisfy the constraint cannot be stated over the even if it has quantification there have been a few in combining heap structures and data recently for instance supports a logic that ensures decidability using a highly restrictive syntax and csl extends the logic mechanism to handle constraints on sizes of structures however both these logics have very syntax that involve the domain being partially ordered with respect to sorts and the logics are so that the decision procedure can move down the sorted structures and hence terminate moreover these logics cannot express even simple properties on trees of unbounded depth like the property that a tree is a binary search tree more importantly the technique for deciding the logic is encoded in the syntax which in turn aims for a fast reduction to the underlying making it hard to extend or generalize in this paper we propose a new fundamental technique for deciding theories that combine heap structures and data for fragments of a logic called strand the logic strand we define a new logic called strand for structure and data that combines a powerful with an arbitrary strand formulas are interpreted over a class of datastructures r and are of the form y where is a formula that combines a complete monadic secondorder logic over the and can have additional quantification and a that can constrain the of the nodes referred to by x and y the in strand is derived from the rich logic of designing decidable monadic secondorder logics over graphs and is extremely expressive in defining structural shapes and invariants strand formulas are interpreted over a recursively defined class of datastructures r which is defined using a regular set of skeleton trees with between them this way of recursively defining datastructures is not new and was by the system which reasons with purely structural properties of heaps defined in a similar manner in fact the notion of graph types is a convenient and simple way to define datastructure types and invariants and is easily expressible in our scheme datastructures defined over skeleton trees have enough expressive power to state most datastructure invariants of recursively defined datastructures including nested lists trees cyclic and doublylinked lists and separate or connected combinations of these structures moreover they present a class of graphs that have a decidable mso theory as mso on these graphs can be interpreted using mso over trees which is decidable in fact graphs defined this way are one of the largest classes of graphs that have a decidable mso theory as we show in this paper the strand logic is to reasoning with programs in particular assume we are given a program p a precondition on the datastructure expressed as a set of recursive structures r and a precondition and a postcondition expressed in a of strand that allows boolean combinations of the existential and universal fragments we show that checking the of the associated reduces to the satisfiability problem of strand over a new class of recursive structures rp note that despite its relative expressiveness in allowing quantification over nodes strand formulas cannot express certain constraints such as those that constrain the length of a list of nodes eg to express that the number of black nodes on all paths in a tree are the same nor express the multiset of stored in a datastructure eg to express that one lists data contents are the same as that of another list we hope that future work will extend the results in this paper to handle such constraints decidable fragments of strand the primary contribution of this paper is in identifying decidable fragments of strand we define two such fragments one which is a semantic fragment that defines the largest class that can exploit our combination mechanism for decidability and the other a smaller but syntactic fragment the decision procedures work through a notion called intuitively for two heap structures without data s and s s in s with respect to a strand formula if there is an embedding of the nodes of s in s such that no matter how the constraints are interpreted if s satisfies then so will the s satisfy by the we define the notion of so that it is entirely structural in nature and is definable using mso on an underlying graph that simultaneously represents s s and the embedding of s in s if s in s then clearly when checking for satisfiability we can ignore s if we check satisfiability for s more generally the satisfiability check can be done only for the minimal structures with respect to the partialorder and defined by the semantic decidable fragment is defined to be the class of all formulas for which the set of minimal structures with respect to is finite and where the quantifierfree theory of the underlying is decidable though this fragment of strand is semantically defined we show that it is syntactically given a strand formula we show that we can build a regular finite representation of all the minimal models with respect to even if it is an infinite set using then checking whether the number of minimal models is finite is decidable if the set of minimal models is finite we show how to enumerate the models and reduce the problem of checking whether they admit a that satisfies to a formula in the quantifierfree fragment of the underlying which can then be decided we also define a syntactic decidable fragment of strand which is a of the semantic class in this fragment we distinguish two kinds of binary relations in the heap and relations intuitively a relation is if for every model m and m the relation holds on a pair of nodes of m iff the relation holds for the corresponding pair of nodes in m given a relation r we show it is also decidable whether r is an relation formulas are then of the form y where a has no additional quantification and b the atomic structural relations in compare only variables in x we show that formulas always have a finite number of minimal models with respect to and are hence decidable using the decision procedure for the semantic fragment we report also on an implementation of the above decision procedures for the structural phase we use a powerful tool for deciding mso over trees which despite its theoretical worstcase complexity works very efficiently on realistic examples by combining a variety of techniques including minimization bdds and tree automata the quantifierfree we use is the quantifierfree logic of linear arithmetic and we use the smt solver z to handle these constraints we have proved several programs correct including programs that search and insert into sorted lists reverse sorted lists and perform search insertion and rotation on trees in each of these cases the verification conditions were always expressible in the syntactic fragment and hence in the semantic decidable fragment supporting our thesis that the decidable fragment is natural and useful in summary we present a general decidability technique for combining heap structures and data identify semantically a decidable fragment demonstrate a and present experimental evaluation to show that the decidable combination is expressive and efficiently solvable we believe that this work breaks new ground in combining heap structures and data and the technique may also the way for defining decidable fragments of other logics such as separation logic that combine structures and data motivating examples and logic design the goal of this section is to present an overview of the issues involved in finding decidable logics that combine heap structure and data which sets the stage for defining the decidable fragments of the logic strand and the choices in our logic design using simple examples on lists let us consider lists in this section where each node u has a du that can hold a value say an integer and with two variables head and tail pointing to the first and last nodes of the list respectively consider firstorder logic where we are allowed to quantify over the nodes of the list and further for any node x allowed to refer to the of x using the term dx let x y denote that y is the successor of x in the list and let x y denote that x is the same as y or precedes y in the list example consider the formula y dy dy the above says that the list must be sorted and that the head of the list must have value c and the tail must have value c note that the formula is satisfiable iff c c and in which case it is actually satisfied by a list containing just two elements pointed to by head and tail with values c and c respectively in fact the property that the formula is satisfiable by a list has nothing really to do with the involved in the above formula assume that we have no idea as to what the mean and hence look upon the above formula by replacing all the using uninterpreted predicates p p to get the formula b y dy now we do not know whether the formula is satisfiable for example p may be unsatisfiable but we still do know that lists are always sufficient in other words if there is a list that satisfies the above formula then there is a list that satisfies it the argument is simple take any list l that satisfies the formula and form a new list l that has only the head and tail of the list l with an edge from head to tail and with data values inherited from l see figure below it is easy to see that l satisfies the formula as well since whenever two nodes are related by in the list l the corresponding elements in l are similarly related this property head tail head tail of course does not hold on all formulas as we see in the example below example consider the formula y dy dy the above says that the values in the list increase by one as we go one element down the list and that the head and tail of the list have values c and c respectively this formula is satisfiable iff c c however there is no bound on the size of the minimal model that is independent of the for example if c and c then the smallest list that satisfies the formula has a nodes in other words the place arbitrary lower bounds on the size of the minimal structure that satisfies the formula intuitively the formula refers to successive elements in the list and hence a large model that satisfies the formula is not to a smaller model the formula in the example example refers to pairs of elements that were reachable leading to contraction of large models to small ones recall that the design principle of the decidable fragment of strand is to examine the structural constraints in a formula and enumerate a finite set of structures such that the formula is satisfiable iff it one of these structures can be with values to satisfy the formula this strategy necessarily fails for the above formula as there is no class of finite structures that captures all models of the formula independent of the the formula in the first example is part of the decidable fragment of strand while is outside of it example consider the formula yy tail dy this formula says that for any node n except the tail there is some node n that has the value dn notice that the formula is satisfiable if c c but still there is no a priori bound on the minimal model that is independent of the in particular if c and c then the smallest model is a list with nodes moreover the reason why the bounded structure property fails is not because of the referring to successive elements as in example but rather because the above formula has a prefix quantification of formulas where an existential quantification follows a universal quantification in the prefix have bounded models and strand hence only allows formulas with quantification prefixes note that quantification of structure variables variables that quantify over nodes but whose is not referenced in the formula can be arbitrary and in fact we allow strand formulas to even have set over nodes the class having motivated formulas with the quantification it is to examine this fragment in classical firstorder logic over arbitrary infinite which is known as the class and is a classical decidable fragment of firstorder logic consider first a purely relational vocabulary assume there are no functions and even no constants then given a formula y let m be a model that satisfies this formula let v be an interpretation for x such that m under v satisfies yx y then it is not hard to argue that the obtained by only the elements used in the interpretation of x ie vx and each relation to this smaller set satisfies the formula y as well hence a model of size at most k always exists that satisfies if the formula is satisfiable where k is the size of the vector of existentially quantified variables x this bounded model property extends to when constants are present as well the should include all the constants but fails when more than two functions are present satisfiability hence reduces to propositional satisfiability and this class is also called the effectively propositional class and smt solving for this class exists the decidable fragment of strand is after a similar but more complex argument given a subset of nodes of a model the subset itself may not form a valid we define a notion of that allows us to extract proper subgraphs that contain certain nodes of the model however the relations edges in the will not be the projection of edges in the larger model consequently the may not satisfy a formula even though the larger model does we define a notion called that allows us to identify when a s of t is such that whenever t satisfies under some interpretation of the s can inherit values from t to satisfy as well this is consider more complex and is the main technical contribution of the paper we then build decision procedures to check the minimal models according to this embedding relation recursive datastructures we now define recursive datastructures using a formalism that defines the nodes and edges using mso formulas over a regular set of trees intuitively a set of datastructures is defined by taking a regular class of trees that acts as a skeleton over which the datastructure will be defined the precise set of nodes of the tree that corresponds to the nodes of the datastructure and the edges between these nodes which model pointer fields will be captured using mso formulas over these trees we call such classes of datastructures recursively defined datastructures recursively defined datastructures are very powerful mechanisms for defining invariants of datastructures the notion of graph types is a very similar notion where again datastructure invariants are defined using a but where edges are defined using regular path expressions graph types can be modeled directly in our framework in fact our formalism is more powerful the framework of recursively defined datastructures is also interesting because they define classes of graphs that have a decidable monadic secondorder theory in other words given a class c of recursively defined datastructures the satisfiability problem for mso formulas over c ie the problem of checking given whether there is some structure r c that satisfies is decidable the decision procedure works by interpreting the mso formula on the of the structures in fact our framework can capture all graphs definable using grammars which are one of the most powerful classes of graphs known that have a decidable mso theory graphs and monadic secondorder logics a labeled directed graph g over a finite set of lv and a finite set of edge labels le is a tuple g v e lv le where v is a nonempty finite set of nodes e v × v is a set of edges v lv assigns a subset of labels to each vertex and e le assigns a subset of labels to each edge monadic secondorder logic mso on graphs over the labels lv le is the standard mso on structures of the form u e where u represents the universe e is a binary relation capturing the edge relation qa is a monadic predicate that captures all nodes whose labels contain a and eb is a binary relation that captures all edges whose label contain b note that eb e for every b le however we also allow boolean variables and quantification over them let us fix a countable set of firstorder variables f v firstorder variables will be denoted by s t etc and a countable set of sv will be denoted by s t etc let us also fix a countable set of boolean variables bv denoted by p q etc the syntax of the logic is p es t t s t s s ¬ s p s where a lv b le s t f v s sv and p bv recursively defined datastructures let be a finite alphabet for any k n let k denote the set k classical definitions of mso do not allow such boolean quantification but we will find it useful in our setting these variables can be easily removed eg instead of over a boolean variable p we can quantify over a set x and convert every occurrence of p to a formula that expresses that x is empty a labeled tree is a pair v where v k and v is nonempty and and v the edges of the tree are implicitly defined that is ui is the ith child of u for every u ui v where u k and i k trees are seen as graphs with labeled vertices and edge relations y that define the edges monadic secondorder logic over trees is the mso logic over these graphs formally we define classes of recursively defined datastructures as follows definition a class c of recursively defined datastructures is specified by a tuple r t r u where t r is an mso sentence u is a unary predicate defined in mso and each a and b are monadic and binary predicates defined using mso where all mso formulas are over trees for some k n let r t r u and t be a labeled tree then t v defines according to r a graph n e lv le defined as follows · n s v u s holds in t · e s s bs s holds in t for some b le · s a lv as holds in t · s s b le bs s holds in t the class of graphs defined by r is the set t t r example let us define a class of recursive datastructures that consists of trees where the leaves of the tree are connected by a linked list the class of trees will be the class of binary trees with edges e and e representing left and relations and we define the relation for the list using an mso predicate t z z z ez z s t where is a that checks if x is a leaf and y and y is a formula that checks if y is in the rightmost leftmost respectively path from x strand a logic over heap structures and data definition of strand we now introduce our logic strand structure and data strand is a logic interpreted on program heaps with both locations and their carried data given a firstorder theory d of sort data and given l a monadic secondorder mso theory over lv graphs of sort loc the syntax of strand is presented in figure strand is defined over the signature d l data where data is a function of sort loc data strand formulas are of the form y where x and y are and respectively of sort loc we also refer to both as is an mso formula with atomic formulas of the form either e en or v vn e en is an atomic in which the data carried by can be referred as or v vn is just an atomic formula from l note that additional variables are allowed in x y both firstorder and secondorder but e en is only allowed to refer to x and y a model for strand is a structure m is an ie a labeled graph with as the underlying set of nodes and is a with as the underlying set is an interpretation for the function data of sort the semantics of strand formulas is the natural extension of the logics l and d x loc y loc z loc variable v x y z set variable s loc constant c function g expression formula formula e c ge en e en v vn ¬ z z s s y x figure syntax of strand we will refer to an as a a of a graph model is a strand model undecidability strand is an expressive logic as we will show below but it is undecidable in general even if both its underlying theories d and l are decidable let d be linear integer arithmetic and l be the standard mso logic over lists it is easy to model an execution of a counter machine using a list with integers each configuration is represented by two adjacent nodes which are labeled by the current instruction the data fields of the two nodes hold the value of the two registers respectively then a halting computation can be expressed by a strand formula hence the satisfiability of the strand logic is undecidable even though the underlying logics l and d are decidable examples we now show various examples to illustrate the expressiveness of strand we sometimes use d instead of data for brevity example binary search tree in strand a binary search tree is interpreted as a binary tree data structure with an additional key field for each node the keys in a are always stored in such a way as to satisfy the property expressed in strand as follows y y z z y y y z z y yy y y dy dy y y dy dy note that has an existentially quantified variable z in after the universal quantification of y y however as z is a structural quantification whose cannot be referred to this formula is in strand example two disjoint lists in separation logic a novel binary operator or separating conjunction is defined to assert that the heap can be split into two disjoint parts where its two arguments hold respectively such an operator is useful in reasoning with frame conditions in program verification thanks to the powerful expressiveness of mso logic the separating conjunction is also expressible in strand for example head tail head tail states in separation logic that there are two disjoint lists such that one list is from head to tail and the other is from head to tail this formula can be written in strand as s heads heads head tail head tail z z tail z s z z tail z s where s s z s deciding strand fragments removing existential quantification given a strand formula y over a class of recursively defined datastructures r t r u we can transform this to an formula xy x y over a different class of recursive datastructures r where datastructures in r are datastructures in r with new unary predicates that give a valuation for the variables in x we define this formally but this is an easy transformation we modify t r to accept trees with extra ai that give an arbitrary singleton valuation of each xi x that satisfies u and introduce new unary predicates v and define x y to be iv x y it is easy to see there is a graph in that satisfies y iff there is a graph in that satisfies xy x y the latter is a strand formula with no existential quantification of variables whose data is referred to by the formula let us refer to these formulas with no leading existential quantification on as universal strand formulas we will now outline techniques to solve the satisfiability problem of a certain class of universal strand formulas let us fix a class of recursively defined datastructures r t r u for the rest of this section we first need to define the notion of of a model the definition of a will depend on the particular class of recursively defined datastructures we are working with since we want to exploit the of the models which in turn will play a crucial role in deciding fragments of strand as it will allow us to check in fact we will define the relation between trees that satisfy t r definition let t v be a tree that satisfies t r and let s v then we say that s is a valid subset of v if the following hold · s is nonempty and closed ie for any s s s the least common ancestor of s and s in t also belongs to s · the subtree defined by s denoted s is the tree with nodes s and where the ith child of a node u s is the unique node u s to u that is in the subtree rooted at the ith child of u this is uniquely defined since s is closed then we require that s also satisfies t r · we also require that for every s s if u s holds in s then u s holds in t as well a tree t v is said to be a of t v if there is a valid subset s of v such that t is isomorphic to s note that a is necessarily a valid datastructure intuitively t v is a of t v if the vertices of t can be embedded in t preserving the the nodes of the are a subset of the nodes of because of the last condition in the definition of a and given a valid subset s there is in fact an injective mapping from the nodes of to for technical convenience we will work with valid subsets mostly as the precise embedding helps in the decision procedures structural abstractions of strand formulas let y y be a universal strand formula we now define the structural abstraction of as follows let r be the atomic relational formulas of the in note that each of these relational formulas will be over the data fields of variables in y only since the is restricted to working over the terms where y y consider evaluating over a particular model after a particular valuation of y notice that the i get all fixed and evaluate to true or false moreover once the values of i are fixed the rest of the formula is purely structural in nature now if is to hold in the model then no matter how we choose to evaluate y over the nodes of the model the i relations must evaluate to true or false in such a way that holds since we want in the first phase to ignore the entirely we will abstract using a purely structural formula by using boolean variables b br instead of the r however since these boolean variables get determined only after the valuation of y gets determined and since we are solving for satisfiability we existentially quantify over these boolean variables and quantify them after the quantification of y formally definition let y y be a universal strand formula and let the atomic relational formulas of the that occur in be r then its structural abstraction b is defined as the pure mso formula on graphs y b br y b where is with every occurrence of i replaced with bi for example consider the formula sorted from example then yy b y y b note that each boolean variable bi replaces an atomic relational formula i where i places some on the of some of the universally quantified variables the following proposition is obvious it says that if a universal strand formula is satisfiable then so is its structural abstraction b the proposition is true because the values for the boolean variables can be set in the structural abstraction precisely according to how the relational formulas i evaluate in proposition let yy be a universal strand formula and b be its structural abstraction if is satisfiable over a set of recursive datastructures r then the mso formula on graphs with no constraints on data b is also satisfiable over r the definition of structural abstractions can be in two ways first if i and j are of the same arity and over z and z respectively and further uniformly replacing zi with zi in i yields then we can express the constraint zi zi bi bj in the inner formula second if a constraint i involves only existentially quantified variables in x then we can move the quantification of bi outside the universal quantification doing these steps gives a more accurate structural abstraction and in practice restricts the number of models created we use these more precise abstractions in the experiments but use the less precise abstractions in the theoretical the proofs in this section however extend to the more precise abstractions we are now ready to define using structural abstractions given a model defined by a tree t v satisfying t r and a valid subset s v and a universal strand formula we would like to define the notion of when the defined by s in the model the most crucial requirement for the definition is that if s in t then we require that if there is a of that satisfies then the nodes of the defined by s s can inherit the and also satisfy the notion of structural abstractions defined above allows us to define such a notion intuitively if a model satisfies then it would satisfy b too as for every valuation of y there is some way it would satisfy the atomic and using this we can out a valuation for the boolean variables to satisfy b as in the proof of proposition above now since the in the are inherited from the larger model the atomic would hold in the same way as they do in the larger model however the may not satisfy if the conditions on the truth and of these atomic relations by are not the same for example consider a list and a of it consider a formula that demands that for any two successor elements y y in the list the of y is the of y by as in the successor example in section yy y y dy dy now consider two nodes y and y that are successors in the but not successors in the list the list hence could satisfy the formula by setting the dy dy to false since the inherits the data values would be false in the as well but the will not satisfy the formula we hence want to ensure that no matter how the larger model satisfies the formula using some valuation of the atomic the will be able to satisfy the formula using the same valuation of the atomic this leads us to the following definition definition let y y be a universal strand formula and let its structural abstraction be b y b y b let t v be a tree that satisfies t r and let a be defined by s v then s is said to embed into t wrt if for every possible valuation of y over the elements of s and for every possible boolean valuation of b if y b holds in the graph defined by t under this valuation then the defined by s s also satisfies y b under the same valuation the embedding relation can be seen as a partial order over trees a tree t into t if there is a subset s of t such that s into t and s is isomorphic to t it is easy to see that this relation is reflexive and transitive it is now not hard to see that if s into t wrt and satisfies then t s also necessarily satisfies which is the main theorem we theorem let yy be universal strand formula let t v be a tree that satisfies t r and s be a valid subset of t that into t wrt then if there is a of that satisfies then there is a of s that satisfies notice that the above theorem depends on the formula being universal over for example if the formula was of the form y then we would have no way of knowing which nodes are used for y in the of to satisfy the formula without knowing the precise meaning of the we would not be able to declare that whenever a of is satisfiable a of a strict s is satisfiable even over lists the above notion of satisfiability preserving is the property that will be used to decide if a formula into our decidable fragment a semantic decidable fragment of strand we are now ready to define the most general decidable fragment of strand in this paper this fragment is semantically defined but syntactically as we show below and intuitively contains all strand formulas that have a finite number of minimal models with respect to the partialorder defined by formally let yy be a universal strand formula and let t v be a tree that satisfies t r then we say that t is a minimal model with respect to if there is no strict valid subset s of v that in t definition let r be a recursively defined set of datastructures a universal formula y y is in iff the number of minimal models with respect to r and is finite a strand formula of the form x y x y is in iff the corresponding universal formula over set of datastructure r as defined in section is in we now show that we can effectively check if a strand formula belongs to the decidable fragment the idea intuitively is to express that a model is a minimal model with respect to and then check using automata theory that the number of minimal models is finite let yy be universal strand formula and let its structural abstraction be b y b y b we now show that we can define an mso formula such that it holds on a tree t v iff t defines a minimal model with respect to before we do that we need some technical results and notation let r t r u we first show that any pure mso formula on lv graphs can be interpreted on trees formally we show that any pure mso formula on lv graphs can be transformed syntactically to a pure mso formula on trees such that for any tree t v satisfies iff t satisfies this is not hard to do since the graph is defined using mso formulas on the trees and we can adapt these definitions to work over the tree instead the transformation is given by the following function interpret the predicates for edges and the predicates that check vertex labels and edges labels are transformed according to their definition and all quantified variables are restricted to quantify over nodes that satisfy u · p · was for every a lv · t ble bs t · t bs t for every b le · t s t · w s w · interpret interpret interpret · · su s interpret · w u it is not hard to show that for any formula on lv graphs satisfies iff t satisfies interpret now we give another transformation that transforms an mso formula on trees to a formula x on trees over a free x such that for any tree t v and any valid subset s v s satisfies iff t satisfies x when x is interpreted to be s in other words we can transform a formula that expresses a property of a subtree to a formula that expresses the same property on the subtree defined by the free variable x the transformation is given by the following function the crucial transformation are the which has to be interpreted as the edges of the subtree defined by x · p p · for every a lv · t s ei s s s t t t x s t t t for every i k · s t s t · s w s w · · ¬ · s ss x · w ww x the above transformation satisfies the following property for any mso sentence on trees for any tree t v and for any valid subset s v s satisfies iff t satisfies when x is interpreted to be s note that the above transformations can be combined for any mso formula on lv le labeled graphs consider the formula interpret then for any tree t v and for any valid subset s v s satisfies iff t satisfies interpret where x is interpreted as s expressing minimal models in mso first we can also express with an mso formula with a free set variable x that holds in a tree t v iff x is interpreted as a valid of t s t u s x t x t u u tr ss x u s u s where t u is an mso formula that checks whether u is the ancestor of s and t in the tree this expresses the requirements in definition we are now ready to define the mso formula on trees that captures minimal models let the structural abstraction of be b y b y b then ¬x ss x ss x y b x u y interpret y b interpret y b the above formula when interpreted on a tree t says that there does not exists a set x that defines a nonempty valid strict subset of the nodes of t which defines a model x that further satisfies the following for every valuation of y over the nodes of s and for every valuation of the boolean variables b such that the structural abstraction of holds in the same valuation also makes the structural abstraction of hold in s note that the above is a pure mso formula on trees and encodes the properties required of a minimal model with respect to using the classical connection we can transform the mso formula t r b to a tree automaton that accepts precisely those trees that define datastructures that satisfy the structural abstraction and are minimal models since the of the language accepted by a tree automaton is decidable we can check whether there are only a finite number of minimal models wrt and hence decide membership in the decidable fragment theorem given a sentence xy x y the problem of checking whether the sentence belongs to the fragment is decidable in fact we develop using the tool the decision procedure above see section deciding formulas in we now give the decision procedure for satisfiability of in over a recursively defined class of datastructures first we transform the satisfiability problem to that of satisfiability of universal formulas of the form y y then using the formula described above and by transforming it to tree automata we extract the set of all trees accepted by the in order to get the of all the minimal models note that this set of minimal models is finite and the sentence is satisfiable iff it is satisfiable in some of one of these models we can now write a quantifierfree formula over the that asserts that one of the minimal models has a that satisfies this formula will be a disjunction of m m where m is the number of minimal models each formula i will express that there is a of the ith minimal model that satisfies first since a minimal model has only a finite number of nodes we create one for each of these nodes and associate them with the nodes of the model it is now not hard to transform the formula to this model using no quantification the universal quantification over y translates to a conjunction of formulas over all possible valuations of y over the nodes of the fixed model existential universal quantified variables are then expanded using disjunction conjunction respectively of formulas for all possible valuations over the fixed model the between nodes in the model are interpreted on the tree using mso formulas in r which are then expanded to conditions over the fixed set of nodes in the model finally the in the strand formula are directly written as constraints in the the resulting formula is a pure formula without quantification that is satisfiable if and only if is satisfiable over r this is then decided using the decision procedure for the theorem given a sentence xy x y over r in the problem of checking whether is satisfiable reduces to the satisfiability of a quantifierfree formula in the since the quantifierfree is decidable the satisfiability of formulas is decidable a syntactic decidable fragment of strand we the semantically defined decidable class in the previous section to define a logic that has a simple syntactic restriction and is entirely decidable the decidable fragment allows only formulas of the kind xy where has no further quantification moreover some of the structural edge relations r on the datastructure are classified as relations in relations are allowed to relate any pair of variables while relations are allowed only to relate existentially quantified variables in x a relation r is if intuitively for any model m and a m of m r holds on a pair of nodes of m iff r holds for the corresponding pair of nodes in m more formally let us fix a class of recursively defined datastructures r t r u let eb denote the defined by b then we say eb is if the following holds for every tree t v satisfying t r for every valid subset s of v and for every pair of nodes u v in the model m s v holds in m iff v holds in for example over trees the relation relating a node with any of its descendants is an relation however the relation that relates a node to its parent is not as we can take two nodes u and v in a subtree subtrees t where u is the parent of v but u is not the parent of v in t we can express the property that rb is in mso over a particular tree t using the following formula us vs u v bu v v hence we can decide whether a relation is or not by checking the validity of the above formula over all trees satisfying t r the syntactic decidable fragment is defined as the class of all strand formulas of the form xy such that a has no quantification b every occurrence of an atomic relation in is of the form rz z where either r is an relation or z and z are in x or are constants we can now show theorem over any class of recursively defined structures r is decidable we omit the proof for lack of space its is as follows when all relations are for any valid subset s holds on any valuation of variables over s iff holds on the same valuation over t since the atomic relations are hence the can always inherit the from the model to satisfy the formula the minimal models with respect to are hence a subset of the minimal models with respect to the which we can show is finite when all relations are not the proof is much more complex and relies on the fact that the relations define only a finite number of equivalence classes of relationships over x all of verification conditions in our experiments turn out to be in the syntactic decidable class program verification using strand in this section we show how strand can be used to reason about the correctness of programs in terms of verifying where the pre and postconditions express both the structure of the heap as well as the data contained in them the pre and postconditions that we allow are strand formulas that consist of boolean combinations of the formulas with pure existential or pure universal quantification over the ie boolean combinations of formulas of the form x and y let us call this fragment strand given a program p that does destructive and data updates we model a as a tuple r pre p post where the precondition is given by the datastructure constraint r with the strand formula pre and the postcondition is given by the strand formula p note that structural constraints on the datastructure for the postcondition are also expressed in post using mso logic in this section we show that given such a we can reduce checking whether the is not valid can be reduced to a satisfiability problem of a strand formula over a class of recursively defined datastructures rp this then allows us to use strand to verify programs where of course are given by the programmer which breaks down verification of a program to verification of code intuitively this reduction the structures in r with extra nodes that could be created during the execution of p and models the the program takes by logically defining the configuration of the program at each time instant over this we then express that the precondition holds and the postcondition fails to hold we also construct formulas that check if there is any memory access violation during the run of p eg locations twice dereferencing a null pointer etc syntax of programs let us define the syntax of a basic programming language manipulating heaps and data more complex constructs can be defined by combining these statements appropriately let var be a countable set of pointer variables f be a countable set of structural pointer fields and data be a data field a condition is defined as follows for technical reasons are pushed all the way in cond p q p q p nil p nil where p q q qk var and is a predicate over data values the set of statements stmt defined over var f and data is defined as follows s stmt p new assume p nil p q pf q p qf where p q q qk var f f h is a function over data and is a condition a program p over var f and data is a non empty finite sequence of statements s s sm with si stmt the semantics of a program is the natural one and we skip its definition let r be a recursive datastructure pre post be two strand formulas and p s s sm be a program the configuration of the program at any point is given by a heap modeled as a graph where nodes of the graph are assigned data values for a program with m statements let us fix the configurations to be g gm the the idea is to capture the entire computation starting from a particular datastructure using a single datastructure the main intuition is that if we run p over a graph g graph r then a new class of recursive datastructures rp will define a graph which encodes in it g as well as all the graphs gi for every i m has the nodes of g plus m other fresh nodes these nodes will be used to model newly created nodes p creates as well as to hold new of variables that are assigned to in p each of these new nodes are pointed by a distinguished pointer variable initially these additional nodes are all in g we build an unary predicate that captures at each step i the precise set of active nodes in the heap to capture the pointer variables at each step of the execution we define a new unary predicate pi for each p var and i m similarly we create binary predicates fi for each f f and i m to capture structural pointer fields at step i the heap gi at step i is hence the graph consisting of all the nodes x of such that holds true and the pointers and edges of gi are defined by pi and fi predicates respectively formally fix a recursively defined datastructure r t r u f ff with a monadic predicate which evaluates to a unique nil node in the datastructure then its with respect to the program p is defined as rp t r u f ff where · t r is designed to hold on all trees in which the first subtree of the root satisfies t r and the second child of the root has a chain of m nodes where each of them is the second child of the parent · u holds true on the root on all the second child of the root and on all first child on which u holds true · var m var i m and new holds only on the root and holds true only on the i th of the second child of the root for every i m for every p var and i m p p and pi is defined as in figure · f f i m and for every f f and i m f f and fi is defined as in figure in figure the mso formulas pi and fi are derived in the natural way from the semantics of the statements except for the statement although the semantics for this statement does not involve any structural modification of the graph it changes only the data value associated p we represent this operation by making a new version of the node pointed by p in order to represent explicitly the change for the data value corresponding to that node we the node pointed by pi and the node pointed by all the edges in the graph and the pointers are to reflect this exchange of nodes in figure we also define two more mso formulas and which are not part of the where the first models the active nodes at step i and the second expresses when an error occurs due to the dereferencing of a variable pointing to respectively handling data constraints the rp captures all the structural modifications made to the graph during the execution p however data by assume statements and cannot be expressed in the as they are not expressible in mso we impose them in the strand formula we define a formula i for each statement index i m where if si is not an assume or a statement then i true otherwise there are two cases handling assume assignments if si is the statement assume then i is the strand formula obtained by the constraint to the ith stage of the this is not hard but is tedious and we skip its definition constraints on in the formula using constraints handling the strand formula i for a statement is i ex ex ik which translates si into strand making sure that it refers to the heap at step i pre and postconditions to the the last that we need is to express the strand formulas pre and the negation of the post on the rp more specifically we need to p new pi x x qi x qi x q var p fi x x y x false zi x zi x x x x x fi x y fi x y x y ex fi x ex pi ex x x x p nil x zi x zi x z var p fi x y fi x y p q pi x qi x zi x zi x z var p fi x y fi x y pf q zi x zi x z var fi x y x fi x y qi y gi x y gi x y g f f x x p qf ex qi ex fi ex x qi x qi x q var p fi x y fi x y gi x y gi x y g f f qi x x assume qi x qi x q var fi x y fi x y f f pi x x where var is the set of all variables occurring in pi x x qi x qi x q var p fi x y fi x y x y ex fi x ex pi ex x x x zi x x z figure predicates defining the new datastructure adapt pre to the for index which corresponds to the original graph ie the predicates p are replaced with p for every p var and the edge predicates f with f for every f f moreover whenever we refer to a node in the graph we need to be sure that node is active which can be done by using the predicate which holds true if x is in the first subtree of the root and u x holds a similar transformation is done for the formula where now we consider pointers edge labels and active nodes at the last step m let resp post rp be the strand formula corresponding to the adaptation of pre resp post reduction to satisfiability problem on the it is easy to see that an error occurs during the execution of p on a graph defined through r that satisfies pre if the following strand formula is satisfiable on the w rp v error ji j similarly the is not valid iff the following strand formula is satisfiable on the v jm j rp theorem let p be a program r be a recursive datastructure and pre post be two strand formulas over var f and data then there is a graph g graph r that satisfies pre and where either p terminates with an error or the obtained graph g does not satisfy post iff the strand formula error is satisfiable on the rp evaluation implementation in this section we demonstrate the effectiveness and of the decision procedures for strand by checking verification conditions generated in proving properties of several programs given preconditions postconditions and each linear block of statements of a program yields a which is manually translated into a strand formula over trees and integer arithmetic as a verification condition the decision procedure for strand implements the decision procedure for the semantically defined fragment given a strand formula our procedure will first determine if it is in the semantic decidable fragment and if not will halt and report that satisfiability of the formula is not when given a formula in the syntactic fragment this procedure will always succeed and the decision procedure will determine satisfiability of the formula the decision procedure consists of a structural phase where we determine whether the number of minimal models is finite and if so determine a bound on the size of the minimal models this phase is by using a monadic secondorder logic solver over strings and trees in the second solving phase the finite set of minimal models if any are examined by the z to check if they can be extended with to satisfy the formula instead of building an automaton representing the minimal models and then checking it for we check the formula using supported by which is a monadic secondorder logic over infinite trees with restricted to finite sets by over a finite universe u and transforming all to be interpreted over u we can interpret over all finite trees let us denote this as the condition can now be checked by if there exists a finite set b such that any minimal model for is contained within the nodes of b bound u u bound this formula has no and hence either holds on the infinite tree or not and can be checked by this formula evaluates to true iff the formula is in we also follow a slightly different procedure to synthesize the formula instead of extracting each minimal model and program verification condition structural solving in final states bdd times minimal models size yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes yes graph model exists no no no yes no no yes yes no no no no no yes no yes no no no no yes solving z with bound nodes formula size kb satisfiable times no no yes no no no figure results of program verification checking if there is a for it we obtain a bound on the size of minimal models and ask the to check for any model within that bound this is often a much simpler formula to to the in our current implementation the constraints are encoded manually and once the bound is obtained we write a program that outputs the z constraints for the verification condition and the bound the translation from strand to formulas and the translation from strand formulas to z formulas for any bound can be automated and is a plan for the future experiments figure presents the evaluation of our tools on checking a set of programs that manipulate sorted lists and binary search trees note that the binary search trees presented here are out of the scope of the logics and csl the programs and search and insert a node in a sorted list respectively while is the insertion program with an intended error the program reverse is a routine for reversal of a sorted list which results in a list and is the code for of a list the routines and search and insert a node in a binary search tree respectively while the programs and perform for in a binary search tree for all these examples a set of partial correctness properties including both structural and data requirements is checked for example assuming a node with value k exists we check if both and return a node with value k for we assume that the inserted value does not exist and check if the resulting list contains the inserted node and the property continues to hold in the program assuming the tree does not contain the inserted node in the beginning we check whether the final tree contains the inserted node and the property continues to hold in we check if the output list is a valid list that is the code for is checked to see if it results in a sorted list and the and codes are checked to see whether they maintain the property that maintain the binary property note that each program requires checking several verification conditions typically for the linear block from the beginning of the program to a loop for the loop invariant linear block and for the block from the loop invariant to the end of the program the experiments were on a gb machine running windows and the formulas and results are available at for the structural solving phase we report first whether the verification condition within our semantic decidable fragment in fact it turns out that all of our verification conditions can be written entirely in the syntactic decidable fragment s t r a n we also report the number of states the bdd sizes to represent automata and the time taken by to compute the minimal models we report whether there were any models found note that if the formula is unsatisfiable and there are no models the z phase is these are denoted by annotations in the table for z for the solving phase we first report the number of nodes of the tree or string that is an upper bound for all minimal models the z formulas are typically large but simple as one can see from the size of the formulas in the table we report whether z found the formula to be satisfiable or not all cases were unsatisfiable except as the verified were correct and the time it took to determine this the experimental results show that natural verification conditions tend to be expressible in the syntactic decidable fragment moreover the expressiveness of our logic allows us to write complex conditions involving structure and data and yet are handled well by and z we believe that a engineering of an smt solver for that answers queries involving heap structures and data is a promising future direction towards this end an efficient theoretic decision procedure unlike that uses search techniques like sat instead of representing the class of all models like bdds and automata may yield more efficient decision procedures related work we first discuss related work that can reason with combinations of heaps and data in handling heaps firstorder theories that can reason with restricted forms of the reachability relation for ensuring decidability are the most common the work most closely related to our work is the logic in called that offers a reasoning with generic heaps combined with an arbitrary the logic has restricted reachability predicates and universal quantification but is syntactically to obtain decidability we find the restrictions on the syntax quite with restrictions in the logic furthermore the logic cannot handle even simple constraints over trees with unbounded depth where the nodes are of the same sort like a tree being a binary search tree however the logic is extremely efficient as it uses no structural solver but translates the also to the boolean aspect of the smt solver we a lot of insight into decidability by studying the expressive power of and we believe that strand generalizes some of the underlying ideas present in to a much more powerful technique for decidability the logic csl has a similar as with similar on the syntax but generalizes to handle linked lists and allows size constraints on structures the work reported in gives a logic that extends an syntax to define certain decidable logic fragments on heaps et al propose an inference rule system for reasoning with restricted reachability but this logic does not have universal quantification and cannot express disjointness constraints and an smt solver based implementation has been reported restricted forms of reachability were first in early work by nelson several mechanisms without quantification exist including the work reported in automatic decision procedures that approximate higherorder logic using firstorder logic using approximate logics over sets and their have been proposed there is a rich literature on heap analysis without data since firstorder logic over graphs is undecidable decidable logics must either restrict the logic or the class of graphs the work to ours in this is which restricts structures to be definable over similar to strand and reduces problems to the system several approximations of firstorder of reachability have been proposed axioms capturing local properties a logic on regular patterns that is decidable among others finally separation logic has as a convenient logic to express heap properties of programs and a decidable fragment without data on lists is known however not many extensions of separation logics handle data constraints see which combines this logic for linked lists with arithmetic acknowledgments we thank for the discussions we had when we started this project a few years back this work is partially by nsf and project references i a pnueli and l d shape analysis by predicate abstraction in volume of lncs pages ­ springer t ball r majumdar t and s k rajamani automatic predicate abstraction of c programs in pldi pages ­ acm m by e r b and k r m leino a modular verifier for objectoriented programs in volume of lncs pages ­ springer j berdine c calcagno and p w ohearn a decidable fragment of separation logic in volume of lncs pages ­ springer n and j linear functional in cav volume of lncs pages ­ springer e e and y the classical decision problem springer a c c and m a framework for reasoning about composite data structures in concur volume of lncs pages ­ springer l m de and n deciding effectively propositional logic using and substitution sets in volume of lncs pages ­ springer l m de and n z an efficient smt solver in tacas volume of lncs pages ­ springer j contextfree graph grammars in of formal languages volume pages ­ springer c flanagan k r m leino m g nelson j b and r extended static checking for java in pldi pages ­ acm p n and k dart directed automated random testing in pldi pages ­ acm n and a department of computer science university january available from n and m i graph types in popl pages ­ acm v modular data structure verification phd thesis massachusetts institute of technology s and s qadeer back to the future precise program verification using smt solvers in popl pages ­ acm t and s sagiv a system for implementing static analyses in sas volume of lncs pages ­ springer s p lee and yk a tool for reasoning about shape and arithmetic in cav volume of lncs pages ­ springer s and g c necula data structure specifications via local equality axioms in cav volume of lncs pages ­ springer a and m i the pointer assertion logic engine in pldi pages ­ acm g nelson verifying reachability invariants of linked structures in popl pages ­ acm g nelson and d c simplification by decision procedures acm trans program lang syst ­ z j d and a j hu an decision procedure for verification of programs with mutable data and cyclic data structures in volume of lncs pages ­ springer z r a j hu and a verifying programs in an smt framework in volume of lncs pages ­ springer s and c a theory of lists and its extensible decision procedure in pages ­ j reynolds separation logic a logic for shared mutable data structures in lics pages ­ g t w reps and s sagiv symbolically computing abstract operations for shape analysis in tacas volume of lncs pages ­ springer g a m m sagiv a meyer and a a logic of reachable patterns in linked datastructures in volume of lncs pages ­ springer 