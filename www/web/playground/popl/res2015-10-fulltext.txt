drex a declarative language for efficiently evaluating regular string transformations university of pennsylvania complete popl consist well easy to abstract we present drex a declarative language that can express all regular transformations and can still be efficiently evaluated the class of regular string transformations has a robust theoretical foundation including multiple closure properties and decidable analysis questions and admits a number of string operations such as insertion deletion substring swap and reversal recent research has led to a characterization of regular string transformations using a primitive set of function combinators analogous to the definition of regular languages using regular expressions while these combinators form the basis for the language drex proposed in this paper our main technical focus is on the complexity of evaluating the output of a drex program on a given input string it turns out that the natural evaluation algorithm involves dynamic programming leading to complexity that is in the length of the input string our main contribution is identifying a consistency restriction on the use of combinators in drex programs and a evaluation algorithm for consistent programs with time complexity that is linear in the length of the input string and polynomial in the size of the program we show that the consistency restriction does not limit the expressiveness and whether a drex program is consistent can be checked efficiently we report on a prototype implementation and evaluate it using a representative set of text processing tasks categories and subject descriptors d language specialized application languages f theory of computation models of computation automata keywords drex string transformations declarative languages introduction programs that transform plain text are and used for many different tasks from documents to translating data between different formats string specific such as a prototype implementation of drex may be from http this research was partially supported by nsf in computing grant permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm and have been used to query and text files for many years since these tools are turing complete they can express very complex transformations however this comes at the cost of not being amenable to algorithmic analysis to address this issue restricted languages have been proposed in the context of verification of string sanitizers and string and for the analysis and optimization of programs these languages build on variants of finitestate transducers which are representations of programs mapping strings to strings and each of these languages supports different algorithmic analyses that are enabled by the properties of the underlying transducer model due to the focus on expressiveness is a limiting factor in all such languages and many programs in particular those that input chunks cannot be represented moreover these languages are not declarative and their semantics are coupled to the transducer model forcing the programmer to reason in terms of finite state machines and process the input lefttoright in the theory of transformations the class of regular string transformations is a robust class that a balance between decidability and expressiveness in particular this class captures transformations that involve reordering of input chunks it is closed under composition it has decidable equivalence and has several equivalent such as transducers with a finite set of registers transducers and monadic secondorder definable graph transformations recently et al proposed a set of combinators that captures the class of regular string transformations in the focus is on expressiveness and the paper does not provide an efficient procedure to evaluate programs written with these combinators efficient evaluation of such programs is the main focus of this paper starting with the combinators presented in we develop drex an expressive declarative language to describe string transformations the base combinator of drex d maps any character a that satisfies the predicate to the string da this combinator symbolically extends the one proposed in with predicates and can therefore model strings over large and potentially infinite alphabets such as the other combinators supported by drex are a g that splits the input string into two parts and outputs the concatenation of the results obtained using f on the first part and g on the second part b that splits the input string into multiple parts and outputs the concatenation of evaluating f on each of such parts c g that applies both f and g to the input string and the obtained results d the conditional f else g that first tries to apply f to the input and if f cannot be applied it applies g e r that splits the string into multiple parts n each belonging to the language described by the regular expression r applies f to every two pair of adjacent chunks ii and finally these results in order to model operations such as a string the operators split iteration and sum also have a version in which the outputs computed on each split of the string are in reverse order a straightforward algorithm to evaluate drex programs involves the semantics ie use dynamic programming and evaluate each subprogram on each substring of the input unfortunately this algorithm takes time in the length of the input string and does not scale to strings longer than approximately a characters because of the analogy between drex operators split sum conditionals iteration etc and regular expressions concatenation union kleene etc one approach is to construct an automaton model for evaluating drex programs similarly to the approach taken to evaluate regular expressions this is not simple because of various reasons such as a the conditional operator f else g applies the transformation g to the input only if the input string is not accepted by f to check whether a string is in the complement of the domain of f one needs to the domain automaton and this is an exponential time operation and b the operator g is only defined on the intersection of the domains of f and g automata intersections multiple times also causes an exponential the main technical challenge is to identify a fragment of drex which does not expressiveness and still permits fast evaluation algorithms we call this subset of drex the consistent fragment intuitively we require each operator to admit unambiguous parsing and limit the operators ability to express the complement and intersection of languages for example g is consistent iff the domains of f and of g are ie there is no string with multiple splits in the case of a conditional f else g the domains of f and g are required to be disjoint making the of the domain of f unnecessary similarly for the operator g we require the domains of f and g to be identical so that the domain of the entire program is equal to the domain of its subexpressions and no language intersection is required for the r operator to be consistent the language r is required to be unambiguous and f is required to be a split operator for which both the left and right hand sides are exactly defined on the language described by r we show that consistency of a drex program can be efficiently determined we present an algorithm that evaluates a consistent drex program f on an input string in time polynomial in the size of f and linear in the length of intuitively we construct a machine for each subprogram which reads the input in a single lefttoright pass each machine keeps track of potential parse trees of as multiple threads and updates the threads on reading each input symbol the goal of the algorithm is to have a number of threads that is linear in the size of the program but does not depend on the length of the input string this bound is achieved using the consistency requirements to kill threads whenever they become for example the machine for g outputs a result as soon as it a single split of the input string since the consistency rules guarantee the absence of any other split if the program were not consistent the machine would need to delay the output causing the number of threads to depend on the length of the string similarly the machine for f else g can output the results of g whenever this is defined because of the requirement that f and g have disjoint domains and cannot simultaneously emit results we also present a dynamic programming algorithm that can handle all drex programs but is limited by its time complexity in the length of the input string we implemented our evaluation and algorithms and evaluated them on several text transformations deletion of comments from a program insertion of around words tag extraction from xml documents dictionaries and the reordering and of fields in files the evaluation algorithm for consistent drex to large inputs less than for seconds for characters while the dynamic programming algorithm due to the complexity in the size of the input does not scale in practice more than seconds for characters and therefore has limited applicability finally the algorithm is very fast in practice less than seconds for programs of size subexpressions and it is also very helpful in identifying sources of ambiguity in the implemented programs in summary we offer the following contributions drex a language for describing string transformations that extends the combinators proposed in to model strings over arbitrary sorts and consistent drex a fragment of drex that admits efficient evaluation without expressiveness section an algorithm for evaluating consistent drex programs in a single lefttoright pass that is linear in the size of the input string and polynomial in the size of the program section a dynamic programming algorithm for evaluating unrestricted drex programs that has time complexity in the length of the input string section a proof that adding a composition operator to drex causes the evaluation problem to become and the dynamic programming algorithm to run in time exponential in the size of the program section and an implementation of drex together with an evaluation of our algorithms on practical string transformations section the syntax and semantics of drex regular combinators for string transformations given a character a and an output string d the function a d maps the input string a to the output d and is undefined for all other inputs a d d if a and otherwise another basic function is d which maps the empty string to the output d and is undefined everywhere else the final basic function bottom is undefined for all input strings the split sum operators are the counterparts of concatenation in regular expressions given an input string if there exists a unique split such that both f and f are defined then f f f and f f f for all other inputs where there is either no split or multiple splits both functions are undefined note the on a unique parse tree this is so that programs define functions rather than relations given two drex functions f and f the function f else f first tries to apply f and if this fails applies f f else f f if f and f otherwise this is the unambiguous counterpart of the union operator of traditional regular expressions we adopt the convention of saying f x when f is undefined for the input x and write a for a when a similarly if both f and f are defined then f f f if either function is undefined for the input f is undefined as well this combinator can be used to make multiple passes over the input string and a typical example would be the function that copies the input string twice transformed into in terms of the input domain the operator combine is the counterpart of intersection in regular languages and is necessary to achieve expressive parity with regular string transformations because of the of string concatenation if f is a drex program and the input string can be uniquely split into n with n and such that f i for each i then f f f n and f n f n f otherwise if the input cannot be split or if multiple splits exist then both iterated sums are undefined this is the counterpart of kleene of regular expressions the sum operator allows us to mix outputs produced by different parts of the input string this is a new operator without a regular expression counterpart and is necessary for expressive completeness let r be a regular expression that defines the language r l and f be a drex program given an input if there is a unique split n such that i l for each i then if n r f f f nn and r f nn f nn f for notational convenience we treat and so if f ii is undefined for any i both functions are undefined furthermore if a unique split of the input string does not exist both the and sums are undefined notice that the regular expression r in r defines the split of the input string and f is applied to each pair of adjacent splits the final operator is function composition if f and f are drex programs such that f and f are partial functions f is defined as f f f with the notational convention that f recall that regular string transformations can be defined in multiple equivalent ways as finite state transducers as streaming string transducers and as graph transformations we summarize the main result of theorem expressive completeness for every finite input alphabet and output alphabet every regular string transformation f can be expressed by a drex program more precisely when we include the sum function composition is unnecessary for expressive completeness while the sum can itself be expressed using function composition and so if composition is included the sum is unnecessary character sorts and predicates consider the basic combinator a d we described in the previous subsection which maps the input a to the output d for large alphabets such as the set of all characters this approach of explicitly each character does not scale basic transformations in drex may therefore also reference symbolic predicates and character functions as we will now describe this is inspired by the recent development of symbolic transducers which has proved to be useful in several practical applications let be a collection of character sorts for each character sort we pick a possibly infinite collection of predicates p such that a p is closed under the standard boolean operations for each p ¬ p and b the satisfiability of predicates is decidable given p whether there exists an x such that x holds is decidable a simple example is the sort a b together with the set of predicates p x a x b true false another example is the set of all integers z and with pz true false we will write u for the set of all characters with the various character properties pu if p and d d d dk is a list of character transformations ie di then d is a basic transformation which maps every string which satisfies to the output string dd dk and is undefined for all other strings for example the function transforms every character to while the function xx outputs two copies of an character the function x x transforms a nonnegative integer by one from it given an input x the function x x from it note that the basic symbolic transformations can still only operate on individual characters in isolation and cannot relate properties of adjacent characters for example we do not allow transformations such as x y x x y which outputs two consecutive symbols x and y if x and y x it is known that allowing such predicates makes several analysis questions undecidable consistent drex programs we now define consistent drex a restricted class which still captures all regular string transformations but for which we can provide an efficient evaluation algorithm section intuitively we restrict each operator to only allow unambiguous parsing and limit the operators ability to express expensive automata operations such as intersection and complement since the purpose of the consistency rules is for the correctness of the evaluation algorithm we defer their motivation to subsection consistent unambiguous regular expressions the consistency rules we propose are based on the notion of consistent unambiguous regular expression are similar to conventional regular expressions but with the additional guarantee that all matched strings have unique parse trees unambiguous regular expressions have been studied in the literature we explicitly them as consistent here to emphasize that there are no strings with multiple parse trees they are defined inductively as follows and are the language associated with is the empty set and the language associated with is the singleton for each satisfiable predicate p is a the language associated with the is the set of all strings x x holds for each pair of nonempty r and r if the associated languages l r and l r are disjoint then r r is also a and r r l l given a pair of nonempty r and r we say that they are if for each string there is at most one split such that r and r if r and r are then r · r is also a and r · r r r a nonempty r is if for every string there is at most one split n into such that i r for each i if r is then r is also a and r r for example the regular expressions and ¬ are for every character predicate every string matching · ¬ has to be split after the first character on the other hand is not with itself there are three ways to parse the string aa in · because the left part of the concatenation can either match a or aa the regular expression is unambiguous there is only one way to split each string such that each substring is in but is not unambiguous we call two r and r equivalent and write r r if r r consistency rules a consistent drex program is one that satisfies the rules defined in this section one major effect of these rules is to guarantee that no string has multiple parse trees so the word unique in the definitions of subsection is unnecessary the domain of a drex program f is the set containing every string such that f is defined in the following rules we assign each consistent drex program a domain type which is a representation of its domain as a most of the consistency rules are straightforward except for sum and combine recall from the definition of chain that for r to be defined on a string we must have a split n with n therefore the domain type of r requires at least two matches of r r · r · r next we want expressions of the form f fk r · r where r is with itself and the domain type of each is r to be consistent we therefore pay special attention to the rule for combine all basic functions bottom d and d where is satisfiable are consistent their domain types are and respectively if f and f are both consistent and have domain types r and r respectively then f and f are also both consistent and have the domain r · r if f is consistent and has domain type r and r is then and are both consistent with domain r if f and f are consistent with disjoint domain types r and r respectively then f else f is also consistent with the domain r r if f is consistent and has domain type r · r such that r r r where r is an then r and r are both consistent and have the domain r · r · r if f and f are consistent with domain types r and r respectively and r r then f is also consistent depending on the syntactic structure of the to be consistent with the classic notation we write do denote the that accepts all possible input characters but formally in our definition the corresponding is the predicate true r and r the domain type of f is defined as follows a if r r and r r with r r r r then the domain type of f is r b otherwise if r is not of the form r · r with r r then the domain type is r c otherwise the domain type is r we now the claim originally made in theorem while consistency was not an explicit goal in the original proof of theorem it is the case that every expression constructed was actually consistent and we can therefore state theorem for every finite input alphabet and output alphabet every regular function f can be expressed by a consistent drex program the consistency and domain computation rules are syntaxdirected and straightforward to implement directly we need to be able to answer the following basic questions about unambiguous regular expressions given r and r are r and r given a r is it given r and r are they disjoint or equivalently is r r also a observe that the traditional algorithm to convert regular expressions to converts unambiguous regular expressions to unambiguous where each accepted string has exactly one accepting path whether a regular expression r is unambiguous can therefore be checked in polynomial time take the product of the corresponding transition free nfa ar with itself and check for the presence of a reachable state q q with q q which can itself reach a pair of accepting states qf qf f × f where f is the set of accepting states of al thus if the input alphabet is finite these questions can be in polynomial time otherwise the same problems for symbolic automata representing r r etc are also decidable in polynomial time assuming that we can check in polynomial time whether a predicate is satisfiable given r and r is r r if is finite then from we have that this can be checked in time r otherwise if are expressed using the symbolic notation of section they can be translated into symbolic automata and the equivalence of symbolic automata is decidable in polynomial time in the size of r and r and exponential in the number of predicates appearing in r and r theorem given a drex program f over an input alphabet checking whether f is consistent is decidable furthermore if the input alphabet is finite then the consistency of f can be determined in time note specifically that programs involving function composition are not consistent in the rest of this paper to distinguish the class of consistent drex programs from the class of all drex programs we will the latter as the unrestricted class the algorithm proposed in can check in polynomial time whether two unambiguous are equivalent the algorithm requires the alphabet to be finite and using the generation technique proposed in one can make a symbolic alphabet finite by constructing the boolean combinations of the predicates in the automaton this operation however can cause an exponential examples of consistent drex programs the simplest nontrivial drex program is the identity function id x several variations of this program are also useful maps strings of characters to and x is the identity function restricted to strings not containing a space more interesting functions can be constructed using the conditional operator the function else the case of a single input character and so switches the case of each character in the input string given a string of the form the function outputs similarly the function which outputs the last name could be written and the two can be combined into which outputs note that the space in between is omitted the expression preserves this space an example of the use of the operators is in string reversal the function x the input string finally to present an example of the sum combinator we consider the situation of in files assume that by the title of the first entry appears in the second entry the title of the second entry appears in the third entry and so on let be the unambiguous regular expression matching a entry let be the drex program which pairs of adjacent entries and outputs the title of the second entry and all other fields from the first entry then the text in the input file we now outline the construction of let be the function which maps each entry to its header such as and be the function which maps each entry to its title then copies the header from the first entry and the title from the second similarly if all the fields of a entry except the title and maps an entire entry to the empty string then completes the body of the output using the fields of the first entry we can then write the reader is referred to appendix a for a description of the consistent drex programs used in our evaluation a algorithm for consistent drex in this section we present the main technical contribution of this paper a linear time algorithm to evaluate consistent drex programs we describe the intuition and present the idea of function evaluators in subsection and then construct the evaluators for each drex combinator we conclude with subsection a brief discussion of why this algorithm does not work with unrestricted drex programs full proofs and the omitted case of the sum will be included in the full version of this paper intuition and the idea of function evaluators given a consistent drex program f we construct an evaluator t which computes the associated function f the evaluator t processes the input string from lefttoright one character at a time after reading each character it outputs the value of f on the string read so far if it is defined to understand the input output specifications of t we consider the example program g in this case t is given the sequence of input signals start n n the first signal start indicates the beginning of the string and f defined f defined i g defined jn start i start j threads of tg figure example run of the evaluator t for g over a string the evaluator tf a result at indices i and j of the input string the evaluator tg for g may simultaneously be processing multiple threads corresponding to different potential parse trees of the input string from the consistency rules we know that at most one thread may return a result at each index and so t can safely emit a result in response to getting a result from tg each character i is annotated with its index i in the input string after reading i i t with the value of g on i if it is defined assume that f and g are consistent and have domain types rf and rg respectively the evaluator t maintains two tf and tg for the functions f and g respectively each time t receives the input a i it this signal to both tf and tg whenever tf reports a result ie that f is defined on the input string read so far t sends the signal start to tg to start processing the suffix consider the situation in figure where f is defined for the prefixes i and j the input to the tg is then the sequence i i start i i i j j start j n n for each signal start i occurring in the input string we call the subsequent sequence of characters ii the thread beginning at index i note that each thread corresponds to a potential parse tree of and that tg may be processing multiple such threads simultaneously the main challenge is to ensure that the number of active threads in tg is bound by and is independent of the length of the input string after reading n tg reports a result to t the evaluator for the g to uniquely identify the thread j the result the result signal result j g is annotated with the index j at which the corresponding start was received note that the consistency rules guarantee that after reading each input symbol tg at most one result for otherwise the prefix of the input string read so far would have multiple parse trees when t receives this result signal from tg it combines it with the response result f initially obtained from f at position j and itself the result result f g to do this it maintains a set for threads of triples if ig f where if is the index along the input string at which tf was started ig was the index at which tf reported a result and tg was started and f was the result reported by tf in order to prevent this set from too large tg kill signals say that at index k tg that for every possible suffix g will be undefined for the string ii k and so the thread start i of tg at the input index i can never return a result it then kill i to signal to t that the relevant entries in the set can be deleted formal specification of the evaluator the input alphabet to each evaluator is therefore in and the output alphabet is out result × n × kill × n where is the input and is the output alphabet of the drex program while constructing the evaluator t for a drex program f we assume the following condition of input validity for each prefix of the input stream in there is at most one thread for which f is defined thus for example t can never see two consecutive start i signals for the same i in return we make the following guarantees correctness of results after reading each input signal j j in in we report the result result i exactly for that thread start i such that f ii j if it exists of every thread beginning at start i of in such that there is no suffix for which f is defined is exactly once while reading in furthermore there are always at most of active threads where f is the size of f if an evaluator t satisfies these requirements for f then we say that the evaluator computes f on the input start n n the evaluator outputs a result in exactly those cases when f is defined and in that case f we will ensure that the evaluator t processes each input signal in time basic evaluators the simplest case is when f bottom the evaluator t is defined by the following rules on input start i with kill i on input a i for a do nothing next we consider the evaluator t d for the case when f d for some d intuitively this evaluator returns a result immediately on receiving a start signal but can only kill the thread after reading the next symbol it therefore maintains a set th n of currently active threads which are to be on reading the next input symbol the set th is initialized to on input start i with result i d update th th i on input a i for a with kill j for each thread start index j th update th observe that by the condition of input validity we can never observe two consecutive start signals in the input stream therefore th and the response time of t d to each input signal is bounded by a constant the final basic function is f d for some character predicate and d the evaluator td maintains two sets th th n of thread start indices initialized to th th th is the set of threads for which no symbol has yet been seen while th is the set of threads for which one input symbol has been seen and that input symbol satisfied the predicate on input start i update th th i on input a i for a a emit kill j for each thread j th b if a satisfies the predicate for each thread j th emit result j da update th th and th c if a does not satisfy the predicate then for each thread j th emit kill j update th and th just as in the case of d we have th th and so td to each input signal in time bounded by some constant we assume a representation for strings with concatenation requiring only constant time specifically strings are only symbolically using a pointer representation such represented strings can be converted into the traditional representation in time linear in the string length evaluators combination and conditionals the simplest nontrivial evaluator is for g recall that by the consistency requirements we have rf rg for the domain types rf and rg of the subexpressions thus all state can be maintained by the tf and tg and can be entirely it has the following behavior on input start i send the signal start i to both tf and tg on input a i send the signal a i to both tf and tg on receiving the result result i f from tf and the result result i g from tg which according to the consistency requirements for g have to occur simultaneously with result i f g on receiving the kill signals kill i from tf and tg by the consistency rules necessarily simultaneously emit the kill signal kill i the evaluator tf else g maintains two tf and tg in addition it maintains two sets n of threads currently active in tf and tg respectively both sets are initialized to the behavior of tf else g is defined as follows on receiving the input start i update i and i send the start signal start i to both tf and tg on receiving the input a i for some a send the input a i to both tf and tg when either tf or tg with the result result i by the consistency rules we know that the other is not with a result emit the result result i if a kill signal kill i is received from tf resp tg update i resp i if i and i then kill the thread by kill i the sizes of and are bounded by the number of active threads of tf and tg respectively and hence it follows that tf else g to each input signal in time of g tf tg where tf and tg are the response times of tf and tg respectively stateful evaluators iteration and split sum we now construct evaluators for and g the evaluators for and g are symmetric with respect to concatenation and can be constructed similarly first we build the evaluator where f is consistent and has the domain type rf whenever receives a start signal start i or an input signal a i this is passed to tf consider a sequence of input signals as shown in figure after reading each input symbol say n n tf may report that f is defined for a suffix of the input stream start k k k n n seen so far the evaluator by a new thread of tf by sending it the start signal start n furthermore it has to record the result result k just reported by tf it does this by adding the entry i n to the set th each entry i j th refers to an active thread j of tf the index of the signal start i received by and the result obtained so far formally the set th n × n × is initialized to the evaluator does the following on input start i a update th th i i start i j k n tf reports tf reports tf reports figure for each thread start i of the evaluator there may be multiple potential parse trees the evaluator maps individual threads start i of tf to the corresponding start signal start i in through the entry i i in the set th thus after obtaining the response from tf at index n updates th th i n b send start i to tf assert that tf does not with a result result i because by the consistency rules f is undefined for rf to be c with the result result i on input a i send the signal a i to tf for each response of tf do the following a if the response is a result result j f then find the corresponding entry j j th for some values of j and assert by the invariant that th records the active threads of tf that this entry exists and is unique i update th th j i f ii send the signal start i to tf that tf does not with a result result i f for that would violate the consistency requirements iii with the result result j f b if the response is a kill signal kill j i let be the set of all tuples j j th for some values of j and by the consistency requirements is to be a singleton set ii update th th iii for every entry j j if there is no entry of the form j j th then emit the kill signal kill j observe that an element is added to th exactly when it is sent a start signal and an entry is deleted exactly when receives a kill signal thus the entries of th correspond to the active threads of tf and its size is bounded by of the response time of to each input signal is therefore of tf where tf is the response time of tf the evaluator for g is similar except that it maintains two sets the first set n is the set of thread start indices which are still active in tf and the second set n × n × is the set of triples i i f which indicates for each active thread in tg the index i at which tg was to start the index i of the original start received by when tf was started and the value f returned by tf on the prefix both sets are initialized to and follows the following rules on input start i a update i b send start i to tf let be the responses from tf let on input a i a send a i to tf let be the set of responses from tf b send a i to tg let be the set of responses from tg for each response r do the following a if r is a result result j f from tf i update j i f ii send the signal start i to tg update where is the set of responses from tg b if r is a result result j g from tg let j j f be the by the consistency rules necessarily unique corresponding record in with result j f g c if r is a kill signal kill j from tf i update j ii if there is no element of the form j j f for some values of j f kill the thread kill j d finally if r is a kill signal kill j from tg i let be the set of tuples j j f for some values of j f ii update iii for every record j j f if there is no longer a record of the form j j f and j kill the thread beginning at j kill j observe that is bound by the number of active threads of tf and is bound by the number of active threads of tg thus to each input signal in time of g tf tg where tf and tg are the response times of tf and tg respectively what breaks with unrestricted drex programs first notice that the function composition operator is to the evaluator model we just described we wish to process each character in bounded time regardless of the length of the input string consider the case of g when the evaluator tf returns a result result i we have to pass the entire intermediate result string to tg and this is possibly as long as the input seen so far notice that this limitation should be because nested function compositions such as the transformation composed with itself k times can cause an exponential in the length of the output string next consider a potential evaluator t for g in the absence of any consistency requirement thus there might exist strings n which admit two splits such that all of f f g and g are defined in this case g is undefined for the entire string we have to drop the requirement of input validity because the nested evaluator tg two result signals after reading n we could modify t to emit an output signal when exactly one thread of tg returns a result unfortunately it turns out that this modification is as the induction hypothesis now breaks the evaluator t has to perform additional to report results correctly the consistency rules provide an easy way to avoid this nontrivial finally note that unrestricted use of the sum operator does not satisfy the output bound f while every consistent drex program f f the complexity of unrestricted drex in this section we first describe the dynamic programming algorithm to evaluate drex programs we show that it has time complexity in the size of the input string and when function composition is allowed requires time exponential in the size of the program we then show that the evaluation problem for drex programs with composition is and is thus computationally hard finally we argue that for unrestricted drex programs even when composition there is no evaluation algorithm for which the complexity is linear in the length of the input string and polynomial in the size of the program evaluation by dynamic programming we now describe the dynamic programming algorithm to evaluate unrestricted drex programs this algorithm also works on programs containing the function composition operator the algorithm the semantics of drex by computing the following functions represented as lookup tables given a program f and a string for any two numbers i and j the algorithm computes the function i j representing the output of f on the substring i j f i j to evaluate the operator we also need to compute the function i j that counts the number of possible ways to split i j so that each split is accepted by f and to evaluate the operator r we compute the function i j which checks whether a substring i j belongs to the language r every function out count and is represented by a table and for each string and each subprogram g of f each table will have o entries corresponding to the of the final output of the algorithm is we explain the intuition of the algorithm by showing how the entries are computed for the iteration and composition operators the value i j corresponding to the output of on the string i j is defined iff there is a unique way to split the string into multiple chunks so that f is defined on each chunk ie iff i j if this is the case then we know that there is a unique value k such that i k j for which both pre i k and post k j are defined and prepost is the output of on i j looking for this witness k takes at most steps if all the required table entries have already been computed similarly the entry i j can be computed in at most steps by counting for how many values of l the function i l is greater than and the functions l j is defined the rule for computing f i j is what causes an exponential in the evaluation time to compute the output of f on i j we first need to compute the output i j of the program f on the string i j and then the output of the program f on the string as we will show when using the composition operator the size of the output may grow exponentially and since computing each entry of the table · · requires o steps the resulting complexity is also exponential we now bound the output length of programs containing the composition operator lemma output size given a program f and an input string such that f is defined we have f d here d is the number of composition operators appearing in f we now state the complexity of the dynamic programming routine to evaluate drex programs theorem complexity of dynamic programming given a program f and an input string the output f can be computed in time of dd d where d is the number of composition operators in f if d we can show that the algorithm has complexity of proof sketch for a particular string and if the program f that does not contain any composition operators d computing we define the substring i j of as ii j so that i i for each i and is the entire string each entry of the tables out count and takes time o and since there are f entries the algorithm has complexity of in the presence of composition operators which can produce intermediate results for each intermediate string a new table of size must be created by lemma we know that an intermediate result has size at most of d hence the complexity is exponential in d drex evaluation with composition is while the main of the algorithm in subsection is ease of implementation it can use exponential space it turns out that even in the presence of composition drex programs can be evaluated in pspace first observe that since the output computed by a program has at most exponentially many characters lemma the index of each character in the output is only many bits long we therefore adopt an implicit representation of strings with the following operations in contrast with the traditional explicit representation of strings a check whether is defined b compute the length of and c given an index i compute the ith character of finally by structural induction on the drex program f and given an implicit representation of the input string we build an implicit representation of f using only polynomial space for example the implicit representation of f else g would function as follows a to check whether the output is defined simply determine whether either f or g is defined b to compute the length of the output if f is defined return the length of f and otherwise return the length of g and c to compute the ith character of f else g if f is defined then return the ith character of and otherwise return the ith character of g observe that since both nested implicit representations f and g consume only polynomial space f else g is itself evaluated in polynomial space the most interesting case is g where we simply connect the implicit representation of the output of f to the input of the function g the only nontrivial case is when f to check whether f is defined on the input we need to determine whether there is exactly one way to split such that g is defined on each split consider each position in the string as a vertex in a graph with an edge between two vertices iff g is defined on the substring between them then each path from the initial to the final node of this graph corresponds to a split of and thus f is defined on iff there is a unique path from the initial node to the final node in this implicitly represented graph of potentially exponential size this problem can be solved in pspace theorem given a drex program f and strings and the problem of determining whether f is in pspace finally we show that when we allow the use of composition operators polynomial space is required and the problem of evaluating a drex program is theorem the following problems are given a program f in drex check whether f is defined given a program f in drex and a string check whether f is defined given a program f in drex a string and a string check whether f proof sketch of to show that the first problem is we reduce from the validity problem for quantified boolean formulas intuitively given a xx xn we construct a drex program f such that f is defined iff is valid the program f is the composition of three programs f and fq where f takes as input and outputs all the strings in n in order and separated by a this program generates all the possible assignments of the boolean variables takes as input the string of all the assignments produced by f and replaces each assignment in a n with t if the assignment a satisfies the sat formula and f otherwise fq takes as input the string over t f and checks whether such a sequence of satisfying assignments is valid for the quantified formula if it is valid it outputs and otherwise it is undefined the other problems can be reduced to the first problem using the composition operator algorithms for unrestricted drex in the proof of theorem we showed that in the absence of the function composition combinator the dynamic programming algorithm has complexity of where is the input string and f the program in this section we argue that if one wants to obtain an algorithm that is linear in the size of the input it is necessary to pay at least an exponential complexity in the size of the program drex operators are similar to those by regular expressions iteration split etc are the broad of kleene concatenation etc since one can evaluate regular expressions efficiently by transforming them into nondeterministic finite automata one can try to construct an automaton model corresponding to drex programs unfortunately as we discussed in section drex combinators can also express language intersection and other complex operations in the presence of such operations directly constructing an automaton model from the program seems hard see where the author summarizes the on matching regular expressions extended with an intersection operator the following is currently the best claim we can make about evaluating unrestricted drex programs with a single linear time pass over the input string theorem given a drex program f and an input string we can compute the output f in time linear in the length of the input string and a of with height of the algorithm f into an equivalent streaming string transducer using the procedure described in an is a finite state machine that reads the input in a lefttoright fashion and stores intermediate results inside variables the final output is a combination of such variables an a can be evaluated on an input string in one pass in time oa since are deterministic operations such as concatenation and iteration even in the absence of function composition cause an exponential making the overall complexity evaluation we implemented the algorithms described in this paper and evaluated their performance on a representative set of text and file transformations we show that the evaluation algorithm for consistent drex to inputs with more than characters subsection and the dynamic programming algorithm presented in section does not scale for inputs with more than characters subsection finally we remark on the experience of expressing string transformations using drex subsection implementation details the prototype implementation of drex was written in java and uses the recently released java se we used the symbolic automata program name reverse size cc ms table evaluated programs with sizes and time to check consistency seconds reverse characters figure evaluation time for the algorithm library to implement the symbolic operations required by the algorithm theorem the set of characters were all bit code units and the predicates were unions of character intervals such as az az the experiments were run on regular hardware windows running on a bit intel core i cpu at with gb of ram each experiment was run times and the results reported are the mean of the obtained running times the dynamic programming dp algorithm for the extended version of drex theorem is implemented each entry i j is only computed and allocated when its value is required by another entry without this technique the algorithm runs out of memory for inputs of length smaller than we also optimize the dp algorithm to take advantage of the for consistent programs the algorithm does not need to check whether there is more than one way to match a string benchmark programs table shows the programs we considered in our evaluation together with their sizes and the running time of the algorithm these programs are described in appendix a observe that for every program the algorithm terminates in less than ms we evaluated the first four programs on randomly generated text files of size varying between and characters and evaluated the more complex functions and on actual files of size also varying between and characters we set a timeout of seconds for each operation algorithm for consistent drex figure shows how the running time for the algorithm presented in section depends linearly on the size of the input for inputs up to characters each program takes less than seconds to compute the output also observe that the evaluation algorithm can successfully handle reasonably large programs such as which has an ast with nodes seconds reverse characters figure evaluation time for dynamic programming algorithm note that the in dynamic programming for unrestricted drex figure shows the running time for the dynamic programming algorithm presented in section the is shown in log scale to better the difference between the different programs from the figure we can see that the running time depends on the length of the input and as a consequence all the considered programs time out for inputs with more than characters in some cases large programs such as execute faster than smaller programs such as this is due to the fact that our implementation uses some optimizations that may depend on the shape of the program for example in the case of programs that are only defined on strings of a fixed length k the algorithm is evaluated only for those i and j such that j i k in conclusion although all drex programs can be evaluated using the dynamic programming algorithm presented in section the procedure does not scale to large inputs user experience and comparison to existing tools we were able to easily program several nontrivial transformations without having to about efficiency the main restrictions of the streaming evaluation algorithm are that programs cannot use compositions and have to be consistent in our case study we did not find instances where composition was required and all the natural implementations of our programs were consistent moreover in many cases the consistency algorithm us in identifying sources of ambiguity that caused our program to be incorrect as an account we had the subprogram x which copies all characters including and with itself in this case the typechecker us that this concatenation was ambiguous on the input string n this was clearly a bug in our script and would have led to behavior even if we had used the dynamic programming evaluation algorithm we also the benchmark transformations in and based substitution as present in all of these tools is very efficient and usable to substitute or delete based on patterns this includes the benchmark programs and for which the implementations were times faster than the drex ones on the other hand reverse and were hard to express in tools such as and the implementations of these functions were times faster than ours related work regular string transformations this class of transformations is robust and has many equivalent including deterministic string transducers streaming string transducers transducers with origin information and string transformations regular string transformations are also closed under composition and decidable equivalence et al proposed a set of combinators that captures the set of regular transformations and this paper builds on it the results in only focus on expressiveness and do not try to answer questions about complexity in particular the transformation to streaming string transducers proposed in has complexity in the size of the program in this paper however we are primarily driven by issues related to the complexity of evaluation for string transformations for string transformations mainly fall into two classes string specific such as and and languages such as and provide the programmer with powerful programming constructs to manipulate strings these languages are and in general cannot be efficiently compiled into fast executable code and are not amenable to algorithmic analysis we also argued in section that some of the programs that can be naturally expressed in drex are actually hard to define using these tools all the existing languages simply act as to an underlying transducer model that they use to reason about the implemented programs bek uses symbolic finite transducers and it has been used to analyze string sanitization functions is a frontend for extended symbolic finite transducers and it has been used to prove the correctness of string and such as base fast is based on symbolic tree transducers with regular lookahead and it is used to reason about programs that manipulate strings and trees over arbitrary domains while these languages enable powerful analysis and verification techniques a their semantics are coupled to the transducer model forcing the programmer to think in terms of a finite state machine and a lefttoright reading of the input string and b they only capture a strict subset of the class of regular string transformations none of these models can reverse a string another language based on automata is a bidirectional programming language for string editing bidirectional programs contain combinators for extracting a view from a concrete input and then an updated input from the updated view also supports where each record is associated with a key although has a similar to that of drex it forces unambiguous operations we are not aware of a complexity analysis for the problem of evaluating a program the goals of and drex are orthogonal the former focuses on bidirectional transformations while the latter focuses on efficiently evaluating all regular string transformations despite this difference we believe that could benefit from the evaluation techniques proposed in this paper efficient string manipulation little effort has been to design languages and algorithms to efficiently evaluate string transformations in linear time the general approach has been to identify an automaton model that processes the string in a single lefttoright pass and can express interesting programs however all existing tools that use this approach take advantage of composition or combination operators that make the compilation to transducers exponential in the size of the program streaming string transducers capture all programs that can be written in drex and can be executed in a single lefttoright pass over the input however transforming drex programs into also causes an in the size of the input program in the context of xml processing numerous languages or fragments have been proposed for efficiently stream processing and manipulating xml trees some of these languages particularly focus on efficiently processing the input in a linear time lefttoright pass although in the case of xml documents with bounded depth some xml transformations can be described in drex the main goal of drex remains that of providing a welldefined fragment regular of string and not tree transformations that can be efficiently executed future directions a major motivation for choosing the class of regular string transformations was the decidability of analysis questions in particular consider regular typechecking given a program f and two regular languages i and o is it the case that for every input i p o such a tool would be helpful to string sanitizers against specific kinds of attacks implementing these procedures is an open research direction in simple string transformations can be synthesized from examples the expressiveness of the combinators used in has not been characterized can drex programs be efficiently or synthesized from inputoutput examples recently et al proposed new techniques for evaluating finite automata in a fashion can these techniques be used to the evaluation algorithm proposed in this paper extending our techniques to tree transformations is another open problem streaming tree transducers are to regular tree transformations or equivalently macro tree transducers and tree transformations as are related to regular string transformations can we design a similar declarative language to express regular tree transformations finally certain operations such as counting the number of substring matches sorting the elements of a dictionary or deleting duplicate entries in a list are not regular string transformations extending drex with primitives but which can still be efficiently evaluated is an interesting direction of future work conclusion we presented drex a declarative language for describing regular string transformations the basic transformers are symbolic so drex can express transformations even over large alphabets such as we demonstrated that the evaluation problem for unrestricted drex is and so we considered a restricted fragment consistent drex which permits a fast evaluation algorithm and still expressive completeness in experiments over representative string transformations such as file the evaluation algorithm for consistent drex to process of characters per second references r and p c streaming transducers for algorithmic verification of programs in proceedings of the th annual acm sigplansigact symposium on principles of programming languages pages ­ acm r and l streaming tree transducers in a k a pitts and r editors automata languages and programming volume of lecture notes in computer science pages ­ springer r a and m regular combinators for string transformations in proceedings of the joint of the rd annual conference on computer science logic csl and the th annual symposium on logic in computer science lics pages ­ acm o streaming transformations for in volume of pages ­ gi a n foster b pierce a and a lenses for string data in proceedings of the th annual acm sigplansigact symposium on principles of programming languages pages ­ acm m transducers with origin information in automata languages and programming volume of lecture notes in computer science pages ­ springer r s even s and g ambiguity in graphs and expressions ieee transactions on computers ­ february a regular expressions into finite automata in volume of lecture notes in computer science pages ­ springer m and v serial composition of way finitestate transducers and simple programs on strings in automata languages and programming volume of lecture notes in computer science pages ­ springer b monadic secondorder definable graph a survey theoretical computer science ­ l and r symbolic pushdown automata in computer aided verification volume of lecture notes in computer science pages ­ springer l and m equivalence of extended symbolic finite transducers in computer aided verification volume of lecture notes in computer science pages ­ springer l and m static analysis of string and in verification model checking and abstract interpretation volume of lecture notes in computer science pages ­ springer l and m minimization of symbolic automata in proceedings of the st acm sigplansigact symposium on principles of programming languages pages ­ new york ny usa acm l m b and d fast a language for tree manipulation in proceedings of the th acm sigplan conference on programming language design and implementation pages ­ acm j and h j mso definable string and finitestate transducers acm transactions on computational logic ­ april j and s macro tree transducers attribute grammars and mso definable tree translations information and computation ­ j g and g tree transducers l systems and machines journal of computer and system sciences ­ j and h macro tree transducers journal of computer and system sciences ­ s gulwani string processing in using inputoutput examples in proceedings of the th annual acm sigplansigact symposium on principles of programming languages pages ­ acm e the equivalence problem for deterministic sequential transducers is decidable in st annual symposium on foundations of computer science pages ­ t m and w finitestate machines in proceedings of the th international conference on support for programming languages and operating systems pages ­ acm g an effective algorithm for the membership problem for extended regular expressions in foundations of software science and computational structures volume of lecture notes in computer science pages ­ springer m introduction to the theory of computation learning rd edition r and h on the equivalence and containment problems for unambiguous regular expressions grammars and automata in proceedings of the nd annual symposium on foundations of computer science pages ­ ieee computer society m p b d and n symbolic finite state transducers algorithms and applications in proceedings of the th annual acm sigplansigact symposium on principles of programming languages pages ­ acm a examples of consistent drex programs this appendix contains simplified descriptions of the consistent drex programs that we used in our experiments in section we will use the following macros in our definitions copy x x x f fn split fn copy and respectively copy or delete a character matching when the predicate is of the form x c we simply write c the function f one or more times the last macro simply the split sum operator on all the arguments a delete comments from a program this program all comments from a file ie the lines starting with we define each component of the program separately the program strings of the form n where does not contain any occurrence of the new line character n n the program copies strings of the form n where the string is either the empty string or it does not start with the character n else the program reads a line and it if it is a comment line and copies it otherwise the last line might not end with a n and the program deals with this exception finally the program and at the end processes the last line therefore deleting all the comments in the input else else else a insert around words this program inserts around every substring appearing in the input the program given a string where is and does not contain any letter outputs the string the program the function since the string might start with a symbol that is not the program start deals with this case similarly the program ending checks whether the string does not end with an sequence finally the program inserts around every substring in the input start ending else ending a extracting tags from a xml file this program extracts and all the of the form where does not contain any character or this is a generalization of a program shown in for simplicity we assume that the string does not contain occurrences of the substring the program copies any string of the form where does not contain any character or copy the program any string that does not contain a substring of the form s where s does not contain any character or the program looks for the following pattern s · · · i · · · n with i its subprogram all the string of the described form containing at least one open character else the program keeps looking for tags and removes eventual at the end of the string finally and therefore outputs all the of the form a a dictionary given a dictionary of the form · · · n we want to output the reverse nn · · · the program copies a string of the form such that does not contain a the program reverse implements the final transformation by left copy reverse a files in this section we define two functions that operate over files the first function attributes within each entry by moving the title to the top the second function a file by moving the title of each entry inside the previous entry to do so we first define a few auxiliary functions that are used for copying and deleting strings spaces and r b t place year title two new sciences author title two new sciences place year author figure a example application of the transformation from the entry on the left to the entry on the right it is easy to see how given a drex program that copies a pattern one can easily define a drex program that the same pattern to simplify the presentation in the following we assume that for every program of the form there is an analogous program that is defined on the same input as but always outputs the empty string the program copies the header of an entry in the example of figure a it copies the string along with the following spaces copy copy we now define macros for copying and deleting a particular string s or a set of strings copy n copy else else the program copies the string title and the program copies every attribute name different from title we omit the full list of attributes for readability year place the program copies the value of an attribute along with the surrounding parentheses ie copy copy copy copy the program copies a complete title attribute ie title two new sciences while copies a complete attribute given a list of attributes the program copies the title and all the attributes the program the title and copies all the other attributes and the program copies the entire list else else else a a file the following function defines a typical transformation a paper author may perform on files the program moves the title attribute to the top of each entry of an input file figure a shows the result of applying to a particular entry in this presentation we assume that every attribute is followed by a the program copies the title first and then all the other attributes therefore obtaining the desired attribute reordering the program performs the operation of figure a for a single entry copy finally the program applies the transformation to all the entries in the file a in a file assume that by the of a file have been the title of the first entry now appears in the second one the second title appears in the third entry and so on the function given such a file moves the title of each entry i to the correct entry i and since the last entry would now not have a title it gets deleted this program requires the use of the sum operator in order to process two entries at a time first and second second and third and so on the program given a single entry copies only the header and the rest of the entry the program given a single entry copies only the title and the rest of the entry while the program the header the title and copies the rest of the entry copy the program a single entry the program given two entries outputs the first entry where the title has been replaced with the title of the second entry it first copies the header of the first entry then the title of the second entry and then the remaining attributes of the first entry combine finally the program applies the transformation to all the entries in the file we omit the regular expression describing the format of an entry in the chain operator since drex can infer it automatically the actual program used for the experiments is able to deal with missing 