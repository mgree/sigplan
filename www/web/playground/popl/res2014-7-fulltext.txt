type analysis modular checking of almost everywhere invariants university of abstract we present a generic analysis approach to the imperative relationship update problem in which destructive updates violate a global invariant of interest such invariants can be and specified with dependent refinement types which are efficient to check unfortunately while traditional flowinsensitive type checking is fast it is when the desired invariants can be broken to overcome this limitation past works have directly up the complexity of the type analysis and associated type invariants leading to inefficient analysis and specifications in contrast we propose a generic lifting of modular refinement type analyses with a symbolic analysis to efficiently and effectively check concise invariants that hold almost everywhere the result is an efficient highly modular flowinsensitive type analysis to check the preservation of global relationship invariants that can fall back to a precise disjunctive symbolic analysis when the optimistic assumption is violated this technique permits programmers to break and then relationship flexibility that is crucial for checking relationships in realworld imperative languages a significant challenge is the global type consistency invariant over heap locations which we achieve via almost heaps to evaluate our approach we have encoded the problem of verifying the safety of reflective method calls in dynamic languages as a refinement type checking problem our analysis is capable of reflective call safety at interactive on libraries and applications categories and subject descriptors f logics and meanings of programs specifying and verifying and reasoning about programs keywords almost everywhere invariants dependent refinement types almost heaps reflection introduction modular verification of just about any interesting property of programs requires the specification and inference of invariants one particularly rich mechanism for specifying such invariants is permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm refinement types which have been applied extensively to for example checking array bounds refinement types are because they permit the specification of relationships in a type system framework that naturally admits modular checking for example a modular refinement type system can relate an array with an index or a memory location with the lock that access to it a less problem that also into a refinement type framework is verifying the safety of reflective method call in dynamic languages reflective method call is a dynamic language feature that enables programmers to invoke a method via a runtime string value called a selector in many languages these calls have become in libraries as a mechanism to client and framework code yet while they are powerful and convenient reflective method calls introduce a new kind of runtime error the method named by the selector may not exist our key observation about verifying reflective call safety is that the essential property to capture and track through the program is the relationship between a the object on which the method is invoked and a valid selector in particular the verifier does not need to determine the actual string value as long as it can ensure that the relationship between the object and the selector holds at the reflective call site this observation is crucial because the point where this relationship invariant is established and where the selector is known usually in client code is likely far removed from the point where the reflective call is performed and at which the invariant is upon usually in framework code the imperative relationship update problem a significant challenge in checking relationship invariants in dynamic imperative programming languages is reasoning precisely about destructive updates of related storage locations such as local variables on the stack and object fields on the heap to illustrate this issue consider an object o with an object invariant specifying a relationship between two fields of and for example of could point to an object that should to a selector stored in we can then use this invariant to show that a reflective method call on of using selector is safe again there are many other interesting properties that require specification of relationships eg of is an array with an index stored in or of is a monitor object guarded by the lock stored in now consider a call to a simple method that updates fields of and with the corresponding fields from the argument p def xf where three program points to are marked explicitly suppose that fields pf and pg of object p have the corresponding relationship with each other as those fields of o eg pf to pg then it is clear that after a call to the relationship invariant between of and should still hold this property seems obvious but two issues make it challenging to verify a standard flowinsensitive type analysis by itself is and sound symbolic reasoning about potential aliasing requires an expensive disjunctive analysis issue arises because the first assignment violates the type refinement on in our reflective call safety example after the assignment the new holding the value passed in xf might not to the old switching the order of assignments does not help then after the first assignment the old might not to the new problems arising from imperative relationship updates have been studied in the context of array bounds checking to deal with issue these type systems either require simultaneous relationship updates or drop and move to a flowsensitive treatment of typing in contrast to a flowinsensitive invariant the type of a location in a flowsensitive treatment is not fixed globally and is permitted to vary we argue that for the relationship update problem computing new types at every program point is pessimistic although the ideal flowinsensitive type invariant imposed by the refinement on the field is broken at program point it is almost immediately at point while the blocks of code between violations and eg points to require at least a fast flowinsensitive analysis can still be effective in checking that the relationship invariant is preserved everywhere else issue arises in the above example because we must reason about potentially two concrete objects the object pointed to by self and the possibly same object pointed to by x while this code satisfies the desired property regardless of whether or not self and x are aliases the analysis must consider both cases consider a slight variant where for example an assignment null occurs before point a sound analysis must detect a bug in this variant when self and cb are aliases prior approaches eg enable strong updates in some situations by reasoning about concrete objects while reasoning is sound it is precise for even this example in particular a disjunctive analysis eg a analysis must reason about two cases where there is one concrete and x are where there are two and x are not aliases we also argue that directly a type system to handle temporary invariant violations or other issues is specific the imperative relationship update problem applies to checking just about any property that requires relational invariants in contrast to the works the essence of our approach is to mix a refinement type system with a generic symbolic flow analysis to handle temporary violations of the type invariant the symbolic analysis performs reasoning and issues like flow and from the particular type abstraction of interest type analysis we propose flowinsensitive storage location type framework for a dependent refinement type system to temporary violations via a generic symbolic separation flow analysis the result is an analysis that soundly checks a type invariant that holds almost everywhere when the fast flowinsensitive analysis detects an invariant violation type analysis splits the type environment which relates storage locations to storage locations into two components relationships between symbolic values ie refinement types lifted to values and the locations where those values are stored ie a symbolic memory the symbolic analysis permits bounded violation of the storage location property and takes over until the type invariant is at which point the fast flowinsensitive analysis as illustrated in the above example we must sup port bounded relationship violations not only among local variables but also among a number of heap locations supporting bounded violations of heap locations is a significant challenge when applied to relationships that hold almost everywhere type analysis addresses the imperative relationship update problem while still maintaining two key benefits of it is nearly as fast as a flowinsensitive analysis to lines of code per section since it begins with the optimistic assumption that the invariant holds everywhere and then only has to reason precisely about the relatively few program locations in which any relationships are violated it permits the of method type signatures to be flowinsensitive flowinsensitive type signatures do not need to specify the effect of the method on the heap contrast this to a modular flowsensitive analysis that has summaries specifying the effects on all methods in essence to rule out the pessimistic assumption that any callee could violate the invariant in summary we make the following contributions · we describe the type analysis framework for fast type and precise symbolic analysis of almost flowinsensitive storage location properties and instantiate it to check reflective call safety our framework is built on the observation that flowinsensitive type invariants on mutable storage locations really serve two roles specifying facts about the values stored in them and what values are allowed to be stored in them we define two generic operations to between the type and symbolic analyses that essentially either or these roles section · we introduce the notion of almost heaps that at the concrete level splits the overall heap into two regions one explicit region where locations are permitted to be type inconsistent and one implicit region where locations are type consistent up to a location that is potentially inconsistent we then define and summarization operations that permit an arbitrary number of locations with any relation between the two regions with locations we thus enable strong update reasoning in our disjunctive symbolic analysis these capabilities are critical for supporting bounded relationship violations among an arbitrarily bounded number of heap locations sections and · a key challenge in verifying of violated refinement relationships is that the code that breaks a relationship may be in one module while the storage for that relationship is in another we introduce symbolic summaries that enable programmers to specify relationship storage and thus retain modular checking for bounded violations sections and · we evaluate the effectiveness of our approach to checking reflective call safety on a suite of libraries and applications and on code by developers on public section overview in this section we present an example that illustrates the main challenges in temporary violations of type consistency particularly with respect to objects our examples are drawn from verifying reflective call safety in realworld code which require such temporary violations to be able to use simple global type invariants like c is an objectoriented layer on top of c that adds classes and methods we will describe its syntax as needed interface in up down state string m image m draw image image draw end interface object string selector d s d s end figure verifying reflective call safety requires knowing relationships between and selectors the example in figure adapted from the library demonstrates how programmers use reflective method call to avoid code and to components ignore the annotations in double parentheses · for denote our additions to the language of types the class lines ­ contains a method lines ­ that the as either up or down according to whether the caller passes the string up or down as the state argument a class is defined within blocks an instance method definition begins with methods are defined and called using infix notation syntax for example the code at line calls the method on the image object with self as the first argument and m as the second this call is analogous to in c now a object itself by using the to call either or the sets up a context and calls the passed in selector on the passed in at line the and selector pair form in essence a callback this syntax o for reflective call in is analogous to in ruby in python and os in javascript in this case the is set to the object itself and the selector is constructed by the passed in state string to the string constant draw lines ­ constructing the selector dynamically reduces by avoiding for example a series of if statements the state variable using reflection for callbacks also improves is to the identity of the this idiom is one common way pairs arise in and other dynamic languages the use of reflection in this example comes at a cost while the type system statically checks that directly called methods exist it cannot do so for reflective are only checked at run time in this work we present an analysis that enables modular static checking of reflective call safety while still maintaining the benefits of reduced to prove that the program is we use refinement types to ensure that the does in fact to the selector to see how these relationships arise consider the reflective call at line it will throw a runtime error if the receiver does not have a method with the name specified in the argument conversely to be safe it is sufficient that to there is an invariant that requires that for every instance of the object stored in the field must to the selector stored in the selector field we capture this invariant by applying the refinement to the field at line this refinement expresses the desired relationship between the field and the selector field the method signature void states that the selector field holds the name of a method that takes zero parameters with return type void this expresses an intuitive invariant that unfortunately does not quite hold everywhere still our framework is capable of using this almost everywhere invariant to check that the required relationships hold when this point in section working backward we see that the method updates the and selector fields with the values passed as demonstrates the need in a modular analysis for refinements to apply to parameters as well as fields we annotate parameter d to require that it to s any time the method is called the first argument must to the second thus at the call to at line we must ensure that self to m in the caller ie the client of we know a precise type for the first argument whereas from the point of view it is merely object this means we know that from the callers point of view the will to the selector if the selector is a method on if we limit the values m can take on to or the refinement in the callee will be satisfied we write in for the refinement that limits strings to one of a set of string constants ie a union of for simplicity in presentation our only refinement for string invariants is in although more complex string reasoning is possible flowinsensitive typing of refinements restricting values stored in variables parameters and fields with relationships and in refinements captures the essential invariants needed to verify reflective call safety here we show why a flowinsensitive type analysis with these refinements is in the presence of imperative updates we focus on the most interesting case updates to fields of objects refinement types v b rv consist of two components the base type b which comes from the underlying type system and the optional refinement formula r which add restrictions on the value v beyond those imposed by the base type as a notational convenience we write them without the bound variable and assume the bound variable is used as the first argument of all atomic relations writing for example int instead of v int v subtyping with refinement types we assume the refinement type system of interest comes equipped with a subtyping judgment t t that is a static overapproximation of semantic inclusion ie under a context the concretization of type t is contained in the concretization of t as an example we consider informally subtyping with the and the in refinements for reflective call safety for in refinements this is straightforward an string is a subtype of another string if the possible constant values permitted by the first are a subset of those required by the second the situation for subtyping the refinement is complicated by the fact that a relationship refinement can refer to the contents of related storage locations consider the type in the method the type environment limits the local variable m to hold since is a subtype of object in the base type system and has both a and a method is a subtype of object m in this environment if for example m instead had refinement in the above subtyping relationship would not hold note that for presentation we have the method type on the here we do so whenever it is not relevant to the discussion type checking field assignments we check field assignments with a approach similar to the type system although extended to handle subtyping here we focus on why flowinsensitive typing raises an after the field assignment d at line see section for more details on how checking proceeds to check this assignment we first augment the type environment with fresh representing the fields of the object and then check the assignment as if it were a local update conceptually we bring field storage locations into scope and give them local names let this augmented type environment be a d object s object selector for some and where we explicitly show the two refinements for presentation we use the field names as the fresh checking the assignment we end up with the subtyping check a ad which expresses the invariant that the relationship between and selector should be preserved across this assignment note that while this subtyping check is what is for assignment in a standard type system the approach ensures that this same check is also required and thus also fails for the next line line where selector is updated although these two assignments are each unsafe in isolation considered in combination they are safe the first assignment breaks the invariant that the field should to selector but the second it these temporary violations cannot be by a flowinsensitive type analysis because in imperative languages flowinsensitive types on storage locations really perform two first they express facts about values any value read from a variable with type m can be assumed to to the value stored in location m but second they express constraints on mutable storage for the fact to universally hold the type system must any write to that variable of a value that does not to m these constraints are fine for standard types but are problematic for relationships that are established or updated in multiple steps violation of relationship refinements as we in section we argue that moving to a flowsensitive treatment of typing is too pessimistic a flowsensitive type analysis the global constraints on mutable storage locations that enable concise specification instead it focuses on tracking facts on values as they flow through the program which then require more summaries other possible alternatives are to change the programming language to temporary violations eg by requiring simultaneous updates or to generalize the type invariant to capture the temporary violations of the simpler invariant we argue that these approaches are too specific our work is motivated by the observation that although programmers do sometimes violate refinement relationships most of the time these relationships are almost flowinsensitive to set up our notion of almost heaps we first make explicit a standard notion of definition a storage location is if the values stored in it and all locations in its reachable heap to the requirements imposed by their flowinsensitive refinement type annotations thus a storage location is if either the value stored in it immediately without pointer dereferences violates a type constraint or there is a location in its reachable heap we distinguish these two cases of immediately versus only in this work we rely on two premises about how programmers violate refinement relationships over storage locations on the heap premise all of the heap is most of the time premise most of the heap is not immediately all of the time in other words only a few locations are responsible for the global type invariant at any time following premise we apply type analysis when the heap is and switch to symbolic analysis when the type invariant is violated under this premise these of violation are bounded in short enough that the path explosion from precise symbolic analysis is to enable the of a type and a symbolic analysis we require two conceptually inverse operations and that are applied when switching between the two kinds of analyses splits a type environment which expresses relationship constraints between storage locations into a symbolic fact map and a symbolic memory m the fact map expresses relationships between symbolic values ie refinement types lifted to the symbolic domain and the memory indicates where those values are stored symbolic local variables and heap so for example splitting a type environment with d object s will result in a fact map with fact v object v and a memory m which maps d to v and s to v here v and v are arbitrary symbolic names for values initially stored in d and s upon in order for a to be sound the fact map must be no stronger than the original type environment a type environment is not directly comparable to a symbolic fact map so we capture the required relationship with a subtyping under substitution judgment that in essence converts the symbolic fact map to a type environment before performing the comparison we perform this conversion with a substitution constructed from the symbolic memory that maps symbolic values to the local variables that store them and m back into a type environment in this case the type environment under the forward memory substitution must be no stronger than the fact map we describe these relations fully in section premise is at the core of our approach to soundly handling temporary type violations on heap locations the key idea is a view of the heap as being made up of two separate regions a a small number of individual locations that are allowed to be immediately and b an almost region consisting of fully or only locations which we illustrate intuitively below immediately in the illustration the node represents one location that is immediately while the light rectangle around it represents the almost region note that there may be pointers shown as arrows to the this location where such objects are not but only in the analysis the locations in the almost region are summarized and represented by an atomic assertion while the possibly immediately locations are and explicitly given in the symbolic memory m during symbolic analysis we can explicit storage locations from the almost region and thus update them to hold values that do not match their expected types ie to become immediately when the storage is again consistent with its expected types we can summarize it back into when the heap consists entirely of we know that the entire heap is fully and we can return to type checking given this mechanism we can easily allow for more than one at a time as long as we account for possible aliasing with already locations premise suggests that this explosion is also as an aside we see as a specialization of separating implication n from separation logic for from corresponds to removing a location from its concretization and introducing an implication of the location intuitively the hole in the above illustration into corresponds to putting a location into its concretization and eliminating an implication see section modular checking and symbolic summaries flowinsensitive type signatures are effective for achieving modularity but they do not summarize the effect that a method has on the heap such heap effect summaries are needed when the code that breaks and a relationship invariant is between multiple methods consider again the temporary invariant violation at line in figure but suppose that instead of updating the and selector fields directly the programmer used the idiom with and methods self self each of these methods in isolation break the relationship invariant but they are safe when used in combination flowinsensitive type signatures specify neither alias information nor the effect of the method on the richer specification is needed to check such relationship violations rather than the type analysis with flowsensitive method type signatures or effect annotations we the symbolic analysis with the ability to summarize methods via pre and postconditions describing the structure of the heap in separation logic for example the symbolic summary for the method with a parameter named p would have input heap self and output heap self p this summary says that regardless of its contents on method entry on method exit the field contains the passed in the parameter and the method does not touch any fields other than when symbolically executing the caller of one of these methods we can apply the summary as long we ensure to the summary when checking the method body section uniquely we need symbolic method summaries only as a escape because of an approach within symbolic analysis we can apply a nested type analysis with a different local type invariant this enables using flowinsensitive method types within symbolic analysis and other ways to symbolic reasoning outside of the type system see section on one hand flowinsensitive type signatures are but simple to express and fast to check on the other symbolic method summaries can precisely describe method heap effects but are complex to express and slow to check we therefore can obtain the same precision as a fully symbolic analysis but still take advantage of the simpler more efficient type analysis where the global type invariant holds in contrast to flowsensitive approaches eg we do not need heap effect summaries for all rather only for those very few that leave a relationship invariant violated storage type and symbolic value analysis in this section we provide an description of how type analysis flowinsensitive type analysis and symbolic analysis to check refinement relationships between storage locations for reference we give the full details of the type and symbolic analyses in our tr here we focus on the core contributions of our framework and illustrate them via an instantiation to check reflective call safety syntax of language and types we describe type analysis over a core imperative programming language of expressions e with objects and reflective method call for presentation purposes we have only three types of values unit strings and objects we assume disjoint syntactic classes of identifiers for program variables x y z field names f method names m and parameter names p as well as a distinguished identifier self that stands for the receiver object in methods program expressions include literals for unit strings c objects var f t e def mp tp e the var declarations specify mutable fields f of types t and the def declarations describe methods m with parameters p of types tp and with return type the return type is a base type which does not itself have refinements but could have refinements on its fields in the case of an object base type an stands for a sequence of items methods can also be annotated with symbolic summaries s which we in section objects are heap allocated local variable binding let x t e in e binds a local variable x of type t initialized to the value of e whose scope is e we include one string operation for illustration string append x x then we have reads of x and fields x f writes to fields x f y basic control structures for sequencing e e and branching e e for presentation we use nondeterministic branching as the guard condition of an ifthenelse expression has no effect on flowinsensitive type checking and can be reflected in the symbolic analysis in the usual way ie by strengthening the symbolic state with the guard condition finally we have two method call forms one for direct calls and one for reflective calls a call allocates an activation record for the receiver object z and parameters x it then with the direct name m or the reflective selector y types t are a base type b for either unit unit strings str or objects var f tf def mp with a set of refinements r which are interpreted the framework is parametrized by the language of refinements r needed to specify the invariants of interest and refinements should be parametric with respect to the syntactic class of identifiers we with a rl rf or rs when we want to emphasize or make clear over which syntactic class of identifiers the refinement ranges x fields f or symbolic values v see section respectively because types include refinements types are parametrized as well written t l t f or t s as are type environments instantiation the reflection checking type refinement to verify reflective call safety we have seen that the key property is the p refinement that says an object must to the value named by with the given method type as a symbolic fact it says that an object must to the value named by but as a type invariant on storage locations the refinement also both the storage location on which the refinement is applied and the storage location named by to hold a and a valid selector for it we also need some refinements on string values such as the union of in c cn which says the value is one of the following string literals c cn to type expressions we use the standard typing judgment form e t that says in a type environment expression e has type t a type environment is a finite map from identifiers to types which we view as the types assigned to program variables ie l e t l for the standard typing judgment form that is a flowinsensitive invariant z ··· p tp self z x str in c cn in b has a method named ci with signature p b · · · b xp figure flowinsensitive typing for reflective method calls the refinement is checked on reflective dispatch we provide the full type system for reflective call safety in our tr here we focus on the rules needed to check reflective calls given the desired type invariant figure the rule for checking a reflective method is itself not complicated we require that the object z has a refinement that it to the selector y with method type signature p the arguments to call are checked against the specified types of the parameters via p tp self z we write as the lifting of subtyping to type environments under a substitution from variables on the right to variables on the left the type of the call is then the return base type of the method as expected without any refinements the refinement is introduced via subtyping the subtyping judgment t t says that in typing environment type t implies type t the subtyping rule combines information from base object types and the environment to introduce this rule says that for any location x that is one of a set of selector strings c cn then any object of base type b with methods of the appropriate signature for all c cn to the method named by x with that signature we also have subtyping rules expressing implication of refinements conjunctive weakening of the set of refinements and disjunctive weakening of in refinements for our purposes it does not matter how subtyping is checked as long as it is a sound approximation of semantic subtyping we could for example use an smt solver as in types and also replace the type rules for string operations with an string solver another instantiation typing for array refinements the type analysis framework is parametrized by the language of refinements and a decision procedure for semantic inclusion to provide context for our approach we sketch another instantiation that checks property considered by many prior works with a few refinements and rules suppose we augment our programming language to include array allocation and array access and add two refinements which indicates that an array has the specified nonzero length and which indicates that the specified index is a valid index for the is that the index is in bounds when analyzing an array access ex we check that x is a valid index into the array e by requiring that es type has the refinement x we introduce this refinement via subtyping with the following rule which says that x is a valid index for an array of length y if the environment restricts x and y such that x and x y smt x x y b y b x we verify that this condition holds by encoding the environment into a linear arithmetic formula written and checking entailment with an smt solver written as the judgment smt for formulas and here we map metavariables x and y in the typing judgment to logical variables of the same name in the smt entailment checking judgment e h p o v a x y z h · ex v emp a o h n h · v t s v p p false emp f v o n o symbolic states symbolic environments symbolic heaps symbolic facts symbolic paths symbolic objects symbolic values figure the symbolic analysis state splits type environments into types lifted to values and the locations where values are stored symbolic analysis state and the type analysis is efficient but it is flowinsensitive all storage locations to be a fixed type and the heap to be always in a consistent state when these constraints hold we get a simple and fast analysis when they are violated our overall analysis can switch to a symbolic analysis that continues until the constraints again hold we now through a modified version of the example from section to describe the key components of this switch we describe our symbolic analysis state and how we convert a type environment to a symbolic state we describe and summarization from the almost heap in section we describe the proofs of soundness for and our overall analysis in section and we explore the interaction between modular symbolic analysis and the almost heap in section symbolic analysis state in the symbolic analysis we split a type environment into a symbolic environment e and a symbolic state figure a symbolic environment e provides variable context it maps variables to symbolic values v that represent their values a symbolic state consists of two components a symbolic fact context mapping symbolic values to the facts symbolic types known about them and a symbolic heap h a symbolic heap h contains a that maps addresses a to symbolic objects o which are themselves maps from field names f to symbolic values we write symbolic objects and heaps using the separating conjunction n notation from separation logic to state that we refer to disjoint storage locations symbolic values v correspond to existential logic variables for clarity we often use a to express a symbolic value that is an address and similarly use x y z for values stored in the corresponding program variables x y z relationship refinements in are expressed in terms of types lifted to symbolic values t is the refinements state relationship facts between values and not storage locations like the refinements in for typing our overall analysis state is a symbolic path set p which is a disjunctive set of singleton paths x a singleton path is a pair of a symbolic state and a symbolic value corresponding to the return state and value respectively the symbolic heap h enables treating heap locations much like stack locations capturing relationships in the symbolic context though certainly more care is required with the heap due to aliasing a symbolic heap h can be empty emp a single object a o with base address a and fields given by o or a separating conjunction of h n h and most importantly a can be which represents an arbitrary but almost heap this formula essentially grants permission to from the almost heap and as discussed in section is the key mechanism for soundly between the type and symbolic analyses from type checking to symbolic execution consider the formal language version of the callback example from section e e e i xi i e i i t e for all i et e is e e f o is f o b o h a b · · · b a o domh fields h n a o ay a e h x f y h ex f ey ey h a b · · · o b h n a o summarize h o o b x t s for all x t s e e x t for all x t figure selected rules how type analysis switches to a symbolic analysis to bounded violations var sel var sel str def updated s s str unit d s here the update method updates the and sel fields in sequence recall that the assignment at line breaks the type invariant and the assignment at line it we illustrate the core operations figure behind type analysis by through this example when checking this method the type analysis will produce a flowinsensitive type error for the assignment at line and so will switch to symbolic execution to do so it will a suitable symbolic analysis state from the type environment symbolically execute the two field writes and attempt to the symbolic analysis state back to the original type environment if this succeeds then the type analysis can continue the rule formalizes this process it says the type checker can switch to the symbolic analysis to check an expression e in a type environment by creating a symbolic state representing and symbolically executing e in that state the judgment form e e p says that in the context of a given symbolic local variable environment e and with a symbolic state on input expression e symbolically evaluates to a disjunction of pairs p on output facts and environment are obtained from via the e judgment form while the input heap is initialized to a fully heap after symbolic execution the symbolic state must be consistent with to the original and the symbolic facts about the resulting symbolic value must be consistent with the inferred type t of the expression note that here we lift the subtyping judgment · · · to symbolic types in the expected way here t converts the standard type t to a symbolic type fact t s with a substitution that replaces all variable references in t s refinements with symbolic values both the initially heap and the finally heap must consist solely of heap is assumed consistent on entry and must be on exit the key aspect of this is that although the symbolic execution is free to violate any of the flowinsensitive constraints imposed by it must restore them to return to type checking we will discuss in detail we describe type environments to symbolic states splits a type environment which expresses type constraints on local variables into a symbolic fact map expressing facts about symbolic values and a symbolic local variable state e expressing where those values are stored for example consider the type environment above at line immediately before the first write d ss where var sel var sel str we can this environment to create a symbolic environment where e d ds self here we have created fresh symbolic names to represent the values stored on the stack d is the name of the value stored in local d s in local s etc these symbolic values represent concrete values from a type environment in which the storage location refinement relationships hold so we can safely assume that values initially stored in those locations have the equivalent relationships expressed as lifted types d ss note that the refinement on d refers to symbolic value s and not storage location s but that the refinements on the types of the fields of the base type of fact still refer to field storage locations these field refinements on the base object type are in essence a that if any explicit storage for those fields is later it must be consistent with when summarized back into we formalize type environment in rule which captures the requirement that the state must the original type environment we note that e forms a substitution map from symbolic values to local variable names and require that the fact map under that substitution be an environment of the original type environment rule in essence any assumptions that the symbolic analysis initially makes about the symbolic facts must also hold in original type environment that e is ensures that the inverse exists but more importantly encodes the requirement that the newly environment makes no assumptions about aliasing between values stored on the stack in local variables note that when a local variable with type b rl in a type environment we do not lift the base type b to the symbolic domain nor do we create storage for any of bs fields that is refinements on the fields of an object base type remain refinements over fields expressing both facts about the field contents and constraints on those storage locations this interpretation is what permits immediately objects to point back into ie the almost region as we detail next with this interpretation our analysis storage for objects from on demand which is not only more efficient but is required in the presence of recursion from heaps returning to the callback example recall that the analysis has a state corresponding to the type environment immediately before line a symbolic heap h consists of two separate regions the heap a precise region with explicit storage that supports strong updates and allows field values to differ from their declared types ie permits immediate and the a summarized region in which all locations are either or only in a newly analysis state h consists of solely before the field write at line can proceed the analysis must first storage for the object pointed to by self to get h n self sel sel and a new fact map that contains the additional facts sel and sel str we formalize with the and rules creating symbolic storage for an object type is very similar to a type environment as rule defines the analysis can a type b to a symbolic object o mapping field names to fresh symbolic values and a fact map facts about those values if the assumed facts about the values are no stronger than those guaranteed by the objects field types once the analysis has an object it adds the new object storage to the explicit heap and facts about the fresh symbolic values to the fact map in rule for the symbolic analysis to perform strong updates it must maintain the key invariant that any two objects storage locations in the explicit heap are definitely separate when an arbitrary object the evaluator must consider whether any of the already objects aliases with the newly object and case split on these possibilities the split is required because any two distinct symbolic values may in fact represent the same concrete value in for any input state in which the heap contains the symbolic analysis is free to the object stored at a symbolic address a from the heap for the case where the symbolic address does not alias any address already on the explicit heap we a new symbolic object o with fresh symbolic values as described above from the base type of a in the case where the address may alias some address y on the heap we must assert that a y we write ay for any sound of with the equality we implement it by substituting one name for the other and applying a meet in the symbolic facts we also leave unspecified the that should soundly yield the set of addresses that a our implementation uses a typebased check to rule out simple this rule is quite general it permits an arbitrary number of locations to be immediately without any constraints on ownership or to simplify the formalization of we restrict relations expressed by refinements in the heap to be among fields within objects relations between fields are captured because all of fields of the object are at the same time see supporting relations would merely require multiple objects while considering all possible aliasing relationships and then their fields simultaneously within each configuration it would also be possible to just the fields corresponding to the specific relationships that we wish to violate by using a model of objects symbolic execution with the and complete the analysis now executes the field writes at lines and the rule describes symbolic execution of writing the value of a local variable y to a field f of a base address x it requires that the object at the base address ex already be and updates the appropriate field in the symbolic heap h we give the rest of our symbolic executions rules in our tr they are as expected unlike traditional symbolic analysis our mixed approach can soundly ensure termination by back to type checking in practice we switch to types at the end of loop bodies to cut back edges and cut recursion with method summaries symbolic objects back into types after execution of the field writes the symbolic heap at line is h n self d sel s that is the fields now contain the values passed in as parameters but recall that d s and self in this state the value stored in field again to the value stored in field flowinsensitive type invariant by self again thus the object can be safely summarized back into the we describe this process in rule which says that a symbolic address a pointing to a object o can be summarized ie removed from the explicit heap if the object is consistent with ie can be to the base type required of the address in the fact map a symbolic object o to an object type b rule is analogous to except that it goes in the other direction we require that the symbolic fact map be by the field types of b converting it to the symbolic domain using o as the substitution note that o does not need to be the observation that this constraint is irrelevant for captures that types are to aliasing once all objects have been summarized and thus h the checker can end the to symbolic analysis and resume type checking back to rule as long as the symbolic are consistent with the original for all symbolic paths rule and the returned symbolic values have facts consistent with the return type of the expression concretization and soundness an important concern for and summarization is whether information is soundly between the type analysis and the symbolic analysis ie we have a sound reduced product in particular information from the heap type invariant on demand during symbolic execution and then permits temporary violations of the global heap invariant in some locations we take an abstract approach to soundness which is critical for expressing almost heaps and connecting the soundness of type checking with the soundness of symbolic analysis in this section we describe via concretization the different meanings of object types and their associated reachable heaps in the two analyses further we present the properties of these that are key to proving soundness of and and also state a theorem of analysis soundness we provide complete concretization functions and a full proof of soundness in our tr concretization a concrete state consists of a concrete environment e mapping variables x to values v and a concrete heap h which is a finite map from addresses a to concrete objects o with their allocated base types b we n to indicate both the disjoint heap union of two concrete and the separating conjunction of two static symbolic concretization functions give meaning to abstract constructs by describing how they constrain the set of possible values and states as is standard we write for concretization and it for all constructs except base types and field types object base types and field types have different meanings in the type domain and symbolic domain to we write b for concretization in the type analysis and b for the symbolic analysis concretization in the type analysis in the type analysis the concretization of an object type is fairly standard it exists o where ha o b and for all methods m b h a om b p and for all fields f h o o f b rf · · · h v b and h o v for all refinements ri h o v a types domain exists o where n a o b and for all methods m b a om b p and for all fields f f and if a then h o o f b rf · · · v h v b and for all refinements ri n o v b symbolic domain figure concretization of an object base type b var f tf def mp in the types and symbolic domains in the symbolic domain values stored in the fields of an object in must not be immediately values stored in the fields of an object in are not constrained the region the key difference between the not only the value but also the entire heap reachable from that object as we show in figure a the concretization b of an object type b var f tf def mp yields a set of pairs of heaps and values addresses the concretization requires that the address point to an object o which has suitable method implementations ie constrained by the concretization of the method signature p on an object of type b for each method m in the object type and has suitable field values for each declared field f of type we the type with its storage class f to make clear that it is a field type dependent on other fields the key property of concretization in the type domain is that the concretization of a field type t f b rf · · · is mutually inductively defined with that for base types and thus the entire heap reachable from that field in addition to the other fields of the object this concretization yields a triple where the heap and value are constrained by the concretization of the base type and the entire triple is constrained by the concretization of each of the field refinements because these refinements are dependent refinements they may constrain other fields of the object in addition to the value of the field in question for example a triple in the concretization of a field refinement g would constrain the g field of the object to store a string with name m that is a valid method for the potentially different object pointed to by the value the concretization of a type environment is a set of concrete e h pairs where the values stored in local variables are consistent with the declared types and reachable heaps from the type bindings in concretization in the symbolic analysis in contrast to the type analysis in the symbolic world part of the heap may be explicitly thus immediately leaving the rest of the heap almost to capture this difference the symbolic concretization of an object type yields two heaps and corresponding to a nondeterministic choice of which objects are in the almost heap and which objects are and thus may have field values from their declared types we write b here to emphasize concretization of base types in the symbolic domain the region of figure b illustrates the key difference in the symbolic domain an objects fields are only constrained by the concretization of the field types if the object is in if the object is in the fields are guaranteed to exist but the values stored in them are not constrained because concretization of object types is defined inductively the concretization can opt out of type constraints for the reachable at each field dereference depending on the partitioning of the full heap into and this definition of concretization permits pointers from to and note that regardless of which heap an object in its method implementations are still constrained by their signatures the concretization e of a symbolic state h with respect to a symbolic environment e yields a pair e h there must exist a valuation v values mapping symbolic values to concrete values and a partitioning of the heap h n such that the of e and h all agree upon symbolic fact maps and heaps h both to a set of tuples where emp in the symbolic heap requires both and be empty whereas requires that be empty but can be any heap the singleton heap formula to a singleton in and n is the heap disjoint union in both and a symbolic path is a disjunction of singleton paths p x its concretization is similar to that of a symbolic state except that it yields a triple e h v where v x v soundness the soundness of type in particular of and on the following key properties of concretization at the analysis requires that the explicitly heap be empty the following lemma states that under those conditions ie when the entire heap is the meaning of base types in the symbolic domain is the same as the meaning of base types in the type domain lemma equivalence of typed and symbolic base types b h v h · v b we rely on this result to show that that the and section rules are sound to show soundness of the rule we rely on a property about the meaning of base types in the symbolic domain lemma for types if n a oa ba v b then n a oa ba v b this lemma considers a value v of type b and a heap containing an object oa of allocated type ba stored at address a informally a is in vs reachable heap otherwise it is if there is one concretization of b where a is in the almost heap then the configuration with a moved to the is also in its concretization in essence moving the storage for a to the heap will not cause the type of v to change from the perspective of the symbolic analysis e e t e z dom e e z t e z m h h h h p ey e h n h figure symbolic execution rules to switch to the typed analysis and to apply symbolic summaries a related lemma describes summarization lemma soundness of summarization for states if o b and h and a b · · · then for all e we have e h n a o e h that is if the symbolic execution determines that a symbolic object is not immediately type inconsistent then it can summarize the symbolic storage for that object back into rule without concrete states we rely on the above lemmas to prove soundness of the analysis theorem type analysis is sound that is if e h e r then if l e t l and e h l then r h v where e h l and e h v t l and if e e p and e h e then r h v where e h v e p this is a fairly standard statement of soundness of for both analyses here e h e r says that in a concrete environment e and with a concrete heap h an expression e bigstep evaluates to a result r for types if the initial concrete state is described by the static type environment and the expression type checks then the expression evaluates to a pair that is not to an error where the final state still to the type environment and the value to the static type similarly the symbolic analysis soundly the concrete execution and rules out a error the proof proceeds by induction on the derivation of concrete execution and covers an additional judgment form describing generalized symbolic provide full details in our tr analysis as described in section the type analysis can hand off checking of an expression to the symbolic analysis we also would like to perform the opposite from symbolic to type ie apply type analysis within symbolic analysis for example we would like do this when we a method call during symbolic analysis to enable modular analysis with only type specifications fortunately we can employ the same consistency mechanisms to allow in the other direction that is to switch from symbolic analysis to type checking rule in figure the key constraint is that the entire heap must be fully in general this requirement means summarization should have been applied so that no locations are the entire state is checked type consistent via to before type checking and then symbolic analysis can resume by a new symbolic state from and adding an assumption from the type of the expression suppose this symbolic analysis is the context of an outer flowinsensitive type analysis observe that type environment is derived solely from the current symbolic execution state and could be more precise than the outer flowinsensitive invariant a common scenario is to symbolic reasoning about guard conditions in an if but switch to type analysis inside the if body with a stronger invariant without to the make any changes to the type analysis cf occurrence typing for the reflective call safety client the checked idiom is quite common where a reflective call is performed after checking if an object to a particular in symbolic summaries for bounded violations on the other hand we have seen a of cases where a further precision refinement is needed when programmers break relationship refinements across module boundaries such as when they abstract the heap with and to see how this is a problem consider the slightly modified version of the update function in which the direct field access is replaced the following functions def d d def sel s s this small change the problem of checking relationship refinement safety because now the invariant violation module function boundaries and thus cannot go to a fully heap on method call to support this scenario we enable the programmer to supply additional checked annotations symbolic method summaries of the form that permit symbolic checking across module boundaries here p is a sequence of method parameter names h and h are summaries of the input heap and output heap respectively and specifies the method return value the input summary gives the form of the part of the heap the method will operate upon the footprint and gives names to the values stored in the fields of the input heap the output summary gives the form of the heap after the method has finished executing in terms of the names given in the input heap and the parameters for example the method summary annotation at line says that whatever the field stores before is called after the method is executed the field stores the value from the d parameter since the method is a the return value is irrelevant the annotation for is analogous applying the summary for leaves the heap in an inconsistent state but then the summary for it with these annotations checking the calls to the is analogous to checking the field writes as before except that rather than applying the symbolic transfer function for field writes we apply the method summary we formalize this in the rule in figure the auxiliary function m looks up the summary of a method m on a static type t the judgment h h h splits the heap h into a footprint specified by h and the frame that the method is guaranteed not to touch this frame inference also produces a symbolic map h that captures the symbolic variables that the parameters in the h match to during the splitting we then apply this map combined with the mapping from parameter names to the symbolic values passed in as parameters to the output summary h to get the footprint on method exit and add it back to the frame to get the entire heap on method exit we also this map to look up the value returned as specified by the summary we write for disjoint union of maps where the result is undefined if the union is not a map the frame inference is a simple application of but makes this rule quite flexible the can choose to access to in a symbolic summary as above to provide a stronger guarantee to the methods callers or request it to get a stronger assumption for checking the method implementation we note that the particular kind of symbolic summary that we describe above essentially standard in separation logic is not the most interesting point other symbolic analysis techniques could be applied such as contextsensitive non modular reasoning rather we argue that the interest lies in that symbolic analysis machinery can be applied when needed without the cost of applying it everywhere all the time checking method implementations for modular checking we type check each method implementation separately according to its type signature as is standard we guarantee that the implementation of a method to its summary with our symbolic analysis infrastructure although the summary checking technique is orthogonal to that for checking relationship refinements one could substitute a different approach eg abstract interpretation or interactive proofs if desired case study checking reflective call safety we implemented our type analysis approach to checking almost flowinsensitive invariants in a prototype method reflection safety checker for we evaluate our prototype a to the static analyzer by the following questions what is the increased type annotation cost for checking reflection safety how much does the mixed approach improve precision do our premises about how programmers violate relationships hold in practice is our almost type analysis as fast as we hope we also discuss a bug found by our in a application the bug fix that we proposed was accepted by the application table describes our performance on a benchmark suite of libraries and large applications the are because they are very large and have been in continuous development since the fact that our tool can run on them provides evidence for the kind of real world that we can that would be challenging for a purely symbolic analysis we discuss these results throughout the rest of this section the cost to add modular reflection checking to potential type errors we first annotated the reflection requirements on system library functions ie with refinements these are requirements imposed by the system api to check for method reflection errors then for each benchmark we report the total number of annotations required as well as the average number required per reflective call site to give an of how much work it would be for developers to check their use of reflection column total annotations all annotations are emit a static type error if their requirements are not met based on this column we observe that our benchmarks fall into three categories depending on how they use reflection clients of reflective such as and have a very low essentially zero annotation burden in contrast benchmarks that expose reflective interfaces such as and have a higher annotation burden this is perhaps not surprising since annotations are the mechanism through which interfaces expose requirements to clients in the middle are those that use reflection in both ways parts of do expose a reflective api but they also use internal reflection quite significantly our application benchmarks also fall in this category they are structured into modular application frameworks and a core application client over our entire benchmark suite we find that we need annotations and symbolic summaries per reflective callsite row combined columns total annotations and symbolic annotations in other words on average the programmer should expect to write one annotation for every uses of reflection and a single symbolic heap effect summary for every uses of reflection importantly note that almost all of annotations are extremely lightweight refinement annotations like only of methods required a symbolic summary even there the summaries were very simple because they were on leaf methods such as this overall low annotation burden a key benefit of our optimistic mostly flowinsensitive approach whenever the reflection relationship is preserved no method summary is needed contrast this to a modular flowsensitive approach where a summary is needed on all methods to describe their potential effects on fields improved precision we verified reflection safety on our benchmarks using two configurations a completely flowinsensitive analysis no switching and our mixed approach we then compared the number of static type errors reported by each columns fi type errors and type errors type analysis sometimes significantly reduces the number of static type alarms eg by in our combined benchmark suite the number of static type alarms ranges from for and to for our most challenging benchmark our tool as a analysis we manually all the reported static type errors to determine if they could manifest at runtime as true bugs see discussion on bugs below or otherwise are false alarms due to static overapproximation the single source of false alarms were reflection calls on objects from collection classes underlying type system for parametric polymorphism like what has been for java with would directly improve precision for this case at the same time as discussed below the efficiency of makes it feasible to instead consider it as a type checker where a small number code or cast are not especially if most casts would go away with generic types premises we designed type analysis around two core premises section that most of the program can be checked and that even when a flowinsensitive relationship between heap storage locations is violated most other relationships on the heap remain as table shows the number of times the analysis switches to symbolic execution and back column successful symbolic sections is quite low even for large appears to hold the maximum number of simultaneous column max is also holds as well note that we need more than the single that would be possible with a flowsensitive analysis modular reflection checking at interactive our two core premises hold enabling type analysis to soundly verify almost everywhere invariants quickly analysis times range from less than a second for our smaller around lines of code benchmarks to around seconds for our largest about lines of code these results column analysis time include only the time to run our analysis they do not include parsing or base type checker our goal with these measurements is to determine the additional compiletime a would when adding our analysis to her existing workflow expressed as a rate of lines of code per second our analysis ranges from about to around with a weighted average of in general the larger benchmarks show a faster rate because they the high cost of checking system which are typically more than over larger compilation units finding bugs when running our tool on the benchmark we found a real reflection bug in a application nc nc here an object registers interest in being whenever any code in the project a this takes the form of a reflective callback the method of self will be called unfortunately self has no such method our benchmark combined lines of code refl call sites methods total annotations per refl site symbolic annotations per refl site check sites fi type errors type errors reduced ­ successful symbolic sections max analysis time rate s s s s s s s s s s table the lines of code count includes project but comments and methods indicates the total number of methods refl call sites gives the number of calls to system library methods that perform reflection either directly or as part of some other operation total annotations lists the total number of annotations and the average number of annotations required per reflective callsite symbolic annotations lists gives the number of symbolic summaries required check sites gives the number of program sites where some annotation was checked fi type errors indicates the number of check sites where a flowinsensitive type analysis produces a type error type errors indicates the number of check sites where we emit a static type error and the corresponding reduction from the flowinsensitive approach successful symbolic sections gives the number of times our analysis successfully from type checking to symbolic execution and back again max gives the maximum number of objects ever present in the explicit heap this includes symbolic sections and analysis time indicates the speed of our analysis on each benchmark in both absolute terms and in lines of code per second our benchmarks include which performs consumer authentication which records custom and is the source of our motivating example in section which reads and writes compressed a automatic which performs web services calls and the which provide base functionality to the widely used application an a pdf reader and an instant message client the combined row treats all of the benchmarks together as a combined experiments were performed on a core intel core i with gb of ram running os x we used compiled in mode to perform the analysis and h to the build analysis detects this error and issues an we reported the bug to the developers they it as a bug and fixed it see our tool was also useful in finding bugs in code we used it to statically detect runtime errors in code from lists and discussion these reflective errors into three different categories in selector names to call a method with a selector stored in a variable but instead passing in a constant selector with the name of the variable and passing the wrong into a reflective call typically a field of self instead of self itself these results show that our tool can statically detect a common class of errors they provide evidence in of including reflective call checking with type analysis in the compiler related work dependent refinement types enable programmers to restrict types based on the value of program expressions and thus rule out certain classes of runtime errors such as array accesses extending dependent types to imperative languages has generally led to flowsensitive type systems because mutation may change the value of a variable referred to in a type the high burden that flowsensitive type annotations impose on the programmer sophisticated inference schemes of which is perhaps the work to ours in contrast to which performs flowsensitive checking of inferred flowsensitive types with at most one we use checking of flowinsensitive annotations and support arbitrary with a disjunctive symbolic analysis as opposed to proving for one eg checks dependent refinements in javascript including the safety of dynamic field problem similar to reflective method call supports only single and a flowsensitive heap there has been a recent explosion in techniques eg that have significantly improved the effectiveness of symbolic execution the approach smt technology combined with abstract interpretation on path programs to lift a based technique to exhaustive verification this technique can be seen as applying a fixed one level of analysis switching between a toplevel symbolic and an abstract interpreter for loops our approach of switching between type checking and symbolic execution is similar to the mix system for simple types a significant difference is that our approach enables the symbolic to the invariant enforced by the type analysis through a operation which is critical for our rich refinement relationship invariants whereas the symbolic and type analyses in mix interact with respect to the heap the notion of temporary violations of an invariant is also of the large body of work on object invariants see for an overview we remark on two perspective differences that make complementary to this work first the points where the invariant is assumed and where they may be violated is not based on the program structure eg inside a method or not but instead is based on the analysis being applied ie type or symbolic second the symbolic analysis takes a more global view of the heap and specifically which objects may violate the global type invariant issues like and invariants are not as in but are possible at the cost of separate symbolic summaries or more expensive disjunctive analysis in certain complex situations on heap locations our symbolic analysis works over separation logic formulas we define an that is universal in however our operator out heap cells that are summarized and validated independently using a refinement type analysis shape analyses are modular analyses that try to infer a symbolic summary for each method our analysis is modular using a fast flowinsensitive type analysis with few uses of symbolic summaries and our technique could complement each other in that we do not require symbolic summaries on all those that violate type consistency across method could be applied to generate candidate symbolic summaries most prior work on reflection analysis has focused on resolution determining at a reflective site what method is called either statically or dynamically we address the problem of modular static checking of reflective call safety ensuring that the receiver to the selector in languages with imperative update et al describe a type system that checks reflection safety by combining occurrence typing with firstclass member names specified by string patterns in contrast we treat the relationship as firstclass ie we permit the user to specify it with a dependent refinement allowing us to check relationships between mutable fields and express that an object to two completely unknown ie potentially identical selectors et al assume reflection safety and this assumption to improve precision of construction conclusion we have described type analysis which fast type analysis over storage locations and precise symbolic analysis over values to efficiently effectively and prove relationship properties we have evaluated using an interesting safety method call safety the key technical for our analysis is from an almost heap on a benchmark suite consisting of libraries and applications we find that our approach is capable of finding bugs in both production and code it has a balanced annotation burden that is for clients of reflection and up to annotations per reflective call site for reflective interfaces type analysis starts with the optimistic assumption that global flowinsensitive relationship invariants hold almost only has to use precise and expensive reasoning for those few program locations that violate a relationship contrast this to traditional modular flowsensitive analyses which require all methods to specify their effect on the heap to rule out the pessimistic assumption that relationship invariants could be violated anywhere our approach permits the of methods to avoid any annotations related to heap effects checking most of the program allows to validate reflective method call safety at interactive to with an overall rate of over our benchmark suite acknowledgments we thank siek the group and jhala for discussions as well as the anonymous reviewers for their helpful comments this material is based upon work supported by the national science foundation under grant and references a ahmed m and g morrisett l a linear language with locations a aiken j s foster j and t checking and inferring local in pldi j berdine c calcagno and p w ohearn symbolic execution with separation logic in j berdine c calcagno b cook d p w ohearn t and h yang shape analysis for composite data structures in cav e a j h and m reflection static analysis in the presence of reflection and custom class in m and j towards partially evaluating reflection in java in c d and d r and automatic generation of tests for complex systems programs in c calcagno d p w ohearn and h yang compositional shape analysis by means of in popl by e and x relational inductive shape analysis in popl a s a and m i precise analysis of string expressions in sas r d and r jhala dependent types for javascript in oopsla j m z r d and g c necula dependent types for lowlevel programming in esop d and by e type analysis modular checking of almost everywhere invariants extended version p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in popl p cousot and r cousot systematic design of program analysis frameworks in popl d p w ohearn and h yang a local shape analysis based on separation logic in tacas s a p and a j a unified framework for verification techniques for object invariants in ecoop m and r adoption and focus practical linear types for imperative programming in pldi c flanagan hybrid type checking in popl t and f pfenning refinement types for ml in pldi m d an and j s foster static typing for dynamic languages in oopsla p n and k dart directed automated random testing in pldi b s s g and a v bottomup shape analysis in sas w r s f and a gupta program analysis via satisfiability modulo path programs in popl y p by e and j s foster type checking and symbolic execution in pldi v by e and x separating shape graphs in esop b j and m s lam reflection analysis for java in m j parkinson local reasoning for java phd thesis university of cambridge computer laboratory j g a and s semantics and types for objects with firstclass member names in j c reynolds separation logic a logic for shared mutable data structures in lics p m m and r jhala types in pldi p m m and r jhala lowlevel types in popl m sagiv t reps and r solving problems in languages with destructive updating acm trans program lang syst r j chen and c objectoriented typed assembly language in pldi s and m felleisen the design and implementation of typed scheme in popl o m s j m and o effective taint analysis of web applications in pldi h xi imperative programming with dependent types in lics h xi and f pfenning dependent types in practical programming in popl 