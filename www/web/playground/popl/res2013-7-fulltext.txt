relatively complete verification of higherorder functional programs university of university kobayashi university of abstract we present an automated approach to relatively completely verifying safety ie reachability property of higherorder functional programs our contribution is first we extend the refinement type system framework employed in the recent work on incomplete automated higherorder verification by on the classical work on relatively complete hoare logic like program logic for higherorder procedural languages then by the recently proposed techniques for solving constraints over quantified firstorder logic formulas we develop an automated type inference method for the type system thereby an automated relatively complete verification of higherorder programs categories and subject descriptors d software engineering verification f logics and meaning of programs specifying and verifying and reasoning about programs keywords relative completeness higherorder programs software model checking type inference introduction recently motivated by the success of software model checkers for the automated verification of firstorder programs researchers have proposed model checkers for the automated verification of higherorder programs interestingly they have all been formulated as a form of refinement type inference the refinement type systems employed in the automated higherorder program verification have some important differences from the ones from the original approaches like dml making them more amenable to automation such as the lack of implicit types but they follow the ones in that the types embed firstorder logic fol formulas called refinement predicates over program values as in dependent types that are used to express and enforce detailed properties of the program for example consider the ocaml program shown in figure here denotes a nondeterministic choice given an in in fact the equivalence of model checking and refinement type inference has been shown for the finite domain data case permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm let rec app x f if then app x f else f x in let check x y if x y then else assert false in let main i app i check i figure a simple higherorder program argument i to main the program recursively calls app nondeterministically to apply the closure check i to i j where j is the number of times the then branch is taken in app the program is safe in that assert false is unreachable for any argument i the program is difficult to verify via firstorder program verification methods because of the higherorder recursive function app recent advances in higherorder program verification have enabled automated verification of such programs via refinement type inference for the program above the following refinement types may be automatically inferred to verify its safety app xint f u x unit unit check xint y u x unit main unit the type of app expresses the fact that the function takes an integer argument x and a argument f which takes an integer at least as large as x the type of check says that it takes integers x and y such that x y and the type of main says that it takes any integer argument the refinement type systems underlying the are sound that is they only type safe programs however they are incomplete in that there are safe programs that they cannot type indeed the only known positive result is for the class of the finite domain data programs which can be verified completely by a refinement type system augmented with intersection types the situation is in contrast to that of automated firstorder program verification where the underlying program logic such as the hoare logic is relatively complete for example none of the refinement type systems proposed for automated higherorder program verification can type and verify the program shown in figure even though the program is only a small modification of the one from figure it simply switches the order of arguments nor are they able to type and verify the program shown in figure which uses the function succ to build closures to pass integers larger than i to check i the program is even if we were allowed to change the order of the function arguments we note that this is an incompleteness at the level of the program logic ie refinement type system and not the verification algorithm ie type inference algorithm that is there exist no types within the refinement type system that can type the program the type syntax is from let rec app f x if then app f x else f x in let check x y if x y then else assert false in let main i app check i i figure a variant of figure let rec app f g if then app succ f g else g f in let app x f f x in let succ f x f x in let check x y if x y then else assert false in let main i app check i app i figure another variant of figure let alone ones while higherorder program verification is in general undecidable like the firstorder program verification is it would be desirable to have a relatively complete reasoning framework that would serve as the basis of verification algorithms as the hoare logic does for firstorder programs to this end this paper presents an automated approach to a relatively complete verification of higherorder programs first we present an extension to the refinement type system such that the resulting refinement type system is relatively complete the extension is inspired by the classical work on relatively complete program logic for higherorder procedural languages by et al also who showed that relative completeness is while avoiding the explicit use of functions as data so as to maintain a hoare logic like separation however their proof of relative completeness does use encoding of functions as data and we rely on the same technique for our relative completeness proof moreover to hide the use of functions as data from the program logic they introduce quantifiers that the client verifier must appropriately instantiate to the best of our knowledge no actual verifier was built based on their program logic therefore as our second contribution we show a type inference method that extends the firstorder logic constraint solving of the previous automated refinement type inference systems to quantified reasoning by recent advances on a related problem in summary the papers contributions are as follows · a refinement type system that is relatively complete for safety verification of higherorder functional programs · a type inference algorithm for the refinement type system in the next section we give an informal overview of the main ideas on incompleteness of the inference the type inference algorithm that we propose is of course incomplete in that it is not able to decide the typability of all programs this is expected because safety verification is undecidable in general instead our contribution is a type system that is complete relative to a theorem prover complete for firstorder arithmetic and a novel inference algorithm that is able to automatically verify a nontrivial subset of the programs that were not possible to verify with the previous automated approaches informal overview we informally describe the incompleteness issue by showing how the existing approaches fail to type the programs shown in figures and first let us try to type figure here the goal is to show that main can be given the type i int unit that is main is safe to be called with any integer i for a base type b we often abbreviate the refinement type ub as b eg int therefore we try to type the body of main under the assumption that the type of i is the most precise type for the partial application check i is y u i unit ie functions that can take any integer at least as large as i and the most precise type for i is u i ie integers equal to i intuitively ub expresses values of the base type b satisfying the refinement predicate and x expresses functions that return a value of the type ex when given the argument e of the type we show that the type systems fail to give the higherorder function app a sufficiently precise type to verify the programs safety the type of app must be of the form f unit unit where the refinement predicates and are fol formulas in the theory of data in addition as discussed below to prevent types the refinement type systems enforce an important wellformedness condition that restricts the variables that can appear free in a refinement predicate here and are restricted so that fv u and fv f u where fv denotes the free variables of from the application f x in the body of app the type system asserts that that is f must be safe to be given the argument x in the body of main app is applied to check i and i and the type system asserts that the type of check i is a subtype of unit and the type of i is a subtype of this leads to the constraints u i and u i accurately expressing the fact that i is passed as the second argument to app and that the first argument to app ie check i expects a value at least as large as i a solution to the set of constraints is u i and u i but this is because variable i would appear in type recall that are refinement predicates of type intuitively it means that the function app could see values from a specific context of its use ie main indeed as above the refinement type systems such types via the wellformedness condition and only allow such that fv u and fv f u that is the refinement predicates are allowed to only mention the variables in their respective consequently the program is conservatively rejected as it is worth noting that the program of figure does not have this issue as arguments are ordered so that argument could depend on the argument to allow the following sufficiently precise type xint f u x unit unit unfortunately as by figure the incompleteness issue is not just a matter of choosing the right order of function arguments here the program is even if we were allowed to change the order of the arguments and the comes from not being able to give a precise enough type to app we would like to express via type the fact that g is safe when applied to f and also when applied to f for any j but this requires a type that is parametric in f and gs behavior and that cannot be given because the only parameters of app are f and g and they are both arguments note that refinement predicates of the form g is safe to be called with f are as they are required to be fol formulas over the data we could also give non refinement predicates to unit but it does not affect the example our approach our approach to solving the incompleteness issue is inspired by the research on relatively complete program logic for higherorder procedural languages ­ the main idea is to add extra dummy parameters that are instantiated appropriately so that the refinement type of a higherorder function can depend on the parameters for example for the program of figure we add an extra parameter a to app and obtain the following program let rec app a f x if then f x else f x in let check x y if x y then else assert false in let main i check i i here for clarity the parameter for the extra parameters are written as quantifier instantiations but they may be understood as ordinary function applications eg is app a with the addition of the extra parameter it becomes possible for the existing refinement type systems designed for automated verification to type and verify the program for example the following types are sufficient for typing the program app f unit x unit check xint y u x unit main unit where u a note that the extra parameter a is used to f s behavior in the type of app there is a simple rule to adding extra parameters that can be shown to be sufficient for relative completeness add one just before each argument following the rule for example the program of figure is translated as follows let rec app a f b g if then fa g else ga f in let succ b f x f x in let check x y if x y then else assert false in let app x a f f x in let main i check ii app i and it can be shown that the resulting program is typable for example by the following types app f g unit app xint f u x unit unit succ f unit x unit check xint y u x unit main unit where u b u a unit and unit however the rule does not answer how the extra parameters should be instantiated in the above we seem to have the appropriate instantiations i and a indeed an analogous rule was first discovered by clarke and in their work on a relatively complete program logic for higherorder procedural languages and their proof of relative completeness relies on the fact that with an expressive theory of the data domain such as arithmetic one can encode each function closure as a data expression so that the extra parameters can be instantiated by the data representation of the corresponding argument however explicitly instantiating the extra parameters by such encoded expressions and forcing the client verifier to reason about them is d d f x e e x f c let x e in e e x if then e else e figure the syntax of the simple functional language therefore they proposed to leave the instantiations unspecified in the program logic so that the task of finding sufficient instantiations is left to the fol theorem prover of the client verifier following the idea for example the program of figure is translated as follows by introducing fresh variables v and v let rec app a f x if then f x else f x in let check x y if x y then else assert false in let main i check i i then the refinement type inference problem is reduced to the problem of finding appropriate instantiations for v and v along with the types for the program for this we extend the fol constraint solving used in the previous work on refinement type inference with quantified reasoning over template expressions concretely in section we show how the counterexampleguided refinement type inference can be extended in this way to infer appropriate instantiations as well as types paper organization the rest of the paper is organized as follows section presents the refinement type system along with the target functional language and proves its relative completeness under the extra parameter addition strategy section presents the type inference algorithm section presents the preliminary experience with the type inference algorithm implemented as an extension to the higherorder software model checker ie refinement type inference system section discusses related work and section concludes the extended report contains the omitted language and type system we formalize the target programming language figure shows the syntax the language is essentially the simplytyped lambda calculus with recursion and primitives for integer arithmetic operations for simplicity the only data in this language is integers but other base types and their operations can be encoded in the functions are mutually recursive in that the body of a function may refer to other functions including itself each function is closed except for the free function names ie functions are lambda lifted we also assume that d contains a function named main that only takes ie integer arguments expressions e nondeterministic branches let expressions constants c function names f variables x and constant or userdefined function applications e x constants include integer constants such as and integer operations such as and recall that we model booleans via integers we assume that there are unary constant operators named assert and assume we restrict expressions to be in continuation passing style cps so that they are except when they occur ie occurs as e in let x e in e by contrast expressions are restricted to be ie value returning expressions which are total applications of constant operators including the assume and assertion expressions assume x and assert x and let x e in e d where e e let x assert in e d ex let x assert i in e d fail where i let x assume in e d ex let x assume i in e d safe where i if then e else e d e e d e where f x e d figure the reduction rules partial applications of userdefined functions we restrict constant operator applications to be total is used for simplicity syntax can be supported by cps sion the rest of the syntax is straightforward as usual applications to the left so that e e the series of applications e e e e e we e e en where we e e en we write e e for let x e in e such that x fve where fve denotes the free variables of e without loss of generality we assume that bound variables are distinct note that while the language only has nondeterministic branches a conditional branch if x then e else e can be encoded as if then assume x e else let y ¬x in assume y e which is equivalent for assertion safety we define the operational semantics of the language as a small step reduction relation from states to states a state is a runtime expression e that extends the source expressions with arguments at function applications a special failure state fail and a special safe state safe we the symbol e to range over runtime expressions when it is clear from the context the reduction relation d is defined by the rules shown in figure here e the e denotes the value e and evaluation is defined of as where c is the relation denoting the semantics of a constant c so that for example i j i a j for integers constant i and j an we let partial function closures formally a value is either an integer constant or a function closure the that because of cps reductions only occur at the top level we write e d e for zero or more reductions from e to e we say that a program is we assume that a program is typed under the standard simple type system whose type grammar is shown below s int s s here the type represents the type of a cps expression for each expression e in the program we write to denote its simple type the typability in the simple type system that the program does not get stuck for example by trying to use an integer as a function but it does not guarantee its safety therefore a program either runs forever safely due to cps a program cannot return stops safely in the state safe by reaching a false assume or aborts with an assertion failure the typing rules for the simple type system are standard and are deferred to the extended report u x figure the syntax of refinement types int x u u x vb vf e x e c let x e in e let e y x e x xy app e e if then e else e if e fv dom e sub figure the typing rules refinement type system we present a refinement type system for the language first we present a sound but incomplete refinement type system without the extra parameter addition and then introduce the extra parameter addition as an extension in section the incomplete refinement type system is not significantly different from the ones proposed previously for automated verification eg it can be obtained by removing intersection types from figure shows the syntax of refinement types here u is a refinement base ie integer type that refines an integer by the refinement predicate which is a fol arithmetic formula over the base ie integer type variables we sometimes abbreviate u as int when is a eg u int intuitively u denotes the type of integers u satisfying the formula the type x is a dependent function type consisting of the argument type and the return type intuitively x denotes the type of a function or a constant operation that returns a value of the type yx when applied to an argument y of the type as usual associates to the right the type x binds x in likewise x binds x in but not in that is fv x fv fv x we sometimes abbreviate x as when x does not occur free in it actually suffices to limit x to occur free in only if x is a base type argument because refinement predicates are restricted to be over the variables types are equivalent up to renaming of bound variables the shape of is defined as follows int while intersection types are not needed for relative completeness they neither soundness nor completeness and sometimes aid the verification in practice the implementation shown in section supports intersection types the full theory of arithmetic is needed for relative completeness but any subset eg the quantifierfree theory of linear arithmetic is sufficient for soundness x x x sf u fv sc u u sb figure the subtyping rules figure shows the typing rules the judgements for the expressions are of the form e where is a type environment mapping variables and function names to types we discuss each typing rule vb types variables note that the rule ignores the environment is not reduced however because the assumption about x in the environment gets at subtyping vf types variables and function names by looking up the environment here denotes the set of simple function types we use the meta variable to range over both variables and function names types constants here denotes the type of the constant c such that xint u x u xu u u u and is the precise type for a constant c eg ty x int y int u u x y let is app types applications here xy is the usual substitution if types branch expressions sub is the subsumption rule the subtyping relation is defined in figure in sb is the fol formula denoting the assumptions about the variables in and is defined as follows xu xu like the rule of consequence of the hoare logic sb the client verifier ie the type inference system to decide the validity of arbitrary fol arithmetic formulas as expected our completeness result is relative to the completeness of deciding this in verification practice one may for incomplete theorem proving or a decidable theory subset to make type checking decidable sub enforces wellformedness of the introduced type by that its free variables appear bound in the environment as shown below the toplevel types ie the types of the recursive functions are required not to contain free variables definition wellformed type we say that a type is closed if it has no free variables let be a toplevel type environment mapping function names to types we say that is a wellformed type for f if is closed and we say that is a wellformed toplevel type environment if f is wellformed for each f · · · let us xn the function xn type x n we define the notion of a welltyped program definition welltyped program we write d if the following conditions hold is a wellformed toplevel type environment see the extended report for the definition of a precise constant type also but sound constant types that the actual semantics are sufficient for soundness also type checking being decidable is different from type inference ie typability being decidable the previous research has proposed various incomplete inference approaches for each f x e d we have x e where main is of the form xint ie the refinement predicates for the arguments of main are all a program d is said to be welltyped equivalently typable if there exists such that d the condition says that contains fixedpoint types for the recursive functions d and says that main is safe to be called with any arguments recall that main is a function over integer arguments the type system is sound in that it ensures that a welltyped program does not cause an assertion failure theorem soundness if d then d is safe the theorem follows from the soundness of the refinement type system extended with extra parameter additions theorem example let the program d consist of the following functions app x f if then app x f else f x check x y if then assume x y check x y else assume ¬x y assert check x y main i app i check i the program is the one from figure translated into the target language we for readability let be the following type environment app xint f u u x check xint y u u x main it is routine to check that d therefore d is typable and is safe next consider d shown below app f x if then app f x else f x check x y if then assume x y check x y else assume ¬x y assert check x y main i app check i i the program is a translation of the program from figure the program is safe but as in section also under the previous refinement type systems note that we cannot simply assign app the type app from the above but with the order of x and f so that f u u x xint the type is not closed and therefore is not a wellformed toplevel type cf definition the wellformedness condition forces the refinement predicates to only refer to the values passed earlier wellformedness is not a restriction in the presence of higherorder functions and function closures ie partial applications we cannot generally determine up front in the program logic what will be passed later to a closure the issue is apparent in the following program d which is a translation of figure app f g if then app g else g f app x f f x succ f x f x check x y if then assume x y check x y else assume ¬x y assert check x y main i app check i app i as in section the program is safe but even if we were allowed to change the order of the function arguments here it is not possible to determine what will be passed to the e x o o e ox inst x x x s figure additional typing rules closures f without some nontrivial program reasoning ie i captured in g added the number of times then branch is taken before the else branch is reached in effect the idea of the extra parameter addition for relative completeness is to such tasks to the client verifier extra parameters for relative completeness as shown in example also section the refinement type system is incomplete by itself while a complete checking of safety is clearly undecidable as the language allows arbitrary integer operations we would like to make the refinement type system be complete relative to an oracle that could decide the fol implications at the subtyping rule sb rather than the extra parameter addition as a program translation as done in section here we present it as a type system extension in the form of universally quantified types this is convenient because extra parameters can be represented as universally bound variables so that they can be easily distinguished from ordinary parameters we extend the grammar of refinement types with universally quantified types as follows x in x x is a binding occurrence and may occur free in ie fv fv x intuitively it expresses the function type x such that x is an extra parameter we define we extend the type system with the quantifier instantiation and the subtyping rules shown in figure here is the set of expressions defined by the grammar o x c o where x is an variable and c o is a total application of a constant therefore inst allows instantiation with any expression having the type s is analogous to the subtyping rule for function types ie sf to distinguish we write for the type judgements of the extended type system all the rules from figure and figure are assumed to be included in with replaced by the wellformedness definition is also from the pre extension cf definition therefore for example both xint u u xint y u y are wellformed refinement types for f such that int int or universal is defined as follows x x if if x and if x and we extend the typing rules to expressions in the obvious way see the extended report with abbreviation introduced each universal quantifier binding x and the binding x that is we extend the notion of welltyped program to accommodate universal quantifier bindings definition welltyped program ­ extended we write d if the following conditions hold is a wellformed toplevel type environment f x e d we have main is of the form xint e a program d is said to be welltyped if d the are type of and the func tions also note that the wellformedness condition now allows the refinement predicates to refer to the universally quantified variables in their scope we state the soundness of the extended refinement type system theorem soundness ­ extended if d then d is safe the proof is standard and is deferred to the extended report as in section for relative completeness it suffices to limit the position of extra parameters ie universal quantifiers to one before each parameter to this end we define to be a simple type such that for a function of the simple type has just the sufficient extra parameters formally is defined by the rules below int int int x note that is defined only for that has one extra parameter just before a parameter also for such that is defined we have we are now ready to state the relative completeness theorem which says that if a program is safe then it can be typed with extra parameter additions even when their positions are restricted to the pattern above theorem relative completeness if d is safe then there such d that d and for each we defer the proof to the extended report the proof the ideas from the work on relatively complete program logics for higherorder procedural languages ­ that instantiate the extra parameters by the encoding of the function closures it is worth noting that as a corollary of theorem it follows that the refinement type system is relatively complete for firstorder programs ie programs without parameters even without the extra parameter extension example we show how types d and d from example first we have d where app u u a xu u a check xint y u u x main note that the types correspond to the ones used to type figure in section also note that and it is easy to see that check can be given the type check we show that app can be given the type app we type the body of app under the type environment a int f u u a x u u a therefore the application f x to give the type to type the other branch app f x we instantiate app with a at app to give the type f u u a xu u a the type is then used to give the application app f the type x u u a which in turn gives the branch the type finally main can be given the type main by instantiating app with i likewise let be the following type environment app app xint u u x succ x check xint y u u x main such that u u a c int and u u b note that for each f app app succ check and main we show that d by following the same instantiation scheme used to type figure in section we type the then branch of app by instantiating app and succ with a and instantiating the resulting app succ f with a or with an arbitrary expression because b does not appear free in its scope in app the else branch can be typed by instantiating g with an arbitrary expression because c does not appear free in its scope in app then to type main we instantiate app with i and instantiate app check i with an arbitrary expression the examples show that instantiating via simple expressions are often sufficient for verifying safety and not all quantifiers may even be needed contrast this with the instantiation via numbering used in the proof of theorem we take advantage of the observation in the type inference method described in section type inference the type inference framework is based on and extends the recent work on the counterexampleguided approach to refinement type inference but the idea may be adopted to extend the of other refinement type inference systems like to allow smooth adoption and use the existing type inference algorithms mostly as a we implement the extra parameter addition as a program translation as in section instead of modifying the underlying type system to model it by universally quantified types as in section figure shows the overview of the type inference process in step we translate the given program by adding extra parameters as done in section here we maintain and use a parameter substitution for instantiating the extra parameters we initialize the instantiation expressions to arbitrary constants eg and then perform a counterexampleguided refinement type inference over the translated program following the counterexampleguided abstraction refinement cegar scheme in model checking in the counterexampleguided refinement type inference we maintain a this can be seen as a difference between just checking safety and expressing the precise semantics as weakest preconditions input program step parameter addition section translated program safe typable step fixedpoint type inference new parameter substitutions new candidate types counterexample step refinement section infeasible step feasibility check feasible unsafe figure the type inference overview set of candidate refinement types or the refinement predicates that them then we try to find a type assignment for the program within the candidates via the standard fixedpoint type inference process step in figure the fixedpoint type inference uses an automated fol theorem prover such as a smt solver to decide the fol implications at the subtyping rule sb we refer interested readers to the previous work for details a counterexample is generated when the candidates are found and we analyze the reason for the failure to either validate the counterexample step or update the candidate types or the parameter substitution to eliminate the spurious counterexample step in the refinement step the previous work only generated new candidate types ie the arrow from step to step but because of the incompleteness of the underlying type system some spurious counterexamples are impossible to by just adding new candidate types the key component of our new type inference method is generating new parameter substitutions in such a situation ie the arrow from step to step then the cegar process is repeated with the updated candidate types or the updated parameter substitutions the former case is identical to the previous work and in the latter case we repeat from step to the program with the updated parameter instantiations adding extra parameters we add an extra parameter just before each parameter also we assign a unique label to each subexpression of the program where a parameter instantiation occurs note that such places are syntactically determined let l be the set of the labels and denote the variables that can occur free in the scope of the subexpression with the label l the type inference process maintains the parameter substitution p that maps each to a expression o such that we use p as the instantiation expression at we restrict the range of p and therefore the instantiation expressions to linear arithmetic expressions that is p is restricted to be of the form c cx · · · where x xn and c cn are integer constants this is an important design choice motivated both by the to minimize the complexity of the type inference and also by the ob that sufficient instantiations tend to be simple expressions in practice cf example the parameter substitution p may be initialized arbitrarily for example p for all we translate the input program by adding the extra parameters to the function definitions and replacing each instantiation site e with the application ep where is the label of e example recall the program d in example we add an extra parameter a just before the parameter f of app let and be the labels of the occurrences of app in the body of app and main respectively we have l a x and i suppose that the parameter substitution is p a i then d is translated to the program dp shown below app a f x if then app a f x else f x check x y if then assume x y check x y else assume ¬x y assert check x y main i app i check i i counterexampleguided refinement in a counterexample is a higherorder program that is with the current candidate types is defined to be a slice of the target program obtained by copying functions and removing branches so that it contains no branches and every function occurrence is linear ie each function is called only once intuitively a counterexample corresponds to the abstract program path taken to reach the assertion failure we check if the counterexample is feasible this part is identical to the previous work and is done by symbolically evaluating the if it is feasible then the program is determined unsafe and we are done otherwise we attempt to infer refinement types for the if the is found typable then the inferred refinement types or the refinement predicates embedded are added to the candidates and the cegar iteration returns to the fixedpoint type inference phase ie step of figure we infer types for counterexamples by using the techniques from the previous work that reduce the inference problem to solving constraints over fol formulas and predicate variables such that the predicate variables serve as of the refinement predicates to be inferred we refer to the previous work for details example given dp from example may generate the ds shown below app a f x app a f x app a f x f x check x y assume ¬x y assert main i app i check i i note that ds is and linear the is typable and may infer refinement types such that app app f u u a xu u a check xint y u u x main note that ds as above because of the incompleteness of the underlying type system ie sometimes a counterexample that is detected to be infeasible is also found the feasibility defines a counterexample to be simply a program slice ie possibly containing branches and but uses linear intersection types to obtain a similar effect check is actually relatively complete in such a situation we in a new parameter substitution pr for the so that the with each of its instantiation site instantiated with pr is ty then we update the parameter substitution with pr that is we set p pr p where is the labels of the and the cegar process returns to the parameter addition phase to the program ie step of figure the parameter substitution inference proceeds as follows first we assign labels to the such that every copy of a sub expression gets the same label as the one in the original note that because of function copying the same expression in the original program can have multiple copies in the next we introduce a parameter substitution template pt that maps each to a linear arithmetic expression template p px · · · where x xn and p pn are fresh integer variables this in turn induces a template that has pt as the instantiation expression at each now the problem of inferring pr is reduced to that of infer is apt the each iff with holds the instantiation expression pt where is a substitution that maps to integer constants although the problem of solving integer nonlinear fol constraints is undecidable in gen the recently proposed constraint solving techniques based on lemma have shown effective for our application in many cases we describe the constraint generation process in section and the constraint solving process in section constraint generation the constraint generation algorithm is essentially the same as the ones from the previous work used for candidate type inference we give a brief review of the algorithm for each function in the program we type templates containing predicate variables that serve as of the refinement predicates to be inferred then we generate constraints over the predicate variables in the standard way that is we apply the typing rules to the but restricting the application of the subsumption rule sub to just the argument position of function applications cf section this generates constraints over the type templates which in turn reduce to constraints over the predicate variables see the extended report for the formal definition of the constraint generation rules because is and linear the generated horn clauses are nonrecursive and we can obtain an equivalent fol formula example consider the ds shown below which is equivalent to ds from example except that the extra parameter of app is instantiated by instead of i app a f x app a f x app a f x f x check x y assume ¬x y assert main i app check i i it is easy to see that the counterexample ds is infeasible ie is safe and is also able to detect the however ds is with the underlying type system because of the instantiation expression to infer a new instantiation expression we the parameter substitution template pt for the instantiation sites of ds and from it obtain the template dt shown below app a f x app p pa px f x app a f x f x check x y assume ¬x y assert main i app p pi check i i where p p are free integer variables next we generate the constraints by the type template such that app au pu u pa u u pa u app au pu u pa u u pa u check xu pu y u px u main this generates the following nonrecursive set of constraints on the predicate variables p p a pa x pp pa px a x pa x pp pa px u pa u a pa x pp pa px x a x pa x pa x x px y x y i pp pi i pi i pi u pi u i pp pi i systematically simplifying the constraints by computing the least solutions for the predicate variables in a bottomup manner we obtain an fol formula on the variables p p shown below x y z px pz pz pp py x y constraint solving we solve the constraints by gulwani et als ap we give a brief overview of the idea first we use integer variables as and integer operations such as addition multiplication and comparison as boolean operations sat solver to find a substitution we describe quantified more detail given a we convert to an formula of the form i i where each i is of the form with such that polynomials on each p as is a linear we translate each i by applying lemma theorem lemma consider the following system of inequalities over variables x xn c cx cm we assume that constant types only embed quantifierfree linear arithmetic refinement predicates the system is unsatisfiable iff there exist nonnegative reals r r rm such that · r rc · · · and · · · · for each j n lemma is incomplete for integers because the only if direction does not always hold trivially the if direction holds even for integers the incompleteness however has not affected the experiments in section see section for the list of limitations with our approach example recall the constraints generated from the template dt in example we translate the constraints to the equivalent form below x y z px pz px pz ¬ pp p pp py pz pp p pp py pz x y applying lemma the constraint is further translated to the following form r r r r r r pp pr r r pr r r r pp pr r r pr r pr r we reduce the constraints to sat by modeling integers as and apply sat solving to find a satisfying assignment a possible solution is p p p p p r r r r r r and from the solution we obtain the substitution p p p p p note that applying the inferred parameter substitution to dt results in the program equivalent to ds from example finally we update the parameter substitution p via pt to translate the input program which results in the program dp from example and is typable by the underlying type system while the example only require a variable as the instantiation expression this is not the case in general even when the instantiations are restricted to linear arithmetic expressions section shows examples instantiation expressions we use the iterative approach of gulwani et al to model integers as we start with a low number of bits and increase the number of bits until a solution is found because of the incompleteness limitation it is possible that a solution is not found even though the process is given an infeasible cf section section shows heuristics for with the issue new candidate types with new parameter substitutions it is often desirable to infer new candidate types along with the new parameter substitutions for instance in example rather than returning to step of figure after the updated parameter substitution pt is inferred it is better to infer candidate types for the translated counterexample dt so that the counterexample is immediately eliminated from the future cegar iterations inferring parameter substitution for prior counterexamples for simplicity we have shown how to infer a parameter substitution for one counterexample in practice it is better to record the counterexamples that have been encountered or the constraints generated from them so that the inferred parameter substitution is able to also the past counterexamples this can be done by a minor modification to the algorithm because constraints from multiple counterexamples simply add up as conjunctions we take this approach in the implementation described in section limitations our type inference algorithm is incomplete as it is not able to decide the typability of all programs this is expected because the underlying problem ie safety verification is undecidable here we list the source of incompleteness like the predicate abstraction in firstorder software model checking we restrict the refinement predicates to an efficiently decidable firstorder theory such as the quantifierfree theory of linear arithmetic consequently there are programs even ones that are firstorder that we cannot verify also predicate discovery uses various heuristics such as interpolation and is in general incomplete even for the theory subset but there are approaches to make this part complete as in section we restrict instantiation expressions to linear arithmetic expressions while this has been sufficient for many cases as we show in section there are programs that we cannot verify because of the restriction but as we show there simple heuristics can often be used to handle such cases the parameter substitution inference is invoked only when the counterexample is with the current substitutions because otherwise it may simply infer the same substitutions for some programs the parameter substitution inference becomes forever blocked because the program generates infinitely many counterexamples each of which can be by just updating the candidate types see section for an example as in section lemma is incomplete for integers implementation and experiments we have implemented a prototype of the type inference algorithm as an extension to the higherorder model checker it takes and cps ocaml programs we use for the nonlinear constraint solving described in sec tion a web interface of the implementation and the mark programs from the experiments are available online we ran experiments on small but representative higherorder programs table summarizes the results the column s is the size measured in the number of words in the program o is the largest order of the functions in the program values are order than n and the column that occur in the range of the parameter substitution template pt cf section e is the number of extra parameters added before each parameter e is used in the heuristics described below i is the number of cegar iterations the column t is the running time in seconds and pt is the fraction of the running time spent on the parameter substitution inference nv marks the programs that required instantiation expressions the experiments were on a machine with intel e cpu and gb ram note that the programs are higherorder ie o the pro grams are safe but none of them can be verified by the previous the limitation is also linked with above because allowing more complex instantiations has no benefit when the underlying theorem prover cannot decide formulas embedding them this is an instance of a more general issue with the parameter substitution inference not inferring sufficiently general substitutions program s o p e i t pt nv d s d s s s s s s s ­ ­ ­ s s s s s ­ ­ ­ table experiment results refinement type systems proposed for automated higherorder program verification we describe each program · d and d are from example · compares the return value of two function arguments let f x y assert x y in let h x x in let main n f h n h n · makes the closure add n for some n applies it to for for some k and asserts that the result is not less than n let add x x x x in let rec repeat f k x if k then x else f repeat f k x in let main n k if n k then assert repeat add n k n · resp is the program below with e ab resp e ab let app f x f x in let check x y assert x y in let main a b app check e e · is lifted one order higher · calls check i i for some i n let succ f x f x in let rec app f x if then app succ f x else f x in let check x y assert x y in let main n app check n n · is with n in the body of main fixed to · in we model and check array manipulating programs we model an array as the pair consisting of its size and the function that maps indices to the array elements let make array n n fun i assert i i n let upd n ar i x assert i i n n fun j if j i then x else ar j the array benchmarks extend the ones from the previous work that demonstrate the application of higherorder program verification to the verification of data structure properties tests array updates it creates an array of size n and updates the ith element to x for some i n the program then reads the element and checks that the result is equal to x as expected let test n ar i x assert ar i x in let main n i x if i i n then test upd make array n i x i x note that the program also checks for array bounds violation creates an array of size updates the first and the second elements to a and b respectively and asserts that the sum of the two array elements equals a b let n ar x assert ar ar x in let main a b upd upd make array a b a b creates an array of size n whose elements are from the set x where x computes the maximum element m of the array and asserts that m x · the programs model and check list operations we model a list by a pair of its length and a function from a nonnegative integer i to the ith element we model the core list operations as follows let nil fun i assert false let cons a len l len fun i if i then a else l i let hd len l l let tl len l len fun i l i let len l len creates a list of the length n whose ith element is n i and asserts that x n holds for all element x of the list two lists of the length len and len computes the length of the resulting list and asserts that it is not greater than len len creates a list sorts the list via an insertion sort and then checks that the result is actually sorted the implementation was able to successfully verify the programs by automatically inferring appropriate extra parameter substitutions except for and before we discuss the reason for failure on these two we describe the heuristic that was needed for verifying and recall that we limit instantiation expressions to linear arithmetic expressions with this restriction it can be shown that and and also are actually when we are allowed to add only one extra parameter before a parameter however and can be typed if we are allowed to add two extra parameters before a parameter even with the restriction note that e is for these programs in table for instance in to show the safety of the call to we need to infer the property that the second argument note that the relative completeness theorem theorem assumes that arbitrary expressions can be used for instantiation equals the sum of the first and the second elements of the array passed as the first argument because the two elements of the array are independent ie the arguments a and b of main it is not possible to express such a fact via a refinement type with just one linearly extra parameter nonetheless the property can be expressed even under the restriction by using two extra parameters for example the following type is sufficient a int int × xint u u u a b where x u a x u b and × is the pair type constructor we use a simple heuristic to increase the number of extra parameters that are added before each parameter we increment the number by one when the parameter substitution inference fails to find a solution to the constraints with some threshold on the number of bits used in the modeling cf section with the heuristic the implementation was able to verify and note that the increased extra parameter heuristic is sound because the soundness theorem theorem holds for any pattern of extra parameter additions the program remains even with the heuristic in fact it can be shown that no finite number of extra parameter additions can type the program when the instantiation expressions are restricted to be linear the implementation fails to verify for a different reason to verify the program we need to infer the following type for app with the extra parameter i u u i xu u i however each counterexample generated from is actually typable by assigning the copies of app the types of the following form whose refinement predicates do not mention the extra parameter u u c xu u c where c is some integer constant therefore the type inference system generates infinitely many counterexample that are by the types of the above form each time and the parameter substitution inference is never invoked to infer the necessary type that uses the extra parameter we leave the issue for future work related work refinement type systems the relatively complete refinement type system of this paper can be seen as dml but with quantifiers ie introduction of types restricted to one before each parameter hence our result shows that dml is actually relatively complete even when the quantification pattern is restricted in relation to dml this papers contribution is in actually proving relative completeness and in an automated type inference method the previous refinement type systems proposed for automated higherorder program verification lack relative completeness except for the case when the data domain is finite we have shown how the type inference systems underlying the may be extended to relative completeness hoare logic for higherorder languages there is a long line of research on relatively complete hoare logic like proof systems for higherorder functional or procedural languages one way to achieve relative completeness is to have a higherorder logic as the interpretation logic ie the logic for the data part so that the formulas can directly refer to higherorder functions as data see eg however such an approach is difficult to as the client verifier must rely on a higherorder logic theorem prover the is similar to that arising from explicitly encoding functions as data in the program logic the approach of using encoding of functions to achieve relative completeness was first proposed by et al a similar approach is taken in crucial to their approach is the idea of avoiding the explicit encoding in the program logic via quantification allowing the client verifier to choose appropriate quantifier instantiations to our knowledge no actual verifier was built based on their program logic the encoding approach is also used in a recent work on relatively complete dependent refinement type system where a type system is extended with linear intersection types and is shown sound and relatively complete for terminating programs their type system is designed for a typebased complexity analysis and the paper does not discuss automated verification quantified firstorder logic constraint solving the problem is studied in the context of or program verification where the existentially quantified variables are used to represent the in the invariant template the technique has found wide applicability including hybrid system verification and program synthesis our work adds higherorder program verification to the list conclusion we have presented an automated approach to a relatively complete verification of higherorder functional programs our work extends the recent research on refinement type inference for automated program verification we have extended the underlying refinement type system by the classical result on relatively complete hoare logic like proof systems for higherorder procedural languages which shows that certain extra parameter additions are sufficient for relative completeness then we have extended the type inference system by the techniques from the recent work on quantified fol constraint solving over template expressions to infer appropriate instantiations for the extra parameters acknowledgments we thank the anonymous reviewers for useful comments this work is partially supported by and references l a language with dependent types in icfp pages ­ c and c in cav pages ­ e m clarke o s y lu and h counterexampleguided abstraction refinement in cav pages ­ m s and h linear invariant generation using nonlinear constraint solving in cav pages ­ w and b a sound and relatively complete for a language with higher type procedures inf ­ s m e m clarke and j y reasoning about procedures as parameters in logic of programs pages ­ s m e m clarke and j y reasoning about procedures as parameters in the language l inf comput ­ a a hoare calculus for functions defined by recursion on higher types in logic of programs pages ­ s gulwani s and r program analysis as constraint solving in pldi pages ­ c a r hoare an axiomatic basis for computer programming acm ­ k honda m and n yoshida and relative completeness of logics for higherorder functions in icalp pages ­ r jhala and r majumdar software model checking acm comput r jhala r majumdar and a rybalchenko verifying functional programs using abstract interpreters in cav pages ­ r jhala and k l a practical and complete approach to predicate refinement in tacas pages ­ t lambda lifting transforming programs to recursive equations in pages ­ n kobayashi types and higherorder recursion schemes for verification of higherorder programs in popl pages ­ n kobayashi and ch l a type system equivalent to the modal model checking of higherorder recursion schemes in lics pages ­ n kobayashi r and h predicate abstraction and cegar for higherorder model checking in pldi pages ­ u d and m linear dependent types and relative completeness in lics pages ­ j n and h computing invariants for polynomial systems in pages ­ er correctness of programs with procedures without global variables theor comput sci ­ b and t relative completeness for logics of functional programs in csl pages ­ p m m and r jhala types in pldi pages ­ s h b and z manna analysis in sas pages ­ s s gulwani and j s foster from program verification to program synthesis in popl pages ­ t dependent types from counterexamples in popl pages ­ h and n kobayashi dependent type inference with interpolants in pages ­ h t and n kobayashi relatively complete verification of higherorder functional programs http a k wright and m felleisen a syntactic approach to type soundness inf comput ­ h xi and f pfenning dependent types in practical programming in popl pages ­ 