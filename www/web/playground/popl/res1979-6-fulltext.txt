first order programming logic robert cartwright computer science department cornell university john science department stanford abstract first order programming logic is a simple yet powerful formal system for reasoning about recursive programs in its simplest form it has one major tation it cannot establish any of the least fixed point of a recursive program which is false for some other fixed point to this we present two intuitively distinct ap to strengthening first order pro gramming logic and prove that either ex makes the logic relatively com in the process we prove that the t wo approaches are formally equivalent the relative completeness of the extended logic is significant because it suggests it can establish all properties obviously we cannot escape the incompleteness inherent in any programming logic of recursive programs including those which compute partial functions the second contribution of this paper is to establish that first order program ming logic is applicable to iterative pro grams as well in particular we show that the assertions informal proof method for iterative programs which has not been formalized simply as first order programming log ic applied to the recursive tions of iterative programs introduction many theoretical computer eg and park have first order logic as too weak a formalism for reasoning about recursively defined functions nevertheless the au cartwright have a cartwright demonstrated that b first order logic can serve as a powerful yet convenient formal system for establishing properties of recursively func tions the key idea underlying our formal system is that recursive definitions of partial functions can be interpreted as equations extending a first order theory of the program data domain the resulting programming logic called first order programming logic is very simple and convenient to use yet it is powerful to prove most theorems of practical interest about recursively de functions in fact first order programming logic seems to be the logic of choice for reasoning about recursive pro grams the most recent of the lisp verifier and moore is based on a restricted variant of first order programming logic from a theoretical viewpoint the ma of ordinary first order pro gramming logic is its to prove true statements about the least fixed point solution of a recursive program which are false for some other fixed point solution for recursive programs which compute total functions this limitation is irrelevant since the least fixed point is the only fixed point for example ing that a particular recursive program computes a total function eg function is simple in most cases nevertheless the few re programs encountered in practice which do not compute total functions eg interpreters which cannot may have simple be established properties within nary first order programming logic to remove this limitation the authors wright have independently developed extensions to first order pro gramming logic which use different tech to capture the concept of least fixedpoint in this paper we prove that either extension to first order programming logic makes the logic relatively complete with respect to the theory of the underlying data domain in the process we prove that the t wo extensions are inter derivable ie that either extension can be formally derived from the other the relative completeness of the extended log ic is significant because it indicates that the logic can prove all properties of the partial functions com by recursive programs of course the extended logic cannot escape the essential incompleteness of any programming logic but the fact that the extended logic is relatively com demonstrates that the logic com captures the semantics of programs that the only source of in completeness in the logic lies in the first order axiomatization of the ing data domain fortunately we can overcome the incompleteness of the data domain axiomatization when necessary by following the same approach that used to prove the consistency of arithmetic axioms we sim augment the axiomatization of the data domain when necessary by the appropriate induction axiom an interesting consequence of the of the two extensions to ordinary first order programming logic is that both extensions can be added to the logic without interference in practice first order programming logic with both extensions is probably more con to use than it is with either ex alone the second contribution of this paper is to show that first order programming logic is applicable to iterative programs eg pascal programs as well recently the assertions method developed by burstall and manna and has attention as a possible alternative to the standard inductive assertions method for reasoning about iterative pro grams however all of the published descriptions of the method have been very informal in this paper we formalize the assertions method by showing that it can be interpreted simply as first order programming logic ap to the recursive translations of iterative programs recursive programs an adequate background for this paper is contained in and either manna concept or manna before we can of a recursive ness and formally define the we must introduce some preliminary definitions a data domain data objects er with a d consists called set of of a set id of the universe primitive operations functions are treated gl gk on as operations constants while all our sorted ourselves domains conceptual impose operations universe results easily generalize to typed data domains to we will restrict data for the sake of notational and simplicity consequently we the restriction that all primitive must be total functions on the id of the appropriate arity to accommodate boolean operations within d we can represent the boolean values true and false by ordinary data ob in id since all operations must be total on we must associate a boolean value with every data object in the programming language lisp follows this convention in lisp the data domain consists of the single type the atom nil represents the boolean value false every other represents the boolean value true the atom t serves as the nominal representative of the set of objects denoting true most boolean operations eg equal always use t to represent a true result to enforce that every properties these data conventions domain d has we fol the universe d is partitioned into two nonempty disjoint sets dt and d f boolean primitive arguments operation must interpret requiring objects in as the boolean value true false for example and in lisp and nil respectively id f are the set of primitive operations includes the constant symbols true and false denoting the nominal of the boolean values true and false respectively obviously the sets true and false must belong t and d respectively boolean valued operations such as must return either true or false to the primitive the standard binary operations equality equal and the boolean characteristic tions t and f respectively for the sets include function and to facilitate writing we also assume following properties recursive that d has the sion the standard operator primitive ifthenelse operations conditional defined include fol if x then y else y if z i z if the universe d forms a well partial order ng under the tive binary boolean operation less let l be a first order language with equality for the program data domain d and let denote a sequence of distinct variables program x of m on the data domain l a recursive d consists of a set of function definitions of the form il n here fn in l and are function f symbols is a term not in l extended to include the new function sym f with free variables n i for example a recursive the natural numbers n which factorial function is program computes on the if n equal else o then where binary we have operators used infix equal notation and for the in the sequel we assume without loss of generality that every recursive program p consists of a single recursive tion all of our results easily general to recursive number of tions programs mutually with recursive an the functional program equation for a assume we are given a first order ax ad for the data domain d such that ad includes a structural induction ax schema eg axioms for the natural numbers n to formally state and prove theorems about the function f de by the recursive program fx we would like to extend d and its corresponding axiomatization ad to include the defined operation f by converting the recursive definition into the the de axiom vi fi u and interpreting f in d as the function computed by evaluating ly this naive approach does not work be cause the function defined by may not be total in many cases the proposed ax is inconsistent with ad a simple example this problem is the recursive program fx fx over the natural corresponding first inconsistent numbers n the order axiom is with axioms we can our basic approach to recursive programs by ing the data domain d to explicitly in the undefined element l bottom we construct the augmented data domain d from d by adding l to the universe id and appropriately extending all the opera tions of d with the exception of if we extend every operation of d to the corresponding strict function on d d u l a function f an d is strict iff f has arguments is to dl as follows the value if any of we extend ifthenelse its if p then d else ii d dl if tp the corresponding to form d is a simple the details are modification the axiomatization to d for mechanical construction left to the reader for notational convenience we let abbreviate the formula xj means that x is defined ie that it belongs id to the proper universe given the augmented domain d and the corresponding axiomatization ad we can successfully convert recursive programs on d into first order axioms ad as suggested above however before further we need to what we mean by evaluating recursive programs which partial function is defined by a recursive program p such as l depends callbyvalue terminology on whether a callbyname computation rule in or the of manna ness and is used to evaluate the program from the of denotational se the function computed by applying a callbyname callbyvalue computation rule to p is the least fixed point of the callbyname callbyvalue functional for p the callbyname functional corresponding to the recursive program is simply ag a the callbyvalue more complex form functional syntactically is slightly it has the ag ix if f then e i where true if u otherwise fortunately we can capture either meaning within first order logic by con the recursive program into the ap first order axiom the call callbyvalue interpretation for the partial function defined by an recursive program satisfies the first order sentence vi i where ag h is the callbyname tional corresponding that the callbyvalue equation wright bl the the callbyname identical callbyvalue func to p a formal proof interpretation sa appears in corresponding proof for interpretation is nearly in the callbyvalue case sentence is equivalent to the conjunction of the two simpler a in subsequent callbyvalue will use these axioms equation examples in preference we to as an illustration of our approach to recursive programs consider the factorial program presented as an example in the previous section the callbyname axiom corresponding to the program is kn n equal o then else the corresponding callbyvalue a b for the same program axioms are bn n equal o else dn nn in practice the callbyvalue ax b is used because it describes the behavior of f when it is applied to an undefined divergent argument in the sequel we will explicitly state which type of computation or callbyvalue that each program uses reasoning first order about recursive programming logic programs in to reason about a recursive program p we simply append the first order characterizing p to the ax ad of the augmented data domain d and apply standard first order deduction lie call the resulting formal system weak first order programming logic for example assume ad is an augmented axiomatization for the augmented na numbers n including the primitive functions the equal function and less be defined let by the callbyname recursive program on n if x equal else o then y the first order ing to the preceding sentence program vx y if x equal else o then y we can prove that is total the theorem by proving bx y xn yn the proof proceeds by structural induction on the pair xy under the standard ordering the base case xo is trivial for the induction step we assume the induction hypothesis vx y x less x i xx y less y since xo by hypothesis hypothesis a second time qed applying the we deduce capturing point the concept of least fixed the functional equation corresponding to a recursive program does not completely characterize it in some cases for ex am ple consider the callbyname program on the natural numbers qx qx and the corresponding first order sentence bx qx qx although the program clearly does not terminate for any x the sentence is satisfied by any interpretation for the function function just the everywhere the problem is that the first order sentence corresponding to an arbitrary callbyname callbyvalue program p is satisfied by any fixedpoint of the callbyname callbyvalue func tional for p if the function computed by p is total this ambiguity does not arise because the functional for p has a unique fixed point for some programs which com partial functions however the ence of fixed points prevents weak first order programming log ic from proving any property of a function which is not true for all fixed points of the defining functional the authors cartwright have pro different ways to augment weak first order problem programming logic to solve this cartwright extends weak first order programming logic by introducing the concept program of a complete recursive whose functional has a unique fixed point given an arbitrary program p computing f on the data domain d it is possible to mechanically construct a corresponding program computing f on the extended domain where denotes the set of over d with the following properties p computes for p the computation se gram p is a complete recursive pro the construction cartwright is described in detail in let function last denote on the which strict extracts unary the last element of a list represented as an then f satisfies the obviously this sentence is not provable in general in weak first order programming logic since it forces f to have a unique fixed point interpretation with respect to a particular data domain model con to fully characterize the re program p on the data domain d cartwright tion of constructed the ad by the following three axioms describing p corresponding the recursion to p corresponding the to recursion pt the equivalence axiom ing the equivalence of f on d it is a straightforward exercise to construct axiom for and for one possible ap see cartwright a bl moreover under suitable assumptions the hypothesis of the presented relative in the data completeness next section domain satisfies theorem which any it is possible to implement encode s expressions over d as objects in d using pairing functions and avoid extending the data domain d in contrast to the complete recursive program approach extends weak first order programming logic by ad an axiom schema called the minimization schema for each recursive program p the schema asserts that the function computed by the program p is or equal to any function which is a fixed point of the same func tional let ax be the functional corresponding to the program defining the function f the minimization schema has the form gx where g is an arbitrary function symbol the schema can be stated more by introducing d scott partial we define ordering c on vx y xi xy using schema this notation becomes the minimization let us illustrate and compare these t wo extensions to weak first order pro gramming logic by the follow ing callbyvalue program over the natural numbers n the function loop defined by is clear ly diverges equals i everywhere yet this fact is not provable within weak first order programming logic since any constant function is a fixed point of the corresponding callbyvalue functional however the divergence able from either the of loop is equivalence the the corresponding equivalence complete between recursive and pro gram or the minimization sc a the proof from the equivalence axiom proceeds as follows the complete recursive pro gram corresponding to is loop xl by the strictness diverges equivalence of last reduces to axiom proving showing and that the loop xn loop x j we can prove by structural on the value of holds for all x such that x tail of x if x then holds otherwise induction assume is a proper the theorem loop xl where since cons is strict hypothesis but by the in p generating a contradiction qed the derivation of the same from the minimization schema is let the function g on n be defined callbyvalue program theorem trivial by the gx j the function hence g clearly of the satisfies minimization the that loop xj for simple theorems involving partial functions where suitable comparison func tions like g are easily constructed the minimization schema to produce simpler proofs than the equivalence axiom for more complicated examples however such as interpreters the equivalence axiom may be more useful because the complete recursive program construction automatically generates the complex comparison function required to successfully the minimization schema the close relationship between com recursive programs and suitable minimization comparison functions g the following theorem theorem the minimization callbyvalue program p are the equivalence ax and schema corresponding to a callbyname recursive proof in each direction the proof is a routine but tedious induction on the structure of the body of the recursive program p an outline of the proof ap in an appendix since either extension to weak first order programming logic can be derived from the other we can safely extend the weak logic to include both extensions we call the resulting system strong first order programming logic relative completeness order programming logic of strong first in weak first order programming ic there are simple properties of which we can express but cannot prove does the strong logic from the same ly the answer is no we can prove a re completeness theorem which suggests that the strong logic is for all cal purposes as powerful a deductive sys tem for reasoning about recursive programs programs which take functions as arguments as we can hope to informally the theorem asserts that any sentence in the strong logic for a program p logically reduces to a in the pure logic of the data domain in other words the incompleteness of the strong log ic lies entirely in the data domain ax not in the axiomatization of the recursive program p before we can theorem we need to ing definitions precisely introduce state the the follow an interpretation a of a first order theory t in the language l into a theory language formulas n a is a of l into possible function corresponding different which maps the formulas of li such that t t a more precise definition of the concept appears in p let s be an arbitrary set of in a first order language l the set of consequences of t denoted cn s is the set of formulas logically implied by t theorem callbyvalue program let p be callbyname an arbitrary recursive fy on the data domain d if there is an in then any of formula cn into cn ad e in the language l u f strong logic for ie p is the language of the provably equivalent within the strong logic to a formula in the language ld proof from the of mathematical logic first order program ming logic provides a method for introducing partial functions de on a data domain d into an ax theory cn ad for d in the termi of this theorem sim asserts that under suitable tions these definitions are the key step in the proof struct a formula fy in the such that the sentence is to language vd ey fy is provable in the strong logic for p the construction for callbyvalue pro grams is described in the corresponding construction for name programs is similar but slightly more complicated given an arbitrary formula y in the language u f we can logically reduce it to an equivalent formula y in he language to f by references by replacing to and performing a simple case analysis to eliminate references to then we can use cr to convert y to an equivalent for y in ld qed reasoning first order about iterative programming logic programs in the assertions method developed by burstall and manna and has been widely as a better proof method than the standard inductive assertions method for reasoning about iterative programs however the descriptions of the method appearing in the literature have all been very making the relative of the method difficult to in this paper we provide a simple formalization of the method within first order programming logic in fact we will demonstrate that assertions method can be viewed simply as convenient notation for proving theorems in first order programming logic about the translations of iterative programs the fundamental idea is the interpretation ment in the of the state at l where l is a node in the flowchart program a directed graph with assignment states and boolean tests to the edges and q formula in is an arbitrary the language of the first data order domain with the free variable lists ranging over the program data domain d the vari able lists and denote lists of program variables respectively and arbitrary free we variables statement within first order programming logic for the program data domain d as a d where x denotes the initial state and l equivalent and start are to executing recursive the programs flowchart starting at nodes l and start respective ly of course more complex tion which explicitly mention labeled ex traces are possible our tion seems to be the simplest one which works there informally asserts is a program state such that the program from l in state the same output as executing that pro the program statement from is start weaker in state than the x o obvious this but more complex translation involving the labeled because execution the state trace or start no t occur zo at l during the execution of the program from start in state z in fact l may be a node which is never reached by any tion path beginning at start however this apparent does not the deductive power of the assertions method the logic is still re complete with respect to the theory of of the underlying data domain moreover all of the arguments used in manna and sample proofs hold for our interpretation of statements in intuitive terms our for of asserts permits nonstandard program executions but forces them to produce standard results our interpretation assertions does retain tive property that an form of the crucial assertion of the at finish where finish is the termination the flowchart implies that terminates for input state zo the condition node of the program otherwise f f would be false since finish x i out where the output variable nonempty subset of the z manna and inputoutput specifications using formulas list is a program variables describe the for a program by stating in at start out at finish using our interpretation formulas becomes of zd in f od f start zo o which is equivalent to f started given our translation of into first order programming logic all of the lemmas and theorems appearing manna and examples can be in simply as in a first order programming logic for the program data domain similarly their informal arguments can be translated into ordinary first order programming logic proofs as an illustration we will show how to for the example described in manna and the translation of the pro gram is start tree f if stack equal then f finish else if f head stack then else f head stack right head stack tail stack count where we have used the same primitive operation names and variable names as the original program in the interest of clarity we have changed the notation slightly first we have omitted the parentheses enclosing unary function ment lists we have used the no tation ei to denote the instead en list consisting of of the ele ments el en to precisely in a tree the following define the number manna and recursive program of pro tree if else then tree tree given the definition of the following inputoutput for the program they specifications prove if tree t at start then count at finish in our formalization the statement immediately reduces by and the of tree for t to sub v f integer start tree where tree and integer are operators denoting characteristic for trees and integers respectively proof the key step in manna and is proving the following lemma if count c stack t s at more then count c stack s at more the formal translation of reduces to more f where list is a operator denoting the characteristic predicate for lists of trees if we assume that is de for any tree t it is very easy to prove by structural induction on the value of t s moreover we can prove within first order programming logic that is defined for any tree t ie by induction implicitly on t manna and this lemma in their in formal proof without it given the lemmas and the recursion equations corresponding the program the inputoutput theorem immediately follows and to note that we formalized the tip counting proof within weak first order programming logic the extra power of the strong logic was not necessary in fact all of manna and sample correctness proofs can be formalized within the weak logic the weak logic suffices because totally correct iterative programs correspond to total recursive programs on the other hand formalizing inter assertions proofs of partial correctness requires the strong logic while manna and do not present any sample partial correctness proofs they do show how to transform arbitrary inductive assertions partial correctness proofs into assertions proofs the resulting proofs cannot be formalized within the weak logic because they induction on the length of the program computation sequence rather than induction on the structure of the program data we believe our formalization of the assertions method some light on why the method produces simple correctness proofs for programs if an iterative program has a particularly simple recursive trans then the assertions method in essence to the applies corresponding structural in recursive program as and moore and cartwright al have observed it is much easier to reason about naturally recursive programs using structural induction than it is using other methods eg inductive assertions fixed point induction on the other hand we the in assertions method will as well when applied to typical iterative programs manna and choice of examples to support this conjecture all of their sample programs have natural recursive translations it seems to uniformly convert non recursive programs into corresponding re programs in order to reason about them yet this is precisely the course that the assertions method follows references r and j theorems about l moore lisp functions january proving j acm burstall r program proving as hand simulation with a little tion in information processing pp northholland amsterdam cartwright r a userdefined data types as aid to verifying lisp pro grams in s and r milner eds automata languages and pro gramming pp edinburgh press edinburgh cartwright r b a practical formal semantic definition and verification system for typed lisp stanford a i lab memo aim stanford university stanford california cartwright r first order seman tics a natural programming logic for recursively defined functions cornell university computer science dept tech report tr new york j w the fixed approach in semantics theory mathematical centre free university amsterdam point and ap r assigning meaning to programs in j t cd proc symp in applied math vol pp math island der math translation in m e cd the collected works of pp north holland amsterdam des log uz der new series no pp trans in m e cd the col works of pp north holland amsterdam p and d park tion rules and proofs of program termi in m cd automata languages and programming pp northholland amsterdam hoare c a r an axiomatic basis of computer programming comm acm october manna z computation mathematical theory of manna z s ness and j inductive methods for proving properties of comm acm august manna z and j point approach to the theory of tation comm acm manna z and r sometimes better than ways comm acm is al j a basis for a mathematical theory of computation in p and d eds computer programming and formal sys pp northholland amsterdam j representation programs in first order unpublished draft computer department stanford university california of science morris j h and b program verification tion comm acm by april park d fixpoint proofs of program machine intelligence university induction and properties in pp press edinburgh scott d outline of cal theory of computation of fourth princeton on information science princeton pp a conference and systems appendix equivalence of the equivalence axiom and the minimization schema i om from to establish for a recursive the minimization that the equivalence ax program p is provable schema for p we program the first p construct the complete recursive p corresponding to p generating order sentence characterizing show that the sentence x is provable fl x within by structural weak first induction on order programming logic the proceeds by struc al induction on the right hand side of the recursive definition of f in p show that the sentence last fx is provable by structural induction on fx within the weak logic as in above the proceeds by al induction on the right hand side of p deduce from the minimization x schema and above combine the to finally prove conclusions of and fx x to prove cs derivable we must show gram p that the minimization from the equivalence that given an arbitrary schema axiom pro fx tx and an arbitrary function g which to reduces by the equivalence axiom but follows immediately from the lemma x which we can prove structure of t weak logic augmented ax by induction is by the on the within the equivalence 