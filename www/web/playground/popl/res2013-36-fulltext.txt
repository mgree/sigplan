haskell to logic through denotational semantics simon peyton jones microsoft research university abstract even welltyped programs can go wrong in modern functional languages by a failure or simply returning the wrong answer an response is to allow programmers to write contracts that express semantic properties such as or some useful postcondition we study the static verification of such contracts our main contribution is a novel translation to firstorder logic of both haskell programs and contracts written in haskell all justified by denotational semantics this translation enables us to prove that functions satisfy their contracts using an firstorder logic theorem prover categories and subject descriptors d software applicative functional languages general terms verification languages keywords static contract checking firstorder logic introduction haskell programmers the benefits of strong static types and purity static types eliminate many bugs early on in the development cycle and purity simplifies equational reasoning about programs despite these benefits however bugs may still remain in purely functional code and programs often crash if applied to the wrong arguments for example consider these haskell definitions f xs head reverse true xs g xs head reverse xs both f and g are well typed and hence do not go wrong in milners sense but g will crash when applied to the empty list whereas f cannot crash regardless of its arguments to distinguish the two we need reasoning that goes well beyond that typically in a standard type system many variants of dependent type systems et al xi or refinement type systems and flanagan et al have been proposed to address this problem each different of expressiveness or automation another line of work to address this challenge studied by many researchers as well and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright © acm findler and felleisen and flanagan siek and wadler and findler allows programmers to annotate functions with contracts which are forms of behavioural specifications for instance we might write the following contract for reverse reverse xs cf ys null xs null ys this contract annotation asserts that if reverse is applied to a crashfree cf argument list xs then the result ys will be empty null if and only if xs is empty what is a crashfree argument since we are using lazy semantics a list could contain that yield errors when evaluated and the cf precondition asserts that the input list is not one of those notice also that null and are just ordinary haskell functions perhaps written by the programmer even though they appear inside contracts with this property of reverse in hand we might hope to prove that f satisfies the contract f cf cf but how do we verify that reverse and f satisfy the contracts contracts are often tested dynamically but our plan here is different we want to verify contracts statically and automatically it should be clear that there is a good deal of logical reasoning to do and a approach is to the task to an theorem prover such as z de and or et al or search for counterexamples with a finite model and with that in mind we make the following new contributions · we give a translation of haskell programs to firstorder logic fol theories it turns out that lazy programs have a very natural translation into firstorder logic section · we give a translation of contracts to fol formulae and an of the language semantics in fol section · our main contribution is to show that if we can prove the formula that arises from a contract translation for a given program then the program does indeed satisfy this contract our proof uses the novel idea of the denotational semantics as a firstorder model section · we show how to use this translation in practice for static contract checking with a fol theorem prover section and how to prove goals by induction section this work is a first step towards practical contract checking for haskell programs out the theoretical foundations for further engineering and nevertheless we have already implemented a prototype for haskell programs that uses ghc as a frontend we have evaluated the of our approach on many examples including lazy and higherorder programs and goals that require induction we report this initial evaluation in section programs definitions and expressions p d dn d f a x u u e case e of k y e e x variables f function variables k e data constructors ee applications bad runtime error syntax of closed values v w kn en f n bad contracts c x e x c c cc cf base contracts arrow contracts conjunctions types t datatypes a type environments and signatures · x · a x · t n f a n t a auxiliary functions · · a x x figure syntax of and its contracts to our knowledge no one has previously presented a translation of lazy higherorder programs to firstorder logic in a provably sound way with respect to a denotational semantics furthermore our approach to static contract checking is different to previous work instead of and symbolic execution xu xu et al we purity and laziness to directly use the denotational semantics of programs and contracts and the obligations with a fol theorem prover the process instead of generating verification conditions by pre and post conditions through a program we directly ask a theorem prover to prove a contract for the fol encoding of a program we discuss related work in section a higherorder lazy language and its contracts to the ideas behind our implementation we define a source language a polymorphic higherorder callbyname calculus with algebraic datatypes pattern matching and recursion our actual implementation treats all of haskell by using ghc as a front end to translate haskell into language syntax of figure presents the syntax of a program p consists of a set of recursive function definitions d dn each definition has a left hand side that binds its and parameters if f has n parameters we say that it has arity n and sometimes write it f n the right hand side u of a definition is either a case expression or a expression e a expression consists of variables x function variables f fully applied to their type arguments applications e e and data constructor applications k e the latter return values of datatypes t as a notation we use xn for sequences of elements of size n when n is omitted x has a size which is implied by the context or is not interesting a program if it evaluates the special value bad for example we assume that the standard haskell function error simply invokes bad thus error string a error s bad moreover we assume that all incomplete are completed with the missing case yielding bad for example head a a head x head bad in our context bad is our way to saying what it means for a program to go wrong and verification amounts to proving that a program cannot invoke bad our language several convenient syntactic constraints i abstractions occur only at the toplevel ii can only immediately follow a function definition and iii constructors are fully applied any haskell program can be transformed into this restricted form by and respectively and our working prototype does just this however this simpler language is convenient for the translation of programs to firstorder logic is an explicitlytyped language and we assume the existence of a typing relation p which checks that a program to the definitions in the signature a signature figure records the declared data types data constructors and types of functions in the program p the wellformedness of expressions is checked with a typing relation u where is a typing environment also in figure we do not give the details of the typing relation since it is standard our technical development and analysis in the following sections assume that the program has been checked for type errors the typing judgement should check that all pattern matches are exhaustive as mentioned above missing cases should return bad the syntax of closed values is also given in figure since we do not have arbitrary abstractions values can only be partial function applications f n data constructor applications k e and the error term bad the operational semantics of is entirely standard and we do not give it here we write p u v to mean in program p righthand side u evaluates to value v contracts we now turn our attention to contracts the syntax of contracts is given in figure and includes base contracts x e arrow contracts x c c conjunctions cc and cf previous work xu et al includes other constructs as well but the constructs we give here are enough to verify many programs and exhibit the interesting theoretical and practical problems we write e c to mean the expression e satisfies the contract c and similarly for functions f we will say what contracts mean formally in section however here is their informal meaning terms s t x f t kt sel s bad variables function applications constructor applications constructor selectors pointers and application unreachable bad formulae t t ¬ x x equality abbreviations sn s sn ¬ figure syntax of fol · e x e means that e does not evaluate to a value or e ex evaluates to true or does not evaluate to a value notice that e is an arbitrary expression in our implementation arbitrary haskell expressions rather than being restricted to some well metalanguage this is great for the programmer because the language and its library functions are familiar but a challenge for verification because these expressions in contracts may themselves diverge or crash · e x c c means that whenever e satisfies c it is the case that e e satisfies ce x · e cc means that e satisfies both c and c · e cf means that e is crash free that is e does not crash regardless of what context it is into see section translating to firstorder logic our goal is to answer the question does expression e satisfy contract c our plan is to translate the expression and the contract into a firstorder logic fol term and formula respectively and get an fol prover to do the heavy lifting in this section we our translation and describe how we use it to verify contracts the fol language we begin with the syntax of the fol language which is given in figure there are two syntactic forms terms and formulae terms include saturated function applications f t that is fully applied to all the arguments that were declared at their definition they also include saturated constructor applications kt variables and for each data constructor kn in the signature with arity n a set of selector functions sel for i n the terms s and concern the higherorder aspects of namely applications which we discuss in section finally we introduce two new syntactic constructs and bad as an abbreviation we often use s for the sequence of applications to each si as figure shows a formula in figure is just a fol formula augmented with a predicate for which we discuss in section translation of expressions to fol what exactly does it mean to translate an expression to firstorder logic we are primarily interested in reasoning about equality so we might hope for this informal principle pp pd dd dd df a x u x u f xu x f x x u su u se s ee u e of k y e t bad s bad yt s ee t bad s where t ee ee t ex x ef ek e ee e ee bad ce c ce x e t t tx t where t ee and t ee ce xc c c ce x c ce cc ce c ce c ce cf figure translation of programs and contracts to logic theory t axioms for bad and x bad x bad axioms for data constructors j y for every ka n t a and ja m s a and k j kx bad for every ka n t a yn sel yi for every kn and i n axioms for for every ka n t a figure theory t axioms of the fol constants if we can prove in fol that e e e e then e and e are semantically equivalent where e e is the translation of e to a fol term that is we can reason about the equality of haskell terms by translating them into fol and then using a fol theorem prover the formal statement of this property is corollary the translation of programs definitions and expressions to fol is given in figure the function pp translates a program to a conjunction of formulae one for each definition d using dd to translate each definition the first clause in ds righthand side uses u to translate the right hand side u and over the x we will deal with the second clause of d in section ignoring case for now which we discuss in section the formula xe simply asserts the equality f x e e that is we use a new function f in the logic for each function definition in the program and assert that any application of f is equal to the logical translation of f s right hand side notice that we erase type arguments in the translation since they do not affect the semantics you might think that the translation f x e e is entirely obvious but surprisingly it is only correct because we are in a callbyname setting the same equation is problematic in a callbyvalue setting ­ an issue we return to towards the end of section e e deals with expressions we will deal with functions and application section but the other equations for e e are straightforward notice that e bad bad and recall that bad is the used for an case or a call to error it follows from our principle that for any e if we to prove in fol that e e bad then the source program e must be semantically equivalent to bad meaning that it definitely translating higherorder functions if was a firstorder language the translation of function calls would be easy e f e f e e at first it might be surprising that we can also translate a higherorder language into first order logic but in fact it is easy to do so as figure shows we introduce into the logic a a single new function app and b a constant for each function f see figure then the equations for e e translate application in to a use of app in fol and any mention of function f in to a use of in the logic for example e map f xs xs assuming that map and f are toplevel functions in the and xs is a local variable once enough app applications stack up so that is applied to two arguments we can invoke the map function directly in the logic an idea we express with the following axiom xy x y y these axioms one for each function f are generated by the second clause of the rules for dd in figure the notation x is defined in figure you can think of as a pointer to or name of of map the app axiom for map translates a saturated use of maps pointer into a call of map itself from an appropriate of the semantics of programs data types and case expressions the second equation for in figure deals with case expressions by generating a conjunction of formulae as follows · if the t is bad meaning that evaluating it invokes bad then the result s of the case expression is also bad that is case is strict in its · if the is an application of one of the constructors ki mentioned in one of the case alternatives then the result s is equal to the corresponding righthand side ei after the variables y bound by the case alternative · otherwise the result is the bit before the implication is just the negation of the previous preconditions the formula kt is the fol way to say t is not built with constructor k why do we need the last clause consider the function not not bool bool not true false not false true suppose we claim that not cf cf which is true but if we lack the last clause above the claim is not true in every model for example not might crash when given the illtyped but crashfree argument the third clause above this possibility by that the result of not is the special crashfree constant if the is illtyped ie not bad and not built with the constructors of the type this is the whole reason we need in the first place in general if e e is provable in the logic then e is illtyped or divergent of course we also need to the behaviour of data constructors and selectors which is done in figure · explains that a term by a data constructor cannot also be bad or · explains how the selectors sel ki work · tells the prover that all data constructors are pairwise disjoint there are a quadratic number of such axioms which presents a scaling problem for this reason fol provers sometimes offer a builtin notion of data constructors so this is not a problem in practice but we ignore this pragmatic issue here a small point is that actually implies but for reasons we keep both axioms translation of contracts to fol now that we know how to translate programs to first order logic we turn our attention to translating contracts we do not translate a contract per se rather we translate the claim e c once we have translated e c to a firstorder logic formula we can ask a prover to prove it using axioms from the translation of the program or axioms from figure if successful we can claim that indeed e does satisfy c of course that needs proof which we address in section figure presents the translation ce c there are four equations corresponding to the syntax of contracts in figure the last three cases are simple and direct conjunction of contracts turns into conjunction in the logic a dependent function contract turns into universal quantification and implication and the claim that e is crashfree turns into a use of the special term in the logic we discuss in section the first equation for predicate contracts e x e is more complicated the first clause t together with the axioms for in figure ensures that satisfies every contract the second and third say that the contract holds if e diverges or is semantically equal to true the choices in this rule were discussed at length in earlier work xu et al and we do not repeat it here the claim e cf e is crashfree means that e cannot crash regardless of context so for example bad true is not crashfree because it can crash if evaluated in the context fst bad true of course the context itself should not be the source of the crash for example is crashfree even though bad will crash we use the fol term to assert that t is crashfree the axioms for cf are given in figure says that a data constructor application is crashfree if and only iff its arguments are crashfree says that is crashfree and that bad is not that turns out to be all that we need summary that completes our but so far only translation from a program and a set of contract claims into firstorder logic to a first approximation we can now hand the generated axioms from the program and our to an fol theorem prover and ask it to use them to prove the translation of the contract claims soundness through denotational semantics our account so far has been largely informal how can we be sure that if the fol prover says yes this fol formula is provable then the corresponding program indeed satisfies the contract to prove this claim we take a denotational approach most of what follows is an adaptation of wellknown techniques to our setting and there are no we refer the reader to or benton et al for a short and modern of the standard methodology technical we will assume a program p wellformed in a signature so that p given a signature we define a strict f on complete partial orders cpos below f d d n d kn d c d bad the f is the lifting of a big sum that sum consists of i products one for each possible constructor even across different data types ii the continuous function space from d to d and iii a unit cpo to denote bad values the notation n d nary products of cpos the unit cpo if n the product and sum constructions are standard but note that we use their nonstrict versions the notation c c d denotes the cpo induced by the space of continuous functions from the cpo c to the cpo d we use the notation bad to denote a cpo ­ the bad subscript is just there for readability the notation d is lifting observe that we have all type information from the source language the elements of the products corresponding to data constructors are simply d instead of more a precise description from e ·· c d × var c d c d x x f f k e ke e e e bad bad u ·· c d × var c d c d e e case e y ek ek if e kd and k is a case branch bad if e bad otherwise p c d c c d p f if f a x u p otherwise figure denotational semantics of type information and the return types of data constructors are similarly ignored this is not to say that a more denotational semantics is not possible or desirable even but this simple denotational semantics turns out to be sufficient for and verification now we can define d as the solution to this recursive domain equation d f d d we can show that d exists using the standard pairs methodology moreover we define the value domain v thus v n d nk d d c d bad kn the following continuous functions also exist roll v c d d c v however in what follows we will always these functions to reduce to denote elements of v we use the following notation · kd dn denotes the injection of the nary product of d into the component of the sum v corresponding to the nary constructor k · is the injection of an element of d c d into the function component of v · bad is the unit injection into v denotational semantics of expressions and programs figure gives the denotational interpretations of expressions e right hand sides u and programs p in terms of the language and combinators we have defined first the set of term variable names x induces a discrete cpo var and the set of function variable names f induces a discrete cpo we define semantic term environments to be the cpo var c d and semantic function environments to be the cpo c d figure defines the denotational semantics of expressions e as a continuous map from these two environments to d it is entirely straightforward except for application which depends on the continuous function app d × d c d defined thus a df a if d bad if d bad otherwise that is application applies the df if the function d comes from the appropriate component of v propagates bad and otherwise returns the semantics of righthand sides u is defined similarly the semantics of a case expression is the semantics of the matching branch if one exists otherwise like application it propagates bad in all other cases we return not bad all the missing cases can only be constructors of different datatypes than the datatype that k belongs to because all case expressions are complete section this treatment corresponds directly to our treatment of in section finally figure gives the semantics of a program p which should be read its syntax in figure since p is continuous its limit exists and is an element of the cpo c d definition we will refer to the limit of the p as p in what follows moreover to reduce notational overhead below for a program with no free variables we will use notation e to mean e p · and e to mean e p although we have not presented a formal operational semantics we state the usual soundness and adequacy results theorem soundness and adequacy assume p and u with no free term variables then i if p u v then u v and ii if e then v such that p e v the proof of adequacy is routine domain theory so we only sketch the highlevel the proof proceeds by defining a logical relation between semantics and syntax via the use of a on admissible relations between elements of d and closed expressions pitts adequacy then follows from the fundamental theorem of this logical relation which asserts that every expression is related to its denotation denotational semantics of contracts now we are ready to say formally what it means for a function to satisfy a contract we define the semantics of a contract as the set of denotations that satisfy it c d where c is a contract with free term variables in the semantic environment figure gives the definition of this function a base contract x e is satisfied by or or by a computation that causes the predicate e to become or return true the denotation of an arrow contract and of conjunction are both straightforward the cf contract is a little harder intuitively an expression is crashfree iff it cannot crash if into an arbitrary crashfree context of course this is a definition so how do we a small technical remark we write the definition with pattern matching notation a instead of using for out d and for out a but that is fine since × is not a lifted construction in previous work xu et al the base contract also required we changed this choice only for reasons of both choices are equally straightforward technically c d x e d d true xc c d d c d cc d d c d c where cf kd kn d di dd figure denotations of contracts know it makes sense the original paper xu et al specified that an expression is crash free iff it cannot crash when into a context that syntactically does not contain the bad value this is a reasonable definition in the operational semantics world but here we can do better because we are working with elements of d using techniques developed by pitts pitts we can define as the greatest solution to the recursive equation for in figure technically since the equation involves recursion to show that such a fixpoint exists we have to use minimal invariance minimal invariance can be used with strict to show that every element in the negative fixpoint of a is contained in the positive fixpoint by constructing a sequence of approximations whose limit is the identity this is the minimal invariance property and showing that every approximation of that element is contained in the positive fixpoint does the rest hence the definition is wellformed in addition the following is true and will be useful later on for induction lemma elements of a chain are in that is if all soundness of the logic translation we have developed a formal semantics for expressions as well as contracts so it is time we see how we can use this semantics to show that our translation to firstorder logic is sound with respect to this semantics our plan is to give an interpretation in the fol sense of the term to our translated fol terms using the carrier set d as our model this is straightforward to do if t it t it f di if it kd otherwise bad the essential soundness theorem that states that our interpretation makes sense is the following theorem interpretation respects denotations assume that p and expression e does not contain any free variables then if e e t then it e recall that notation e the semantics of e in the program p see definition the proof is an easy induction on the size of the term e our soundness results are expressed with the following theorem theorem if p then d i t pp as a corollary we get our principle from the introduction corollary assume that p and e and e contain no free term variables the following are true · e e iff ie e ie e · if t pp e e e e then e e proof the first part follows directly from theorem for the second part the lefthand side implies that e e and e e are equal in all models of t pp in particular using theorem by d i and by the first part the case is finished theorem assume that e and c contain no free term variables then the fol translation of the claim e c holds in the model if and only if the denotation of e is in the semantics of c formally d i ce c e c completeness of the d domain has a complex structure and there are many more facts that hold about elements of d that are not reflected in any of our axioms in t for instance here are some admissible axioms that are valid x x bad x for every f a xm u p and k with m n these axioms assert that partial applications cannot be to any constructor nor bad if the reader is that without a complete of all equalities of d it is impossible to prove any programs correct we would like to them that that is not the case as we shall see in the next section the translation and lazy vs strict semantics we have mentioned previously section that the translation that we have presented is only valid in a callbyname setting and here we explain why whenever we use universal quantification in the logic we really quantify over any denotation including and bad in a callbyname language given a function f x true the axiom xf x true is true in the intended denotational model however in a callbyvalue setting x is allowed to be interpreted as that means that the axiom is actually not true because f true instead we need the following variation xx bad x f x t moreover the axioms for the · combinator have to be modified to perform checks that the argument is not or bad before actually calling a function in a callbyname language these guards are needed only for case and the function part of app contract checking as satisfiability having established the soundness of our translation it is time we see in this section how we can use this sound translation to verify a program the following theorem is then true theorem soundness assume that e and c contain only function symbols from p and no free term variables let t pp if c is unsatisfiable then d i ce c and consequently e c proof if there is no model for this formula then its negation must be valid true in all models that is ce c is valid by completeness of firstorder logic ce c this means that all models of validate cf c in particular for the denotational model we have that d i and hence d i ce c theorem the proof hence to verify a program e satisfies a contract c we need to do the following · generate formulae for the theory t pp · generate the negation of a contract translation c · ask a fol theorem prover for a model for the conjunction of the above formulae incremental verification theorem gives us a way to check that an expression satisfies a contract assume that we are given a program p with a function f for which we have already shown that d i cf cf suppose next that we are presented with a next goal to prove that d i ch ch we may consider the following variations of how to do this · ask for the of t pp ch the soundness of this query follows from theorem above · ask for the of t pp cf cf ch this query adds the already proven contract for f to the theory if this formula is unsatisfiable then its negation is valid and we know that the denotational model is a model of the theory and of cf cf and hence it must also be a model of ch ch · ask for the of t pp f cf cf ch this query removes the axioms associated with the definition of f leaving only its contract available this makes the proof of hs contract to changes in f s implementation via a similar reasoning as before such an invocation is sound as well incremental verification essentially implies that our approach does not require a analysis once a contract is proved about a function it can be assumed even if the definition of the function is not exported and subsequently used to prove contracts of other functions that may call it only the contract but not a definition of a function can be for efficiency reasons when verifying further goals the is that the exported contracts might not be precise enough for proving these further goals our framework supports any of those strategies induction an important practical extension is the ability to prove contracts about recursive functions using induction for instance we might want to prove that length satisfies cf cf length z length s length xs in the second case we need to show that the result of length xs is crashfree but we do not have this information so the proof gets stuck often resulting in the looping a naive approach would be to perform induction over the list argument of length ­ however in haskell datatypes may be lazy infinite streams and ordinary induction is not a valid proof principle fortunately we can still to fixpoint induction the fixpoint induction scheme that we use for length above would be to assume that the contract holds for the of some function inside the body of its definition and then try to prove it for the function length z length s xs formally our induction scheme is definition induction scheme to prove that g c for a function g a x eg meaning e contains some occurrences of g we perform the following steps · generate function symbols g · generate the theory formula t pp a x eg · prove that the query cg c c is unsatisfiable why is this approach sound the crucial step here is the fact that contracts are admissible predicates theorem contract if di c for all elements of a chain d d then the limit of the chain di c moreover c proof by induction on the contract c for the cf case we get the result from lemma for the predicate case we get the result from the fact that the denotations of programs are continuous in d the arrow case follows by induction we can then prove the soundness of our induction scheme theorem the induction scheme in definition is correct proof we need to show that p g c and hence by it is enough to find a chain whose limit is p g and such that every element is in c let us consider the chain p k g so that p g and p p p whose limit is p g we know that c so by using contract all we need to show is that if p c then p c to show this we can assume a model where the denotational interpretation i has been extended so that ig p and p by proving that the formula cg c c is unsatisfiable since d i and d i cg c we get d i c and hence p c note that contract is essential for the soundness of our induction scheme and is not a property that holds of every predicate on denotations for example consider the following haskell definition ones ones f s x f x f z let us try to check if the ones is true in the denotational model using fixpoint induction by here we really mean the negation of logical equality ­ not a haskell function that computes a bool the case for holds and so does the case for the z constructor for the s x case we can assume that fx ones and we can easily prove that this implies that fs x ones nevertheless the property is not true ­ just pick a counterexample s where s s s what here is that the property is true of all the elements of the following chain s ss but is false in the limit of this chain in other words is not admissible and our induction scheme is plain for predicates finally we have observed that for many practical cases a straightforward generalization of our lemma above for mutually recursive definitions is required indeed our tool performs mutual fixpoint induction when a recursive group of functions is encountered we leave it as future work to develop more advanced techniques such as strengthening of induction hypotheses or identifying more sophisticated induction schemes implementation and practical experience our prototype contract checker is called it uses ghc to parse typecheck and a haskell program translates it into first order logic exactly as in section and invokes a fol theorem prover z etc on the fol formula the haskell program is expressed in intermediate language called core et al an explicitlytyped variant of system f it is straightforward to translate core into our language expressing contracts in haskell how does the user express contracts we write contracts in haskell itself using higherorder abstract syntax and a gadt in a manner of the work on typed contracts for functional programming et al data contract t where contract a a contract b contract a b pred a bool contract a cf contract a contract a contract a contract a a value of type contract t is a a contract for a function of type t the connectives are for dependent contract function space cf for pred for and for conjunction one advantage of writing contracts as haskell terms is that we can use haskell itself to build new contract combinators for example a useful derived connective is function space contract a contract b contract a b c c c c a contract is always associated with a function so we pair the two in a statement data statement where a contract a statement in our previous mathematical notation we might write the following contract for head head cf xs not null xs cf here is how we express the contract as a haskell definition statement head cf pred not null cf if we put this definition in a file together with the supporting definitions of head not and null then we can run the program translates the contract and the supporting function definitions into fol generates a file and invokes a theorem prover and indeed is verified by all theorem provers we tried for recursive functions uses fixpoint induction as described in section a widely supported format for fol practical considerations to make the theorem prover work as fast as possible we the theories to include only what is needed to prove a property unnecessary function pointers data types and definitions for the current goal are not generated when proving a series of contracts it is natural to do so in dependency order for example reverse a a reverse reverse reverse xs x statement reverse cf cf to prove this contract we must first prove that cf cf cf then we can prove contract assuming the one for at the moment the programmer to specify which auxiliary contracts are useful via a second constructor in the statement type reverse cf cf using dependent contracts can prove dependent contracts for example filter p cf cf cf cf ys all p ys this contract says that under suitable assumptions of the result of filter is both crashfree and satisfies all p here all is a standard haskell function and p is the functional argument itself in our syntax we use to bind p statement filter cf cf p cf cf pred all p the contract looks slightly since it uses two arrows one from and one from the in the lambda this contract is proved by applying fixed point induction higher order functions our tool also deals with very higher order functions consider this function from library a b res res a b res res f f f x x xs xs f for our tool proves cf cf cf cf cf cf cf cf experimental results we have run on a collection of tests some of which can be viewed in figure our full and tables can be from the test cases include z e axioms description cf all cf cf cf length cf cf cf factorial cf exp cf cf exp cf factorial cf reverse cf any morphism filter satisfies all iterate cf repeat cf head cf figure theorem prover running time in seconds on some of the problems in the test suite on contracts that hold together with the number of axioms the generated files · of standard library functions such as iterate and · of functions with more complex recursive patterns function functions with · partial functions given appropriate preconditions head · the example from catch mitchell and · some nontrivial postconditions such as the example above with filter and all and also any p xs any p ys any p xs ys we tried four theorem provers z and e and gave them seconds for each problem for our problems z seems to be the most successful to give an idea of the sizes of the fol problems we additionally include the number of fol axioms that are associated with each verification task in figure this number ranges between but does not appear to be directly associated to the running time discussion contracts that do not hold in practice programmers will often propose contracts that do not hold for example consider the following definitions length z length s length xs z true false suppose that we would like to check the false contract length cf x x a checker will diverge trying to construct a counter model for the negation of the above query we have that this is indeed the behaviour of several tools z e why when a exists it will include tables for the function symbols in the formula recall that functions in fol are total over the domain of the terms in the model this means that function tables may be infinite if the terms in the model are infinite several very useful axioms such as may in fact force the models to be infinite in our example the table for length is indeed infinite since is always disjoint from cons x xs for any x and xs even if there is a infinite model the theorem prover may search forever in the wrong corner of the model from a practical point of view this is it is not acceptable for the checker to loop when the programmer writes an erroneous contract there exists a very simple counterexample eg z and that single small example is all the programmer needs to see the of the contract addressing this problem is a challenging but essential direction for future work and we are currently working on a modification of our theory that admits the denotational model but also permits finite models corresponding to counterexample traces if the theory can guarantee the existence of a finite model in case of a counterexample a finite model such as and will find it a correspondence to operational semantics earlier work gave a declarative of contracts using operational semantics xu et al in this paper we have instead used a denotational semantics for contracts figure it is natural to ask whether or not the two semantics are identical from computational adequacy theorem we can easily state the following theorem corollary assume that e and c contain no term variables and assume that ce x ep it is the case that d i if and only iff either p e or p or p true hence the operational and denotational semantics of predicate contracts coincide however the correspondence is not precise for dependent function contracts recall the operational definition of contract satisfaction for a function contract e xc c iff for all e such that e c it is e e ce x the denotational specification figure says that for all denotations d such that d c it is the case that d there are more denotations than of terms in d and we can easily show that the correspondence breaks exploiting the function as a test we omit the details due to lack of space this is not a serious problem in practice after all the two definitions mostly coincide and they precisely coincide in the base case at the end of the we are interested in whether main cf and we have proven that if is crashfree it is definitely crashfree in any term finally is it possible to define an operational model for our fol theory that interpreted equality as contextual equivalence probably this could be made to work although we believe that the formal from syntactic manipulation of terms could be worse than the current denotational approach polymorphic observe that our of in figure includes only axioms for data constructors in fact our denotational interpretation allows more axioms such as y this axiom is useful if we wish to give directly a cf contract to a value of arrow type for instance instead of specifying that map satisfies the contract cf cf cf cf one may want to say that it satisfies the contract cf cf cf with the latter contract we need the previous axiom to be able to apply the function argument of map to a crashfree value and get a crashfree result in some situations the following axiom might be as well x if the result of applying a function to any possible argument is crashfree then so is the function pointer this allows us to go in the inverse direction as before and pass a function pointer to a function that expects a cf argument however notice that this last axiom introduces a quantified assumption which might lead to significant efficiency problems we would like to say that cf cf cf but that is not quite true in particular x is not valid in the denotational model for instance consider the value for y the lefthand side is going to always be true because the application is illtyped and will yield but y is not itself crashfree related work there are very few practical tools for the automatic verification of arbitrary lazy and higherorder functional programs though the automated verification of higherorder programs at least for restricted languages has been studied before for instance by the acl community furthermore our approach of directly translating the denotational semantics of programs does not appear to be in the literature catch mitchell and is one of the very few tools that address the verification of lazy haskell and have been evaluated on real programs using static analysis catch can detect pattern match failures and hence prove that a program cannot crash some annotations may be necessary for the analysis to succeed our aim in this paper is to achieve similar goals and moreover to be in a position to assert functional correctness types et al is an approach to callbyvalue functional program verification contracts are written as refinements in a fixed language of predicates which may include recursive predicates and the extracted conditions are using an because the language of predicates is fixed predicate abstraction can very effectively infer precise refinements even for recursive functions and hence the annotation burden is very low in our case since the language of predicates is by design the very same programming language with the same semantics inference of function specifications is harder the other important difference is that types requires all uses of a function to satisfy its precondition whereas in the semantics that we have chosen bad uses are allowed but the programmer gets no guarantees back rather different to types et al allows refinements to be written in the very same programming language contrary to our case however in the expressions that refine types must be pure that is terminating and have a unique denotation eg not depending on the store driven from a typing relation that includes logic entailment judgements verification conditions are extracted and automatically using z similar in spirit the et al compiler also extracts verification conditions that are using z or interactive theorem provers hybrid type systems such as and flanagan attempt to prove as many of the goals statically and defer the rest as runtime tests et al is a verification back end that supports procedures as well as pure functions by using z verifies programs written in the intermediate language which could potentially be used as the back end of our translation as well recent work on performing induction on top of an smt solver proposes a tactic for encoding induction schemes as firstorder queries which is of the way that we perform induction leino the recent work on the system et al presents an approach to the verification of firstorder and callbyvalue recursive functional programs which appears to be very efficient in practice it works by extending smt with recursive programs and control literals that guide the pattern matching search for a and is guaranteed to find a model if one exists whereas that is not yet the case in our system as we discussed earlier it does not include a special treatment of the value nor pattern match failures seem to be in the scope of that project but rather partial functional correctness the tool et al verifies equational properties of functional programs its proof search is based on induction equality reasoning and operational semantics while termination it can also start new induction proofs driven by syntactic heuristics however it only considers finite and total subsets of values and we want to reason about haskell programs as they appear in the possibly nonterminating with lazy infinite values and run time firstorder logic has been used as a target for higherorder languages in other verification contexts as well users of the interactive theorem prover have for many years had the to use automated firstorder provers to proof obligations this work has recently in the tool et al which not only uses firstorder provers but also smt solvers as back ends there has also been a version of the dependently typed programming language agda in which proof obligations could be sent to an automatic firstorder prover et al both of these use a translation from a typed higherorder language of wellfounded definitions to firstorder logic a work that comes very close to ours in that they deal with a lazy general recursive language with partial functions is by et al who use agda as a logical framework to reason about general recursive functional programs and combine interaction in agda with automated proofs in fol there exists more work on translating the semantics of programs or their properties in higherorder logics eg for instance the work on characteristic formulae and the work on verification and pottier the former is interpreting a program as a higherorder predicate transformer whereas the latter introduces a higherorder typed and extracts verification conditions which are proved in coq or with an automated theorem prover we aim to within the of firstorder logic to exploit automation by the advances in fol theorem provers and model at the same time we do lose expressivity as our predicate language are only haskell functions on the other hand this gives us practically for free even in the of inductive types but even in the case of the previous work of and pottier conditions have to be imposed on datatypes to make sure that the logical specification can be embedded in a logic built in like types that work enforces contract preconditions in all call sites finally in the higherorder logic world the recent work of can be used to translate haskell programs and reason about their semantics in the main application being the verification of monad transformers the previous work on static contract checking for haskell xu et al was based on a term was effectively wrapped with an appropriately nested contract test and symbolic execution or inlining was used to show that bad values could never be reached in this wrapped term in work xu xu proposes a variation this time for a callbyvalue language which performs symbolic execution along with a of the program that can be used via a theorem prover to eliminate paths that can provably not generate bad value the of a program has a similar spirit to our translation to logic furthermore the of programs is dependent on whether the resulting formula is going to be used as a goal or assumption in a proof improving work and van horn and horn propose a system in the same space of symbolic execution but they the language of contracts to handle arbitrary potentially divergent or functions we believe that our approach which is to directly encode the semantics of programs might be simpler to specify and reason about that said symbolic execution has the advantage of a theorem prover on many small goals instead of a single big goal we have some ideas about how to break large satisfiability queries to smaller ones by the symbolic evaluation of functions and we consider integrating this methodology finally higherorder model checking kobayashi ab aims at verifying properties about the execution of functional programs for instance it can also verify temporal properties of programs based on a translation of programs to higherorder recursion schemes higherorder model checking is an area of active research to improve the efficiency and applicability of the original approach conclusions and future work static verification for functional programming languages seems an compared to the imperative world and very promising area of research in practical terms our most immediate goal is to ensure that we can find finite counterexamples quickly and present them to the user rather allowing the theorem prover to diverge as mentioned in section we have ideas for how to do this it would also be interesting to see if in smt could also be used to support that goal we would like to add support for primitive data types such as integer using theorem provers such as to deal with the typed firstorder arithmetic part of another approach might be to generate theories in the smt format understood by z which has support for integer arithmetic and more another important direction is finding ways to split our big verification goals into smaller ones that can be proven significantly faster finally we would like to investigate whether we can automatically contracts to be used as induction hypotheses in inductive proofs deriving information from failed attempts acknowledgements thanks to the popl reviewers and richard for their feedback and to for early work on a prototype of our translation references coquand and connecting a logical framework to a firstorder logic prover in th international workshop on frontiers of combining systems lncs springer verlag michael robert and k m leino a modular verifier for objectoriented programs in formal methods for components and objects pages ­ benton andrew kennedy and some domain theory and denotational semantics in coq in proceedings of the nd international conference on theorem proving in higher order logics pages ­ berlin springerverlag m andrew d gordon and david semantic subtyping with an smt solver in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm and extending with smt solvers in conference on automated deduction lncs springer verlag matthias and david sound and complete models of contracts j program ­ july peter and combining interactive and automatic reasoning in first order theories of functional programs in birkedal editor th international conference on foundations of software science and computational structures volume of lncs pages ­ march characteristic formulae for the verification of imperative programs in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm and new techniques that improve model finding in proc of workshop on model computation model de and z an efficient smt solver in proceedings of the theory and practice of software th international conference on tools and algorithms for the construction and analysis of systems pages ­ berlin springerverlag robert bruce findler and matthias felleisen contracts for higherorder functions in proceedings of the acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm and typed contracts for functional programming in proceedings of the th international conference on functional and logic programming pages ­ berlin springerverlag and interpolation and symbol elimination in in proceedings of the th international conference on automated reasoning pages ­ berlin springerverlag formal verification of monad transformers in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm and flanagan hybrid type checking acm trans program lang syst ­ february kobayashi types and higherorder recursion schemes for verification of higherorder programs in proceedings of the th acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa a acm kobayashi modelchecking higherorder functions in proceedings of the th acm sigplan conference on principles and practice of declarative programming pages ­ new york ny usa b acm k m leino induction with an smt solver in proceedings of the th international conference on verification model checking and abstract interpretation pages ­ berlin springerverlag mitchell and not all patterns but enough an automatic verifier for partial but sufficient pattern matching in proceedings of the st acm sigplan symposium on haskell haskell pages ­ new york ny usa acm towards a practical programming language based on dependent type theory phd thesis university of technology andrew m pitts relational properties of domains inf comput ­ m ming and jhala types in proceedings of the acm sigplan conference on programming language design and implementation pldi pages ­ new york ny usa acm and pottier a hoare logic for callbyvalue functional programs in proceedings of the international conference on mathematics of program construction pages ­ july g siek and gradual typing for functional languages in in scheme and functional programming workshop pages ­ william and an automated prover for properties of recursive data structures in proceedings of the th international conference on tools and algorithms for the construction and analysis of systems tacas pages ­ berlin springerverlag martin m t simon peyton jones and system f with type equality coercions in proceedings of the acm sigplan international workshop on types in languages design and implementation pages ­ new york ny usa acm g the problem library and associated infrastructure the and parts v journal of automated reasoning ­ ali and satisfiability modulo recursive programs in proceedings of the th international conference on static analysis sas pages ­ berlin springerverlag chen fournet and yang secure distributed programming with types in international conference on functional programming pages ­ and david van horn higherorder symbolic execution via contracts in proceedings of the acm sigplan conference on objectoriented programming systems languages and applications oopsla philip wadler and robert bruce findler welltyped programs cant be in proceedings of the th european symposium on programming languages and systems esop pages ­ berlin springerverlag the formal semantics of programming languages an introduction foundation of computing series mit press xi dependent ml an approach to practical programming with dependent types j program ­ march n xu hybrid contract checking via symbolic simplification in proceedings of the acm sigplan workshop on partial evaluation and program manipulation pages ­ new york ny usa acm n xu simon peyton jones and static contract checking for haskell in proceedings of the th annual acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm 