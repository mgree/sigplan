message of thanks on the of the acm sigplan distinguished hoare principal microsoft research mem cambridge university computer laboratory categories and subject descriptors d programming languages formal definitions and theory d software engineering verification f logics and meanings of programs specifying and verifying and reasoning about programs f logics and meanings of programs semantics of programming languages general terms verification reliability languages theory security even to one who has long enough to receive many the recognition of distinguished from the scientific community in ones own research field is surprisingly i particularly the sigplan citation for my which out exactly the of which i am most i have known nearly all the previous of this and they number among my and i have derived from them all and i am to be regarded in their the me to reflect again on the and progress of my how did i select the topics for my research what methods did i consider appropriate for an academic to such research what is the current level of of research on these topics what does the future hold for it why do i regard my interest in unifying theories as a contribution to that future computer programs i have always regarded the computer program as a topic for scientific study indeed programs must be a central topic in computer science both pure and applied having chosen this topic i addressed to the fundamental questions that the of all no matter what their chosen topic of research what does it do to answer this question we need a conceptual framework and language for describing the observable properties and behaviour the program equally important is a description of the environment in which the program is executed in copyright is held by the popl january ­ pa usa acm its users in many branches of science separate branches of mathematics have been developed to provide effective frameworks for the topics relevant to that branch fortunately from around the beginning of the last have shown that all branches of mathematics rest on a common foundation to preserve the greatest generality in describing the behaviour of a generalpurpose computer we should exploit this common foundation from it we get boolean algebra predicate calculus and the theory of sets when required it is easy to define from these foundations the structures manipulated by our programs for example functions sums products types relations sequences etc experiments in application have shown that these concepts give concise and intuitive descriptions of computer systems while preserving a level of abstraction that is appropriate for specifications how does it work for this we need to look inside the program to identify its internal components and the ways that they are connected again the foundations of mathematics provide a language for defining the behaviour of each component and the interfaces between them in an of rational software engineering these interface specifications will be written in advance of the design they will serve as a contract between the of the various program components this is an ideal that has inspired much pure research in the field at the design of theories that exploit modularity compositionality of designs even if it has to be later to efficiency of the eventually executed program why does it work the answer to this deeper question must to general principles which apply not just to a particular program but to a general range of similar programs actual or the principles should support a proof that the joint working of all the components of a program will necessarily lead to the correct operation of the whole program as described by its specification then we will really know both why and how the program works the principles of programming are often as a set of rules defining the semantics of the programming language in which the program is or can be expressed several forms of semantics have been developed to serve different purposes an operational semantics provides a guide for an implementation of the programming language and serves the programmer as a basis for errors discovered in test a deductive semantics gives the pattern for proving correctness of programs which is a more difficult but more certain way of ensuring that no errors will detected in service a denotational semantics constructs a mathematical model of the programming language so that standard mathematical reasoning can be applied directly to it each of these of semantics has a clearly defined role the last section of this message expresses the hope that a full theory of programming will eventually unify semantics expressed in all the and so ensure their mutual consistency how do we know the theory applies to the real world this is the question of greatest concern to the it is by a series of experiments with collection and interpretation of their observed results every claim of discovery of a new theory and every to an old theory must be supported by to experiment ­ even a thought experiment will do further and larger experiments are needed to explore the limits of applicability even of already theories for these experiments should be by independent of the of the theory often the theory needs modification or extension to extend the range of its application a unifying theory is one whose range of application is the of all how are the results of the research to engineering practice modern engineering depends on automation of the design process it is the computer that works out in detail the implications of every engineering design decision and checks the and safety of a product before it comes into service an established design automation provides a means of transfer of new scientific results into engineering practice when agree about the strength of the evidence of a new theory or an or extension of an old theory the and of the tools will to incorporate any improvements in the next release of the for which they have developed a share current state of the art in branches of science it is the natural world that the experimental observations that support or refine the theories of pure and and most recently have on international projects to build the and to experiments whose results the data bases of the worlds computers for an engineering science the experiments are performed on the products made by in computer science the programs developed by the open source movement already give and public access to experimental material on a scale that is fortunately more than adequate for our current research needs the main task for modern science is to interpret the of experimental material by relating it to the natural laws which are to explain them write computer significant computer programs to the mass of data automatically in the light of current theories this is now the only way to extract information from the data and so to refine extend and even unify existing theories analogous tools for scientific analysis of programs are used by the software to help in the engineering of critical parts of widely used software they are often used to support the experimental side of research into the principles of programming the last has seen an increase in the power of these programming tools law every a roughly a fold increase in the performance of computer often by a reduction in price this rate of progress has been by a comparable increase in the algorithmic efficiency of sat and smt solvers and model checkers the advance in software tools has been driven by regular scientific these are and by independent and the whole experimental community in the assembly of realistic challenge material for of the a second for program analysis has been the totally of the computer or other exploit a programming error to or even take control of perhaps of computers which run the erroneous program that is why leading software are to in the development of program analysis tools these are based on the best available current theories of programming and the best available smt solvers and model checkers the tools are now applied to many of lines of commercial software before release the future i therefore predict an future for further academic research on the principles of programming and for further of its research results the research will take advantage of the most advanced available program analysis tools to perform experiments at ever increasing on real and realistic software the tools themselves will by exploiting experience of their use both by and by software developers continuous interaction of and will lead to an exponential increase in the rate of scientific progress perhaps computer science will match the recent in the progress of and more recently which has been achieved by integrating tools into the scientific method and much of this progress will be made by between academic researchers and software developers who already the of using program analysis tools to reduce the costs and the of programming error at the same time will continue to their resources into more immediately applicable tools which concentrate on test case generation of early detection of programming errors academic research should not be confined to with the better research of users it should also continue to higher and longer term ideals because this is the only way of ensuring a stream of new ideas and even to advance the state of the art ideals such as accuracy of measurement or purity of are the force of science even if the theory itself says that they can only be approximated the approximations can be refined in computer science the relevant scientific ideal is total correctness of computer programs guaranteed by proofs with the of computers during their design and implementation it is for the to decide later in each case how far the ideals must be to meet engineering constraints of cost and unification my own personal research has recently to of a scientific ideal namely the unification of theories of programming since this is mentioned in my citation for the distinguished i will this last section of my message of thanks to why i believe that unification will make a contribution to the future described in the previous section in the natural sciences the for a unifying theory is an integral part of the scientific the aim is to show that a single theory applies to a wide range of highly for example the theory of applies very accurately both to towards the and to towards the sun in many cases a more subset of the is already covered by a more scientific theory in these cases the theory must be derived from the unified theory for example theory of the elegant theory of as well as the less elegant theories of the scientific benefit of a unified theory is that it is supported by all the evidence that has already been for all of the previous theories separately furthermore each of the previous theories then inherits the support given by the total sum of evidence by all the other theories the has different concerns from the including and for the current project the will therefore continue to use familiar more theories that have been found from experience to be well adapted to the particular features of the current project or the needs of the current client indeed the will often the theory even further it so closely to current needs that there will never be an for repeated use that is why the separate theories that are subsumed by a unifying theory often retain all their practical value and they are in no way or by the unification the real practical value of unification lies in its contribution to the transfer of the results of scientific research into engineering practice one of the main factors that the and the sensible manager from a scientific theory is that the do not yet agree what that theory should be fortunately there is an method of a scientific an experiment is designed whose result is differently by all the theories that are party to the the can then have increased in the but sometimes no such experiment can be discovered this may be because in of differences in their presentation the theories are in fact entirely consistent in this case the only way of the issue is to find a theory that them all quantum theory provides an example three separate mathematical of quantum theory were put forward by and then showed that they were all derivable from a single unified theory this is what enabled the of a to all three of them and quantum theory is now accepted as the to a theory of everything that has to offer a second contribution of a unified theory to the is in the design and use of a suite of software tools that in automation of the design process since every major engineering combines a range of it is important that all the members of the tool suite should be based on a common theory so that they can communicate consistently among each other on standard interfaces which are based upon the unification the standards also facilitate among the tools and permit independent evolution of separate tools for joint use in a design automation finally the of the general and will be by reducing the number of independently developed theories to a single theory presented in a single coherent framework and notation that in itself is sufficient justification for by of research into unification of theories 