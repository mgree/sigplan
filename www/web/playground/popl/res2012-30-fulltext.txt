on the power of coercion abstraction inria abstract coercions in system f also known as functions are welltyped of the identity they may change the type of terms without changing their behavior and can thus be erased before reduction coercions in f can model subtyping of known types and some of quantifiers but not subtyping assumptions nor certain forms of delayed type instantiation we generalize f by allowing abstraction over functions we follow a general approach where computing with coercions can be seen as computing in the calculus but keeping track of which parts of terms are coercions we obtain a language where coercions do not contribute to the reduction but may block it and are thus not we recover coercions by choosing a weak reduction strategy and restricting coercion abstraction to or by restricting abstraction to coercions that are polymorphic in their domain or codomain the latter variant subsumes f f and mlf in a unified framework categories and subject descriptors d programming languages formal definitions and theory general terms design languages theory keywords type system f polymorphism coercion conversion functions type containment subtyping bounded polymorphism introduction parametric polymorphism and subtyping polymorphism are the two most popular means of increasing expressiveness of type systems although first studied independently they can be combined together each mechanism alone is relatively simple to understand and has a more or less canonical presentation however their combination is more complex the most popular combination is the language f cardelli however this is just one relatively easy in the design space in fact much work in the s has been to improving the combination of parametric and subtyping polymorphism motivated by its application to the typechecking of objectoriented features the key of subtyping polymorphism is already modeled in the language f proposed by mitchell one way to define f is as the closure of system f by conversion we write cm for a context c with a term m permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm a context from to is a closed context c such that xc x is an expansion of the identity also called a function and has type in system f if c is a context from to and m is a term of type then cm is a term of type in system f in system f the rule allows m itself to be of type moving to system f we may keep ie of contexts explicit we write g m for the application of context ie a coercion g to the term m we write for the empty context of type is induced by expansion as follows if g and g are contexts from to and from to then x g g x is a context from type to besides expansion also introduces opportunities for inserting type abstractions and type applications which may change polymorphism a for instance from the type we can find a context to any type of the form ¯ provided ¯ does not appear free in this context is x ¯ x such are not supported in f where polymorphism can only be introduced and eliminated explicitly at the part of terms conversely f allows reasoning under subtyping assumptions which f does not support indeed bounded quantification m of f introduces a type variable that stands for any subtype of inside m in particular a covariant occurrence of in m can be converted to type by subtyping therefore f and f are incomparable is there a language that both before we this question let us first consider another form of assumptions that have been introduced in mlf le and polymorphism m introduces a type variable that stands for any instance of inside m that is an occurrence of type within m in an position can be converted to any instance of quantification delays the choice of whether a polymorphic expression should be instantiated immediately or kept polymorphic this mechanism enables expressions to have more general types and has been introduced in mlf to enable partial type inference in the presence of firstclass secondorder polymorphism and some type annotations notice that bounded type instantiation allows for deep type instantiation of binders as f does but using a quite different mechanism bounded type instantiation has with bounded quantification of f but the two also differ significantly since for instance type conversion is not congruent on arrow types in mlf surprisingly among the three languages f f and mlf any combination of two have features in common that the other one lacks hence the challenge becomes whether all their features can be combined together this question has in fact already been raised in previous work on mlf and our contributions we answer by introducing a language fp that extends f with abstraction over functions combining all features simultaneously in a unified framework § the language fp subsumes f f and mlf § it also and extends a previous language of coercions designed for modeling mlf alone and our subset of fp that coincides with mlf is wellbehaved it satisfies the subject reduction and progress lemmas and strongly it also has an untyped semantics actually the extension of f with abstraction over coercion functions leads to a larger language f of which fp is a restriction § the language f is wellbehaved we show that f can be simulated into system f hence reduction rules in f are just particular instances of reduction § f can also be simulated into the untyped calculus by coercions which shows that coercions do not contribute to the computation unfortunately they may block it and are thus not § can be by choosing a weak reduction strategy § but this is not entirely satisfactory so other restrictions or extensions of f with coercions are still to be found nevertheless we believe that f is a ground for understanding coercions § system f all languages we consider are second order calculi whose origin is system f system f comes in two in terms do not carry type information and are thus a subset of the untyped calculus while in terms carry explicit type information namely type abstractions type applications and annotations of function parameters of course both are closely related since there is a bisimulation between the reduction of terms in and terms in via type erasure where the reduction of type application between terms in is reflected as an equality on terms in that is calling the reduction of type applications and the reduction of term applications the type of two explicitlytyped terms related by reduction resp reduction are related by reduction resp equality conversely if the erasure of a term m reduces to a term m then m also reduces by a sequence of reductions followed by a single reduction to a term whose erasure is m both views are equally useful we prefer source expressions to be explicitly typed so that type checking is a trivial process and types can be easily maintained during program transformations we also wish types to be after compilation for efficiency of program execution moreover a source language with an untyped semantics is generally simpler to understand reason about and use we may argue that even if the source language has polymorphism it should first be compiled in a way to an intermediate language with an untyped semantics crary et al from types to type conversions our approach to coercions is similar to polymorphism in system f because we focus here on functions that are in some one may use other forms of coercions that may have some computational content eg change the representation of values and thus not be then we should compile source expressions into an intermediate language where remaining coercions if any are this is then the language we wish to study here also means that the dynamic semantics of our language is ultimately that of the underlying with more constructs therefore the semantics only depends on the reduction strategy we choose and not on the typechecking details nor on the coercions we may use types are useful for programmers to understand their programs it is also useful for programmers that types do not determine the semantics of their programs at least we should provide an intermediate representation in which this is true coercions may also be introduced a to make type conversions explicit inside source terms coercions usually simplify the study of the language by providing a concrete syntax to manipulate typing derivations proofs such as subject reduction become computation on concrete terms instead of reasoning on derivations while in practice programming languages use weak evaluation strategies strong evaluation strategies provide more insight into the calculus by also modeling reduction of open terms since our focus is on understanding the essence of coercions and the properties we prefer strong reduction strategies a weak reduction strategy on a wellbehaved strong calculus is usually if all properties do not automatically transfer conversely properties for weak reduction strategies do not say much about strong reduction strategies the two of f let us first return to the definition of f which in original presentation is given in it is defined by adding to system f a type containment rule that allows to convert a term m of type to one of type whenever there exists a context from type to which we write this judgment called type containment is equivalent to the existence of a closed function m of system f such that m ie a function that is an expansion of the identity interestingly mitchell gave another characterization of type containment a proof system for the judgment which can be read back as the introduction of a language of coercions whose expressions g witness type containment derivations then we write g where g fully determines the typing as a term m fully determines its typing derivation for example g g is a coercion that given a function m returns a function that its argument with g passes it to m and the result with g hence the of type containment a full presentation of coercions appears in § where f is described as a subset of f the interpretation of coercions as terms is more intuitive than coercions as proof witnesses unfortunately its formal presentation f which is equivalent to f is technically more involved for reasons explained in § hence we prefer to present f first in § and only introduce f informally in § interestingly the reification of f into system f given in § already reveals this intuitive interpretation of the we refer to it when describing the typing rules and reduction rules of f in system f the use of a coercion g around a term m is explicitly as g m we may continue a coercion g as a context and reading this as the hole of g or equivalently see g as a function and read this as an application of a coercion to a term reduction rules are added to reduce such applications when both g and m have been sufficiently a way depending on the form of both so that a coercion g is never stuck in the middle of a welltyped redex as in g x m n the type system ensures that g is of a certain shape for which a reduction exists in the above example g may be g g and then g x m can be reduced to x g m x g x the of f to abstract over coercion functions we introduce a new form c m in f where the parameter c stands for a coercion function that can be used inside m to convert an expression of type to one of type this abstraction can be typed as where is the type of m we need a new application form m g to pass a coercion g to a coercion abstraction ie a term m of type by typing constraints coercion abstractions can only be instantiated with coercions which by construction are thus x y m x xm m m c x m m mm cm cm xm m variables terms reduction contexts mx m figure calculus syntax and semantics intuitively coercions do not really contribute to the computation is this enough to erase them formally we can exhibit a forward simulation between reduction of terms in f and of their erasure in the untyped calculus moreover f has the subject reduction property and is strongly normalizing still coercions cannot be erased in f since although they do not create new evaluation paths they may block existing evaluation paths a subterm may be stuck while its erasure could proceed since coercions are in f this can only be due to the use of a coercion variable indeed a coercion variable c may appear in the middle of a redex as in c x m n this is irreducible because reduction of coercion applications g m depends simultaneously on the shapes of g and m so that no rule when g is unknown more generally we call a an irreducible term of the form g x m n notice that the erasure of a x m n can be reduced immediately hence the existence of in reduction contexts prevents coercions in fp an obvious solution to recover is to make configurations that they never appear during the reduction of welltyped programs one interesting restriction called fp read parametric f is to request that coercion parameters be polymorphic in either their domain or their codomain this allows coercion variables to appear either applied to a function or inside an application but not both simultaneously another solution is to change the semantics choosing a weak reduction strategy for coercion abstractions and restricting them to appear only in front of value forms coercion variables hence cannot occur in a reduction context any more this variant is called fw read weak f although our main f f and mlf in a same reached both fp and fw are restrictions of f we may thus whether other yet more interesting solutions exist we further discuss some of the issues in § argue about some of the difficulties in the general case and suggest other restrictions worth exploring we defer a discussion of related works to § the language f the language f generalizes f with abstraction over coercions we recall the definition of the untyped calculus on figure we normally include pairs and projections both to have non trivial errors otherwise even untyped terms cannot be stuck and to have more interesting forms of subtyping however we omit them in this summary for of we refer to them informally to explain how the definitions generalize to pairs we assume an enumerable collection of term variables ranged over by letters x and y untyped terms written m include variables abstractions xm and applications m m the semantics of untyped terms is given by a smallstep strong reduction relation reduction contexts of the calculus are all contexts written c we now write cm for the term obtained by the hole of c with m and mx m for the capture avoiding substitution of m for x in m expressions are considered equal up to the renaming of bound variables which are defined in the types coercion abstraction coercion type m n x x m m m m m gm c m m g g c top g g dist dist g g gg c g gg terms type abs app term coercion coercion abs app coercions distributivity type abs app coercion coercion coercion abs app x c typing environments figure syntax of f usual way this convention applies to the calculus as well as to all typed languages presented below syntax of f the language f is explicitly typed types are described on figure we assume given an enumerable set of type variables ranged over by and types are type variables arrow types polymorphic types the top type or coercion abstractions where the coercion type is of the form coercions are not first class hence a coercion type is not itself a type the language of expressions is split into terms and coercions we reuse the term variables of the calculus in addition we assume an enumerable set of coercion variables written c terms are an extension of system f hence they include type variables x abstractions x m applications m m type abstractions m and type applications m a construct already present in f is the use of the application g m of a coercion g to a term m there are two new constructs specific to f and not present in f coercion abstraction c m which is annotated with the coercion type and coercion application m g that passes a coercion g to a term m and should not be with the earlier construct g m of f that places a coercion g around a term m since the main purpose of coercions is to change types we could the description of coercion constructs together with their typing their associated reduction rules that justify the typing rules still each coercion expression can be understood as a context some rule so we introduce each construct with the context it stands for also for the reification of coercions as terms given in § a coercion variable c stands for the coercion it will be bound to the opaque coercion top is a version of existential types we currently do not handle existential types for reasons explained in § it turns a term of any type into an opaque term of type that can only be used abstractly the empty coercion stands for the empty context and witnesses of type containment the arrow coercion g g stands for x g g x and witnesses of the arrow type constructor the distributivity coercion dist stands for x x and a type abstraction with a term abstraction assuming the hole has type where does not appear free in it returns a term of type for instance the coercion of a polymorphic function y n x x x m x m mn m n m m m gm m c m m g m figure coercion erasure makes it appear as if it had been defined as y n which is actually what it will reduce to once the other distributivity coercion dist which stands for x c c x is similar but a coercion abstraction with a term abstraction we may need more distributivity coercions when extending the language of terms hence the notation uses the following the a and the subscript b c indicate the kind of the first and second type constructs respectively they can be combined into ab c to form the type of the hole or into b ac to form the type of the term for example dist is a coercion from to while dist is a coercion from to the remaining coercions are the lifting of all term constructs without computational content to coercions type abstraction g and type application g coercion of a coercion g g which intuitively stands for g g and witnesses transitivity of coercions it has type if g and g have coercion types and respectively finally coercion abstraction c g and coercion application g g all these coercions are of the form p g where p is one of the contexts g c or g where the hole is filled with g it is convenient to the notation p when the hole holds a term instead of a coercion although this is formally another syntactic node we recover the syntax of system f by removing coercion types from types and coercion variables coercion abstractions and applications from both terms and coercions we recover the syntax of system f by further removing the top type term coercions and all coercion forms which become the coercion erasure written · defined on figure is as expected type annotations on function parameters and coercions are erased while other constructs are on their equivalent constructs in the untyped calculus typing rules typing environments written are lists of bindings where bindings are either type variables coercion variables along with their coercion type c or term variables along with their type x figure we write m if term m has type under and g if coercion g has coercion type under the two typing judgments are recursively defined on figures and they use auxiliary wellformedness judgments for types and typing contexts we write ok to mean that typing environment is wellformed and or to mean that type or coercion type is wellformed in as usual we require that typing contexts do not bind twice the same variable which is not restrictive as all expressions are considered equal up to renaming of bound variables details can be found in the extended version typing rules for terms are described in figure rules and are exactly the typing rules of system f rule is similar to rule except that a coercion g of coercion type is used instead of a function m of type rule is similar to except that the parameter c stands for a coercion of coercion type instead of a term of type the result is a coercion abstraction of type p x p v p pg c v dist p dist p g g p dist p dist c p v p x v v c v top v values c x m m p reduction contexts p g c g contexts figure system f values and reduction contexts consistently applies a term that is a coercion abstraction of type to a coercion g of coercion type typing rules for coercions are described in figure they are all straightforward when read with the context that the coercion stands for in mind rule reads the coercion type of a coercion variable from its typing context the empty coercion has type provided is wellformed in the current context as all basic coercions it contains just enough type information so that its typing rule is syntaxdirected the top coercion top converts an expression of type to the top type provided is wellformed the arrow coercion g g turns an arrow type into an arrow type provided gi type i into i for i in the distributivity coercion dist turns an expression of type into one of type provided is wellformed in the current environment which prevents from appearing free in and is wellformed in the current environment extended with finally rule is similar to but a coercion abstraction and a term abstraction the remaining rules and are similar to their counterpart for terms but where the term m of type has been replaced by a coercion ie a context g of coercion type where is the type of the hole and the type of the body rule for typing g introduces a variable that is bound in g and can be used in the type of the body of g but not in the type of its hole which is enforced by the first premise in particular g builds a coercion to a polymorphic type and not a polymorphic coercion accordingly only the codomain of the type of the conclusion is polymorphic rule is typed in a similar way c g has type and not as one could would be type and coercion applications are typed accordingly and the typing rules for f are obtained by removing and for terms and their counter parts and for coercions as well as rule for coercion variables and rule for distributivity of coercion abstraction the type that appear in distributivity and top coercions make type checking syntax directed the type in arrow coercions is not needed for typechecking but to keep reduction a local rewriting rule we may leave implicit when they are or can be from the context our presentation of f is in f is the image of f by coercion erasure that is it is the subset of terms of the untyped calculus that are the erasure of a term of system f we write m to mean that there exists m such that m and m is m ok x x m m x m x m m m n n m m g m g m c m c m figure system f term typings m m g g top g g g g dist dist g g g g g g g g c g c g g g g g ok c c figure system f coercion typings m n cm cn m n cm cn x m n m x n m m c m g m c g g g x m x g m x g x dist x m x m dist c x m x c m m m p g m p g m figure reduction rules for f dynamic semantics the dynamic semantics of system f is given by a standard smallstep strong reduction relation the syntax of values and reduction contexts is on figure a value is an abstraction of a value an opaque value top v or a a is a variable a applied to a value type or coercion a value by a coercion variable or a partial application of a distributivity coercion reduction contexts c are all term contexts for convenience we have distinguished a subset of reduction contexts p called reduction contexts a term m placed in a reduction context is just a of m ie a term that behaves as m but possibly with another type reduction rules are defined on figure we have indexed the reduction rules so as to distinguish between steps with computational content that are preserved after erasure and steps that become equalities after erasure we write for the union of and hence rule is split into two rules so as to pre serve the index of the premise the only redex is all other reductions are reductions rule is type reduction a reduction the first four rules cover system f notice that allows all possible contexts hence there is no particular reduction strategy and a callbyvalue evaluation would be a particular case of reduction rule is the counterpart of reduction for coercion application m g it only reduces a term applied to a coercion a coercion applied to a coercion is a coercion and is not reduced directly but only when it is applied to a term so that rule eventually applies all other rules reduce the application g m of a coercion g to a term m which plays the role of a destructor both g and m must be sufficiently evaluated before it when g is the opaque coercion or a variable since top v and c v are values other coercion nodes are all constructors we thus have one rule for each possible shape of g the most interesting rules are · when g is an arrow coercion g g and m is a function x m rule reduces the application by g on all occurrences of x in m and g outside of m this changes the type of the parameter x from to hence the need for the annotation on arrow coercions · when g is a distributivity coercion dist and m is a polymorphic function x m rule reduces the application to x m by ex changing the type and value parameters this is sound since cannot be free in · when g is a distributivity coercion dist and m is a abstraction followed by a value abstraction c x m rule reduces the application to x c m by the parameters the remaining cases for g can be as p g rule g with m transforming p g m into p g m notice that the two occurrences of p are different abstract nodes on each side of the coercion on the lefthand side and a term on the righthand side rule is actually a that could be expanded into and should be understood as the following five different rules g m g m g g m c g m g m g m g g m c g m gg m g m g the use of the the similarity between all five cases it is also more concise for example the application gg of a coercion abstraction g to a coercion g is only reduced when it is further applied to a term m as other complex coercions by first elements of g around m two first steps below so that rule can finally last step c gg m c g m g c g m g g m c g the reduction rules for system f are obtained by removing rules and optional reduction rules our presentation of f could be ex with additional reduction rules for arrow and distributivity coercions such as g g m n g m g n however this the set of values and progress would require binding coercions as for f described in § which are technically more involved for sake of simplicity the current presentation has fewer but sufficiently many reduction paths examples let us first see examples in the f subset functions in f allow for the of quantifiers and removal of useless quantifiers they also let terms have more principal types for example in system f the z y z can be given the two incomparable types however the former type is more general as it can be to the latter already in f using three this example does not use distributivity but the following example still in f does in the examples we use type constructors list and d which we assume to be covariant the map function has type list list it can also be given the type d list d list dd for some type constructor d using the following coercion which is already typable in f d dist d indeed applying the coercion d turns a term of type into one of type d list list d which in turn d dist to type this example also illustrates the lowlevel nature of the language of coercions to which we will come back in § the last two examples illustrate coercion abstraction we define a function first inspired from f that implements the first projection for nonempty tuples of arbitrary length tuples are encoded as pairs ending with we assume pairs have been added to f and write proj and proj for the projections the function first c x proj c x of type abstracts over a coercion c from arbitrary tuples to the singleton tuple it can be applied to any nonzero tuple by passing the appropriate coercion in this example subtyping could be encoded with just polymorphism instead of coercion but this is not true in general the other example of coercion abstraction inspired from mlf delays the instantiation of a call to the polymorphic function choose of type say ch when given itself as an argument let be c ch choose c choose of type ch we may then pass the function plus of type int int int say plus this application is written int plus and has type plus properties of f in this section we show that f is wellbehaved moreover there is a forward simulation between terms of f and their coercion erasure hence coercions do not really contribute to the reduction however coercions are not as they may sometimes appear in and block the reduction soundness type soundness of f follows as usual from the subject reduction and progress lemmas the proof of subject reduction uses substitution lemmas for terms types and coercions which in turn use weakening the proof is easy because coercions are explicit so the reduction rules actually are the proof proposition subject reduction if m and m n hold then n holds proposition progress if m holds then either m is a value or m reduces termination of reduction the termination of reduction for f can be on the termination of reduction in system f following and we show a forward simulation between f and system f by translating f into system f so that every reduction step in f is simulated by at least one reduction step in system f reification of f in system f there is indeed a natural translation of f into system f obtained by coercions as actual computation steps even though we ultimately erase steps we do not actually need to do so and on the contrary we may see them as computation steps in system f reification is described on figure we write m for the reification of m coercions of coercion type are as functions of type hence a coercion abstraction c m is as a higherorder function xc m a coercion variable c is as a term variable xc we assume an injective mapping of coercion variables to term variables thus the type of a term abstracted over a coercion is translated into the type of a higherorder function other type expressions are the application of a coercion to a term and the application of a term to a coercion are both as applications the remaining cases are the translation of coercions g which are all done in two steps we first translate g into some performing to transform a coercion from to into a function from to for atomic coercions variables identity or distributivity the result of this step is in the subset x x x m x m mn m n m m m m gm g m b b c m xc m m g m g x x c xc c xc x x top y x x y g g y g x g y g x dist y x y x dist y x c x p g x p g x figure reification of f into system f of f however for complex coercions the result still contains inner coercions hence in the second step we recursively translate the result of the first step this translates types and residual coercions notice that the first step may introduce applications of coercions to terms which are then turned into applications of terms to terms the translation of p g covers five one for each form of p here as in the reduction rules the two occurrences of p are different abstract nodes since p is a coercion on the lefthand side and a term on the righthand side the translation uses an auxiliary predicate dom that computes the domain of a coercion the domain of a coercion g in environment is the unique type such that g for some type this cannot be computed locally hence we assume that terms of f have been previously and all coercions have been annotated with their domain type alternatively we can define the reification as a translation of typing derivations we actually use such a translation to show that reification preserves easy but details can be found in the extended version proposition of reification if m then m is welldefined and m it is easy to verify that reduction in f can be simulated in the translation which implies the termination of reduction in f lemma forward simulation if m holds then if m n then m n if m n then m n corollary termination reduction in f is terminating confluence reduction in f is allowed in any since coercions do not contain terms and coercions are never reduced alone we may equivalently allow reduction in all coercion contexts since no rule will ever apply hence reduction in f is a rewriting system an analysis of reduction rules in f shows that there are no critical pairs hence the reduction is weakly confluent since reduction is also terminating it is confluent in fact the relation alone is confluent moreover the reduction and commute corollary confluence reduction in f is confluent lemma if m m and m m hold then there is a term n such that m n and m n forward simulation coercion erasure sends terms of f into the untyped calculus it also induces a simulation from the reduction in f by the reduction in the calculus where steps becomes equalities lemma forward simulation if m holds then if m n then m n if m n then m n unfortunately the backward simulation fails the c y c x x y is a welltyped closed value in f while its erasure y reduces to yy to recover bisimulation the definition of the language must be so that configurations cannot appear in a reduction context this observation leads to two opposite solutions which we present in § and § coercions as functions f while the reification of f into system f carries good about what coercions really are it lacks the ability to distinguish coercions from expressions with computational content there is an alternative presentation of f called f and described in the extended version that maintains the distinction between coercions and expressions while remaining closer to the form of coercions f is mainly a coercion of system f in this sense it can be seen as an explicit version with coercion abstraction of presentation of f as system f with functions the reification of f into system f can be as the composition of a translation from f to f that keeps the distinction between coercions and terms and the final of this difference the first part along with its inverse define translations between f and f that preserves and coercion erasure although we have not proved it f and f should be the same up to their representation of coercions unfortunately typechecking in f is more involved than in f as we need to typecheck coercions as binding expressions the reason is that coercions are not exactly expressions having coercions as expressions would require an even more type system as it would have to ensure that coercions are which means maintaining a stack of the currently expanded variables to remember closing them for example consider typechecking the context x x that term abstraction and type abstraction known as distributivity when typechecking the subterm x we must verify that it is the body of an expansion with the variable x we initially followed this approach and it was moreover it did not scale to products as the type system must also ensure that two trees have the same coercion erasure instead we make the expansion of a term m an atomic construct namely g m g where s stand for hole variables this can be interpreted as x gm gx which is the expansion of m ie xm x using coercion g interpreted as g around the argument and coercion g interpreted as g around the result here g may bind coercion or hole variables that are used inside m and g hence the type system must keep track of those variables with their types when type m c m c m m g m g g dist dist c g c g gg g g c c bounds types expressions coercions environments figure parametric f syntax restriction wrt f checking g and extend the typing environment accordingly when typechecking m and g we presented f rather than its more intuitive version f to avoid the additional complexity in the type system moreover it is not obvious how to extend f with as discussed in § parametric f parametric f written fp restricts the language so as to rule out configurations by means of typechecking the restriction is on the type of coercion abstractions c m ie on the type of coercion variables observe that a coercion variable appearing in a position c x m n has a coercion type where and are both arrow types to prevent this situation from in fp we require that either the domain or the codomain of the type of a coercion parameter be a variable hence we only allow c m or c m in order to preserve this invariant by reduction we must request the type variable to be introduced simultaneously so we may write c m but not c m alone this is a form of parametricity since either the domain or the codomain of c must be treated abstractly and thus not as an arrow type in m to enforce this restriction we a type abstraction to every coercion abstraction and see c m as a single syntactic node which we write c m to avoid confusion although we modify the syntax of source terms fp can still be understood as a syntactic restriction of f syntax changes the syntax of parametric f is defined on figure as a to the syntax of f we write for removal of a previous grammar form we replace coercion abstraction c m of f by two new constructs c m and c m to mean c m and c m but atomically for we introduce a mode that ranges over and hence we write c m for either c m or c m note that the type variable is bounded in both and m as a device we can read the type of the coercion variable by moving c in front ie c becomes c while c becomes c which can also be read c the reason to keep the type variable before the coercion variable is to preserve the order of the abstractions in f we say that c m and c m are negative and positive coercion abstractions respectively the positive form is parametric on the codomain of the coercion and implements a lower bounded quantification as in the negative form is parametric on the domain of the coercion and implements an upper bounded quantification as in f with the definition of fp we replace coercion application m g by m g to perform type and coercion applications m g atomically both positive and negative versions p pg p g dist p dist p dist c p dist v c v c v c p values p c c g g contexts figure parametric f changes in values wrt f have the same meaning but different typing rules type appears before g to that the type application is performed before the coercion application in the expanded form as a device the is oriented towards the side of the variable it in the coercion type of m hence if m is c n we must write m g we must change types accordingly replacing coercion types by which factors the two forms and whose in f are and respectively typing environments are modified accordingly notice that c stands for c c should be read as c and therefore may appear free in as for coercion abstractions this allows the encoding of recursively defined bounds discussed below in the syntax of coercions we replace coercion abstractions and coercion applications as we did for expressions we also change the distributivity coercion that term abstraction with coercion abstraction to reflect the change in coercion types it must simultaneously the term abstraction with the type abstraction and coercion abstraction that are stuck together to the semantics the syntactic changes imply corresponding to the semantics of the language notice that all restrictions are captured syntactically so no further restriction of typing rules is necessary typing rules consistently with the change of syntax we replace the typing rules and by rules and given on figure the corresponding typing rules and for coercions are changed similarly we also replace by finally the modified distributivity coercion is typed as described by rule notice that is a metavariable as m or and different occurrences of the same metavariable can only be instantiated simultaneously all by or all by we use different metavariables and when we mean to instantiate them independently the new typing rules for fp are derived from the typing rules of the corresponding nodes in f for example is the combination of rules and in f wellformedness judgments are in the obvious way details can be found in the extended version operational semantics the operational semantics is modified in the obvious way the syntax of values for fp is defined on figure as a modification of the syntax of f the in the reduction rules are the replacement of by by and the change of contexts that induces a change in as described in figure properties since fp can be seen as a restriction of f where coercion abstraction is always by a type abstraction some properties of c m c m m g m g ok c c c g c g g g g g dist figure parametric f typing rules wrt f c m g m c g dist c x m x c m figure parametric f new reduction rules wrt f fp can be derived from those of f in particular normalization and subject reduction properties are preserved just by observing that fp is syntactically closed by reduction proposition preservation if m and m n hold then n holds confluence and progress must still be verified for confluence we observe that there are still no critical pairs although this does not follow from the absence of critical pairs in f so weak confluence is still preserved and confluence comes as a corollary progress is a proof on its own but it is similar to the one in f proposition progress if m holds then either m is a value or m reduces as expected coercions are in fp because the new reduction rules are a combination of two rules and are themselves rules the forward simulation follows from forward simulation in f it remains to check the backward simulation proposition backward simulation if m and m m then m n such that n m the proof schema is not original and we assume that m reduces to m and show that the of m reduces to n with n equal to m since f strongly we may assume without lost of generality that m is already in normal form because m reduces we can use the reduction derivation to show that it must be of the form m by inversion of the function we show that m is of the form m m where c is a reduction context and q a context of arbitrary depth such that c m and m erase to c m and m respectively we show that if a normal term of the form qx m has an arrow type then q is empty hence m is of the form cx m m and reduces to m whose erasure is m expressiveness of parametric f although it is fp is already an interesting in the design space as it subsumes in a unified framework three known languages f and f in fact its more expressive version with fbounded polymorphism et al by construction f is included and simulated in parametric f in the rest of this section we show that and f are also subsumed by fp in each case we exhibit a translation of typing judgments from the source language to typing judgments of fp so that the coercion erasure of the translation of a source term is equal to the type erasure of this term and therefore the translation is semantics preserving to avoid confusion between source and target terms we write t or s for terms a or b for types and for typing environments in the source language formally we exhibit a translation of judgments t a m that is welldefined type preserving and semantics preserving that is if t a then t a m holds for some m and such that m and t m as a consequence reduction in the source language terminates since it is simulated in fp bounded polymorphism f is a wellknown extension of system f with subtyping there are several variations on f all sharing the same features but with different expressiveness due to the way they deal with subtyping of bounded quantification bounded quantification a b restricts types a that ranges over to be subtypes of the bound a the differences lie in when the subtyping judgment a b a b holds different versions of the corresponding subtyping rule are given on figure in kernel f the bounds a and a must be equal whereas full f only requires the bound a to be a subtype of the bound a moreover cannot appear free in the bounds a or a in kernel or full f while allows this form of recursion called fbounded polymorphism the most general assumption a a is that of perhaps surprisingly this is a slightly more general rule et al than the more intuitive one a a a in summary we have kernel f full f where all are strict we show that the most expressive version is included into fp the translation of typing judgments uses auxiliary translations of subtyping judgments a b g and wellformedness judgments bounded polymorphism a b is translated into a negative coercion abstraction which encodes upper bounds positive coercion abstraction encodes lower bounds and are never needed in the translation of translation of expressions is easy for example the translation of a type application is a coercion application as follows t b b m a b a g t a b a m g the most involved part in the translation is for subtyping judgments in particular for the case a a c g a b b c g a b a b c g g let us check that the judgment returned by the conclusion holds under the assumptions returned by the premises and the a b b a b a b a a a b b a b a b fbounded a a a b b a b a b figure bounded polymorphism variants on the subtyping rule implicit of the hole in the conclusion is the domain of the coercion say in environment c the coercion g has type by rule and since g to the coercion g g has type hence by rule the coercion of the conclusion has type as expected notice that is missing type abstraction and type application in coercions as well as distributivity of the universal on the arrow as in f indeed only allows instantiation of quantifiers at the root of types as in system f and contrary to f hence the inclusion fp is strict it is that fp naturally matches the most expressive version this following a systematic approach and type conversions as coercions as in fp rather then a limited subtyping relation additionally fp may simplify the proof of type soundness for as coercions are explicit polymorphism the language and is the internal language of mlf which is itself an extension of system f with polymorphism is a mechanism to delay type instantiation of system f it is a key to performing type inference in mlf and keeping principal optional type an notations of function parameters as our current concern is not type inference but expressiveness we use rather than mlf for comparison with fp by lack of space we cannot formally present instead we identify a subset fx of fp and explains how it closely relates to without giving all the details of which can be found in the extended version we first define the subset of fp by removing negative abstractions in types terms and coercions arrow coercions g g and distributivity coercions from the syntax of terms of course we remove typing rules and reduction rules for these con accordingly we then define fx as the restriction of where a type variable cannot appear in its instance bound ie is not free in in both restrictions are closed by reduction so they preserve the properties of fp we claim that is equivalent to fx the translation of polymorphism ab is a positive coercion abstraction where and are the translation of a and b the translation of expressions and type instantiations is then routine see the extended version the proof for the direct inclusion is similar to one by and the proof for the reverse inclusion is new but not much more difficult in summary we have fx fp it is inter that the natural restriction of f that allows variables to appear in their instance bounds much as with fbounded polymorphism this suggests an extension to with recursively defined bounds however we do not know whether this extension could still permit partial type inference in mlf moreover reduction in is simulated in fx this implies termination of reduction in a result already proved by and summary features of fp and its variants are up on figure the expressiveness of f and f can be compared by checking which feature is present in one language and not in the others deep instantiation corresponds to the g and g con extension of system f deep instantiation arrow congruence permutation of and upper bounds lower bounds f f fp figure language and feature comparison allowed in f and but not in f upper bounds are used in f and lower bounds are used they correspond to coercion abstraction c g and g g when is or respectively f allows neither arrow congruence is the g g construct allowed in f and f distributivity dist is used in f the other form dist is only used in fp since it involves coercion abstraction notice that and f only have coercion abstraction in common but with opposite each of them share a different feature with f none of them uses distributivity as it only makes sense when deep instantiation and arrow congruence are available simultaneously all examples of § are actually typable in some syntactic of course for instance the last example becomes c ch choose of type ch for instance it can be to the type plus this uses the coercion c plus c ch int weak f another solution to recover is to prevent from appearing in a reduction context at first it seems to suffice to use weak reduction on coercion abstraction indeed if a coercion variable cannot appear under a reduction context it cannot appear in a configuration however since c m is irreducible its erasure m should also be irreducible ie a value if we choose strong reduction for term abstraction we must also choose strong reduction in the calculus used as the target hence m must be a value for strong reduction that is c m would only be allowed when m is fully evaluated which would considerably limit the interest of abstracting over c therefore we choose a weak strategy for both coercions and terms keeping strong reduction on types is optional and independent the syntax of weak f written fw is defined on figure as a restriction of the syntax of f we replace c m in terms by c u where u is a value form a value form is a term that to a value ie a value or an application of a coercion g to a value form a value is any form of abstraction whose subterm is an arbitrary term for a term abstraction a value for a type abstraction because we may evaluate under type abstractions or a value form for a coercion abstraction the static semantics of fw and f are the same the reduction relation of fw is a of the reduction relation of f that prevents evaluation under term and coercion abstractions and preserves the value restriction reduction contexts are modified accordingly x and c are removed rule the coercion abstraction part of is m c m c u g dist v x m v c u top v u v g u expressions coercions values value forms c m m g g reduction ctx c g u c g u figure weak f syntax and semantics wrt f restricted to make it callbyvalue indeed keeping the f rule c g m c g m would place the arbitrary term m under a coercion abstraction it is routine to check that fw is wellbehaved and that coercions are we refer the reader to the extended version related work although many type systems could be explained using coercions since for instance they use a form of subtyping very few have followed this path and made the connection with coercions explicit we have already widely discussed f f and parts of fx is closely related to the work of and who proposed the first encoding of in a calculus of coercions but for the main purpose of proving the termination of they exhibit a type and semantics preserving encoding of into their version of fx and show a simulation of computation between their fx and system f unfortunately subject reduction and other properties that depend on it do not hold in their system our version of fx can be seen as a fix to their definition hence there are many between their development of fx and our development of the typing rules differ we omitted the proof of inclusion from into fx by lack of space but also because it in fact their translation of into fx has itself been inspired by the translation of mlf into system f by and and however and restrict their study to the termination of without any interest in f or f while our main interest is not in fx but in fp and f ie a general treatment of abstraction over coercion functions that extends f and as a side result a possible of although f subsumes core f we have not included records in f which are often the first application of f our formalization in the extended version includes tuples and therefore models tuple inclusion we claim that f can model record subtyping as well however our treatment of records in f would be similar to their treatment in f and require an expressive runtime system so that subtyping is record subtyping in f may also be compiled away into records without subtyping in plain system f by inserting coercions with computational content et al that change the representation of records whenever subtyping is used since these coercions are not and can be inserted in different ways the soundness of the approach depends on a coherence result to show that the semantics of the translation does not actually depend on the places where coercions are inserted another method for eliminating subtyping has been used by crary bounded polymorphism is compiled away into an intersection type while intersection types are themselves encoded with explicit coercions this directly relates to our work by their which is similar to our reduction and their use of bisimulation up to tion to show of coercions of course the languages are different as we do not consider intersection types while they do have neither coercion abstraction nor distributivity and only consider callbyvalue reduction their work could serve as a reference to extend f with recursive types languages with dependent types often split terms with and without computational content using kinds so that parts of terms that contribute only to the static semantics can be at runtime this is more powerful than our notion of coercions for instance it could allow to build coercions by feature that we would like to have however we do not know whether this approach could be applied and benefit to our extension of f coercions introduced in fc weirich et al the internal language of haskell are interesting because they use coercion projections and cannot be expressed in f although fc uses a weak evaluation strategy it can declare abstract coercions at the toplevel which amount to a form of coercion they need coercion projections to however coercions in fc are do not have distributivity nor deep instantiation of quantifiers and are thus structural which allows for an easier setting and a simple criteria to be used for consistency checking a new version of fc and jones makes coercions firstclass values in an otherwise comparable setting coercions can be abstracted over as in f and also stored in datastructures however as a result of being firstclass coercions may change the termination hence the semantics of programs and are not in our terminology the two languages f and fc follow orthogonal approaches and are thus not easily comparable combining the features of both would be an interesting challenge adding coercion projections to f and taking distributivity away we could obtain a version much closer to fc but where coercions are oriented surprisingly few works have consider distributivity and include the power of f apart from theoretical papers on f itself functions can also be seen as a way of typing derivations abstraction over coercions is then abstraction over type derivation transformations there might be interesting connections to establish with expansion variables for quantifiers introduced by and discussion and future work the language f extends f with abstraction over coercion functions in a general way where coercions are functions ie certain terms of the calculus that do not contribute but may block the evaluation in order to solve this problem and make coercions we have proposed two restrictions of f weak f restricts the reduction relation by choosing a weak evaluation strategy for both coercions and terms and restrict coercion abstraction to value forms the main advantage of this solution is its simplicity and its generality still the restriction of coercion abstractions to value forms which is analogous to polymorphism in languages with side effects is significant moreover it allows the abstraction over coercions of coercion types which are never applicable thus leaving the possibility of code hidden under coercion abstraction or at least delaying its detection instead fp restricts the types of coercion parameters and forces them to be polymorphic in either their domain or codomain the advantage of fp is to retain a strong reduction relation which shows that the calculus is really wellbehaved although restrictive it already subsumes f and f we believe it is an interesting point in the design space it also shows that an extension of with subtyping would be possible and even if the question of designing the surface language to make type inference possible remains open still as both solutions are significant and orthogonal restrictions to f we may explore other possibilities fp fp so that it could type more expressions but still prevent from being typable is probably the extension to this work an obvious but minor generalization is to let c¯ ¯ m abstract over several coercions simultaneously but all with the same polarity allowing multiple cannot come without further restrictions as transitivity could then be used to build an abstract coercion between arrow types a more generalization is to replace the local constraint on the type of coercions by a global constraint defined by some auxiliary consistency judgment we could allow abstractions of the form ¯ c¯ ¯ ¯ m using a side condition on the typing rule to ensure that the combination of coercions in context still prevents the creation of however finding a suitable notion of consistency in the presence of distributivity is challenging beyond f so far we have explored restrictions of f to prevent from appearing in a reduction context instead we could perhaps extend the calculus to allow them apart observe that when a coercion variable appears in a it is always a coercion between arrow types and that any actual coercion that will be passed at runtime will start with an arrow coercion g g that can be decomposed into g and g and pushed out of the way so we could decompose the abstract coercion as well by introducing coercion projections left g and right g that behaves as g and g whenever g is g g while this idea is intuitively simple it is actually quite involved as new difficulties appear one after the other when solving them due to the presence of distributivity require both binding coercions as in f and independently a notion of structural equivalence to treat coercions up to some unfortunately the combination of both breaks confluence a fix to confluence is to reduce coercions themselves which introduces further problems see the extended version for more details moreover even assuming that such a calculus can be set up there will remain to solve a typechecking problem quite similar to although more flexible than the one for fp with nonlocal consistency indeed coercions cannot ensure reduction may either get stuck being unsound or loop forever we leave this exploration for future work leaving f and quantifiers we have added coercion abstraction to the language f as it is the reference in the absence of abstraction however many of the difficulties in f come from the distributivity rules which allow coercions to move quantifiers inside types or more precisely from the combination of distributivity with of the arrow is already the source of difficulties in f including undecidability of this suggests exploring a restriction of f that does not have distributivity nor type abstraction and type application of coercions that would not extend f but have a much simpler metatheory language extensions several features of programming languages have also been left out of f although products are not included in this short presentation we have already verified that they can easily be added labeled products should work as well we do not expect difficulties with tagged unions or types eg following crary although details are subtle and still need to be checked we dont any difficulties for adding fix points to the source language some care is needed for existential types which already raise a problem in system f as they do not have an semantics with a strong evaluation strategy therefore we left them out of f and replaced them by a top type this is however an orthogonal issue an interesting extension is to make coercion firstclass objects which raises another challenge for since coercions can then be built by computation should a computation that just builds coercions be as well coercion types are monomorphic in f but between possibly polymorphic types we do not expect difficulties to have polymorphic coercion types firstclass coercions would naturally bring polymorphic coercion types we have studied coercions for secondorder polymorphism we should not expect difficulties with higherorder polymorphism however adding coercions to a language with dependent types may be more challenging references p g and a basic theory of fbounded quantification inf comput ­ september url http v t coquand c and a inheritance as implicit coercion information and computation ­ p w cook w hill w and j c mitchell fbounded polymorphism for objectoriented programming in url l cardelli an implementation of research report digital corporation systems research center url http k crary typed compilation of subtyping in icfp url k crary s weirich and j g morrisett intensional polymorphism in semantics journal of functional programming ­ url d le and d mlf information and computation url d a type directed translation of mlf to system f in icfp oct url d and a qualified types for mlf in icfp sept url s and j b expansion for available url g and p mlf with the power of system f in volume doi j c mitchell polymorphic type inference and containment information and computation d and b a intermediate language for mlf in volume pages ­ url http d and s p jones practical aspects of compilation in system fc available url s weirich d s peyton jones and s generative type abstraction and typelevel computation in popl url 