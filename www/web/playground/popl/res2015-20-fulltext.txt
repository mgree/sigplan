analyzing program analyses di informatica university of italy microsoft research wa usa di university of italy to cousot abstract we want to prove that a static analysis of a given program is complete namely no arises when some query on the program behavior in the concrete ie for its concrete semantics or in the abstract ie for its abstract interpretation completeness proofs are therefore useful to assign to alarms raised by static analyses we introduce the completeness class of an abstraction as the set of all programs for which the abstraction is complete our first result shows that for any nontrivial abstraction its completeness class is not recursively enumerable we then introduce a stratified deductive system a to prove the completeness of program analyses over an abstract domain a we prove the soundness of the deductive system we observe that the only sources of incompleteness are assignments and boolean tests a common in static analysis joins do not induce incompleteness the first layer of this proof system is generic and it deals with the standard constructs for program composition that is sequential composition branching and guarded iteration the second layer is instead the designer of an abstract domain a provides conditions for completeness in a of assignments and boolean tests which have to be checked by a suitable static analysis or assumed in the completeness proof as hypotheses we instantiate the second layer of this proof system first with a generic abstraction in order to provide a sound rule for the completeness of assignments we instantiate it to the numerical abstract domains of intervals and providing necessary and sufficient conditions for the completeness of their boolean tests and of assignments for categories and subject descriptors d software engineering proofs formal methods d programming languages formal definitions and f logics and meanings of programs semantics of programming analysis general terms languages keywords abstract interpretation abstract domain permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm introduction consider the typical process by alice the designer of a new static analysis a alice starts with a set of representative programs and properties to be checked eg the absence of certain runtime errors or of infinite computations she designs the static the abstract best her initial next she will try the analysis a on a new set of programs validate the results and carefully refine the abstract domain or improve the efficiency as needed when a becomes precise and fast enough it is to external users a major part of the design of a is the of the analysis should the expected answer on a set t of test programs without too many computational time space resources to achieve it alice gives up some of the precision ie she introduces incompleteness into a the for this design choice is that t represents realworld programs and as such she needs a to be complete for them we denote this set of programs with ca where a is the abstraction or a set of abstractions employed by the static analysis a on the other hand the incompleteness of the analysis will only manifest in less common or programs given a program p alice wants to know whether p is in ca or not in fact if p ca then the analysis will be precise and it will answer exactly to any query q on the behaviour of p which is expressible in the language of a as a consequence any raised by the static analysis a on p will be a true and a can then be used as an effective program verifier for p the problem we are interested in proving that p ca for instance let us consider the basic abstract domain null null for analysis of variables the nonnull analysis will infer that for the very simple program nn in figure x is not null after the the true branch is taken x is null but it is assigned a allocated memory location otherwise x maintains its nonnull value intuitively nn both the boolean guard x null and its negation x null are exactly representable in null new is complete wrt we do not know what happens to the heap abstraction but we know for sure it returns a nonnull value complete abstraction skip does not affect the current state and eventually the join does not introduce next let us consider the program dec in figure let us assume to analyze it using the abstract domain of intervals int without loop unrolling and this case the number of abstract iterations is finite the analysis will report that x at the loop exit which is the most precise answer why is this the case at first one may argue that since the inferred invariant is a singleton it is necessarily the most precise one however this way of reasoning is incorrect in general for instance a program point may be unreachable so that the concrete set of states at that point is if x null x new object else skip query x null figure the program nn an example where the abstraction is complete x y while x x x y y query y figure the program an example where intervals are incomplete whereas are complete x while x x x query x figure the program dec an example where intervals are complete but the proof is not trivial x while x x x query x figure the program dec an example where intervals are incomplete and a proof system may deduce the opposite and for any abstraction a every abstract value different from the bottom value a will be correct yet incomplete also one could reason as follows the assignment x with a constant is precise with intervals both boolean guards x and x can be exactly represented with intervals resp by and the operation x x on intervals is precise eg therefore one may conclude that this is why the analysis of dec with intervals is complete however this way of reasoning is wrong consider the program dec in figure in its concrete semantics at the loop exit point we have that x whereas in its analysis with int the most precise invariant we can obtain even without is x therefore dec by contrast here the same intuitive argument as for the dec program still holds assignment x is precise with int both x and x can be exactly represented with int the x x on intervals is precise eg where is the problem with the above reasoning it turns out that even if the guard x can be exactly represented with intervals its transfer function x z z is not complete with respect to int to give an example let us consider the set of concrete values s which is the set of values of x computed by the of dec hence if the input to x is s then we obtain in int s x s int on the other hand if the input to x is instead the abstraction ints then we have ints int that is the transfer function x is not complete on int therefore we cannot use syntactic arguments to prove whether p ca because they may lead to wrong conclusions our solution as a first step one may think to design a deductive system for proving that a program p is complete for an abstraction a which requires that all the assignments and boolean guards of p are complete for a such a deductive system will be sound but definitely too strong for instance we cannot use it to prove that the analysis of very simple programs as dec in figure is complete this deductive system can deduce completeness of nn in figure though instead we propose a layered proof system for completeness roughly the layered proof system pushes the completeness proof of the analysis from the program statements up to the assignments and boolean guards and then it may use a further analysis to prove their completeness for instance in the example of figure the analysis of the program dec is complete if both the initialization and the while loop are complete the analysis of the initialization x is trivially complete for intervals the analysis of the while loop is complete if the analysis of the boolean guard of its negation and of the body are with a little bit of effort we can prove that the analysis of the body x x is complete for intervals the problem comes with the boolean guards x and x we observed before that in general intervals are not complete for those guards we will show that incompleteness happens when there is a hole in the concrete set of values and the boolean guard among those in fact in our counterexample above s has a hole between and and the guard in the program dec there is no such a hole because the variable x assumes in the concrete all the values between and thus the analysis of the boolean tests of dec with intervals is complete we can use a static analysis to prove this and to conclude that the interval analysis of dec is complete we should be careful in defining what holes are consider the program in figure here both x and y uniformly assume all the values between and and at the end of the loop we have that x and y however the analysis of with intervals will determine at best that y once again the source of incompleteness is the boolean guard in fact the transfer function of x which is the negation of the guard x is not complete for intervals with the set of input pairs x y of concrete values s it is worth that this incompleteness does not from a in the abstract join of intervals in fact the abstract lub a of any abstraction a is always complete meaning that x y x a y always abstraction functions in galois connections always preserve joins on the other hand using the abstract domain of the guard x and its negation x are instead complete for the input set s a further issue arises with assignments for relational abstractions as it turns out that assignments like z x y and x y are incomplete even if x y and y are complete considered as numerical expressions indeed we will show that the only assignments which are complete for have the following shape x a y k and x a x k for a and k z given an abstraction it is therefore natural to ask i which conditions on expressions and their input concrete states ensure completeness of the analysis and ii how to statically check these conditions so that the we can prove that the analysis is complete we will address these issues in the article this work from our experience in building real analyses we want to be able to prove that the static analysis on a given abstraction in some cases will infer an invariant which is complete and therefore use this information for ranking alarms from analyses that cannot be proved complete should be lower therefore we a new methodology for designing static analyses in addition to the main static analysis for property checking alice also provides one or more completeness conditions to be used to validate the completeness of the analysis for a given program our goal is because as we will see in the paper a proof of completeness relies upon the determination of the best correct approximation for all the statements occurring in the program while this requirement can be for the fundamental constructs for program is sequential composition branching and guarded iteration for the latter two by requiring completeness of their boolean generic assignments this is still an open problem as there exist relational abstract domains where the best correct approximation of the assignment for certain expressions is not known yet results we recall the necessary basic notions of abstract interpretation and completeness of abstract domains section and we define the syntax concrete semantics and abstract semantics for a basic imperative language section we introduce the notion of completeness class for an abstraction a as the set of programs for which the analysis over a is complete we show that for all nontrivial abstractions the corresponding completeness class is infinite nontrivial and in particular it is a set namely it shares the same structure of the of true in first order therefore incompleteness section we provide the core proof system for completeness we prove that it is sound for all abstract domains and argue that completeness of boolean guards can be regarded as the part in these completeness proofs section we then analyze the soundness of the proof system for relational abstractions in particular for the case of we introduce a further layer in the proof system to prove completeness of assignments and boolean guards we instantiate it with the interval and abstractions we characterize the assignments which are complete for we provide necessary and sufficient conditions for the completeness of intervals and when handling boolean guards section we conclude by comparing our work to previous one section and by discussing other possible applications of completeness proofs section background orders given a function f x y and a subset s x then f s f s y s s denotes the image of f on s a complete lattice c wrt an ordering relation is denoted by c the pointwise ordering relation between two functions f g x c whose codomain is a complete lattice c is defined by f g if for any x x f x c gx a function f c d between complete lattices is additive when f preserves arbitrary while it is continuous when f preserves of chains given a function f c c on a complete lattice c and denote respectively the least and greatest fixpoints of f when they exist recall that least and greatest fixpoints always exist for monotone functions abstract domains in standard abstract interpretation abstract domains also called abstractions are specified by galois for short concrete and abstract domains c c and a a are assumed to be complete lattices which are related by abstraction and concretization maps c a and a c that give rise to a gc c a that is for all a a and c c c a a c c a a gc is a gi when xx we use to denote all the possible abstractions of c a means that a is an abstract domain of c specified by some while the notations a and a are used to emphasize the underlying abstraction and concretization functions and if c a is additive then we obtain a gc c a by considering its a c c c c a a if c a is then c a is a gc where c a a a c c a is the of we recall well known properties of a gc c a is additive is c c is a closure operator ie it is monotone idempotent and increasing ie x x if µ c c is a closure operator then µ c id is a gi if a a then a is equivalent to a denoted a a when a a a a the is called the lattice of abstractions because it turns out to be a complete lattice wrt the relative precision ordering a a iff for any c c a a c c a a c a a means that a is a more precise abstraction of the concrete domain c than a or equivalently that a abstracts a a lub in the lattice of abstractions is therefore the most precise domain in which abstracts all the is the most abstract ie less precise domain in which is more precise than all and is also called reduced product of the intervals the interval abstraction was introduced by cousot and cousot and it is still a widely used abstraction since it is efficient and yet able to give useful information to prove eg the absence of arithmetic or array accesses let z z and assume that the standard ordering on z is extended to z in the usual way hence int a b a b z a b with the standard ordering int induced by interval gives rise to a complete lattice where is the bottom element and is the top element then consider the function min z z defined as follows min x x if x x y x x y otherwise while max z z is defined the abstraction map z int defined by x if x max x if x preserves arbitrary unions in z and therefore gives rise to a gi ie int abs z it is straightforward to define the lift of intervals to with n if x zn is a vector of integers and i n then xi z denotes the ith component of x in turn if x zn is a set of vectors then xi xi z x z denotes the ith projection of x then the interval abstraction is n int with the ordering of int the following abstraction map zn defined as x yields an abstract domain abs zn the abstract domain is a relational refinement of the interval abstraction which is able to represent vari able relations of the form ± x ± y k while keeping an acceptable efficiency by exploiting a representation based on a modification of socalled difference bound matrices the terminology comes from the fact that in two dimensions an abstract element is a polyhedron with at most sides given n a difference bound matrix m is a n × n square matrix having entries z then any m induces according to the canonical representation described in a zn defined as follows x xn n z i j n xi xj xi xj xi xj xi xj observe that interval bounds like xi a and xi b can be encoded respectively by a and b so that a interval is a particular let us also recall that representations are not unique so that it can happen that for different m m we have that the abstract domain is defined to be zn m and turns out to be a complete lattice wrt the subset relation observe that are closed under arbitrary set intersections but not under set unions so that is a complete lattice which is not a join of zn zn is the abstraction given by x o x o it is well defined and being a closure operator it is additive so that it yields a gi namely we have that abs zn clearly are a refinement of intervals ie correctness let f c c be some concrete monotone keep notation simple we consider functions and let f a a be a corresponding monotone abstract function defined on some abstraction a then f is a correct or sound abstract interpretation of f on a when f f holds if f is correct for f then we also have fixpoint correctness that is a the abstract function f f a a is called the best correct approximation of f on a because any abstract function f is correct iff f f hence f plays the role of the best possible approximation of f on the abstraction a completeness an abstract function f is a complete abstract interpretation of f on a when f f holds when f is an abstract transfer function on the abstraction a used by a static analysis completeness intuitively encodes the greatest precision for f meaning that the abstract behaviour of f on a exactly matches the abstraction in a of the concrete behaviour of f if f is complete for f then we have fixpoint completeness also called fixpoint transfer it turns out that completeness f f holds iff f f thus the possibility of defining a complete approximation f of f on some a only depends on the concrete function f and on the abstraction a we will use both a is complete for f and f is complete on a to refer to the completeness equation f f the problem of making abstract domains complete has been addressed in a constructive characterization of the most abstract refinement called complete and of the most concrete simplification called complete core of any abstract domain a making it complete for a given continuous function f c c is given as a fixpoint solution of an abstract domain equation derived from f and a let us recall this definition for the case of the complete refinement this is the abstract domain refinement defined as a a rf x where for any domain x rf x is the most abstract domain which contains the maximal inverse image of f on x namely rf x yx c f c y as a consequence the following characterization of complete abstract domains holds the abstraction a is complete for f iff for any y a c f c y a language and abstract semantics syntax we consider a basic deterministic imp with arithmetic and boolean expressions as defined eg in whose syntax is as follows a v z x var a a a a a a b t f a a a a b b ¬b imp c skip x a c c if b then c while b do c programs are commands in imp the set of variables occurring in some syntactic object is var concrete semantics we let s var z denote the set of program stores we will often represent a store s as a tuple the semantics of arithmetic expressions is the function a s z defined as usual similarly the semantics of boolean predicates is the function b s t f the collecting semantics of an arithmetic expression a is the function a s z defined as a s a s similarly the collecting semantics of a predicate b is the function b s s defined as b s s b t intuitively b s filters the concrete states of s which make b true the collecting denotational semantics of a command c is the function c s s defined as skip s s x a s x a s c c s if b then c s c c s c b s ¬b s while b do c s ¬b s c b t observe that nontermination is encoded by the empty set a program c imp does not terminate on an input s s when c s in the following we make the hypothesis that the inputs to semantic functions ie the sets of stores in s are recursively enumerable sets store abstractions a store abstraction is specified by a gc a abs s on sets of stores variable projection existential abstraction of a set of stores on a set of variables v var is defined by the following mapping v s s v s s sy v y y variable projection on a single variable x var is denoted by x we will consider store abstractions with a complete variable projection namely an abstract domain a such that for any v var v v completeness of variable projection is satisfied by any store abstraction used in practice eg this property holds for all known and relational numerical store abstractions like sign int oct domain of linear equalities etc any store abstraction a which is complete for variable easy formalization of variable renaming is omitted here can be also viewed as an abstraction of sets of integer values in z by considering stores that focus on a single variable call it y this is determined by the abstraction map z z a defined as zz s y z hence in the following the store abstraction a is also viewed and used as an abstraction of sets of integers abstract semantics we define the best correct abstract semantics for a generic store abstraction a abs s we assume that is the join in a the best correct abstract semantics a a a for an arithmetic expression a is a s a s it is worth noting that in general the best correct abstract semantics is not the standard compositional definition · c of the abstract semantics of expressions for instance the compositional definition of a binary integer operation op is a c s a c s op a c s when instantiating such a definition for the intervals int it turns out that x x int x x x x the best correct abstract semantics for a predicate b on a is the abstract function b a a defined as b s b s we derive the best correct abstract semantics c a a of a program c imp as the best correct approximation of its concrete semantics we exploit two wellknown facts i the composition of two complete functions is complete and ii in a gc the abstract join is always the best correct approximation of the concrete join let s a be an abstract store skip s x a s s x a s c c s if b then c s while b do c s c c s ¬b s c b s ¬b s c b x let us comment on the definition i the best correct approximation of an assignment x a does not rely on the best correct abstract semantics a of the arithmetic expression a ii in the least fixpoint definition for while b do c the abstract function x s c b x turns out to be the best correct on a of the concrete function t s c b t iii in the abstract function x s c b x practical static replace the abstract lub with a widening operator to or force the convergence of the iterations in the abstract domain a thus the property of having the best correct abstract semantics of programs complete abstractions a store abstraction a is complete for an arithmetic expression a a boolean test b and a program c imp when for any set of stores s s a s a s b s b s c s c s the class of complete abstractions completeness queries and alarms the goal of a static tool is to soundly answer some questions on the dynamic concrete execution of programs for instance common queries to static analysis tools are is this variable is this variable nonnegative does this loop ever terminate the first two are examples of safety properties the third of a liveness property here we focus on safety properties given a program p a set of input stores i s and a store query ie a store predicate q we are interested to know whether the final states of p satisfy the query q ie whether the following formula holds s p i q true or equivalently by denoting with q s the stores satisfying q whether p i q obviously we cannot decide this for each possible query therefore static analyses the collecting semantics p and the query q in general the abstractions used for these two approximations may be instance this happens when a numerical abstract domain like intervals or is used to infer variable bounds and a smt solver is used to check the absence of buffer we are interested in the case where there is no underapproximation of the query that is we require i the two abstract domains to coincide and ii the query q to be exactly represented in this abstract domain namely q q for instance a query like x y y is exactly represented with but not with best approximation with intervals being x y the key observation is that if a program query q is exactly representable in a store abstraction a and the abstract semantics on a for a program p is complete then the query q in the abstract is the same as q in the concrete ie no in q for p is introduced by the abstraction a thus completeness of a static analysis of p implies that no false can arise for queries which are representable in a this is summarized by the following lemma which comes straight from the definitions if q q a is the abstraction of q q is representable in a when q q lemma if a is complete for p and q is representable in a then for any i s p i q p i a q proof let a be complete for p and q be representable in a by monotonicity of from p i q we obtain by using the completeness and hypotheses p i p i a q q q since p is always correct we have that p i a q p i a q thus by applying to both sides of the inequality we obtain p i p i q q note that the proof of p i a q p i q does not make use of the completeness hypothesis since this implication is a straight consequence of the soundness of the best correct approximation p on the other hand completeness is crucial for proving the reverse implication completeness can be therefore read as follows if a complete static analysis of p raises an in a representable query q then this is real p i a q p i q example consider the program in figure and the final query q y which is representable by the intervals x y and therefore by an as well the static analysis of on int raises an for q meaning that int int x y int y however since int is not complete for lemma does not allow us to conclude that this is a false on the other hand the static analysis on oct also raises an for q because oct oct x y oct y and in this case lemma tells us that this is a real classes of completeness from lemma it is therefore natural to reason on the precision of an abstraction a in terms of the set of programs that are complete for the program properties represented by a this is the class of programs which represents at best and uniquely the potential of an abstract domain in questions on their behavior we therefore introduce the notion of completeness class as a mapping from abstract domains to sets of programs those for which the abstraction is complete an analogous completeness class is defined for arithmetic expressions and boolean predicates definition completeness class given a its completeness class ca for commands is defined as ca p imp p p similarly the completeness classes of a for arithmetic boolean and generic expressions are aa a a a ba b b b roughly the completeness class ca is defined to be the set of all programs whose static analysis on a given abstraction a will never produce false alarms for queries representable in a this is therefore a property of programs with respect to a fixed abstraction it is worth noting that this property is infinite and cf it is infinite because for any abstract domain a whose abstraction function is computable we have that ca this is shown by a straightforward argument by observing that skip ca for any a and because sequential composition of complete commands is still complete it is also ie it is not an index set for partial recursive functions because there always exist programs p and q such that p is complete for a p q and q is not complete for a this is known in static analysis where semantics preserving program transformations may lose precision of analyses eg see example consider the abstract domain for sign analysis of integer variables sign z which is a straightforward abstraction of z we consider the standard lifting of sign to a store abstraction in abs s consider the following two programs p y z x y z q y z x y z y obviously we have that p q however since sign is complete for multiplication and incomplete for addition it turns out that x y z sign xz y z x y z x y z y sign xz y z xz y z so that p sign x y z q sign xz y z thus p while q it turns out that the relative precision of abstract domains encoded by the ordering on the lattice of the corresponding classes of completeness are not related in particular it may well happen that for an abstraction a which is complete for a given p a generic refinement of a ie a turns out to be instead incomplete for the same program p this is well known in static program analysis and it corresponds to the fact that abstractions may induce a complete static analysis for some program where more precise ones instead fail for that same program in the following we assume that the set s of all stores is infinite if we consider a trivial store abstraction ie there is no abstraction at all or any set of stores is abstracted into a single top value corresponding to the dont know answer then the corresponding completeness class turns out to be the whole set of programs imp let id denote the trivial identical store abstraction ie for any s id s s and s denote the trivial dont know store abstraction ie for any s ss s also let res denote the set of all recursively enumerable subsets of s let us point out that any static program analysis always relies on recursive namely decidable abstractions a meaning that i for any store s is computable and ii for any s res and s s is decidable theorem if a is recursive then ca imp iff a id s proof the trivial abstractions id and s are complete for any program so that if a id or a s then ca imp assume now that ca imp and a id and a s hence there exists some s res such that s s s since a is a decidable abstraction we have that s and s are recursively enumerable hence there exist programs ps and ps on a single integer variable x such that ps s s and ps s s we pick some b s s and some c s s then let us consider the program associated with the following partial recursive function bc s s x if x s b if x c undefined otherwise observe that if x s then x x since c b then it turns out that s s and s s b moreover since s s s b by gc we obtain that s s b thus we have shown that there exists a set of stores s res such that s s s this means that ca which contradicts the hypothesis that ca imp informally the result above states that for all nontrivial abstractions there exists a program for which the abstraction is incomplete moreover by a straightforward argument any of these programs eg in the proof of theorem can be extended to an infinite set of programs for which the abstraction is incomplete this means that any nontrivial abstraction has an infinite set of programs for which it is incomplete we show that ca and its complement ca for any nontrivial abstraction a are sets recall that a set s is if there exists a general effective method ie a total recursive function which enables us to find for any recursively enumerable subset y x an element note that for generic recursively enumerable sets s and s such that s s the set s s may not be recursively enumerable this means that due to the c s s the program exists but we may not have a constructive computable way for building it the existence of as a mathematical object is enough for the purpose of this proof x x y see it follows that no set can be recursively enumerable this proves that for a nontrivial abstraction a both ca and its complement ca are enumerable sets having a structure which is similar to the set of numbers of true in firstorder theorem if a is nontrivial and recursive then ca and ca are sets proof in the following without loss of generality we assume that programs in imp have a single variable ranging over n so that s n if p is a program and s s we denote by p sn the fact that p terminates with any input in s in less than n steps let g imp n be an enumeration of programs this induces a corresponding enumeration g res n of recursively enumerable sets consider the representation in imp of the halting problem of turing machines cf k p imp n n p gp n we first prove that ca is the proof relies on a many reduction of k to ca denoted by k m ca and means that there exists a total recursive function f imp imp such that x k iff f x ca let a be recursive and nontrivial as in theorem there exists s res such that s s s let b s s c s s and consider the program as in the proof of theorem where we proved that ca since is recursive there exists p imp such that p s by monotonicity of for any x s we have that p x s clearly p ca holds consider the partial recursive function imp × res res p x x if p gp gx p x otherwise since is partial recursive there exists a program r imp such that r p x p x by the theorem there exists a total recursive function f imp × imp imp such that for any p imp and x res we have that f r p x r p x p x consider a generic program p imp if p k then there exists n n such that p gp n let denote the set of all sets of stores for which a is not complete for x res x x p gp gx hence f r p y y for some y s therefore f r p ca if p k then for any n n we have that p gp does not converge in less than n steps therefore for any x res we have that p x p x and therefore f r p p which implies that f r p ca because p imp f r p above is total recursive we have that k m ca which is equivalent to k m ca this proves that ca is see theorem vii § in and theorem in the proof that also ca is is analogous and it is based on a reduction k m ca which exploits the partial recursive function p x p x if p gp gx x otherwise as a consequence neither ca nor its complement ca turn out to be recursively enumerable sets let us notice that the proof of the previous theorem provides a further insight into the structure of ca given a nontrivial and recursive abstraction a it is always possible to systematically and effectively transform any algorithmic procedure to enumerate ca into a program p such that p ca the same holds for ca this can be read as follows the proof that an abstraction is complete or incomplete for a given program ie a static program analysis can produce or cannot produce false impossible the completeness class of an abstraction is therefore a nontrivial property of programs for which no recursively enumerable procedure may exist which is able to enumerate all of its elements in the following we provide recursively enumerable of ca namely systematic and possibly automatic proof systems such that if the proof succeeds for some program p and nontrivial abstraction a then p ca proving completeness of programs given a store abstraction a our goal is to prove whether p ca to this aim we design a layered proof system parametric on the abstraction a the first layer is a compositional proof system a for a generic abstraction a it deals with the fundamental constructs for program composition sequential composition branching and guarded iteration the second layer is instead domainspecific it deals with the completeness of the assignments and of the boolean guards the handling of the assignments depends on whether the store abstraction is relational or not let us remark that the abstract domain a here is fixed an approach based on complete refinements or complete core simplifications of the abstraction a as in section would therefore be orthogonal a complete refinement of a for all the assignments and boolean guards and their occurring in p would generate an abstract domain which is complete for all the programs that can be constructed by combining through sequential compositions conditionals and loops and for all the possible sets of input most practical cases the abstraction a would likely be refined to the concrete domain the core proof system we report in figure the core proof system a for proving the completeness wrt a generic store abstraction a this deductive system is fully compositional on the programs syntax a command is trivially complete for all abstractions skip the rule seq states that the sequential composition of two complete commands is complete too it is worth that the composition of the best correct approximations of two functions f and g in general is not the best correct approximation of their composition f g while this indeed holds when these best correct approximations of f and g are indeed complete the rule if asserts that a conditional statement is complete when its body its boolean guard together with its negation are complete loop statements are handled by the rule while iteration is complete if its body is complete as well as the loop guard and its negation it is worth that the rules for branching and loop commands imply that the abstract join operation never incompleteness in the analysis unlike a common in static program analysis let us show that these rules are sound for proving completeness in a theorem for any a the rules in a are sound proof skip skip ca always holds skip a skip ap aq seq a pq a c b ba ¬b ba if a if b then c figure the core proof system a a c b ba ¬b ba while a while b do c seq if a is complete for c and c then a is complete for c c c c s c c s c c s c c s c c s if if a is complete for b ¬b and c then a is complete for if b then c if b then c s c b s ¬b s c b s ¬b s c b s ¬b s c b s ¬b s if b then c s while if a is complete for b ¬b and c then a is complete for while b do c we first show that ts c b t x s c b x for any t s we have that s c b t s s s c b t c b t c b t so that ts c b x s c b x hence by fixpoint transfer cf section c b t s c b x we therefore obtain while b do c s ¬b c b t ¬b c b t ¬b s c b x while b do c s let us point out that for a boolean guard b in a program p the rules of a require both b and ¬b to be complete on a for any possible set of input stores it is therefore important to remark that boolean guards are a major source of incompleteness even in cases as shown by the following example example let us consider the loop guard in the program dec in figure assume that the body of the while loop x x is complete for the interval abstraction will be formally proved later on the proof of completeness for dec in int would need the hypotheses x and x stating the completeness of the guards of dec however is is not true in general that intervals are complete for a guard like x even if x is exactly representable in int in fact we have that int x int x int int x int therefore x a similar counterexample may show that x let us also observe that even a simple equality test x y between different variables cannot be complete in a relational abstraction such as oct which is able to represent precisely a variable relation like x y it is enough to note that oct x y x y x y oct oct x y oct y x y x y oct x y x y x y a similar example may show that the test x y is not complete for intervals as well although this could be somewhat expected since intervals are not relational proving completeness of assignments assignment commands are not handled by the core proof system a the deductive system a is compositional on programs syn and the problem for assignments from the fact a compositional rule for deriving the completeness of x a from the completeness of the expression a andor x a cannot be sound for a generic abstract domain a this is shown by the following example dealing with the relational abstraction example let var x y z and let us represent a generic store simply by vx vz z we consider the arithmetic expression x y and the abstraction oct it turns out that x y in fact for any nonempty set of stores s s consider the constraint m x y n which is expressed by this means that there exist s such that m x y n x y and for any s m x y n thus oct x y s m n on the other hand since for any m x y n we also have that oct x y m n let us consider now s s and the assignment z x y imp whose concrete semantics on s gives z x y s the abstraction of z x y s in oct is therefore as follows oct z x y s x y z x y x y x z x z y z y z on the abstract side the abstraction of s in oct is as follows x y z x y x y x z x z y z y z here and z x y oct z x y but oct z x y s because the relation x z is not satisfied hence oct z x y s oct z x y namely z x y abstractions an abstraction a is when it does not take into account any relationship between different variables let us formalize this notion for any x var let x¯ var x and let x s a be defined as xs then a is defined to be when s s s xs null sign and int are examples of abstractions while oct is not for a abstraction a we introduce the following compositional rule for assignments a aa a x a we denote by nr a the core proof system a with the rule and we show its soundness for deriving completeness theorem for any abstraction a nr a is sound ie if a p then p ca proof the soundness of the rules in a follows by theorem the soundness of follows from these equalities x a s x x a s y x a s yx x¯ x a s y¯ x a s yx by def of variable projection and z z a s yx by a aa and completeness of y¯ z a s yx by def of variable projection and z x¯ x a s y¯ x a s yx x x a s y x a s yx x a s thus for abstract domains a nr a is a fully com proof system for checking completeness of programs let us give a simple example of derivation in nr a example let us consider the abstract domain null for analysis described in section and the simple program p x if x then x where with a slight of notation we assume that stands for a null reference while for a nonnull reference the proof tree in figure can be derived in nr null and this entails that the abstract semantics of p on the abstraction null is complete let us that the key point in proving the completeness of p is that the abstraction null is complete for the boolean guard x and its negation ¬x nevertheless for the program dec in figure we are still not able to derive that int dec the rule allows us to derive that the assignment x x is complete for int but this is not enough since the boolean guard x is not complete cf example the fact that ca is a set even for nontrivial abstractions implies that an effective complete proof system for deriving completeness of programs cannot be defined the proof system nr a is indeed sound but not complete and the program dec shows this incompleteness relational abstractions as shown in example the completeness of an expression a does not imply that an assignment x a is complete for a relational abstract domain it can be shown that more restrictive hypotheses such as the assumption that x and the completeness of the boolean expression x a on a would imply that x a is complete on a the proof is omitted however this would yield a sound but far too restrictive derivation rule indeed although the syntactic condition x can always be met for any program p simply by replacing an assignment x a where x with the composition x a x x where x is a fresh variable this rule would require the hypothesis x y ba and we observed in example that the equality test is not complete even for most known abstract domains thus for the generic case of a abstraction a it can be argued that a reasonable rule for deriving the completeness of assignments x a from the completeness of some other arithmetic expression andor boolean guard andor command induced by x a simply cannot be found hence a abstraction therefore needs a specific analysis of the completeness of its assignments we present a significant sample of this analysis for the case of the abstraction abstraction in example we have shown that the assignment z x y is not complete for oct a similar example can be found for x x y these observations show that any generic linear assignment x a x an xn is not complete for oct when n the intuitive reason is that for a relation a x y b the substitution of x with a x an xn provides a relation for more than two variables which cannot be represented by oct a this is also true for nonlinear assignments like x y y thus we are left to linear assignments of the following shape x a y k and x a x k if a eg x y the following example shows that as expected we do not have completeness example we follow the notation of example where var x y z let us consider the assignment x y imp and the set of input stores s s on the concrete side we have that x y s the abstraction of x y s in oct is therefore as follows oct x y s x y z x y x y x z x z y z y z on the abstract side the abstraction of s in oct is as follows x y z x y x y x z x z y z y z we consider the store so that x y oct x y however we have that oct x y s because the relation x z is not satisfied this shows that oct x y s oct x y ie x y it turns out that the remaining assignments are the only which are complete for lemma the only complete assignments for oct are x a y k and x a x k where a and k z nr null x x ¬x nr null x nr null if x then x nr null p x then x figure the derivation tree proving the completeness of the program p on the abstraction null proof consider x a y k with a by the characterization of completeness given in and in section we have that x a y k iff for any oct oct s x a y k t oct oct we observe that this maximal set of store can be obtained from oct by replacing in any relation involving the variable x the expression ay k if a then it is clear that this replacement still provides relations of the shape ± y k it turns out that this also happens for a let us consider the case a namely x y k the following cases are possible the replacement for a x b provides the relation a k y b k for a x y b the relation a k b which can be true or false and in this case we obtain the empty for a x y b the relation a k y b k which is equivalent integer variables to a k y b k for a x ± z b where z y we obtain a k y ± z b k thus in each case we obtain a variable relation of the shape ± y k ie s x y k t oct is an a similar analysis applies to the remaining cases x y k and x k lemma therefore provides an exhaustive static analysis of the completeness of assignments for the abstraction it is to observe that figure describes algorithms that compute the best correct approximations called exact approximations in on for precisely the set of complete assignments characterized by lemma this may suggest an interesting relationship between the property of being complete for an assignment and that of a computable best correct approximation proving completeness of guards we argued that the main problem in proving a p lies in the fact that in general it is hard to prove that b ba and ¬b ba for an arbitrary store abstraction a actually most of the times only trivial false nondeterministic choices and eg x null in the out to be complete for instance one may expect that a boolean condition which is exactly representable in some abstraction as x in int turns out to be complete however in general this is not the case as shown by example our goal is to take into account explicitly the boolean guards of programs by adding suitable assumptions to completeness proofs in a thus we derive a conditional proof of completeness in a for a program p whose assumptions on the completeness of the boolean guards of p then need to be validated in a further distinct step let us consider a store abstraction a and a boolean predicate b we use the following notation b t s b t if b s b s holds for a given s s then b is called complete for a in s since this condition is equivalent to b s b s and b s b t s we have that b is complete for a in s when b t s b t s now let us consider some b which is representable in the abstract domain a that is b t b t holds we call them expressions for example x k y k is a int and expression while k x x y is a expression but not a expression in this case it turns out that b t s b t s b t a s b t a s so that completeness of b for a in s corresponds to require b t s b t a s we our proof system a with suitable assumptions that guarantee that the sets of possible input states for a boolean guard make it complete this allows us to derive a conditional proof of completeness for a program p under these assumptions on the completeness of the boolean guards of p these proof assumptions can then be proved in a later step eg by a static analysis focused on boolean guards let denote the set of boolean guards occurring in some program point of p and assume that the set p of boolean guards of p which are not complete on a ie p b b ba consists of expressions only if a p then the completeness proof for p may fail along some guard b p if we are able to guarantee that this guard b is complete for any set s of possible input stores at the program point where the guard b occurs in p then we can safely conclude that b is complete on a for the purpose of proving that p is complete on a we therefore add the following conditional gc for the completeness of guards b p assumes b t s b t a s gc b ba hence a conditional completeness proof of p in a gc depends on the collection gp of all the assumptions made for the guards b p the next step consists in designing some statically that allow to validate all the assumptions in gp made in a conditional proof of p so as to establish an proof for p on a completeness of int and guards given a set of store we want to provide a characterization of the completeness of boolean expressions which are representable as intervals or namely we characterize the sets of stores s that make a int and expression complete hence providing specific conditions for the assumptions of the conditional rule gc for int and oct in order to keep the notation as simple as possible in what follows we consider the abstractions int and oct on stores over two variables x y ie s z and int oct abs z moreover for any set of concrete points s z we use ints z to denote the corresponding interval and abstractions the generalization to n variables is conceptually simple but tedious in two variables a possibly infinite interval is a possibly infinite rectangle r in the x y a rectangle r can be represented by its set of edges denoted by which are at most four this is the case of finite similarly an o in two variables can be represented by its edges in which are at most any e determines a line in the x y integer which is denoted by le if l is a line in the x y integer and s z is any set of points then ls denotes the orthogonal projection of s onto l completeness of guards is then characterized as follows theorem let r be a expression then r is complete for int in a set of stores s z if and only if the following condition holds e le ints r s r proof since ints r r ints r always holds let us first observe that r is not complete for int in s when ints r r ints r ints r ints r ints r moreover it turns out that the rectangle ints r is strictly contained into the rectangle ints r iff there exists an edge e r such that le ints r e le ints r the following figure helps in this where s is given by the set of ints r is the red dashed inner rectangle and ints r is the blue dotted rectangle · ·· · since the rectangle ints r is contained in r the last condition ints r ints r holds iff there exists an edge e such that le ints r le also the orthogonal projection le onto the line le satisfies the following property le ints r s r so that ints r ints r holds iff s r le ints r it is now easy to check that this latter condition holds iff the negation of holds observe that in the condition we have that le ints r is always an interval because ints r is always a rectangle furthermore if s is already a rectangle namely ints s then condition holds so that we have completeness let us also observe that is trivially satisfied when one of the following conditions hold ints r or s r or r s finally if s r but ints r then down to e le ints r which is always false so that completeness does not hold example in the following the set of points s in the x y is given by the set of let us first consider the following example r · · · ·· in this case the rectangle r turns out to be complete for int in s in fact for any edge e the two projections le ints r and le s r give the same intervals which are depicted with blue and red lines let us now consider the following modified picture where the rightmost point of s is moved one step down r · · · · · here completeness of r for int in s is lost in fact for the rightmost vertical edge e s r is the red dashed interval which is strictly contained in the interval le obtained by s onto e the gap between these two intervals is depicted by the blue dotted segment of course theorem can be stated in general for a n dimensional space with n in the general geometric formulation r is a n dimensional also called s zn is any set of points in the n dimensional space edges of r are replaced by the n of the r and lines determined by edges are the determined by furthermore theorem also holds for with the same statement where the abstraction oct replaces int here in the dimensional case the edges of an are at most while the abstraction in oct of a projection onto a line down to an interval abstraction thus if o is a guard then o is complete for oct in s iff the following condition holds e le o s o example in the following picture the o is complete for oct in the set s of points depicted as in the picture is depicted with blue dotted edges while o is depicted with red dashed edges condition holds for example for the edge e in the picture le o s o is the red dashed interval e ·· · ·· o · on the other hand let us consider the following modified picture where the leftmost point of s is moved two steps down e · · · ·· o · here completeness of o for oct in s is lost the gap between the two orthogonal projections on the edge e is depicted with a gray segment ie condition does not hold theorem explains precisely why the expression r x which is the negation of the loop guard of the program in figure discussed in section is not complete for int in the set of input stores s here ints r x x and s r and for the edge e x we have that le ints r x y is not contained in s r instead this incompleteness does not arise with oct because le r s r assumptions on guards consider the following program template p x k y k while x y r do x a y a which subsumes the examples of figures and we assume that i ki z are constant values ii r is any finite or infinite dimensional rectangle in int such that its complement is a rectangle as well iii the arithmetic expressions ai are complete for int ie ai by assumption i k k nr int x k nr int y k nr int x k y k also by assumption iii the body of the can be proved complete for int a a nr int x a nr int y a nr int x a y a let us then consider the set s of stores ie concrete x y points computed by the body of the of p ie if i k k z is the set of input stores for the then s is given by s x a y a r x we thus have a conditional proof nr int p which depends on the assumptions on the boolean guard r and its negation assumes s r ints assumes s ints we apply theorem to derive the validity of these assumptions let us consider the following cases a if r i i ie r i then the is not entered so that s i and r s and s s for example this happens with x y while x do x x y y in this case completeness of r and for s is a trivial case of condition in theorem b if r i i then the is entered if s is an infinite set then we have nontermination this means that s r and s this happens for example with the program x y while x do x x y y here condition for r and follows trivially because we have that respectively s r and s c if r i i and s is finite then the is entered and we have termination this means that rs and this is the case of the following two programs p x y while x x y y p x y while x do x x y y here we have that sp sp by condition we obtain that r is not complete for sp while both r and are complete for sp while for p the assumptions of its conditional proof cannot be validated the assumptions for p are validated by theorem hence we have nr int p d finally let us consider the analyses of the programs p and p of point c for the abstraction oct in this case by lemma we have that all the assignments in p and p are complete for oct moreover while oct p can obviously be inferred as in point c here we are also able to infer that oct p in fact since the set sp is an ie sp the condition is trivially satisfied both for r and so that the assumptions for r and of the conditional proof of p can be validated related work to the best of our knowledge this is the first attempt to systematically extract a property concerning the precision of a static program analysis through a proof system the subject of our analysis is a given abstract interpretation of a program while the property to analyze is the completeness of this abstract interpretation completeness for an abstract interpretation is particularly important because it formalizes the absence of false alarms and therefore it is related with the quality of the program analysis the most related approach is in where the authors define a constructive optimal abstraction refinement for deriving the most abstract complete domain which refines a given incomplete abstraction for a generic program statement our method follows an orthogonal pattern we are not interested in refining an abstract domain for obtaining completeness with respect to a given class of programs but rather in studying the class of programs for which a given abstraction is complete this different starting point leads us to design a deductive system for deriving a completeness proof for programs on a given abstraction this new perspective allows us to decompose the problem of a complete abstraction for a given program which becomes modular and inductive on the programs syntax the of completeness properties in static analysis is also studied in where it is argued how completeness can play a role for designing static analyses by reasoning on the completeness properties of their underlying abstract domains provably precise static analyses usually make some assumption on the syntactic form of the analyzed program for instance the precise interprocedural analysis of computes for each program point all the affine relations among program variables what the authors call precision is effectively our notion of completeness they achieve precision by focusing on a particular class of programs namely affine programs affine programs are such that i all guards are nondeterministic and ii the righthand side of assignments are either affine expressions or unknown values similarly in type systems it is to ignore the guards in order to prove the completeness of the type inference algorithm eg in we argued in this article that the main problem for proving completeness is the handling of assignments and of boolean guards our research follows the lines of a recent approach by cousot and cousot who put forward a type system for typing the structure of an abstract interpretation a type represents inductively the way an abstraction has been built by composing simpler abstractions through systematic domain operations like reduced product it could be interesting to investigate the possibility of combining our proof system with a structural type system for abstract interpretations as in with the aim of providing along a derivation in a some additional information about the used and their composition through domain operations conclusion static analysis is by design incomplete nevertheless experience has shown that it can be made precise enough to be used for verification we static analyses which in addition to the inferred invariants also provide completeness certificates the completeness certificate is used to provide to the analysis of alarms as a foundational step towards this goal we introduced a theoretical framework to prove the completeness of a static analysis we have shown that the source of incompleteness lies in the handling of boolean guards and for relational abstractions in assignments for abstractions we introduced an core proof system which pushes the completeness of the analysis to the numerical expressions and the boolean guards of conditionals and loops for relational abstractions instead the structure of complete assignments has to be derived in advance in order to obtain a sound proof system we argued that the designer of a static analyzer should also provide completeness conditions for the boolean guards and that these conditions could be automatically checked by further yet less sophisticated static leave the design of such automated analyses for future work we studied the completeness of boolean guards in widely used numerical abstractions such as intervals and most known abstract domains have been indeed designed to precisely capture properties of some given programs this is justified by the fact that the class of completeness ca of any abstraction a is always an infinite set therefore deriving an abstract domain which is complete for a specific program p provides at the same time a domain which is complete for an infinite class of programs as future work we think that proving completeness of static analyses could be also to i automatically apply abstract code if the analysis of the original and the programs can both be proven complete then the repair is very likely to have fixed a concrete bug ii validate among different program one may only keep the ones for which she can prove it preserves the completeness of the analysis iii provide a better understanding of why analyses of arrays works well in practice even without performing argued as necessary in acknowledgments and have been partially supported by the microsoft research software engineering foundation references cousot p and cousot r static verification of dynamic type properties of variables research report no university of france cousot p and cousot r static determination of dynamic properties of programs in proceedings of the nd international symposium on programming paris pp ­ cousot p and cousot r abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in conference record of the th acm symposium on principles of programming languages popl acm press pp ­ cousot p and cousot r systematic design of program analysis frameworks in conference record of the th acm symposium on principles of programming languages popl acm press pp ­ cousot p and cousot r a galois connection calculus for abstract interpretation in conference record of the st acm symposium on principles of programming languages popl s and p sewell eds acm press pp ­ cousot p cousot r j l a d and x the e analyzer in proceedings of the european symposium on programming esop vol of lecture notes in computer science springer pp ­ cousot p cousot r and f a parametric segmentation functor for fully automatic and scalable array content analysis in conference record of the th acm symposium on principles of programming languages popl acm press pp ­ cousot p cousot r f and m an abstract interpretation framework for with application to extract methods with contracts in proceedings of the th acm inter conference on object oriented programming systems languages and applications oopsla acm press pp ­ l and milner r principal for functional programs in conference record of the th acm symposium on principles of programming languages popl acm press pp ­ j c e sets trans of the mathematical society ­ m and f static contract checking with abstract interpretation in proceedings of the conf on formal verification of objectoriented software springer r hiding information in completeness holes ­ new in code and watermarking in proc of the th ieee international on software engineering and formal methods ieee press pp ­ r f and f making abstract interpretation complete journal of the acm ­ p static analysis of j computer math ­ gulwani s b and a lifting abstract interpreters to quantified logical domains in conference record of the th acm symposium on principles of programming languages popl acm press pp ­ m affine relationships among variables of a program informatica ­ v and f refining abstract static analyses with in proc of the symp on programming languages and systems vol of lecture notes in computer science springer pp ­ f and ball t modular and verified automatic program repair in proceedings of the th acm conference on object oriented programming systems languages and applications oopsla acm press pp ­ a a new numerical abstract domain based on matrices in proc of the nd symp on programs as data objects vol of lecture notes in computer science springer pp ­ a the abstract domain higher order and symbolic computation ­ m and h precise interprocedural analysis through linear algebra in conference record of the st acm symposium on principles of programming languages popl acm press pp ­ f complete abstractions everywhere in proc of the th international conference on verification model checking and abstract interpretation vol of lecture notes in computer science springer pp ­ h theory of recursive functions and effective the mit press r i recursively enumerable sets and springerverlag g the formal semantics of programming languages an introduction mit press 