string processing in using inputoutput examples gulwani microsoft research wa usa abstract we describe the design of a string language that supports restricted forms of regular expressions conditionals and loops the language is expressive enough to represent a wide variety of string manipulation tasks that with we describe an algorithm based on several novel concepts for synthesizing a desired program in this language from inputoutput examples the synthesis algorithm is very efficient taking a fraction of a second for various benchmark examples the synthesis algorithm is interactive and has several desirable features it can rank multiple solutions and has fast convergence it can detect in the user input and it supports an active interaction model the user is to provide outputs on inputs that may have multiple computational interpretations the algorithm has been implemented as an interactive for microsoft system the prototype tool has met the test it has synthesized part of itself and has been used to solve problems beyond authors categories and subject descriptors d programming techniques automatic programming i artificial intelligence program synthesis general terms algorithms human factors keywords program synthesis user programming by example version space algebra programming string manipulation introduction more than people use these have and include designers human resource and even ­ they are not programmers but they need to create small often applications to support functions unfortunately the state of art in programming is far from satisfactory systems come with of features but to find the correct feature or of commands to use from a of features to permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm their task more significantly programming is still required to perform tedious and tasks such as transforming entities like from one format to another data extracting data from several text files or web pages into a single document etc systems like microsoft allow users to write macros using a rich library of string and numerical functions or to write arbitrary scripts using a variety of programming languages like basic or net since are not in programming they find it too difficult to write desired macros or scripts we have performed an extensive case study of help and identified that string processing is one of the most common class of programming problems that with this is not surprising given that languages like python into existence to support processing and that new languages like provide a rich support for string processing during our study of help we also carefully studied how these users were describing the specification of the desired program to the on the other side of the help it turns out that the most common form of specification was inputoutput examples since inputoutput examples may lead to the interaction between the user and the often involved a few of communication over multiple we describe a program synthesis system that is capable of synthesizing a wide range of string processing programs in from inputoutput examples the synthesizer aims to replace the role of the which not only removes a human from the loop but also enables users to solve their problems in a few seconds as opposed to a few our synthesis system which is ready has the following important properties fully automated we do not require to provide of any form real time our system takes less than second on average per interactive round easy interaction programming by examples is an interactive process where examples are added in each round to make the specification more precise our system helps identify the inputs for which the user should provide examples fast convergence our system typically takes of iteration for convergence in practice handling if the user makes a small in mostly correct specification our system can still compute the likely solution and report the likely this paper makes the following contributions we describe a string language that is expressive enough to represent a wide variety of string manipulation tasks found during an extensive study of online help while at the same time also being restrictive enough to enable efficient program search over that space section we describe an algorithm with several novel concepts that can efficiently synthesize a set of programs in our language that are consistent with a given set of inputoutput examples section we describe extensions to the above algorithm that enable several properties section we discuss our experience with a prototype tool section problem definition we start out by describing a representative up from an online help that illustrates a typical interaction between a user and an on help we then use it to the key technical problem that we address in this paper example the user to extract the following from the respective strings john data ts a ff s a the user initially provides a few examples to the that are similar to the first example above the provides a program that uses the logic of extracting characters after the first occurrence of the user runs program on other inputs in her and that it does not perform the desired extraction for the second example above and then presents that to the the then provides a program that uses the logic of finding the first occurrence of and extracting characters on left of it and characters on right of it the user runs program on her and that it does not perform the desired extraction for the third example above and then presents that to the the then provides a program that uses the logic of finding the first occurrence of a pattern of the form where is to match any character the user runs program on her and is satisfied with the produced results and the thread is closed one might why did the not suggest a program which is similar to but is to match any as opposed to any character or why did the not suggest a program which is similar to but the first three occurrences of are forced to match only even though programs and are semantically different these programs may not yield different outputs on the inputs the user has in her hence these programs are observationally equivalent over the format of the inputs present in the we draw the following conclusions from this representative case study first the user is communicating her using inputoutput examples second the user cannot be expected to provide representative inputs in the first round hence an example based synthesis system must be interactive however in order to remain usable the system should allow the user to interact easily and converge quickly ie in a few to the desired in this paper we describe such a program synthesis system we present an algorithm for synthesizing string manipulation programs that are consistent with inputoutput examples we also describe how the algorithm can be extended to enable easy interaction and fast convergence expression language for string manipulation we have identified a string expression language that is expressive enough to describe various string manipulation tasks while at the same time concise enough to be amenable for efficient learning there is a tradeoff between the expressiveness of a search space and the complexity of finding simple consistent hypotheses within that space in general the more expressive a search space the harder the task of finding consistent hypotheses within that search space however it is also that the tradeoff is not as simple as it seems as an expressive language can sometimes make a simple theory fit the data whereas restricting the expressiveness of the language means that any consistent theory must be very complex our string expression language seems to the right tradeoff we present a core version of this language extensions that enable easy adaptation of the underlying algorithm are mentioned later in section the syntax and semantics of the string expressions is formally described in figure and figure respectively we use the notation to denote an empty string and to denote an undefined value if any of the arguments to any constructor is then it returns the notation denotes the substring of starting at location and ending at location the string expressions map an input state which holds values for string variables denoting the multiple input columns in a to a single output string string × × string string the above formalism can also be used for string processing tasks that require generating a tuple of strings as an output by simply solving independent problems a trace expression refers to the f constructor which denotes the string obtained by the strings represented by f f f in that order an atomic expression refers to denoting a constant string or loop constructors which are explained below the p p constructor makes use of two position expressions p and p each of which evaluates to an index within the string p p denotes the substring of string that starts at index specified by p and ends at index specified by p if either of p or p refer to an index that is outside the range of string then the constructor returns the position expression cpos refers to the index in a given string from the left side or right side if the integer constant is nonnegative or negative r c is another position constructor where r and r are some regular expressions and integer expression c evaluates to a nonzero integer the pos constructor evaluates to an index in a given string such that r matches some suffix of and r matches some prefix of where length furthermore is the c such match starting from the left side or the right side if c is positive or negative if not enough matches exist then is returned we use notation r c to denote the c occurrence of regular expression r in ie pos r c c we often denote cpos cpos by simply tokens and regular expressions a token is either some special token or is constructed from some character class in two ways denotes a token that matches a sequence of one or more characters from ¬ denotes a token that matches a sequence of one or more characters that do not belong to we use the following collection of character classes numeric alphabets alphabets az alphabets az alphabets characters characters all characters we use the following matches the beginning of a string matches the end of a string string expr e b e bool b d d conjunct d predicate match r ¬ match r trace expr e f atomic expr f p p loop e position p cpos r c integer expr c regular expression r t token t ¬ figure syntax of string expressions refers to a free string variable while refers to a bound integer variable denotes an integer constant and denotes a string constant a token for each special character such as dot etc for better readability we reference tokens by representative names for example refers to a sequence of characters refers to a sequence of numeric refers to a sequence of characters that are not numeric matches with the character addition of more tokens may make the language more powerful these tokens may be added either by the user or can be by searching for frequently occurring in a given however to true to our goal of avoiding any user annotations we aim to keep the language expressive without having to depend on addition of tokens a regular expression r t is a sequence of tokens t t we often refer to singleton token sequences simply as t we use the notation to denote an empty sequence of tokens matches an empty string it is worth discussing our restricted choice of regular expressions first we allow for only a restricted form of the kleene star operator the kleene star is restricted to one or more occurrences as opposed to zero or more occurrences and that too at the innermost level second we do not allow for the disjunction operator these restrictions together with the token partitioning optimization described in section enable us to efficiently enumerate regular expressions that match certain parts of a string if we allowed arbitrary kleene star and disjunction we would lose this ability use of conditionals at the outer level allow us to recover some of the expressiveness lost due to restricted form of regular expressions the following two examples illustrate the expressive power of our substring constructor example the goal in this problem taken from an online help is to extract the of the observe that characterizing the substring that is being extracted is nontrivial in fact not even possible using the tokens that our language provides however characterizing the left position before the substring and the right position after the substring is relatively easy and also expressible in our language e b e d d match r if b then e else if b then e else d d match r f f loop e e e let e in if then else e p p cpos p p where length if otherwise r c such that st matches r matches r and is the c such position in increasing decreasing order if c is figure semantics of string expressions input output wk corn z z hd sc pk z o f pk z the following string program identifies the left position to be the one before the occurrence of the first number while the right tion to be the one at the end of the string string program in our language pos cpos example directory name extraction consider the following example taken from an online help input output string program cpos loops the string expression loop e refers to concatenation of e e e where e is obtained from e by replacing all occurrences of by is the smallest integer such that evaluation of e yields it is also possible to define more interesting termination conditions based on position expression or predicates but we leave out details for lack of space example generate abbreviation the goal here is to extract out all letters this problem is taken from and is presented as an example of advanced text formulas input international machines principles of programming languages international conference on software engineering output ibm popl string program loop example split the goal in this problem taken from an help is to place each odd in a separate cell while ignoring any numbers or we reduce the problem of generating multiple unbounded number of output strings to that of generating one output string where the multiple strings are separated by a unique symbol say input output string program loop p p where p and p example remove spaces the goal in this problem provided by the product team and also present in is to remove all leading and spaces and replace internal strings of multiple spaces by a single space notice how the loop expression out all but last sequence of characters to not print any in the output input de output de string program p p where p pos and p conditionals the toplevel string expression is a switch constructor whose arguments are pairs of disjoint boolean expressions b and trace expressions e the value of in a given input state is the value of the trace expression that corresponds to the boolean expression satisfied by boolean expressions b are represented in dnf form and are boolean combinations of predicates of the form match r where r is some regular expression and is some integer constant match r evaluates to true iff contains at least matches of regular expression r we often denote match r by simply match r conditionals play a very important role in our string processing language they allow us to appropriately data that is in multiple formats this is precisely the place where most existing data tools that allow string processing through of automated features fail since they assume that the input is in a fixed structured format conditionals also allow us to express transformations that are beyond the expressive power of the underlying part of our language example conditional concatenation the goal here is to the first and the second strings and in the input tuple as only if both and are nonempty strings otherwise the output should be empty string this example is taken from an online help input input output manager string program e b where b match match e b example mixed date parsing the goal here is to parse in multiple formats into and year this example is taken from an internal list we show below the program for extraction and year extraction are solved similarly input output string program e b e b e where b match b match b match e pos e pos e example name parsing the goal in this problem provided by the product team is to parse names that occur in multiple formats and transform them into a uniform format input output dr s sr e k b necula necula g ii k string program for extracting initial of the first name the logic used is that of extracting the initial of the first word not followed by a dot p p where p pos and p pos string program for extracting last name the logic used is that of extracting the word followed by a or the last word if no exists e b e where b match b e p p e p pos and p the above two programs can be together after conditionals at the toplevel along with some constant strings to yield the desired program example numbers the goal here is to parse numbers that occur in multiple formats and transform them into a uniform format adding a default area code of if the area code is missing this example was provided by the product team input output string program e b e where e b e e dag where f e b e e b e e e dag f f form a path between and f f f f f loop e loop e loop e e e p p p p p p p p p p p cpos c r t cpos cpos c r c r r r r c c t t t t t t figure syntax and semantics of a for describing sets of string expressions dag dag × where and f f p p p p p if e loop e loop e cpos cpos if c c c c t t t t t if figure the function the function returns in all other cases not covered above b match b e e algorithm in this section we describe an algorithm for learning a string expression in the language presented in section that is consistent with the provided inputoutput examples in fact the algorithm ends up learning a set of string expressions all of which are consistent with the provided inputoutput examples this enables the algorithm to have several desirable properties discussed later the toplevel structure of the algorithm is described in procedure in fig which we explain below step the algorithm first computes in the loop at line for each inputoutput pair a set of all trace expressions that map input to output we refer to this set as a trace set this is done using the procedure explained in section the set of such expressions can be a key enabling technology is the datastructure described in section for representing and manipulating such a set of expressions step if the target program does not contain any conditionals ie it is expressible as a trace expression then the algorithm can simply the trace sets of all inputoutput examples however since this is not a valid assumption the algorithm first partitions the examples so that inputs in the same partition are handled by the same conditional in the toplevel switch construct and then the trace sets for inputs in the same partition partitioning is performed in line using the procedure explained in section inputs in the same partition have the property that intersection of their trace sets is nonempty the algorithm uses a greedy heuristic to minimize the number of such partitions by starting with singleton partitions and then iteratively merging those partitions that have the compatibility score a notion defined in sec step the algorithm then constructs in the loop at line a boolean classification scheme as a function of the inputs that will place them in the appropriate partition this is done using the procedure explained in section this boolean classification forms the toplevel switch construct for the string program returned by the algorithm at line steps and are explained in detail in sec the procedure used in step is explained in sec it makes use of two key procedures and which are discussed in sections and respectively we start out by briefly describing the key datastructure used by these procedures and the operations that it supports datastructure for manipulating sets of expressions figure describes our for representing sets of string expressions of various kinds and also presents its formal semantics e f p and r denote respectively a set of string programs a set of trace expressions a set of atomic expressions a set of position expressions and a set of regular expressions they are represented using the datastructure shown in fig t and c represent a set e b e × size where size size × f and size p p × e c × × t × figure the size function the equations here also illustrate the representation that our datastructures provide compared to explicit representation of tokens and a set of integer expressions and are represented explicitly the constructor used in our string language is generalized to the dag constructor dag where is a set of nodes containing two marked source and target nodes and is a set of edges over nodes in that induces a dag and maps each to a set of atomic expressions the set of all expressions represented by a dag constructor include those whose ordered arguments belong to the corresponding edge on any path from to the switch loop pos and constructors have all been overloaded to accept a set of values of the corresponding type for its arguments with the expected semantics the datastructure supports the following two interesting operations both of which are required for the partitioning procedure intersection operation given two sets of expressions of the same kind construct a set of expressions that are common to the two given sets the intersection function is described in fig the most interesting part is the intersection of two dags which is similar to intersection of two regular the challenge compared to regular automata case is to the labels on the edges in case of automata the labels are simply a set of characters while in our case the labels are sets of string expressions we sets of string expressions using the intersection operation supported by the datastructure used for representing those sets of string expressions size operation given a set of expressions of some kind estimate the size of the set the size function is described in figure observe the benefits provided by the used by each set construct learning substring extraction logics in this section we describe how to learn the set of all expressions in our language that can be used to extract a given substring from a given string this is an important component of the procedure the number of such expressions may be in which case explicit representation and computation of all these expressions would be infeasible with respect to both time and space for example following is a small sample of various logics for extracting from the string call it second number second last token substring between the first and the last pos first number that occurs between on both ends first number that is by a sequence the procedure performs this task effectively and is built around the following two key observations decomposition into independent the problem can be decomposed into two independent problems each of which can be solved independently note the two independent calls to procedure at lines and in procedure in figure the solutions to the problem can also be maintained by independently representing the solutions to the two problems note the representation of the constructor in eq in figure partitioning of tokens into sets a given string does not often distinguish between several sets of tokens hence for any problem the choice of regular expressions for a given string can be restricted to using only one token from each set of tokens we define this more formally below definition we say that a token t is from token t with respect to a string if the set of matches of token t in is same as the set of matches of token t in string note that is an equivalence relation definition partition given a string and a set of tokens let denote the partition of tokens into sets and let reps denote some set of representative tokens one from each partition we use the notation t to denote the set in which token t lies we use this observation to restrict the choice of tokens used in constructing regular expressions to come from the set reps at lines and in procedure this significantly reduces the number of regular expressions that get considered at lines and without the completeness of the algorithm learning traces in this section we discuss how to learn the set of all trace expressions ie constructors that can be used to generate a given output string from a given input state the number of such expressions may be for example consider the problem of transforming numbers in example consider the second inputoutput example where the input state consists of one string and the output string is figure shows a small sampling of different ways of generating parts of the output string from the input string using and constructors each substring extraction task itself can be performed in a number of ways as explained in sec following are three of the trace expressions represented in the figure of which the second one also shown in in the figure would lead to the correct answer extract the substring extract the substring input ­ ­ output ­ ­ constant constant constant constant figure small sampling of different ways of generating parts of an output string from the input string extract the substring print constant extract the substring print constant extract the substring extract the substring extract the substring print constant extract the substring procedure performs this task effectively by using the dag datastructure introduced earlier to represent all trace expressions it uses the following crucial observations independence of unknown first observe that the logic for generating some substring of an output string is completely from the logic for generating another disjoint substring of the output string hence the problem of generating the output string can be into independent of generating different parts of the output string in particular assume that we have an oracle as in a system like that provides us with the decomposition of a given output string into disjoint adjacent where each disjoint substring gets generated by a different argument of the enclosing operator given such a decomposition we can decompose the problem of identifying the trace expression for generating the output string into independent of generating each of the disjoint adjacent using at atomic expression constructor these problems can not only be solved independently but their solutions can also be stored independently to represent an exponential number of solutions in linear space however unfortunately we do not know the appropriate decomposition of the output string into various parts for which we can independently a solution the naive strategy of all possible would not scale since the number of is exponential in the size of the output string number of possible is quadratic second observe that the total number of different of a string is quadratic and not exponential in the size of the output string this leads to a representation of all possible of a string using a dag representation and hence allows us to decompose the problem of generating the output string using a trace expression into a quadratic number of independent of generating different of the output string using some atomic expression with the above two observations we are now ready to explain the effective of the procedure the procedure generates a dag constructor that represents the set of all trace expressions that can generate a given output string from a given input state the key idea is to construct a node corresponding to each position within the output string and create an edge from a node corresponding to any position to a node corresponding to any later position observe that each edge here corresponds to some substring of the output each such edge is annotated with the set of all atomic expressions that can generate the corresponding substring lines and in procedure the set of all such and loop expressions is generated by procedures and respectively the following theorem holds theorem procedure computes the set of all trace expressions e with the following properties a soundness e generates the output string from the input state ie e a completeness restriction any loop that occurs in e is and executes at least twice on proof the procedure generates the set of all expressions that can generate from the procedure extends the mapping with all loop expressions that can generate from and furthermore satisfy the restrictions in a hence the theorem follows learning loops in this section we discuss how to infer the set of all loop constructors that can be used to generate some unknown part of a given output string from a given input state in the process we would also identify the unknown part of the output string that the loop constructor can generate procedure performs this task effectively and involves the following steps guess three positions within the output string and unify the set of trace expressions that can generate with the set of trace expressions that can generate to obtain a new set of string expressions say e that uses the loop iterator the unification algorithm is explained below obtain the set of obtained by running the string expressions e on input if this set contains a singleton string that matches for some then we conclude that can be generated by loop e otherwise ignore the unification algorithm is same as the intersection algorithm except with the following replacement to eq in figure if the key idea above is to guess a set of loop bodies by unifying the sets of trace expressions associated with the and and then test the validity of the set of loops for performance reasons we do not recursively invoke in the call that it makes to this allows us to discover all single loops nested loops may be discovered by controlling the recursion depth learning conditionals in this section we discuss how to generate the toplevel switch constructor after having learned for each inputoutput example the set of all trace expressions that can generate the output string from the input state there are two important components that enable learning of appropriate conditionals partitioning of inputoutput examples into disjoint partitions and learning based on inputs for those partitions the provide the conditionals while the intersection of the trace sets associated with various inputs in a partition yields the computational branch for the corresponding conditional learning partitions in this section we discuss how to appropriately classify the inputoutput examples into different partitions the idea being that exam input state output string set of foreach pairs length length length let be the mapping that maps edge to the set foreach e let return dag let e e be the elements in in increasing order of input state output string return switch e e foreach length e e set of pairs while exists e e st e e e if loop e for some let e e be st cse e loop e is largest return e e e input state string return result foreach st is substring of at position b false while old set of inputs result result return result length d true string int while result cpos old foreach r t matching for some match r r foreach r t matching for some match r let be st csp r t t t let be st is the match for r in is largest let be the total number of matches for r in d d ¬ ¬ if old then fail b b d r r result result r return result if old then fail regular expression string return b let r be of the form t return t t figure algorithm for learning string programs that are consistent with a given set of inputoutput examples that end up in the same partition are those that require similar computational processing we attempt to achieve this by requiring the partitioning to satisfy the following two properties utility for each partition there is at least one trace expression e that is consistent with all examples in that partition number of partitions should be as small as possible observe that the utility requirement can be satisfied trivially on its own by placing each example in its own partition but then it would not lead to any generalization which in turn would not lead to any convergence the requirement can be satisfied trivially on its own by placing all examples in the same partition but it may lead to failure because there might not be any trace expression that can express the transformation for all the examples it is the combination of these two requirements that leads to faster successful convergence it would be computationally expensive to try out all possible partitioning choices and select the one that contains smallest number of partitions we present a partitioning algorithm based on greedy algorithmic design pattern that is not only efficient but in practice yields the smallest number of partitions the algorithm for learning partitions is described in procedure in figure we start with singleton partitions that contain one input each along with associated trace sets we then merge two partitions only if their associated trace sets have at least one trace expression in common this criterion leads to satisfaction of the utility requirement we refer to such trace sets as being compatible with each other definition compatible we say that trace sets e and e are compatible with each other denoted e if e e often there are multiple choices of pairs of partitions that can be merged with each other we select a pair that has the compatibility score the compatibility score is designed to facilitate partitioning decisions that at least in practice lead to the smallest number of partitions the compatibility score has two components cs and cs cs measures agreement of two partitions with respect to the compatibility of their trace sets and their intersection with all other trace sets in particular if two trace sets e and e are both compatible with e and so is e then we up the compatibility score of e and e also if two trace sets e and e are both not compatible with e then we up the compatibility score of e and e note that in either of two cases the potential of e or e to merge with e is unchanged as a result of the intersection of e and e the idea is to select those partitions for merging that keep merging potential with other partitions in a later step resulting in a smaller number of overall partitions cs is used to produce a score in case there are on the cs score it gives preference to those pairs of trace sets whose relative size after intersection is largest the idea is that a larger trace set is more likely to merge with other trace sets in a later step resulting in a smaller number of overall partitions definition compatibility score let e and e be two compatible trace sets drawn from a set e e of trace sets we define the compatibility score of e and e with respect to denoted by cse e as cse e cse e cse e where cs and cs are defined as follows cse e e e e e e e e if e e e e otherwise cse e e comparison on compatibility xy which are pairs of numbers is defined using ordering ie we repeat the merging process one by one until no more partitions can be merged learning for partitions in this section we discuss how to generate for the various partitions generated using the algorithm described above a classifier for a partition is a boolean condition over the set of predicates in our language that returns true for all inputs in the partition and returns false for all inputs not in that partition we attempt to learn not just any classifier but a simple one given a set of predicates one simple approach can be to enumerate boolean formulas of large sizes and check if it can act as a classifier for some partition however this approach would be computationally expensive we present a classifier learning algorithm based on greedy algorithmic design pattern that is not only efficient but in practice yields smallest the algorithm for learning is described in procedure in figure we learn a boolean classifier in dnf form the loop in line a new conjunct d in each iteration with the property that none of the inputs in satisfy d but several inputs in do is that decreasing subset of inputs from that are not yet covered by the disjunctive boolean formula b learned so far the loop in line is repeated until becomes empty or it does not change the loop in line identifies a new predicate in each iteration with the property that several inputs in satisfy but several inputs in do not satisfy and then adds it to the conjunct d and are both those decreasing subsets of and respectively that satisfy the conjunct d built so far is used to decide whether or not the loop in line needs to be iterated any further while is used to update which is required for the loop in line hence the following theorem holds theorem if does not fail and returns a boolean condition b then all inputs in satisfy b and none of the inputs in satisfy b to ensure learning of small boolean formulas we ensure that the predicate that is chosen at line is such that several inputs in do not satisfy this keeps smaller which helps to terminate the inner loop at line faster which leads to conjuncts d containing small number of predicates several inputs in satisfy this keeps larger which helps to keep smaller which in turn helps to terminate the outer loop in line faster which leads to fewer number of conjuncts to enable a selection that satisfies criterion we choose a predicate with classification score as defined below with respect to the sets and definition classification score of a predicate given two sets of inputs and and a unary predicate over inputs we define the classification score of denoted by csp as csp size × size ¬ correctness if procedure does not fail the synthesis algorithm succeeds in that case the following theorem holds theorem soundness the set of string expressions returned by are all consistent with each inputoutput pair ie the proof of theorem follows from similar soundness properties of the involved procedures of which the most interesting one has been stated in theorem conjecture completeness if there exists a string expression in our language that is consistent with the given set of inputoutput pairs the algorithm produces one the above conjecture is true at the level of traces ie if there exists a consistent trace expression satisfying the restriction a in theorem then the algorithm generates it however the above conjecture may not be true in general in practice though we have observed our partitioning and classification procedures to always work and it appears that there are some interesting theoretical properties of these procedures that might the way for proving the above conjecture under some general conditionals this investigation is left for future work discussion to language extensions the algorithm can be easily adapted to deal with the following language extensions the choice of can be arbitrarily as long as they can be efficiently the choice of regular expressions is for reasons mentioned earlier the substring construct can be extended further to allow for a constant index offset into the current choice of the loop construct can be to allow for termination conditions based on position logic or conjunctions of predicates it may be possible to nest conditionals inside loops the key algorithmic idea would be to recursively perform partitioning and classification as is done at the toplevel instead of a simple unification however performance may be a concern general principles here we summarize some key general principles of our learning algorithm the algorithm first learn traces and then infer this is unlike recent work on program synthesis techniques eg that attempt to learn everything at the same time often leading to for learning conditionals the algorithm uses a greedy strategy based on functions to first infer partitioning and then boolean classification the standard way to learn conditionals in recent program synthesis work is to phrase this as a combinatorial search problem using solvers which leads to solutions that may not scale in realtime settings like ours for learning traces the algorithm uses dag based datastructures that can represent and manipulate intersection evaluation computation sets of programs this approach would work in general for any term algebra the dag based datastructure can be to bdds which can represent and manipulate conjunction disjunction negation sets of program states and are popular in the verification community extensions active interaction model for easier interaction a simple interaction model can be to ask the user to investigate the results of a synthesized program on other inputs in the and to report any however this may be in case of large to enable easier interaction we exploit the fact that our synthesis algorithm returns a set of programs the synthesis system can run on every input in the to generate a set of corresponding outputs ie the set can be computed directly without explicitly all programs in this requires exploiting the structural decomposition of the underlying datastructures as is done in and size methods we leave out details for lack of space the synthesis system can then any input for user inspection whose corresponding output set contains at least two strings we refer to this as the active interaction model it is interesting to compare the above idea with the idea of distinguishing inputs that was introduced recently in the context of synthesis of algorithms an application of that idea in our context would mean any two semantically different programs from and then synthesizing an input on which the two programs yield different outputs such an approach would not be effective in our setting since as is illustrated by the in example convergence does not require to narrow the choice of consistent programs down to a semantically unique program in the language it is sufficient to narrow the choice down to that set of consistent programs that are equivalent with respect to the finite number of inputs in the handling the algorithm declares failure when it fails to learn a boolean classification scheme in that case it can attempt to identify any error in one inputoutput example as follows the algorithm an inputoutput example as a if the input belongs to a singleton partition but the boolean classification scheme fails to generate a boolean classifier for that singleton partition for each example the algorithm ignores the corresponding partition and the boolean classification scheme for other partitions if it succeeds it the example as and presents that to the user for validation and can even suggest a fix by running the learned program on the input corresponding to the example example consider the following set of examples provided to our tool in one of the scenarios in which the user failed to correctly in the output column input input jones output d j l the algorithm groups the first and third example in one partition while the second example belongs to a singleton partition the algorithm fails to generate a boolean classification scheme that distinguishes the two partitions ignoring the singleton partition enables algorithm to succeed trivially since there is only one partition the algorithm declares the second example to be and the user to investigate if she really meant j which it generates by running the learned program on the input ranking of multiple solutions for faster convergence selecting an expressive language for inductive program synthesis systems raises an interesting while it makes users who want to program sophisticated tasks it may impact users who want to program simple tasks but now may require to provide more bits for of their which in the need to provide more examples and more of interaction the principle which states that the simplest explanation is usually the correct one comes to our here we define a comparison scheme between different string expressions by defining a partial order between them some of these choices are but have been observed to work well there is also a of this partial order based on the user observed during last few scenarios a constructor is simpler than another one if it contains smaller number of arguments or its arguments are pairwise simpler similarly for constructor and are simpler than all other tokens that extraction logics based on the of strings are more common a token corresponding to a character class is simpler than the one corresponding to a smaller character class we generality here cpos expressions are simpler than pos expressions giving preference to extraction logics based on constant offsets a constructor is simpler than both constructor it is less likely for constant parts of an output string to also occur in the input and constructor if there is a long substring match between input and output it is more likely that the corresponding part of the output was produced by a single substring extraction logic procedures and which generate a set of solutions can take this ordering into account to produce an ordered set of solutions prototype tool we have built the program synthesis system described in this paper as an called for microsoft microsoft is the most used system in the world and is widely regarded to be the of all the program synthesis system has two components a the algorithm described in section which has been implemented in c it is less than lines of code and b the extensions described in section which are supported using a simple but graphical user interface described below user interface the user first selects a region of containing both input and output columns we treat the mostly columns as input columns and less columns as output columns however we also provide the flexibility for the user to select multiple column ranges and identify explicitly which columns are inputs and which columns are outputs since it may be the case that most cells in an input column have null entries while our default treatment would be to regard it as an output column we treat the rows that contain entries for an output column as inputoutput examples for the program to be learned for that column the user then the the system then the as follows it invokes the synthesis algorithm procedure for each of the output column for each output cell in row and output column the system runs the generated set of programs for output column on the input state specified in row to generate an ordered set of possible outputs the system the cell as follows if contains one string the most common case the system the cell with that string if contains multiple strings the system the cell with the first string top solution but it to point out to the user that there are multiple computational interpretations of the few examples provided by the user and that the user may want to investigate the output of the cell if is empty the system the cell with to draw the attention that the user should provide the output for that cell the user may then repeatedly fix contents of any cell by on it a box up that allows the user to choose from other strings in the corresponding sequence or to provide a new output after any such fix the above learning process is automatically repeated with the extended set of inputoutput examples and the contents of are automatically updated to reflect the new learned results evaluation metrics our synthesis system can be evaluated against several metrics stated below algorithmic performance this is a measure of the effectiveness of the datastructures used by the algorithm the algorithm was to take less than seconds on average for a benchmark suite of more than problem instances drawn from online help or obtained from product team as representative examples the examples described in this paper form a representative part of this benchmark suite each problem instance contained up to inputoutput pairs more than what the user would want to provide in any scenario and each string in any pair contained up to characters more than what is typical of cells experiments were performed on a machine with intel cpu and gb ram number of interactive this is a measure of the generalization power of the conditional learning part of the algorithm and the ranking scheme we observed that the tool typically requires just one round of interaction when the user is smart enough to give an example for each input format which typically range from to to start with it is to note that this was indeed the case for most scenarios in our benchmarks even though our algorithm can function without this assumption the maximum number of interactive required in any scenario was with to being a more typical number the maximum number of examples required in any scenario over all possible interactions was success ratio we have not come across any problem instance that can be expressed in our language but our algorithm fails to converge to the correct solution this is a measure of the validity of the completeness hypothesis discussed in section however we have found several problem instances that cannot be expressed in our language most of these instances are related to semantic entity reasoning such as transforming into of the for syntactic string manipulation tasks we have been more than at the expressiveness of our language few testing in the middle of some internal to large where we were to try out modified scenarios on the on real data the tool successfully learned the desired transformations in all those cases following are a few examples of scenarios where was used by to perform tasks beyond the of the author example synthesis of part of a future extension of itself the synthesis system is currently being extended with semantic knowledge of common entities that would allow the system to perform transformations that are beyond the of syntactic computations one of the dictionaries that was recently added to the system was mapping from a international code to the name of that performed this task which he originally thought would take around an in absence of any in less than a using the after copying and the data from into an input input output case return case return string program the above examples were sufficient for to the with the desired output for more than rows each containing data for a different the code fragment in the output column was copied and in development environment as part of a switch statement and it compiled example task to estimate the total number of to links in the directory from statistics consisting of pairs of links and he tried to use the by giving examples where the output column was a copy of the input column only if the input link column contained in the path input input output quite surprisingly for the author the successfully without use of its hidden capability of being able to add new tokens addition of token would have done the trick closer investigation of the generated program another trick for solving the same problem all and only links had occurrences of the token a pattern that could not have been easy for the user to discover string program b where b match and b example arithmetic task the synthesis engine currently does not support any arithmetic reasoning hence we thought that a few examples found on help for computing the sum of all numbers in a string had to wait however showed us a trick that almost did it input output alpha beta popl cav pldi esop string program p p where p pos and p it is interesting to note above how the loop constructor gets used to print all but last numbers each followed by a plus sign the position expression p ensures that there better be another number following the number to be extracted the last integer is then separately the desired sum can now be obtained by the output column as a number inside related work work on learning concepts such as deterministic finite state automata or regular transducers from examples is not applicable in our setting because it requires making many more queries to the user and most string processing tasks described in this paper are more expressive than what can be expressed by these concepts the most closely related work is that of using or examples these techniques may be lifted to the setting but they would not work well because a the real scenarios are more challenging than what these techniques can handle b the interface inherent to most of these techniques requires users to provide much more information that is way beyond the bar in we explain these issues below using is a programming by system for learning commands where the primitive program statements include moving the cursor to a new position and text however there are two significant differences a the language of programs considered is not as expressive as required in the setting in particular it does not provide support for conditionals which are very important for data tasks in hence it cannot be applied for the processing required in examples also its cursor movement logic is restricted to positions either before or after the occurrence of a single token while scanning from left side in contrast our position extraction logic is much more powerful it allows to identify positions based on occurrence of sequences of tokens both before and after the desired position while scanning from left or right side as a result the system cannot be applied for processing required in examples and b more significantly as for any system the user is required to provide a complete or trace where the consists of a sequence of the editor state after each primitive action really out how to do the transformation but on a given example the user is also required to segment each iteration of an inner loop further based systems also have the of being sensitive to the order in which the user chooses to perform actions our system is based on programming by example as opposed to it requires the user to only provide the final state as opposed to also providing the intermediate states this our system much more usable however at the of making the learning problem much more difficult for which we do present an effective algorithm is another system that records highlevel actions similar to the actions used in and implements a set of rules for generalizing the arguments of each of the actions however dependence on heuristic rules to describe the possible makes it difficult to understand the hypothesis space clearly as well as to imagine applying it to the different domain of applications simultaneous editing is another system that allows the user to define a set of regions to edit and then allows the user to make edits in one while the system makes equivalent editing in all other records the inference used in simultaneous editing is much less powerful since it does not support conditional or edits every editing action is applied uniformly to every record using examples described a system that gap programs based on examples a gap program is a collection of pattern replacement pairs where each pattern is composed of constants and variables that bind to the text in between the constants and a replacement can be a constant string or a variable from the input pattern gap programs are not expressive enough to represent the solution of most of the string processing benchmark examples described in this paper data processing for programmers the pads project has enabled simplification of ad hoc data processing tasks for programmers by along several dimensions development of domain specific languages for describing text structure or data format learning algorithms for automatically inferring such formats and a language to allow users to add simple annotations to enable more effective learning of text structure the learned format can then be used by programmers for documentation or implementation of custom data analysis tools in contrast the focus of this paper is to enable to perform small often tasks on their data to provide annotations for learning relatively simple text structure and then develop custom tools to the inferred structure is way above the and bar for these users hence we are interested in the entire process which includes not only learning the text structure from the inputs but also learning the desired transformation from the outputs algorithmic techniques provides a good survey of various program synthesis techniques exhaustive search logical reasoning probabilistic inference and algebras exhaustive search based techniques would not scale for our problem setting since the underlying state space even for programs of small bounded size is logical reasoning techniques such as those used in learning programs from inputoutput examples or programs from logical specifications are not suited for various reasons they are not as scalable several are acceptable for discovering a new algorithm but not for an interactive session they cannot deal with in the user input they cannot easily compute all solutions required for providing various computational interpretations to the user for an ambiguous input the part of the synthesis algorithm presented in this paper is to the algebra approach that involves maintaining a set of all hypotheses drawn from a hypothesis space that are consistent with a sequence of observed examples mitchell originally used this idea for learning of boolean functions while extended the concept to learning more complex functions in a setting our synthesis algorithm shows how the concepts of algebra can be lifted to the programming by example setting for a fairly expressive string expression language involving conditionals and loops the idea of using dags as the version space for constructor is inspired by the use of a similar datastructure in a very different context of solving an important open problem related to global value numbering the novel concepts introduced in this paper are quite general we feel that they might be used to create versions of other algebra based systems eg those that learn scripts or imperative python programs conclusion general purpose computational devices such as computers are accessible to people at large at an rate in the future will become entities but unfortunately programming general purpose platforms has never been easy because we are still mostly stuck with the model of providing detailed and syntactically correct instructions on how to a certain task instead of simply describing what the task is program synthesis has the potential to change this when for the right set of people for the right set of problems and using the right interaction model in this paper we have identified a application that of string processing in which of of with on a regular basis as is evident from online help and to product groups we have developed an efficient algorithm to help a variety of string processing tasks from inputoutput examples which we found to be the most natural expression mechanism on help we have special attention to issues and the line from developing an technology to one that is ready to be acknowledgments thanks to who had such a in the of this technology that he find connections in product even before a prototype could be built thanks to the product team who kept with us despite their initial whether such a technology can ever be possible thanks to for building a ui for the tool thanks to and for adding new features and taking the technology to another level details of which are beyond the scope of this paper thanks to and david walker for useful discussions finally to my parents and for the best after with the tool for the first time we understand what your research is about references d learning regular sets from queries and counterexamples inf comput ­ k and r pads a domainspecific language for processing ad hoc data in pldi pages ­ k y and d walker the next data description languages in popl pages ­ k d walker k q and p white from to fully automatic tool generation from ad hoc data in popl m developers to and reduce costs in report for application development and program management april s gulwani dimensions in program synthesis in acm s gulwani and g c necula a polynomialtime algorithm for global value numbering in sas pages ­ s s gulwani s and a program synthesis in a j ko b a myers and h h six learning barriers in programming systems in pages ­ t why systems fail learned for usable ai in workshop on usable ai italy t s p and d programming by using version space algebra machine learning t l v and d programming scripts by in workshop on t a p and d s version space algebra and its application to programming by in t a p and d s learning programs from traces using version space algebra in pages ­ r c and b a myers interactive simultaneous editing of multiple text regions in usenix annual technical conference t m mitchell generalization as search r p editing by example toplas ­ s russell and p artificial intelligence a modern approach nd edition prentice hall edition december s s gulwani and j foster from program verification to program synthesis in popl j m query learning of transducers in proceedings of the rd international colloquium on inference j formulas john and sons i h and d mo learning text editing tasks from examples in what i do programming by pages ­ mit press cambridge ma usa q xi and d walker a contextfree language for text in pldi pages ­ 