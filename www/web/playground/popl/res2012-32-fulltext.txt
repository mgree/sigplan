sound predictive race detection in polynomial time university of and university of massachusetts m university of massachusetts yi flanagan university of california at abstract data races are among the most reliable of programming errors in concurrent software for at least two happensbefore hb relation has as the standard test for detecting techniques such as approaches fail to be sound as they may of races this work introduces a new relation cp which generalizes happensbefore to observe more races without soundness intuitively cp tries to capture the concept of happensbefore ordered events that must occur in the observed order for the program to observe the same values what distinguishes cp from past predictive race detection approaches which also generalize an observed execution to detect races in other executions is that race detection is both sound and of polynomial complexity we demonstrate that the unique aspects of cp result in practical benefit applying cp to realworld programs we successfully analyze applications eg and show that traces longer than in past predictive race analyses can be analyzed in seconds to a few for these programs cp race detection races that are hard to detect by repeated execution and hb race detection a single run of cp race detection produces several races not discovered by separate of happensbefore race detection categories and subject descriptors d concurrent programming d verification general terms languages reliability verification introduction data races are the most common of a programming error in the central field of concurrent programming two memory accesses are conflicting if they are performed by different threads they access the same memory location and at least one of them is a write a data race is then typically defined as two concurrent or unordered or not conflicting accesses typical modern dynamic race are based on one of two principles happensbefore hb ordering or computation race follow an idea by and attempt to detect inconsistent use of locks for access to the same memory location by different threads permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright © acm this approach has the advantage of detecting many races even if these are not observed in the execution being for instance if the records two write accesses by different threads to the same memory word without holding a common lock it will report a possible race the of race is that they are unsound the reported races are often spurious since the two events may be via other thread communication eg the prior reading of a flag indicating that the thread can now freely read shared data without synchronization consider for instance the example execution in figure our convention is that events occur in the total order of the observed execution we use the standard syntax for the of lock l and for the of variable x thread thread wy wx q rx ry figure example of no race on variable y although the two accesses to shared variable y do not occur with the same lock held they are second access only occurs after thread has observed a value written by thread it is quite possible that if the two critical sections over lock l had been thread would not have to read y since its read of x would have a different value in our work we focus on sound race detection races are extremely hard to and false positives to the user reduces the of a race detection tool sound race detection is a feature of happensbefore based approaches hb race attempt to when there has been communication that effectively orders the two conflicting events unordered events are reported as a race since there is no reason why they could not have occurred at exactly the same instance in its simplest form happensbefore is a partial order that generalizes the observed total order of a multithreaded programs execution by · ordering all events by a single thread in the order they were actually observed · ordering lock and subsequent of the same lock in the order they were observed all events unordered by happensbefore are then considered to be potentially performed simultaneously under the assumption figure example program that threads can only communicate via mechanisms represented in the hb order this approach is sound consider again the above class int execution trace the hb edge shown as an arrow int count counts accesses together with the transitivity of the hb partial order ensure that the two writes to y are thus no hb race is reported static pc new the problem with plain happensbefore race detection is that it can miss many races due to hb edges the original void r definition of happensbefore by lamport was in the context of distributed systems with an hb edge introduced for explicit communication lock synchronization does not induce the same hard ordering as explicit communication however a critical section can often be with others as long as lock semantics mutual exclusion is preserved consider the count r int int t t code example shown in figure in this example the count class has two fields and protected by the object lock return t this the count field the number of accesses to and and the main method two concurrent threads this program has a race condition on count unfortunately precise race public static void args such as or fail to detect this race condition on of test runs fork fork figure a illustrates the essence of the problem by showing the trace that the jvm typically generates for the program of figure with no overlap between the executions of the two threads for this trace a happensbefore race would not find a race on count since the lock release by thread happensbefore the lock acquire of thread thereby the lack of figure example traces for the program synchronization between the accesses to count in contrast trace b presents a different scheduling where there is clearly a race on thread thread thread thread count by inspection we are able to predict from trace a that a race condition could occur as in trace b we say that trace a has a race our work consists of defining a new relation cp by analogy to happensbefore to detect such races a race occurs if two conflicting actions are not unlike prior precise race a race can detect race conditions as in figure the essence of detecting this race is that the critical section of thread has received no information that can reveal whether the critical section of thread has already executed or not more precisely reordering events as in trace b thus an hb race maintains the property that tool report tool report all read operations return exactly the same values as in the happensbefore no race happensbefore race call this a correct reordering of the observed race race behavior a correctly execution is just as feasible as the observed one a race condition b happensbefore race some previous work has addressed the problem of latent races in the context of happensbefore race detection this work typically comes under the label of predictive race in contrast our work offers the first sound yet scalable tech sis and is a subset of the general area of predictive and for predictive race detection specifically cp the ing concurrency analysis ­ the main hb order while still maintaining soundness cp is guaranteed to idea of this body of work is to consider which of the correct re have a polynomial cost of evaluation and our efficient orderings of critical sections would have a race in an hb tation allows this into a linear cost by limiting the size of the problem with a approach is that it the reordering window cp race detection results are not complete requires exploring all reorderings of critical sections to determine examining all correct reorderings of the original trace would which ones are correct and produce a race this exploration is an an exponential search consequently our may miss expensive process the space of possible reorderings is exponential some races nevertheless it is guaranteed to detect a superset of and executions with races are often hard to discover when applied the observed happensbefore races and to only give warnings for to dynamic ie runtime race detection the predictive runtime true races more accurately the soundness theorem we prove is analysis technique can be understood as a hybrid of testing and more subtle if our issues a there is either a cor model checking reordering of the observed execution that an hb race or a reordering that a deadlock thus our race soundness guarantee only applies to programs yet in practice although this definition only covers locks other communication can be captured as happensbefore edges our sound of a possible deadlock is just as valuable as a of a race specifically our work makes the following contributions · we present a weaker relation than happensbefore yet the same desirable features cp leads to sound race detection and can be evaluated efficiently in polynomial time it is worth that multiple researchers have such a weakening of hb in the past we demonstrate with numerous examples why it is not easy to weaken hb while remaining sound both the definition of cp and our proof of soundness are results of work with several intermediate failed attempts · we present an efficient implementation of cp although the relation is polynomial practical race detection can even quadratic complexity an n algorithm with n being the number of observed events is in practice with event counts in the we implement our algorithm in datalog for declarative logical reasoning and apply successive optimizations first to make the algorithms complexity depend only on synchronization events and then to derive a family of linear algorithms by allowing finite reordering windows · our experiments the advantages of cp and our implementation the extra races detected are among the to discover with plain hb analysis a single race detection run several new races by independent runs of plain hb race detection our implementation avoids past scalability if we examine races appearing within a finite reordering window eg shared memory events we can achieve linear runtime costs for our analysis even for realworld programs and the rest of the paper introduces our relation section illustrates the kind of reasoning it supports and its soundness properties section describes our implementation section presents experimental results section and discusses related work section before section we next introduce our new relation and subsequently illustrate it via examples definitions we consider a standard model for assigning semantics to a concurrent execution that is all events are observed in a total order and we define our concepts relative to the observed order events have the form t ai where t is the thread performing the event and i is the events index in the total order the action a performed by an event is of the form wx rx and thread creation and joining can be added straightforwardly as explicit edges for simplicity we do not discuss these events in the examples definition happensbefore in this framework the happensbefore hb relation is defined simply as the smallest relation that satisfies the following we use as a dont care value · events by the same thread are ordered as they appear this partial order of events in a trace is also called program order po t i hb t i if i i · and of the same lock are ordered as they appear t hb t if · hb is closed under composition with itself hb hb hb we also assume two relations · the binary relation read conflicts two events by different threads conflict if they both access the same variable and one of the actions is a write · the function that maps a lock acquisition event to the corresponding lock release ie t if there is no t with in this case we say that t is with t is a function for a wellformed execution so we also consider its inverse definition precedes precedes cp is then the smallest relation such that a cp has a edge between critical sections over the same lock that contain conflicting events t cp t if there are t k t k such that k k where t and t b cp has a edge between critical sections over the same lock that contain events these events can be lock acquisition or release events and not necessarily internal events in the critical section because of rule c below this condition turns out to be equivalent to the weaker and of the same lock are ordered if the beginning of one critical section is with the end of the there is an hb order between the start of a critical section and every internal event as well as all internal events and the end of a critical section t cp t if cp c cp is closed under left and right composition with hb cp hb cp cp hb note that cp is a subset of the happensbefore relation the three cases of the cp definition we see that all cp edges produced by the first two rules are edges on the same lock and so are also hb edges the third rule then states that cp is closed under composition with hb which still produces a subset of the hb edges since hb is closed it is similarly easy to see that cp is transitive definition we define a race or when we need to distinguish from happensbefore races to be a pair of conflicting events that are not in either direction illustration there are a few aspects of the definition of cp that should be for clarity probably most important among them is that cp is not a reflexive relation if it were rule c would make cp equal to hb consequently cp is also not a partial order recall that we want cp to retain only some of the hb edges ie ordering dependencies in a way that captures which conflicting events could have simultaneously in a but execution consider again the example of figure from section and observe that the shown hb edge is not a cp edge none of the events shown are they constitute a and a race the same occurs in the execution of figure in this section we try to a balance between precise presentation and avoiding tedious definitions for concepts we thus try to be more formal when defining elements unique to our approach and otherwise rely on the preconditions for a wellformed trace such as pairing of lock and of critical sections are omitted here but stated fully in our proof of soundness thread thread wy q wy figure another example of a certain race not reported by hb in both cases the critical sections do not contain conflicting events which would order them per rule a of the cp definition in contrast figure in section no cp race report the hb edge is also a cp edge per rule a and rule c can then be used to the two operations on variable y indeed rule a of the cp definition is almost to see this consider what a feasible execution definition correctly we say that an execution ex correctly cr another execution ex also written ex cr ex iff ex is a total order over a subset of the events of ex that · contains a prefix of the events of every thread in ex and respects program order ie if an event e in ex appears in ex then all events by the same thread that e in ex also appear in ex and e · for every read event that appears in ex the most recent write event of the same variable in ex is the same as the most recent write event of the same variable in ex the definition of cr matches the intuition for feasible alternative executions if every value read is the same as in the observed execution then the alternative is certainly also feasible in this light rule a from the definition of cp is intuitively clear as far as later events are concerned two conflicting events have to occur in the same order in every execution thus conflicting events induce a hard ordering dependency if it is certain that they do not constitute a race in this case because they are protected by a common lock since two critical sections over the same lock have to be ordered in their ie all events of one have to all events of the other the ordering constraint on conflicting events becomes an ordering constraint on the entire critical section containing them the same reasoning applies to rule b of the cp definition if two events internal to respective critical sections are then the entire critical sections are also rule c is the most interesting aspect of the cp definition the rule is both very conservative and surprisingly weak in different ways intuitively rule c is directly responsible for the soundness of cp once some evidence of event ordering is found all earlier and later events in an hb order automatically maintain their relative order this conservative aspect of the rule is necessary for ensuring that a cp race indicates that the events could have been concurrent at the same time rule c is quite weak consider three events e e e it could be that e cp e e hb e and consequently e cp e this still does not mean that e cp e even though the hb order between e and e is what allows e to cp e this aspect is what prevents cp from missing the possibility of races as in even when it assumes conservatively that certain reorderings are not possible in order to maintain soundness this pairing of a read with the most recent write event implicitly introduces sequential consistency as an assumption nevertheless this is not a constraint every hb race is a cp race in case no hb races are observed for an execution a relaxed memory model yields sequentially consistent behavior thus our assumption is valid complications and soundness we discuss the of cp through examples of executions such examples naturally lead to the statement of our soundness theorem and its proof example reasoning for each example it is interesting for the reader to consider independently whether there is a race or not reasoning about concurrent executions is quite hard even concise examples require exhaustive of a large number of possible or complex formal reasoning to establish ordering properties in the following examples we expressed the constraints as symbolic inequalities with eg this event is either before that or after the other and proved manually they were unsatisfiable figure contains a first example that suggests why sound predictive race detection is hard in the presence of many threads and nested locks we use the shorthand for a sequence of events that induces an ordering with other identical sync sequences eg can be short for for ease of reference cp edges produced by rule a of the cp definition are shown in the figure as arrows thread thread thread ss wx gg wz zz rz wz wx figure no race between the two writes to x in any correctly execution arrows show the hard cp constraints ie cp order because of rule a of the cp definition can be thought of as there is no race between the two writes to x in the above example any correct reordering of the execution will have the three sync sequences and the critical sections over lock m ordered in the way they were observed resulting in an ordering of the two writes interestingly the empty critical section over l in thread is necessary or there would be a race the cp definition captures this reasoning accurately rule b is essential in establishing that the two critical sections over lock l are because of rule b the end of the critical section over l in thread is relative to the empty critical section over l in thread since cp with hb to yield cp the event in thread is with in thread thus rule b for another interesting example consider figure there is no race on x in this example but establishing this fact requires reasoning involving both the hard ordering constraints induced by sync sequences and the semantics thread thread thread thread tt tt tt tt ww tt tt figure trace with no on x and identity of locks eg the fact that the critical sections on n cannot overlap cp avoids such reasoning but gives an accurate result the two critical sections on n are not and also do not necessarily occur in the order shown in a correctly execution the two critical sections on m however are and also necessarily in the order observed again we see the interesting aspects of rule c of the cp definition even though the hb order between the critical sections on n is what enables the cp order between the critical section on m the former does not get to a cp order figure presents another example thread thread thread thread wx wx zz figure no race between the two writes to x this execution does not have a race on variable x nevertheless the reasoning required to establish this fact can be quite complex removing events can easily result in a execution for instance removing the edge allows a race by moving the entire set of actions by thread and thread before those of thread and thread detecting races can often require complex reorderings of events the value of a polynomial but sound predictive race is that it avoids exploring all such reorderings consider the case of figure there is a between the two writes thread wx thread wx thread wx thread wx figure the hb race on x execution on the left requires a complex reordering of events shown on the right to variable x there is also a race it is not possible to expose this however without thread scheduling that breaks up the outer critical sections as shown on the right part of the figure cp does not need to the schedule in order to of a possible race at the same time however cp often avoids complex nested lock reasoning by not distinguishing between a race and a deadlock our soundness theorem has an interesting form a is a sound of either a race or a deadlock in a correctly execution the deadlock is immediately apparent there is a cycle in the graph to see this consider the example of figure thread wx thread wx thread thread figure the observed execution left has a between the two writes to x there is no race however instead it is easy to events to expose a deadlock see right there is a between the accesses to variable x in this example yet there is no hb race no correctly execution can have the two write events without synchronization between them the cp soundness theorem states that this is only possible when a reordering can expose a deadlock due to threads locks in a way that introduces a cycle in the acquisition dependencies the above examples offer the reader a of the of defining cp and proving its soundness the difficulty of reasoning about event order the challenge of defining a relation that the observed ordering much more than happensbefore yet at the same time is guaranteed to be sound a race analysis has to either perform heavy reasoning or to conservatively assume ordering every time events may be ordered rule c of the cp definition plays this role but it is still hard to prove that it is conservative enough the conservative ordering is of course hb all critical sections are assumed to always be precisely in the order they were observed soundness we now state more fully our assumptions on the execution form as well as our soundness theorem our assumptions include the of locks as well as standard lock semantics definition trace a trace is a total order of events such that acquisition of a lock is not followed by another acquisition of the same lock without an lock release critical sections are more explicitly if an acquisition of lock l is performed after an acquisition of lock l by the same thread and before ls release then the release of l cannot appear before the release of l does our main soundness theorem has a simple statement theorem cp is sound given a trace tr with a we can produce a tr cr tr with either an or a deadlock the full proof can be found in the appendix note that the statement of the theorem applies only to one cp race and since cp is a subset of hb every is also a that is the theorem proof establishes that either the first of a trace is an in some correct reordering of the trace or we can produce a correct reordering with a deadlock the idea of stating the soundness guarantee so that it applies to the first error reported is standard the first race is the one that in the total order of the trace ie a between events e t ui and e t u j with i j such that that there is no between two events both of which appear before e as well as no race between events ee with e appearing after e and before e although the theorems guarantee applies to only one race we can conservatively maintain soundness when multiple races at the cost of potentially missing some specifically once a which may be merely an is discovered and reported the rest of the trace can be treated as if the were a cp edge thus the two events this means that the soundness guarantee of the theorem then applies to the next reported any correct reordering of a restricted trace ie one with extra cp edges is a correct reordering of the original trace the is that some another cp race may not be reported due to our conservative treatment the form of the soundness theorem is quite interesting although a cp race implies a race only in programs this is a pointing out a potential deadlock is at least as important as pointing out races furthermore deadlocks are an easier problem to dynamically detect or statically eliminate therefore we expect cp warnings to be almost always correct race warnings implementation cp reasoning based on definition is highly recursive notably rule c can into rule b which can back into rule c as a result we have not implemented cp using techniques such as vector clocks nor have we yet discovered a full cp implementation that only does online reasoning ie never needs to look back in the execution trace these remain challenging questions for future work however cp has an easy polynomial algorithm derived directly from the definition we express this algorithm in the datalog language datalog programs have guaranteed polynomial complexity and datalog can express any polynomial algorithm consider a trace of execution expressed via the input relations of figure we report errors of the form instruction x accessed memory location y in a way that races with instruction z e what is the next event after e t what is the thread performing e m e is a lock acquire for mutex m m e is a lock release for mutex m x e is a write for variable x x e is a read for variable x figure input relations for our datalog algorithm datalog code notation a relation in the form value is a function the left arrow symbol is the implication used for inference ie if the right hand side is true the left hand side fact is inferred is the logical or operator we can then straightforwardly define concepts such as critical sections matching operations etc these are captured by relations event e is in the critical section starting at and event is the lock release with lock acquisition this allows defining hb and eventually cp as in figure figure straightforward cp logic in datalog having a polynomial algorithm is not sufficient for scalability however realistic executions can have of significant shared memory events significant events are those remaining after elimination of events that will not affect the of a repeat accesses to the same shared memory variable by the same thread without synchronization operations defining relations such as hb or cp on a of events is in our implementation we address this challenge in two ways · we compute quadratic relations such as hb or cp only on lock acquisition and release events the hb and cp order on regular memory events is then computed based on the hb and cp order of synchronization events this is already shown in the code of figure · we do not fully compute hb or cp but instead maintain a finite window k of allowed distance for event reorderings typically or significant shared memory events and are guaranteed to be conservatively computed for e and e less than k significant events apart this strategy effectively makes our race detection often be of practically linear complexity we only relate every event with at most k others our implementation does have some remaining n or higher asymptotic complexity parts but for relations that are expected to be small a exception in practice is long critical sections for which we have to relate all events to all others thus quadratic complexity the strategy also means that our algorithm will only detect and report races between events less than k significant events apart our computation of cp for only a finite window is implemented by computing a relation and various of it for events by the same thread synchronization actions etc these relations are then throughout the implementation to restrict computations that require of every pair of events importantly this means that our main implementation logic differs from the simple form of figure in particular all rules need to both have a filter so that they trigger accurate computation only when events are within a distance of k as well as a conservative closure so that a sound overapproximation of cp is computed when there is a possibility of missing an ordering due to the finite window this is well illustrated by looking at the form of the second rule of the cp definition which is also the second rule in figure in the implementation the rule is broken up in two the version for when cp is accurate the version for conservative cp when the base cp information may be this approach allows us to maintain soundness while achieving scalability additional optimizations in our implementation include manual indexing for efficient relational joins as well as join order optimizations experiments we evaluated the performance and prediction capability of our cp race on a collection of multithreaded java benchmarks mostly from previous studies one may argue that even an exponential search algorithm can become linear by limiting its search space to a finite window but the constants space and time overhead would be in that case our limiting the window is practically feasible exactly because computing cp has a reasonable asymptotic complexity in the first place the most substantial of our benchmarks are · web server coupled with a test · a server implementation from the foundation coupled with a · a part of the project a implementation of the java map interface the code size of this benchmark is small but its driver it resulting in a long trace to perform the cp analysis on the benchmarks we used the framework to dynamically the bytecode of each benchmark at load time the instrumentation code creates a stream of events for field and array accesses synchronization operations thread etc we used this infrastructure to perform an happensbefore race analysis and to also produce a trace subsequently used for the cp analysis the cp analysis was thus explicitly coded to report races if they were not also hb races since the latter were discovered and reported already we conservatively translate accesses to variables and thread events into accesses the traces produced are quite even though references are out the traces are then reduced to only maintain events concerning shared memory locations and to eliminate to the same variable by the same thread without synchronization the reduced trace is then imported into a database and analyzed using our datalog implementation the first columns of table show the main metrics for our benchmarks the benchmark size in loc is not entirely representative of its complexity for our analysis much of the code in a programs directory is library code not at all conversely much of the code actually is java library code never shown in the benchmark size library code is still valuable to analyze the code may not contain races but may be used in an unsafe way a race in client code is the most extreme example if we were to report its code size uniformly with the other benchmarks it would come to the directory contains the entire collections project however the main class and test driver file are just loc neither of the two sizes is representative of the code actually though the second is closer similar apply to the report of thread counts this metric lists the total number of thread created which can be higher than the number of threads active simultaneously table collects the results of our experiments we use a commercial datalog engine by inc on academic all analysis was done on a machine with a dual six core intel x processor and gb of ram the cp analysis implementation is singlethreaded hence only one core was active at a time we performed cp analysis with the reordering window k significant events as described in section we report the races found in a single hb run in hb runs as well as the races found by cp in its single run but never found in the hb runs races are reported ie dynamic race instances are based on which data words they occur on still multiple races may have the same underlying cause eg a single missing may fix more than one race furthermore recall that our soundness guarantee only applies to the first race and ensuring that all race reports are sound requires which we currently perform manually and requires multiple of our analysis for these reasons the number of races and running times should be viewed trace size events race conditions detected original reduced hb run hb runs cp programs pool pool vector size loc k k k k k k see text k k k k k k k k k k k k k thread count time s s m s s s s s s m s s s s table benchmark metrics and number of races detected by our cp analysis but not found in hb runs as well as time taken for cp analysis running times of sec are effectively zero this is the overhead of the datalog engine and data from text files only as an of the utility of our approach a likely way our analysis would be used by a programmer in practice would be not to report all races but by analyzing a trace the first race in the code then the results are representative of the position of our approach relative to others as can be seen in table of these benchmarks ie produce reduced traces fewer than events with of them having fewer than these brief executions offer little to detect hb races and no to correctly events for all of the traces cp does not discover any races that are not hb races nevertheless a approach would report races even for these executions since it is easy to observe when a shared variable is accessed by a different thread with a disjoint set of locks held this illustrates quite well how unsound race a different problem unsound predictive analyses possible race conditions whereas our work focuses on proving the presence of race conditions is another benchmark that is mostly although its trace is longer than the ones it is still fairly short k events and has neither hb nor cp races the study and the said et al work showed no races on either despite using an unsound analysis and an smt solver that all valid trace reorderings respectively the real benchmarks for our approach are the three longer traces and it is to compare results with hb clearly hb race detection and cp race detection are different in nature the cost of our current cp analysis is at least orders of magnitude higher than the cost of hb race detection nevertheless the goal of cp is to perform a deep analysis implicitly considering event reorderings and to find hard races which a plain hb analysis would not normally detect for both and race detection several races that were not exposed by any of the happensbefore race runs this ranges from to or an average of new races for these two benchmarks that cp race detection can target deeper races than typical hb examining the intermediate results of our analysis indicates that cp is a much weaker relation than hb the number of cp edges computed by our analysis among synchronization operations is typically as low as to of the number of hb edges for these benchmarks thus happensbefore race detection often considers events to be ordered when there is no semantic reason why they should be is our final benchmark it has a long execution covering very little code thus cp only reports races also detected by hb this is the inverse problem from that of the traces cp does not over hb not because of coverage but because of coverage of the possible executions it would be interesting in the future to perform a sensitivity analysis and create runs of several sizes both for as well as for the programs with smaller traces to see at what point cp starts detecting more races than hb and when hb up this requires extensive knowledge of the benchmark programs however the table also shows that the time required for cp analysis is quite low although there is certainly room for further improvement of our cp implementation for small traces cp analysis is almost for traces with long critical sections many threads and deep lock nesting the analysis time grows still the overall scalability of cp analysis far reported numbers for past sound predictive concurrency analyses in the literature for instance said et als technique takes sec to analyze a k event trace the longest trace analyzed by said et al is much smaller than ours at k events long yet even this size may be since the trace is for which performs a number of events relative to the original trace length we are not aware of a sound predictive analysis that can scale to executions at the level of our reactive applications and with a running time in the low related work our approach is distinguished from other related work by maintaining precision while generalizing beyond an observed trace and polynomial complexity and achieving scalability we discuss other precise predictive and other dynamic approaches in some depth and briefly overview other race detection techniques predictive approaches the most relevant work to our precise race prediction technique ­ was briefly discussed in section and section such work is typically a hybrid of testing and model checking and does not achieve the polynomial complexity and scalability of race detection for instance in the recent work by said et al scalability relies on a modern smt solver and an efficient encoding of the problem another interesting idea that past work has explored is causality which makes use of a priori control and dataflow dependence information to obtain a reduced slice of the happensbefore partial ordering for a particular observed trace race conditions are with causality by only the relevant operations in a program trace and modelchecking all feasible trace permutations in a analysis phase these permutations are sound because one may infer and ignore irrelevant operations via static dependence information the soundness of the follow from the soundness of the trace permutations generated causality requires two static analysis phases for prediction this approach can detect races that our approach does not recall that our execution always respects event order however our definition of causality is explicitly towards mechanisms that do not perform static program analysis and thus cannot tell whether a value read by a thread subsequent values produced by the same thread our order to also take such dependences into account instead of assuming that every value read by a thread affects all subsequent thread actions is orthogonal to the core properties of the definition among this work the tool is distinguished by explicitly producing a polynomial algorithm for race detection nevertheless in order to do so the general soundness guarantees of the theory that it the main soundness theorem of the work which applies to more than race detection states that every produced consistent permutation corresponds to a possible program execution nevertheless generating all the consistent permutations of a partial order is a problem to avoid an exponential search two for the case of race detection the first is avoiding a search of permutations events are processed following the order of the original execution for predictive power relies on an unsound definition of what a race def of the definition to causality the criterion for race detection two conflicting accesses that occur without holding a common lock are considered to race the examples of section assuming a program text that causes the events in the order shown under the causality criterion result in false race reports under this definition the second is in the implementation which performs a single slicing traversal of the trace also resulting in another interesting predictive approach consists of reordering models that are more permissive than our relation on executions past work assumes that threads only communicate via holding locks and not by writing to shared memory locations any trace that holds the same locks in the same order of nesting is considered an appropriate generalization of the observed behavior in that predictive model the system then adds soundness back by trying to the atomicity violation through changes to the scheduling of a real execution the published experiment numbers imply that their approach does not scale at or the level of cp race detection and can from high costs in small yet complex executions nevertheless there cannot be a valid comparison since is an atomicity violation and not a race thus addressing an inherently harder problem combinations of approaches along these lines should be interesting future work dynamic analysis happensbefore approaches numerous tools are based on happensbefore relation these tools are more precise than race but are often less efficient uses clocks along with dynamic escape analysis to performance et al provide an alternative algorithm to the simple happensbefore analysis that uses a linear amount of storage happensbefore race have also been applied to nested parallelism the algorithm is an efficient happensbefore vector clock algorithm that uses the optimization for a x performance improvement improves upon by using an adaptive lightweight representation for the happensbefore relation and by introducing optimized fast paths that account for approximately of operations encountered in a trace and provides a x performance improvement over improves on the performance further by sampling techniques approaches a for a shared variable is the set of locks that protect access to that variable were introduced as an alternative representation to the happensbefore analysis later were used alone as an efficient technique for data race detection in every cp race and hence every hb race is also a race since the absence of a cp edge between conflicting accesses to a location means that there is no consistently held lock for that location consequently a race would detect all races detected by cp and may also report many additional warnings in practice many of these extra warnings are false alarms that do not correspond to actual races various refinements and extensions for have been proposed static escape analysis can improve performance reasoning about races at the object level instead of the memory word level improves performance but leads to more false alarms the technique was also extended with timing thread segments to reduce false positives caused by data not being protected by a lock during an initialization phase further performance use static analysis to reduce the amount of instrumentation necessary or involve type inference algorithm has also been extended for the java memory model and implemented with aspectj hybrid techniques recent work on dynamic data race detection focuses on combining and happensbefore analysis and developed a scheme a first pass analysis filters out problematic fields for a second pass hybrid analysis uses a happensbefore analysis to estimate whether threads can concurrently access a memory location so as to reduce false positives caused by empty presents improved versions of happensbefore and algorithms enable happensbefore approaches to report additional warnings and reduce the number of vector clock comparisons needed in the happensbefore analysis combines and happensbefore in an way by using to efficiently track the happensbefore relation this precise complicated analysis is embedded in a java virtual machine to enable continuous monitoring of race conditions other approaches several static approaches exist to deal with data races type systems and languages have been proposed to prevent races in programs other static approaches include and for c programs scalable analyses and approaches aiken and also investigate static race detection focusing on programs approaches such as model checking involve running the target program with many different thread schedules either concretely or symbolically takes potentially access pairs and uses a randomized scheduler to note that the algorithm which reasoning is also slightly incomplete in how it reasons about threadlocal data and so may miss some real hb or cp races the execution to exhibit an actual race condition it would be interesting to try to combine such techniques with our approach which is explicitly towards discovering hard races without exploring many complex interleavings conclusions precise race are important tools for developing reliable multithreaded programs while avoiding the costs associated with false alarms we showed how to extend the traditional notion of race detection to also support race prediction without scalability or soundness our work introduces the novel concept of the relation which significantly hb we prove that cp race detection is sound and demonstrate its practical value defining and proving the soundness of cp was far from trivial both tasks possible only after several failed attempts and significant work we believe that our research can open several for further work first it is quite possible that a more efficient implementation of cp can be derived to push performance further by at least an order of magnitude and even bring it to levels comparable to hb such a development may for instance be based on a novel summarization of cp information using vector clocks or on the use of binary decision diagrams to represent datalog relations we could try the engine for this purpose a second possibility is that of defining other relations that weaken hb in a sound yet efficient way finally we the underlying notion of trace prediction based on the relation may also provide benefits when checking properties such as atomicity and determinism acknowledgments we would like to thank gupta and the anonymous reviewers for their valuable comments that the paper this work was by the national science foundation under grants and we thank inc for providing the platform used for our implementation and for continuous support references m abadi c flanagan and s n types for safe locking static race detection for java transactions on programming languages and systems toplas ­ r a l wang and s d optimized runtime race detection and atomicity checking using partial discovered types in international conference on automated software engineering a aiken and d barrier inference in symposium on principles of programming languages popl d f r e and a a of java without data races in objectoriented programming systems languages and applications oopsla u b z ma and p a theory of data race detection in workshop on parallel and distributed systems testing analysis and debugging e and k effective race detection using aspectj in international symposium on software testing and analysis m d k e and k s proportional detection of data races in conference on programming language design and implementation pldi c r lee and m rinard a type system for preventing data races and deadlocks in java programs in objectoriented programming systems languages and applications oopsla f chen and g concurrency errors at runtime using causality technical report department of computer science university of illinois at f chen and g parametric and causality in computer aided verification cav f chen t f and g effective predictive runtime analysis using causality and atomicity technical report university of illinois at department of computer science october f chen t f and g a predictive runtime analysis tool for java in international conference on software engineering jd k lee a r v sarkar and m efficient and precise detection for multithreaded objectoriented programs in conference on programming language design and implementation pldi m and k d data race detection for java in international conference on computational science a and e detecting access in programs with critical sections sigplan notices ­ m b and l a clarke data flow analysis for verifying properties of concurrent programs in international symposium on foundations of software engineering t s qadeer and s a race and java runtime in conference on programming language design and implementation pldi m s qadeer and z scheduling in symposium on principles of programming languages popl d r and k effective static detection of race conditions and deadlocks in acm symposium on operating systems principles a p and f for atomicity violations under nested locking in computer aided verification cav c flanagan and s n efficient and precise dynamic race detection in conference on programming language design and implementation pldi c flanagan and s n the dynamic analysis framework for concurrent programs in pages ­ c flanagan s n and j yi a sound and complete dynamic atomicity checker for multithreaded programs in conference on programming language design and implementation pldi d typesafe in in workshop on types in language design and implementation j j runtime checking of multithreaded applications with threads in international workshop on model checking of software d p c e and j wang detecting data races by analyzing sequential traces in intl conference on system sciences v f and a gupta reasoning about threads communicating via locks in computer aided verification cav v and c wang universal causality graphs a precise happensbefore model for detecting bugs in concurrent programs in computer aided verification cav s k s qadeer and z static and precise detection of concurrency errors in systems code using smt solvers in computer aided verification cav l lamport time clocks and the ordering of events in a distributed system communications of the acm ­ july j w and s v the java memory model in conference on programming language design and implementation pldi j m detection of data races for programs with nested parallelism in m s qadeer t ball g p a and i finding and in concurrent pro grams in operating systems design and implementation m a aiken and j effective static race detection for java in conference on programming language design and implementation pldi h detecting data races using dynamic escape analysis based on read barrier in virtual machine research and technology symposium vm r and jd hybrid dynamic data race detection in symposium on principles and practice of parallel programming e and a efficient data race detection in c programs in symposium on principles and practice of parallel programming e and a efficient data race detection in multithreaded c programs concurrency and computation practice and experience ­ p j s foster and m contextsensitive analysis for detecting races in conference on programming language design and implementation pldi m said c wang z yang and k generating data race witnesses by an analysis in formal methods symposium pages ­ springer a r l wang and s d automated typebased analysis of data races and atomicity in symposium on principles and practice of parallel programming s m g nelson p and t a dynamic data race for multithreaded programs in acm symposium on operating systems principles e detection of access in conference on programming language design and implementation pldi k race directed random testing of concurrent programs in conference on programming language design and implementation pldi k and g detecting errors in multithreaded programs by generalized predictive analysis of executions in international conference on formal methods for open distributed systems k g and g online efficient predictive safety analysis of multithreaded programs international journal on software technology and tools transfer ­ t f f chen and g maximal models for multithreaded systems technical report university of illinois at department of computer science december n and c wang on interference abstractions in symposium on principles of programming languages popl f a and p threads to expose atomicity violations in international symposium on foundations of software engineering n a static data race analysis tool in usenix technical conference the software foundation available at the software foundation available at the world wide web web server available from c von and t static conflict analysis for multithreaded objectoriented programs in conference on programming language design and implementation pldi c von and t r object race detection in objectoriented programming systems languages and applications oopsla j w r jhala and s static race detection on of lines of code in international symposium on foundations of software engineering c wang s m and a gupta symbolic predictive analysis for concurrent programs in world on formal methods fm c wang r m and a gupta symbolic analysis for atomicity violations in tools and algorithms for the construction and analysis of systems tacas l wang and s d accurate and efficient runtime detection of atomicity errors in concurrent programs in symposium on principles and practice of parallel programming j contextsensitive pointer analysis using binary decision diagrams phd thesis stanford university mar y efficient detection of data race conditions via adaptive tracking in acm symposium on operating systems principles appendix soundness proof theorem cp is sound given a trace tr with a we can produce a tr cr tr with either an or a deadlock proof let the first race of trace tr be between events e and e with e appearing before e in the trace being the first race means that there is no between two events both of which appear before e as well as no race between events ee with e appearing after e and before e consider a trace tr such that · tr cr tr and tr has the same first as tr ie between events e t ui and e t u j with i j with i and j the indices of the events in trace tr · among traces satisfying the above property tr has minimal distance j i between events e and e of the first intuitively this means that all irrelevant events between e and e are out of the ee segment in trace tr · among traces that satisfy the above properties tr is one that also the distance between e and every beginning of a critical section containing e from innermost to outermost that is among traces that have the same minimal distance between e and the innermost acquisition event k for a critical section containing e tr the distance between e and the second such lock acquire among those satisfying all the above tr the distance between e and the third such lock acquire k and so on all the way to the outermost critical section containing e we will refer to the last two requirements as the property for such a trace tr we get important lemmas lemma all events e between e and e are such that a e hb e and e hb e b e cp e and e cp e proof we prove each case separately a · assume e hb e then we can move e and all events e that occur between e and e such that e hb e to the point right after e the result of the move maintains program order note that thread t is not affected by the move at all since we have already assumed that e hb e therefore e cannot any previous event in t if this move or any move in later proofs is not possible it is because of one of two reasons · it causes the result to not be a trace because the pairing of lock becomes invalid ie a lock is acquired while held · the result is a valid trace t but t cr tr because a read now a different written value the former means that the moved events have a common lock with some event say f that occurs before e an since in this case e hb f hence f would be a moved event the latter reason is also an since then a moved event would conflict with a event f if the two events were then they would also be hb ordered hence f would have moved if the events were not then ee would not have been the first race of tr hence the move is possible which violates the first property therefore our assumption was false and e hb e · if e hb e then we can move e and all events e that occur between e and e such that e hb e to right before e again with similar reasoning as above or as in lemma below we get a contradiction b if either e cp e or e cp e then we would have had e cp e per part a and the definition of cp a contradiction lemma consider any lock acquire event a for a critical section containing e all events e between a and e have a hb e and if e hb e then e hb e proof assume a hb e let e be the set of operations made up of e and all e that occur between a and e such that e hb e note that set e cannot contain any events from thread t or else a hb e try to move all operations in e to right before a if the move is not possible it is either because these moved events have a common lock with some event f a contradiction since then f hb e and f would be moved or that the moved events conflict with a event also a contradiction since it would imply a race before ee or a cp relation which violates the assumption of between a and the moved events therefore moving e before a is possible and the result of the move maintains order however moving e violates the property of tr the fact that e hb e follows from similar reasoning as in lemma but uses the assumption that e hb e to establish that e is not among the moved events lemma any conflicting events that both occur before e or with one being e and the other occurring after e and before e have to be proof otherwise we trivially have a earlier than ee lemma consider any lock acquire event a for a critical section containing e if a critical section cc starts before event a and ends after a and before e then a cp c proof by induction base case consider the cc that ends the after a among all such cc that satisfy the stated conditions assume that a cp c by the of lock operations such a critical section cc cannot be performed by thread t let d be the first event after a in this critical section we will try to move dc to the point right before a order if the move is successful it violates the of tr hence the move must be illegal because it violates some property of cr or of the definition of a trace therefore the move must be illegal for either of the usual two reasons it causes the result to not be a trace because the pairing of lock becomes invalid ie a lock is acquired while held the result is a valid trace t but t cr tr because a read now a different written value for case the moved events cannot be a lock held by thread t at position a since that lock would not be released before e if the lock were held by a thread other than t we have a critical section with the stated properties for cc that ends before the currently considered cc which is impossible case means that the moved events conflict with some event that occurs after a this event e has to cp the moved event it conflicts with by lemma but from lemma we have a hb e and therefore a cp c inductive case the argument is identical to the base case except in case when we consider the possibility that a lock that needs to be acquired by the moved events is held by a thread other than t in this case we have an earlier critical section gg with the stated properties and therefore a cp g by the inductive assumption but since our cc acquires the same lock we get the desired a cp c lemma there cannot be a critical section by a thread other than t that starts after event e and before e and ends after event e proof assume that such critical sections exist among them pick the cc that starts last ie to e let d be the last event before e of this critical section we have two cases if cd does not contains nested critical sections inside it we can move all events cd to the point right after e the proof is similar to that of lemma the move respects ordering also the moved events cannot be a lock held at point e there are no nested critical sections in the moved events and the lock acquired by event c is still held at e furthermore the resulting trace is a correct reordering of the original because if it were not we would then have a conflict between events whose relative position changes ie between the moved events and events but in that case there would be a cp edge in cd to an event before e by lemma and since c is between e and e we would get using lemma e cp e a contradiction if cd does contain critical sections let gg be the one ending last before e consider an event sequence produced as follows we drop all events starting from and including g of that thread we drop all events after e by all other threads clearly the result is a prefix of tr if it is a legal trace that correctly tr then we are the of tr in the resulting event sequence there cannot be an event a lock already held the only lock release events are either after e in which case subsequent lock are also or are together with their lock acquisition event in the case of gg events note that if there is a critical section inside cc that starts before gg it has to also end before g or it would violate the definition of either gg or cc also no read can see a different write or this would imply a conflict between a event after g and another before e in such a case we would have a cp ordering per lemma and e cp e as before we conclude that the resulting trace correctly tr and violates its assumption a contradiction with these lemmas about trace tr we can now attempt to prove the soundness theorem we will show that tr either has an hb race in fact e and e have to be adjacent in this minimal trace or if not the trace a deadlock which can be caused by a slightly trace clearly if ee is an hb race in tr then we are done assume it is not we will try to tr so that one of the properties is violated which is a contradiction consider the first event f such that · f is performed by a thread other than t · f occurs after e and before e such an event needs to exist if ee are furthermore by lemma e hb f and since f is the first such event in any thread other than t it needs to be a lock acquire consider then the critical section f f there are two cases f occurs before e let f f be over lock l we get two a l is not held by t during e since e hb f and f is the first such event outside t there must be a critical section over l after e and before f let g be the lock acquire event of that critical section g has to be an event by thread t otherwise the definition of f would be violated there would be another first event also g has to be after e by our assumption that l is not held during e consider a move of f f to right before point g the move respects order also if a read a different write then a moved event must conflict with one of the events after g hence lemma we have some e such that e cp f but we have e hb e by lemma e cp f and f hb e by lemma hence e cp e a contradiction finally the move may cause a lock m to be acquired while being held this means a critical section and that lock is inside f f assume that m is the first such lock if m is held at point g by a thread t other than t then it has to be released before f the definition of f since there is a different first event after e by a thread other than t a more interesting case is when lock m is held at point g by thread t in that case lock l is nested inside lock m in thread t because l is acquired at position g with m held and lock m is nested inside lock l in thread t we can cause a deadlock by moving a prefix of the f f critical section up until the lock m acquisition to point g therefore the move of f f to point g either produces a legal trace t such that t cr tr or a deadlock the move can be repeated until there are no more critical sections over lock l between e and f f at that point we can just move event f to right before e this would produce a correctly trace that violates the of tr a contradiction we conclude that if case a occurs there is always a deadlock in a correct reordering of trace tr b l is held by t during e let a be the last lock acquisition event of lock l before e consider a move of f f and all previous events by the same thread after a to right before point a let a be the lock release with a the move respects order also if a read a different write then a moved event must conflict with one of the events after a hence by lemma we have some e such that e cp e where e is a moved event and therefore e cp f since all the moved events f and are by the same thread but by lemma we have a hb e and therefore a cp f since however the critical sections starting at a and ending at f are over the same lock l we get that a cp f because of the second rule in the cp definition this implies e cp e since e is before a by assumption of case b and f hb e by lemma a contradiction finally we consider the case of the move being illegal because it causes a lock m to be acquired while being held if such an m is held by a thread t other than t at point a then it has to be released before e otherwise the release event would violate the definition of f since it would come before it after e and by a thread other than t this means that lemma applies to the critical section of that thread hence we have that a cp h where h is ms release event in t but since h happensbefore some moved event since the moved events acquire lock m we get e cp f again all moved events are with f and consequently via lemma e cp e a contradiction if lock m is held at position a by thread t then l is nested inside m in thread t while m is nested inside l in the thread performing f f the lock acquisition of m by that thread cannot be before f since the lock is released after e and f is the first event after e by a thread other than t therefore m is acquired and released inside critical section f f as before we can cause a deadlock by moving a prefix of the f f critical section and any earlier events after a by the same thread to a therefore this case again implies a deadlock in a reordering of trace tr f occurs after e we then have by lemma that f f has to be performed by thread t let f f be over lock l lock l cannot be held by t during event e or e cp e therefore there must be some critical section gg over l performed by thread t after e such that g hb f recall that f is the first event after e by a thread other than t assume that gg is the last such critical section consider an event sequence produced as follows we drop g and all events e after g by a thread other than t we drop all events after e by all threads clearly the result is a prefix of tr if it is a legal trace that correctly tr then we are the of tr therefore the result of this event drop has to be illegal the drop respects order also if a read a different write then a event must conflict with one of the events before e by lemma we get a cp edge between events after e and before e in tr and by lemma and cp properties we have e cp e a contradiction thus the event sequence cannot be a trace a lock has to be acquired while held such a lock m has to be acquired before one of the events with its release among the events the lock is then by one of the events ie by thread t the acquisition of m has to be in thread t otherwise f would not be the first event between e and e by a thread other than t in thread t for trace tr lock l has to be nested inside m since every event after g which is an acquisition of l caused the drop of the release but not the acquisition of m however lock m is nested inside l in thread t since it is acquired after ls acquisition point f and before ls release which occurs after e we can again cause a deadlock with an event move of a prefix of fe this concludes the proof of the theorem any cp race implies either an hb race in the minimal trace tr or a deadlock in a trace 