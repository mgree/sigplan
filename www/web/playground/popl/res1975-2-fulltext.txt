a fast and usually linear algorithm for global flow analysis extended abstract by l graham and mark wegman computer science division university of california berkeley california a new algorithm for global flow analysis on reducible graphs is presented the algorithm is shown to treat a very general class of function spaces for a graph of e edges the algorithm has a worst case time bound of oe func tion operations in programming terms the number of operations is shown to be proportional to e the number of exit nodes from program loops consequently a restriction to control structures guarantees linearity it is shown that by these time bounds a yet class of function spaces can be handled introduction in analyzing a computer program for purposes of code improvement program verification or error it is necessary to be able to trace at compiletime the flow of information through a program in connection with code improvement tech such as for example common subexpression elimination or moving invariant computation out of loops this analysis is called global flow analysis until recently the principal systematic technique for global flow analysis has been the interval analysis of and allen the time needed to analyze the graphical representation of a program using this method is at worst tional to the number of edges in the graph times the number of nodes kennedy extended inter val analysis to deal with a class of global flow problems than had previously been handled by this method and unman have presented an tive approach to global flow analysis in which the analysis can be carried out in time proportional to the number of edges in the graph times the maximum depth of the graph in the worst case the depth is proportional to the number of nodes in the graph has proposed and implemented several to the iterative method the method is investigated further by and unman in comparisons of the iterative approach with interval analysis appear both in and unman and in kennedy in unman presents a somewhat algorithm for common subexpression tion which requires at worst time proportional to e for a graph with e edges research by national grant gj science foundation and unman also provide several useful of the class of graphs reducible flow graphs on which interval analysis can be used global flow analysis is also discussed and unman and in aho in this paper we present a new algorithm for global flow analysis which combines a modification of interval analysis with a modification of the transformations introduced by and unman in to characterize reducible flow graphs for a very general class of information flow problems the algorithm requires time at worst proportional to e log e for a flow graph with e edges a analysis of the algorithm reveals that the time is proportional to the number of edges plus the sum of the number of exits from program loops consequently the algorithm is linear for programs and very nearly linear for most well structured programs the paper is organized as follows in the next section the basic definitions and results about program flow graphs are presented in sec tion we introduce the notions of information pro problems fast functions and acceptable assignments in section we introduce t t and t we investigate the use of these trans in solving information propagation problems section contains an of the number of t t carried out by the af on graph in section we outline an efficient imple of the algorithm which requires time pro to the number of transformations sec tion contains further discussion of the method and possible extensions the present paper is in the form of an extend ed abstract in which the proofs are omitted or briefly sketched a full presentation of these results will be submitted for publication in a journal and the results will be contained in the phd dissertation of the second author basic notions a directed g ne has a set of nodes n and a set of e where is for all e members of e e uv for some u v members of n in this paper we will assume that all graphs are directed am p p zo of nodes such that for a between o and kl pj is an edge a path p popl pk is a path from p to pk of length k for any such that oj k pi is a predecessor of pj and pj of pi relative to p if p is an immediate successor of pi a path pop p u if for some oi a path p popl pk passes through edge e uv if for some i an v an edge uv leaves a path c popl pk where pop a trivial or thus if a is a cycle whose c is a trivial cycle cpo pi and popl an edge where po p is a looping cycles is acyclic edge a graph with no a flow distinguished members of graph g is a graph with node no in n such that for all n there exists a path from no to a v v let g be a flow dominates node y i and only if no to y passes through x graph node x every path from lemma dominance induces a partial on the nodes of a flow graph ordering an interval i h of a flow graph g maximal set of nodes i in n with a header node h in i that for all edges ev in e and v s i then v h and furthermore all with nodes only from i pass through h con such cycles theorem and allen every flow graph can into a unique set of intervals in time proportional to the number of edges let g be a flow graph let n be a set of nodes each representing an interval of g and let e be a set of edges between nodes of n such that xy is in e x and y represent different intervals of g and there exists an edge in e from a node in the interval represented by x to the header of the node repre by y let n be the node representing the interval containing no then g n e n is the derived of g a flow graph g is reducible if there exists an integer ko and a sequence of graphs k graph of gi a flow is not reducible is irreducible figure is an example of an flow graph the flow graphs in the other figures in this paper are reducible let g be a reducible flow graph edge xy is a if y dominates x looping edge is a trivial an a the present work is based on the following two theorems of and unman on reducible flow graphs theorem unman a flow graph g is reducible if and only if its edges can be par into two sets s s such that o is a directed acyclic flow graph for any e in s d is not a directed acyclic flow graph and for every edge xy of s y dominates x definition let g be a flow if there exists a node v in n and e vv is a looping edge in e then mation thus t loops if there exists a node v in n and the only edge which enters v is e u v then mation and m or xu and thus transformation t eliminates v and replaces all edges leaving v by edges leaving u figures and are examples of t and t theorem unman let be a flow graph g is reducible if and only if there exists a sequence of flow graphs gk ko such that g is the trivial graph an for f e for some and e such that is defined it can be shown that the sequence of flow graphs in the theorem is at least as long as the sequence of derived graphs for reduction by intervals figure a t transformation a o figure the paradigm irreducible flow graph de figure a t transformation lemma let g be a reducible flow graph g contains a nontrivial cycle if and only if e contains a nontrivial information propagation problems in order that our global flow analysis tech be most useful we wish to demonstrate that they can be carried out efficiently for various program flow problems rather than presenting a separate algorithm for each type of code improve ment we characterize the class of problems by our algorithm following in spirit the unifying approach of evidence for the generality of this class is provided by and unman we cannot expect to obtain complete tion for every kind of code improvement technique that might seem useful for example it is to determine what arithmetic operations are by program flow and can therefore be determined at compiletime suppose there is a statement abc in a program if the value of b is and the value of c is every time this statement is executed then we would like to replace the statement with a however since even determining whether a variable equals or o is undecidable we cannot detect all such instances consequently for each program analyzed we restrict our attention to a finite set x of facts for example a c a power of whose truth at any point in the program may or may not be with each edge uv in the program graph is associated a function which maps the subset of facts true at node u to the subset of facts true at node v if the con flow of the program leaves node u along edge uv the task of our global flow analysis is then to associate with each node in the graph a subset of x which will always be true just before the node is executed at runtime the association of sets of facts with nodes is an assignment finding a maximal such assignment is at least as difficult as polynomial complete problems however we can find substantially faster algorithms if we restrict ourselves to assignments with the property that if xl is the set of facts for node u x is the set of facts for node v and f is the function associated with edge uv then these notions more we first consider define the sets of functions we let x be a set a function f mapping subsets of x into subsets of x is said to if for all xl x subsets of x such that x is contained is contained in in x then the intersection h of two functions f and g is defined for all subsets xl of x by t the reader familiar with techniques of hoare relationships with that those issues here the and work program verification will find we do not explore the composition h of two functions is defined for all subsets xl of x by a set of functions f is an information pro space if f is closed under tion and intersection f is monotonic a set of functions f is fast if f is an information propagation space or all f in f and all xl subsets of x lemma the transitive closure of a set of monotonic functions under composition and tion is an information propagation space i p ai ret f be the closure o t the identity function and the and un der composition and intersection since the and are monotonic f is an information space all functions in f are of the form fx x where x x and x are x and f is fast the functions in f include those using and from many global flow problems for many global flow problems of practical in each subset of x can be represented by a bit vector of length x function operations can then be implemented as boolean word operations and are consequently very next we complete our specification of the class of problems we are considering given a flow graph g and an information propagation space f we associate functions of f with edges in e by a function m from e to f we use the notational convention that for any e e e fe me let p po pi pk be a path we extend our notational convention to paths so that for ko f if p is the trivial path then for any xl x xl an information ro a ation ip where e f is an information propagation set the domain of the functions is a mapping e f is a tuple how graph space in f and m having stated the problem we are now ready to define a class of solutions a fixed for an information propagation problem s a function fp n such that for all n in n e mn in e and o a to an information p g f is a function such that for all paths p popl pk where po no then fp an table information ro a ation such that as is a function p and for all fixed points fp for all n in n if and for the of x sn is of x set of all subsets and n e n then let k be a set of functions such that if f is in k then f is a mapping f nx we say f is maximal in k if for all f in k either f f or there exists n in n such that fn f n intuitively given a set of facts true just before a node is executed a fixed point for that node yields a set of facts true upon entry to any successor of that node a safe assignment with each node a set of facts that are true at that point in the program an accept able assignment is safe and in addition is at least as good as a maximal fixed point example consider the information propagation problem of figure letting al stand for a for y and a for z let f be the transitive closure of the functions in the range of m under composition and intersection let fp be the maximal example then al o and fixed point for this let s be a maximal safe assignment then sn a sn sn sn aa sn both fp and s are acceptable assignments the function mapping each node to is a fixed point and a safe assignment but it is not an acceptable assignment notice that the safe assignment given above is not a fixed point since it is easily shown that every fixed point is a safe assignment ready no yes n z stop no x for any xl x define m as non xl n n fn nn x nn xl xl ua if ae x i xl nn x x if otherwise f flow graph and functional mapping of information propagation problem in dealing with fast information propagation spaces the fact that x is finite is never used and is therefore in theory although it can lead to a more efficient implementation sup pose we have an information propagation space all functions of which map finite sets to finite sets then even if the set x of facts is infinite only a finite subset are necessary for any flow graph such a finite subset is easily found by the following technique construct an assignment b to the nodes by the following method set while bv is undefined for some v if uv is in e and bu is defined set bv fu the set x is finite and if s is ip then thus for any u s ip if assignment for p any safe assignment for for every su gx is a safe assignment for and only if s is a safe the transformations in section we introduced the notions of an information propagation problem and an acceptable assignment for such a problem in this section and the next we develop an algorithm for finding an acceptable assignment for an information tion problem on any reducible flow graph in this section we describe three tions t t and t on flow graphs we show that given an information propagation problem on a flow graph a graph transformed by t t or t has a corresponding information propagation pro from an acceptable assignment for the trans formed graph we can find an acceptable assignment for the original graph if the information space is fast then this process requires at most three functional operations application of a function to an argument composition of two func tions or intersection of two functions if the space is not fast up to compositions of functions can be required for a t tion where x is the set of facts of the mation propagation problem it follows from these results that if we can reduce a flow graph to one node using these trans then from an acceptable assignment for the graph we can find an acceptable assignment for the original graph in time tional to the number of t ti and ti trans needed we show in section that the number of such transformations is where is the number of edges in the original graph and that the number of t transformations is at most consequently we can find an acceptable assignment for an information tion space with fast functions in functional operations and in otherwise we now introduce tions the flow graph definition let g be a flow graph if for some v in n there exists an edge e v v in e and there exists a unique u in nv such that uv is in e then transformation for any set x x denotes the number of elements in x thus t as transformation when defined has the same effect t of and unman let g be a flow graph if for some v in n there exists a unique u in nv such that uv is in and there exists any e vw in e where v w then transformation where if v has no immediate successors other than w then n nv e uv vw and otherwise n n e e thus vw is removed and replaced by uw if there are then no nontrivial paths from v is removed from n and uv is removed om e given a node v entered by a unique edge uv transformation t of and unman u to all immediate successors of v and v and the edge entering v in con each application of transformation t con u to one of the immediate successors of v v and the edge entering v only when the last immediate successor is eliminated be graph g is no let g a fan graph if every be a flow edge figure a fan graph definition let g be a fan graph if for some v in n e no is only edge entering v then transformation the since the node v has no immediate successors transformation t when defined has the same effect as transformation t of and unman we next relate these transformations to ac assignments to information propagation problems lemma let ip g fx m be an tion propagation problem where g and f is fast let g be defined for some e in e an information propagation problem p g fx m can be found using only one com position of functions and one intersection of func tions such that any acceptable assignment to p is an acceptable assignment to p e ht l only other edge entering v define m such that the lemma ma ma and for all a in show that this satisfies notice that unlike the previous next two lemmas do not assume a fast propagation space lemma the information lemma tion propagation let be an problem where let g be defined for some e in e an information propagation problem p can be found using at most one intersection of functions and one composition of functions such that by at most one functional application we can obtain an acceptable assignment to p from an acceptable assignment to p enters v and let e vw v w be an edge in e which leaves v let e uw and let g ne define m such that me if otherwise and for all a in e e ee then for any acceptable to p let this satisfies the lemma u ma ma assignment u show if as that needed to find p only if tional application is needed to obtain an able assignment to p from an acceptable ment to p only if ini ini assign lemma follows from construction in proof of let lp be an tion propagation problem where is a fan graph let g e be defined for some e in e an information propagation problem p g f x m can be found using no function operations by one functional application we can obtain an acceptable assignment to p from an acceptable assignment to p sketch of proof for some v in n no et v for all be the unique edge in e which enters e in ee let me me for assignment as to p let l fn the lemma o show that this satisfies by combining these three lemmas and the corollary we get theorem let be an tion propagation problem where g and f is fast let t be the number of t and tj transformations needed to reduce g to a graph with the single node no then we can find an acceptable assignment to p in ini applications of functions at most intersections of func tions and t compositions of functions thus for any information propagation problem p where f is fast it remains only to analyze the number of t t and tj trans necessary to reduce g in order to know how many function operations are needed to find an acceptable assignment next section we do this analysis in the in order to find the number of function opera tions needed to find an acceptable if f is not fast it suffices by lemma to examine the number of operations required for each ti transformation and the number of t tions needed to reduce g the later issue is resolved in section we answer the former by the following lemma lemma let be an tion propagation problem where g and x is a finite set let g be for some e in e an information propagation problem p can be found using only compositions of functions and two intersections of functions such that any acceptable assignment to p is an acceptable assignment to p xl composition ee and denotes the of u reduction of flow graphs in this section we analyze the number of t t and t transformations necessary to reduce a flow i to a graph with one node if such reduction is possible this result combined with the results from the previous section give us the number of function operations needed for global flow analysis the study of the number of transformations proceeds in several stages we first exhibit an algorithm for reducing a reducible flow graph using these transformations we then prove the correctness of the algorithm at the same time proving certain characteristics of its behavior we then give two analyses of the number of trans carried out by the algorithm the first analysis shows that the number of is at worst el where e is the set of edges of the original graph the second analysis while being than the first since it yields an worst case reveals that the algorithm is linear or nearly linear on the graphs for most programs the algorithm which we refer to as algorithm a is written in a higherlevel algollike lan guage in section we show that the algorithm can be refined in such a way that the time taken to find an appropriate sequence of transformations is proportional to the number of transformations the of the algorithm is a of calls on a procedure at every call from label b of the program is passed a set s of nodes similar to an interval and a header h the set s differs from an interval in that a node in the set may have a looping edge and there is a path from every node to the header hence the graph is strongly connected eliminates all nontrivial cycles pass ing through nodes other than the header at the final call of at label c the entire graph now acyclic except possibly for a looping edge through no is passed to and reduced to a fan graph the final while loop reduces the graph to one node within applicable transformations on the edges connecting the nodes of s can be made in arbitrary order in fact one need not even follow a ti transformation by a t trans formation as the algorithm indicates we have written the algorithm this way only to aid the we next state changes however procedure the graph in order node the algorithm notice that only edges between nodes in s t must other edges of to determine whether to delete a algorithm a procedure t e set of edges edge begin end v node of looping procedure t n set of nodes e set of edges no es of edges hv and vw in e begin if v has no immediate successor in then begin end end procedure s set of nodes h node in begin while there exists an edge vw in e with such that if then do begin choose such vw if then end end s procedure t n set of nodes nodes of edge begin end e set of edges begin comment main program while g contains a nontrivial do begin is a nontrivial ha node in t not dominated by any other node in t dominates v and there is a path p from v to h such that all nodes on p are dominated by h b end c while s nonempty do begin choose any v in if then end end in the following h example each step is a call to a n step t is called with replaces edge ed edge hd by step t abc is called with s edge dd replaces edge de by edge ce ec replaces edge ec by edge cc hc step t ab is called with s hb edge cc replaces edge ce by edge b e edge bb replaces edge eb by the graph t a is called with s ha edge bb replaces edge a e edge be replaces edge edge aa node e deleting edge be edge ac node b replaces deleting edge bc edge ab edge ad node c replaces deleting edge cd edge ac edge af replaces edge df edge ag replaces edge dg edge ah node d replaces deleting edge edge ad edge aa node f replaces deleting edge fa edge af edges ga ag and node g edges ha ah and node h by by and by and by and by by by and by and and and the final graph is the next few lemmas are used in proving theorem and will serve as an outline of that proof it follows from the second theorem of and unman in section that ti and t transform a reducible flow graph to a reducible flow graph in lemma we establish the same result for t lemma let g be a reducible flow graph such that for some u v w in n uv vw e contains edges e vw and e uv where uv is the only edge which enters v then g is a reducible flow graph omitted u the next lemma is used in proving termination of the algorithm lemma graph if edge which a nontrivial let g n e be a directed every node of g is entered by some is not a looping edge then g contains cycle induction on ini corollary let graph with no nontrivial n n or there exists that and possibly edges entering x g be a flow cycles ten either xn such xx are the next we establish ments of the properties of the lemma let g be a reducible flow graph with a nonempty set for some vu is a nontrivial of g let h be any node in t not dominated by another node in t define s h dominates v and there exists a path p from v to h such that all nodes of p are dominated by h let es el then there are no nontrivial in e which enter nodes in s other than h there is a path in e from h to every node in s gj is a reducible flow graph omitted u the following lemma shows that procedures correspond to transformations a flow graph t lemma correctness of let g and gs be reducible flow graphs el s and no nontrivial in e enter nodes in s other than h after is carried out let n be the resulting set of nodes and e be the resulting of edges xy set of edges let e be the set in e such that x and y are in s then every execution satisfies the conditions of procedures ti and t for transformations ti and t f ti and t are called exactly as many times as the number of edges xy in es such that consequently always ter after completion of g is a reducible flow graph all edges in e leave h e contains trivial and le no new non omitted u as a lemma algorithm a could be rewritten so that set t is computed only once at the beginning of execution and after each call of h is removed from t having established the correctness follows that is algorithm a easily theorem algorithm a terminates and reduces any reducible flow graph g to a graph with the single node no m omitted u now we are ready to analyze the number of ti t and t transformations necessary to reduce a reducible f f ow graph to a single node we will ob our bound by choosing a particular ordering on the edges in executing and then showing that that ordering is to carry out gs is a region in the sense of this analysis we must introduce a few more con definitions a flow graph g is tree rooted at no if for every node x in there is exactly one node in e which enters x if g is a tree rooted at no and g nl el nl s a tree rooted at nl such that n n and el se then g is a subtree of g a let g be a flow graph a tree m is a flow graph e ce such that g is a tree rooted at n a of g is an edge of e that x does not y and y does not x the definition of a outside the domain of reducible graphs is dependent on a spanning tree of a graph a is an edge xy such that y dominates x in the given spanning tree a reverse is an edge xy such that x dominates y if a graph is ble then the are the same no matter which spanning tree is used let x y be nodes of a tree such that x dominates y let uo ul u uk be the path from x to y in the tree where x uo there can be only one such path the mation replaces edges xl transforming tree the cost of is k which the number of edges changed is states a less general theorem but his proof supports the following theorem theorem if a tree has less than or equal to e edges and less than or equal to e are performed then the sum of the costs of the is no more than oe we will show that algorithm a is equivalent to performing no more than e on a spanning tree of a flow graph g we will obtain a on the number of ti and t transformations by to theorem in order to invoke theorem which is about trees we will show how algorithm a transforms a spanning tree of a flow graph as it transforms the graph for that purpose we need the following two lemmas lemma gs be let g and reducible flow graphs such that es ei no nontrivial of e enters a node of s other than h and there is a path in gs from every node to h then any spanning tree for g contains a subtree rooted at h which is a spanning tree for gs omitted u let g and gs reducible flow graphs such that es ei no nontrivial of e enters a node of s other than h gs contains a path from every node in s to h contains at least one nontrivial cycle n be a spanning tree for g then there is some node x in sh such that e contains a or a nontrivial which leaves x and enters a node in s there is a path uk in g where h uo x uk for in e enters uj omitted el we next define a sequence of tj and t transformations called a it will turn out that a on a flow graph is equivalent to a on a spanning tree of the graph we then show that we can reduce any reducible flow graph to a fan graph by a sequence of definition let g be a flow graph and let g be any spanning tree for g let x v be nodes in n xv such that either a path in g om x to y or for some z in n there exists a path in g from x to z and an edge zy in e in either case let l uk be the specified path from x to y where and the transformation s a sequence of applications of t and if necessary tj to the edges which replaces them respectively by xy it is defined only if the sequence o applications of tj and t is defined lemma let g gs and g be defined as in lemma then there exists a sequence of choices of nodes and edges in the while loop of which corresponds to a sequence of such that each eliminates a nontrivial or a of g omitted u lemma let g be a reducible flow graph g can be reduced to a graph with no nontrivial in follows from lemmas and since on flow graphs correspond on their spanning trees we get u to theorem let g be a ble flow graph the number of tj t and t transformations carried out by algorithm a to reduce g to a flow graph with the single node no is no more than ini el and ini respectively sketch it follows from lemma theorem and showing the equivalence of numbers of and numbers of that all nontrivial cycles can be eliminated in t transformations it follows from lemma t at this bound holds independent of the order in which edges are chosen within it can be shown that a graph with no nontrivial cycles can be reduced in t transformations and at most in i t tions a total of at most tions is needed u ln tj combining this with the results we get of section theorem let p be an information propagation problem where g if f is fast then we can find an acceptable assignment to p in ini func tions at most el intersections of functions and compositions of functions if f is not fast then we can find an acceptable assignment to p in ini applications at most ie ini intersections of functions and compositions follows from theorem lemma and theorem u we can expect that a typical collection of program flow graphs will tend to exhibit a more special set of characteristics than the total set of reducible flow graphs we have just studied par in view of the current ideas about well structured programs consequently we again analyze the number of transformations of algorithm a this time with respect to programming language issues we define two of iteration loops in programs we then show that the number of t t and t transformations needed to reduce a reducible flow graph is no more than the number of exits from program loops finally we discuss the implications of this result definition let g be a reducible flow for each n in n n dominates v and there is a nontrivial path p from v to n containing only nodes dominated by n n dominates v and there is a nontrivial path p from v to n containing only nodes dominated by n and passing through only one is the number of nodes in which are left by edges which enter nodes not in and is the number of nodes n such that n s and n is left by an edge which enters a node not in n intuitively if nonempty to a program loop starting from the statement represented by n clearly for any node n if nonempty corresponds to a program loop without its inner loops that do not pass through n for any node n is the number of exit nodes from the program loop dominated by n and is the number of program loops from node n figure contains these concepts an example we obtain the following these definitions consequences from let g n be a reducible flow graph then easily from definitions u let g be a reducible flow graph the number of t transformations carried out by algorithm a to reduce g is at most sketch of proof induction on u o nl e o a b c d def e f h j def o o figure e t k e k j kl k kl i figure example for lemma since we have shown in theorem that it is only the number of t transformations that can be nonlinear in the size of the flowgraph lemma provides a convenient measure of the time needed for global flow analysis for particular classes of programs even though as figure illustrates the measure is somewhat consider the flow graph shown in figure if in i is the number of nodes and is the number of edges then ni however since there are approximately ln exit nodes each from approximately n program ps it follows from lemma that the number of t tions needed by algorithm a is no more than in however it is easily seen that algorithm a performs only transformations on this graph using notions of graph grammars similar to those found in we can analyze the forms of program graphs obtained from various combinations of programming language control structures for example suppose we consider a programming language containing assignment statements conditional statements while state ments statements case statements and for is what is found in pascal gc statements and proce it can be rather easily shown that for such a language the number of edges in a program flow graph is proportional to the number of nodes every program flow graph is reducible and there is at most one exit node from every pro gram loop consequently the time required for flow analysis is proportional to the number of nodes ie roughly to the size of the program if we add a halt statement or any statement which effectively causes an exit from the entire program such a statement appears in a program flow graph as a node with no successors it turns out that such nodes cannot affect the of algorithm a it is only when a programming language includes an unrestricted a labelled exit as is found in or some equivalent facility to make multiple jumps out of nested loops that the possibility of non linearity occurs even for such a language we can probably expect in practice that the number of such jumps be reasonably small relative to the size of the program furthermore their effect on the complexity of the algorithm is additive rather than multiplicative implementation we have shown that the number of tions to reduce a reducible flow graph is e where is the number of edges in the graph and that consequently the number of function operations for many global flow problems also has this bound we have also argued that for actual programs the number of opera tions is approximately linear in the size of the program ie the number of nodes in order to argue that the method is indeed of practical interest we now indicate how one might implement the algorithm so that the time required on a ran dom access machine for finding the transformations and doing other is on the order of the number of transformations figure summarizes the data structures used in the implementation we will represent the flow graph g n by an structure namely with each node x we will associate an unordered list of the nodes y such that xy is an edge of the graph the nodes are from to ini and can be addressed directly the key to an efficient following notion implementation is the definition an of the nodes of graph is an assignment of integers to the nodes such that for any edge xy if xy is a then and if not then a tarjan gives an algorithm which produces an of the nodes in a graph in time proportional to the number of edges he also shows the of structures and for a variety of graph algorithms an has the property that for any nodes x y if xy and x dominates y then the first step in the implementation is to produce an of the nodes we list the nodes in their ordering the ordered list can be constructed in linear time by a sort creating an array of pointers to the nodes and lists indexed by next we create a reverse structure in which each node x points to two lists the first is a list of nodes y such that yx is an edge which is a the second is a list of nodes y such that yx is an edge which is not a thus for each node x the lists to which x points indicate the edges entering x since a can be determined by the fact that it goes from a node with a higher to one with a lower the reverse structure can be created in linear time the next step is to find the set s and node h which are arguments to we scan the list of nodes in decreasing order we let h be the first node encountered which is entered by a nontrivial this h cannot any node with an entering since such a node would have to have a higher having found h we find the subgraph by what is essentially a depthfirst recall that for any x must be in s since by definition of h x and the edge provides a path from x to h also for any node x in sh any node entering x leaves a node in s we mark each node as its membership in s is discovered beginning with h and using the reverse structure after adding a node x to s we fol low one of the edges entering x if that edge leaves a node not already in s we add the node to s and follow one of its edges otherwise we back track and follow another edge from a previously encountered node the number of steps in this pro is the number of edges in the resulting es since each edge is traversed once additionally an bit is associated with each node which is set if an edge from h to that node is traversed also as edges are traversed construct an structure for the subgraph gs next in time proportional to the number of edges in es we do an on the nodes of s as before we list the nodes of s in order of the new this new list has the same order as the old list but has no caused by nodes not in s the purpose of the new is only to obtain this list the new can then be discarded this method of obtaining the list is in general faster than obtaining the of nodes by scan the original list starting at h now we are ready to carry out the computation of by again exploiting the properties of since the graph has no entering nodes of sh all entering edges of nodes in s h must leave nodes with smaller the node h has the smallest of any node in s consequently the node following h in the new list has entering edges only from h and possibly itself if the node has a looping edge apply ti then using the struc ture for the subgraph apply t to all edges leaving that node at the comp of the t transformations the third node of s in the ordering will have entering edges only from h and possibly itself repeat until all nodes in s have been processed application of tj and t requires changing edges in the original structure and the reverse structure by keeping a pointer from each entry in the structure for gs to the corresponding entry in the original structure edges are easily deleted by checking the bit before adding an edge duplicate entries for edges leaving h can be avoided if the edge is added the appropriate bit is set since the reverse structure is not needed during the computation when a node in sh is processed its reverse list can be re placed immediately by the single entry for h the reverse list for h can be re placed by the single entry for the looping edge to h the structure for gs need not be updated application of tj or t does not change the of the nodes since finding each is done in time proportional to the es shown time for finding all such subgraphs is proportional to the number of transformations necessary to re move all nontrivial cycles once the nontrivial cycles have been eliminated the rest of the tation can be done in a straightforward way by pro the remaining nodes in increasing order tile time for the total computation is pro to the total number of transformations the implementation just described illustrates that our global flow analysis algorithm can be realized on a random access machine within the theoretical time bound however we make no claims that what we have described is in any sense the best implementation in particular one is likely in practice to put an upper bound on the size of a graph to be analyzed in light of such a bound and the empirical characteristics of flow graphs for actual programs other might well be more efficient in addition we have made no attempt to save space instead creating linked lists new data structures include an array fields containing a record for each node with for pointer pointer to doublylinked list to each linked reverse list bit bit pointer to linked list for sub graph gs an array containing nodes of g ordered by an array containing nodes of gs ordered by auxiliary et al stacks and temporaries lists figure data representation for implementation discussion we have presented a global flow analysis algorithm for reducible flow graphs and have analyzed its time complexity in number of function operations both in general and for special classes of program flow graphs the algorithm presented here is a major and generalization of interval analysis like interval analysis the algorithm works only on reducible graphs and requires composition and intersection of functions the iteration approach to global flow analysis works on all graphs and requires only functional application however almost all programs written yield reducible graphs and has been proposed as a necessary condition for a wellformed or structured pro gram in practice all functions used in code optimization have been as easy to compose and as they were to apply it should be noted that algorithm a is easily modified to incorporate a test for of any flow graph we are extending the algorithm to include irreducible graphs by the condition for t the complexity appears to be compared with the techniques for achieving for a flow graph g both of the previously known methods have a worst case time of ini function operations their worst cases occur in loops which are nested the me are often linear in practice because nesting level is almost independent of the length of the program however the nesting level typically about appears as a multiplicative factor this is an in the case of interval analysis this increases the running time by a factor of this does not occur in our algorithm we expect that the running time of our algorithm will usually be significantly less than the running time of the previously known algorithms we have expressed our class of global flow problems as information propagation problems for sets of facts we could instead have used the more general bounded framework the distributive law frequently required would be replaced by the weaker monotonicity requirement we used the set formulation for ease of understand ing by the reader after analyzing the algorithm for fast functions we indicated how to extend the algorithm to functions and then to sets together with an information propagation space of functions which map finite sets to finite sets our algorithm is easily generalized to handle global flow problems such as analysis for which one analyzes the reverse of the flow graph we are also studying methods for increased tional efficiency for many programming languages such as the pascal subset mentioned in section program loops can be analyzed before the entire program has been scanned consequently we can in composition and intersection operations of global flow analysis in the parsing semantics leaving only a stack of function applications to be carried out after parsing is completed for large programs this technique can reduce the use of storage for intermediate results during compilation all of the extensions will be included in references aho av and unman jd the theory of parsing translation and compiling vol ii compiling prenticehall n j allen f e control flow analysis sigplan notices vol no july pp d private communication july j global common subexpression elimination sigplan notices vol no july pp rw assigning meanings to programs proceedings mathematical society in applied mathematics vol pp a j and unman of lattice algebra to loop in these proceedings ms and unman j d flowgraph ity siam journal of computing vol no june pp ms and unman jd analysis of a simple algorithm for global flow problems proceedings acm symposium on principles of programming languages october pp ms and unman jd of reducible flow graphs journal of the acm vol no july pp hoare car an axiomatic basis for computer programming communications of the acm vol no october pp j and unman jd global optimization problems and iterative algorithms tr department of engineering princeton university january kennedy k a global flow analysis algorithm international journal of ter mathematics vol december pp kennedy k a comparison of algorithms for global data flow analysis rice technical report rice university february g a a unified approach to global program optimization proceedings acm symposium on principles of programming lan guages october pp m unpublished university of april see also w t and n on the of while and exit statements communications of the acm vol no august pp m a mathematical theory of global program optimization prenticehall nj tarjan r e depthfirst search and linear graph algorithms siam journal of vol no september pp tarjan re efficiency of a good but not linear set union algorithm to appear in journal of the acm unman j d fast algorithms for the of common subexpressions acts informatica vol no december pp wegman m phd dissertation in progress n the programming language pascal acts informatica vol no pp wa a case against the goto sigplan notices vol no november pp 