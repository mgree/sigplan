symbolic algorithms for language equivalence and kleene algebra with tests team ­ de de inria france abstract we propose algorithms for checking language equivalence of finite automata over a large alphabet we use symbolic automata where the transition function is represented using binary decision diagrams bdd the key idea consists in computing a bisimulation by exploring reachable pairs symbolically so as to avoid this idea can be combined with already existing optimisations and we show in particular a nice integration with the disjoint sets forest datastructure from hopcroft and standard algorithm then we consider kleene algebra with tests kat an algebraic theory that can be used for verification in various domains ranging from compiler optimisation to network programming analysis this theory is decidable by reduction to language equivalence of automata on guarded strings a particular kind of automata that have exponentially large alphabets we propose several methods allowing to construct symbolic automata out of kat expressions based either on derivatives or on standard automata constructions all in all this results in efficient algorithms for deciding equivalence of kat expressions categories and subject descriptors f mathematical logic decision problems f models of computation automata d program verification model checking keywords binary decision diagrams bdd symbolic automata disjoint set language equivalence kleene algebra with tests kat guarded string automata derivatives partial derivatives we support from the following projects and is permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm introduction a wide range of algorithms in computer science build on the ability to check language equivalence or inclusion of finite automata in modelchecking for instance one can build an automaton for a formula and an automaton for a model and then check that the latter is included in the former more advanced constructions need to build a sequence of automata by applying a transducer and to stop whenever two subsequent automata the same language another field of application is that of various extensions of kleene algebra whose equational theories are reducible to language equivalence of various kinds of automata regular expressions and finite automata for plain kleene algebra closed automata for kleene algebra with converse or guarded string automata for kleene algebra with tests kat the theory of kat has been developed by kozen et al it has received much attention for its applications in various verification tasks ranging from compiler optimisation to program and very recently for network programming analysis like for kleene algebra the equational theory of kat is making it a challenging task to provide algorithms that are computationally practical on as many inputs as possible a difficulty with kat is that the underlying automata work on an input alphabet which is exponentially large in the number of variables of the starting expressions as such it standard algorithms for language equivalence even for reasonably small inputs this difficulty is shared with other fields where various people proposed to work with symbolic automata to with large potentially infinite alphabets by symbolic automata we mean finite automata whose transition function is represented using a compact datastructure typically binary decision diagrams bdds allowing one to explore the automata in a symbolic way and recently proposed a algorithm for symbolic automata which is much more efficient than the of the traditional algorithms however to our knowledge the simpler problem of language equivalence for symbolic automata has not been covered yet we say simpler because language equivalence can be reduced trivially to suffices to the disjoint union of the automata and to check whether the corresponding initial states are has complexity while hopcroft and algorithm for language equivalence is almost linear this latter algorithm for checking language equivalence of finite automata can be seen as an instance of firstorder unification algorithm without section one tries to unify the two automata recursively keeping track of the generated equivalence classes of states using an efficient datastructure our main contributions are the following · we propose a simple coinductive algorithm for checking language equivalence of symbolic automata section this algorithm is generic enough to support various improvements that have been proposed in the literature for plain automata · we show how to combine binary decisions diagrams bdd and disjoint set the efficient datastructure used by hopcroft and to define their almost linear algorithm for deterministic automata this results in a new version of their algorithm for symbolic automata section · we study several constructions for building efficiently a symbolic automaton out of a kat expression section we consider symbolic versions of the extensions of derivatives and partial derivatives to kat as well as a of and inductive construction the latter construction also requires us to the standard procedure consisting of eliminating epsilon transitions notation we denote sets by letters x y s t and functions by lower case letters f g given sets x and y x × y is their cartesian product x y is their disjoint union and xy is the set of functions f y x the collection of subsets of x is denoted by px for a set of letters a a denotes the set of all finite words over a the empty word and uv the concatenation of words u v a we use for the set preliminary material we first recall some standard definitions about finite automata and binary decision diagrams for finite automata the only slight difference with the setting described in is that we work with moore machines rather than automata the accepting status of a state is not necessarily a boolean but a value in a fixed yet arbitrary set since this is we to the standard automata terminology finite automata a deterministic finite automaton dfa over the input alphabet a and with outputs in b is a triple s t o where s is a finite set of states o s b is the output function and t s sa is the total transition function which returns for each state x and for each input letter a a the next state for a a we write x a x for x for w a we denote by x w x the least relation such that x x and x au x if x a x and x u x for some x the language accepted by a state x s of a dfa is the function x a b defined as follows x ox x aw w when the output set is these functions are indeed characteristic functions of formal languages two states x y s are said to be language equivalent written x y when they accept the same language coinduction checking whether two states of two distinct automata the same language reduces to checking whether two states of a single automaton the same language one can always build the disjoint union of the two automata we thus fix a single dfa and we define bisimulations we make explicit the underlying notion of which we need in the sequel type s dfa t s a s o s let m s dfa x y s let r in let todo xy in while todo do invariant r r todo let xy todo in if r xy then continue if mo x mo y then return false fun a todo mt x a mt y a r xy done return true figure simple algorithm for checking language equivalence definition bisimulation given two relations r r s × s on the states of an automaton r to r denoted r r if whenever x r y then ox and for all a a r a bisimulation is a relation r such that r r bisimulations provide a sound and complete proof technique for checking language equivalence of dfa proposition coinduction two states of an automaton are language equivalent iff there exists a bisimulation that relates them accordingly we obtain the simple algorithm described in figure for checking language equivalence of two states of the given automaton this algorithm works as follows the variable r contains a relation which is a bisimulation candidate and the variable todo contains a queue of pairs that remain to be processed to process a pair x y one first checks whether it already belongs to the bisimulation candidate in that case the pair can be since it was already processed otherwise one checks that the outputs of the two states are the same ox and one pushes all derivatives of the pair to the todo queue all pairs for a a this requires the type a of letters to be and thus finite an assumption which is no longer required with the symbolic algorithm to be presented in section the pair x y is finally added to the bisimulation candidate and we proceed with the remainder of the queue the main invariant of the loop line r r todo ensures that when todo becomes empty then r contains a bisimulation and the starting states were indeed bisimilar another invariant of the loop is that for any pair x y in todo there exists a word w such that x w x and y w y therefore if we reach a pair of states whose outputs are then the word w associated to that pair witnesses the fact that the two initial states are not equivalent remark note that such an algorithm can be modified to check for language inclusion in a straightforward manner assuming an arbitrary preorder on the output set b and letting language inclusion mean x y if for all w a x w y w it suffices to replace line in figure by if x mo y then return false upto techniques the previous algorithm can be by exploiting upto techniques an upto technique is a function f on binary rela tions such that any relation r satisfying r f r is contained in a bisimulation intuitively such relations that are not necessarily bisimulations are constrained enough to contain only language equivalent pairs we have recently shown with that the standard algorithm by hopcroft and actually exploits such an upto technique on line rather than checking whether the processed pair is already in the candidate relation r hopcroft and check whether it belongs to the equivalence closure of r indeed the function e mapping a relation to its equivalence closure is a valid upto technique and this optimisation allows the algorithm to stop earlier hopcroft and moreover use an efficient datastructure to perform this check in almost constant time disjoint sets we recall this datastructure in section other examples of valid upto techniques include as used in based algorithms or congruence closure which combines both and equivalence closure these techniques require working with automata whose states carry a semilattice structure as is typically the case for a dfa obtained from a nondeterministic automaton through the powerset construction binary decision diagrams assume an ordered set a and an arbitrary set b binary decision diagrams are directed acyclic graphs that can be used to represent functions of type a b when b is the two elements set bdds thus intuitively represent boolean formulas with variables in a formally a ordered binary decision diagram bdd is a pair n c where n is a finite set of nodes and c is a function of type n b such that if cn a l r and either cl a or cr a then a a the condition on c ensures that the underlying graph is acyclic which makes it possible to associate a function n a b to each node n of b if cn b b n l r if cn a l r and a if cn a l r and a let us now recall the standard graphical representation of bdds · a node n such that cn b b is represented by a square box labelled by b · a node n such that cn a l r a × n × n is a decision node which we picture by a labelled by a with a dotted arrow towards the left child l and a plain arrow towards the right child r for instance the following represents a bdd with four nodes its node denotes the function given on the righthand side a a b b b b if a and a otherwise a bdd is reduced if c is injective and cn a l r entails l r the above example bdd is reduced any bdd can be transformed into a reduced one when a is finite reduced ordered type node and v of n of a × node × node val node val c node val with let constant v v v let node a l r if lr then l else let apply f node node node fun app x y match cx cy with v v v w constant f v w v node a app l y app r y v node a app x l app x r if aa then node a app l l app r r if aa then node a app l y app r y if aa then node a app x l app x r figure an implementation of bdds bdd nodes are in correspondence with functions from a to b the main interest in this datastructure is that it is often extremely compact in the sequel we only work with reduced ordered bdds which we simply call bdds we denote by the set of nodes of a bdd with values in b which is large enough to represent all considered functions we let f denote the unique bdd node representing a given function f a b this notation is useful to give abstract specifications to bdd operations in the sequel all of this notation actually efficient bdd operations implementation to better explain parts of the proposed algorithms we give a simple implementation of bdds in figure the type for bdd nodes is given first we use library to enforce unique representation of each node the two type declarations and the two conversion functions and c between those types the third utility function is just a convenient operator for defining recursive functions on pairs of values the function constant creates a constant node making sure it was not already created the function node creates a new decision node unless that node is useless and can be replaced by one of its two children the generic function apply is central to bdds many operations are just instances of this function its specification is the following apply f x y f x y this function is obtained by the two bdds together until a constant is reached is used to exploit sharing and to avoid performing the same computations again and again suppose now that we want to define logical disjunction on boolean bdd nodes its specification is the following x y x y we can thus simply use the apply function applied to the boolean disjunction function let bool node bool node bool node apply s s s s s n a n b n b m b n c let iter f × unit node node unit fun iter x y match cx cy with v v v w f vw v iter x l iter x r v iter l y iter r y if aa then iter l l iter r r if aa then iter l y iter r y if aa then iter x l iter x r figure over the set of pairs reachable from two nodes s s s s s a b c t s s s s s s s s s s s s s s s s figure a symbolic dfa with five states note that this definition could actually be slightly by inlining code and that the result is already known whenever one of the two arguments is a constant let bool node bool node bool node fun x y match cx cy with v true v false x v true v false y if aa then node a l l r r if aa then node a l y r y if aa then node a x l x r we ignore such optimisations in the sequel for the sake of clarity symbolic automata a standard technique for working with automata over a large input alphabet consists in using bdds to represent the transition function a symbolic dfa with output set b and input alphabet a a for some set a is a triple s t o where s is the set of states t s maps states into nodes of a bdd over a with values in s and o s b is the output function such a symbolic dfa is depicted in figure it has five states input alphabet abc and natural numbers as output set we represent the bdd rather than giving the functions t and o separately we label the square box corresponding to a state x with its output value ox and we link this box to the node tx defining the transitions of x using a arrow the explicit transition table is given below the the simple algorithm described in figure is not optimal when working with such symbolic at each nontrivial iteration of the main loop one goes through all letters of a a to push all the derivatives of the current pair of states to the queue todo line resulting in a lot of suppose for instance that we run the algorithm on the dfa of figure starting from states s and s after the first iteration r contains the pair s s and the queue todo contains pairs s s s s s s s s s s s s s s s s type s t s s bdd o s let m s x y s let r in let todo xy in let iter todo in while todo do let xy todo in if xy r then continue if mo x mo y then return false mt x mt y r xy done return true figure symbolic algorithm for checking language equivalence assume that elements of this queue are from left to right the first element is removed during the following iteration since s s already is in r then s s is processed it is added to r and the above pairs are again to the queue which now has elements the following pair is processed similarly resulting in a queue with one pairs since all pairs of this queue are already in r it is finally through one iterations and the algorithm returns true note that it would be even worse if the input alphabet was actually declared to be even though the bit d of all letters is irrelevant for the considered dfa each nontrivial iteration of the algorithm would push even more copies of each pair to the todo queue what we propose here is to exploit the symbolic representation so that a given pair is pushed only once intuitively we want to that starting from the pair of nodes n m the letters and are equivalent since they lead to the same pair s s similarly the letters and are equivalent they lead to the pair s s this idea is easy to implement using bdds like for the apply function figure it suffices to the two bdds together and to push pairs when we reach two leaves we use for that the procedure iter from figure which applies a given function to all pairs reachable from two nodes its code is almost identical to apply except that nothing is constructed and is just used to remember those pairs that have already been visited we finally modify the simple algorithm from section by using this procedure on line we obtain the code given in figure we apply iter to its first argument once and for all line so that we a pair of nodes that has been vis letters being elements of abc here we represent them with of length three in the past will never be visited again since all pairs of states reachable from that pair of nodes are already guaranteed to be pro as an invariant we have that all pairs reachable from a pair of nodes in appear in r todo let us illustrate this algorithm by running it on the dfa from figure starting from states s and s as previously during the first iteration the pair s s is added to r and is called on the pair of nodes n m this call results in building the following bdd where leaves consist of calls to todo n m n m n m n s s s s s s s the following three pairs are thus pushed to todo s s s s s s the first pair is removed by a trivial iteration s s already belongs to r the two other pairs are processed by adding them to r but without any new pair to todo thanks to the two expected calls to n m are all in all each reachable pair is pushed only once to the todo queue more importantly the derivatives of a given pair are explored symbolically in particular the algorithm would execute exactly in the same way even if the alphabet was actually declared to be much larger for instance because the considered states were part of a automaton with more letters in fact the main loop is executed at most n times where n is the total number of bdd nodes both leaves and decision nodes reachable from the starting states finally note that in the code from figure the candidate relation r is redundant as the pairs it contains are also stored implicitly in the table of iter except for the initial pair the corresponding lines and can thus be removed symbolic counterexamples algorithms for language equivalence can be instrumented to produce counterexamples in case of failure ie a word which is accepted by one state and not by the other an advantage of the previous algorithm is that those counterexamples can be displayed symbolically thus readability this is particularly important in the context of formal proofs eg when working with kat in coq where a plain guarded string is often too big to be useful to the user while a symbolic guarded only the bits that are relevant for the counterexample are be really helpful to understand which hypotheses have to be used to solve the current goal consider for instance the following automaton s t aa b s t s c t intuitively the states s and t are not equivalent because t can take two transitions to reach t with output while with two transitions s can only reach s with output more formally the word over abc is a counterexample we have s s os t t ot but there are of other counterexamples of length two it suffices that a be assigned true and b be assigned false in the first letter and that c be assigned true in the second letter the values of the bit c in the first letter and of the bits a and b in the second letter do not change the above computation as a consequence this counterexample is best described as the or alternatively the word a ¬b c whose letters are conjunctions of literals indicating the least requirements to get a counter example the algorithm from figure makes it possible to give this information back to the user · modify the queue todo to store triples w x y where x y is a pair of states to process and w is the associated potential counterexample · modify the function iter figure so that it uses an additional argument to record the encountered node labels with negative polarity when going through the recursive call for the left child and positive polarity for the right child · modify line of the main algorithm to return the symbolic word associated with the current pair when the output test fails nondeterministic automata standard coinductive algorithms for dfa can be applied to nondeterministic automata nfa by using the powerset construction this construction transforms a nondeterministic automaton into a deterministic one we extend it to symbolic automata in the obvious way a symbolic nfa is a tuple s t o where s is the set of states o s b is the output function and t s maps a state and a letter of the alphabet a a to a set of possible successor states using a symbolic representation the set b of output values must be equipped with a semilattice structure b assuming such an nfa one defines a symbolic dfa ps t o as follows t x xn tx o x xn ox · · · where denotes the pointwise union of two bdds over sets n m n m this dfa has exponentially many states however when applying algorithms to such automata one them on the and only those subsets that are reachable from the initial states need to be visited this number of reachable subsets is usually much smaller than the exponential worstcase bound in fact it is quite often of the same order as the number of states of the starting dfa see eg the experiments in section hopcroft and disjoint sets the previous algorithm can be freely by using upto techniques as described in section it suffices to modify line to skip pairs more or less according to the chosen upto technique for an upto technique f line thus becomes if xy f r then continue the technique used in hopcroft and algorithm can however be integrated in a deeper way by exploiting the fact that we work with bdds this leads to a second algorithm which we describe in this section let us first recall disjoint sets the data structure used by hopcroft and to represent equivalence classes this standard datastructure makes it possible to check whether two elements belong to the same class and to merge two equivalence classes both in almost constant time the idea consists in storing a partial map from elements to elements and whose underlying graph is acyclic an element for which the map is not defined is the representative of its equivalence class and the representative of an element pointing in the map to some y is the representative of y two elements are equivalent if and only if they lead to the same representative to merge two equivalence classes it suffices to add a link from the representative of one class to the representative of the other class two optimisations are required to obtain the theoretical complexity · when following the path leading from an element to its representative one should it in some way by modifying the map so that the elements in this path become closer to their representative there are various ways of paths in the sequel we use the method called · when merging two classes one should make the smallest one point to the one to avoid generating too many long paths again there are several possible heuristics but we this point in the sequel as explained above the simplest thing to do would be to replace the bisimulation candidate r from figure by a disjoint sets forest over the states of the considered automaton the new idea consists in relating the bdd nodes of the symbolic automaton rather than just its states ie just the bdd leaves by doing so one avoids pairs of nodes that have already been visited up to equivalence concerning the implementation we first introduce a bdd unification algorithm figure ie a variant of the function iter which uses disjoint sets forest rather than plain this function first creates an empty forest we use module of maps over values to represent the corresponding partial maps the function link adds a link between two the recursive terminal function looks for the representative of a node and implements the inner function let unify f × unit node node unit the disjoint sets forest let m in let link x y m x y in representative of a node let rec x match m x with none x some y match m y with none y some z link x z z in let rec unify x y let x x in let y y in if x y then match cx cy with v v v w link x y f vw v link y x unify x l unify x r v link x y unify l y unify r y if aa then link x y unify l l unify r r if aa then link x y unify l y unify r y if aa then link y x unify x l unify x r in unify figure unifying two nodes of a bdd using disjoint set let m s x y s let todo xy in let unify todo in while todo do let xy todo in if mo x mo y then return false mt x mt y done return true figure symbolic algorithm with disjoint set unify is defined similarly as iter except that it first takes the representative of the two given nodes and that it adds a link from one to the other before those links can be put in any direction on lines and and we should actually use an appropriate heuristic to take this decision as explained above in the four other cases we put a link either from the node to the leaf or from the node with the smallest label to the node with the label by this way we the bdd by leaving as few decision nodes as possible it is important to notice that there is actually no choice left in those four cases we work implicitly with the bdd obtained by mapping all nodes to their so that we have to maintain the invariant that this bdd is ordered and acyclic notice that this bdd need not be reduced the children of given a node might be and a node might have several representations since its children might be with the children of another node with the same label we finally obtain the algorithm given in figure it is similar to the previous one figure except that we use the new function unify to push pairs into the todo queue and that we no longer store the bisimulation candidate r this relation is subsumed by the restriction of the disjoint set to bdd leaves if we execute this algorithm on the symbolic dfa from figure between states s and s we obtain the disjoint set forest depicted below using dashed red arrows this actually corresponds to the pairs which would be visited by the first symbolic algorithm figure a bb c b if instead we start from the nodes in the following described automaton we would get the disjoint set forest depicted similarly in red while the first algorithm would go through all lines one of which is a b c a b c dd the corresponding bdd consists of the three nodes labelled with a b and d on the righthand side this bdd is not reduced as explained above the node labelled with b should be removed since it points twice to the node labelled with d and removing this node makes the node labelled with a useless in turn complexity concerning complexity while the algorithm from figure is quadratic in the number n of bdd nodes and leaves that are reachable from the starting symbolic dfa the algorithm from figure performs at most n iterations two equivalence classes of nodes are merged each time a link is added and we start with the discrete partition of nodes unfortunately we cannot immediately deduce that the algorithm is almost linear as did tarjan for hopcroft and algorithm the problem is that we cannot always freely choose how to link two ie on lines and in figure so that we cannot guarantee that the complexity of maintaining those equivalence classes is almost constant we conjecture that such a result holds however as the choice we enforce in those cases binary decision nodes thus reducing the complexity of subsequent bdd unification with row types as mentioned in the introduction hopcroft and algorithm can be seen as an instance of firstorder unification algorithm for recursive terms ie without the algorithm presented in figure and more specifically the bdd unification figure is of extension of this unification algorithm for dealing with row obtain an mllike type inference algorithm in presence of extensible records more precisely row types are functions from a given set of labels to types typically represented as association lists with a default value unification of such row types is performed pointwise and is implemented by the two association lists together as we do here with bdds which from almost constant functions to functions with finitely many output values it would thus be interesting to understand whether our of this unification from association lists to bdds could be useful in the context of unification either by exploiting the richer structure of functions represented by bdds or just for the sake of efficiency when the set of labels is large eg for type inference on objectoriented programs where labels correspond to method names kleene algebra with tests now we consider kleene algebra with tests kat for which we provide several automata constructions that allow us to use the previous symbolic algorithms a kleene algebra with tests is a tuple x b · · ¬ such that i x · · is a kleene algebra ie an idempotent semiring with a unary operation called kleene star satisfying the following axioms x y x the preorder being defined by x y ii b x iii b · ¬ is a boolean algebra x y y the elements of the set b are called tests we denote them by the elements of x called kleene elements are denoted by x y z we sometimes omit the operator · from expressions writing xy for x · y the following illustrate the kind of laws that hold in all kleene algebra with tests ¬ · ¬ · ¬ x x x xy x yx · ¬ · x · · x · ¬ ¬ · y · · x · y the laws from the first line come from the boolean algebra structure while the ones from the second line come from the kleene algebra structure the two laws from the last line require both boolean algebra and kleene algebra reasoning binary relations binary relations form a kleene algebra with tests this is the main model we are interested in in practice the kleene elements are the binary relations over a given set s the tests are the predicates over this set encoded as relations and the star of a relation is its reflexive transitive closure this relational model is typically used to interpret imperative programs such programs are state transformers ie binary relations between states and the conditions used to define the controlflow of these programs are just predicates on states typically a program while do p is interpreted through the kat expression · p · ¬ kat expressions we denote by the set of regular expressions over a set v x y v v x y x · y x assuming a set a of elementary tests we denote by ba the set of boolean expressions over a a a ¬ further assuming a set of letters or atomic kleene elements a kat expression is a regular expression over the disjoint union ba we let p q range over elements of note that the constants and from the signature of kat and usually found in the syntax of regular expressions are represented here by the corresponding tests guarded string languages guarded string languages are the natural of string languages for kleene algebra with tests we briefly define them an atom is a valuation from elementary tests to booleans it indicates which of these tests are satisfied we let range over atoms the set of which is denoted by at at a a boolean formula is valid under an atom denoted by if evaluates to true under the valuation a guarded string is an alternating sequence of atoms and letters both starting and ending with an atom p n pn n the concatenation u v of two guarded strings u v is a partial operation it is defined only if the last atom of u is equal to the first atom of v it consists in the two sequences and removing one copy of the shared atom in the middle to any kat expression one associates a guarded string language ie a set of guarded strings as follows g at gp p at gx y gx gy u v u gx v gy ba p gx u · · · un u un i n ui gx kat completeness kozen and smith proved that the equational theory of kleene algebra with tests is complete over the relational model any equation that holds universally in this model can be proved from the axioms of kat moreover two expressions are provably equal if and only if they denote the same language of guarded strings by a reduction to automata theory this gives algorithms to decide the equational theory of kat now we study several such algorithms and we show each time how to exploit symbolic representations to make them efficient derivatives derivatives were introduced by for plain regular expressions they make it possible to define a deterministic automaton where the states of the automaton are the regular expressions themselves derivatives can be extended to kat expressions in a very natural way we recall this extension in figure one first defines a boolean function that indicates whether an expression accepts xy x y y x q if if x px px · x pq if p q p figure explicit derivatives for kat expressions sx sy sx sy sx sp s sx sy sx y sx sy sx sx x sp p s figure symbolic derivatives for kat expressions the single atom this function is then used to define the derivation function p that intuitively returns what remains of the given expression after reading the atom and the letter p these two functions make it possible to give a of the characteristic function of g we have gx x gx p u the tuple reg ba can be seen as a deterministic automaton with input alphabet at × and output set at thanks to the above a state x in this automaton accepts precisely the guarded string language the isomorphism at × at pat × × at however we cannot directly apply the explicit algorithm from section because this automaton is not finite first there are infinitely many kat expressions so that we have to restrict to those that are accessible from the expressions we want to check for equality this is however not sufficient we also have to regular expressions wrt a few simple laws this is simple to implement by expressions we thus assume that expressions are in the remainder of this section symbolic derivatives the input alphabet of the above automaton is exponentially large wrt the number of primitive tests a × therefore the simple algorithm from section is not tractable in practice instead we would like to use its symbolic version figure the output values in at a are also exponentially large and are best represented symbolically using boolean bdds in fact any test appearing in a kat expression can be into a boolean bdd rather than working with regular expressions over ba we thus move to regular expressions over which we call symbolic kat expressions we denote the set of such expressions by and we let e denote the symbolic version of a kat expression e note that there is a slight here wrt section the input alphabet is a × rather than just a for some a for the sake of simplicity we just assume that is actually of the shape alternatively we could work with automata whose transition functions are represented symbolically for at and explicitly for this is what we do in the implementation we define the symbolic derivation operations in figure the output function s has type it maps symbolic kat expressions to boolean bdd nodes the operations used on the righthand side of this definition are those on boolean bdds the function s is much more efficient than its explicit counterpart in figure the set of all accepted atoms is computed at once symbolically the function s has type it maps symbolic kat expressions to bdds whose leaves are themselves symbolic kat expressions again in contrast to its explicit counterpart s computes all the transitions of a given expression once and for all the operations used on the righthand side of the definition are the following ones · n m is defined by applying pointwise the syntactic sum operation from kat expressions to the two bdds n and m n m n m · n x syntactically all leaves of the bdd n by the expression x from the right n x n · x · f n the boolean bdd f with the bdd n f n n if f otherwise · q is the bdd mapping q to and everything else to q being cast into an element of a by two simple one proves that for every expression x atom at and letter p we have s x x s x p px again we notation by letting the pair p denote an element of a this ensures that the symbolic deterministic automaton s s represents the previous explicit automaton and that we can use the symbolic algorithms from section partial derivatives an alternative to derivatives consists in using partial derivatives which to kat in a straightforward way the difference with derivative is that they produce a nondeterministic automaton states are still expressions but the derivation function produces a set of expressions an advantage is that we do not need to expressions on the the set of partial derivatives reachable from an expression is always finite we give directly the symbolic definition which is very similar to the previous one sx sy sx y sx sx sx x sp p s sy the differences lie in the bdd operations whose leaves are now sets of expressions · n m n m · n x x · x x n · f n n if f otherwise one can finally relate partial derivatives to one ka sx p px the above denotes the iterated sum of the set of partial do not have a syntactic equality because partial derivatives inherently exploit the fact that multiplication over sums using symbolic as described in section one can thus use the algorithm from section with partial derivatives construction other automata constructions from the literature can be generalised to kat expressions we can for instance consider and construction which produces nondeterministic automata with epsilon transitions with exactly one initial state and one accepting state we consider a slightly simplified version here where we omit a few optimisations and just proceed by induction on the expression the four cases are depicted below i and f are the initial and accepting states respectively in the concatenation and star cases a new state j is introduced p i p f xy ax if ay x · y i ax j ay f ax x i j f to adapt this construction to kat expressions it suffices to epsilon transitions to transitions labelled by tests in the base case for a test we just add a transition labelled by between i and f the two epsilon transitions needed for the star case just become transitions labelled by the constant test as expected when starting from a symbolic kat expression those counterparts to epsilon transitions are labelled by boolean bdd nodes rather than by explicit boolean expressions epsilon cycles the most important optimisation we miss with this simplified presentation of and construction is that we should merge states that belong to cycles of epsilon transitions an alternative to this optimisation consists in first the expressions so that for all subexpressions of the shape e e does not contain ie se such a procedure has been proposed for plain regular expressions by when working with such normal forms the automata produced by the above simplified construction on plain regular expressions have acyclic epsilon transitions so that the optimisation is unnecessary this procedure easily to symbolic kat expressions for instance here are typical p p p q p q p q p q we say that symbolic kat expressions satisfying the above property are in strict star form the procedure is linear in the size of the expressions it always produces a smaller expression as a consequence when deciding whether a kat equation holds or not it is always to put the expressions in strict star form first independently from the considered automata construction see the experiments in section according to the example it might be to example into p q p q such a step is invalid unfortunately the second expression accepts the guarded string p for all while the starting expression needs this example seems to show that one cannot ensure that all iterations time s s s s s s s s s s s s nfa states dfa states table checking random saturated pairs of expressions subexpressions are mapped to by s as a consequence we cannot experiments assume that transitions generated by and construction form an acyclic graph in general we implemented all presented algorithms in ocaml the corresponding library is available online together with an allow ing to trace them on examples transitions removal symbolic kat expressions are which allows us the above construction produces symbolic nfa with transitions which have to be eliminated in order to apply the algorithms from section other constructions from the literature produce automata with epsilon transitions and can be adapted to kat using transitions a generic procedure for eliminating such transitions is thus desirable the usual technique with plain automata consists in computing the reflexive transitive closure of epsilon transitions to the other transitions with the resulting relation and declare a state as accepting in the new automaton whenever it can reach an accepting state through this closure more formally let us recall representation of nondeterministic automaton with epsilon transitions as tuples n u j n v where u is a n matrix denoting the initial states j is a n n valued matrix denoting the epsilon transitions n is a n n matrix representing the other transitions with entries sets of letters in and v is a n matrix encoding the accepting states the language accepted by such an automaton can be represented by the following product using kleene star on matrices to represent sets of expressions using trees eg for partial expressions are also using smart constructors sums associated to the left sorted and without products are associated to the left consecutive tests are merged units are as much as possible for construction and for and construction the produced symbolic nfa are once and for all and so that their states are just natural numbers this allows us to use to represent sets produced during the queue todo used for storing the pairs to process is a fifo queue so that the automata are explored in a manner we performed a few experiments to compare the presented algorithms and constructions we generated random kat expressions over two sets of primitive tests and atomic elements with connectives and explicit occurrences of the constants and a pairs of random expressions were checked for equality after being saturated by adding the constant on both sides a difficulty here is that random pairs of expressions are almost always distinguished by a very short guarded string which is found almost immediately thanks to the strategy independently from the size of the expressions and u · j n · v from the upto techniques at work instead we would like to thanks to the algebraic law a b a · b · a which is valid in any kleene algebra we get the algorithms based on their running time on more interesting pairs where the expressions are either equivalent or distinguished only by long guarded strings by the expressions with ka u · j n · v u · j n · j v the constant we make the expressions equivalent moreover looking at an execution of the presented algorithms on we finally check that n u j n j v represents a nondeterministic such saturated pairs what happens is that the output test line automaton without epsilon transitions this is how kozen on figure always succeeds so that the algorithms stop only once epsilon elimination for plain automata the whole automata have been explored and a bisimulation has been the same can be done here for kat by that tests or found moreover an analysis of the various automata constructions boolean bdd nodes form a kleene algebra with a star shows that the automata constructed for an expression p are very operation the function one can thus the similar to the automata constructed for the expression p ex above reasoning to the case where j is a matrix rather the latter is as hard as exploring the former than a matrix the results are displayed in table for each construction and the iteration j of such a matrix can be computed using for each of the two symbolic algorithms we give the total num algorithms on top of the efficient semiring of boolean bdd nodes the resulting automaton has the expected of iterations ie the number of times we execute line in figure and the global running time each construction is type to two lines depending on whether we first put expressions in strict star form or not we additionally provide the total number · there is a transition labelled by p between i and j if there of nfa states generated by and and exists a k such that j ik and p the tions as well as the total number of dfa states generated for the nondeterministic symbolic transition function can be three constructions computed efficiently using appropriate bdd functions one can notice than partial derivatives provide the · the output value of a state i is the boolean bdd node obtained algorithms and construction yield approximately by taking the disjunction of all the j ij such that j is an accepting state ie just j if when using and construction experiments were performed on a pro os x intel core i go ocaml the same number of iterations as partial derivatives but require more time computing the transitive closure for epsilon removal is a costly operation construction gives results both in terms of time and iterations the produced automata are larger and more difficult to compute concerning the equivalence algorithm one notices that using disjoint set significantly reduces the number of iterations there is almost no difference in the running times with the first two constructions because most of the time is spent in constructing the automata rather than checking them for equivalence this is no longer true with construction for which the automata are sufficiently big to observe a difference directions for future work the equational theory of kat is but none of the presented algorithms are pspace just because of the use bdds but also because the bisimulation candidate which has to be stored can be exponentially large experiments however suggest that they can be useful in practice the symbolic dfa produced by the various constructions proposed in this paper tend to be of reasonable size this empirical observation in a formal way seems extremely difficult a natural extension of this work would be to apply the proposed algorithms to and netkat two extensions of kat with important applications in verification while programs with mutable tests in the former case and network programming in the later case has a equational theory and its structure makes explicit algorithms completely useless designing symbolic algorithms for seems challenging netkat remains and foster et al propose in the present volume a decision procedure relying on a variation of derivatives to get a practical algorithm they represent automata transitions using sparse matrices and they exploit some form of symbolic treatment by using what they call bases kat can be encoded into netkat so that their algorithm could be used for kat this encoding is however not and it is nontrivial to understand the behaviour of their algorithm on the resulting instances conversely the algorithms presented in the present paper to with netkat seems feasible although not straightforward concerning the symbolic treatment of automata our use of bdds seems more powerful and less adhoc than their use of bases but the precise relationship remains and we leave its formal analysis for future work moving away from kat we leave open the question of the complexity of our symbolic variant of hopcroft and algorithm figure tarjan proved that their algorithm is almost linear in time complexity and he made a list of heuristics for linking and path compression schemes that lead to that complexity together with and he recently showed that this complexity is still reached asymptotically with randomized linking a similar study for the symbolic counterpart we propose here remains to be done acknowledgments we are to the anonymous who provided and detailed and in particular to the one who the relationship between the present work and type inference algorithm for row types references p a yf chen l r and t when simulation meets in proc tacas volume of lecture notes in computer science pages ­ springer verlag c j n foster a d kozen c and d walker netkat semantic foundations for networks in proc popl pages ­ acm a and d kozen kleene algebra with tests and program technical report tr cs cornell university july v m partial derivatives of regular expressions and finite automaton constructions theoretical computer science ­ s l z and g notes on equational theories of relations algebra ­ f and d checking nfa equivalence with bisimulations up to congruence in proc popl pages ­ acm a p and t abstract regular model checking in proc cav volume of lecture notes in computer science pages ­ springer verlag a regular expressions into finite automata theoretical computer science ­ r e algorithms for boolean function manipulation ieee trans computers ­ r e symbolic boolean manipulation with ordered diagrams acm computing ­ j a derivatives of regular expressions journal of the acm ­ e d kozen and f smith the complexity of kleene algebra with tests technical report tr cs cornell university l and m minimization of symbolic automata in popl pages ­ acm l and algorithms for finite automata in proc tacas volume of lecture notes in computer science springer verlag z and l equational properties of kleene algebras of relations with conversion theoretical computer science ­ jc and s typesafe modular in ml pages ­ acm n foster d kozen m a and l a decision procedure for netkat in proc popl acm a s d and r e tarjan disjoint set union with randomized linking in proc pages ­ siam n b b d kozen and k kat b in proc acm july j g j l m e n r t and a monadic secondorder logic in practice in tacas volume of lecture notes in computer science pages ­ springer verlag p and b dijkstra and meet kleene formal aspects of computing ­ j e hopcroft an n algorithm for states in a finite automaton technical report stanford university j e hopcroft and r m a linear algorithm for testing equivalence of finite automata technical report cornell university december g huet phd thesis paris vii these l and s follow automata information and computation ­ d kozen a completeness theorem for kleene algebras and the algebra of regular events information and computation ­ d kozen kleene algebra with tests transactions on programming languages and systems ­ may d kozen on the theory of kleene algebra with tests technical report cornell university march d kozen and mc certification of compiler optimizations using kleene algebra with tests in proc cl volume of lecture notes in artificial intelligence pages ­ springer verlag d kozen and f smith kleene algebra with tests completeness and decidability in proc csl volume of lecture notes in computer science pages ­ springer verlag september e f moore on sequential machines automata studies of mathematical studies ­ r and r e tarjan three partition refinement algorithms siam journal on computing ­ f pottier and d advanced topics in types and programming languages chapter the essence of ml type inference mit press d kleene algebra with tests and coq tools for while programs in proc volume of lecture notes in computer science pages ­ springer verlag d web appendix to this paper with ocaml implementation of the proposed algorithms d and d sangiorgi advanced topics in bisimulation and coinduction chapter about of the coinductive proof method cambridge university press d application au des phd thesis paris vii these de d extension of ml type system with a sorted equational theory on types research report d sangiorgi on the bisimulation proof method mathematical structures in computer science ­ r e tarjan efficiency of a good but not linear set union algorithm journal of the acm ­ m applications of symbolic finite automata in volume of lecture notes in computer science pages ­ springer verlag m d l t a henzinger and a new algorithm for checking of finite automata in proc cav volume of lecture notes in computer science pages ­ springer verlag 