monoids and invariants as an orthogonal basis for concurrent reasoning university david university university research birkedal university dreyer popl consist complete well easy to abstract we present a concurrent separation logic with a simple premise monoids and invariants are all you need partial commutative monoids enable us to invariants enable us to enforce userdefined protocols on shared state which are at the conceptual core of most recent program logics for concurrency furthermore through a novel extension of the concept of a view shift supports the encoding of logically atomic specifications ie that permit the client of an operation to treat the operation essentially as if it were atomic even if it is not categories and subject descriptors d programming languages formal definitions and theory d programming languages language constructs and features f logics and meanings of programs specifying and verifying and reasoning about programs keywords separation logic finegrained concurrency atomicity partial commutative monoids invariants higherorder logic compositional verification introduction concurrency is about shared state this is true not only for concurrency where the state takes the form of a heap that threads may write to and read from but also for concurrency where the state takes the form of a network that threads may send to and receive from or a sequence of events on which threads may thus to verify concurrent programs of any we need compositional methods for reasoning about shared state this goal has a long line of work especially in recent years during which a synthesis of relyguarantee reasoning and separation logic has led to a series of advanced program logics for concurrency cap permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm and others in this paper we present a logic called that explains some of the of these prior separation logics in terms of a simpler unifying foundation while also supporting some new and powerful reasoning principles for concurrency before we get to however let us begin with a brief overview of some key problems that arise in reasoning about shared state and how prior approaches have dealt with them invariants and their limitations the canonical model of concurrency is sequential consistency threads take turns interacting with the shared state with each turn for one step of computation although the semantics of sequentially consistent sc concurrency is simple to define that does not mean it is easy to reason about in particular the key question is how to do threadlocal is verifying one thread at a though other threads may interfere with ie the shared state in between each step of computation in the thread we are verifying the invariant rule the simplest and way in which concurrent program logics account for such interference is via invariants an invariant is a property that holds of some piece of shared state at all times each thread accessing the state may assume the invariant holds before each step of its computation but it must also ensure that it continues to hold after each step formally in concurrent separation logics the invariant rule looks something like the following some important details that we explain later in § r p e r q e atomic r p e q here the assertion r states the knowledge that there exists an invariant r some piece of shared state given this knowledge the rule tells us that e may gain exclusive control of the shared state satisfying r so long as it ensures that r continues to hold of it when it is finished executing note the crucial side condition that e be atomic meaning that it takes exactly one step of computation if e were not atomic then another thread might access the shared state by r during es execution in which case it would not be safe for the rule to grant e exclusive control of the shared state throughout its execution there is much recent work on weaker models of concurrency which are in many ways more realistic but in this paper we focus on sc concurrency the invariant rule is simple and elegant unfortunately it also from two major limitations which a significant amount of work has to overcome limitation the need for protocols the first limitation to the static nature of invariants for the kinds of interference found in more sophisticated concurrent programs one may require something a bit more dynamic than fixed invariants it is often necessary for instance to have a way of expressing · once a certain change to some shared state has occurred it is cannot go back · certain changes to the shared state may only be made by threads that have the to make those changes at first at least neither of these seems to be expressible in the limited language of invariants as a consequence many more recent logics provide some as relyguarantee assertions regions and to account for and all of these mechanisms are effectively different ways of describing protocols on shared state which assert how the shared state is permitted to over time although the protocol mechanisms of modern logics are clearly useful each logic in its own somewhat different mechanism and corresponding proof rules as primitive leading us to is this really necessary might there be a simpler logical mechanism for interference from which more advanced mechanisms could be easily derived limitation the need for logical atomicity the second limitation to the side condition of the invariant rule requiring the operation e to be atomic take exactly one step of computation obviously this side condition makes it much more desirable as a client to program with atomic operations than with nonatomic ones but there are many operations that appear to be atomic even though they take more than one step of computation and for such operations the invariant rule is not applicable specifically it is often desirable to construct concurrent programs so that the interference on shared state is only observable within the limited scope of some mutable adt abstract data type for instance consider concurrent stacks a sophisticated implementation may rely on finegrained synchronization between threads in order to parallelism and thus proving it correct demands the use of invariants or protocols to account for the interference but this internal interference need not the verification of client code in particular the canonical notion of correctness for concurrent stacks is that it should appear to clients as if all stack operations take effect atomically ie in some sequential order which is typically formalized via linearizability or contextual refinement in this case we say that the operations provided by the stack adt are atomic we would like to be able to treat atomic operations as if they were atomic that way clients of the stack adt could establish invariants on the contents of the stack and then use the invariant rule when reasoning about push and pop operations this can be done to some extent with contextual refinement see the layered verification in but it requires going outside the logic in order to connect up the verification of an adt with that of its clients moreover the refinement approach is only applicable in higherlevel languages where the type system is strong enough to support hiding the of an adt from its clients a more flexible approach we argue would be to the notion of observable atomicity as a logical specification so that both the proof obligation for establishing atomicity and the proof principle it provides to clients take the form of a single specification written within the logic itself we refer to such a elimination stack appendix mutable references figure channels with blocking receive figure local channel assertions figure asynchronous channels figure figure case study a stack of abstractions specification as being logically atomic intuitively the key benefit of working with a logically atomic spec is to enable a version of the invariant rule without the side condition that e be atomic this allows clients to treat operations providing such as if they were actually atomic without requiring any reasoning very recent work by da et al on their logic supports precisely such a notion of logically atomic together with a number of useful but nonstandard proof rules but all of these are into the logic as primitive furthermore is currently not able to reason about a significant class of sophisticated concurrent data structures that employ this the question might there be a way to define logical atomicity in terms of simpler logical primitives and to derive the associated reasoning principles within the logic an orthogonal basis for concurrent reasoning in this paper we propose a concurrent separation logic based on a very simple premise monoids and invariants are all you need invariants we have already discussed at length as for monoids partial commutative monoids are widely known to provide a generic model of physical resources like the heap and logical resources like ghost for use in a separation logic a number of modern logics involve either in the model of the logic or as a feature in the logic itself what does not seem to be widely known however is that monoids and invariants form a kind of orthogonal basis for concurrent reasoning in particular · monoids enable us to express protocols on shared state · invariants enable us to enforce protocols on shared state these two mechanisms put together are powerful in particular using monoids and invariants we show how to · encode a variety of the advanced protocol mechanisms from modern logics § and § · derive proof rules that are taken as primitive proof rules in other modern logics § and § · encode logically atomic and derive their most important associated proof rules § · go beyond and verify logically atomic for finegrained concurrent that employ § a key technical of that the above contributions is an extension of the concept of view shift that has been proposed in recent work we explain this mechanism in § furthermore the soundness of primitive proof rules which we discuss briefly in § has been fully mechanized in coq syntax fix disjoint infinite sets chan and var of channel names and variables c d chan x y f var v w x c rec f x e v v v e v e e e e ei e case e of inj x e inj x e e e fork e k e k k · · · derived forms none inj machine states inj e m bag finite of values c chan fin bag t n fin exp pure reduction omitted e pure e reduction c e c e c e c e when e pure e c cc c cc m v cc m v cc c cc none cc m v c cc m machine reduction c t c t c e c e c t i ke c t i ke c t i e c t i k j e figure a language with asynchronous channels we denote the disjoint union f x y by f x y to demonstrate the effectiveness of abstraction and modular reasoning in we have applied it to a significant case study that builds a stack of abstractions with each layer only an abstract atomic specification to the layers above figure the bottom two layers are atomic while the top three are logically atomic at the bottom of the stack we start with a atomic specification of channels in a calculus with asynchronous message passing § on top of that we first develop § followed by channels with a logically atomic blocking receive operation § we then show that we can use channels via a standard encoding to implement a logically atomic spec for mutable references which we finally use in the verification of a finegrained elimination stack adt § put together this a modular verification of elimination stacks running on a machine performed completely within the logic full details of the case study as well as all other omitted technical details appear in our technical appendix ­ part i monoids is a higherorder separation logic parameterized by the language of program expressions that one to reason about for the purpose of this paper we instantiate the programming language to the one shown in figure which provides primitive operations e and e for asynchronous nonblocking message passing via channels we have chosen this language rather than the usual command language one finds in most papers in order to emphasize that nothing about is to concurrency and that abstractions can in fact be built up within the logic § the logic includes the usual connectives and rules of higherorder separation assertion logic as generated by the grammar below exp val prop × · · · t p t t t t x t t t t false true p p p p p p x p x p p p p p · · · here denotes the type of a term written t p or among others in the logic terms include language expressions and values propositions and products and function spaces over these the c c cc cc m m v v cc m m cc m m c v v cc m cc c v v none cc figure rules derived from the semantics of asynchronous channels see figure typing rules are standard and omitted see the appendix the judgment p q says that for all instantiations of the variables in the propositions p q the contexts are often left implicit in the following sections we will introduce and key features of the logic along with their associated terms and types physical state to specify and reason about the behavior of programs the logic features hoare triples written p e v q here v serves as a binder for the return value in postcondition q the logic is parametric in the syntax and semantics of the underlying programming language as such the logic only features basic structural rules and lacks hoare axioms for primitive expressions however the logic provides a canonical way of adding such axioms by the reduction semantics of the underlying language as axioms about the entire physical machine state to express this features a physical state assertion written and a type state of physical states of the underlying language for every term of type state asserts exclusive ownership of the physical state along with the knowledge that the physical state is exactly using this assertion we can directly translate the reduction relation defined in figure into the axioms given in figure the physical state assertion only supports reasoning about the entire physical state however as we will see in § through the combination of monoids and invariants it is possible to define more local reasoning principles figure summarizes the syntax and proof rules for physical states and selected structural hoare rules for now ignore the in and the in combined these rules simply yield the standard rule of consequence with implication in the next section we will explain how generalizes that rule ghost state in addition to physical state assertions also supports assertions about ghost state auxiliary state ghost state was originally proposed as a way to abstractly characterize some syntax p · · · p p p e p · · · state physical state axioms false structural hoare rules frame p e v q p r e v q r ret true w v v w bind p e v q v q kv w r p ke w r p q pq pp p e v q v q p e v q q figure physical state and selected structural rules knowledge about the history of a computation that is essential to verifying it more generally ghost state is useful for describing a threads knowledge about some shared state as well as the it has to modify it in many logics ghost state takes the form of a ghost heap however as the name implies ghost state is a purely logical construct introduced solely for the purpose of verification and thus there is no need to tie it to a particular language or machine model consequently in following several recent logics we model ghost state as a partial commutative monoid which is taken as a parameter of the logic we call the elements of this ghost resources and we use the term resources to refer both to physical states and ghost resources assertions in represent predicates over both kinds of resources we represent the partial commutative monoid as a total commutative monoid with a zero element the term a · b is thus always well formed formally we require a set m with two distinguished elements zero undefined and unit and an operation · compose such that the following properties hold a · b · c a · b · c we call m the carrier of the monoid m m · and use m to refer to the carrier without the zero element m to reason about these monoid elements the logic features a type monoid of monoid elements and the composition operation as a function on monoid for each term a of type monoid the logic features a corresponding ghost assertion a which asserts a along with ownership of an a fragment of the global ghost state the global ghost state is the composition of all locally owned fragments ghost resources can thus be split and combined arbitrarily according to the chosen · operation t · u t u since the ghost state is to the underlying physical state we can update the current global ghost state arbitrarily at any time we express updates of ghost state using view shifts a view shift from p to q written p q asserts that it is possible to update the state from p to q without changing the underlying physical state the rule of consequence in figure thus allows view shifts and not just implications to be applied in pre and postconditions if we own a fragment a of the global ghost state we must ensure that any updates of the ghost state are consistent with any fragments potentially owned by the environment eg other threads the rule in figure expresses that we can update a ghost fragment a to an element b b if this update is a b syntax a p · · · a a · a · · · monoid ghost resource axioms a b a · b true false ghost resource updates ab a b b b where a b is shorthand for af a af b b b af figure syntax and proof rules for ghost resources that is if it preserves an arbitrary composable frame af a b af a af b b b af a b a b where a af is notation for a · af note that the premise of rule is merely a fact it does not express ownership of any state to express such facts the logic features an always modality written p for that p holds and does not assert any ownership such assertions are called pure and can be freely duplicated ie we have p p p and p p view shifts and hoare triples are other examples of pure assertions the knowledge that a view shift or hoare triple holds can thus be freely duplicated monoid constructions the monoid representing ghost with the update rules that it be seen as a way of expressing a protocol on logical state given ownership of a particular monoid element what does the owner know about the global ghost state and how are they permitted to update it in this section we present a number of useful monoid constructions and their update rules representing different types of protocols these protocols are not yet related to anything else they just exist on their own we will see in § how to enforce a protocol some other shared state the main in this section is an encoding of state transition systems as a monoid state systems provide a general and intuitive way of describing possible interference expressed as a directed graph the nodes of the graph represent possible ghost states while edges describe how the ghost state may in § we show how to this way of describing interference in through a general construction recall that we represent as commutative monoids with zero when defining monoid we leave this zero element implicit furthermore we will not explicitly define the cases of the composition function that involve or the exclusive monoid the exclusive monoid over a set x supports two notions of ownership exclusive ownership of an element x x vs no ownership the owner of an element x x thus has exact knowledge about the state formally is the monoid with carrier x and composition only defined when one of the operands is this gives rise to the following update which captures the ownership intuition given above xa any nontrivial element of the monoid can be updated to any element in terms of reasoning the already described physical assertions behave like ghost assertions about an ex monoid over physical states see the axiom in figure except that of course one cannot use view shifts to update them the fractional monoid it is often desirable to share knowledge about some piece of ghost state eg between different threads a simple way to do that would be to reuse the carrier from but let a · a a this captures the right idea of knowledge but gives up any notion of ownership since all elements are no update is possible instead we would like a way to keep track of how much the knowledge about ghost state has so that after it all up again we can do a update this is achieved by the monoid which has carrier q × x and composition q x · q x q q x if q q and x x with this monoid we can do any update after collecting all the pieces x a the product monoid using a product construction we can combine any family of monoids into a single monoid while maintaining their individual reasoning principles ie updates we define the carrier of the product monoid ii mi to be the product of the monoid ii mi composition is defined pointwise if all of the constituent compositions are well defined otherwise it is we would like to operate on the ith component of this product monoid just as we would act on the individual monoid mi and indeed the following update rule holds a mi b f i a f i b b b finite partial functions a very common monoid in separation logics is the heap modeled as a finite partial function from locations to values we can obtain this monoid from the product monoid by adding just one new piece given a infinite domain x and a monoid codomain m define m to be the product monoid xx m with the additional restriction of the carrier to elements f where the set x f x m is finite this is well defined since the set of these f contains the unit which is the function mapping everything to m and is closed under composition you can think of these f as finite partial functions to m where the elements outside their domains are mapped to since the domain of f m is finite an additional update becomes possible a new element can be allocated a m f f x a x note that x is bound by the set in applying this update one cannot choose which x one gets consider the monoid heap where loc is a set of locations the carrier of this monoid consists of finite partial functions from locations to values and composition of h and h is defined if all pointwise compositions are defined from the composition on it follows that this is the case iff domh and domh are disjoint this is exactly the standard composition of heaps in separation logic now consider this models a fractional heap another commonly used monoid in separation logics it can be used as ghost heap we define the syntactic q sugar x w to mean x q v if q and false other then we can show v true x x v x q q v w x q v x q w x qq v v w x q v x q v x q v q x v w x v x w we can use to allocate a new ghost heap cell knowledge about the value and ownership of the location can be split and combined using this is useful in particular when combining two pieces of a cell that were out earlier one can learn that they point to the same value rule says that fractional assertions have wellformed having full ownership the value in the ghost heap can be updated using named monoid instances and multiple monoids in the previous section we had to fix the global monoid to provide a particular derived construction we may however want to use two different constructions in the same proof without requiring them to share their monoid it is also useful to be able to obtain a fresh instance of a monoid at any time as it turns out all the tools we need to this are already at hand given a family of monoids we use a combination of the product and finite partial function monoids to define a global monoid m as follows m mi ii the product construction allows us to use a different monoid for independent parts of the proof while the finite partial function construction provides named instances of these monoids for the remainder of the article we assume has been instantiated with the monoid m given above constructed from a family of monoids taken as a parameter we write a mi or just a if mi is clear from the context for i a when a mi and for false when a mi the ghost resource a mi thus asserts ownership of a part a of the instance named of monoid mi in the current state from the rules for ghost resources figure and the updates in § and § we can derive the following rules for allocating updating and combining named monoid ghost resources a mi true a mi a mi b a mi bb b mi a mi b mi a · b mi the monoid a common pattern in concurrent reasoning is to put in of the global state of some ghost resource while else fragments of that resource together with the knowledge that their fragments are all contained within the state we can capture this pattern with the monoid where x a m x a x a m x so the monoid consists of pairs where the right component behaves just like m and the left component asserts exclusive ownership of a nonzero element of m we impose the additional restriction that if an element is present it must be an extension of the current fragment a m x which is shorthand for b a b x composition is defined pointwise and undefined if it is not in the if the combined fragment the combined element or if two elements are present note that m is the unit and asserts no ownership or knowledge but m m asserts that the element is m we write · x to assert full ownership x m and a to assert ownership a for consistency we write · x a for x a the update for this monoid says that if we own the element and some fragment then we can exchange that fragment for anything compatible with the rest m b af · a · af a · b · af b the rule requires that m be which means af a b af · a af · b a b the monoids and are for any x and monoid products preserve building on an example from § consider this monoid allows us to assert ownership of some complete heap · h as well as ownership of eg individual memory locations as v since heap is we obtain the following updates · h · v v · h · w w domh · h · h · v v · h v we can deduce that h h · v for some h by the definition of the carrier moreover we can add a new location to at any point we wish provided we can show that is not allocated in the current heap this with the update for heap where we can never be sure which location we just know it will be fresh with tokens in their logic et al show how to characterize the possible interference in a concurrent computation using state transition systems with tokens as suggested in § these mechanisms serve to express of state change and the to make state changes concretely an sts comes equipped with a set of states and transitions between them as well as a set of tokens and a mapping from states to tokens the transition relation enforces by restricting which states are accessible from which other states the tokens assigned to a particular state are owned by the sts and can be up by any thread when to other states tokens must be when taking transitions the disjoint union of the tokens owned locally and the tokens owned by the current state cannot change the tokens owned locally by a given thread thus serve to limit the of other threads to make certain transitions as an example consider the possible states of a remote procedure call rpc between a client and a server initially a call has been sent and it is the servers turn to send back a reply only after that has can the client receive the reply and terminate the corresponding sts is given in figure the second state rx contains the token this means that the token is owned by the sts if we are at this state to satisfy of tokens a transition from tx to rx can only be performed by giving up thus limits the possible interference from the environment but the owner of can make this transition thus saying we are at least in state tx and we own token amounts to saying we are exactly in state tx rx done tx figure sts for a remote procedure call s t s t t s t s s t s t t s t s t s t s s s s t t s s t s s t × ps × pt s s s s t s s s s t s t s s t · s s t s · s s s t t where composition is undefined if the result is not in figure monoid encoding of the monoid for an sts s with token set and token assignment t s is defined in figure it has three parts first is the current state s ownership and knowledge of this state can only ever be held by one party hence we use an exclusive monoid to represent it even if we do not own the s we can use the second part of the monoid s to describe what we know about the set of possible states s could be eg that it is accessible from a certain state s composition on these sets is simply intersection and knowledge about possible states is freely as s s s finally there is a set of locally owned tokens t since we own them locally we know that no other party them composition is defined by and that the protocol does not own them either s s t s t regarding the second part of the monoid not all possible sets of states s are sensible every such set we define to exist will be stable knowledge meaning it cannot be by actions of the environment we thus restrict the set of possible states to be closed under transitions by the environment as formalized by the in figure s t s the figure also shows how to lift the relation between states to a relation between pairs s t s t says that the tokens in t one can move from s to s and end up with the tokens in t in our rpc sts for example we have tx rx on the other hand tx has no successor this definition gives rise to the following update the state and some tokens we can make any transition that is justified by the tokens we own s t s t s s t s s t t note how we use to to s we know that we are at least in s while encoding as monoids is interesting we can only its true the island update we have a way of enforcing as protocols over the evolution of some shared state for that we need invariants ­ part ii invariants so far only supports reasoning about state that is owned by one thread or another there is no mechanism yet for sharing state between threads to support such sharing we extend the logic now with invariants given a proposition p the assertion p asserts the existence of a shared invariant named which resources satisfying p since invariant assertions just assert the existence of a shared invariant they are pure and thus freely p p to access the shared resource they invariants can be for the of a atomic expression opening an invariant grants temporary ownership of the shared resource once the invariant is possibly after resources have been in or out it can be closed again the following inv rule which will turn out to be derivable from other rules grants e ownership of shared resource r for the of its execution inv r p e v r qe e atomic r p e v qe for now ignore the later modality we will come back to it later the rule read backwards says that if you know that an invariant r with name exists you can add its resources to the precondition the verification of e can then freely use those resources as it but it must give back control of some resources satisfying r when it is done masks to ensure that each invariant is at most once we annotate hoare triples with an invariant mask for the hoare triple p e v qe we can assume the invariants in e hold prior to the execution and must them after each single physical step we say that the invariants in e are enabled which means that they hold on some portion of the shared physical and logical state here e is a term of type type of invariant masks which are simply sets of invariant names view shifts it is helpful to think about the inv rule as combining three separate steps of reasoning first note that in the conclusion is enabled which means that it can be and the resource satisfying r can be from shared control to the local control of e second this resource together with p is used to reason about e which r and some additional q under the assumption that is third the invariant is closed which returns the resource satisfying r to shared control and the original invariant mask for reasons that will become clear in § we find it useful to be able to reason about the opening and closing steps of this rule independently of the reasoning about e that goes on in between consequently instead of taking inv as primitive a novel notion of view shifts that can open or close invariants this is achieved by annotating view shifts with two sets of invariants those that are enabled before and after the update the view shift p e e q expresses that it is possible to update the local state from p to q without updating the physical state where only the invariants in e and e are required to hold before and after the update respectively we write p e q as syntactic sugar for p e e q the and rules in figure express invariant opening and closing as view shifts the rule of atomic consequence in figure allows us to open invariants e for the of an expression e provided we close them again this rule can be composed with and to obtain inv as a derived rule note that can only be sound for atomic expressions after doing one step in e another thread may be next to compute and it may rely on invariants in e we will see in § how to give specifications for functions that are not atomic while still allowing opening invariants our more general notion of view shifts will prove to be very helpful there view shift rules view shifts permit a frame rule similar to the usual frame rule for hoare triples however this rule serves syntax p e · · · p p · · · name proof rules p e e p p true p p p true figure syntax and proof rules for invariants e e e p e e q q e p e e r e r p e p r e e e q e e q r pp pe e ep p e v q e v q e e e q e atomic p e v qe e figure most important view shift rules cf our appendix not only to frame resources around a view shift it can also be used to frame invariants if some invariant not covered by either mask of the view shift is known to be enabled it remains so when the view shift is applied hence view shifts may only affect invariants that they explicitly name in one of their masks the same kind of is possible for hoare triples we refer the reader to the appendix for the full set of rules the view shift transitivity rule allows two view shifts to be combined provided they agree on the invariants that are enabled between the two view shifts and that those invariants are not in the conclusion e e e this side condition is necessary to ensure soundness of the rule new invariants are created by local resources satisfying the invariant to the shared state as this involves a of resources from local to shared but not any actual change to physical state it can be expressed as a view shift the rule in figure allocates an invariant with a name chosen from a set of possible names e we require e to be infinite to make sure that there is some invariant name in there that is not taken already and since we can pick the infinite set we can reason that the different invariants we create have different names by creating them with applications of with disjoint es disjointness of invariant names is important if we wish to apply inv in nested fashion since we will have to prove that each invariant is at most once later modality since any assertion can serve as an invariant one can define invariants that refer to other invariants or even themselves this introduces a potential circularity following and we use to break this circularity and the notion of steps using a later modality the assertion p expresses that p holds one step later to ensure that invariants are well defined the shared resource up p need only satisfy p thus opening an invariant grants ownership of the shared resource one step later conversely to close an invariant it suffices to the shared resource one step later if a resource p holds now it also holds later p p with propositions things are simpler propositions are not affected by as expressed in rule examples of such propositions include physical state assertions and ghost assertions primarily when reasoning about propositions appearing in invariants if an invariant is we can immediately view shift from p to p by opening the invariant to obtain p then applying the formal definition of can be found in the appendix invariant constructions in combination with invariants the monoid constructions presented in § let us encode powerful patterns for local reasoning about protocols on shared resources including several that were developed in previous work to achieve this an abstract protocol as defined by a monoid is to an interpretation of what the protocol is intended to guarantee about some shared resources and the desired connection between the two is enforced with an invariant it is then possible to derive hoare triples for expressions that update the shared resources in with the protocol with interpretation the whole point of the encoding of from § was to be able to define protocols capable of some shared resource eg the pointer structure implementing some concurrent mutable adt although in general the shared resource need not be physical to support this functionality we begin by extending the from § with an interpretation s for each state s which will say what property should hold of the underlying shared resource when the current ie state of the sts is s let the sts s interpretation function s prop and instance name be given we then define the following invariant s s s s by creating this invariant we enforce that the current state s of the sts instance is a shared resource as is whatever shared resource up its interpretation s which is the state that multiple threads want to access concurrently returning to the rpc example from § let us assume knowledge of an sts invariant an instance of the rpc sts in figure suppose we own resources p and the sts resource rx and want to transition the sts to state done and establish q our ghost resource represents knowledge that the sts is at least in state rx and ownership of no tokens when we open the invariant we learn the state s rx done and take ownership of s the knowledge we started with ensures s tx since we want to transition to done our primary proof obligation is to show that no matter what s is we can update the resources on hand p s to having proven that we can then close the invariant and away with done q the ghost represents our updated knowledge about the sts this general reasoning pattern is reflected in the derived rule sts in figure if we ignore the tokens for simplicity the rule says if we know the sts instance is at least in state s and want to update the sts then it suffices to show that for any future state s of s we can adding s to our precondition establish s in our postcondition for some future state s of s the rule matches exactly island update rule as with inv from the previous section it is derived using and the proof follows the same decomposition open invariant reason with additional resources close invariant the only difference is an additional update using right before closing the invariant monoids with interpretation in this section we implement the second layer of our stack figure using reasoning principles similar to those et al developed for types we derive these principles by an interpretation to the monoid much as we did for the monoid in § consider the hoare triples we obtained in figure to reason about language primitives they all carry in their precondition a physical assertion about the global machine state which can only ever be held by a single party these are called specifications as opposed to the specifications given in figure which only mention the channel they operate on we aim to derive these we will achieve this by putting ownership of the entire physical state into an invariant so that it is shared by the invariant this physical state to a ghost resource so that fragments of the ghost resource which can be split up among different threads effectively control fragments of the physical state we can model the state of a network using the monoid net this gives us an adequate level of sharing we can make assertions about individual channels without all the others next we define the interpretation net prop that we wish to hold for the state of this monoid ie the composition of all fragments c c here we implicitly coerce between the finite partial functions in net and the ones the possible physical states to tie the two together we use an instance of and the following invariant c · c c we extend to net prop by setting false now assume that we own c m which we will write c m and consider what we obtain upon opening the invariant while we cannot know which c witnesses the existential we know from the definition of that c m c and thus cc m with our temporary ownership of the shared physical state c we can justify operating on our channel c all of this follows just from c m which is a purely logical assertion that has nothing to do per se with the physical is the invariant which lets us decide how we want to tie the two together after the operation on c we make us of the fact that we own both the state and the fragment c so we know else can hold any knowledge about this channel hence we can do a update the ghost state with the new physical state and closing the invariant in general we may want to give an interpretation m prop to every nonzero element of some monoid m we can do so with the invariant c · c c the reasoning pattern enabled by this construction is by rule in figure the rule says that if we know an invariant the part of to and if we own the fragment a in then we can gain access to the interpretation a · af of the current state where af is everything owned by the environment if using the resources of the interpretation together with the p that we carried in we can establish b · af which implies b af together with q then we are allowed to carry out whatever was left in q and update our ghost fragment to b like sts this rule combines opening and closing an invariant with a update except here the update uses rather than the triples given in figure are derived using the mask will contain the name of the invariant note that we make crucial use of the rule here after opening the invariant we actually obtain c but physical state assertions are so we can immediately view shift that to sts s s t s p e v s t s t s t s qe e atomic s t p e v s t s t qe inv r p e v r qe e atomic r p e v qe e atomic m af a · af p e v b b · af qe a p e v b b qe figure derived rules to reason about shared state true c c c m m v v c m c m c v m v none c m m m v c m m figure derived rules for language primitives see figure for the basic rules c and not with the furthermore we obtain a single unified description of by case distinction on m this pattern turns out to be very expressive it is applicable whenever it is necessary to collect some state in a central place and useful to ownership and knowledge about parts of this state for example in a language this pattern easily to provide fractional permissions also note that corresponds closely to et als sharing rule this is yet another example of ability to derive powerful reasoning principles that are built fixed into prior logics semantics the semantics of is defined in the technical appendix and formalized in the coq development in this section we give a very brief overview of the model to model invariants assertions in are modeled relative to a world that describes the invariants allocated so far since invariants are themselves expressed as assertions this introduces a circularity in the modeling of assertions and worlds this is the standard circularity that also arises in models of type systems with dynamic allocation and higherorder store we use standard techniques to solve the circularity and in particular et als library for solving such in coq the construction of the semantic domain of allows us to model parametric in the ghost state monoid invariants and monoids are thus also orthogonal semantically adequacy theorem expresses that if e v v is derivable and e executes to a value v when started in physical state then v satisfies here v is a pure predicate ie it describes a property of v and cannot mention resources or invariants formally theorem adequacy if e v v and i e i v t then v the t in the final state permits e to fork off other threads soundness of the underlying higherorder separation logic the rules in figures and and the adequacy theorem have all been proven in coq true c c m c m m v c m m v m c m recv c m c m m m m where recv rec recv c let v c in case v of none recv c m figure logically atomic spec for channels with blocking recv logical atomicity how can triples like the ones in figure be used of course one could just use them as normal hoare triples and establish c m before calling them this however would effectively access to the channel every caller would have to prove that they exclusively own the channel in order to access it moreover we often want several threads to be able to race for access to the resource for example consider the case where there is an invariant even the channel making sure it only ever contains even numbers m c m m m m n m is even even since send is a atomic operation we can use inv to gain access to the channel we can open the invariant around the call to send atomically observing the current state of the channel if we are sending an even number we can the invariant after send is done and close it again this is sound because no other thread can interfere with the atomic call to send in this case we say that we have a atomic triple for send now consider the blocking implementation of recv defined in figure we would like to do the same kind of reasoning eg to verify that recv c always returns an even number but recv is not atomic so inv does not apply however intuitively recv behaves as if it were atomic there is a single point in time often called the linearization point where the receiving action is logically committed namely the instant when succeeds we to be able to exploit this and call recv based on the channel assertion that is by if we only have a normal hoare triple for recv there is no way to do this our goal is thus to find a notion of a logically atomic triple that admits the reasoning principles given in figure but is applicable to functions like recv now note that all of our reasoning principles in figure were derived using which lets us compose atomic triples with view shifts that open and close invariants whereas the corresponding rule for general expressions works only for view shifts with the same set of invariants enabled on both sides it is thus justified to say that logically captures the essence of what it means to be atomic hence logically atomic triples should support the same kind of reasoning and we will use this insight in determining how to define them logically atomic triples in order to the definition of logical atomic specifications it is helpful to consider the needs of both a client using such a specification and a module proving it client perspective what would it mean for recv to support a reasoning principle like well for example we would like to have the following instantiation of c m recv c m c m m m m p e m m c m m m m e qm p recv c m e as a client of the module implementing recv we would expect that module to prove the first premise we would then give proofs for the two view shifts and obtain the conclusion now recv is not atomic so is not sound however we can transform into the elimination form of its first premise ie into the statement that can be applied to recv p q e m p e m m c m m m m e qm p recv c v e if this is the interface provided by the module then we as client can do exactly the reasoning that would allow us to do the key observation is that such a statement can be made about any operation be it atomic or not there are still some problems though suppose we want to call recv on the channel c by the invariant even to do this we have to choose some m and then prove that we can view shift from p to c m however we only learn the current m after opening the invariant inside the proof of the the view shift so we have no way to fix it a priori furthermore we cannot prove the second view shift at that point we have that all messages in m are even numbers so we cannot the invariant to solve this we introduce a special treatment for m such that it only has to be fixed after opening the invariant we will also in an application of frame similar to how was into this leads us to the following p q r e p e m c m rm m m c m m m m rm e qm m p recv c m m qm e this is strong enough to be useful in our example we choose p true q m m n m is even e even rm m m m n m is even the view shifts are then easy to show applying this yields the desired triple stating that recv c always returns an even number true recv c m m n m is even note how our ability to prove the postcondition that m is even relies on the fact that the frame r can depend on m module perspective let us now switch roles and consider the case of a module that wants to provide a specification like this means we get to assume some arbitrary p q r e and the associated view shifts and we have to prove an ordinary hoare triple unlike in the normal case of proving a triple we do not have access to the resource c m that we operate on instead we own x e v em e em e p q r er x p rx er v p e v x qx v qx v em e x p r er v q em e er e em p em em er x r x v r em er em q figure definition of logically atomic triples and atomic shifts some p about which we only know that we can view shift to the desired resource how can that be enough the key is this at the linearization point as explained above the single step of execution where the operation commits we will make use of the view shifts we have been given together with rule to grant us temporary access to c m for that one step formally at the linearization point we will use the view shift from p to c m which may open some islands e hence we call it the opening view shift after operating on the resource the only way to complete the proof is to use a corresponding closing view shift of which we have only one to view shift the updated resource back to q since this marks the point in time where the atomic action commits we also call this the view shift note that since we do not know anything about r we have no choice but to use the same m with q that we originally from the opening view shift sometimes however one has to deal with an operation that could be the linearization point but it is not known up front ie until reasoning about the postcondition whether that will be the case for this reason it is necessary to be able to abort an atomic update for example recv internally uses which has two possible outcomes either a message was received in which case we can commit and are done or the channel was empty in which case we loop again thus in the proof we would be stuck if the only closing view shift we had at our was the one hence we extend to assume an additional view shift as another closing view shift which lets us go back to p if the commit did not happen we arrive at the following general pattern p q r e p e e e x x rx x v x v rx e e e qx v p e v x qx ve e leaving aside the generalization of the predicates the only difference from is that the first view shift is now bidirectional formal definition we define logically atomic triples in figure note that x is free in r and q while v is free in and q and also note that e e denotes disjointness of invariant masks the definition differs from only in a few technical details first of all we collect the antecedent of the implication into its own syntactic sugar which we call an atomic shift an atomic triple is roughly an implication from an atomic shift to a normal hoare triple that the pre and postconditions of the triple and the shift together we give this hoare triple a fixed mask since e will generally not be atomic cannot be applied so a smaller mask would be of no use to a client the definition three masks e em and er what are they well it turns out that rather than about the invariants that the client may rely on being enabled that would be e e in it is often more convenient to talk about those invariants the client may not rely on in figure we write e to denote e e atomic x e v em x e v em x e v em e x x e v x e v em e e em x p e v p em ee x y e v em e x y e v em e x e e e x e v em e x v e e e x e v em ee e em x r e v r em e em r x e v em e x s s s t s e v s t s t s t s em e em x s t e v s t s t em e figure selected proof rules for logically atomic triples context m p c m r er m c m m m m p qm m p c m rm let v c in open er c v none m m c m m m m v rm p v none er m m qm m v p v none m m qm m v case v of none p recv c m m qm m m v qm m m m m qm m figure proof outline for recv or pure like invariant assertions it is thus possible to move the pure assertions into the context which means we can make them available anywhere and to put the resources into p finally note that atomic shifts and atomic triples like view shifts and hoare triples are pure facts and can therefore be duplicated derived rules these definitions support the derived rules given in figure most important is the rule of consequence which like the original may be applied to view shifts that change masks but with we can open invariants around expressions like recv that are not atomic in other words for any expression satisfying a logically atomic specification we can apply reasoning patterns eg that in most logics work only for atomic expressions shows that any atomic triple is also logically atomic the rule permits us to bind a variable in the atomic shift unlike in the standard existential rule for hoare triples cf our appendix it would be unsound here to move y all the way out of the triple to a universal quantifier finally can be used to convert logically atomic triples to normal ones this is where the restriction its only slightly head the first two masks describe invariants that the module knows and about we call em the module mask these are the invariants the module wants to be able to open up before calling client view shifts so it is essential that the client not depend on these invariants at all we call e the shared mask these are the invariants that both the module and the client may depend on and that therefore the client may not in its atomic shift both of these masks show up in logically atomic triples themselves the third mask er we call the client mask this is a set of invariants that the client depends on and in its atomic shift the module does not know or care about these invariants and thus the client can choose er arbitrarily so long as it is disjoint from the first two masks the atomic shift imposes a somewhat odd restriction that p must be the reason for which is as follows it is necessary when opening an invariant to it with the modality see but with logically atomic triples it is often the case that invariants are in a nested fashion ie the caller an invariant around the triple using figure and the module itself another invariant at the linearization point ultimately however this all happens in an application of around a single physical step of the underlying language so there is just one physical step available to strip off a single this issue is solved by making p which means we can use to deal with the in practice this is not a serious restriction the assertions we use are typically either like ghost resources proof of blocking receive as an example of working with logically atomic specifications we are going to derive the already mentioned specification for recv c m c m recv c m c m m m m first we unfold the syntactic sugar for atomic triples we thus get to assume some p q r er such that the atomic shift shown at the top of figure holds the most important step of the proof outlined in figure is to establish the following triple p c v p v none m m qm m v intuitively either returns some message and completes the update yielding q or it returns none and maintains p once we have shown this we can use to obtain a normal hoare triple and complete the proof with standard reasoning to show we will have to use the atomic shift it is clear what to do in the precondition we are going to open the invariants er with the opening view shift obtaining c m for the postcondition we are going to use the view shift in case and the view shift otherwise hence we have to show m c m rm c v c r v none m m c m m m m rm v er now we can apply to bind the m followed by but without changing masks to make use of this bound variable in the postcondition m c m rm c v c v none m m c m m m m v rm er note that after rm with this is exactly a logically atomic version of the spec for given in figure we are thus just a single application of away from the proof this also shows that our construction only requires a logically atomic spec for does not depend on being atomic together with the triples for send and in figure and an application of this completes the proof of the channel specification from figure with this example we have illustrated how to prove a logically atomic specification for recv and how the logically atomic specification of supports reasoning principles normally for atomic expressions putting logical atomicity to work now that we have proven a logically atomic spec for recv we are in a position to state and prove a logically atomic spec for mutable references using the wellknown encoding in figure the idea behind this encoding is to represent a reference as a channel on which a background server process for requests allocating a reference ref e involves allocating a fresh channel r which represents the reference and off a server process r e this server process will for messages from client processes that send it get set and cas requests on r in order to perform reads and writes on the reference each such request includes a generated reply channel d along which the server sends the result of the operation by analogy with modules we wish to show that this encoding is a functor if and satisfy a logically atomic spec for channels then ref and cas satisfy such a spec for references in figures and we define predicates chan and ref to represent the signatures of channels and references in which the specific masks expressions and abstract predicates that a particular implementation would define are held abstract the concrete predicate in figure satisfies these properties we can implement chan note that we require the abstract predicates to be so they can be used with in our appendix we verify references as channels by proving ref ref cas to our knowledge the correctness of this encoding has not been specified and proven in this modular style before prior work has shown that an entire language with references can be translated into calculus let expressions and be given define ref e let r in fork r e r e rpc e get e e rpc e case e e rpc e case e where rpc r m let d in d m d r rec let d m r in let reply m v m loop v in case m of get reply v v reply w v let b v v in let v if b then v else v in reply b v figure implementing references as channels since the reference operations use the channel interface we require that all invariants needed by the channel operations are available in furthermore the reference module allocates an invariant in order to enforce a protocol on the ghost state underlying the abstract pointsto predicate thus there need to be infinitely many invariant names it can use for its own purposes to satisfy this is also the reason that is a view shift rather than an implication note that we can completely abstract away from how the channel operations treat their invariant names just as users of ref do not have to care about the fact that some of the invariants in actually belong to the channel module this shows that with some small effort proper abstraction is possible in despite our use of global invariant masks at view shifts and hoare triples in our proof of the server thread for a reference is the one that actually commits all operations on it by performing logical updates on of client requests hence a client thread must transfer its atomic shift and precondition p to the server which it does using the invariant of the reference module this transfer is made possible by the fact that invariants in are impredicative as explained at the end of § the server can then apply the clients opening and view shift sending q back to the client this is a particularly simple example of a common in finegrained concurrent algorithms to make the proof work out we had to change the code in figure slightly at some places we introduced skip to be able to strip off a since adds a to the invariant this means we have to take a physical step if the invariant is around the last operation a function is performing and the functions postcondition does not specify a the need to insert such is a known in the world of stepindexed logics but it is sound adding does not affect the observable behavior of a program for the kind of observations we are considering as logically atomic triples are compatible with advanced techniques for reasoning with shared state eg it is straightforward to verify clients of the module against the abstract spec ref to this point our appendix includes a verification of elimination stacks · · val × bag prop c m m c m m c m c m false true c c c m m c m m x c m m x c m c m c m c m m m m figure specification for channels with blocking receive ref · · val × val prop r v v r v w r v r w false v true v r r v r v r v r x r v x v r v r r v x r v x r v v v r v v v b b true v v r v b false v v r v figure specification for references a challenging example from the literature that in a more complex way than the module does this verification is parameterized by an arbitrary implementation of references that is assumed to satisfy the logically atomic spec ref the code and proof closely follow those in the technical appendix of the difference being that the proof depends on the reference operations being atomic whereas ours does not with this we complete our stack of abstractions figure related work in the introduction we motivated in relation to the state of the art in modular concurrency verification here we give a few more detailed comparisons with the most closely related work monoids the of partial commutative monoids back to the models of separation logic but only recently did a number of different models and logics begin to employ as a way of characterizing more finegrained notions of interference the views framework in particular enables the user to tie logical resources represented as a of the users choice to physical resources according to a particular userdefined interpretation of logical resources as assertions about physical ones in this way views like supports reasoning however views is limited in that it effectively requires the user to in a fixed invariant logical to physical resources with no logical support for further invariants on top of those logical resources in contrast provides builtin logical support for userdefined invariants over logical ghost resources these are crucial eg for enabling the verification of elimination stacks to impose its own invariants over the logical pointsto assertions exported by the module one layer below furthermore although we have not it in this paper invariants can be defined using higherorder guarded recursive predicates to unlike in views which only supported firstorder logics view shifts were introduced by the views framework as a specialization of the notion of from cap a describes an update of ghost state in terms of an update of the underlying physical state a view shift in is thus simply a that preserves the underlying physical state cap uses a twolevel approach for reasoning about atomic expressions one has to prove how the expression updates the physical state and separately prove a that relates this back to the abstract level in rule offers more finegrained control instead of going all the way to the concrete physical state it is possible to open just as many levels of abstraction as are needed to justify the execution of the atomic expression although we believe our monoid encoding of with tokens is novel most of the monoid constructions we used have been described previously in particular et al treat monoids in an algebraic manner as separation algebras sa they provide various generic building blocks like discrete sas equivalent to our exclusive monoid products and sums as well as a generalization of fractional monoids they call shares to facilitate the treatment of sums their monoids can have multiple units we believe that our restriction to a single unit and a single zero can be lifted easily unlike sas our monoids do not generally have to be invariants the idea of relating logical resources with physical resources through invariants is also present in and work on monotonic state and work on separation logic and et als work on types they are all restricted to a sequential setting and system uses variables whose values grow reason locally about lower bounds on ghost state using invariants they lift these reasoning principles to monotonic physical state invariants and are orthogonal independent principles supports similar reasoning principles for monotonic state through an encoding of as separation logic combines monoids with indirect hoare triples specifying an interpretation map which serves as invariant their approach is based on a syntactic translation into a standard separation logic and it is not clear how this approach extends to a concurrent setting types combines the approach of a type system with the more flexible forms of sharing supported by arbitrary monoids in as we have shown in § rule we can support reasoning in the style of sharing rule in the concurrent setting previous on and has typically fixed a particular and very useful monoid construction can be used to encode the patterns of reasoning found in these logics but with a simpler set of primitive mechanisms and proof rules whose soundness we have verified in coq in addition on a technical level is more general and expressive than these earlier logics like but unlike and supports full higherorder logic and impredicative invariants which are useful for giving modular specifications of libraries going beyond supports view shifts these are essential to our ability to encode logically atomic as shown in § the notions of logical atomicity developed in and are closely related as is evident by the extra binder both had to introduce the universal quantifier in and the binder in the precondition of logically atomic triples as well the similarity of the proof rules at this point lacks the private pre and postcondition of but they would be easy to add to the syntactic sugar like et al to provide a minimal basis for concurrent reasoning but is based on a ghost heap and invariants whereas ours is based on arbitrary ghost and invariants the two approaches are optimizing for different goals our logic is and supports more higherorder and logically is not making it better suited to use with automated verification tools like smt solvers however more work remains to be done to sort out the precise formal relationship between the two orthogonal bases atomicity concerning the proving of logically atomic is currently not able to reason about finegrained data structures that employ in this is possible thanks to the impredicative invariants see the example in § similar to the approach taken in which in turn was inspired by previous work of and on to support and thus also our model of is based on a solution to a recursive domain equation that is avoided in which instead attempts to use a kind of encoding of predicates however according to the soundness and the generality of this encoding approach of are and propose another approach to observable atomicity based on linearizability like they to an theorem when verifying clients against modules with atomic behavior however following ideas from et al their logic also supports speculative execution of linearization points which they use to establish soundness of the reasoning patterns developed by vafeiadis in his thesis further work remains to be done in order to extend with support for such speculative reasoning the same goes for and as well is important in verifying finegrained concurrent in which the ordering of a sequence of linearization points may not be known in real time but only after the corresponding operations have completed intuitively is challenging in because when we verify that a module satisfies a logically atomic spec we perform updates to the state of the module using view shifts provided by the client so the client can in theory observe the linearization points in real time to address this problem a natural starting point would be to try to follow the model of in et al and generalize assertions from predicates over resources to predicates over sets of resources but it is not yet clear how this would fit into our general approach to logical atomicity acknowledgments this research is supported in part by a microsoft research phd and in part by the advanced grant from the for independent research for the natural sciences we thank for discussions during her at and we also thank the anonymous reviewers for extremely helpful and detailed feedback references appendix and coq development m abadi and l lamport the existence of refinement mappings theor comput sci ­ a ahmed d dreyer and a representation independence in popl p and j solving reflexive domain equations in a category of complete metric spaces j comput syst sci ­ e a proving assertions about parallel programs journal of computer and system sciences ­ l birkedal b j k j and h yang stepindexed kripke models over recursive worlds in popl e et al invariants modularity and in psi p da t and p a logic for time and data abstraction in ecoop t l birkedal p m j parkinson and h yang views compositional reasoning for concurrent programs in popl t m p m parkinson and v vafeiadis concurrent abstract predicates in ecoop r a and a w appel a fresh look at separation algebras and share in x local relyguarantee reasoning in popl x r and z shao on the relationship between concurrent separation logic and reasoning in esop i p ohearn n and h yang the client on data refinement in the presence of pointers in m fu y li x z shao and y reasoning about optimistic concurrency using a program logic for history in concur d n and l a scalable lockfree stack algorithm in m p and j m linearizability a correctness condition for concurrent objects toplas ­ b personal communication b and f expressive modular finegrained concurrency specification in popl j b and l birkedal separation logic in esop c b jones steps toward a development method for programs toplas ­ n r a d dreyer and d types in icfp l lamport how to make a multiprocessor computer that correctly executes programs ieee trans comput ­ r and a auxiliary state for concurrency in popl h and x modular verification of linearizability with linearization points in pldi r milner communicating and mobile systems the calculus cambridge university press a r i and g a communicating state transition systems for finegrained concurrent resources in esop p ohearn resources concurrency and local reasoning ­ s and d verifying properties of parallel programs an axiomatic approach cacm ­ a and f pottier the essence of monotonic state in j c reynolds separation logic a logic for shared mutable data structures in lics f a y and l birkedal modular reasoning about concurrent higherorder imperative programs a coq k and l birkedal impredicative concurrent abstract predicates in esop a d dreyer and l birkedal unifying refinement and reasoning in a logic for higherorder concurrency in icfp a j a ahmed l birkedal and d dreyer logical relations for finegrained concurrency in popl v vafeiadis modular finegrained concurrency verification phd thesis university of cambridge v vafeiadis and m parkinson a of relyguarantee and separation logic in concur d walker objects in the picalculus inf comput ­ 