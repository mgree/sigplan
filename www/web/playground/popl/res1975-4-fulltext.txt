automatic data choice in a language of very high level computer science j t schwartz department institute new york university abstract setl is a oriented language of very high level whose of semantic objects includes finite sets ordered and sets of order ed as mappings this paper sets techniques for the cal analysis and optimization of setl programs the techniques described allow relations of inclusion and membership to be established the domains and ranges of mappings to be from above and below and the of mappings to be proved once facts of this kind have been automatic choice of data becomes possible the methods employed are based upon and extend known techniques of dataflow analysis keywords and phrases program gramming theoretic choice optimization high level languages automatic pro languages set data structure this work was supported by the al science foundation under grant x setl cf schwartz morris is a oriented lan guage of very high level whose of semantic objects includes not only the integers reals strings and procedures of programming languages but also sets ordered n tuples and sets of ordered as mappings a setl program may be considered to represent an algorithm as it exists before the detailed data choices which algorithm tion in a language of lower level such as pl or algol have been made because of the of setl its compilation produces code of rather low efficiency consisting largely of calls to library routines each of which implements the most general case of some basic settheoretic construction again because of the of the language most of the relatively routine decisions which a programmer makes in an algorithm efficiently are potentially an optimizing setl translator having a language of roughly pl level as target this paper will out line a number of program analysis in part built on currently known global optimization methods which should allow many of these choices to be made automatically for an account of cal global optimization techniques see allen a more detailed account of the to be sketched in the present paper will be found in setl and cf schwartz we note also as a necessary preliminary to this paper that although setl involves no type the types of the objects appear ing in setl programs p can be by an appropriate global analysis for this see the analysis described by yields rather precise information and eg is capable of discovering that the value of a variable x is a program p is a set of triples each having an integer first component a second component and a third component which is a set of integers we assume that this kind of detailed type information is available at the start of the more program analysis which we shall now describe we begin by introducing symbols for certain important monadic operations on setl objects i specifically the symbol denotes the operation of choosing a random member of a set i the symbol n an integer the operation of ing the nth component of a tuple i the symbol w the operation of ing an arbitrary component of a tuple the symbol ii n an integer the operation of choosing an arbitrary but not one of the first n of a tuple we also introduce symbols for various binary operations with boolean relation values denotes and c relations the membership of comparisons next these elementary relation symbols we introduce a family of composite symbols which we shall call relation strings let nk be symbols repre monadic on composite setl objects and let p denote a binary operation we that the mappings pi be singlevalued then if x and xl setl objects we write x nn p u pj if the relation ll x p lj holds the following are significant examples of this general construction means that the nth component of x x x means that every is a first belongs to x ie that x is a map with domain the relationship x e x means that every element of x is an element of xl ie that x is included in xl this is to ­ forms the family of the basic vocabulary of our analysis which ly true relationships aims to find relationships which must of the compile necessarily time hold structure because of a program p of in our analysis a program is by a family of basic blocks b consisting of assign ments the of p is repre by a mapping which sends each b into the set of all b to which control can flow when it leaves b we classify the occurrences in p of variables into occurrences occurrences and an resp able is an occurrence of a variable as the target of an assignment resp as an operator argument in the form of p as the first step of our analysis we subject p to the data analysis introduced by john and described in allen this produces for each i of p the set of all o which can supply a value to i note that we work with programs which consist of several subroutines some of which can be recursive and that our dataflow analysis must operate across subroutine boundaries allowing this are outlined in allen and schwartz once dataflow analysis has been performed the remain der of our analysis can be carried out in a manner which makes no reference to the flow of control in the program p being analyzed in particular the of and calls is not of additional complications our next step is to perform type analysis as described in this makes available rather detailed mation concerning the structural type of the values assumed by each and of p using this type tion we set up a collection of of the form ing this collection consists of all rela which are in view of the known types of the o or i variables x y and in view of the opera tor defining example the if x if x is an relationship x c x is x and xl are for only if xl is known to have elements of a type at least of x a set as wide as the type of x s x is of each of which the elements only if xl has a first is component which is of a type at least as wide as the type of x etc starting with the set of relationships for p our analysis algorithm then works downward systematically eliminating rela which might be false until a kernel provably of mutually and hence true relationships remains more specifically if i is an a rela for all can only hold if holds o the remaining rules for elimination of relationships reflect the properties of all setl primitive opera which can appear in the form of p the full set of rules is but we illustrate it by listing the rules which apply to the relationships this relationship is always false operation defining o is anything other than set union set difference and intersection ii i singleton formation ik application of a map of one or more parameters or tion of a tuple component ii or ii ik application of a valued map of one or more parameters if o is defined by o il i then o ol is false unless i c both hold if o il i then il ol hold if o il i then o is false unless either il ol or i holds if o i unless i c holds then if o c is o false with a then with set then il must hold to be true if o il k must hold i a tuple and the i i lf value of for i k li i is known to be n at compile time then o cm only be true if il n is true if the value of i is not known at compile time then il co must be true if o ii o i i then ik il e o and if then must note also a few basic set such as the null set and the null tuple will enter opera tions as each of these has properties which are to be exploited in applying the above rules relationships satisfied by whose value is established by a read operation must be declared in appropriate form the technique of above modified in can also be used to relationships analysis a fairly establish o sketched evident way useful and relationships o al where denotes the it can be used to establish arithmetic inequalities x x y and their set theoretic x etc the rules applied in proving such arithmetic are by the following statements if is defined by ­ will if is defined be rejected by o i unless selection i of an element from i then i must satisfy i for o to hold to avoid the generation many initially relationships if too many are generated our analysis will become inefficient we conjecture relationships o only if the o and are instances of variables v and v for which a test vv is made in the program being analyzed and conjecture o only if either v c o occurs in a if at some point v is initialized to zero the methods of analysis outlined above can be improved so that the analyzer is aware that immediately after instruction ts s s c t is necessarily true this is accomplished by automatically inserting after t s s a similar technique can be used in connection with conditional branches so that eg the analyzer will know that x e s along one branch of the conditional if x e s then and that x e s along the other branch for use in connection with such it is convenient to introduce a which may be by the symbol where x y has either the value x or the value y but where it is understood that the operator is only to be used when it is known that x and y have the same value note that this construct makes a logical or available during global analysis since z x y z will have all the properties by either x or y in contrast flow paths are associated ing analysis not with the or operation but with the logical operation of inter section which is applied to the proper known to hold for a variable after a of together flow paths has come in optimizing setl programs it can sometimes be useful to estimate the domain of a mapping f from below ie to show that the domain includes all of some set s this information if available can be used either to ensure that a value fx is not q ie undefined or to justify the association with each element x in s of a field for the value fx the constructions which are normal ly used to build up a function f defined everywhere on a set s are as follows i the set s may be defined then f may be defined for each s either by an iterative loop first element eg and of f vx s fx o or by a set expression eg f x s ii the set s may be built and f defined for the s as these elements are added in the pattern s sx fx up elements of to s eg y of these by treating iterations two cases i is best handled both explicit set theoretic vx g s and the set theoretic iterations implicit in expressions such as in terms of auxiliary sets s and s representing all the elements x in the iteration where sl resp s is updated immediately before resp after each cycle of in such an approach is treated essentially as if it were sl s initialize sets to null while x sl choose element arbitrary of ss block s sx end while ss l s if this transformation the analytic methods suffice in cases like that the domain of f is applied then outlined earlier will and to prove includes s case ii by is more difficult to handle to treat it we can allow our routine statements of the form to s c x domain f if the analysis algorithm is to be of reasonable efficiency it is important not to permit facts of so compound a structure to be unless they are likely to be both true and useful to help ensure this we allow statements of the form to be manipulated by our analysis routines only if x occurs in an assignment of the form fx and only if x e s s c and x domain f are all in dealing with maps it is generally important to know when they are single valued when true this fact will often be provable by a straightforward variant of the techniques that we have described specifically we can introduce a family monadic assertions concerning sets f of ordered writing these assertions as where n the assertion of that f is a singlevalued map of n parameters this relationship is only if f is a set of nl or is the null set the assign ment f nt a f a f holds after an of the xn if it holds before this assignment applying these rules and a few others we can eliminate relationships from an initially set until the relationships which mutually remain become once information concerning set tic relationships of inclusion membership domain inclusion and of maps has been collected we are in a position to make automatic datastructure choices for a study of some of the issues which arise in connection with such choices see low to implement an abstract algorithm p efficiently a manual programmer designs data structures such as arrays structures containing sub fields lists etc which have the same information content as the abstract sets and mappings used in p but which represent this information in a and accessible able form any of these design decisions are relatively routine and can be seen by sampling the abstract algorithms collected in schwartz to depend only on tion derivable by the analytic methods just explained on information and on information concerning the opera applied to the objects generated in a setl program to be optimized schwartz describes algorithms which develop information of this last sort a typical device applied in designing the data struc ture of a program is to find cases in which a set s included within a set s can do without representation of its own perhaps because each element of s is a serial number represented by an nth bit of the vector whether the nth element of s does or does not belong to s another typical device is to find and exploit cases in which a map f known to have domain included in a set s can be represented either by a vector of items or by a collection of fields attached to the elements x of s where field stores one value fx data structure choice motivated by such considerations is amenable to automatic treatment here are a few of the principles which apply if s is to be represented by an bit vector we must be sure that s is not set up when the set s has one value and used later after elements have been removed from s if sl is a toplevel object which is not made member or part of any still more composite object only this check need be made to ensure that s can be represented by such a bit vector if s is itself made a direct or indirect part of some composite object y either as a set member or as a tuple component tional complications arise for tion of an bit vector to remain desirable in this case it is that each such y be dead at every point in the program p at which s is if this is the case we write more general relationships nk p p xl can be defined in much the same way when they hold strong relationships of the form logically validate a wide variety of data structure choices schwartz an algo rithm which finds all the y of which a given object s is made a direct or part and thus allows the validity of strong relationships to be determined e f s and s by an bit vector then this bit vector can be inserted in of s into any composite object y of which sl is to become part if all the members or components of y are then the mem and testing which such insertion would otherwise make necessary is the optimization techniques which have been outlined will generally improve the efficiency of setl programs substantially and should in many cases bring them to an efficiency comparing with that by manual a com optimization system these techniques is being designed at new york university be implemented there and will in we note that the above methods of analysis may be regarded as greatly variants of some of the techniques which have been used to prove more general assertions concerning programs such as their correctness however our are themselves responsible for choosing out of a quite a priori range of the propositions which they will attempt to prove the rela of implication with which they work is easily recursive rather than merely being recursively enumerable which is the case when proof of more general propositions is we observe that the techniques outlined above as well as the type finding techniques described in all have a number of properties in common basically they use a straight forward method of transitive closure to make any particular program property amenable to analysis one constructs some algebra a of symbols upon which programs p act in a manner to the detailed action of p on its data ment during actual execution all these algebras are finite enough for the action of p on a to after finitely many steps which implies that the inter action of p with a is a matter which can be fully out at compile time in implementation terms such algebras a are represented by tables or subroutines whose separate entries describe the action on the symbolic entities of a of each of the primitives of the language l to be ed wy such table defines some aspect of the basic knowledge concerning l which an analysis algorithm will have a suitable transitive closure algorithm then this knowledge globally over the program to be analyzed for a related remark on optimization technique see f e allen optimization ing co a basis for program proceedings of the ifip northholland amsterdam data proceedings of the ifip north holland ing co amsterdam flow j r low automatic coding of data phd thesis stanford university choice j b morris and of california a comparison of sci lab j t schwartz examples of its on programming on the setl project the setl language use pp new an and york university of inclusion and membership grams setl no university relationships in setl pro new york more on copy tion of setl programs setl no new york university june the structure of objects appearing programs setl no york university april in setl new optimization new york interprocedural setl july no optimization of very high level languages to appear journal of programming languages york m a mathematical of global program optimization prenticehall co n j theory m of programs mode ls calculating by valuations sigplan notices properties on specific vol no a revised and extended algorithms for the types of objects appearing in setl setl no new york october analysis thesis in a very high level new york university type language october 