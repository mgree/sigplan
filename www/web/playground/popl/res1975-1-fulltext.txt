node applied to data flow analysis k w kennedy university abstract a new approach to global program data flow analysis which constructs a node listing for the control flow graph is discussed and a simple algo rithm which uses a node listing to determine the live variables in a program is presented this algorithm combined with a fast node listing con due to aho and unman produced an on log n algorithm for live analysis the utility of the method is demonstrated by an of the class of graphs for which short exist this class is quite similar to the class of graphs for programs i introduction analyzing computer programs at compile time for code optimization one a class of problems which the construction of data flow information from the control flow graph many algorithms for the of such in formation have appeared in the literature al az ac au hu ke ke ki most of these solve a problem and require n extended or steps where n is the number of vertices in the control flow graph recently unman u published an algorithmic method which can be used to solve a number of these problems in on log n extended steps the purpose of the current work is to follow a new line of attack from the control flow graph of a program we construct an intermediate repre of the flow called a node listing which is then used to solve data flow problems this paper is primarily to an intro the foundation grant gj of computing activities treatment of the basic concepts surrounding the node listing the final section however the class of graphs for which the node listing method produces linear time algorithms for data flow analysis ii control flow analysis the flow of a program usually begins with the program expressed in some intermediate text which is scanned and into basic blocks sequences of instructions which are always executed in order after the last instruction in a block control may transfer to any one of a num of basic blocks called successors of the block just executed we may represent a program by control flow m or flow graph in which each node represents a has c block and each edge represents a possible transfer a flow graph is therefore a triple g where n is a finite of nodes e is a finite set of edges a subset of and no is the unique node with no pre called the program entry node in these terms we may define the set of successors sx of a block x sx y similarly we define of x px the set of px y ce a in the control flow graph from nl to k is a sequence that n n ie of nk of nodes such is k the path length the number of edges used in traversing the path a simple path is a path in which no node is repeated except possibly the first which may also be the last a simple cycle ia a simple path nl nz n kl such that nl nk iii data flow we shall consider data flow analysis by studying a representative problem that of live variables within a program given an item variable x which is defined at various points in a program we wish to determine for each point p in a program flow graph whether or not x will be used after control leaves p we that dead x ia live at at p otherwise p if it can be used again and the live information would be useful in register allocation for example since the value of a variable which can never be used again need not be saved for simplicity we formulate another version of this problem for each block b in the program determine the of variables x for which there is a path from the entry point of b to a use of b which path is contains no of the x we can now translate this problem to one of solving a of boolean let be the set of x which are live on entry to block b because there is a use of x within b which is not by a let be the set of x for which there exists an path through b note that the sets and can be computed by a local of block b now there exists an path from the entry of b to a use of x if and only if there exists such a path to a within b or through b to a successor of b snd there to a use in equation form ij the solution to this system of clearly a solution for our simplified live problem several methods for the solution of have been proposed ke hu all the proposed methods involve n algorithms even though method u provides an on log n algorithm for a related but somewhat different problem the author knows of no algorithm to solve which ia faster than on in particular the method of unman cannot be adapted to live analysis in a straightforward way we here present the simplest way of solving the live equations in of finding its sources of suppose we begin with all tbe live sets empty and iterate through the graph change equation until none of the live sets this method has been studied by several authors ke ki we here present a of the method adapted from and unman algorithm a live analysis and unman a flow graph g with the from to n in some suitable manner each node is referred to by its number sets and inside j for all j w sets method al ti let lin az do step a for j n in order if any changes for any j repeat step a other halt a apply equation to block j and unman have that this algorithm is correct and that step az will be executed at most d times where d is equal to the maximum num of backward branches in any simple path within the flow graph hu since step a requires steps applied to every node in the graph for each execution of a a total of ini steps are required it can be ke that d is in the worst case ao the algorithm may re ie steps on when ever the graph is restricted kn for some fixed k so that there seem to be two major areas of in this approach an extra pass through the program ia required to discover that no sets have changed this and the testing for changed sets on every produces a lot of un necessary work that might be avoided if we could know when to halt the iteration second iteration over every node in each pass seems to be the problem is to iterate exactly enough times to transmit information along any simple path in the program the node listing method attempts to overcome these difficulties iv node to gain some motivation concept consider the flow low for graph the node in figure listing be figure a graph on this graph the approach to live analysis could require iterations over the four nodes however if equation were applied to nodes in the all the live sets would be correctly computed and fewer than two iterations through the graph would be required the node listing method is on this tion a node listing is really a specification of the order in which an equation is to be applied to nodes of a graph as it happens these are often quite short and the algorithms which use them are fast we define a path in a flow graph g n to be a simple path such that no simple path from nl to nk is contained as a subsequence of in figure below the simple path ia not basic because it contains the basic path o figure simple and basic paths in dealing with data flow problems we will be con with basic paths as we shall see longer simple paths can add nothing to the data flow information being propagated for example suppose that we are trying to determine if vari able x is live in node of figure suppose also that there is an exposed use of x in node we wish to know if there ia an path from node to node in determining this we need not consider the path be cause if this path is then the path must be also the basic path restriction ia weaker than a simple path tion and should allow ua to find we now define a node listing for program flow graph g n to be a sequence nm of nodes from n where nodes may be repeated such that every basic path in g is a subsequence that ia if is a basic path in g then there exist indices such that li k jk and xf ni theorem listing proof nodes for any flow graph there of length nz where suppose x of the graph then a node n in i are all the x y xn xl x with n xn xl of xl certainly such a listing xx x is a a node listing is said to be minimal if there exists no node listing for the same pro gram flow graph we will be concerned with find ing minimal or minimal before let us examine the utility of this concept suppose we have a node listing for a given flow graph g then the following algorithm computes the live acts in g algorithm b live analysis via node listing a flow graph a node listing g l xl xz xa for g the sets and for each node the sets jn method for each b initially let b perform step b once for each node xj in l in reverse order then halt b apply equation at x theorem algorithm b terminates and correctly computes the live sets proof termination is trivial to show correctness we must show that ia correctly computed for each node j let j be an arbitrary node in the graph and suppose x ia live on entry to j then there must be an path in g to a use of x furthermore there must be a basic path to such a use since every path contains a basic path removing nodes cannot cause a path to lose the property let jl j be such a path where suppose also that a use within j otherwise step bl the fundamental x is not live due to it is marked live in property of node us that jk ia a subsequence of l so the nodes of our basic path will be processed in the order when node ia processed x will be put in t s live n jk and x can not be in since the path is a chain of similar arguments allows us to conclude that when will be put in j is processed x since it was put in on a previous step thus if any variable is live on entry to any node that variable will be put in the live set for that node during the algorithm if a variable ia not live at arbitrary node j then it cannot be added to by the correct ness of equation used in b ke m theorem complexity of algorithm suppose that each node in g has at most k successors for fixed k then the total number of steps required by the algorithm is l proof step b requires and it ia executed kl exactly where denotes of the listing m the speed of algorithm b depends directly on the length of a node listing for the graph to which it is applied the question immediately arises these listing be the next few sections deal with this question v flow graph unman ul has defined two which can be performed on a flow graph g formation q is the removal of the edge xx from g let y be a node having a single predecessor is the replacement x then transformation of the nodes x and t y and the edge x y by the single node z the new graph contains the edge zz only if g contained either yx or a flow graph xx is said to be reducible if re application of t and t until neither transformation is possible yields the trivial flow graph a single node and unman have shown that the property of is independent of the order in which t and t are applied an important result due to and unman hu will be useful later definition a node x is said to a node y if every path from x no to y contains theorem a flow graph ia reducible if and only if for each cycle c of g there is an entry node of c which dominates all other nodes in c theorem that all loops in a reducible flow graph are it is interesting to note that is a common property of programs in fact all structured have this property hu it is therefore to node reasonable to restrict our concern for reducible flow graphs vi listing graphs we can approach the node listing problem through an equivalent problem that of construct ing an acyclic graph which contains every basic path in g our motivation from the follow ing lemma lemma let g ne be an acyclic flow graph that not exist a sequence of nodes in g such that xl xk and then there exists a node listing of length in for g further more this node listing contains every path not merely the basic paths proof apply topological sort algorithm to the acyclic program flow graph the result is a linear listing yi y for g with one copy of each node in g let xl xk be a path in g let m be index of xi in the listing for g ie if xi xl is an edge in e then by the property of the topological sort the se of edges x implies mk so the path xl x is a subsequence of the generated listing since the path was chosen arbitrarily all such paths are sub sequences and the generated node listing listing is a h the reader should note that this proof is con in that it provides an algorithm for producing a listing the topological sort in time proportional to the number of nodes and edges ing we now to generalize the method of lemma definition a directed graph l nl el ia said to be a listing graph for gn if a l is cycle free b there exists a function which is onto the nodes of a listing graph may be thought of aa nodes of g that ia we say represents xn if yx every node in g is represented by some node in l however there may be several representations of given node the inverse of n nl defines the representations of ia the set of that is of x definition consider the path p xl x in g we say that such that if there p is reflected in exist nodes yi y a yi xi and b ie yi yk a listing graph l is a path in l ia to be complete g if every path in g is reflected for in l lemma let be a program flow graph and let be a complete listing graph for g then there exists a node listing of length n l for g proof by lemma there exists a node listing ll of length for l we produce a node listing lg by replacing each node y in ll by suppose xl xk is a basic path be its reflection is a subsequence in g let yl yk in l then yl yk of l by lemma so ia a subsequence of yk xl xk lg by construction since the algorithm for producing a node listing for g from its complete listing graph l ia linear in the number of nodes and edges in l we may view the problem of constructing a complete listing graph for g as equivalent to the problem of constructing a node listing for g the next theorem us to restrict our attention to strongly connected subgraphs of a flow graph theorem let be a program flow graph and let set of maximal c be the components of g each if there cl then there a node exists listing a node i for listing of length where no is the set of nodes in n which are not in any of the c proof let be the acyclic graph derived from g by replacing each component ci by a single node c then and by the e a node listing l of length m for g now replace each node ci in l by the listing i the length of the listing l is we need to that l ia a node listing for g let p xl xk be a path in g case all the of p are in some strongly connected component ct then p must be a subsequence of the listing and hence a subsequence of l case the nodes of p are not contain ed in any ct suppose we break down the path into parts p such that a each a path contained in some contained in the acyclic part of g and b the path p ia formed by the pj end to end in order of ing j create s new path p by the p end to end while transforming any p which is contained in the result is a path ci in to the single node ci g which must be a subsequence of l by lemma all that re ia to show that if pj is contained in c then it is a of lt this follows immediately if we show pj to be a basic path lemma let p xl xk be a basic path in flow graph g and let c be a subgraph of g formed by taking a subset of the nodes of g and all edges among those let pc xq be any portion of the path p which is contained in c then p is basic in c proof suppose not then there exists a path p from x to x in c which is contained in pc but if this is ao then by replacing po by p in the path p we can get a path p which a contradiction ia basic ia contained of the assumption in that p p m the proof of the above lemma the ment that the of length in i i ia a node listing proved for g and hence the theorem is vi short node in this section we investigate the of node for data flow analysis by examining the class of graphs for which node are short that ia bounded in length by for some fixed k our hope is to show that there exist short for many of those graphs which require amounts of computation by one of the algorithms wi the restriction we shall make is actually a bit stronger than the one described above definition a flow g ia said to be if there a complete list ing graph l for g such that xk with this definition lemma may be in slightly weaker form ss follows lemma all acyclic flow are we next turn our consideration to the class of graphs lemma if g is a control graph which contains a node x such flow that x is on every cycle in g then g is proof we construct the listing graph l by building two acyclic lo and li and taking their union let lo be the acyclic graph constructed from g by removing every edge leading out of the node x and renaming the nodes in the graph li el and yl x let li be the acyclic graph constructed from g by removing the edges leading into x and renaming nl x el and nx the union of these is acyclic e two l lo both lo and li are acyclic and there are no edges of the form define in l as follows we must show that yl y l is a complete listing graph for g let p yl yk path in g if p does not pass through x then it must be included in both lo and l suppose p contains let po be the part of p up to and in x x and pi be the part after x by lemma po and pi are both so p is reflected in while pi ia re in li the edge between x and its y in p is represented in lt by the edge included in l by construction which thus was p is reflected in l and l is a complete listing graph for g there are two representations yo and yl in l of every node in g except x which has but one therefore g is m note that we have used a subtle fact which is im in our definition of node that is the path xx if it in g is not basic this is because blocks can be completely analyzed by local methods and are therefore considered basic blocks in this sis it has been shown u that the class of graphs whose form is depicted in figure below require n bit vector steps to analyze live analysis using the interval method for figure the graph with nodes however length the node ni by for these graphs are of so the node listing approach will be clearly of i e n on this we next turn our attention to a larger of graphs which are we shall define this class by defining acceptable graph let be a control flow graph furthermore suppose there exists a function t tn which the type of a node if we that x ia otherwise x is a block by definition definition an interval transformation on gn t ia one which produces a graph nt by replacing any node x in g by a region with the following restrictions a all of x in g become predecessors of h in g h r is connected c every cycle in r contains h d the region head h ia in applying an interval transformation edges of the form y x in g are replaced by edges in g while each edge xy may be re placed by several edges xy name interval xn the arises because the regions r are acl definition an interval transformation ia to be if all the exits from the ex region the same node ie there exists a node e in r such that every edge of form xy in g is replaced by the edge g figure a interval mation the nodes are drawn as p head f exit figure a interval transformation definition an for a single entry region ia a subgraph of r which contains a every path from a node in n to an exit from nr b every basic path from a node in to a node a predecessor of h in nr and c for each properly contained single entry s every basic path from a node in n h to a node of s an in graph for r is a subgraph which contains every path from the head of r to an other node of r the following by theorem is an adaptation and unman hu of a re theorem if g is a reducible flow graph then there exists an acyclic for g which of all the forward in g proof the of a reducible flow graph is the subgraph formed by eliminating edges removed by an application from g those of t during the reduction of g and unman hu have shown that the dag of a reducible flow graph is acyclic and unique furthermore it contains every path from the header of r to a node with inr because any backward branch from a node on such a path must by theorem branch to a node which is already on the path hence the dag contains path to a node within r every basic u definition a transformation is a interval transformation such that the expanded region has an acyclic the transformation in figure above is a un acceptable while the region shown in figure can never be the target of a trans formation exit an figure region an minimal target region lemma if g is a reducible graph and g n e no is produced g by an interval then reducible flow from g is proof and unman ru shown that every interval is reducible therefore we can reduce the expanded region single node by the application of a sequence of t and t transformations the re is the original graph g which is re by another sequence of such trans if these two sequences are applied g will in the order described be reduced to s single the graph node m lemma let r be a strongly connected region with an acyclic out graph if r is formed from r by applying a mation to any node in r except h then r has an acyclic proof let be formed by inserting the for the expanding region r n e h node and replacing in place of the expanded branches into and out of the expanded node by to the header of re and from the exit of re clearly is acyclic so we need only show that it is a valid for r a let p be a basic path from a node within r to an exit if p contains no nodes of re then p must be in and therefore in assume that p does contain of re the nodes within in p re must be the single entry restriction on re that ia no path to an exit of r can through the exit node of r twice therefore we may replace the nodes of r in p by the single ex node from r the resulting path po is basic in r since not p would not be basic if it were in r and is contained in the portion of the path within r ia in re by lemma and hence is contained in therefore the whole path ia contained in out r by construction b let p be a path in a s of r from a node other than the head h to a node for s bl suppose s does not contain the ex node then p is in and therefore in b suppose s ia the expanded region r then p is in out re and hence in b suppose s contains the expanded node on any path through r to a node of s the of r must be by the same argument aa in case a above therefore the path po in which the from re are replaced by the single expanded node is in out r and hence p is in by lemma and the construction a note that case b includes the special case rs ing node for may be any r path to a theorem let g be a control flow graph formed by beginning with a single ex node and repeatedly applying un acceptable transformations to produce a se ing of graphs then g ia which ends proof let lo be the acyclic for g guaranteed by lemma in which each node y is renamed yo as in the proof of lemma since g is reducible by theorem there exists an acyclic for g as well let li be this graph with each node y renamed yl form l lo for each node in which is a node for a header lo hx of of g insert the branch graph is acyclic in n the both lo and li are acyclic and branches between them go only one way we need only that l ia a complete listing graph for g suppose p ia a path in g there are two cases to consider a path p no branch a node to region head in this p consists entirely of for branches h and must be con in li b the path p contains at least one branch from a node to its re head let be the last such branch in p and unman hu have shown that the portion po of p up to and including y must be entirely contained in the region by ho otherwise the path p would be a cycle through ho hence po is contained in the of by lemma and in the for g lemma the portion pi of p beginning with ho entirely of forward and ia therefore reflected in lt finally the edge is in l by tion so the entire path p is reflected inl but there are at most two representations of each node in g so and the theorem ia proved h consider the transformations family of of the defined by form shown in figure generating transformations figure it can be easily seen that both generating trans formation are therefore the graphs are this family ia im it has been shown that live analysis on graphs requires in bit vector when either of the standard algo is applied ke a more interesting case is presented by the of and bj figure which are often taken qed programming as standard for sequential expansion block expansion w conditional expansion ex expansion figure the transformations and of corollary any flow graph formed from a single node by repeated application of the tions of and is proof clearly transformations through are only transformation is in question it does not have a single block as head however trans formation can be eliminated if we include the four transformations shown in figure o figure eliminating transformation the result now follows theorem immediately from u although it is not our intention to investigate the graphs the following theorem should give some of the tional power obtained by allowing copies of any node theorem let g n be a control flow graph generated from a single node by repeated application of interval tions in which the of the expanded region can be made acyclic by the head of that able region once then g is proof the same construction as in the proof of theorem will work if modified so that the into the of the ex region go to both copies of the then straightforward and follows the proof of theorem the number of rep of any node is bounded by since we only make s third node copy of a non u theorem allows us to consider the loop or loop conditional figure in which a special condition inside the loop causes a branch to a piece of code for process ing before returning to the main execution stream v v r figure loop the need for such generalized loop exits in programming has been discussed in the literature it is therefore that the addition of such a control structure will not increase the complexity of data flow analysis vii summary and conclusions we have defined the concept of a node listing and examined its in the solution of global dataflow analysis problems the class of flow graphs with short is large and include most of those flow graphs which would be generated by structured programming and many flow graphs on which the standard dataflow algorithms do quite recently aho and unman au have an algorithm which given a reducible flow graph g ne will construct a node listing for g of length proportional to log ini in time proportional to ini log ini thus the previous ly open question of whether or not there exists an in i log ini algorithm for live analysis has been resolved via the node listing approach the node listing method may also have tion in another important area of computer science recently much attention been around the question what makes a program many authors have to define which control structures should be avoided if a program is to be easily read and understood by another person but no real quantitative measures have been put on this quality of under however the length of a programs node listing is in one sense a measure of to the compiler we have seen here that the compiler and the human agree that certain control structures such as those of and are simple it does not there to view the complexity of a control structure in terms of the node expansion that it may cause acknowledgements the author to thank allen john and rosen for their help and ment au au al az ac bj hu hu hu ke ki kn se references aho av and unman jd of parsing translation vol prenticehall new the theory and compiling aho av and unman jd private allen fe control notices july analysis vol no pp allen fe a method for determining program data lecture notes in computer science vol international sym on theoretical programming springerverlag berlin allen fe and j graph tic constructs for program control flow analysis ibm research report rc tj watson research center heights new york c and g turing machines and only two formation rules w no may diagram with vol oj dijkstra ew and hoare car structured programming academic press new york ms and jd analysis of a simple algorithm for global flow problems conf record of acm on principles of programming languages boston mass pp october ms and unman jd flow graph siam j computing vol no pp june ms snd unman jd of reducible flow graphs vol no pp july kennedy k of code international j computer pp dec motion math vo kennedy k a comparison of algorithms for global flow technical report dept of mathematical sciences rice univ texas february ga a unified approach to global record program optimization conf of acm sw on principles of programming languages boston pp october mass knuth de the art of computer pro gramming vol fundamental algo addisonwesley reading mass x knuth de structured programming with goto statements draft jan lg global hall m a mathematical theory of program optimization prentice nj u unman jd algorithms for the of common acts informatica vol no pp z ct a control statement for natural topdown structural proc symposium on programming 