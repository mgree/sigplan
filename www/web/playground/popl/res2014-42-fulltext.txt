game semantics for interface java s and department of computer science university of school of electronic engineering and computer science university of london abstract we consider an object calculus in which open terms interact with the environment through interfaces the calculus is intended to capture the essence of contextual interactions of java code using game semantics we provide fully abstract models for the induced notions of contextual approximation and equivalence these are the first denotational models of this kind categories and subject descriptors d formal definitions and theory semantics f semantics of programming languages denotational semantics keywords full abstraction game semantics contextual equivalence java introduction denotational semantics is with the construction of mathematical denotations that capture program behaviour it on compositional modelling with the aim of the structure of computation and reasoning about programs many developments in denotational semantics have been driven by the for full abstraction a model is fully abstract if the interpretations of two programs are the same precisely when the programs behave in the same way ie are contextually equivalent a faithful correspondence like this the path to a broad range of applications such as compiler optimisation and program transformation in which the preservation of semantics is of importance recent years have seen game semantics as a robust denotational paradigm it has been used to construct the first fully abstract models for a wide of programming languages previously out of reach of denotational semantics game semantics models computation as an exchange of moves between two players representing respectively the program and its computational environment accordingly a program is interpreted as a strategy in a game corresponding to its type intuitively the plays that game semantics generates constitute the observable patterns research supported by the engineering and physical sciences research and a of engineering research permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm that a program produces when interacting with its environment and this is what the full abstraction results game semantics is compositional the strategy corresponding to a compound program phrase is obtained by canonical combinations of those corresponding to its an important advance in game semantics was the development of nominal games which full abstraction results for languages with dynamic generative behaviours such as the calculus higherorder concurrency and ml references a feature of nominal game models is the presence of names eg memory locations references names in game moves often along with some abstraction of the store the aim of the present paper is to extend the range of the game approach towards programming languages by on objects to that end we define an imperative object calculus called interface java intended to capture contextual interactions of code written in java mj as specified by interfaces with inheritance we present both equational contextual equivalence and contextual approximation full abstraction results for the language to the best of our knowledge these are the first denotational models of this kind related work while the operational semantics of java has been extensively there have been relatively few results regarding its denotational semantics more generally most existing models of objectoriented languages such as have been based on global state and consequently could not be fully abstract on the other hand contextual equivalence in languages has been studied successfully using operational approaches such as trace semantics and bisimulation the approaches are to ours and the three papers listed also provide of contextual equivalence the main difference is that traces are derived operationally through a carefully designed labelled transition system and thus do not admit an immediate compositional description in the style of denotational semantics however between traces and plays in game semantics indicate a deeper correspondence between the two areas which also itself in other cases eg vs at the time of writing there is no general methodology for moving between the two approaches but we believe that there is scope for unifying the two fields in the not so future in comparison to other game models ours has quite lightweight structure for the most part consists of calling the methods and returning results to calls made by the in particular there are no justification pointers between moves this can be attributed to the fact that java does not feature firstclass higherorder functions and that methods in java objects cannot be updated on the other hand the absence of pointers makes definitions of simple notions such as less direct since the dependencies between moves are not given explicitly any x x a i ai skip void null i i int m int m int x m m m i m i m i ii m m int let x m in m m m int im i i i m int m m if m then m else m x i m i m i i m i m mf m void if m i i f mf m i vn i mi · · · mn i im vn i xi i mi i in m in figure typing rules for terms and implementations more and need to be inferred from plays the latter strategy composition nonstandard because it is impossible to determine statically to which a move belongs the switching conditions cf interactions become crucial for determining the strategy responsible for each move finally it is worth noting that traditional links are by definition from our setting a move for a given object cannot be by the other player as the move has a fixed polarity determined by the ownership of the object in fact identity strategies contain plays of length at most two further directions in future work we would like to look for representations of fragments of our model in order to use them as a foundation for a program verification tool for java programs our aim is to take advantage of the developments in automata theory over infinite alphabets and automata in particular to account for the nominal features of the model the language we introduce an imperative object calculus called interface java in which objects are typed using interfaces the calculus is a down version of java mj expressive enough to expose the interactions of objects with the environment definition let ints and be sets of interface field and method identifiers we range over them respectively by i f m and variants the types of are given below where stands for a sequence n of types for any n an interface definition is a finite set of typed fields and methods an interface table is a finite assignment of interface definitions to interface identifiers types void int i f m i i i we write i i for interface extension interface i extends i with fields and methods from we that the extension relation must not lead to circular dependencies moreover each identifier f m can appear at most once in each and each i can be defined at most once in ie there is at most one element of of the form i or i i thus each can be seen as a finite partial function types we write f for f and m for m similarly defines a partial function ints given by i i i i i undefined otherwise an interface table is wellformed if for all interface types i i · if i appears in i then i dom · if i i then dom we assume that interface tables are wellformed interface extensions yield a subtyping relation given a table we define by the following rules i i i i we might omit from subtyping judgements for definition let a be a infinite set of object names which we range over by a and variants terms are listed below where we let x range over a set of variables vars and i over z moreover is selected from some set of binary numeric operations m is a implementation again we that each m appear in each m at most once m x a skip null i m m let x m in m m m if m then m else m im i m mf mf m m m xm m the terms are typed in contexts an interface table and a variable context x · · · xn n a i · · · am im such that any interface in occurs in dom the typing rules are given in figure for the operational semantics we define the sets of term values heap configurations and states by states v skip i null a v f v v s a ints × × if sa i v m then we write sa i while and stand for vf and mm respectively for each f and m given an interface table such that i dom we let the default heap configuration of type i be vi f v if where skip and vi null the operational semantics of is given by means of a smallstep transition relation s i i s j if j i i s let x v in m s m vx s s null s if then m else m s m s if then m else m s m s a a s s ia s a if sa i i i s a a s if a a s af s s i m s a i vi max a s s m vx if xm s af v sa i v f v m skip if sa i v m s em s em if s m s m figure operational semantics of between presented in figure the transition relation uses evaluation contexts e that are defined as follows e let x in m m i m a if then m else m i f f m af mm · · · vi mi · · · mn given m void we write m if there exists s such that m s skip definition given mi i we shall say that m contextually approximates m if for all and all contexts c such that void if cm terms are then cm we then write m contextually equivalent written m m two m if they approximate each other for technical convenience features the let construct even though it is definable given x m and m consider new x i m xm mm where i is a fresh interface with a single method m as usual we write m m for let x m in m where x is not free in m although does not have explicit local variables they could easily be introduced by taking let x i in · · · where i has a single field of type in the same manner one can define variables and methods that are private to objects and to the environment through interfaces example let empty cell get void empty set empty void val empty vari val int and consider the terms mi cell i defined by m let v in cell m m let b vari in let v in let v in cell m with m get set y m get if then else set y y we have m m cell intuitively each of the two implementations of cell corresponds to recording a single value of type empty using set and providing access to it via get the difference lies in the way the value is stored a single private variable is used in m while two variables are used in m however in the latter case the variables always hold the same value so it does not matter which of the variables is used to return the value the game semantics of the two terms will turn out to consist of plays of the shape n g s g · · · sk gk where gi call ret call ret i i si call ret and i n cell nj empty j i intuitively the plays describe all possible interactions of a cell object the first two moves n correspond to object creation after that the gi segments represent the environment reading the current content initially having null value while the si segments correspond to updating the content with a reference name provided by the environment the stores i attached to moves consist of all names that have been introduced during the interaction so far it is worth noting that because has explicit a context can always guess the actual interface of an object and extract any information we may want to hide through example let empty point empty x int y int and consider the terms mi empty i defined by m empty m let p point in px py in our model they will be interpreted by the strategies and respectively using eg the context c point skip we can see that m m empty on the other hand theorem will imply m m empty on the whole is a compact calculus that down java to the needed for interaction accordingly we the introduction of explicit class hierarchy as it would remain to the environment and any internal computations can be represented using standard object encodings at the moment the calculus allows for single inheritance for interfaces only but extending it to multiple inheritance is not problematic the following semantic developments only rely on the assumption that must not give rise to the game model in our discussion below we assume a fixed interface table the game model will be constructed using mathematical objects moves plays strategies that feature names drawn from the set a although names various elements of our model we do not want to into the precise nature of the sets containing them hence all of our definitions preserve ie our objects are strong nominal sets note that we do not need the full power of the theory but mainly the basic notion of for an element x belonging to a nominal set x we write x for its which is the set of names occurring in x moreover for any x y x we write x y if there is a permutation such that x · y we proceed to define a category of games the objects of our category will be which are nominal sets carrying specific type information definition an is a pair a ma a where definition a legal sequence in ab is a sequence of moves from that to the following grammar where ma and mb range over ma and mb respectively lab max may x y y call x y y y call y ret we write lab for the set of legal sequences in ab in the last clause above we say that call ret · ma is a nominal set of moves · a ma a ints is a nominal typing function such that for all m ma m we start by defining the following basic z z i i a a a i to each s lab we assign a polarity function p from move occurrences in s to the set o p represent the two players in our game reading of programs o is the and p is the in the game the latter corresponds to the modelled program while the former models the possible computational environments surrounding the program are via o p and p o in addition the polarity function must satisfy the condition for all interfaces i given a and b we can form the a × b by · for all mx mx x a b occurring in s we have o and p m n ma × mb a m n am a bn a bn a am a n a am a if a n am a bn a bn a otherwise another important is i · · · in with mi a · · · an n a distinct ia · · · an ai ii · if mn are consecutive moves in s then pn pm alternation it follows that there is a unique p for each legal sequence s namely the one which assigns o precisely to those moves appearing in odd positions in s a in ab is a pair m with sto and m for each sequence s of we define the set of available names of s by av m for all n n in particular a for each type we set val to be the set of semantic values of type given by where for each x a we let x s i i x with x x ix ix val void m val int mz val i mi for each type sequence · · · n we set val val × · · · × val n we let a store be a typepreserving finite partial function from names to object types and field assignments that is a ints × val such that is finite and a i if af v v that is a name is available in s just if it appears inside a move in s or it can be reached from an available name through some store in s we write s for the underlying sequence of moves of s ie s and let denote the prefix relation between sequences if s m s and a m s then we say a is introduced by m in s in such a case we define the owner of the name a in s written oa to be pm where p is the polarity associated with s for each polarity x o p we let where the new notation is explained below first assuming a i the judgement a i holds iff i i and af stands for f next we define typing rules for values in store contexts v val void v val int v i v v void v int vi and write v for v v i i we let sto be the set of all stores we write for the set of all f such that af is defined we let sto contain all stores such that a dom f af and we call such a a default store given a and b plays in ab will consist of sequences of moves with store which will be either moves from ma mb or moves representing method calls and returns formally we define ma mb calls where we set calls call a a v val and ret a a v val xs a s oa x be the set of names in s owned by x definition a play in ab is a sequence of s such that s is a legal sequence and moreover for all s m s · it holds that dom m · if a dom with a i then if m mx for x a b then i x m a for all nt in s if a then t a i if im then if m call then v for some if m ret then v for some · if m call then oa pm we write for the set of plays in ab by of notation we frequently write instead a is introduced by m in s recall also that s collects all names appearing in s in particular m · · · mi i m · · · mi i note above that because of and alternation if m ret then implies oa pm thus the condition that names cannot appear in a play in unreachable parts of a store cf moreover ensures that the typing information in stores is consistent and to the constraints imposed by and the underlying finally implements the specification that each player need only call the other players methods this is because calls to each players own methods cannot in general be observed and so should not be for in plays given a b c next we define interaction sequences which show how plays from ab and bc can interact to produce a play in ac the sequences will rely on moves with stores where the moves come from the set ma mb mc calls the moves will be assigned from the set ol pl or pr the index l stands for left while r means right the indices indicate which part of the interaction a b or c a move comes from and what polarity it has we also consider an auxiliary notion of oo ol or p o pl op pr each polarity has an opposite determined by ol p o or op pl pr oo finally each x ab bc ac has a designated set of given by ol pl or pr ol pl or pr note the slight of notation with p as it is also used for move suppose x ab bc ac consider a sequence s of from abc ie a sequence with elements m with m along with an assignment p of from to moves of s let s x be the subsequence of s containing those m of s for which pm px additionally we define s x to be s x where the function acts on by restricting the domains of stores to available names sm s m definition an interaction sequence in abc is a sequence s of in abc satisfying the following conditions · for each s m s dom m · if s m s and a dom with a i then if m mx for x a b c then i x m a for all nt in s if a then t a i if im then if m call then v for some if m ret then v for some · there is a polarity function p from move occurrences in s to such that for all mx mx x a b c occurring in s we have ol and pr if mn are consecutive moves in s then pn pm alternation ol Ø po l or o pl pr pl or ol pr or d op figure interaction diagram for the diagram specifies the alternation of in interaction sequences transitions are labelled by move while oo is the initial state · if s m s then m call implies oa pm · for each x ab bc ac s x lx · if s m s and m ret then there is a move nt in s such that for all x such that pm px n is the of m in s x · conditions p s ab p s bc p s ab p s bc os ac for each s s ending in and each a if pm p o and a s ab or pm op and a s bc or pm oo and a s ac then a t a we write for the set of interaction sequences in abc note that by and each return move in s has a unique next we show that the of moves inside an interaction sequence are uniquely determined by the interaction diagram of figure the diagram can be seen as an automaton accepting s for each s the edges represent moves by their while the labels of vertices specify the polarity of the next outgoing move for example from oo we can only have a move m with pm ol or for any p lemma each s has a unique polarity function p proof suppose s we claim that the alternation and conditions uniquely specify p consider the interaction diagram of figure which we read as an automaton accepting s call it a the edges represent moves by their while the labels of vertices specify the polarity of the next outgoing move by we obtain that the first element of s is some ma and by alternation its polarity is ol thus oo is the initial state we now use induction on s to show that a has a unique run on s the base case is trivial so suppose s s m by induction hypothesis a has a unique run on s which reaches some state x we do a case analysis on m if m ma mb mc then there is a unique edge accepting m and by alternation this edge must from x if on the other hand m call then the fact that oa pm gives two possible edges for accepting m but observe that no combination of such edges can from x finally let m ret be justified by some n in s then by n is the of m in all projections and hence the edge accepting m must be the opposite of the one accepting n eg if m is accepted by ol then n is accepted by pl next we show that interaction sequences project to plays the projection of interaction sequences in abc on ab bc and ac leads to the following definition of projections of x bc xl undef ac xl x x bc y ac undef undef bc y ac y where x y o p we can now show the following lemma let s then for each x ab bc ac and each m in s if pm px then x pm px m where px is the polarity function of s x proof we show this for x ab the other cases are proven similarly by induction on s the base case is trivial for the inductive case if m is the first move in s with polarity in then by m ma and therefore pm ol and o as required otherwise let n be the last move in s with polarity in before m by ih now by and observe that for all x pn so in particular the following lemma a on names appearing in interaction sequences lemma let s then s os ac p s ab p s bc if s tm and · pm oo and s ac t m · or pm p o and s ab t m · or pm op and s bc t m then t m t and in particular if m introduces name a in t m then m introduces a in s proof for by definition of interactions we have that these sets are disjoint it therefore suffices to show the lefttoright inclusion suppose that a s is introduced in some m in s with pm p o and let s ab · · · m · · · if a m then a p s ab as required otherwise by last set of conditions a is copied from the store of the move preceding m in s a contradiction to its being introduced at m similarly if pm op finally if pm oo then we work similarly considering os ac for we show the first case and the other cases are similar it suffices to show that m t t so suppose a m t therefore a os ac but then we cannot have a t as the latter by item would imply a p s ab p s bc proposition for all s the projections s ab s bc and s ac are plays in ab bc and ac respectively proof by of s and application of all projections satisfy moreover is preserved by projections for let m call be a move in s and let nt be the move introducing a in s suppose pm and let us assume o we need to show that p by o we obtain that pm ol and by of s we have that oa p o thus pn p o and by lemma n introduces a in s ab and therefore p as required if on the other hand p then we obtain pn oo op and therefore by lemma a p s bc os ac thus by the same lemma a p s ab and hence o the cases for the other projections are shown similarly in our setting programs will be represented by strategies between we shall introduce them next after a few auxiliary definitions intuitively strategies capture the observable computational patterns produced by a program let us define the following notion of subtyping between stores for sto holds if for all names a a i a i f dom af in particular if a is in the domain of may contain more information about a because of assigning to a a larger interface accordingly for plays s s we say that s is an of s if s and s agree on their underlying sequences while their stores may differ due to subtyping related to where such subtyping leads to s having stores with more fields than those in s p is assumed to copy the values of those fields formally s o s is defined by the rules s o s p sm o sm o s m o s extends by t m o s m where extends by t if · for all a dom dom a t a · for all a and f dom a af t af the utility of is to express semantically the fact that the environment of a program may use to in its objects additional fields and methods not accessible to the program definition a strategy in ab is a nonempty set of plays from satisfying the conditions · if then s closure · if sm then sm · if s and s t then t · if s and t o s then t we write a b when is a strategy in ab if a b and b c we define their composition by s ac s where s s ab s bc in definitions of strategies we may often leave the presence of the empty sequence implicit as the latter is a member of every strategy for example for each a we define the strategy a a ma ma the next series of allow us to show that strategy composition is well defined lemma if sm with pm oo then sm hence if sm with pm oo and s s then sm proof for the latter part if s · s then since · by former part of the claim we have sm · so sm now for the former part suppose that pm p o then by the interaction diagram we also have pn p o as sm ab by of we get s m s nt recall that for any nominal set x and x y x we write x y just if there is a permutation such that x · y with s m sm ab and s nt ab we therefore have s m s nt and trivially s s s s moreover by lemma m s s and nt s s hence by strong support lemma sm by last set of conditions the remaining values of t are determined by the last store in s hence sm lemma if s s end in moves with in and s ac s ac then s s proof by induction on s ac the base case is in si with pm oo i where note that by ih m will have the same polarity in s s then by ih we get s · s for some let si m si ac for i so in particular s · s and therefore s s s s moreover by hypothesis we trivially have m s m s and hence by lemma and strong support lemma we obtain sm sm which implies s s by conditions suppose now si mi i with pm p ac oo and the last move in si being the last move in having polarity in by ih s s then by consecutive applications of lemma we obtain s s proposition if a b and b c then a c proof we show that is a strategy closure and are clear moreover since each s has projections in ab and bc we can show that its projection in ac is too for if s and t o s with s u ac and u we can construct v such that t v ac and v o u where o is defined for interaction sequences in an analogous way as for plays with condition pm o replaced by pm oo and pm p by pm p o op moreover v ab o u ab and v bc o u bc so t finally for let sm be due to respectively where s s both end in the last move of s by lemma we have s s and thus by consecutive applications of lemma we get so sm the above result shows that strategies are closed under composition we can prove that composition is associative and consequently obtain a category of games proposition for all a b b c and c d definition given a class table we define the category g having as objects and strategies as morphisms identity morphisms are given by for each a note that of identity strategies easily follows from the definitions and hence g is well defined in the sequel when can be inferred from the context we shall write g simply as g as a final note for class tables we can define a functor g g which acts as the identity map on and sends each a b of g to s t s o t where refers to plays in g in the other direction we can define a strategy transformation which satisfies soundness here we introduce constructions that will allow us to build a model of we begin by defining a special class of strategies a strategy a b is called evaluated if there is a function f ma mb such that ma mb mb note that of implies that for all ma ma and permutations it holds that · f · ma thus in particular ma recall that for a and b we can construct a product a × b we can also define projection strategies a × b a ma mb ma and analogously a × b b note that the projections are evaluated moreover for each object a a ma ma pa is the unique evaluated strategy of type a given strategies a b and a c with evaluated we define a b ma f ma s where we write sm mb for the sequence obtained from s by replacing any occurrences of mb in it by m note that there can be at most one occurrence of mb in s the above structure yields products for evaluated strategies lemma evaluated strategies form a wide of g which has finite products given by the above constructions moreover for all a b and a c with evaluated and using the above result we can extend to general a b and a c by a b × a c × b b × c where is the isomorphism the above represents a notion of of and where the effects of those of we can also define a between strategies × a × b a × b a × b for any a a and b b lemma let a a a b a b b × b c and b c with and evaluated then proof the result follows from the simpler statements id id id id for all appropriately typed with evaluated and lemma an immediate consequence of the above is a b × b × c × c a c × c more generally lemma provides us with conditions similar to those present in freyd categories or equivalently categories with monadic products we also introduce the following weak notion of given strategies a b we define z × a b ma s setting i z i for each i z we can show the following lemma for all strategies a a and a b · id and id · if is evaluated then × method definitions in induce a form of vn i xi i mi i m in in the modelling of which requires some extra semantic machinery traditionally in callbyvalue game models leads to strategies corresponding to higherorder value terms in our case higherorder values are methods themselves via the objects they may hence necessarily passes through generation of fresh object names containing these values these considerations give rise to two classes of strategies introduced below we say that an play s is total if it is either empty or s t s and · t sto and mb ma · if s s m nt and a dom ma mb ts for sto such that ma mb ts then a n and t a a we write pat b for the set of total plays in ab thus in total plays the initial move ma is immediately followed by a move mb and the initial store is to p in the sense that p cannot use its names nor their values a strategy a b is called singlethreaded if it consists of total plays and satisfies the conditions · for all ma there is ma · if ma mb t s then ma mb ts for sto · if ma mb t s call and a t then s thus singlethreaded strategies reply to every initial move ma with a move which depends only on ma ie p does not read before moreover does not change the values of p does not write and may introduce some fresh objects with default values finally plays of singlethreaded strategies consist of just one thread where a thread is a total play in which there can be at most one call to names introduced by its second move conversely given a total play starting with t we can extract its threads by tracing back for each move in s the method call of the object a t it is related to formally for each total play s t s with s the move of s written is given by induction · m if pm p · call call if a t · nt s call nt if a p s t and n introduces a · m nt if pm o and n m if s s nt s with s we set nt then the current thread of s is the subsequence of s containing only moves with the same move as s that is if m and s ma mb t s then s ma mb t s m note that the use of the term thread here is internal to game semantics and in particular should not be with java threads where the restriction only those moves nt of s such that m we extend this to the case of s by setting s s finally we call a total play s if for all s m even s with s · if s m s m then s s · if s ends in some nt and a dom s m then a t a we write for the set of plays in ab we can now define strategies which occur as interleavings of singlethreaded ones let a b be a singlethreaded strategy we define s s s lemma is a strategy for each singlethreaded proof closure and follow from the corresponding conditions on for if sm with s then using of and the fact that do not change the current thread nor do they modify or use names from other threads we can show that sm we say that a strategy is if for some singlethreaded strategy thus strategies do not depend on initial stores and behave in each of their threads in an independent manner note in particular that evaluated strategies are and singlethreaded lemma let a b and a c be strategies with then and a c × b b × c proof the former claim is straightforward for the latter we ob serve that the initial effects of and commute on initial move ma does not read the store updates that includes in its response mb while cannot access the names created by in its second move mc t it is worth noting that the above lemma does not suffice for obtaining categorical products allowing strategies to create fresh names in their second move breaks of considering for example the strategy i × i a a sto we can see that as the contains plays of the form a bt with a b we can now define an appropriate notion of exponential for our games let us assume a translation assigning an to each type sequence moreover let i be an interface such that i m · · · mn n n where i i · · · for each i for any a given singlethreaded strategies · · · n a i such that for each i if ma a t s i then a t a i call s m mi we can group them into one singlethreaded strategy n n a i i i note that the a above is fresh for each ma ie a ma let now · · · n be strategies with i a × i i for each i we define the singlethreaded strategy i a i i ma a s pat i ma v s i ma a t call s ret s pat i ma v s vt s i ma a t pat i where a v v s s t and t a i by definition i is singlethreaded therefore setting n n a i we obtain a strategy implementing a simultaneous of · · · n in particular given translations mi for each method in a implementation m we can construct m i m · · · mn finally we define evaluation strategies i × i i by taking prefixes of a a i for each field f thus object creation involves creating a pair of names a a with a i and a i where a is the name of the object we want to return the name a serves as a store where the handle of the method implementations that is the name created by the second move of m will be passed the strategy i upon receiving a request call simply it to the respective method of a f and once it receives a return value copies it back let i of call distinct for sequence of interfaces i the latter has a right inverse i each r i i with the same plays we can now define the semantic translation of terms definition the semantic translation is given as follows · contexts x · · · xn na · · am im are translated into by × · · · × n × i · · · im where void int z and i i · terms are translated as in figure top part where ai i i we can now show the following natural mapping from groups of strategies in a × i i to ones in a i lemma let · · · n be as above and let a a be evaluated then in order to prove that the semantics is sound we will also need to interpret terms inside state contexts let m with where contains only variables and dom doms a s m is translated into the strategy · n × id i · n × id × id n s m s × i m the semantic translation of states figure lower part apart from dealing with in order to complete our translation we need also to address the of x i in the rule x i m i m i i recall that m i two stages s s × i s × i the first stage s creates the objects in doms and implements their methods the second stage of the translation s the fields of the newly created objects in the rest of this section we show soundness of the semantics let us call new and re is obtained using thus the second move of m will appear in the i above and will be a fresh name b which will serve as a handle to the methods of m in order to the transition rules in figure which involve state given a rule r we write s m r s m if the transition s m s m involves applying r and context rules invoke m xm on input v the would have to call the remaining challenge is to merge the two occurrences of i in we achieve this as follows let us assume a wellformed extension of proposition correctness let s m be a and suppose s m r s m i f i that is i contains a single field f of type i we next define the strategy i i × i of g if the transition r is not stateful then m m if r is one of or then s m s id × i m if r is one of or new then s m s m i a a call ret thus in every case s m s m where m b a f and sto is such that a i and a i we let i m be the strategy i × i i proof claim is proved by using the results of this section for the let construct we show by induction on m that m vx id v m for we use the following properties of field assignment and access and is the assignment strategy i × a v note that x may appear free in m it stands for the keyword this of java here we omit m inside as well as the whole i m in for i × × id id × i × × which are easily the former one states that assigning a field value and accessing it returns the same value the latter that two assignments in a row have the same effect as just the last one the final claim follows by showing that the diagrams below · · xi i i i skip void · · ai ii n i ir i i ii null i i where i · i int i z · let x m in m × m · im i m i i where i i i aa pi i a i · m m int mm z × z z where z × z z i j i j · m m int mm i × i eq z where eq a a a b a b · if m then m else m mid z × m m · i m i i × × i i × i × i × i i where m × i m mn i if m m xm · · · mn · mf m void mm i × · · mf m i where i av pi af v m m i × where m m m · · · mn · s × i i × × i mid i × i × × i id × i × i × × i × i × × i where doms a · · · an i i · · · in ii i i × · · · i i × · · · × in m m · · · mn mi m m · · · mn v · · · vn vi fi vi · · · vi vi ··· · × fn v v · · · vn vi × · · · × v × · · · × figure the semantic translation of commute we write a for × i i m g i i m mi i × i g i g i i g i m i × i i m i i i g where a a combination of values and assignments and × i × i i × a × a with id id the former diagram says that assigning method implementations m to object stores a and calling mi on some method m is the same as assigning m to a and evaluating instead a new copy of mi on m the reason the diagram is that the copy of mi differs from the original just in the handle name the one returned in the codomain of mi but the latter is hidden via composition with the latter diagram that if we create a with methods m then calling ai on m is the same as calling mi on m the latter holds because of the way that ii calls inside the interaction by calls to methods of ai to mi proposition computational soundness for all m void if m then m ie m skip proof this directly follows from correctness proposition computational adequacy for all m void if m then m proof suppose for the sake of contradiction that m and m we notice that by definition of the translation for blocking constructs and conditionals may block and due to correctness if m were due to some reduction step being blocked then the semantics would also block thus m must be due to divergence now the reduction relation restricted to all rules but is strongly as each transition decreases the size of the term hence if m diverges then it must involve infinitely many reductions and our argument below shows that the latter would imply m for any term n and a a dom construct a na where a a vari by recursively replacing each subterm of n of the shape n mn with af af n mn vari is an interface with a field f int observe that each s n induces some s a na such that a appears in s only in stores and in a single place in the initial move and o never changes the value of af while p never decreases the value of af we write a na a for the subset of a na containing precisely these plays then take m to be the term let x vari in xf where x a fresh variable because m we get j m for some j z consider now the infinite reduction sequence of m it must have infinitely many steps so suppose m s m contains j such steps then we obtain m sa m a af with j by correctness we have that j sa m a af sa m a af a since in m a a the value of a cannot decrease and its initial value is j as by sa we reach a contradiction full abstraction recall that given plays s s we call s an of s written s o s if s s are identical except the type information regarding present in stores the types of in s may be subtypes of those in s we shall write s p s for the dual notion involving ie s p s if s s are the same but the types of in s may be subtypes of those in s then given x o p and fixed a b let us define s s s x s and s s s we write p for p a play will be called complete if it is of the form may next we establish a result stating that any complete play together with other plays implied by from a term lemma let s p be a complete play there exists and m such that m proof the argument proceeds by induction on s for s any divergent term suffices for example one can take div m void void and any term of type with div m m m suppose s then the second move can be a question or an answer we first show how to reduce the former case to the latter so that only the latter needs to be directly suppose s qq call s ret s w s where o i m il ir consider i f il m ir and the following play from p i s qq p s call pm v s ret pm v s where p s i i p i f u and sj is the same as sj except that each store is extended by if m i satisfies for s then for s one can take let xp m where y refers to o ie y is of the shape x f where x dom and f is a sequence of fields that points at o in q thanks to the reduction given above we can now assume that s p is nonempty and s qq m m · · · where m is an answer we are going to s in two ways so that it is easier to decompose ultimately the decomposition of s will be based on the observation that the m · · · segment can be viewed as an interleaving of threads each of which is started by a move of the form call p for some p a thread consists of the starting move and is generated according to the following two rules mi belongs to the thread of mi and every belongs to the same thread as the corresponding · the first transformation of s forward the point of creation to the second move in this way threads will never create objects and consequently it will be possible to compose q ip q n pi pi ip null and i i n null undefined pi p s let xn ip observe that s p · the second transformation consists in storing the unfolding play in a global variable it should be clear that the recursive structure of types along with the ability to store names is to store plays in objects let be a signature that makes this possible this will be used to enforce the intended interleaving of threads after their composition in the style of let history play and history consider s h n qq m m · · · with q q h history play null i i h history play i i h history play observe that s p now we shall decompose m · · · into threads recall that each of them is a subsequence of s of the form call c t ret where the segment t contains moves of the form call o or ret o for some o os we would now like to invoke the ih for each thread but since a thread is not a play we do so for the closely related play h n q u c t vr let us call the term c next we combine terms related to the same p ip into an object definition by mp ip m u c the if s in using and c that nested really occur in threads related to p in such cases the corresponding term c will be run otherwise the statement leads to divergence the term m for s can now be obtained by taking let xn ip in let history in let in make where represents a series of bindings one for each pi p s n qq is a conditional that if and only if the initial values of free identifiers as well as values accessible through them are consistent with q and q respectively make is a sequence of assignments that set values to those specified in need to be performed to ensure typability and is skip i null or if m is a name it is a term of the form yf where y is xn or x ix such that yf gives an access path to m in we conclude with full abstraction results both in and equational forms for technical convenience we shall use a modified but equivalent definition of contextual approximation lemma let x i · · · xk ik mi i and f i · · · ik then m m if and only if for all and z where test let z void if f m in test proof the lemma holds because on the one hand it relies on contexts of a specific shape and on the other hand any closing context c for mi can be presented in the above form with test x · · · xk given a term m let us write m comp for the set of complete plays from m in what follows we shall often omit for brevity theorem full abstraction given mi i we have m m if and only if clp m comp clp m comp proof the proof uses the following play transformation given t qq s p we define t p void as nn call nf sn ret nf sn n where are the same as in the above lemma n n sn stands for s in which each store was augmented by n and is the store of the last move in t intuitively t is the play that needs to provide for a terminating interaction with t let s clp m comp then there exists s m comp with s clp s apply to s to obtain z test void such that test because s m comp and adequacy holds we must have from m m we obtain hence because of soundness there exists s m comp such that s test since test it follows that s and consequently s clp s thus s clp s and s clp s hence s clp s and because s m comp we can conclude s clp m comp let be such that by soundness there exists s m comp such that s test because m comp clp m comp and clp m comp clp m comp we also have s clp m comp thus there exists s m comp such that s clp s consequently s since s test we also have s test because s m comp and s test by adequacy we can conclude that example let us example we have clp and clp ie clp clp thus it follows from theorem that m m m m and theorem equational full abstraction given mi i m m if and only if m comp m comp proof the preceding result implies that m m if and only if clp m comp clp m comp we show that this implies m comp m comp let s m comp by clp m comp clp m comp it must be the case that s clp m comp ie there exists s m comp such that s clp s again by clp m comp clp m comp it follows that s clp m comp ie there exists s m comp such that s clp s so we have s clp s and s clp s which implies s clp s however s s m comp so s clp s entails s s hence s clp s and s clp s and s s follows because s m comp we showed s m comp the other inclusion is derived analogously references m abadi and l cardelli a theory of objects springer verlag e m m f s de a and m and in a sequential calculus of classes in proceedings of s abramsky d r a s ch l and i d b nominal games and full abstraction for the in proceedings of lics s abramsky r and p full abstraction for pcf information and computation ­ s abramsky and g linearity sharing and state a fully abstract game semantics for algol with active expressions in algollike languages pages ­ s abramsky and g game semantics in logic and computation proceedings springerverlag j editor formal syntax and semantics of java volume of lecture notes in computer science springer j and f s lam dynamic denotational semantics of java in formal syntax and semantics of java pages ­ gm mj parkinson and am pitts mj an imperative core calculus for java and java with effects technical report computer laboratory university of cambridge h and t on notions of for data languages theor comput sci ­ m j and a m pitts a new approach to abstract syntax with variable binding formal aspects of computing ­ j m e and ch l on full abstraction for pcf information and computation ­ a jeffrey and j java jr fully abstract trace semantics for a core java language in proceedings of esop a jeffrey and j a fully abstract may testing semantics for concurrent objects theor comput sci ­ s n and u s two semantic models of objectoriented languages in theoretical aspects of object oriented programming pages ­ mit press v and m wand reasoning about class behavior in proceedings of j a game semantics of local names and good variables in proceedings of j game semantics for higherorder concurrency in proceedings of j game semantics for callbyvalue polymorphism in proceedings of icalp s b and p b typed normal form bisimulation for parametric polymorphism in proceedings of lics r milner fully abstract models of typed theoretical computer science ­ e moggi computational lambdacalculus and monads in proceedings of lics a s and n algorithmic nominal game semantics in proceedings of esop a s and n game semantics for good general references in proceedings of lics j power and e premonoidal categories and notions of computation math struct in comput sci ­ n full abstraction for nominal general references logical methods in computer science n automata in proc of popl 