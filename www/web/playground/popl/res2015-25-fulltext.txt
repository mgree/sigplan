abstract symbolic automata mixed similarity analysis of university of university of abstract we introduce a model for mixed approximation of programs based on symbolic finite automata sfa the edges of sfa are labeled by predicates whose semantics specifies the denotations that are allowed by the edge we introduce the notion of abstract symbolic finite automaton where approximation is made by abstract interpretation of symbolic finite automata both at syntactic predicate and semantic denotation level we investigate in the details how the syntactic and semantic abstractions of sfa relate to each other and contribute to the determination of the recognized language then we introduce a family of transformations for simplifying we apply this model to prove properties of commonly used tools for similarity analysis of binary following the structure of their control flow graphs binary are represented as concrete sfa where states are program points and predicates represent the possibly infinite io semantics of each basic block in a constraint form known tools for binary code analysis are viewed as specific choices of symbolic and semantic abstractions in our framework making symbolic finite automata and their abstract interpretations a unifying model for comparing and reasoning about soundness and completeness of analyses of lowlevel code categories and subject descriptors d programming languages formal definitions and theory f logics and meanings of programs semantics of programming analysis general terms languages keywords symbolic automata abstract interpretation introduction the problem similarity analysis is a key component in and understanding software including code eg coming from specifications analyses and other heterogeneous metadata this is particularly relevant when dealing with binary which besides representing a large portion of existing also represent a highly often hard to analyze carrier this is due to its nature permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm allowing overlapping instructions and untyped computations where data and code without any static boundary in order to both semantic meanings and syntactic patterns from programs existing tools for similarity analysis of binary always employ mixed and semantic representations of programs at syntactic level properties concerning the control flow graph such as in and or feature vectors concerning sequences of instructions are used together with sequence comparison algorithms and hash functions for extracting structural in code at semantic level more advanced semantic properties such as those extracted from symbolic executions dynamic analysis and such as those used in and are employed for semantic preserving code transformations for code eg for similarity analysis in detection the use of mixed representation of code in similarity analysis is a good practice because pure semantic similarity is too complex and often undecidable while pure syntactic is too and to false due to code techniques this is precisely what happens in most known tools and methods for and comparing programs in order to extract semantic from syntactically different code however none of these tools have a formal semantic model in which relative precision and soundness can be formally proved this paper is intended to fill this gap our contribution we attack this problem by observing that most known methods employed in similarity analysis of can be seen as abstract interpretations of symbolic finite state automata sfa symbolic finite automata introduced in and further developed in provide the ideal formal setting in order to treat within the same model the abstraction of both the syntactic structure of programs and their intended semantics sfa have been introduced as an extension of traditional finite state automata for modeling languages with a potential infinite alphabet transitions in sfa are therefore modeled as constraints interpreted in a given boolean algebra providing the semantic interpretation of constraints and therefore the potentially infinite structural components of the language recognized see our main contribution is the introduction of the notion of abstract symbolic finite automaton where approximation is made by abstract interpretation of standard sfa abstract interpretation here acts both at syntactic predicate topological graph and semantic denotation level we investigate in details how the syntactic topological and semantic abstractions of sfa relate to each other and interfere when automata at different levels of abstractions are compared with respect to their recognized language the abstraction respectively on syntactic predicates and semantic structures corresponds precisely to the abstract interpretation of the underlying boolean algebra of a concrete sfa m resulting in a different sfa a whose language recognized is an over approximation of the language of m the key aspect here is to maintain a relative compatibility between syntactic abstractions on predicates and constraint formulae and the abstractions of their semantics this intuitively means that the approximate predicates and their interpretation provide one over the others coherent partitions of objects respectively interpretations and predicates topological abstraction means instead changing the graph structure of sfa yet keeping correctness namely providing an over approximation of the recognized language of m this is achieved by generalizing a minimization algorithm proposed in with respect to a family of equivalence relations on sfa states the result is a simplification of m which is still correct in the sense of abstract interpretation with respect to m abstract sfa provide a general enough model for representing syntactic and semantic properties of arbitrary programming languages we apply our model in the attempt to formalize and prove properties of two commonly used tools for similarity analysis of binary notably and following the structure of their control flow graphs binary are represented as concrete sfa where states are program points between basic blocks and predicates represent the possibly infinite io semantics of each basic block in a constraint form tools for similarity analysis are then formalized as abstract interpretations of these concrete sfa by studying the properties of the corresponding abstractions we can provide a first unifying model for formally proving properties for these tools moreover our model suggests potential refinements of similarity analyses for such as the possibility of extracting minimal sfa from as canonical signatures for code fragments mathematical notation given two sets s and t we denote with s the powerset of s res the set of recursive enumerable re subsets of s with s t the between s and t with s t strict inclusion and with s t inclusion s denotes the set of all finite sequences of elements in s a set l with ordering relation is a poset and it is denoted as l a poset l is a lattice if xy l we have that x y and x y belong to l a lattice l is complete when for every x l we have that x x l as usual a complete lattice l with ordering least upper bound lub greatest lower bound greatest element top and least element bottom is denoted by l given f s t and g t q we denote with g f s q their composition ie g f x f l d on complete lattices is additive if for any y l f ly df y f ly df y continuity holds when f preserves of chains is defined for a continuous function f x x f x nn f n where f and f n f f n abstract interpretation abstract domains can be equivalently formalized either as galois connections or closure operators on a given concrete domain which is a complete lattice c cf let c and a be complete lattices a pair of monotone functions c a and a c forms a galois connection gc between c and a if for every x c and y a we have x a y x c y resp is the resp to resp and it is additive resp if is a gc between c and a then if then id is a cg between c and c given an additive resp function resp we have a gc resp by considering its right resp left adjoint x y y x resp x y x y an upper closure operator or simply a closure on a poset l is an operator l l which is monotone idempotent and extensive ie x x we denote with the set of all closure operators on the poset l if c is a complete lattice then x c id forms a complete lattice which is the set of all possible abstractions of c where the bottom is id xx and for every is more concrete than iff iff y c y y iff c c ii ix ii ix ii ix x iff i i ix x is disjunctive when c is a of c which holds iff is additive cf is partitioning or induces a partition if it is additive and is a partition of c if then the most abstract partitioning closure containing def is partitioning the key aspect of partitioning closures is that they preserve the structure of boolean algebras if f c c is a continuous function and is an abstraction then f always has a best correct approximation in c which is f def f any approximation f c c of f in c is sound if f f in this case we have the fixpoint soundness cf f is complete when f f which holds iff f f cf therefore the possibility of defining a complete approximation f of f on some abstract domain only depends on f and in this case we have in the following for any semantics · s d mapping syntactic objects in s into denotations in d such that · is an element in the set of fixpoint semantics s s d inductively defined as follows s f s d s s and if we denote by · s s d the corresponding best correct approximation which is defined inductively on the structure of s as follows s f s s it is known that · is sound and whenever is complete for the basic semantic operators f defining · s then · is complete ie for any s s s s cf symbolic finite automata symbolic automata and finite state transducers have been introduced to deal with specifications in a potentially infinite alphabet of symbols we follow in specifying symbolic automata in terms of ef boolean algebra consider an effective boolean algebra a da a · ¬ with domain elements in a re set da a re set of predicates a closed under boolean and ¬ the semantic function · a da is a partial recursive function such that da and a we have that and ¬ da in the following we notation by denoting with · also its additive lift to a ie for any a for a we write when and say that is satisfiable a is able if is decidable definition a symbolic automaton sfa is a q q f where a is an effective boolean algebra q is a finite set of states q q is the initial state f q is the set of final states and q × a × q is a finite set of transitions a transition in m a q q f labeled from state p to state q p q is often denoted p q is called the guard of the transition an of a sfa m is a transition p q such that a also denoted p a q the language recognized by a state q q in m is defined as a an da i n pi ai pi p q pn f in this namely case l m where all states m we outgoing assume complete sfa for any ter a d this can be simply achieved by adding a q q such that q q and for all states q lack ing an outgoing for a q p p q d then q ¬ q with the following terminology holds for sfa m is deterministic whenever p q p q if then q q m is clean if for all p q p is reachable from q and m is normalized if for all p q q there is at most one move from p to q m is minimal if m is deterministic clean normalized and for all p q q p q given a sfa m define the sfa f a q and q f q × q we as follows q q q q q × a × q is such that q q p q p q q q and f q q f abstracting symbolic automata symbolic automata means building different automata an upper approximation of the original recognized language this can be achieved by abstract interpretation of the underlying effective boolean algebra a and by the structure when on the boolean algebra we may either approximate the domain of denotations da where formulae and predicates are interpreted or approximate the predicates in a where formulae are built in both cases we need to obtain as result an abstract effective boolean algebra abstract effective boolean algebras the duality of syntax and semantics is encoded in sfa by the underlying algebraic structure of effective boolean algebras they represent the universe of predicates and formulae later called syntax as well as the domain for their interpretation and semantics providing the structure for expressing the language recognized by the given sfa the abstraction of syntactic and semantic structures applies on sets of predicates and semantic structures representing as usual in abstract interpretation properties respectively of predicates and semantics in the following a da a · ¬ is an effective boolean algebra definition semantic abstraction let a be an effective boolean algebra and be a partitioning abstraction of its domain of denotations the semantic abstraction of a wrt denoted abstraction is the effective boolean algebra a da a · ¬ where da d d da · a da such that d d a a ¬ da before abstracting predicates ie syntax we have to guarantee the effectiveness of symbolic computation in the sfa next lemma proves that if s is a set whenever is additive maps any re subset x of s into a re abstract subset x of s lemma if x s is re and is additive then x is re namely by lemma because is a recursive function and by characterization of recursive enumerable sets the range of over re sets is itself re see theorem if s is a set and is additive then x x s x is re is re definition syntactic abstraction let a be an effective boolean algebra and let be an additive abstraction of predicates the syntactic abstraction of a wrt de noted abstraction is the effective boolean algebra a da · ¬ where · da is defined as in sfa if we have both a abstraction and a abstraction of an effective boolean algebra a then we define the combined abstraction abstraction of a by combining them as follows let and the abstraction of a wrt and is the effective boolean algebra a da · ¬ it is clear the paper that a we assume aid that and a and hypothesis in definition and respectively theorem if a is decidable then for any and a is decidable note that in the definition of symbolic automata there is a strong relation in the underlying effective boolean algebra a between the domain of denotations da and the set of predicates a used to symbolically represent them this means that if we abstract the domain of denotations by considering leaving unchanged a we are implicitly changing the interpretation of predicates in da on the other hand if we abstract the predicates by considering we explicitly describe how symbols are abstracted and the semantics is simply the collection of all the semantics denoting the same abstracted predicate this leads to the following notion of compatible abstractions compatible syntactic and semantic abstractions let us consider a abstraction of a we aim at characterizing the syntactic abstractions that produce abstract predicates which may have semantics compatibility of the notion of semantic abstraction naturally induces a corresponding syntactic abstraction with defined as follows def analogously any syntactic abstraction naturally induces a cor in order to semantic characterize abstraction with when and how a syntactic ain a semantic abstraction we need to characterize the syntactic abstraction that precisely corresponds to the semantics · namely the abstraction collecting all the predicates having the same se · this is precisely id which can be rewritten as here · is the adjoint semantic function defined as follows · def x da x then we can define the induced abstraction def x y y x observe that when · a da is namely when there exists at least one predicate for each possible semantics in da we have that id id indeed id considers every single predicate and we have a predicate for each semantic object so in this case we have no effects on the semantics and id return precisely the identity on the semantics compatibility of a abstraction wrt abstraction can therefore be defined in terms of relative abstraction of and or analogously in terms of relative abstraction of and definition semantic compatibility given a abstracted effective boolean algebra a and a syntactic abstraction is compatible if intuitively we have semantic compatibility when the syntactic abstraction is more concrete than the semantic abstraction when they are compared on the domain of abstractions of predicates indeed semantic compatibility means that the way a syntactic abstraction partitions the set of predicates of a is a refinement of the partition induced by the syntactic abstraction that corresponds to the semantic abstraction we can say that when we have semantic compatibility the abstraction of the syntax distinguishes programs with the same abstract semantics namely the abstract program provides an underapproximation of the abstract program behavior theorem let then is the most abstract syntactic abstraction compatible note that a may not be an effective boolean algebra because may not be a re set example consider the domains depicted in fig the missing point labels are the set union of smaller elements the first three domains on the left represent possible syntactic abstractions of a where a def x y x y x y x y the last domain on the right represents possible semantic abstractions of da where da def x y x y consider for instance the semantic abstraction of da depicted with on the last domain on the right the corresponding syntactic abstraction is depicted on the three syntactic domain on the left considering the closures depicted on the first domain on the left we observe that the closure a is compatible being more concrete that this means that the syn tactic abstraction can distinguish predicates with the same abstract semantics in particular while x y x we have that x y x y x while x x now consider a compatible abstraction of a we introduce the notion of compatibility of a semantic abstraction definition syntactic compatibility a semantic abstraction is compatible for a syntactic abstraction a if intuitively we have syntactic compatibility when the syntactic abstraction is more abstract than the semantic abstraction when they are compared on the domain of abstractions of predicates figure relation between indeed syntactic compatibility means that the semantic abstraction corresponds to a syntactic abstraction and that the partition on the set of predicates of a induced by is a refinement of the partition induced by in other words when we have syntactic compatibility the abstraction of the syntax programs with different abstract semantics hence capturing behaviors that according to are not related with the program to analyze yet providing an overapproximation of the abstract program behavior theorem let then is the most concrete semantic abstraction compatible example consider again the example in fig introduced in example consider in this case the syntactic abstraction depicted on the third domain we observe that is compatible since is more abstract than this means that induces a further semantic abstraction elements with different abstract semantics in particular x y x x x while x y x y x in this example we can also observe a syntactic abstraction depicted on the second domain which fails both the since it not comparable with finally we show when a syntactic abstraction does induce an abstraction of the semantic denotations and vice versa lemma let id iff id iff theorem let then id id this result tells us that when we have a syntactic abstraction distinguishing predicates with the same semantics then we cannot abstract the semantics we prove that we can characterize both in the domain of semantic abstractions and in the domain of syntactic abstractions theorem let be such that id and iff in fig we can see the relation between the two in particular we observe that the two transformers form syntax to semantics and show a relation similar to an as observed in the following result proposition let and the following conditions holds figure compatible abstractions example consider again the example in fig for which satisfies the hypotheses of th we have a corresponding semantic abstraction depicted on the right which is indeed more abstract than as a corollary of the previous results we show when a abstraction of a satisfies both the the computational cost of making analyses compatible is still to be explored proposition let and such that the following facts are equivalent is compatible and is compatible abstracting symbolic automata consider a sfa m a q q f and the abstraction of the effective boolean algebra a denoted as a we define the symbolic finite automaton corresponding to m on the abstract effective boolean algebra a as m def a q q f where def q q q q note that m mid that when abstracting and the following we prove boolean algebra of an sfa we the recognized language providing a sound approximation in the sense of abstract interpretation theorem given a sfa m a q q f two closures and the abstract effective boolean algebra a and the corresponding sfa m a q q f then l m l m for this reason is the following we terminology and refer to the sfa whose underlying boolean algebra is an abstraction of a boolean algebra a as an abstract sfa moreover we can observe that given two abstract boolean of the semantics · with respect to the pair of abstractions and this is formally stated in the following proposition proposition consider a sfa m a q q f the closures and then l m l m · · minterms a notion which plays a central role in our transformations of sfa is the notion of this notion has been introduced in for def tree new tree a null null foreach in return the minterms are the leaf predicates class tree predicate tree left tree right refine def if and ¬ if left null if the tree is a leaf then split left new tree null null right new tree ¬ null null else figure generation algorithm providing a minimal and representation of the predicates in a given set of predicates eg the guards of a given program in this context we observe some properties of minterms which make them powerful tools for reasoning on semantics in a syntactic way a is a minimal satisfiable boolean combination of all predicates occurring in a given sfa minterms can be generated from a set of predicates by the algorithm proposed in and reported in fig as observed in the set of minterms of an sfa may be expensive to compute indeed in the worst case the complexity of the algorithm that computes the minterms is exponential in the number of guards of the sfa basic properties of minterms the generation for a formula produces a tree t that satisfies the following basic properties proposition let tree be the tree built during the generation starting from a set of predicates given a let us denote by t the subtree of tree having as root then the following properties hold let k then ik i any minterms satisfiable implies that for all minterms is not satisfiable for all we have that is satisfiable iff for any we have that is satisfiable with satisfiable iff sat the following proposition shows that the semantics of minterms is a partition of the domain da of denotations where sat def is satisfiable proposition let a da a · ¬ be an effective boolean algebra then is a partition of da approximated minterms minterms change their structure when the underlying boolean algebra is approximated by abstract interpretation we consider an effective boolean algebra a da a · ¬ where the semantic function · a da is consider a subset a of such predicates for example the set of predicates that label a given sfa we define the syntactic abstraction as that abstraction of predicates that precisely only the predicates in and abstract in any other predicate let a then is formally defined as additive lift of def if otherwise note that the fixpoints of is of course corresponds to an abstraction on the semantics that precisely only the semantics of the predicates in as stated by the following result lemma let a da a · ¬ be an effective boolean algebra and consider which is id compatible then da observe that is id compatible if whenever there is a predicate in then contains also all the predicates with the same semantics the closure may not be partitioning in general so we consider and we observe that the equivalence classes of the partition induced by on da are precisely the semantics of the minterms of proposition let a da a · ¬ be an effective boolean algebra and consider a such that the abstraction is id compatible then minterms d d da it is now interesting to observe what happens when we consider a generic syntactic abstraction such that namely that further abstracts the set of predicates that we are considering in this case the semantics of the minterms of the approximated predicates are precisely given by the abstraction of the semantics of the minterms of theorem let a da a · ¬ be an effective boolean algebra and consider a such that the abstraction is id compatible and an abstraction such that then minterms minterms this means that the semantics of the minterms of a set of abstract predicates is precisely the abstraction of the semantics of the original predicates example let a da a · ¬ be an effective boolean algebra where a x n n z and the semantic function · a z is naturally defined as x n n let us consider the following subset of a x x x x the corresponding set of minterms is minterms x x x ¬x ¬x x ¬x ¬x x ¬x ¬x ¬x x ¬x ¬x ¬x ¬x observe that minterms z the closure is defined as the additive lift of x n def x n if x n otherwise and as states in proposition we have that d d z z let z def v v and z def v v and let the closure sign defined as the additive lift of sign x n def x z x z if n z if n z otherwise observe that the is the set x z x z and the semantics of the minterms of sign is z z moreover as shown in theorem sign minterms z z topological sfa abstraction in section we have seen how an sfa can be abstracted by abstracting its underlying boolean algebra this abstraction does not influence directly the topological structure of sfa when dealing with automata the natural way of about automata simplification or abstraction is the merge of states in general we can define a simplification operation on automata that states wrt a given equivalence relation over states namely the equivalence relation establish the criteria that the simplification uses for merging states definition consider a sfa m a q q f and an equivalence relation r q × q over its states we denote with the sfa obtained by simplifying m wrt r namely the sfa computed as the of m wrt r ie mr thus sfa simplification is the operation of made parametric on the equivalence relation used to merge states it is easy to observe that for every equivalence relation r the sfa resulting from sfa simplification at least the language recognized by m indeed when we merge states we keep all the transitions of the original sfa and we may add some new spurious ones proposition consider a sfa m a q q f for any equivalence relation r q × q we have that l m l given two equivalence relations r and r we write r r when r is a refinement of r of course the is the equivalence relation the is the language recognized by the corresponding simplified sfa proposition consider a sfa m a q q f and two equivalence relations r r q × q such that r r then l l m another important property of topological abstractions is that they do not change the set of minterms since they do not change the predicates in the following we report a simplification algorithm where the predicates of the sfa to simplify are first rewritten as disjunction of minterms line thus whenever the equivalence relation r deals with properties of the languages of strings that reaches or starts from a state it may be easier to check these properties on minterms instead of checking them on the language of denotations examples will be provided in the following r input m a q q f r q × q a da a · ¬ def minterms p q q p q m a a def q q f da · ¬ µ def def q p q output m mr examples of sfa simplifications minimization and in have extended the standard algorithm of hopcroft for finite state automata minimization to sfa this operation is based on the idea of refining an initial partition by checking all the possible moves depending on the considered alphabet symbol in this is feasible because they have a finite alphabet in sfa the alphabet is re hence in general infinite for this reason the algorithm proposed iterates this check on in a way that makes the number of possible iteration finite instead of checking transitions for each alphabet symbol the check is made for each see for details observe that this sfa minimization algorithm can be seen as a simplification wrt the equivalence relation that relates all and only the states that are reached exactly by the same language of minterms consider a sfa m a q q f and for every q p let µ be the predicate written as a disjunction of minterms namely as the disjunction of the leaves of the subtree t with root of the tree generated during the construction of the minterms of the considered sfa we define the language of strings of minterms that reaches a state q as l q def µ n n i n q qn q let q × q be such that q p iff lq lp observe that for the properties of minterms proved in the previous section we have that checking the language of minterms or checking the language of denotations is equivalent since minterms provide a minimal and representation of predicates let denote the minimization of m proposition sim m according to the above formalization of sfa minimization we can weaken minimization by defining a relation over states that the language of of minterms of a fixed length k that reaches a given state to this end given an sfa m a q q f and for every q p let µ be the predicate written as a of minterms we define the language which is the language of strings of length k that can reach the state q lk q def µ q qk q i qk q let k q × q be such that q k p iff let denote the simplification of m wrt k the following examples illustrate the difference between minimization and example consider the sfa m in fig on the left it is clear that the predicates x odd and x even are equivalent as well as predicates y even and y odd this is captured by the minimization algorithm of and that correctly state q with q and q with q the algorithm is shown in fig at the top on the right observe that the edge between q and q q as well as the edge between q q and q is labeled by one of the two equivalent predicates of course the sfa m and recognize the same language in order to the difference between minimization and at the bottom right of fig we report the result obtained by applying the simplification algorithm wrt k where k at the sfa m observe that the simplification algorithm with k merges the state q with the states q and q as shown in the resulting sfa indeed the states q q and q are reached by the same language of strings of length in this simple case all the denotations with y positive the edge between q q q and q is labeled by true since it corresponds to y odd y even we can observe that the language recognized by is greater than the one recognized by m let us consider the pairs n n with n n z where the first number denotes the values of x and the second the values of y for example we have that the string of pairs l while it does not belong to l m l of course when the value of k increases it increases also the precision of the simplification wrt k by states that are equivalent namely at the limit with k increasing the becomes minimization theorem given two states p and q we have that p q iff k n p example observe that if we compute the simplification of the sfa m in the example in fig wrt k and k we obtain the sfa namely indeed if we consider the language of words of length that reach a given state we can no longer merge q with q and q minterms provide a systematic simplification of sfa based on the extraction of invariant properties that hold for the language of strings that reach or start from a given state consider an sfa m a q q f and for every q p let µ be the predicate written as a disjunction of minterms consider a state q q for every string µ of length k that reaches the state q we have that ik is true iff all the of minterms share at least one this because thanks to the properties of minterms only figure minimization and one at the time can be true let inv def minterms i k it is the set of all the minterms shared by all the which provides the invariant property of the corresponding string indeed thanks to minterms this satisfiability can be checked syntactically we can therefore define the following equivalence relation q × q such that q inv k p iff kp where inv k inv µ thus inv k states reached by paths that have the same k invariant property we can observe that if two states share the same then they share the same while the opposite may not be true since the language an order in the constraints that the commutativity of the conjunction theorem given two states p and q and k n we have that p implies k k p inv k q example consider again the automaton m in fig the minterms generated by its predicates are given in the table in fig each i denotes the mi obtained as the conjunction between the constraint on x and on y for instance for the m x even x y even y in fig we rewrite m where on each edge the predicates are denoted as the set of the minterms specifying it for instance x i mi note that on this automaton the generates the same transformation as the as showed in fig consider instead the automaton m on the right in this case the languages recognized by q and q are different for instance the trace lq is not in lq since does not satisfy the predicate between q and q in m ie y if we consider invariant then we observe that the invariant on the path is m m and the same is for the path hence we can the states q and q topological abstraction of abstract sfa it is worth noting that abstraction in sfa may influence the automata simplification in this section we prove that the of simplification and in particular of minimization and in sfa is strictly related with the degree of abstraction of their semantics or syntax example consider the sfa m in fig and assume that we want to abstract from the parity of y hence we define abstraction on the predicates of m as y odd y even y odd true and as the identity on the other predicates in this example we do not abstract the semantics and we consider id let m be the sfa wrt the considered abstraction where the predicates of m are substituted with their abstraction according to by applying minimization to this sfa we obtain the sfa depicted at the top left of fig we can observe that due to the predicate abstraction the minimization of m more states than the minimization of m and therefore l l for example the string of pairs l while it does not belong to l we have an analogous situation in the case of consider the predicate abstraction such that x odd x even x even true and as the identity on the other predicates and let id by applying the simplification algorithm wrt k with k to the sfa m we obtain the sfa at the top right of fig also in this case due to the abstraction the simplification algorithm more states and therefore l l for example the string of pairs l while it does not belong to l let s denote the set of sfa and let us define the following ordering relation on s modeling precisely the relative precision of sfa with respect to language containment and size of the automaton where given m a q q f and m a q q f s we have that m m l m l m l m l m q q it is immediate to observe that s is a possibly lattice given the sfa simplification s s a sfa m a q q f and a abstraction of the effective boolean algebra a we when the diagram in fig in general we have that when we simplify the sfa after the abstraction of the underlying algebra we obtain an sfa that is more abstract than the one obtained by applying simplification before the abstraction the intuition beyond this is that the abstraction of the underlying boolean algebra could make equivalent edges of the original sfa that are not equivalent and this may cause the merge of states that would not be merged when simplifying original sfa proposition given m a q q f s the closures and and a relation r we have that example at the bottom left of fig we show the result of abstracting the boolean algebra after the sfa minimization we observe that even if and recognize the same language the automata obtained by after the abstraction of the underlying boolean algebra has less states than the one computed by abstracting the boolean algebra after the minimization we have a similar result for as we x even odd even y even odd even odd odd x y x y x y x y x y x y x y x y x y x y x y x y x y x y x y x y x y kx y k y k y k k y y k k y st x y m q st s st st ii odd i io dd q q i i even q q i i even i i odd i i odd figure transformation figure minimization and in presence of abstraction figure completeness of sfa simplification can see by comparing the sfa at the bottom right and top right of fig programs as sfa in this section we specify the approximate semantics of a program as the language recognized by a sfa we consider programs in imperative computational model and assume to have access their correct control flow graph cfg the cfg of a program is a graph where nodes are given by sequences of non branching instructions more formally let i be the instruction set containing both branching and instructions we denote with i i the set of instructions and with c the set of boolean expressions over program states that are guards of the branching instructions let c range over c and b range over i the cfg of a program p i is a graph gp np ep where the set np i of nodes specifies the basic blocks of p namely the maximal sequences of sequential instructions of p while the set of edges ep np denotes the guarded transitions of p in particular a labeled edge b c b ep means that the execution of p flows from b to b when the execution of b leads to a program state that satisfies condition c when a basic block b has no ing edges in ep we say that it is final denoted b final gp we denote with and respectively the entry and exit point of the basic block b and with the block of gp namely the set of all the entry and exit points of the basic blocks of gp namely def b np out b b np let ranged over by s be the set of possible program states let exec i be the function that defines the semantics of basic blocks namely the pairs of inputoutput states that model the execution of sequences of instructions when s s it means that the execution of the sequence of instructions b transforms state s into state s let us denote with s c the fact that the boolean condition c is satisfied by state s we define the set of executions of the cfg of a program p the sequences of basic blocks and guards that can be encountered along a path of gp np ep formally def i k bi ci bi ep we consider a safety semantics namely the semantics of all prefixes of execution traces of a given program p the execution trace semantics of a program p denoted p is therefore the set of all finite executions starting from the entry point of the starting basic block b in the cfg gp of p let be the set of possible initial states of program p formally for each s p s def s ss ss s sk sk i k si ci si si p def p s s init p in order to define the sfa that corresponds to the cfg semantics of a given program we need to define an effective boolean algebra that it is suitable for the representation of program execution for this reason we define the following effective boolean algebra where predicates are either basic blocks of instructions or guards of branching instructions representing the syntactic structure of the program and the denotations are pairs of inputoutput states p def × i c · ¬ where the semantic function · ic is defined as follows for i c def s s s s s s s c if b i if c c we denote with · also its pointwise extension to c definition let p be a program with cfg gp the sfa associated with p is m p def p out b b final gp p where b is the starting basic block of gp and p is defined as p def b out b b np c b c b ep proposition if p is a program then m p is a deterministic sfa m p is clean if no is included in gp the language l m p re × recognized by the sfa m p approximates the concrete program semantics p in a language of sequences of infinitely many possible inputoutput relations associated with each basic block this is formally stated by the following theorem theorem if p is a program then for any s p s l m p given the sfa m p that represents the cfg of a program p then it is possible to approximate the semantics of p by abstracting either the predicates namely the syntax or the semantics of the effective boolean algebra underlying m p let us consider the minimization simplifications given compatible abstractions × and c and k n we have that m p this provides a reduction of the original sfa and therefore cfg providing at the same time a unique approximate representation of the abstract semantics of p this is possible thanks to the combined syntactic and semantic approximation both on the code and on its interpretation two programs p and q can then be considered similar if they have the same reduced abstract sfa up to k n p k q iff k max n this weaker notion of similarity can be improved by considering minimal sfa as canonical representation of the approximate syntax and semantics of programs p q iff the following theorem is therefore immediate by construction theorem let p and q be programs then p k n p k q q iff it is clear that for decidable abstractions there exists k n such that p k q p q formal similarity analysis of the idea of is that the of a binary forms a template that is expected to be identical regardless of code variations due to register renaming memory address allocation and constant replacement similar ideas have been employed in where are treated as graphs of graphs a control flow graph where each block is itself represented as a graph which is the sequence of its instructions while the subset of considered here is sound and semantic compatible it is computationally expensive for large size this problem has been in which adds a further level of abstraction to make the resulting abstract sfa more compact in contrast to other similar tools for similarity analysis such as and all designed to find differences in variants of the same program for the purpose of creating and are motivated by a different problem find similar code in that are not known to be related this more advanced abstractions on both code and semantics therefore better showing the potential of abstract sfa performs symbolic transformations on the source binary in order to transform each basic block of assembly code into a corresponding symbolic representation the idea of symbolic execution is that the operations encoded by the assembly instructions are immediately performed when the arguments are integers in a sort of partial evaluation local to each basic block otherwise the same operation keeps its symbolic structure consider for example the following fragment of binary code and the result of its binary b c b b c assembly mov add performs algebraic manipulation of instructions in order to reach a canonical form thus the result of symbolic execution with algebraic simplification of the previous example is normalized state updates constraints eax × where denotes the value of before the execution of the basic block namely at the entry of the basic block the syntactic information lost during symbolic execution is actually added back by the constraints on numerical values in other words the symbolic execution of basic blocks augmented with numerical constraints is actually an isomorphism the key abstraction in is generalization whose idea is to use typed logical variables in order to be independent from register names the generalization is performed by consistently replacing register names with logical variables the replacement is consistent in that two occurrences of the same register name are always replaced by the same variable observe that this replacement is a purely syntactic operation in addition to abstracting the registers used also constants are abstracted associates a type with each logical variable to keep track of type of the original register in the example considered before the generalization phase of produces the following a v b × n n constraints n n × n types reg let us consider the function g that generalizes a single basic block g i × rec × ret where is the domain of normalized symbolic updates while rec is the set of constraints where register names and numerical values have been replaces by symbolic variables and ret denotes the domain of type declarations we say that gb is the of the basic block b observe that g acts as an abstraction since there may be more than one basic block sharing the same in particular g can be associated with an upper closure g as follows g b def b b b gb gb in one single symbolic representation all basic blocks that have the same we can therefore model the generalization process that operates on the cfg of the as an g abstraction of the predicates of the effective boolean algebra p introduced in section for representing the cfg of programs as sfa here we consider the extension of g to branching conditions on which it behaves like identity g c the resulting symbolic automaton on the boolean algebra pg associated with a program p is p pg b final gp g where pg × g c · ¬ g g b b p c c p and the semantic function · is the same as defined in section but now with a reduced abstracted domain · g c re × we observe that g is neither syntactic nor semantic compatible def def since it simplified updates with different semantics by ab values and variables for example g eax g eax x n it still distinguishes between different simplified updates sharing the same semantics as for example g eax g eax but also g eax constraint x n y n constraint n n n and g eax constraint x n y n constraint n n n indeed g is not comparable with id proposition g is is neither syntactic nor semantic compatible this observation is also related to the of in detecting similar basic blocks indeed can lead to both false positives blocks as equivalent and false blocks that are classified as different as observed before there are two causes of semantic merging updates with different semantics and distinguishing updates with the same semantics we are interested in id namely obtaining a closure such that id therefore avoiding yet keeping a possible way for making g semantic compatible is to erase from the domain c all the elements that have the same generalized symbolic updates but different constraints namely by all syntactic constraints in the example above it means for instance to restrict to the blocks that have generalized update x n y n while abstracting from the constraints on n it is possible to prove that is semantic compatible when considering this restricted domain of blocks this the fact that is sensible to the structure of the constraints indeed the constraints keep track of how the numerical values present in the update have been computed and is therefore tight to the particular way in which the basic block has computed them this means that can be by an attacker that changes the structure of the constraints define × rec × ret as the projection on the first element of the tuple of the based on this given b i we define the predicate abstraction u b that keeps only the blocks that have the same generalized update of b and abstract in every other block b if g b g b otherwise as expected for every basic block b we have that the predicate abstraction g ub that extracts the of blocks that have the same generalized updates of b is such that ub is syntactic g ub compatible as stated by the following result theorem b i we have that u b g u b this result is a direct consequence of the definitions of ub and of g and by prop once again this formally proves that the set of blocks with the same semantics when we restrict to blocks that have the same symbolic update we consider a subset of instruction permutation and same string reference ie instructions and nodes can be matched by common string references eg indicating functions that all contain code referring to the same string all these equivalences correspond straightforwardly to abstractions of the sfa at syntactic and topological level consider the sfa m p and the following abstractions permutation let i t be a function associating the in t at each instruction in i consider the lift of to multisets define an equivalence relation on basic blocks viz predicates in m p such that for any b b i c b b if b b this clearly induces a partition which is a partitioning closure operator denoted on predicates in i c in other words the order and the arguments of instructions it is therefore clear that b b b b namely may blocks with different semantics meaning that it is not semantic compatible ie id on the other hand since precisely the multiset of instructions we could have blocks with the same semantics but written with different sets of instructions ie b b b b meaning that fails also the syntactic compatibility same reference let n be a set of strings and i n the function associating with each basic block b the set of strings of n appearing in b this is clearly the of a gc therefore a closure on predicates which is also a partition this abstraction any instruction considering only a set of string manipulated in the block again it is quite straightforward to observe that this abstraction can both blocks with different semantics and distinguish blocks with the same semantics for instance a string may be computed without writing it explicitly hence also fails both the in order to make permutations syntactic compatible we can indeed restrict the domain of the permutation abstraction similarly to what we have done on and forcing syntactic compatibility let def b b b b b and b if otherwise as expected for every basic block b we have that the predicate abstraction sb that collects blocks that have the same set of instructions of b is such that sb is syntactic sb compatible as stated by the following result which is a consequence of the definitions of sb and of and by prop theorem b i we have that sb sb related works to the best of our knowledge this is the first application of abstract interpretation to symbolic finite automata and of abstract symbolic automata to similarity analysis of binary the most related work is where the authors introduced the notion of lattice automata lattice automata like sfa allow languages over an infinite alphabet in contrast to abstract sfa lattice automata do not distinguish between abstractions and semantic ones indeed transitions in lattice automata are constrained by elements in an atomic lattice l which provide precisely the allowed along that transition sfa are in this context strictly more general as they separate the symbolic constraints and their semantics allowing in principle separate approximations for them the idea of the programs data in a so called predicate abstraction is common practice in static program analysis the roots of this idea are in automatic software verification see observe that given a program p predicate abstraction abstracts the semantics states of p into a set of predicates e and then it derives an abstract program p bool that models how the execution of p affects e thus predicate abstraction corresponds to a semantic abstraction that groups states wrt to e and p bool is a possible way of representing the syntactic compatible abstraction of p as observed in predicate abstraction considers only finite abstractions while the semantic abstraction of denotations in abstract sfa can be an infinite domain moreover predicate abstraction does not allow to change the cfg of the program the relation between the approximation of structures and their semantics is well known in the literature see and for a recent account in particular in the authors study this relation for the systematic synthesis of optimal symbolic predicate transformers as introduced in none of these consider the case of abstract interpretation of sfa in the authors model as finite state automata a widening of is introduced for extracting syntactic code invariants in programs this construction lacks of abstractions concerning the semantics of sequences of instructions conclusion we have studied how to weaken symbolic finite automata by abstract interpretation the results is a general theory of approximated sfa which is parametric on the chosen abstraction the purpose is to provide a compact and effective representation of code approximations both at syntactic and semantic level interestingly for a turing complete programming language there is no syntactic abstraction which induces a compatible semantic abstraction this follows from a simple argument and it is indeed a common underlying problem in most known methods for program similarity analysis such as and observe that the existing tools either abstract the syntax independently from the semantics like in or represent into the syntax the abstraction of the semantics like in predicate abstraction in the first case we to fall far away form the meaning of the program to analyze in the second case the analysis may be too much bound to the semantics without having the possibility of exploiting better syntax properties necessary in similarity analysis eg in and compatibility these two aspects by semantic compatibility the abstraction of the syntax distinguishes programs with the same abstract semantics namely the abstract program provides an underapproximation of the program behavior by syntactic compatibility the abstraction of the syntax programs with different semantics hence capturing behaviors that are not related with the program to analyze therefore providing an overapproximation of the program behavior interestingly in our model we can restrict the form of predicates in order to have compatibility this is what we proved in and thus showing the limits of existing tools for code similarity and the possibility of systematically deriving conditions for making them syntactic compatible another direction of future research is in the use of topological abstractions of sfa for extracting signatures of code as recently studied in this requires the extension of widening operations such as those introduced in to abstract sfa in this case approximate sfa provide advanced signatures in analysis both properties of way code changes during program execution the invariant of the engine and additional semantic information such as the values passed in this may reduce the false positives occurring in in detection of acknowledgments this work has been when and were at the university of at usa they thank the center for advanced computer studies for the kind this work is supported by the force research laboratory and project and by the project face formal for references t ball r majumdar t d and s k rajamani automatic predicate abstraction of c programs in m and m l editors pldi pages ­ acm isbn p cousot verification by abstract interpretation in verification theory and practice to manna on the of his th volume pages ­ springer p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in conference record of the th acm symposium on principles of programming languages popl pages ­ acm press p cousot and r cousot systematic design of program analysis frameworks in conference record of the th acm symposium on principles of programming languages popl pages ­ acm press p cousot and r cousot formal language grammar and program analysis by abstract interpretation in proceedings of the acm conference on functional programming languages and computer architecture pages ­ acm press new york ny ­ june p cousot r cousot and l theories solvers and static analysis by abstract interpretation j acm m r s k k and g m modelling by abstract interpretation in proc of the th int static analysis symp sas volume of lecture notes in computer science pages ­ springerverlag berlin l and m equivalence of extended symbolic finite transducers in n and h editors cav volume of lecture notes in computer science pages ­ springer isbn l and m minimization of symbolic automata in s and p sewell editors popl pages ­ acm isbn v widening for automata thesis v l and d abstract satisfaction in s and p sewell editors popl pages ­ acm isbn h structural comparison of executable objects in u and m editors volume of pages ­ gi isbn x c flanagan and s qadeer predicate abstraction for software verification in proc of conf record of the th acm symp on principles of programming languages popl pages ­ acm press t l and b lattice automata a representation for languages on infinite alphabets and some applications to verification in h r nielson and g editors sas volume of lecture notes in computer science pages ­ springer isbn d m and d automatically finding semantic differences in binary programs in proceedings of the th international conference on information and communications security pages ­ springerverlag r f and f making abstract interpretation complete journal of the acm ­ march s and i the per model of abstract noninterference in c and i editors proc of the th static analysis symp sas volume of lecture notes in computer science pages ­ springerverlag a m and r fast location of similar code fragments using semantic in nd workshop on program protection and reverse engineering acm i and r an abstract model for safety semantics int j comput math ­ t w reps s sagiv and g symbolic implementation of the best transformer in b and g editors volume of lecture notes in computer science pages ­ springer isbn h theory of recursive functions and effective the mit press a v m and t w reps algorithms for symbolic abstraction in a and d editors sas volume of lecture notes in computer science pages ­ springer isbn m p b d and n symbolic finite state transducers algorithms and applications in j field and m editors popl pages ­ acm isbn m the closure operators of a lattice of mathematics ­ url 