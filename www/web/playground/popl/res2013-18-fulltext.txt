a theorem prover for boolean bi park park department of computer science and engineering university of science and technology of abstract while separation logic is as an enabling technology for program verification most of the existing verification tools use only a fragment of separation logic that separating implication as the first step towards a verification tool using full separation logic we develop a nested sequent calculus for boolean bi implications the underlying theory of separation logic as well as a theorem prover based on it a feature of our nested sequent calculus is that its sequent may have not only smaller child sequents but also multiple parent sequents thus producing a graph structure of sequents instead of a tree structure our theorem prover is based on backward search in a refinement of the nested sequent calculus in which weakening and contraction are built into all the inference rules we explain the details of designing our theorem prover and provide empirical evidence of its categories and subject descriptors f mathematical logic mechanical theorem proving proof theory general terms verification keywords separation logic boolean bi theorem prover nested sequent calculus introduction separation logic separation logic is an extension of hoare logic which reasoning about programs using mutable data structures as it is as an enabling technology for program verification researchers have developed automated verification tools that use separation logic as their foundational theory examples of such tools include space and the active development of such tools to the importance of local reasoning in program verification which is precisely the key feature that separation logic to support all the tools however use not full separation logic but only a decidable fragment by berdine et al or its extension specifically separation logic features two new logical connectives separating conjunction and separating implication permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm but this decidable fragment includes only separating conjunction lack of separating implication implies that for any program performing heap mutation or allocation there is no support for backward reasoning by weakest precondition generation an essential requirement for any complete program verification system see and ohearn thus while very effective in their respective application domains these tools allow only forward reasoning based on symbolic execution as in and fail to demonstrate the full potential of separation logic in program verification separating implication is not a decision rather it is an decision due to the availability of no theorem prover for full separation logic berdine et al suggest that such a theorem prover is highly desirable and can into a complete program verification system based on separation logic this incompleteness could be dealt with if we instead used the weakest preconditions of separation logic unfortunately there is no existing automatic theorem prover which can deal with the form of these assertions which use quantification and the separating implication if there were such a prover we would be eager of it still however there is no practical theorem prover for full separation logic our goal is to develop a theorem prover for full separation logic and incorporate it into a program verification system supporting backward reasoning the first step is then to study boolean bi the underlying theory of separation logic boolean bi boolean bi is a logic which belongs to the family of the logic of bi implications of ohearn and it inherits additive connectives from classical propositional logic thus the convenience of classical reasoning it is also particularly suitable for reasoning about local resources because of multiplicative connectives inherited from intuitionistic linear logic like other members in the family boolean bi allows us to consider free combinations of these additive connectives and multiplicative connectives giving rise to an form of contexts called trees whose internal nodes specify whether subtrees are combined or we obtain separation logic as a model for boolean bi based on a monoid of heaps while theoretical work on boolean bi is with recent of its undecidability there is still no practical theorem prover for boolean bi the display calculus for boolean bi by which on the framework of display logic by has the cut elimination property and thus can be easily turned into a theorem prover but developing a practical proof search strategy on top of it does not seem to be easy because of the complexity due to its display rules in order to develop a practical theorem prover for boolean bi and hence also for full separation logic we choose to develop another proof theory that directly reflects the characteristics of boolean bi and itself well to proof search this paper presents such a proof theory for boolean bi as well as a theorem prover based on it contribution we present a nested sequent calculus sbbi for boolean bi unlike in typical nested sequent calculi ­ its sequent may have not only smaller child sequents but also multiple parent sequents thus producing a graph structure of sequents instead of a tree structure the use of nested sequents is necessary because of the presence of intuitionistic multiplicative conjunction in a classical setting the use of a graph structure of sequents is necessary because of the interaction between multiplicative implication and classical negation as in typical sequent calculi for classical logic we use multisets of formulas not only for but also for of a sequent thus sequents in sbbi do not use which are by new structural connectives specifying a graph structure of sequents sbbi has the cut elimination property and is sound and complete with respect to the kripke semantics for boolean bi our theorem prover for boolean bi is based on backward proof search in another nested sequent calculus which is obtained from sbbi by building weakening and contraction into all the inference rules in conjunction with a graph structure of sequents the structural rules in make it particularly challenging to a practical proof search strategy even if it is based on backward proof search we deal with an explosion in the search space due to the structural rules which can be applied and exponentially increase the search space by their applications we find that our theorem prover is reasonably fast in proving typical formulas of boolean bi to the best of our knowledge our theorem prover is the first theorem prover for boolean bi organization of the paper section gives on boolean bi section presents the nested sequent calculus sbbi and the satisfaction relation for its sequents section proves the cut elimination property of sbbi and section proves the soundness and completeness of sbbi with respect to the satisfaction relation as well as the kripke semantics for boolean bi section the display calculus for boolean bi by and shows that sbbi is an optimization of the display calculus section presents the nested sequent calculus section describes the backward search strategy in our theorem prover and presents experimental results section discusses related work and section concludes our theorem prover with an online and technical report are available at on boolean bi formulas in boolean bi extend classical propositional logic with multiplicative connectives from linear logic formula a p ¬a a a i a a a a p denotes an atomic formula drawn from a set v i is the multiplicative unit a b is a multiplicative conjunction and a b is a multiplicative implication we define as ¬ a b as ¬b and a b as ¬a b we use conventional precedence rules for logical connectives ¬ the kripke semantics of boolean bi uses a nondeterministic commutative monoid on a set u assume a binary operator w p iff w p w iff never w ¬a iff w a w a b iff w a or w b w i iff w e w a b iff w w u such that w w w and w a and w b w a b iff w u w a implies w w w w b figure satisfaction relation w a for formulas axiom axiom axiom axiom ai a i aa a bb a a b c a b c a a b b a b a b h a b c a b c h a b c a b c h figure axioms and inference rules for multiplicative connectives in the system for boolean bi u × u pu and a unit element e u where pu denotes the power set of u we extend to a binary operator on pu such that u u w w w u w u a nondeterministic commutative monoid is a triple u e which satisfies the following conditions commutativity associativity w u w e w w w u w w w w w w w u w w w w w w given a nondeterministic commutative monoid u e and a valuation v pu of atomic formulas we obtain the kripke semantics of boolean bi from the satisfaction relation w a for formulas given in figure the satisfaction relation w a is defined inductively on the structure of formula a a formula a is valid written a if w a holds for any element w and valuation the system for boolean bi uses a judgment a and is obtained by extending classical propositional logic with axioms and inference rules for multiplicative connectives given in figure an induction on the structure of the proof of a proves the soundness of the system with respect to the kripke semantics of boolean bi and prove that the system is also complete with respect to the kripke semantics of boolean bi theorem a if and only if a nested sequent calculus sbbi for boolean bi this section presents the nested sequent calculus sbbi for boolean bi we first explain the definition of sequents in sbbi then we present the satisfaction relation for sequents and the inference rules of sbbi nested sequents a sequent in sbbi represents a graph structure whose nodes store sequents in classical logic a node can have multiple parent nodes wp p p ws ws c c wc wc wc figure an example of a graph structure of nodes in sbbi p for parent c for child s for sibling as well as multiple child nodes but the following two relations should always hold a node can have multiple parent nodes but each parent node determines a unique sibling node hence no node can have two parent nodes with the same sibling node a node can have multiple child nodes but each child node determines another unique child node hence we can divide all child nodes into groups of two sibling nodes formally a sequent w describes a graph structure with respect to a certain node in it which we refer to as the reference node it consists of a truth context and a context a truth context contains node states which are either true formulas specific to the reference node or descriptions of its relation to child sibling and parent nodes a context contains false formulas specific to the reference node sequent w truth context · s context · a node state s a m w w w w we use truth contexts and contexts as unordered sets and do not use an additive zero like a in the definition of m is a special node state which corresponds to the unit element of the monoid in the kripke semantics of boolean bi a multiplicative pair w w asserts the existence of a pair of child nodes which are reference nodes of w and w an adjoint pair w w asserts the existence of a sibling node and a common parent node which are reference nodes of w and w respectively note that a sequent in sbbi to a sequent in classical logic if we leave only true formulas in its truth context the use of adjoint pairs implies that we can describe the same graph structure of nodes using different sequents by changing the reference node as an example consider the graph structure in figure where lines denote relations and arcs denote sibling relations we let ws wp wc wc then the following three sequents describe the same graph structure in figure but all use different reference nodes top right center and bottom left p c c wc ws p c c wc ws p p c wc ws p p c sbbi provides two inference rules which convert a sequent into another equivalent sequent by changing the reference node our definition of sequents in sbbi the principle of proof by contradiction from classical logic a proof of a sequent means that its truth and contexts together lead to a logical contradiction this from the standard interpretation of sequents for classical logic in which the conjunction of implies the disjunction of is as the ple of proof by contradiction the development of both the satisfaction relation and the rules for sbbi satisfaction relation for sequents given a nondeterministic commutative monoid u e and a valuation v pu of atomic formulas we can define the satisfaction relation w w w for sequents it uses another satisfaction relation w s s for node states and the satisfaction relation w a for formulas w w iff s w s s a w a the satisfaction relation w s s for node states is defined as follows w s a iff w a w s m iff w e w s w w iff w w u such that w w w and w w w and w w w w s w w iff w w u such that w w w and w w w and w w w note that the satisfaction relation for multiplicative formulas can be rewritten in terms of the satisfaction relation for node states as follows · w i iff w s m · w a b iff w s a · b · · w a b iff w s a · · b if w w w holds for any element w and valuation we say that w is unsatisfiable and write w w nested sequent calculus sbbi figure shows the nested sequent calculus sbbi for boolean bi the inference rules are divided into three groups structural rules traverse rules and logical rules we read every rule from the conclusion to the premise a structural rule makes a change to the sequent in the sion but does not change the reference node the rules and are weakening and contraction rules the rules and rewrite a node state according to commutativity and associativity of sequents respectively note that associativity of sequents does not use w w w and w w w both of which are syntactically the rule creates a new child node with a special form of sequent m · which can be back into the parent node by the rule intuitively m · describes an empty node whose sibling node can be identified with its parent node a traverse rule changes the reference node without changing or sibling relations between nodes the rules and the left child node corresponding to c c and the parent node corresponding to p p respectively as the new reference node in conjunction with the rule the two traverse rules enable us to an arbitrary node as the reference node because every pair of nodes can be connected only via relations the following example shows how to the sibling node as the reference node s p p s p s s p p s s p s s p p a logical rule focuses on a principal formula in the reference node if the sequent already expresses a logical contradiction it structural rules s a s s s a a a w w w w w w w · w w · w m · m · traverse rules c c c c c c c c p s s p s s p p p for parent c for child s for sibling logical rules a a init s · ls rs a ¬a a ¬a a b a b ls a b a b rs m i m i a · b · a b ls a b a b rs a b a b · ls a · · b a b rs figure nested sequent calculus sbbi for boolean bi completes the proof without generating a premise all the rules from to rs are from classical propositional logic the rule expresses the principle of proof by contradiction the rules and use the fact that i is true only in an empty node which m describes the rules ls and rs are based on the following interpretation of multiplicative conjunction w a b iff w w u such that w w w and w a and w b w a b iff w w u w w w implies w a or w b the rule ls creates two fresh child nodes corresponding to w and w where a and b are true respectively which explains why we need to use nested sequents the rule rs chooses two existing child nodes corresponding to w and w which are described by and the rules ls and rs are based on the following interpretation of multiplicative implication w a b iff w u w a implies w w w w b w a b iff w w u such that w w w and w a and w b the rule ls chooses existing sibling and parent nodes corresponding to w and w which are described by and the rule rs creates a fresh sibling node corresponding to w where a is true and a fresh parent node corresponding to w where b is false which explains why we need to allow multiple parent nodes figure shows an example of proving a a b a ¬b in sbbi the formula means that every node can have an adjacent node in which either b or ¬b is true first we apply the rule to create an empty node described by m · in which we later mix assumptions of b and ¬b to produce a logical contradiction a · m · a b a ¬b then we extend the truth context of the empty node with a node state s describing the current relation with its sibling and parent nodes a · m s · a b a ¬b here we the empty node as the reference node to generate s and apply the contraction rule to duplicate s after the sequent for the empty node and adding b to its context we consume s in m s b by the rule to restore a a a init s a · m · m b a b a ¬b ¬b m s · a · a m s s · m s · m · a · a b a b a ¬b ¬b a · m · a b a ¬b a a b a ¬b a a b a ¬b rs where s a · · a b a ¬b figure a proof of a a b a ¬b in sbbi we number all proof steps for comparison with figure the previous relation between the empty node and its sibling and parent nodes a · m b a b a ¬b finally we add b to the truth context and produce a logical contradiction m b b cut elimination in sbbi we state the cut elimination property of sbbi as follows theorem cut elimination if c and c then strictly speaking theorem states only the of the cut rule the cut elimination property however immediately follows as a corollary and we refer to theorem as the cut elimination theorem section gives an indirect proof of theorem which exploits the cut elimination property of the display calculus for boolean bi here we give a sketch of a direct proof which is inspired by the proof of cut elimination in original display logic the main in proving theorem is that the two contraction rules and duplicate a node state or a formula in their premise in conjunction with the traverse rules these contraction rules can produce copies of the cut formula c in different smaller sequents within the same sequent as in cn w cn w here cn means a truth context containing n copies of c to represent such a sequent containing smaller sequents with copies of the cut formula we introduce the following definitions partial sequent partial truth context partial node state w w w w a partial sequent is a sequent with one or more holes in it similarly partial truth contexts and partial node states contain one or more holes we write w · · · wn for the sequent obtained by holes in with sequents w · · · wn in that order we define w · · · wn and w · · · wn in a similar way w · · · wn w w · · · wn w · · · wn where n where n w where note that uses the first sequent to describe the reference node and remaining sequents to fill the holes in the proof of theorem which is inspired by the proof of cut elimination in display logic proceeds by proving the following three lemmas here we say that c holds if a and a implies for any proper a of c we also write c and c to indicate that c is the principal formula of the last inference rule in their proofs the proof of lemma uses lemma and the proof of lemma uses lemma lemma suppose that c holds then c and c imply lemma suppose that c holds then cn · · · k k and c imply · · · k k lemma suppose that c holds then c and cn · · · k k imply · · · k k then we complete the proof of theorem by induction on the structure of the cut formula c soundness and completeness of sbbi this section proves the soundness and completeness of the nested sequent calculus sbbi with respect to the satisfaction relation in section theorems and it means that the syntactic of a sequent coincides with its semantic the principle of proof by contradiction in the definition of sequents theorem soundness if then w theorem completeness if w then the proof of soundness proceeds by induction on the structure of the proof of the proof of completeness uses a translation of a sequent w into a formula w w in boolean bi defined as follows w d s g g s s a d d a as a m s i w w s w w w w w w s ¬ w w ¬ w w recall that a sequent w is a description of a set of nodes with respect to a reference node w w is essentially the same description as w except that it specifies the relationship between nodes through the use of multiplicative connectives and and negation ¬ the translation is characterized by propositions and proposition w w if and only if ¬ w w proposition if · ¬ w then propositions and allow us to complete the proof of completeness if we additionally show that a implies · a for a ¬ w since a implies a by theorem it suffices to prove the following lemma whose proof exploits the cut elimination property of sbbi theorem lemma if a then · a the following corollary shows that sbbi is sound and complete with respect to the kripke semantics in section corollary · a if and only if a display calculus for boolean bi this section the display calculus for boolean bi without the cut rule by we establish the equivalence between sbbi and and show that sbbi is an optimization of definition and properties of the display calculus uses a judgment x d y called a consecution in its inference rules x is called an and y a x a a m y x x x x y a a x y y x y are essentially an extension of in boolean bi with negative structures y do not use the multiplicative unit m and the multiplicative structural connective but introduce a negative structural connective and a multiplicative structural connective which is originally from the display calculus for linear logic the inference rules of are divided into three groups structural rules display rules and logical rules structural rules deal with the structural properties of display rules introduce or eliminate y x and x y as necessary in order to display a target or as the element in the left or right side of a consecution a logical rule focuses on a single formula that has already been displayed in the left or right side of a consecution by the display rules we refer the reader to for the inference rules of presents the following results on the definition shows that w w is a metalevel operator corresponding to the logical connective in similarly to theorem theorem states only the of the cut rule but we refer to it as the cut elimination theorem theorem cut elimination if x d a and a d y then x d y theorem soundness and completeness a d a if and only if a equivalence between sbbi and although the equivalence between sbbi and is obvious from corollary and theorem it does not how sequents and are related here we present direct translations between the two calculi and study their and differences given a consecution x d y we translate x to a sequent x x and y to another sequent y y then we combine x x and y y to build a single sequent x d y c let us write for we define x d y c as follows x dy c x x y y a x a x · · m x m · yx yy x x x x x x x x x x x x x x · a y a y · · xy y y y xx y y y y x y y x x y y · like sequents in sbbi both x and y are essentially descriptions of a set of nodes but formulas in x are regarded as true whereas formulas in y as false in the reference node we also observe that multiplicative structures x x and x y correspond to multiplicative pairs and adjoint pairs in sbbi lemma shows that sbbi is as expressive as lemma if x d y holds in then x d y c holds in sbbi given a sequent we translate to an g and to a d then we combine g and d to another w defined as follows w g d · g a s g g s s · d a a d d a as a m s m w w s w w w w w w s w w w w w w is defined in a similar way to w w given in section for example w w s coincides with w w s if we write as and w w s coincides with w w s if we write as ¬ and as the comparison between w w and w w reveals a correspondence between structural connectives in and logical connectives in boolean bi that with the translation from to boolean bi given in lemma shows that is as expressive as sbbi in conjunction with lemma it proves the equivalence between sbbi and lemma if then w d a with lemmas and we can now give another indirect proof of theorem by exploiting theorem we need an additional lemma relating the two translations lemma g x · and d y · proof of theorem suppose c and c c w d a and c w d a by lemma g d d c and c d g d by the display rules and the rule g d d g d by theorem g d d by the display rules g d d c in sbbi by lemma by lemma sbbi as an optimization of the two translations in section suggest that sequents in sbbi essentially represent a normal form of in we say that a consecution is of the normal form if it permits a negative structure x only in the right side of according to the revised definition of y a a y y x x it turns out that every consecution x d y can be converted by the structural rules for associativity and a and the display rules to its normal form x d y c w d a whose formulas form the same syntactic structure as the sequent x d y c thus we may think of sequents as representing of the normal form and sbbi as a sequent calculus that directly such note that of the normal form in still require the negative structural connective whereas sbbi requires no such negative structural connective hence those display rules dealing with have no counterparts in sbbi which implies that proof searches in sbbi are always simpler than in except in trivial cases because of the extra cost of applying such display rules in figure shows an example of proving in the same formula as in figure the proof search proceeds in a similar manner first creating m next applying a contraction rule to duplicate a then the and finally applying the rule we number each proof step to mark the correspondence between proof steps in figures and note that the display rule expands to a pair of a traverse rule or and the rule at proof steps and we observe that takes extra six proof steps all of which apply display rules marked in this example illustrates that sbbi is a formal system which can be obtained from an optimization of that with those display rules dealing with the negative structural connective and all the logical rules accordingly nested sequent calculus while the presence of multiplicative connectives from intuitionistic linear logic may suggest the inverse method for implementing a theorem prover for boolean bi the contraction property alone makes the inverse method not so ideal as it seems as already observed in previous work on intuitionistic bi by et al this is especially the case for sbbi which unlike sequent calculi for intuitionistic bi needs to use a graph structure of sequents instead of a tree structure for example it is not clear how to generate a minimal graph structure that to a given pair of graph structures for those inference rules with two sequents in the premise thus we choose to use a backward search strategy in our theorem prover as the first step we obtain the nested sequent calculus sbbi shown in figure by embedding the weakening and contraction rules and into structural rules w w w w s w s w s · w w w s w w where s w w s w w w w w w m · traverse rules m s m where s m c c c c c c c c p s s p s s p p p for parent c for child s for sibling logical rules a a a a init c lc ¬a ¬a a b a b lc a b a b rc m i m i a · b · a b lc a a b b a b a b rc a a b b a b a b lc a · · b a b rc figure nested sequent calculus we define s as s in the rule a d a init d a m a a m a a m m a d a a b a ¬b d a a b a ¬b a b a ¬b a a b a ¬b m d a a m d a da a d a a b a ¬b a b a ¬b b a b a ¬b ¬b m rd d ada d figure a proof of a d a b a ¬b in adapted from all the other rules of sbbi similarly to sbbi the inference rules are divided into structural rules traverse rules and logical rules since contraction is built into all the inference rules in the premise of every structural rule subsumes the graph structure of nodes represented by the conclusion except the rule which rewrites a node state according to commutativity of sequents every structural rule has a premise that strictly extends its conclusion with new relations between nodes below we further describe the two structural rules and in which the premise nodes by changing and sibling relations but is also able to recover the original structure of nodes expressed in the conclusion in the rule each sequent wi si i in the premise represents the same graph structure as the conclusion except that its reference node is now described by wi extending wi with si in this way is a part of building contraction into the rule and is thus necessary for the completeness of with respect to boolean bi as an example consider the proof of a sequent w w b w · where w a · and w c b c · and w c · we apply the rule to generate another sequent w w b w w s w s w s · · with s w w · · b and s w w · · b and s w w b · · eventually we reach the following sequent which is provable only because of the interaction between s and a b via the rule lc c b c w s w s s · ¬a b c s a b · hence if we omit si in the premise of the rule we lose the completeness of the rule creates a new child node with a special form of sequent m · which can be back into the parent node by the rule intuitively m · describes an empty node whose sibling node can be identified with its parent node similarly to the rule the premise of the rule combines the conclusion with a new sequent s which represents the same graph structure as the conclusion but has a different reference node s in the premise also costs the completeness of for example if we omit s in the premise of the rule the sequent in figure is not provable because its proof depends on the interaction between a b and s via the rule lc m a s b a b b a init c a b m a a s b b a b s b m a a b a b b s b m a · b init c s m a a a b b b s m a · a b b b b lc a b · m a · s b a b · m a · b where s m a · a b b s a b · m a · figure a proof of a b · m a · b in every inference rule in is invertible ie the premise implies the conclusion and vice versa we can formally prove that both weakening and contraction are admissible in we can also prove the equivalence between sbbi and theorem weakening and contraction in if then s and a if s s then s if a a then a theorem equivalence between sbbi and in sbbi if and only if in figure shows an example of proving in the same sequent as in figure the proof tree is much smaller the depth decreases from to and the number of applications of rules decreases from to besides the amount of nondeterminism in proof search is now minimal in figure after applying the rule when read from the conclusion to the premise we have to decide whether or not to duplicate s by applying the contraction rule and if we skip the rule proof search fails in figure this form of nondeterminism does not arise because the contraction rule is embedded into the rule as a result except for applying the rule the only source of nondeterminism concerns which of a b and a ¬b should be considered first by the rule rc which is irrelevant for the purpose of this proof since their role is to change only the reference node without changing the graph structure of nodes the traverse rule and the structural rule in figure do not increase the complexity of proof search for example once we decide to focus on ¬b in a a m b ¬b we obtain a unique sequence of rules namely followed by for m b ¬b in the reference node thus the cost of proof search is mainly by various decisions on applying the structural and logical rules and not by applications of the traverse rules section explains how to eliminate the traverse rules in proof search backward proof search in this section explains the design of our theorem prover which uses a backward search strategy built on top of because of the undecidability of boolean bi our theorem prover implements a algorithm for our purpose a algorithm is still useful because in program verification we usually attempt to prove formulas that are to be true our theorem prover includes a which converts every proof in into an equivalent proof in sbbi according to our proof of theorem in addition to automated proof search it also supports an interactive mode in which the user can issue various tactics to manually change the structure of nodes both extensions are a preliminary step toward developing a program verification algorithm d input goal sequent w search depth d output true or fail for each node w w as the reference node if lc or is applicable return true if rc lc or rc is applicable w result of applying the rule return d if lc is applicable w and w result of applying the rule return d d if rc or lc is applicable to a fresh node state s w and w result of applying the rule to s return d d if d return fail for each node state s in node w to which or is applicable w as the reference node w result of applying the rule to s if d true return true for each node w w as the reference node w result of applying if d true return true return fail figure for the proof search algorithm system based on full separation logic for space reasons we do not describe these extensions basic structure of the proof search algorithm figure shows the for the proof search algorithm given a goal sequent w and a search depth d as input it attempts to search for a proof tree for w with at most d applications of the structural rules except the rule along any search path first it every formula in a given sequent and applies the corresponding logical rule if possible lines ­ after checking if d line it considers the structural rules and lines ­ it returns either true or fail depending on the result of the proof search for the sake of simplicity the algorithm assumes that the rule is embedded into all the other rules for example the rule in figure indeed refers to one of the four instances obtained by independently applying the rule to node states w w and w w w the first phase of the algorithm lines ­ exploits the fact that all the logical rules including rc and lc are invertible hence it starts by applying the logical rules possible until no more applications are left for the rules rc and lc we make sure that they do not focus more than once on the a m · a a a m b a a a a a m b init c m a a m a a b b b ¬b init c a m b ¬b a a a m b ¬b a a a m · a a m b a b a ¬b rc a a m · a b a a a b a ¬b ¬b rc where a b a ¬b rc a a b a ¬b figure a proof of a a b a ¬b in each rectangle marks a principal formula or a sequent to be exposed in the reference node same pair of a principal formula and a node state eg a pair of a b and in the rule rc since the principal formula in the premise after the first phase the algorithm recursively invokes itself to apply the structural rules and in depthfirst order lines ­ for example with d it considers all sequences of length in the following order we choose to consider the rules and before the rule which is the least restrictive rule in the sense that it can be applied to any sequent note that applying a structural rule does not create new formulas but only gives rise to new pairs of a formula a b or a b and a node state to which the rules rc and lc can be applied a recursive invocation of immediately focuses on these new pairs during its first phase lines ­ explosion in the search space and the number of while the algorithm eventually finds a proof tree for every provable sequent if given an search depth a naive implementation from two problems that are unique to boolean bi the first is an explosion in the search space in terms of the amount of conjunctive nondeterminism among the logical rules rc and lc and the structural rules that is a typical proof search is quickly with too many choices for applying these rules which are all invertible and thus can be applied this problem is due to the structural rules and each application of which immediately or the search space the second problem is an explosion in the number of due to the logical rules rc and lc each application of which increments the number of these rules can be applied to each formula a b or a b as many times as there are corresponding node states for example if contains n multiplicative pairs the rule rc creates n from a b during the first phase of the algorithm the first problem is closely related to the contraction property built into the structural rules as an example consider the structural rule in figure the graph structure of the premise has four times more nodes than that of the conclusion because each sequent wi si i represents the same graph structure as the conclusion as shown in figure consequently the premise provides four times more ways to apply the rules of thus the search space in a similar way each application of the other structural rules and the search space we remark that the first problem is not the price to pay for building contraction into the structural rules since the same problem of search space explosion remains even if we do not build contraction into the structural rules the second problem itself is orthogonal to the first problem but its effect is by the first problem as an exam ple consider again the structural rule in figure where we set a b c after an application of the rule to obtain the graph structure in figure two applications of the rule rc to copy a to w b to w and c to w if these formulas happen to involve multiplicative connectives we can again apply the rules rc and lc to propagate their component formulas which in turn may trigger further applications of the rules rc and lc and so on to the first problem we need to a scheme for applications of the structural rules section we can solve the second problem by an idea from the inverse method section in addition we can eliminate the traverse rules section applications of the structural rules as a solution to the first problem we assign a priority either high or low to every sibling relation between nodes so as to all applications of the rules and and to every node itself so as to all applications of the rule when applying a structural rule the algorithm first considers sibling relations and nodes with a high priority and then those with a low priority below we explain how to assign to sibling relations and how to determine for nodes for the rule as shown in figure we assign to sibling relations in the premise according to figure with the following interpretation · for a sequent inside a rectangle w every sibling relation in it is assigned the same priority as in the conclusion · for a sequent inside a dashed rectangle w every sibling relation in it is assigned a low priority · a sibling relation depicted with lines high priority is assigned a · a sibling relation depicted with dashed lines low priority is assigned a the for this assignment is that an application of the rule is primarily intended to generate sibling relations described by w w w · rather than s s and s in w s w s w s · when applying the rule the algorithm focuses first on those node states both of whose sibling relations have a high priority in a similar way we assign to sibling relations in the premise of the rules and according to figure we determine of nodes by analyzing of relations if a node is involved in a sibling relation with a high w w w w w w w w w w w w ·· w w w figure the graph structure of nodes before conclusion and after premise applying the structural rule in figure after applying the rule m m after applying the rule m · figure assigning to sibling relations after applying the rules and is defined as priority it is more likely to be under active consideration by other structural rules than those nodes with no such hence we assign a high priority to every node involved in at least one such sibling relation for the logical rules lc and rc we reuse the priority assigned to the reference node of the conclusion for two new nodes in the premise now we the algorithm as a algorithm in the first stage it applies the structural rules using only sibling relations and nodes with a high priority note that it still generates every node with a low priority which is never used by the structural rules but may be needed by the logical rules for example the two sequents discussed in section are provable in the first stage precisely because we also generate every node with a low priority if the proof search fails it enters the second stage and the proof search without ignoring sibling relations and nodes with a low priority the second stage is necessary for the completeness of proof search since some formula requires us to apply the structural rules using those with a low priority as well in fact we can find even a formula whose proof tree applies the structural rules using only those with a low priority section presents examples of such formulas the proof tree from the premise we solve the problem of an explosion in the number of with a simple technique of the proof tree from the premise suppose that we apply the rule rc or lc to produce two in the premise without knowing whether this application is necessary or not if this application is unnecessary however every proof tree for the first premise must be a proof tree for the conclusion as well hence upon finding a proof tree for the first sub goal we it against the conclusion and attempt to prove the second only in the case of a failure in this way we can apply the rules rc and lc without about an explosion in the number of in essence we partially simulate the inverse method with a overhead of proof trees but without entirely the nested sequent calculus eliminating the traverse rules the algorithm invokes the traverse rules to change the reference node lines in figure but we can eliminate the traverse rules with a slight change in the representation of sequents the basic observation is that the traverse rules change only the reference node without the graph structure of nodes hence by rewriting every rule in such a way that it directly focuses on any formula or node without requiring a reference node we can discard the traverse rules to this end we introduce a labelled sequent which assigns a unique label w to every node and all formulas and ms in it with w labelled sequent l graph structure · w w labelled truth context · aw labelled context · aw w w in the graph structure specifies that w is a parent node of w and w then we can convert every sequent to a unique labelled sequent modulo renaming labels since a sequent determines a unique graph structure of nodes where each node contains a unique set of true formulas ms and false formulas let us write w for the unique labelled sequent converted from sequent w for a rule w from w and w in we derive a new rule that w from w and w in a single step for an axiom w in we derive a new axiom w we refer to the system as the labelled w w r in w w rl in the labelled the labelled has no traverse rules because the premise and conclusion of a traverse rule in represent the same graph structure of nodes still it is equivalent to because the definition of labelled sequents the traverse rules into all the inference rules proposition w is provable in if and only if w is provable in the labelled figure shows an example of proving in the labelled the same formula as in figure the depth decreases from to w w aw init l w w bw aw init l w w a bw w a · aw a bw a bw a w w w w a bw bw bw bw rl init l rl aw aw · aw a b a rl where a bw a a bw a figure a proof of · aw a b a in the labelled the rule rl focuses on the formula inside the rectangle and the number of applications of rules decreases from to the rule immediately completes the proof when it detects the same labelled formula in both contexts of a given labelled sequent the rule also directly focuses on regardless of the presence of w w in the graph structure in this way the labelled with the traverse rules yielding a smaller proof tree than experimental results we compare a naive implementation of the algorithm with an optimized implementation that those ideas described in sections and both implementations internally use the labelled to eliminate the traverse rules as explained in section our implementations are written in objective caml and run on linux with intel core i and of main memory figure shows results of running both implementations naive and optimized on representative formulas for a given formula a we use sequent · a and search depth d as input to the algorithm except for experiment c we set d to the minimum search depth for finding a proof tree the result is either the return value of true and fail or error if the proof search does not terminate within in the cost in terms of the number of applications of the rules we the rule which is already embedded into all the other rules the time is in seconds experiment a tests formulas all involving multiplicative connectives of increasing complexity the two formulas marked require only those applications of the rule in which sibling relations with a low priority are visited hence the proof search in the second stage of the algorithm experiment b is designed to measure the effectiveness of the two optimizations specifically against the rule experiment c tests the effect of increasing d for a common formula which can be proven with two applications of the rule followed by an application of the rule we observe that the cost of proof search is mainly driven by search depth d ie the number of applications of the structural rules required to complete proof search we also observe that the optimized implementation is much less to the exponential growth of the search space than the naive implementation thereby that the two optimizations in sections and are indeed highly effective in experiment c a search depth of eventually produces a proof tree but only after a number of wrong applications of the rule an increase of d to however immediately a wrong application of the rule which happens to lead to the correct two applications of the rule which is why it produces a proof tree at a much lower cost from to a further increase of d to does not significantly increase the cost but the time becomes much longer because of the extra overhead of manipulating much larger sequents overall we find that the optimized implementation is reasonably fast in proving typical formulas of boolean bi related work proof search in the logic of bi and separation logic previous work on proof search in the logic of bi mainly focuses on intuitionistic bi which is another member in the family that inherits multiplicative connectives from intuitionistic linear logic like boolean bi but additive connectives from intuitionistic propositional logic and present a labelled tableau calculus for a propositional fragment without and develop a theorem prover called on top of it their later paper extends the calculus for full intuitionistic bi et al investigate the inverse method for a propositional fragment without units and i and develop a forward theorem prover for boolean bi no theorem prover has been developed yet because of the lack of a proof theory suitable for proof search and formulate a labelled tableau calculus by extending the labelled tableau calculus for intuitionistic bi in but only in order to investigate the relation between intuitionistic bi and boolean bi shows that a modular combination of display calculi for classical logic and intuitionistic linear logic gives rise to a display calculus for boolean bi the first syntactic formulation of boolean bi and proves the cut elimination property by observing that its rules all the syntactic constraints given in developing a practical proof search strategy on top of it however is far from easy because of the complexity due to its display rules and the difficulty in restricting applications of the contraction rules and present a labelled tableau calculus for separation logic it lies between syntactic tableau and semantic labelled because labels correspond to heaps in separation logic their calculus sound and complete does not directly translate to a proof search strategy in its current form it is easy to build a tableau for a given formula according to the calculus but one needs to check if all branches in the tableau are logically or structurally inconsistent this requires two semantic functions a measure and an interpretation for each branch and the calculus does not specify how to obtain such semantic functions for a similar reason the labelled tableau calculus for boolean bi in does not directly translate to a proof search strategy for theorem provers for the decidable fragment of separation logic by berdine et al without separating implication see for example nested sequent calculi a nested sequent calculus is one whose sequent may contain smaller sequents it has been used as a formulation of some modal and logics for which no sequent calculus of the standard form exists sbbi is also a nested sequent calculus because a sequent may contain smaller sequents formula a a b i a b i i a ¬a ¬a b ¬a ¬b b i a b c a b c i a b c a b c i a b b c a b b c ¬a ¬a c b a c d a b c c a c c a b a ¬a b b a a c d a b b b a b c d d c b a a b c d d b c a a b c d e e d a b c a b c d e e b a c d c i a b b c d a d c b b d naive optimized result cost result cost time true true true true true true true true true true true true true true true true error true true error error fail error error error error true true true true true fail true true true error figure results of running two implementations naive and optimized of the algorithm the time is in seconds a nested sequent calculus is often obtained as an optimization of an equivalent display calculus that is not simplified to a sequent calculus of the standard form et al ­ propose such nested sequent calculi for logic and classical logic in particular their nested sequent calculus for classical logic is similar to sbbi in that it has two residual rules corresponding to the traverse rules of sbbi the main difference is that uses only a tree structure of sequents and has no rule for associativity which changes and sibling relations between sequents hence it is much easier to embed contraction rules in than in sbbi and the problem of search space explosion due to structural rules as in does not exist in comparison between sbbi and we have seen in section that for boolean bi sequents in sbbi essentially represent a normal form of in for intuitionistic bi establishes a stronger result that sequents in its sequent calculus are a normal form of in its display calculus and thus belong to the same syntactic category he also that a sequent calculus for boolean bi is to exist if it has no negative structural connective such as in see section in our discovery of sbbi does not his conjecture because we can think of sequents in sbbi as implicitly applying a negative structural connective to contexts what is equally important however is that introducing only a negative structural connective is not enough to achieve a sequent calculus for boolean bi which must use a graph structure of sequents in which a sequent may have multiple parent sequents in the case of the linear structural connective allows such a graph structure of sequents but the purpose of introducing is to obtain the display theorem which is essential to proof of the cut elimination theorem for display calculi similarly even though it does not require such a graph structure the display calculus for intuitionistic bi in also has the same linear structural connective in contrast sbbi introduces an adjoint pair w w for the purpose of allowing such a graph structure of sequents conclusion despite its close connection with separation logic boolean bi has not received much attention from the proof search community such a lack of research which is quite considering the status of separation logic in the field of program verification is perhaps due to the difficulty of finding a proof theory suitable for theorem proving our nested sequent calculus sbbi as well as a theorem prover based on it may serve as a test for developing proof search strategies for boolean bi in particular its use of nested sequents allowing multiple parent sequents may new light on how to deal with separating implication in a theorem prover for separation logic acknowledgments we are to the anonymous reviewers for their helpful comments this work was supported by the engineering research center of program of of science and technology national research foundation of grant and program through by the references n display logic journal of logic ­ n linear logic displayed journal of formal logic ­ j berdine c calcagno and p w ohearn a decidable fragment of separation logic in proc pages ­ j berdine c calcagno and p w ohearn modular automatic assertion checking with separation logic in proc pages ­ j berdine c calcagno and p w ohearn symbolic execution with separation logic in proc pages ­ j berdine c calcagno b cook d p w ohearn t and h yang shape analysis for composite data structures in proc cav pages ­ l birkedal n and j c reynolds local reasoning about a copying garbage collector in proc popl pages ­ r s and on the wand in proc csl pages ­ j a proof theory for boolean bi via display logic technical report college london j a unified display proof theory for logic in proc pages ­ j and m undecidability of propositional separation logic and its in proc lics pages ­ k deep sequent systems for modal logic in proc advances in modal logic pages ­ by e and x relational inductive shape analysis in proc popl pages ­ d and m j parkinson towards practical verification for java in proc oopsla pages ­ d p w ohearn and h yang a local shape analysis based on separation logic in proc tacas pages ­ k t n s and s park the inverse method for the logic of implications in proc pages ­ d and d expressivity properties of boolean bi through relational models in proc pages ­ d and d and generation in propositional bi logic in proc pages ­ d and d semantic labelled for propositional bi without bottom journal of logic and computation ­ d and d and resource graphs for separation logic journal of logic and computation ­ d d and d j the semantics of bi and resource mathematical structures in computer science ­ r l and a and for logic using nested sequents in proc advances in modal logic pages ­ r l and a displayed logics using nested sequents with deep inference in proc pages ­ r l and a on the correspondence between display and deep inference in nested sequent calculi for logics logical methods in computer science ­ s s and p w ohearn bi as an assertion language for mutable data structures in proc popl pages ­ b j and f imperative programs as proofs in proc pages ­ r sequent calculi for some logics ­ d and d exploring the relation between intuitionistic bi and boolean bi an embedding mathematical structures in computer science ­ d and d the undecidability of boolean bi through phase semantics in proc lics pages ­ s j berdine e m clarke and b cook arithmetic strengthening for shape analysis in proc sas pages ­ n r and a formal verification of the heap manager of an operating system using separation logic in proc pages ­ j a and a rybalchenko separation logic calculus heap theorem prover in proc pldi pages ­ acm h h and wn program verification with lemmas in proc cav pages ­ p w ohearn and d j the logic of implications of symbolic logic ­ d j the semantics and proof theory of the logic of implications academic j c reynolds separation logic a logic for shared mutable data structures in proc lics pages ­ v vafeiadis and m j parkinson a of relyguarantee and separation logic in proc concur pages ­ h yang an example of local reasoning in bi pointer logic the graph marking algorithm in proceedings of the st workshop on semantics program analysis and computing environments for memory management pages ­ 