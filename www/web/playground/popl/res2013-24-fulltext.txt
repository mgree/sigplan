views compositional reasoning for concurrent programs thomas college birkedal it university of copenhagen college matthew parkinson microsoft research yang university of oxford abstract compositional abstractions many reasoning principles for concurrent programs the concurrent environment is abstracted in order to reason about a thread in isolation and these abstractions are composed to reason about a program consisting of many threads for instance separation logic uses formulae that describe part of the state abstracting the rest when two threads use disjoint state their specifications can be composed with the separating conjunction type systems abstract the state to the types of variables threads may be composed when they agree on the types of shared variables in this paper we present the concurrent views framework a metatheory of concurrent reasoning principles the theory is by an abstraction of state with a notion of composition which we call views the metatheory is simple but highly applicable the relyguarantee method concurrent separation logic concurrent abstract predicates type systems for recursive references and for unique pointers and even an adaptation of the method can all be seen as instances of the concurrent views framework moreover our metatheory proves each of these systems is sound without requiring induction on the operational semantics categories and subject descriptors f specifying and verifying and reasoning about programs logics of programs general terms theory verification keywords concurrency axiomatic semantics compositional reasoning introduction this paper aims to find the core principles underlying compositional reasoning systems for firstorder concurrent programs compositional reasoning means that we consider each component in isolation without having to know the precise concurrent or sequential context in which it will be placed this is essential for reasoning about incomplete code or libraries the context is not known permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm in a concurrent setting compositional reasoning allows a thread to be considered in isolation rather than considering all possible interleavings of a program type systems and program logics are two common forms of compositional reasoning they a balance between invariant properties that must be preserved during the execution of a concurrent program and operations that may be performed standard type systems and relyguarantee methods focus on preserving global properties for example the typing of the memory such approaches are good at handling sharing and interference but work less well with stateful behaviour separation logic focuses on local portions of the state which can be manipulated independently this approach is good at handling stateful behaviour but works less well with sharing and interference there have been into the middle ground such as linear types and related capability systems which allow strong updates to memory and and which combine ideas from relyguarantee and separation logic to enable reasoning about finegrained concurrency in the heap these developments have led to elaborate reasoning systems each introducing new features to specific applications of compositional reasoning and adhoc metatheory to justify these features given the of these approaches it is not clear that they have significant common ground can the adhoc metatheory of each be generalised to give a paradigm in which all can be understood we argue that in fact the above reasoning systems employ a common approach to compositionality they provide abstractions of the state which enough information to prove properties about the behaviour of a thread allowing for the possible behaviours of other threads we introduce the concurrent views framework views framework or views for short which captures this compositional reasoning by introducing the notion of views intuitively a threads view consists of abstract knowledge about the current state of the machine and the threads to change the state of the machine the knowledge of a thread must be stable under the operations of concurrent threads no other thread may have to the threads knowledge conversely no thread can have knowledge that another thread has the right to views are compositional knowledge and may be distributed between threads and to illustrate the views framework first consider type systems for an imperative concurrent language in a simple type system the types of variables are invariant each threads view is provided by a typing context which the knowledge that the values of variables agree with their types and the to change the state such that this typing is preserved when views are composed they must agree on the types of all variables they share in a type system that permits strong ie updates threads again have knowledge that variables agree with their types but may make updates that change the types of variables threads views may be consistently composed only if they describe disjoint sets of variables which each thread can be seen to own note that since heap locations may be aliased by multiple variables it is not in general to update their types however a type system may include unique reference types that ownership of heap locations and hence allow updates in this paper we show how a simple type system § a type system with strong updates recursive types and subtyping § and a type system with unique references § can all be in views now consider program logics for the same concurrent language with concurrent separation logic the views are assertions that describe the part of the state owned by a thread these views knowledge about the owned part of the state and the exclusive right to modify it views are composed with the separating conjunction which enforces disjoint ownership of the state so that no thread may alter state owned by another thread more elaborate logics such as and concurrent abstract predicates cap allow assertions to describe shared state and ownership of specific capabilities to update the shared state here the stability of assertions is important an assertion about the shared state must be invariant under operations for which other threads may have capabilities in this paper we represent a wide range of example program logics in our views framework including several separation logics the § and relyguarantee methods § and cap § a description of all our examples can be found in the technical report along with coq of many of them the views framework the essential for sound compositional reasoning given a set of views with a composition operator denoted together with an for the atomic commands views provides a generic program logic for soundness we require a reification function from views to sets of machine states and an axiom soundness property the reification function relates partial abstract views to complete concrete machine states axiom soundness ensures that the axioms for the atomic commands are sound with respect to the reification in the context of an arbitrary environment view this compositionality in the meaning of program c updates the view from p to q for all environment views r it must update p r to q r this approach has previously been used for extending sequential separation logic for higherorder languages where it is otherwise difficult to locality properties of commands which are sufficient for ensuring compositionality we show that the interpretation also provides a simpler and more general metatheory for logics of concurrent programs identifying simple properties needed to prove soundness in contrast with the complex soundness results in the literature the views framework provides a generalised frame rule this rule is essential for directly encoding the weakening rule from relyguarantee and rules for manipulating resource invariants in concurrent separation logic the new rule allows a function to be applied uniformly to the pre and postcondition of a command without this rule the encoding of concurrent separation logic relyguarantee and method would require a far more complex representation of the highlevel reasoning with permissions such as given the wide range of examples that are instances of our framework we believe views the core principles underlying compositional reasoning about concurrent programs overview in § we present our core contribution the concurrent views framework defining the parameters and properties necessary to instantiate our general program logic as a example we show how a simple type system may be encoded in views in § we show how separation algebras and interference can be used to construct instances of the views framework these constructions with separation logic in § we present a novel of the frame rule for the views framework this rule makes it possible to encode contextual rules which we illustrate by the weakening rule of the relyguarantee method we present a general combination rule in § which the rules of disjunction and conjunction we give a sufficient condition for its soundness and consider the special cases of disjunction and conjunction we outline the general soundness proof for the framework in § in § we show the of views through five further example instances recursive types unique types the method atomic concurrent separation logic and concurrent abstract predicates finally we discuss related work in § and conclude in § we have all of the metatheory of the paper as well as many of the examples in coq see concurrent views framework in this section we present the concurrent views framework in § we present the programming language and its operational semantics which is by a notion of state and a set of primitive atomic commands and their semantics as state transformers in § we provide a set of rules for compositional reasoning which is by an abstraction of the state equipped with a composition operation a views and an of the atomic commands in § we give a general soundness result for the framework with respect to the operational semantics which is by a relationship between the abstract views and the concrete states and requires each axiom to satisfy a soundness property with respect to the semantics of the corresponding atomic command to illustrate the views framework we its definition with an example of how to instantiate it for a simple type system for a heap update language programming language and operational semantics we define the views framework on a simple programming language that is built from standard composite commands and by a set of atomic commands this enables us to consider many examples without having to change the metatheory parameter a atomic commands assume a set of syntactic atomic commands atom ranged over by a definition language syntax the set of syntactic commands comm ranged over by c is defined by the following grammar c a skip c c c c c c c the operational semantics is by a model of machine states and an interpretation of the atomic commands as state transformers parameter b machine states assume a set of machine states s ranged over by s parameter c interpretation of atomic commands assume a function atom s ps that associates each atomic command with a nondeterministic state transformer where necessary we lift nondeterministic state transformers to sets of states for s ps a s a s s s for machine state s the set of states a s is the set of possible outcomes of running the atomic command a if the set is empty then the command blocks here we consider partial correctness and so ignore executions that deadlock that is reach a state other than skip in which every thread is blocked if we wish to guarantee against some behaviour it should be modelled with an exception state rather than by blocking we define the operational semantics of the language using a labelled transition system transitions are between commands and are labelled by atomic commands or id id labels computation steps in which the state is not changed definition transition labels the set of transition labels label def atom id extends the set of atomic commands with a designated identity label id labels are ranged over by is extended to label by defining id def s s the labelled transition system splits the controlflow aspect of execution represented by the transitions between commands and the aspect of execution represented by the labelling of the transitions this makes it easy to programs over a more abstract while preserving the controlflow structure which simplifies the soundness proof of our logic definition labelled transition system and operational semantics the labelled transition relation comm × label × comm is defined by the following rules c c c c c c skip c id c i c c id ci c id c c c id skip skip c id c c skip id c c c c c a a skip c c c c c c c c the operational transition relation comm × s × comm × s is defined by the following rules c c s s c s c s c s c s c s c s heap update language for our examples we use a language with simple atomic primitives for manipulating a heap we therefore define instances of parameters a b and c accordingly definition atomic heap commands parameter a assume a set of variable names var ranged over by x and y and a set of values val ranged over by v of which a subset loc val represents heap addresses ranged over by l the syntax of atomic heap commands is defined by the grammar a x y x v x y x y x ref y definition heap states parameter b machine states are partial functions from variables and locations to values there is also an state denoted which represents the result of an invalid memory access formally sh def var loc fin val definition heap command interpretation parameter c the interpretation of the atomic commands is given by x y s def y doms sx sy x v s def x sx doms v x y s def x y sx doms sy x y s def y sy doms sx x ref y s def y doms sx l l sy l loc doms where b s if b then s else here we extend dom to sh by taking dom views and program logic reasoning systems typically do not require the user to reason directly about the state they provide an abstract representation of the state that supports a particular form of reasoning for example in a simple type system the state is abstracted by a type context which maps variables x to types a type represents a property about the variable eg that it is a pointer to a cell in the heap in a program logic like separation logic the state is abstracted by assertions p q that describe parts of the memory complex assertions may be used to represent interesting structures such as a lock x with an invariant p p such assertions may not merely describe the state but also enforce a protocol that threads must for instance only a lock after establishing its invariant these abstract representations do not precisely describe the memory just certain properties it satisfies they also can contain additional information about typing ownership and protocols for instance that is not present in the underlying state these abstractions form the key parameter of the framework the views we have one basic requirement for views which is that they form a commutative parameter d view commutative assume a commutative view the variables p q r are used to denote elements of view if the has a unit u then we call it a view monoid written view u the unit is not required for the theory but simplifies its use intuitively views are resources that knowledge about the state and the protocol threads must and to modify the state in with the implied protocol the operation view composition combines the knowledge and of two views since composition is used to combine the views of different threads it must ensure consistency between these views for example to combine two typing contexts they must agree on the type of any variables they have in common since threads only maintain the types in their view if agreement was not enforced then one thread might violate in separation logic composition separating conjunction enforces that ownership is exclusive no two views can simultaneously have ownership of a heap cell in variants that allow assertions about shared state such as composition also forces consistency between such assertions this consistency is typically implemented by a special inconsistent view that is the result of composing two views that are not consistent the inconsistent view is usually a unique zero element of the when composed with any other view the result is the inconsistent view we define a program logic for our programming language in which views provide the pre and postconditions of the commands the program logic is by the set of axioms for atomic commands parameter e assume a set of axioms axiom view × label × view definition entailment the entailment relation view × view is defined by p q def p id q axiom definition program logic the program logics judgements are of the form p c q where p q view provide the precondition and postcondition of command c comm the proof rules for these judgements are as follows p a q axiom p a q p c q p r c q r p skip p p c q p c q p c c q p c p p c p p c r r c q p c c q p c q p c q p p c c q q p p p c q p c q p c q q q p c q the intended semantics of p c q is that if the program c is run to termination from an initial state that is described by the view p then the resulting state will be described by the view q this is a partial correctness interpretation the judgements say nothing about nonterminating executions the proof rules are standard rules from disjoint concurrent separation logic they include the frame rule which captures the intuition that a programs view can be extended with a composable view and the disjoint concurrency rule which allows the views of two threads to be composed note that although in separation logic the concurrency rule imposes disjointness in views it does not it just imposes the last two rules are rules of consequence they allow the precondition to be or the postcondition with respect to the relation if is reflexive these rules may be combined into a single rule simple type system consider a simple type system for our heap update language where variables and heap cells are typed from the set type ranged over by and defined by val ref the type val indicates that a variable or heap cell contains some unspecified value while the type ref indicates that it contains the address of a heap cell whose contents is typed as a typing context var type is a partial function which assigns types to variables within the views framework typing contexts are views composition is the union of contexts as relations with a special inconsistent typing context used to denote the composition of typing contexts that on the type of some variable definition simple type views parameter d the view monoid for the simple type system is defined as var type judgements of the type system have the form c we treat this as syntax for c in the views framework it remains to give axioms for the type system definition simple type axioms parameter e the axioms for the simple type system are defined as x y x y ref x y x ref val x y x ref y x ref y x y x v x ref y the inference rules of the type system are as follows c c op skip c op c c c c c c c c c each of these rules is justified by the rules of the views program logic where we interpret as the most interesting of these is the last the weakening rule which is an instance of the frame rule with the frame reification and soundness in order to relate the program logic to the operational semantics it is necessary to define a relationship between the abstract views and the concrete machine states in a type system this would be given by a judgement s that state s is welltyped with respect to the context in separation logic it would be given by a kripke model where the judgement s p asserts that formula p holds in state s in the views framework we model this relationship with a reification function parameter f reification assume a reification function view ps which maps views to sets of machine states note that the reification function has very few restrictions the structure of views is not reflected at the level of machine states the notion of composition is purely an abstraction the space of machine states need not be covered completely by the reification this is useful for giving interpretations to our proof judgements furthermore inconsistent views may be mapped to the empty set of machine states choosing an appropriate reification function is important we could for instance map all views to the empty set and claim soundness of an arbitrary logic however judgements in the logic would no information about the operational semantics as they would not describe the execution of a program from any initial state at all consequently soundness is always with respect to the choice of reification function soundness requires that the axioms concerning atomic commands are satisfied by the operational interpretation of the commands we define an abstract notion of executing a small step of the program to be able to make the step from p to q with the action we must ensure that the operational interpretation of the action satisfies the specification and moreover it also preserves any possible environment view definition action judgement the action judgement is defined as pq def p q r view p r q r for a view monoid this definition simplifies to pq r view p r q r semantic entailment is a special case of the action judgement for the label id definition semantic entailment p q def id pq programming language a atomic commands highlevel program logic d views e soundness f reification g axiom soundness lowlevel operational semantics b states c atomic semantics figure overview of the views framework for each axiom p q the interpretation of must update view p to q while preserving any environment view this is captured by the following property property g axiom soundness for every p q axiom pq this property is both necessary and sufficient for the soundness of the program logic we state the soundness result here and provide more details in § theorem soundness assume that p c q is derivable in the program logic then for all s p and s s if c s skip s then s q simple type system soundness we typing contexts as the set of states which are welltyped with respect to the context consequently we must define a notion of typing for states definition state typing the state typing judgement s where var type s sh and loc type ranges over heap typing contexts is defined as follows s def x dom sx x l dom sl l where v def val ref v the state typing essentially ensures that every typed variable and location has a value consistent with its type specifically this means that references must refer to addresses that have the appropriate type note that it would not be possible to have x and y the same location in the typing context x ref val y ref ref val this is necessary since otherwise an update to the location via x could the type of y definition simple type reification parameter f the simple type reification ts is defined as follows ts def s sh s to establish soundness we need only show property g axiom soundness this is straightforward for further details importantly this works because we do not require locality at the low level of the semantics only at the high level thus standard separation algebra approaches would not work for this example summary the parameters of the views framework are in figure the language § is by a set of atomic commands and its semantics is determined by a notion of state and the semantics of the atomic commands as state transformers the views program logic § is by a of views and an of the atomic commands the soundness of the logic § is with respect to a reification of views into concrete states and is established by proving the axiom soundness property in the following sections we consider numerous instances of the views framework in doing so we elaborate the metatheory with common constructions and additional proof rules remark the views framework is more general than existing of separation logic in that it does not restrict views to be sets of machine states but allows them to be elements in any in fact choosing this views and an reification function well is the most important step of using our framework a good choice of the views leads to a program logic where a verifier works on the right level of abstraction of machine states also it an appropriate scope for the universal quantification in the axiom soundness property and gives an effective set of axioms for atomic commands this influence of the views on axiom soundness corresponds to selecting a notion of locality properties for commands which was usually done in a fixed manner in the work on separation logic constructing views we can instantiate of the framework directly but instantiations often have common structure which can be used to simplify the process we present two general approaches to constructing views as sets whose elements themselves belong to a partial monoid separation algebras calcagno et al introduced the concept of separation algebras to separation logic for many examples we use a of separation algebras with multiple units and without the requirement to construct a view monoid parameter h separation algebra a separation algebra is a partial commutative monoid with multiple units namely it is a set m equipped with a partial operator · m × m m and a unit set i m satisfying · commutativity m · m m · m when either is defined · associativity m · m · m m · m · m when either is defined · existence of unit for all m m there exists i i such that i · m m and · of unit for all m m and i i if is defined then i · m m definition separation view monoid parameter d each separation algebra m · i induces a separation view monoid pm i where p p def m · m m p m p separation algebras are typically constructed by adding instrumentation to machine states this instrumentation determines how states may be composed typically by recording ownership or invariant properties while previous work has required we do not remark for separation view monoids it is common to choose entailment to be subset inclusion disjoint concurrent separation logic to illustrate the separation algebra we present a simple separation logic for disjoint concurrency definition separation algebra parameter h the separation algebra for disjoint concurrent separation logic is where def var loc fin val is the union of partial functions with disjoint domains and the unit is the partial function with the empty domain elements of declare ownership of the variables and heap addresses that belong to their domains as well as defining their values significantly they do not declare information about parts of the state which are not owned views p q are sets of these abstract states thus p and q describe resources which hold information about part of the state judgements of disjoint concurrent separation logic are as in the views framework triples of the form p c q the view x v denotes the singleton set of the partial function mapping variable x to value v and x denotes the set of all partial functions that map only variable x to a value similarly the views l v and l map heap address l to v or any value respectively the view v pv is the infinite join of pv for all values of v definition parameter e the for separation logic is given by the schemas x y v x y x v y v x l l x v x l l v x l l y v x y x l l v y v y l l v x x y y l l v x v x y v x ref y l x l l v y v for the soundness of a view model based on separation algebra we typically provide a reification function for elements of the separation algebra this is then lifted to give a reification for views parameter i separation algebra reification m ps definition parameter f p mp m given this construction of a view monoid and reification func tion property g has an equivalent formulation that is typically simpler to check property j axiom soundness ii for every p q axiom and every m m p m q m remark the case where id will always hold if p q implies that p q subset inclusion as a natural choice for the entailment relation disjoint concurrent separation logic soundness since views are sets of partial functions from variables and locations to values they can be seen as sets of heap states thus we can define a simple notion of reification definition reification parameter i the reification ps is defined as follows s def s our axioms for atomic commands are sound in the sense of property j taking entailment to be gives the standard rule of consequence note that the reification function does not cover the machine state space there is no view p with p this means that our triples do not permit memory to occur in with the standard interpretation separation algebras with interference views model partial abstracted information about machine states that is stable to interference from other threads in logics with finegrained permissions such as those used in dg and concurrent abstract predicates cap the elements of the separation algebra are not stable by construction but an additional obligation is added to only mention stable sets of elements this can simply be seen as another way of constructing a view monoid from a separation algebra and an interference relation parameter k interference relation an interference relation r m × m on a separation algebra m · i is a preorder satisfying the properties · for all m m m m m with m m · m and m r m there exist m m m with m r m m r m and m m · m and · for all i i and m m with i r m m i definition view monoid parameter d an interference relation r on a separation algebra m · i generates a view monoid i where p pm rp p the notation rp means m m mp p mp r m the composition is as in definition that is closed under and includes i follows from the conditions in parameter k remark unlike in cap and dg we do not need to provide a guarantee relation to say what a thread can do that is dealt with by axiom soundness in this setting property g has an equivalent formulation that is typically simpler to check property l axiom soundness iii for every p q axiom and every m m then p m q rm separation logic with ownership we illustrate how interference can be used to construct views by showing how separation logic can be constructed this way rather than using the separation algebra introduced in section we construct a view monoid for disjoint concurrent separation logic by machine states with an ownership mask which provides explicit permissions for stating which variables and addresses are owned definition separation algebra parameter h the separation algebra is where def var loc fin val × m · m m def dom m dom m dom m k dom m mk mk mk mk mk mk and i def m k dom m mk where i accesses the ith component of a tuple for each variable or address the first component of the partial function represents its value and the second component indicates whether or not the variable or location is owned if a variable or location is undefined then it is not allocated composition requires that the state components are the same as that of the composite and that their ownership masks sum to give the mask of the composite this ensures that each variable and location is uniquely owned this composition is welldefined associative and commutative if we constructed a view model based on this separation algebra the commands we could reason about would be very limited they could not alter the machine state this is because programs are required to preserve all frames and therefore all values however the intention is that only variables and locations that are owned are preserved by other threads thus instead of preserving all frames we wish only to preserve all stable frames for a suitable notion of stability this can be obtained by defining an interference relation definition interference relation parameter k m r m def k dom m mk m k mk this relation expresses that the environment can do anything that does not alter the variables and locations owned by the thread it is not difficult to see that the interference relation satisfies the decomposition property any change that does not alter the variables or locations owned by either thread does not alter the variables or locations owned by each thread if we consider the view monoid induced by the separation algebra under this interference relation we obtain a notion of view that is specific about variables and locations that are owned but can say nothing at all about variables and locations that are not owned thus threads are at to variables and heap locations they own and allocate locations that are not owned by other threads since these operations preserve stable frames note that composition plays an important role here it enforces that the environment cannot also own variables and locations that belong to the thread we define an operation by p def m m p k v mk v m k v this operation in fact defines an isomorphism between the two view monoids so we can really think of the separation logic model as being constructed in this way this construction of separation logic the approach of implicit dynamic frames there assertions about the state and about ownership are assertions are required to be self a property which corresponds directly to stability separation logic with fractional permissions can be defined by using from the interval instead of a bit mask in § we discuss how the more complex permissions model of cap can also be expressed using separation algebras with interference generalised frame rule when reasoning uses a context it is common to have weakening rules on that context such as the weakening rule of the type system in § in the views representation weakening rules become rules that perform the same manipulation on the pre and postcondition of the specification in the simple type system the weakening rule to the frame rule however for certain examples the frame rule is not powerful enough to represent the required context manipulation directly we therefore introduce a generalised version of the frame rule relyguarantee we the need for generalized frame rules by considering the relyguarantee method relyguarantee judgements take the form r g p c q here p and q are assertions interpreted as sets of states r and g are relations on states rely and guarantee relations that describe how the environment and the program c respectively are allowed to update the state the assertions p and q are required to be stable under r the atomic step rule takes the following form a p g a p q r g p a q where a p def s s a s p the first condition ensures that g describes the possible behaviours of the program the relyguarantee method is by the following rule for parallel composition g r r g p c q g r r g p c q r r g g p p c c q q this rule requires that the behaviours of each thread abstracted by g and g are contained in the interference expected by the other thread represented by r and r the context of the composition relies on the environment doing no more than both threads expect while the guarantee must account for the behaviours of each thread the above rules suggest encoding relyguarantee into the views framework with views consisting of triples p r g of assertions and rely and guarantee relations where p is stable under r composition would then follow the parallel rule resulting in the special inconsistent view when the relies and guarantees do not meet the definition rg view monoid parameter d the set of relyguarantee views is defined as p r g rp p composition is defined as p r g p r g pp rr gg provided gr and gr with all other cases resulting in the unit is s s we encode the rules by placing the rely and guarantee both into the pre and postcondition r g p c q def p r g c q r g for all relyguarantee judgements we assume the pre and postcondition are stable with respect to the rely and thus p r g and q r g are both valid views using this encoding the structural rules including parallel follow trivially from the rules of the views program logic and the atomic rule can be considered to define a set of atomic axioms parameter e views are to the set of states satisfying their assertions definition rg reification parameter f p r g p lemma rg axiom soundness property g if a p g and a p q then a p r r g proof we must show that for every p r g a p r g p r g q r g p r g we can assume composition is defined as the undefined case is trivial and as reification ignores the relyguarantee components we can simplify this to g r g r rp p rp p a p p q p showing that the result is in q follows directly from the second premise and that it is in p from the first premise using routine relational reasoning while we have established the soundness of most of the rules we have not yet considered weakening rule r r g g r g p c q r g p c q this rule simply increases the restrictions on the environment it may do less r r but must more g g if we try to encode the context weakening rule using the frame rule induced by the composition above we require r r g g r g p r g p r g p r g however this does not hold when r g we could use a more elaborate structure to represent the pair of relations such as the structure which can then be encoded into our framework however this the original of relyguarantee and does not capture the intuition behind it instead we provide a new of the frame rule that can capture this reasoning directly we introduce a generalised frame rule which applies a function to the pre and postconditions of a specification the rule is by a function f view view p c q f p c f q by choosing particular functions f we can encode a range of reasoning rules in particular the standard frame rule for the frame r pick the function fr def p p r now for the rule to be sound we must prove the following property for the f function and the action judgement used in axiom soundness property m f step preservation p q pq f pf q this property is sufficient for the soundness of the generalised frame rule the proof of soundness is essentially the same as for the frame rule and has been checked in coq remark the generalised frame rule is analogous to the frame rule of context logic where contexts are applied by a operation to the pre and postconditions one could construct a context algebra by taking views as the data and the functions satisfying property m as the contexts and thus see the generalised frame rule as an instance of the context logic rule conversely one could view the application of a context as a function satisfying property m and hence see the context logic frame rule as an instance of the generalised frame rule relyguarantee weakening returning to our motivating example we can now show how to encode relyguarantee weakening rule using the generalised frame rule the weakening rule can be in an equivalent form as r g p c q r r g g p c q thus we justify this instance of the rule using the generalised frame rule choosing f to be the function that restricts the rely by r and extends the guarantee by g fr g def p r g p r r g g where x f x v is f v if v is not and is otherwise thus we are required to show the following lemma fr g step preservation property m p r gp r g p r r g g p r r g g this holds because the changes to the rely and guarantee only serve to further restrict the set of environment views that we must consider in the action judgement and the assumption ensures r r and g g combination rule the views proof system we have presented so far has omitted two common rules disjunction and conjunction one key reason for this is that such rules are not applicable to every instantiation of the framework for example the simple type system of § does not naturally support a disjunction or conjunction rule both of these rules may be expressed as special cases of a general rule for combining multiple specifications of a single program this general rule is by a notion of view combination such as disjunction or conjunction which maps indexed families of views into single views by choosing the index set i we can define combination operations at different parameter n view assume a function i i view view the combination rule is as follows i i pi c qi ii pi c ii qi this rule is justified sound by the following property property o primitive combination for all label i i ii pi ii qi remark this combination rule the generalised frame rule from the previous section which is simply a unary instance of the combination rule disjunction in the case of disjunction there is often a natural operator that has the following properties property p join distributivity p ii qi ii p qi property q join morphism ii pi ii pi together these two properties imply property o separation algebras when views are constructed from a separation algebra as in § the views themselves are sets and so it is natural to consider set union as a notion of disjunction by the definition of a separation view monoid definition it follows that satisfies the join distributivity property property p the join morphism property property q likewise follows directly from the definition of reification definition consequently the obvious rule of disjunction is sound for logics built from separation algebras in this way such as separation logic for a view monoid definition note that the interference relation preserves unions since it is applied from this it follows that again satisfies the required properties to provide a rule of disjunction conjunction it is possible to give properties analogous to properties p and q relating a conjunction with such properties are sufficient to establish property o however it is not often that an instantiation of views is equipped with a operator with these properties for instance in separation logic does not over conjunction in cases such as separation logic where a conjunction rule is sound property o can typically used to directly justify it it is less common for instantiations to have a conjunction rule than a disjunction rule one explanation for this is that views typically add instrumentation that is not present in the concrete state such as type information this information can independently of the concrete state leading to different specifications for the same program that make incompatible changes to the instrumentation which cannot be combined with a conjunction rule disjoint concurrent separation logic for disjoint concurrent separation logic consider the binary conjunction operation given by set intersection we can prove that this gives a sound rule of conjunction by establishing property o using two useful facts for views constructed from separation algebras the action judgement need only account for singleton environment views pq m p m q m this fact the of axiom soundness ii property j secondly singleton views are precise p p m p m p m note that this is not a general property of separation algebras but can be established for separation logic suppose that pq and pq using the above facts and definition i we can establish that p p m p m p m q m q m q q m this is sufficient for property o to hold for binary intersection this argument extends to intersection notably however it does not apply to the case which would give c for every program c where this would be unsound since yet there are programs which may fault when run from an arbitrary initial state soundness in this section we sketch the soundness of the framework the following results have been machine checked with coq and the proof scripts are available there are two key properties of the action judgement the first is that it is closed under the composition of a view and the second that it is closed under the semantic entailment order definition lemma basic locality for all p q r view label if pq then p rq r lemma basic closure for all p p q q view label if p p p q and q q then pq to prove the soundness we use a semantic judgment that ensures every step of the machine correctly preserves the context using the action judgment the semantic judgement is defined it is a greatest fixed point definition semantic judgement for command c comm and views p q view the semantic judgement p c q is defined to be the maximal relation such that p c q holds if and only if the following two conditions are satisfied for all label c comm if c c then there exists p view such that pp and p c q if c skip then p q we can understand the semantic judgment p c q as creating a trace of views for each possible interleaving of the commands in c where each trace starts in p and if it is a finite trace then it ends in q that is if n is a finite trace of c then there exists a sequence p pn such that p p pn q and i if is an infinite trace of c then there exists a sequence pp such that p p and i for each of the proof rules there is a corresponding lemma establishing that it holds for the semantic judgement we present two particularly interesting ones here lemma soundness of frame if p c q then p r c q r proof by coinduction the case c skip is trivial assume that p c q and c c by these assumptions there exists p such that pp and p c q it suffices to show that p rp r and p r c q r the first follows from lemma and the second from the coinductive hypothesis remark the soundness of the generalised frame rule and the combination rule are proved by a similar argument to the frame rule for the combination rule we require the axiom of choice for the indexing set this allows us to select a next view p in the above proof for each index lemma soundness of parallel if p c q and p c q then p p c c q q proof by coinduction assume that c c c either one thread takes a step or one thread has finished executing if the latter c ci cj skip and id where i j it must be that pj qj so id pi qj by definition of furthermore pi qj ci qi qj follows from lemmas if the former assume that c c c and c c the case where c reduces is similar by assumption there exists p such that pp and p c q it suffices to show that p pp p and p p c c q q the first follows from lemma and the second from the coinductive hypothesis by similar lemmas for the other proof rules we establish that the proof judgement of the logic implies the semantic judgement lemma if p c q is derivable in the program logic then p c q to establish soundness we link the semantic judgement to the operational semantics lemma if p c q then for all s p and s s if c s skip s then s q this lemma follows from the definitions soundness now follows immediately from the preceding two lemmas theorem soundness assume that p c q is derivable in the program logic then for all s p and s s if c s skip s then s q further examples we provide five additional instantiations to illustrate the flexibility of our metatheory recursive types unique types method separation logic with resource invariants and concurrent abstract predicates the recursive types example demonstrates that views captures more realistic types it also illustrates how the rule of consequence can be used for subtyping the connection between strong update type systems and separation logic has been an open problem for around ten years the unique types example makes steps towards connecting them using the views framework the example illustrates that even underlying traditionally reasoning is a compositional core the example shows how resource invariants can be added to the views formulation of separation logic by using the generalised frame rule the final example cap illustrates that the metatheory to recent complex logics recursive types in this example we give a type system for references to pairs and recursive types which allows us to represent simple lists and trees the syntax of types is val null ref µx x the type null represents the type just by the value the reference type ref is a pointer to a pair of locations with types and respectively the type allows null as well as values of type note that ref cannot be a null pointer finally the fixedpoint operator and type variables make it possible to represent recursive data types for example we can define lists as list def µx ref x as with the simple type system views consist of type contexts and the inconsistent context unlike in that example however we compose typing contexts with disjoint union this allows us to consider variables as uniquely owned by threads rather than shared and consequently reason about strong updates of variables definition recursive type view monoid parameter d the view monoid for recursive types is var type we extend the language introduced in § to work with pairs instead of single heap cells we assume that values are integers and locations are positive integers x ref y z allocates a pair of consecutive locations in the heap them with values y and z the first and second components of a pair x may be accessed independently by x fst and x snd to encode case splitting on a pointer being null we use two commands x which blocks if x is not null and performs the identity action otherwise and x which blocks if x is null and performs the identity action otherwise these allow us to encode choice as x then c else c def x c x c since we wish to allow updates commands are specified with both a pre and a context c in the views framework we naturally interpret this as syntax for c in order to introduce types and to fold and unfold recursive types we introduce a notion of subtyping the subtyping relation is defined as the least preorder satisfying null µx µx x µx x µx definition context subtyping subtyping is lifted to contexts in the obvious way def x x definition recursive type parameter e the typing rules for atomic commands include the following x x x null x x x x ref y x fst y x ref y x ref y y x fst x ref y x y z x ref y z x ref y z typing rules for the snd component are analogous to those for fst we give the axioms for entailment as def the challenging aspect of this instantiation is giving the reification which requires us to define a notion of being welltyped we define a relation v that expresses that a value v has type in a heap typing that maps locations to types note that values range over integers v val null v µx x v v µx v v ref v v we can then define reification as the set of states that are well typed with respect to a view that is those states for which there is a heap typing such that the value of each variable and heap location is correctly typed by the view and the heap typing definition recursive type reification parameter f s µ def x dom sx x to show the type system is sound we simply show axiom soundness property g for the axioms and subtyping relation unique types the previous example used an atomic allocate and instantiate instruction x ref y z but this is not realistic as this would be done in many operations in this example we extend the types from the previous section to allow us to separate allocation from instantiation we give a new highlevel syntax to types that allows us to represent a unique reference at the toplevel t we change to map to these extended types we can then give rules for the atomic commands to allocate and update a unique reference x x ref x val val x y y x y these rules allow us to alter the type of something in the heap this is sound as we are currently the only thread to have access to the location we use the subtyping relation to cast away the uniqueness by adding the following to the subtype relation ref we define a function that the uniqueness information so that we can reuse the previous definitions def x if x then ref else x our notion of a memory satisfying a type context is the same as before with an additional constraint that each unique reference can be removed from the memory and the memory is welltyped without it in the smaller context s def s µ x s x µ where f x def y if xy then f y else note this does not mean that the location of a unique reference cannot occur in another stack or heap location but it cannot occur as something potentially considered as a reference technically x y y x x y val is a sound axiom in this model we require this kind of property of our model as we only distinguish between integers and references at the type level the concrete model does not separate them thus it is possible for the allocator to use a location for which the integer is currently in use but this does not matter if it is being treated as a location then it would already be allocated and thus the allocator would not double allocate it the axioms and subtyping satisfy the required properties property g method we present a version of the method that can be encoded trivially into the views framework however we omit the auxiliary variable rule and leave this to future work normally the method has a check on parallel composition each command used by one thread when restricted to its precondition preserves all the assertions used in the proof of other thread we explicitly account for the assertions used in a proof and the commands and preconditions as contexts to our judgements specifically p a p c q means that executing c in a state satisfying p if it terminates then the state will satisfy q and the proof only uses assertions in p and its atomic commands are described by a thus the rule for an atomic command is p p q p p a a a p q p a p a q the parallel rule is p a p a p c q p p p a a a p p p p c q p p p a a a p p p p p a a pp c c qq the two right premises are the standard interference freedom checks again as with relyguarantee this parallel rule induces a composition operation that we can use to build a view model the precise definition actually requires that the proof only uses assertions that are intersections of some elements of p otherwise we would require the parallel rule to additionally require its pre and postconditions to be in p this requirement is only evident in the soundness proof and does not alter the reasoning provided by the method that we present definition view monoid parameter d the view monoid s is defined by def p a p p p p p with composition given by p a p p a p def p p a a p p provided p p p a a a p p p p p p a a a p p p and otherwise defined to be the proof rules follow from the views framework using the obvious encoding the atomic rule determines the atomic axioms parameter e we can provide a weakening rule that allows the context to be as a simple application of the generalised frame rule for soundness we define reification parameter f as simply taking the assertion component of a view and in the case of axiom soundness property g follows from the premises of by the consistency requirement of composition step preservation property m for weakening follows trivially from axiom soundness given that the atomic rule is closed under the context atomic csl we consider a concurrent separation logic with a single resource invariant that must be preserved by each atomic command this logic has a simple rule for atomic commands i p a i q i p a q if the atomic command meets the specification in standard separation logic § with the invariant i added to both the pre and postcondition then it meets the specification in this logic we interpret this in the views framework by defining views to be pairs of shared invariants and local assertions composition on these views requires invariants to agree definition atomic csl view parameter d the atomic csl view is × where i p i p is defined to be i p p if i i and otherwise we encode the judgement i p c q as i p c i q there are two rules for manipulating the context the resource invariant the first is a frame rule for the resource invariant and the second allows local state to be added to the resource invariant i p c q i i p c q i i p c q i p i c q i these rules can be interpreted as instances of the generalised frame rule for the invariant frame rule the following function is suitable def i p i i p for the local invariant rule a more complicated function is necessary i def i p if i i i then i p i else the function ensures that the resource invariant in the premise is i i if not then the function maps to the inconsistent view thus making the rule and the property for soundness we define the reification to take the composition of the invariant and assertion in the sense of definition atomic csl reification parameter f i p def i p def this is the only example we present in the paper that does not have a unit however the model does have a zero and satisfies x u x u x y y u y y u this property is sufficient to show the simplification of pq given in provided axiom soundness property g can easily be established given the soundness of the context rules require us to prove property m for the first we can to the frame rule of with the frame i for the second the function i either the judgement trivial or preserves the reification so property m holds remark if we wish to establish the conjunction rule for this logic we can do so if the resource invariant is precise given that assume has a conjunction rule we must show for the binary case i pi q i pi q i p pi q q using the rule of conjunction we know i p i pi q i q using the rule of consequence we know i p pi q i q and moreover if i is precise then this implies i p pi q q this establishes primitive combination property o which is sufficient for the conjunction rule to be sound concurrent abstract predicates concurrent abstract predicates cap extends separation logic with shared regions that can be by multiple threads through atomic operations each shared region is associated with some interference environment which how it may be by defining a collection of actions threads can the shared state only by performing actions for which they have a capability resource which may be exclusive or an example of a cap assertion is the following r x x r i r this assertion represents a shared mutex in the heap at address x the boxed part of the assertion describes the shared region either the mutex is available x has value or it is locked x has value if it is available the exclusive region the thread itself has capability a belongs capability lo to the c kr which will permit it to lock the mutex the actions corresponding to the capabilities are defined by the interference environment ir i r def lock unlock x x x un x lo the interference environment that a thread holding a lock capability may atomically update x from to in the shared region simultaneously removing the capability a thread holding an unlock capability may update x from to while returning to the shared region by locking the i is precise iff p q i p i q i p q mutex a thread acquires the exclusive capability to unlock it this guarantees that only one thread can have locked the mutex at a time and only that thread can unlock it having locked the mutex through an atomic operation a threads view may be described by the following assertion r x r i r whereas in the thread does not know whether the mutex is locked or not in it knows that it is locked it can only make such an assertion because it holds the exclusive capability without that the assertion would not be stable in separation logic capabilities are always directly associated with the information they to as in l whereas in cap they can be separated in the rest of this section we informally describe the parameters for the views framework we do not give their formal details and direct the reader to thesis and our technical report for the full definition and explanation cap assertions are modelled by sets of states instrumented with ownership capabilities and region information each instrumented state consists of three components the first is the threadlocal state which consists of capability resources as well as heap resources the second is a mapping that associates region identifiers with their states the third is an interference environment that associates the action identifiers used in capabilities with their interpretations as actions instrumented states form a separation algebra parameter h composition of instrumented states is defined as requiring equality between the second and third components while combining the resources in the first component for the formal definition see § to use cap we must work with stable assertions views in order to account for possible interactions between threads these stable assertions are defined by closure under an interference relation parameter k which allows the environment to update regions in any way for which it can have a suitable capability the interference relation is constructed as the transitive closure of three relations which model region update in with actions the environment may have capability to perform region construction and region destruction see p definition for the formal definition and p lemma for the proof of the decomposition property reification parameter i for cap is given by combining the heap components of the local and shared states the capabilities and interference environment the atomic rule of cap effectively establishes axiom soundness property l by means of a guarantee relation that atomic operations to preserve stable frames p lemma p lemma remark in our example interference was not essential since the interference relations were equivalences views were sets of equivalence classes and it was easy to define canonical representations of these classes cap on the other hand is difficult to model without considering interference explicitly one reason for this might be that interference is and not simply an equivalence consequently expressing as between closed sets is likely to be the simplest way of constructing a suitable view model another reason is that it is convenient to construct views from assertions that are not themselves stable hence it is convenient to have a model in which we can represent both stable and assertions related work our composition operator provides a logical notion of separation which as we have demonstrated by examples need not be realized by physical separation in the concrete machine this idea of separation has been used in recent work on separation logics for concurrent languages similar ideas are also useful in a purely sequential setting to enable modular reasoning about abstract data structures implemented using physical sharing but for which a logical notion of separation can be defined the soundness of capability system is based on an axiom that is similar to our definition of interference relation and the soundness proof of concurrent abstract predicates also uses an equivalent lemma our framework does not have an explicit notion of guarantee so many of the other properties required in both work and concurrent abstract predicates are not required also provides conditions such that the stable predicates can be composed the condition requires to the scope of interference which we do not require conclusions we have introduced views as a general framework in which a wide variety of compositional reasoning approaches can be constructed understood and proved sound we find it surprising and that approaches such as separation logic relyguarantee the method and type systems can be understood in an elegant unifying setting while the power of the views framework is in the variety of systems that it its is in providing a common semantic for them each of the approaches we have studied can be proved sound by to the general soundness result of views without to induction over the operational semantics we have shown how views captures a broad selection of existing reasoning systems of course the true test is whether views can be used to develop new and interesting systems we are already finding this to be the case concurrent abstract predicates has been extended with higherorder features using views extended with to prove soundness the views framework has been extended to reason about c with interesting permission annotations to ensure isolation between threads views are also in the development of sound logics for local reasoning about structured data such as file systems in this setting data into fragments that record how they are connected is central and is justified by the semantic entailment of views in reynolds noted the close relationship between separation logic and type systems and whether the line between types and assertions can be erased we have shown that at least in the firstorder case types and assertions are simply different kinds of view ultimately we have identified core principles underlying compositional reasoning about concurrent programs and them in a unifying framework views acknowledgments we thank hoare peter ohearn john wright and the anonymous of popl lics concur and popl for helpful feedback and comments on the paper and yang support from references a ahmed m and g morrisett l a linear language with locations ­ l birkedal n and h yang semantics of typing and higherorder frame rules for algollike languages l birkedal b j and h yang a simple model of separation logic for higherorder store in icalp r c calcagno p ohearn and m parkinson permission in separation logic in popl c calcagno p and u local reasoning about data update ­ c calcagno p w ohearn and h yang local action and abstract separation logic in lics a and f pottier functional translation of a calculus of capabilities in icfp pages ­ t abstract data and local reasoning phd thesis college department of computing t m p m j parkinson and v vafeiadis concurrent abstract predicates in ecoop t p and m abstraction and refinement for local reasoning in t l birkedal p m parkinson and h yang views compositional reasoning for concurrent programs technical report and material r a and a w appel a fresh look at separation algebras and share in m x m j parkinson and v vafeiadis reasoning in esop pages ­ x local relyguarantee reasoning in popl x r and z shao on the relationship between concurrent separation logic and reasoning in esop pages ­ p g and a wright reasoning about file systems using structural separation logic draft c gordon m parkinson j a and j uniqueness and reference for safe parallelism in oopsla s s and p w ohearn bi as an assertion language for mutable data structures in popl pages ­ j b and l birkedal separation logic in esop c b jones steps toward a development method for programs acm toplas ­ n l birkedal and j verifying programs using frame properties in n a d dreyer and d types in icfp g morrisett d walker k crary and n from system f to typed assembly language toplas ­ s and d an axiomatic proof technique for parallel programs i informatica ­ m j parkinson r and p ohearn modular verification of a nonblocking stack in popl f pottier syntactic soundness proof of a system with hidden state technical report inria j c reynolds separation logic a logic for shared mutable data structures in lics j b and f implicit dynamic frames combining dynamic frames and separation logic in ecoop f smith d walker and j g morrisett alias types in esop k l birkedal and m parkinson a specification of the joins library in higherorder separation logic technical report it university of copenhagen v vafeiadis and m j parkinson a of relyguarantee and separation logic in concur pages ­ 