a meta lambda calculus with computation school of mathematical sciences the university of abstract we propose meta lambda calculus as a basic model of textual substitution via metavariables the most important feature of the calculus is that every redex can be reduced regardless of whether the redex contains metalevel variables or not such a meta lambda calculus has never been achieved before due to difficulty to binding structure consistently with renaming in the presence of metalevel variables we overcome the difficulty by introducing a new mechanism to deal with substitution and binding structure in a systematic way without the notion of free variables and renaming calculus enables us to investigate terms that include a certain type of level terms have been regarded as terms and left out of consideration thus far we find that some terms behave as and eval command in programming languages with these terms we show a procedural language as an application of the calculus which new light on the notions of stores and recursion via metalevel variables categories and subject descriptors f mathematical logic and formal languages mathematical logic ­ lambda calculus and related systems keywords lambda calculus metavariables textual substitution dynamic binding introduction metavariables and meta lambda calculi when discussing a formal language we use metavariables a metavariable is a symbol that stands for some syntactic object in a discussed language for example we use the following expression when defining reduction of the lambda calculus xm n m nx for variables x and terms m n in this case x m and n are metavariables if we instantiate the metavariables x m n with specific syntactic objects in the lambda calculus for example x xy z respectively then we get as an instance of reduction note that the expression the syntactic object zy in the lambda calculus since we can calculate as permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm zy after the instantiation of the metavariables recently several formal systems are proposed as extensions of the lambda calculus to the notion of metavariables ­ in this paper such formal systems are called meta lambda calculi the most important feature of meta lambda calculi is that they include textual substitution to model instantiation of metavariables the ordinary substitution in the lambda calculus is performed with renaming to avoid variable binding whereas textual substitution is performed without renaming by replacing each occurrence of a variable simply with a term thus textual substitution generates new bindings dynamically we illustrate a sketch of meta lambda calculi consider an extension of the syntax of the lambda calculus defined by the following presented in terms m x xm m m x xm m m where x ranges over the set of variables and x ranges over the set of metalevel variables the first three in the above represent the constructs namely the constructs in the lambda calculus the last three represent metalevel constructs as counterparts of the constructs in the syntax we have the following reduction sequence corresponding to the example discussed before zy where letters m and n are metalevel variables and letters x y and z are variables in this paper a metalevel application containing a metalevel abstraction as the left part is called a metalevel redex and an counterpart is called an redex for instance is a metalevel redex and is an redex metalevel reduction denoted by in section and section is performed on a metalevel redex in a similar way to the ordinary reduction but by textual substitution in the above example metalevel variable m is instantiated with the term xy by metalevel reduction and the variable x is dynamically bound by the binder x problem in designing a meta lambda calculus when trying to define a meta lambda calculus formally we face a subtle problem resulting from of the ordinary substitution with textual substitution consider the following cases to examine redexes containing metalevel variables consider a term we cannot reduce the term simply by the ordinary substitution as m since such reduction gives us the following two reduction sequences that are not confluent xy zy the term zy in the second line is the intended result of the term as shown before it is obviously a to consider that m since m is a metalevel variable to be instantiated later with a term that may contain the variable x consider a term we cannot reduce the term simply as ym since such reduction gives us the following two reduction sequences that are not confluent yy zy the second reduction sequence gives us the intended result note that we have the following expression with a side condition in the definition of substitution in the lambda calculus yn mx yn mx if y x hence we cannot actually have without satisfying a side condition such as the one above however we do not have such side condition in the first place since we have no information about the free variables occurring in the term for which m stands namely the term with which the metalevel variable m is instantiated later the above cases indicate that we cannot define easily substitution for terms containing metalevel variables the of the problem is that a metalevel variable is just a for some term unknown yet approaches in previous works approaches in previous works related to modeling metavariables and the problem discussed above are classified into two categories here we explain briefly the essential points of the two categories respectively features of individual works are mentioned in section metalevel variables assigned with interfaces one approach is to assign each metalevel variable x with a finite list of variables to be bound dynamically which is called the interface of metalevel variable x in this paper with assigning an appropriate interface to each metalevel variable and with embedding such additional information into terms explicitly instantiation of metalevel variables can be by computation in calculi dealing with only static binding in particular the ordinary lambda calculus for example consider the following metalevel reduction the metalevel reduction can be by the following lambda term which is obtained from the above term by assigning metalevel variable m with the interface x y to take a familiar example the above fact corresponds to the fact that the c program with macros in figure can be by the c program without macros in figure a metalevel variable assigned with an interface for example the list of x and y is roughly equivalent to an ordinary function of x and y figure int main int x int y x define m y x x m y y x return m x figure int main int x int y x int x int y return y x x mx y y y x return mx y x calculus m in and the calculi in ­ adopt similar approaches to the one discussed above so as to consider metavariables to be assigned with interfaces these calculi are inherently designed to deal with only static binding as the ordinary lambda calculus and hence in these calculi the notion of textual substitution is modeled by a mechanism like the ordinary substitution as illustrated above as a result the problem in question from these calculi in this paper these calculi are called lambda calculi with interfaces from meta lambda calculi since there is a difference between the concept modeled in meta lambda calculi and the concept modeled in lambda calculi with interfaces in order to the challenge in meta lambda calculi we explain the essence of the difference between meta lambda calculi and lambda calculi with interfaces in meta lambda calculi metalevel variable m must satisfy the following principle for any variables x and y xm ym if and only if x y where denotes the equivalence induced from rewriting rules this principle is a consequence of the requirement that the term xm is the counterpart of the expression xm in the metalanguage and the term is the counterpart of the function m xm on the set of all lambda terms the principle corresponds to the fact that two functions m xm and m ym are equal if and only if x y note that if the principle did not hold and we had some distinct variables x and y such that xm ym then we would have equivalence such as xy yy the goal of meta lambda calculi is to add new syntactic objects called metalevel variables satisfying the above principle into the ordinary lambda calculus in contrast lambda calculi with interfaces as well as the ordinary lambda calculus do not contain any term that corresponds to a metalevel variable namely they do not contain a term n satisfying the following property for all variables x and y xn yn if and only if x y in the example shown before the term can be used in the ordinary lambda calculus to the behavior of metalevel variable m however the term itself cannot be an alternative to metalevel variable m generally for instance we have distinct in the ordinary meta lambda calculi reduction the other approach to resolve the problem in section is to restrict reduction rules by side conditions taking levels into account to a case of calculus m in reduction xm n m nx is defined with the following side condition m and n contain no metalevel constructs the other previous meta lambda calculi ­ also adopt similar approaches although there are various technical differences a reduction defined with such side conditions is called a reduction in this paper reductions bring confluence in meta lambda calculi since wrong reduction sequences mentioned in section are eliminated by such side conditions however reductions make some redexes stuck for instance the following redex containing metalevel variables cannot be reduced in the previous meta lambda calculi due to such side conditions shown above in other words we cannot reduce an redex until we instantiate metalevel variables in the redex with some terms our purpose in this paper we propose meta lambda calculus with a new mechanism to reduce redexes containing metalevel variables calculus enables us to advance computation in the presence of metalevel variables and hence up new possibilities for reduction strategies that have been restricted by reductions in previous meta lambda calculi for example we are able to introduce the notion of lazy evaluation in the presence of metalevel variables another purpose of calculus is to examine those terms that include a certain type of level such as an abstraction applied to a metalevel abstraction like such terms are called terms in this paper terms have been regarded as terms and left out of consideration by type systems or by reductions in previous meta lambda calculi one of distinct features of calculus is that the calculus makes it possible to compute terms in section we show that some terms behave as and eval command in programming languages through an example these terms provide us new insight into the notions of stores and recursion via metalevel variables overview of our approach an analysis of calculation in the metalanguage in the metalanguage we can always · rewrite a redex xm n to the expression m nx · perform renaming with some fresh variable and · pass down substitution nx on a term to its subterms in this way we can calculate a redex to perform substitution of variables even if the redex contains metavariables for example we can have the following calculation in the metalanguage y y where v is fresh vm ym y vm m ym y m m m m m yy m m m m m m yy m y since v is fresh note that x and y are variables as syntactic objects in the lambda calculus whereas v is a metavariable that stands for some variable in the lambda calculus if we instantiate metavariables m in the last line with term yx we get the following result the key factors that enable us to advance calculation in the presence of metavariables are · substitution operators and · freshness conditions with renaming note that these two factors interact with each other in the above example the freshness condition v is fresh first arises in association with renaming of the binder y to v in the process of the calculation the freshness condition substitution operators m following metavariables m furthermore the last reduction that yields substitution operator m actually eliminates the freshness condition v is fresh at the end of the calculation consequently we have y m m yy m y for any term m we attempt to incorporate the two notions of substitution op and freshness conditions into a meta lambda calculus to achieve our purpose it is not difficult to embed substitution operators as syntactic objects a major is how to deal with freshness conditions and the interaction with substitution operators in a meta lambda calculus as explained in the subsequent discussion we overcome the by indexed variables and skip operators as alternatives of freshness conditions indexed variables consider the extended syntax of the lambda calculus defined by the following terms m vd vm m m where v ranges over a set of names and d ranges over the set of nonnegative integers in this syntax a variable consists of a name v and a nonnegative integer d called the index of the variable in a term variable vd d binders of v and hence is bound by the d th binder of v for instance in term the variable y is bound by the binder y as in the ordinary lambda calculus whereas the variable x the rightmost binder x and is bound by the leftmost binder x in a word we consider an extension of the lambda calculus with de bruijn indices the extended syntax enables us to perform reduction without renaming although we can still have the notion of renaming for example we can reduce a term in the following two ways the reduction sequence in the second line is regarded as the one in the ordinary lambda calculus note that if we equivalent terms as we usually do in the ordinary lambda calculus then the above two reduction sequences are identical as a result the extended syntax provides us a more expressive notation without changing the theory of the lambda calculus skip operators as alternatives of freshness conditions in the extended syntax we no longer need the notion of freshness of variables for example we can calculate with metavariables as follows y where y is a skip operator on the term m to increment indices of y in term m appropriately so as to skip the binder y for instance xy y denotes xy the above calculation corresponds to the following calculation with a freshness condition in the ordinary lambda calculus where v is fresh skip operators free us from the need to perform renaming and the need to keep freshness conditions outside of terms consequently skip operators can be more easily embedded into a meta lambda calculus than freshness conditions a sketch of meta lambda calculus we construct meta lambda calculus in section by indexed variables and by embedding both substitution operators and skip operators as syntactic objects in the calculus here we show a sketch to give an intuition about the calculus the syntax defined by the following is a part of the syntax of calculus terms m vd vm m m x xm m m substitutions id vm · v · where v ranges over a set of names d ranges over the set of nonnegative integers x ranges over the set of metalevel variables and id the empty sequence the elements of form vm called are counterparts of substitution operators mv and the elements of form v called are counterparts of skip operators in calculus a substitution is dealt with as a finite sequence of and in order to calculate the two kinds of elements in an integrated way to model the interaction between substitution operators and freshness conditions in the metalanguage note that a substitution can occur only with a metalevel variable x in the form x the represents a substitution that is suspended to wait for instantiation of the metalevel variable x for instance term corresponds to the expression m zx that cannot be calculated any more in the metalanguage action of a substitution on a term m denoted by m is designed to reflect the behaviors of substitution operators and skip operators as alternatives of freshness conditions for instance the expression xm xz denotes the term as the expression xm zx is reduced to zx in the ordinary lambda calculus note that the substitution xz is suspended on the metalevel variable m since the substitution cannot act any more until m is instantiated later also the expression xm denotes which corresponds to the expression y shown in section the syntax enables us to advance computation in the presence of metalevel variables in the same way as the metalanguage for example the calculation shown in section is represented by the following reduction sequence in calculus where indices equal to are omitted in the last line reduction eliminates substitutions of form v · vn to simulate the interaction between substitution operators and freshness conditions if we instantiate the metalevel variables m in the last line with term yx we get the following intended result yx where the metalevel represents the instantiation of m note that the suspended substitution for variables y and x following the metalevel variable m in the first line is to obtain the result after the instantiation of m in the discussion thus far we illustrate a sketch of an extension of the lambda calculus added metalevel constructs in the same way we can easily add constructs constructs and so on as a result we obtain meta lambda calculus that includes infinitely hierarchical levels as meta lambda calculi in blocks to variable binding we make a remark about a connection between variable binding and metalevel application in calculus we have the following equality m m vn m vn m this equality states that variables vd occurring in the right part m of metalevel application mm are from being bound by outer binders of v as an example we take a term that roughly corresponds to a part of the c program with macros in figure we should consider that the variable y in the right part yx of the metalevel application is not bound by the leftmost binder y otherwise we could perform substitution for the y as follows yx yx such a reduction prevents a calculus from satisfying confluence since we also have the following reduction sequence that generates new bindings dynamically note that in the term after the metalevel reduction the variables y in the two copies yx are newly bound by one of the two binders y respectively this fact indicates that in the term before the metalevel reduction we should consider that the variable y in the right part yx of the metalevel application copied by instantiation is not bound yet by any binder stated differently in the c program with macros in figure the variable y in the fifth line the value of y determined by assignment in the third line whereas the variable y on the right of define command in the fourth line the text y itself which does not refer any value yet meta lambda calculus we formally define meta lambda calculus and show that the calculus satisfies confluence terms and substitutions we consider the set l of levels as the set of positive integers the is the metalevel is the is and so on we assume that we are given the set n of names and function lv of n into l that assigns a level to each name definition we define inductively the set ter of terms and the auxiliary set sub for each level as follows vd ter if v n d n vm ter if v n m ter m n ter if l m n ter id sub vm · sub if v n m ter sub v · sub if v n sub where n v n n is the set of nonnegative integers and id the empty sequence we define the set sub of is substitutions as a finite sequence for names v and terms m and are called notation as defined above · represent marks for substitutions we use the same dot to represent concatenation of substitutions for instance if substitution equals vm · v for name v and term m then · denotes vm · v · vm · v in particular id · · id holds we also use exponential notation namely id and n · n for substitutions and nonnegative integers n we omit following names and brackets id around the empty sequence when no confusion may occur example the following are terms where x y z are names of level and m n are names of level · x · · z we usually represent the term in the first line simply as xy z action of substitutions on terms definition let v be a name and d a nonnegative integer the v v d of a substitution is the term defined inductively as follows d · v d m if v w and d v d vw otherwise w · v d v d vw where vw is the integer defined by vw if v w otherwise we give an intuitive explanation about v of a substitution consider an n indexed family of infinite stacks of terms such a family of stacks is called an environment here vm and v represent operations on the stack indexed by name v hence substitution as a composition of represents an operation on environments in what follows the stack indexed by name v in an environment is simply called the the environment whose consists of the infinite sequence v v v for each name v is called the identity environment the v v d the element at depth d in the in the environment obtained by operating on the identity environment for instance consider a substitution vm · v · v substitution means the operation pop from the and then pop from the and then push the term m into the by operating on the identity environment we obtain an environment whose consists of the infinite sequence m v v and thus we have v m v v v v and so on definition let s be a subset of the set n of names the s of a substitution is the substitution defined inductively as follows ids id vm · s vm · s s if v s otherwise v · s v · s if v s s otherwise for levels and substitutions we define and by v n v n we abbreviate and to v and v respectively for names v definition we define inductively the term m resulting from action of a substitution on a term m and the substitution resulting from composition of substitutions and as follows vd vd if v id v d v otherwise vm vm v m n m n id vm · vm v · v · v · where v denotes · v the first branch in the first line for action on a variable of name v states that substitution does nothing and as the suspended substitution on the variable if the does not contain any of level the second branch states that substitution replaces the variable vd with the corresponding term v d and the suspended substitution composed with further acts on the term the restriction represented by indicates that all of level in are consumed by substitution for the variable vd the expression v in the second line represents a substitution obtained by to skip the binder v appropriately the restriction represented by in the third line and the fifth line is due to blocks to variable binding discussed in section note that vd v d v always holds by definition we show that m and are welldefined for all terms m and all substitutions and by induction on height of terms and level of substitutions defined below definition the height of a term m and the height ht of a substitution are the nonnegative integers defined inductively as follows ht n · ht · ht definition the level lv of a substitution is the nonnegative integer defined inductively as follows · lv if m for some d n lv otherwise · lv proposition let m be a term and be a substitution then m is welldefined proof we give a detailed proof for this proposition to the mechanism of the calculus many other propositions in this section are proved in a similar way the above proposition is proved by induction on ordering of pairs lv consider the case of m vd first we show that is welldefined by induction on length of the case of id and the case of w · are trivial consider the case of wn · then wn w · note that n w is welldefined by induction hypothesis since lv and thus is welldefined next we show that v d v is welldefined if lv then by induction hypothesis v d v is welldefined since lv v lv if lv then v d ve for some e n and hence v d v ve v by definition consider the case of m vm we show that v is welldefined and lv v lv by induction on length of the case of id and the case of w · are trivial consider the case of wn · then v wn vw · v we prove below that n vw is welldefined if lv then n vw is welldefined by induction hypothesis since if lv then n we for some e n and thus n vw note that n we for some e n if and only if n vw wc for some c n thus we have lv v lv consequently m vm v is welldefined by induction hypothesis since v vv · v is welldefined and we have lv and the case of m m m is trivial corollary let and be substitutions then is welldefined reductions on terms definition let be a binary relation on the set ter of terms we say that is a reduction relation if satisfies the following conditions vd · · vd · · if m m vm vm if m m m n m n if m m n m n m if m m we define reduction as the least reduction relation satisfying the following expression vm n m vn if we also define renaming and reduction as the least reduction relations satisfying the following expressions vm vw · w if and vm v v m if respectively notation let and be binary relations on a set the composition of binary relations and is denoted by · the transitive closure of is denoted by remark a term is said to be if all indices in the term equal and all substitutions in the term equal id consider the set of terms consisting only of constructs of level then the set is just the set of terms in the ordinary lambda calculus under the assumption that we have infinitely many names of level in the set n of names furthermore reduction renaming and reduction on the set coincide with the counterparts in the ordinary lambda calculus as a result the formalization of calculus provides us another definition of the ordinary lambda calculus in which reduction is defined without the notion of free variables and renaming equivalence on terms the reduction defined in definition is not strictly confluent consider a term m z y with names x y z of level and name n of level we can obtain two distinct normal forms from m as follows m · xy and m · xy · y · yz the two substitutions yz · xy and yz · xy · y · yz in the above are obviously distinct sequences of however and have the same v for all names v and nonnegative integers d we introduce an equivalence relation to such two substitutions the equivalence relation leads the reduction to be confluent definition we define equivalence relations t on the set ter of terms and s on the set sub of substitutions inductively as follows id s id s if v d t v d for any v n d n vd t vd if s vm t vn if m t n m m t n n if m t n and m t n the symbols t and s are written simply as by the subscripts when no confusion may occur we give another possible formalization of the equivalence on terms to illustrate the connection between equivalent terms more concretely by providing canonical form of substitutions definition we define reduction on terms as the least reduction relation satisfying the following three expressions vd · w · · vd · vd · · we vd · we and vd · · · vd · · · for any w and un u with w u definition for each term m we define m as the number of in m namely the number of and occurring in m a term m is said to be canonical if m m holds for any term m satisfying m m a substitution is also said to be canonical if vd is a canonical term for some name v and nonnegative integer d remark a substitution is canonical if and only if for each name v we have v · · · · · · · for some nonnegative integers pv qv and canonical terms mv mv such that if pv and qv suppose that the above equality hold then we have v d qv if d pv otherwise for each nonnegative integer d proposition let m and n be terms then m n holds if and only if m · n holds proof it is straightforward that m n implies m n we show that m n implies m · n we have canonical terms mc and nc such that m mc and n nc note that m n implies mc nc we can prove that if mc nc then mc nc by straightforward induction on theorem the following properties hold m m if m m and if and id id m id m m m for terms m m and substitutions in short action of substitutions on terms and composition of substitutions preserve equivalence and the set sub of substitutions amounts to a monoid on the set ter of terms up to equivalence we prove the above properties in what follows proposition let m be a term then m id m holds proof we prove the stronger proposition that m m holds for any term m and any substitution satisfying the following condition for any name v there exists a nonnegative integer p such that v vv · vv · · · · · · vp the stronger proposition is proved by straightforward induction on lemma let and be substitutions v a name d a nonnegative integer then v d v d v holds proof by straightforward induction on length of proposition let m and m be terms and substitutions if m m and then m m holds proof the proposition is proved by induction on the ordering of pairs lv as in the proof of proposition corollary let and be substitutions such that and then holds proposition let m be a term and substitutions then m m holds proof the proposition is proved by induction on ordering of pairs lv lv consider the case of m vd we can prove that by induction hypothesis and by the fact that for each level we show below that vd vd suppose that lv then vd v d v v d v v d v v v d v v v d v vd by induction hypothesis and by the fact that v v v suppose that lv then v d ve holds for some e n we have vd ve v v e v v v e v v d v vd consider the case of m vm we show that v v v suppose that lv then v v w d w d vw v w w d v v w w d vw w d w vw vw d by induction hypothesis suppose that lv then w d we holds for some e n we have v v w d w d vw v w we vw v w v w vw e w e vw we w vw w d w vw vw d therefore we have m vm vv vm v v vm vv v v · v v vm vv · v vm v m by induction hypothesis the case of m m m is trivial corollary let and be substitutions then we have confluence of reductions we prove that reduction is confluent up to equivalence by the technique of parallel reduction in other words we prove confluence of reduction definition we define auxiliary binary relations t on the set ter of terms and s on the set sub of substitutions inductively as follows vm n t m vn if m t m n t n vd t vd if s vm t vm if m t m m m t m m if m t m m t m id s id vm · s vm · if m t m s v · s v · if s note that we have t the symbols t and s are written simply as by the subscripts when no confusion may occur lemma let m and m be terms and substitutions if m · m and · then m · m holds proof by straightforward induction on the ordering of pairs lv lemma let m and n be terms if m · n holds then we have m · n proof we can prove the following proposition by straightforward induction on if m l n for some term l then there exists a term l such that m l n definition for each term m and each substitution we define term m and substitution inductively as follows vd vd vm vm m n l vn m n id id vm · vm · v · v · if m vl otherwise lemma let m and n be terms such that m n then n · m holds proof by straightforward induction on theorem let m and n be terms if m · · n then m · · n holds proof by lemma and lemma we can easily prove that m · · n implies m · · n for any terms m and n by this proposition and lemma the above theorem is proved corollary let m and n be terms and be the union of reduction relations and if m · n then we have m · n an application calculus provides us a way to manipulate binding structure with dynamic binding via metalevel variables we illustrate the feature through an application of the calculus to a procedural language procedural language proc we introduce a simple procedural language proc as an extension of imperative language imp in proc permits us to store and not only numbers but also procedures we implement proc in by exploiting the feature to manipulate binding structure dynamically the implementation of proc demonstrates that some notions related to names in procedural languages such as stores recursion and of names can be realized by dynamic binding via metalevel variables definition we define the syntax of proc by the following e x n plus e e e e f z proc p commands c x e z f exec f if e p p while e p local p export x x z z procedures p id c p where n h k range over the set n of nonnegative integers x x x range over a set nn of names for numbers z z z range over a set np of names for procedures and id the empty sequence the sets nn and np are disjoint we define p as the set of all procedures note that a procedure p is a finite sequence of commands we represent concatenation of procedures p and p as p p definition a pair n p of a function n of nn into n and a function p of np into p is called a state of stores we define s as the set of all states of stores and call an element of the set s simply a state let n p be a state then the value e of e in state is the nonnegative integer defined inductively as follows x nx n n plus e e e e e e e similarly the value f of f in state is the procedure defined as follows z pz proc p p definition let n p be a state for nonnegative integers n and names x in nn state nx is defined as follows nx n p where n x n if x x nx otherwise for names x in nn similarly state pz is defined for proce p and names z in np as follows pz n p where p z p if z z pz otherwise for names z in np definition for procedures p p and states we define transition relation p p as follows x e p p ex z f p p f z exec f p f p if e p p p p p if e if e p p p p p if e while e p p if e p while e p and if p id for some state then local p export x z p p with xx · · · · · · implementation of proc in in the subsequent discussion we assume that the set nn of names for numbers and the set np of names for procedures are disjoint finite sets x¯ x¯ and respectively for some nonnegative integers a and b note that we can adopt such assumption when computing a procedure in proc since every procedure contains only finitely many names furthermore we assume that the set of names of level in calculus contains all names in proc notation in this section applications of each level are and the body of an abstraction extends as far right as possible in a way letters are names of level and letters are names of level we omit marks for applications of level for instance m n mm x y m n definition to e f commands c and procedures p in proc we assign terms e f c and p in calculus respectively as follows x x zero n scc n plus e e plus e e e e e e z z proc p block p x e set x e z f set z f exec f f if e p p if e p p while e p while e p local p export x xk z local x z p id id c p comp c p where zero fst snd scc snd snd plus m block y if p k while fix e loop id fix x x xf x x loop comp p w e p local x z x z kx kp export x z kr x · · · r id kk comp q k definition for each state in proc we define as the substitution n · p in calculus where n and p are the substitutions defined as follows n x¯ x¯ · · · · · p · · · · · we also define a relation for substitutions and as follows if and only if v v for each name v s · is denoted by with the above setting a transition sequence in proc is simulated by the corresponding reduction sequence in calculus as stated in the following propositions proposition let p be a procedure and states and a substitution if p id and hold then there exists a substitution such that p id and proof by straightforward induction on size of transition sequence p id corollary let p and p be procedures and states and a substitution if p p and hold then there exists a substitution such that p p and remark stated differently we have the following as an alternative to proposition let p be a procedure and states and a substitution if p id and hold then we have comp kk p kk for some substitution such that example let p be the following procedure in proc that corresponds to the ruby program in figure sum proc n ar ct plus ct if n local ar n exec sum export rv ct rv n rv rv ct local ar exec sum export rv ct then p is reduced to the following term in normal form p · ct · rv · where and are the church of and respectively and m is the term that corresponds to the procedure assigned to name sum figure def ct ct if n n else end end ct sum figure p print figure p print p recursion via names and textual substitution in proc we can write recursive procedures in the usual manner this feature from the fact that we can store and procedures via names and the feature is implemented with terms block and in calculus actually the terms block and behave as and eval command in programming languages for example consider the following term l that corresponds to the ruby program in figure l p then we have the following infinite reduction sequence that corresponds to the infinite loop caused by the program in figure l m nm · · · where m is the term defined as follows m p n block p note that the terms block and play fundamental roles to generate the infinite reduction sequence in fact if we remove the applications of the terms block and in term l then we get the term which corresponds to the ruby program in figure that causes no infinite loops from viewpoint of variable binding are considered as blocks to variable binding discussed in section and eval command blocks to variable binding the terms block and behave in the same way a comment from viewpoint of type systems to make a brief comment about properties of calculus we introduce a type system similar to the simple type system for the lambda calculus definition we assume that we are given a set of atomic types the set typ of types is defined inductively as follows t typ if t is an atomic type t t typ if is a level and t t typ definition a function of n into typ is called a type assignment for type assignments terms m substitutions and types t we define typing relations m t and inductively as follows vd v if vm v t if and m t m m t if m t t and m t id vm · if m v and v · if with the type system defined above we can have subject reduction property stated by the following proposition proposition let be a type assignment t a type m and m terms if m t and m m then m t holds however the type system does not provide us strong normalization property in contrast to the type system for calculus m for example consider a type assignment x satisfying the following conditions xn b b xp block b xx b b xy b xz block b where b is a type and block b b b b then the following expressions hold x block b block b x block b b x l b where l is the term defined in section the term l has type b and thus we may expect that the term l a value of type b however the term l actually has no normal form and hence nothing as in the case of the in order to eliminate such situations and achieve strong normalization property we need a more elaborate type system in fact the type system permits term l nl to have type b b b in the type assignment x whereas l is a fixedpoint operator of level in a sense that we have lm m lm for any term m a key difference from cal m providing strong normalization property is caused by the existence of terms that bring on reduction such as reduction generating new meta level redexes a term is said to be if the term can be typed only in type assignments a type assignment is said to be if there exists a name v such that the type v of v in the type assignment contains an arrow of level greater than for instance the above x is a cross level type assignment and the terms block and export x z are terms as well as the term l mentioned above cross level type assignments and terms are mean hence terms have been left out of consideration by type systems or by reductions in previous meta lambda calculi however we consider that terms may be worth since terms seem to have con with notions related to names and bindings in program ming languages such as stores recursion and of names as demonstrated in this section we leave further research about this topic as a future work related works meta lambda calculi we discuss connections with previous meta lambda calculi that include inherently textual substitution via metalevel variables calculus m proposed by and is a meta lambda calculus with infinitely hierarchical levels m reductions and a type system to achieve properties in with textual substitution the type system eliminates terms mentioned in section m is actually a subsystem of consisting only of terms the reduction in m is viewed as a restriction of reduction in on a set of terms calculus in and also includes infinitely hierarchical levels reductions and explicit substitutions unlike other meta lambda calculi does not have the notion of level of application in other words the level of each application occurring in a term is determined dynamically in the process of computation one of the features of different from is that substitutions in have canonical representation by this feature terms the same substitution for example and are reduced to the same term · yz by reduction and reduction in in the above two terms are reduced to distinct two terms in normal form new calculus of contexts and twolevel lambda calculus adopt reductions and freshness contexts a freshness context is regarded as an assumption about freshness conditions for metalevel variables reductions are controlled by freshness contexts in a word a term is reduced under some assumption about freshness conditions for metalevel variables the new calculus and mentioned above include new binders n separately from ordinary lambda binders a new binder indicates that an variable is fresh for metalevel variables for instance holds since the variables x and y in the above terms are considered to be fresh for metalevel variable m in calculus such information is represented by the above two terms and the renaming are represented in as calculus is a study of categorical semantics for metavariables the type system in the calculus eliminates terms mentioned in section the formalization shown in and and in and assumption about free variables for metalevel variables in order to perform renaming in the presence of metalevel variables the notion of blocks to variable binding discussed in section is pointed out in other works attempts to model textual substitution via metavariables in a calculus are from and typed context calculus which is designed to the notion of lambda contexts their calculus reductions and a mechanism called to binding structure consistently with the notion of holes to represent lambda contexts holes are regarded as metalevel variables and lambda contexts are regarded as metalevel abstractions from viewpoint of meta lambda calculi the technique of is considered a kind of approaches by interfaces assigned to metalevel variables mentioned in section and simply typed context calculus calculus m in et al and calculi with modal types and and with modal types are also designed by approaches of interfaces assigned to metavariables these calculi are called lambda calculi with interfaces from meta lambda calculi in this paper the goal of these calculi to provide type systems for metalevel variables seems to lead the design to use information about interfaces assigned to metalevel variables not only in type systems but also in rewriting systems this feature of the design makes the difference between these calculi and meta lambda calculi as illustrated in section the technique of indexed variables is adopted in the syntax of calculus m in is similar to the syntax of in a sense that variables and applications are assigned with numbers the numbers in calculus levels of variables which determine strength of substitution so that substitution of level is performed by regarding variables of level less than as in contrast the numbers in calculus m stages of computation which determine time of substitution in m all variables occurring in a term are bound statically as usual unlike meta lambda calculi methods to deal with substitutions as syntactic objects date back to abadi cardelli curien and explicit substitutions and applies the method to the lambda calculus with metalevel variables the formalization of substitutions with and in is almost the same as their formalization although substitutions in are sorted by names and defined to occur only as suspended substitutions on metalevel variables the slight difference from their formalization from the purpose to make calculus become a of m as well as the ordinary lambda calculus in other words this paper does not concern itself about modeling concrete way and cost of performing substitution which is the original purpose of explicit substitutions in abadi et al calculus n proposed by is an extension of the lambda calculus to model dynamic binding the syntax of n includes additional constructs called labels separately from ordinary variables a main difference between n and is their style of dynamic binding calculus deals with dynamic binding by lambda binders via metalevel variables whereas n deals with dynamic binding by labels not by lambda binders conclusion we have proposed meta lambda calculus in which any redex of any level can be reduced to perform substitution for variables this feature makes it possible to advance computation even in the presence of metalevel variables and hence provides us new possibilities for reduction strategies that have been restricted by reductions in previous meta lambda calculi also we have shown a procedural language as an application of calculus through the implementation of the procedural language we have observed the connections between dynamic binding via metalevel variables and the notions of stores and recursion in procedural languages we hope that calculus toward understanding metavariables and the association with notions related to names and bindings in programming languages acknowledgments the author to thank his for the discussions the author also thanks and anonymous reviewers for helpful comments references m abadi l cardelli pl curien and jj explicit substitutions journal of functional programming ­ monads and calculus in new frontiers in artificial intelligence ­ and representing by delimited continuations in new frontiers in artificial intelligence ­ and contextual type theory in proceedings of the th international workshop on logical frameworks and theory and practice ­ n g de bruijn lambda calculus notation with a tool for automatic formula manipulation with application to the churchrosser theorem ­ a lambdacalculus for dynamic binding theoretical computer science ­ a approach to bindingtime analysis in proceedings of the th annual ieee symposium on logic in computer science lics ­ and higher order unification via explicit substitutions information and computation ­ j a new calculus of contexts in proceedings of the th acm sigplan international conference on principles and practice of declarative programming ­ j and the calculus extended version information and computation ­ j and p twolevel lambdacalculus electronic notes in theoretical computer science ­ and a typed context calculus theoretical computer science ­ and categorical semantics of calculus in in informal proceedings of the th workshop on programming and programming languages ­ and frank pfenning a modal foundation for metavariables in proceedings of the acm sigplan workshop on mechanized reasoning about languages with variable binding ­ frank pfenning and contextual modal type theory acm transactions on computational logic article pages and a simply typed context calculus with firstclass environments journal of functional and logic programming ­ and calculi of metavariables in computer science logic csl lncs ­ and calculi of metavariables frontiers of computer science in ­ parallel reductions in calculus information and computation ­ the formal semantics of programming languages the mit press 