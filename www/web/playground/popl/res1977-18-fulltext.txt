structuring university cr of abstract structuring can be defined of what ia being structured and can be applied to more than one domain using one mechanism to structure both values and we obtain for a variety of data and control structures structuring assignments ia to structuring control the former is more to a mathematical style of programming while the latter ia more to tracing key and phrases language design data structures control recursion cr category introduction programming have a variety of data structures and control structures that are intended to be convenient for programming for example provides character a structure of character and the structure known in some aa a record for structuring data and if state ments definite or indexed iteration in definite iteration the while loop and of course the go to for structuring control in each case it is quite clear whether the construct is a data structure or a control structure two assumptions are implicit that a variety of structures us better than one and that structures are appropriate for data or for control but not for both this paper questions these two it suggests that a structuring mechanism defined independently of what is being structured can provide the good things we now while keeping the number of basic language constructs to a minimum we first exhibit one such mechanism then its the structure to begin with we shall give ourselves come simple the two logical values true and false numeric values such as and e character values such as a and a facility for defining new simple values such as red blue and as in whether these values are not be it is a con choice for the moment character strings are not considered simple and are not included in the logical forming above we give ourselves numeric and comparison expressions a operators for of next we give ourselves a simple assignment identifier expression note that element important the left side may not be an array declaration of though is irrelevant at present finally we give ourselves a naming notation for values and assignments for example pi means that for and pi it will i i stand means that increment appears it will for the assignment i to increment from a conventional label we emphasize that the above statement does not in i but only gives a name to the act of i our structure is simply a set of ordered pairs the first member of each pair is called an index the second an element of the structure indices are it may seem appropriate to restrict the indices of a given structure to one type or to a of a type but such restrictions are irrelevant to this paper an expression of an index may include variables although our examples will use only constants the elements of a structure constitute that which is being structured we shall consider structured and structured assignments structured values define are values a map as a structure whose elements for example the map m d has indices a map expressions elements and and elements is itself a value and can be in assignments or as indices it may be given a name by the and used in or same notation used to give a simple value a if m is or a map and i is or denotes an index of m then mi denotes an of m corresponding to index i if this element ia to be unique the indices must be unique other operations on maps may be defined as necessary for example if m is a map and i and e are values then the expression m with iw denotes a map like m except that mi e certain special cases of special notations when the indices are the integers to n the notation may be abbreviated by listing only the elements in order of index in brackets the map of the previous may be expressed as this gives us a kind of array if the elements are characters eg a b c we may abbreviate further eg abc this gives us character strings the equivalent of records or structures are formed not as an but simply by using suitable programmer defined values as indices name address cl cl it is convenient to group indices equal elements so that that have for three pairs in this connection and for arrays the abbreviation to m can stand for n nl m whenever and m denote appropriate values n n by introducing a name for the index we can express a group of elements in terms of their indices by specifying a range for the index ie a domain for the map we obtain either redundancy that is useful for checking that all indices are present or the ability to specify a restricted else for example i c to r i else ia a array containing and zero elements the tion to maps with more than one index dimensional is straightforward nonzero in some cases a may represent a map as a sequence of pair of values in other cases only the elements need storage in still other maps may be compiled into code for comput ing values from indices as an example in which the is suitable consider the following re definition of limited factorial mm n s o d the reader may at this point feel in notation but he should not feel in concepts or language pro will have different data structuring requirements and different notations and that seem convenient for their purposes no programming language can hope to provide all such nor should it attempt to instead it should provide a general structure and a mechanism for it to an needs and for making convenient abbreviations this paper not discuss such mechanisms it that the map can easily be specialized to provide a variety of programmers needs while maintaining an of concepts within the pro gramming language it also suggests certain that seem needed often enough to special notations within the language structured define a group as a structure are assignments for example x y zd whose a group is an assignment it is executed by executing its elements in the order they are written this may be a slight of the term assignment it is used here to mean a notation for associating some with some values rather than exactly one variable with one value a group may be given a name by the same notation used to give a simple assignment a name if g is or denotes a group and i is or de notes an index of g then gi denotes an element of g corresponding to index once again if the element is to be unique the indices must be unique without this restriction we can build guarded command sets by using logical expressions as indices thus one builds a group and selects elements from it the same way one builds and selects elements from a map most of the same tion are relevant when the indices are the integers to n or when we are in the elements may simply be listed giving us the usual do group for example the group of the previous may be ex as do z y z c the alternative of executing elements in order of increasing index was considered but rejected for two reasons we did not want to restrict the indices to be of an ordered struct for this alternative type the for more complicated one alternative remains in contention that groups should not be executed a separate tic construct ia then required for sequencing if g is a group then gi is case statement either the algol w kind or the pascal kind for which a more familiar notation a is case i of g as a further specialization we introduce the no tation d to abbreviate a group whose indices are true and false from which we are selecting one he elements for example if b then else x y d group true x cl b similarly if then d the special the false alternative is null the else which was so useful in the previous section for specifying sparse arrays has an analogous role in groups used as case statements by introducing a name for the index and group ing indices tion we have a for construct the s s i rj merely which in turn s ss the generalization to more than one index which in the previous section gave us dimensional arrays here gives us the effect of nested constructs but written as a simple construct notice that the indices are not variables so no question of assignment involving indices within the construct is raised finally the notation may be used to abbreviate group for example while do cl a i do a group say g defined as then i i go who consider iteration recursion may at this point next section is intended of those people to cc be simpler than be the change the viewpoint understanding structured assignments when we read or write programs we have always maintained a program counter or instruction pointer we are always aware of the flow of control for example at the end of a loop we know that control or ex goes back to the beginning of the loop we have no problem execution continues understanding the to at the indicated statement understanding programs containing go is another matter recursive flow of control in general in a stack of return and so it is more complicated than looping in current pro gramming languages it ia further complicated by making it from procedures which in a new local scope each invocation in this paper recursion was introduced independently of local scope even so defining a while loop by way of recursion may seem to be defining something simple by way of something complex a program should not be understood in terms of a particular implementation of a language nor by tracing an execution of the program these two premises are generally well accepted and need no in this paper yet in almost every programming text control structures are ex only by how to trace an tion according to some implementation selection if or case ia usually explained by saying that jumps to one of the alternatives and from there to the end of the construct in this paper the notation gi is to denote an element of g apart from the subtle change in the use of the word jump may sometimes be for example with the constant definition devices the structured assignment if devices c then a else b el can be compiled simply as a giving conditional compilation without any new language feature the for construct as an abbreviation for a sequence rather than aa a loop the important point is not the change in terminology but the change in from control to structured assignments one could never ment a s to as a structured assign an explanation of recursion that involves activation records or return stacks is irrelevant and wrong the best implementation of the recursive group in the previous section is exactly the same as the im of the while construct that it the proper explanation of a recursive construct the principle or of a while construct in of mathematical induction it is sometimes that an average person cannot be expected to understand the of induction or to apply it to programming if that were true it would not be an argument against the use of induction in programming but against the use of average people as programmers in fact average people understand the principle well although informally given a positive integer and enough time an average person he can count from to the given integer for large enough integers that be is not based on the experience of having done so but on an implicit understanding of the principle of induction it is often easy to see that a recursive construct works for n o and that if it works it will work for n k the common is or how it works for n k this is made for one of two reasons a failure to assume the in hypothesis induction requires that we prove an implication not the hypothesis of the implication b about the tion an explanation of the should come only after the semantics are understood not as an explanation of the semantics for either reason this leads to an effort to understand by tracing and to the induction if it works for n and then good enough for me mathematical semantics refers to the characterization of programming language state ments by their effect on program state the mapping from variables to values it has developed as a technique for defining programming languages in this view the time sequence of events that occur during program execution is irrelevant a statement is a mathematical function from states to states unfortunately may of the statements it has been used to characterize were designed to control tion by structuring assignments rather than control we are taking the view that is con with mathematical semantics exits the while loop considered as a construct denoting execution has one exit its head and that exit is only a single level exit that cannot be used to terminate execution of several nested loops at once intermediate and deep have been proposed in various forms for arguments pro and con see suppose al is defined as at al while bl do a a cl and action assignment defined as a within al is a b do a if b then af exit al cl where the notation exit al means that we jump to the statement following al the benefit of this construct is efficiency with only exits one needs to perform a test within al prior to a to determine whether to execute a and continue al or to exit al the problem with this construct is a loss of clarity an tion of al would lead one to conclude that a and a are executed repeatedly until bl becomes false as structured structured control able the equivalent as follows assignments rather than loops and exits are recursive definitions are al bl then a cl else a al o the may be implemented by simply branch ing to the appropriate label we thus have the efficiency of the deep exit without a new language feature and the condition under which a is executed is clear at a the has the property that when there is more to be says when there is no more to be done one says something exit the recursive version is more straight forward when there ia more to be done one specifies it and when there is not one says nothing uniform when programming if one that one needs to select a value from a class of values one can use the notation fx where f denotes the and x ie used to select the desired element of f one may then decide to implement f either as a map or if one needs to intro local names and variables and to use assign ments in the production of the desired value as a function procedure that returns a value and does not affect global variables the notation fz must not the choice of tation of f a change in the implementation of f that does not change the meaning of the program such as substituting a map for a function or vice versa should not require changing the notations involving f throughout the program the above principle of language design is a version of the principle of uniform we now have a new application principle if one that one needs to select an action assignment from a class of actions one can give the class a name say g and denote selecting the desired action by gx this notation should allow g to be implemented either as a group giving us a case statement implementation or routine procedure that affects value global variables and does not return a conclusion the point of this paper is not the tions used to present the structuring mechanism when the reader finds them or un he is to change them nor is the point the particular structuring mechanism chosen it is not that the mechanism in this paper is adequate or suitable for all purposes there are two points one is that structuring can be defined independently of what is being structured and can then be applied to more than one domain a well general structure that can be specialized in a variety of ways is to the of structures we now live with the other main point is that structuring assignments is to structuring control the former is more to a mathematical style of program composition while the latter is more to tracing arguments in of structuring value than storage have been presented elsewhere i am to and for discussion and suggestions that lead to this paper references dijkstra ew a discipline prenticehall of programming and parameters a simple view of variables to appear hoare car an axiomatic basis for computer programming comm acm october car recursive data structures report stanford university rb programming without pointer variables acm conference on data march knuth de structured programming with to statements acm computing hf m a control structures comm acm november of dt uniform an essential property for a software engineering language in cd software engineering academic press scott d and c towards a mathematical semantics for computer languages j cd computers and automata john pp 