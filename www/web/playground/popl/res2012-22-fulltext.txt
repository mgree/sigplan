in the grey area of proofs university of tu university of abstract interpolation is an important technique in verification and static analysis of programs in particular interpolants extracted from proofs of various properties are used in invariant generation and bounded model checking a number of recent papers studies interpolation in various theories and also extraction of smaller interpolants from proofs in particular there are several algorithms for extracting of interpolants from socalled local proofs the main contribution of this paper is a technique of interpolants based on transformations of what we call the grey area of local proofs another contribution is a technique of transforming under certain common conditions arbitrary proofs into local ones unlike many other interpolation techniques our technique is very general and applies to arbitrary theories our approach is implemented in the theorem prover and evaluated on a large number of benchmarks coming from firstorder theorem proving and bounded model checking using logic with equality uninterpreted functions and linear integer arithmetic our experiments demonstrate the power of the new techniques for example it is not that our proof transformation gives more than a reduction in the size of interpolants categories and subject descriptors d software engineering formal methods f logic and meanings of programs assertions i artificial intelligence deduction inference resolution general terms theory verification keywords program verification theorem proving interpolation introduction interpolants extracted from proofs have several applications in verification and static analysis see eg although interpolants are guaranteed to exist in some theories for example those having quantifier elimination interpolants extracted from proofs turn out to be smaller and more useful than those obtained by general interpolation algorithms see eg for this reason recent papers consider the problem of obtaining small interpolants for various theories in this paper we consider two related problems extracting interpolants from proofs and such interpolants papers define algorithms for extracting interpolants from socalled permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm local proofs roughly in local proofs some symbols are colored in the red or blue and others are symbols are said to be grey a local proof cannot contain an inference that uses both red and blue symbols in other words cannot be mixed within the same inference however building local proofs may require substantial changes to a firstorder theorem prover or an smt solver in addition local proofs do not necessarily exist one of the contributions of this paper is a technique for changing proofs into local ones under some conditions the ideas of this technique can be traced to an observation made in that existential quantification of constants results in an interpolant we prove a simple result showing that this technique is correct and can be applied to translate nonlocal proofs with colored constants into local proofs when we already have a local proof one can extract an interpolant from it this interpolant is a boolean combination of some formulas occurring in the proof if one uses the algorithm of more exactly the interpolant is obtained as a boolean combination of conclusions of some an inference having at least one colored premise and a grey conclusion the interpolation extraction theorem of is not restricted to any particular theory essentially the only condition on proofs is inference soundness that is the conclusion of any inference is a logical consequence of its premises this generality gives one a lot of freedom since one does not have to follow rules of any specific calculus such as resolution and in building local proofs in this paper we exploit the generality of by considering proof transformations that preserve both inference soundness and locality it is interesting that such transformations can change the shape and the size of the extracted interpolant the transformations we consider are always applied to grey formulas in the proof which inspired the title of this paper while the class transformations we consider off a grey formula obviously preserve inference soundness they can violate locality to preserve locality we create a sat problem whose solutions encode all local proofs obtained by a sequence of further we create a linear expression over the variables of the sat problem that expresses some numeric characteristics of the interpolant for example the number of different atoms in it thus we are interested in the solutions of the problem that the linear expression any such solution can be used to build a proof giving a smaller in some sense interpolant these solutions can be found using an smt solver or a optimisation tool the main contributions of our paper are below we present a new method of producing smaller interpolants from local proofs the methods is based on transformation of the grey area of proofs it uses the idea that proof locality can be expressed by a set of propositional formulas whose models represent all local proofs obtained by such transformations sections we present a method for changing proofs into local ones this method is applicable to all proofs in which all colored symbols are uninterpreted constants section we define a transformation of interpolant problems into the problem of solving constraints section is defined with respect to various measures of the size of interpolants we implemented our algorithm in the theorem prover it uses the smt solver for solving constraints section as cannot yet efficiently handle the combination of various theories we generate proofs over smt problems using z we show that our method improves by generating considerably interpolants in the size the total weight and the number of quantifiers section the rest of this paper is structured as follows section relevant definitions and properties of firstorder logic and interpolation in section the notion of colored and local proofs are introduced our result on translating nonlocal proofs into local ones is formulated in section section details our approach to interpolants we present experimental results in section and overview related work in section section concludes the paper interpolation we consider the standard firstorder predicate logic with equality we allow all standard boolean connectives and quantifiers in the language we assume that the language contains the logical constants for always true and for always false formulas throughout this paper we denote formulas by a b c d g r terms by r s t variables by x y z constants by a b c and function symbols by f g possibly with indices let a be a formula with free variables x¯ then a respectively a denotes the formula respectively a formula is called closed or a sentence if it has no free variables we call a symbol a predicate symbol a function symbol or a constant thus variables are not symbols we consider equality part of the language that is equality is not a symbol a formula or a term is called ground if it has no occurrences of variables a formula is called universal respectively existential if it has the form respectively where a is quantifierfree we write c cn c to denote that the formula c cn c is a note that c cn c may contain free variables a signature is any finite set of symbols the signature of a formula a is the set of all symbols occurring in this formula for example the signature of b gz is g b the language of a formula a denoted by la is the set of all formulas built from the symbols occurring in a that is formulas whose signatures are subsets of the signature of a we recall the following theorem from theorem interpolation theorem let a b be closed formulas and let a b then there exists a closed formula i la lb such that a i and i b in other words every symbol occurring in i also occurs in both a and b every formula i satisfying this theorem will be called an interpolant of a and b we call a theory any set of closed formulas if t is a theory we write c cn t c to denote that the formula c c c holds in all models of t in fact our notion of theory corresponds to the notion of theory in logic when we work with a theory t we call symbols occurring in t interpreted while all other symbols uninterpreted as proved in interpolation also holds for theories in the following sense theorem let a b be formulas and let a t b then there exists a formula i such that a t i and i b every uninterpreted symbol of i occurs both in a and b every interpreted symbol of i occurs in b likewise there exists a formula i such that a i and i t b every uninterpreted symbol of i occurs both in a and b every interpreted symbol of i occurs in a the proof of this theorem in uses which is guaranteed when t is in the sequel we will sometimes be interested in the interpolation property with respect to a given theory t we will use t instead of and all definitions to t to be precise we call an interpolant of a and b any formula i such that a t i i t b and every uninterpreted symbol of i occurs both in a and b if e is a set of expressions for example formulas and constants c cn do not occur in e then we say that c cn are fresh for e we will less formally simply say fresh constants when e is the set of all expressions considered in the current context we call a reverse interpolant of a and b any formula i such that a t i i b t and every uninterpreted symbol of i occurs both in a and b reverse interpolants for a and b are exactly interpolants of a and ¬b moreover when b is closed reverse interpolants are exactly interpolants in the sense of reverse interpolants are convenient when we use a inference system such as resolution for finding a proof of a b that can give us an interpolant in this case one can search for a from the set of formulas a ¬b instead local proofs in this section we recall some terminology related to inference systems inference systems are commonly used in the theory of resolution and however we do not restrict ourselves to the calculus the material of this section is based on the terminology of to our setting we also introduce the notion of local proofs and recall results on extracting interpolants from local proofs as proved in definition an inference rule is an nary relation on formulas where n the elements of such a relation are called and usually written as a an a the formulas a an are called the premises of this inference whereas the formula a is the conclusion of the inference an inference system i is a set of inference rules an axiom of an inference system is any conclusion of an inference with premises any with premises and a conclusion a will be written without the bar line simply as a a derivation in an inference system i is a tree built from in i if the root of this derivation is a then we say it is a derivation of a a derivation of a is called a proof of a if it is finite and all leaves in the derivation are axioms a formula a is called provable in i if it has a proof we say that a derivation of a is from assumptions a am if the derivation is finite and every leaf in it is either an axiom or one of the formulas a am a formula a is said to be derivable from assumptions a am if there exists a derivation of a from a am a is a derivation of note that a proof is a derivation from the empty set of assumptions any derivation from a set of assumptions s can be considered as a derivation from any larger set of assumptions s s let us now fix two r red and b blue in the sequel we assume r and b to be fixed and give all definitions relative to r and b denote by l the intersection of the languages of r and b that is the set lr lb we call signature symbols occurring both in r and b grey symbols occurring only in r red and symbols occurring only in b blue a symbol that is either red or blue is also called colored for a formula c we say that c is grey if c l otherwise we say that c is colored in other words grey formulas contain only grey symbols and every colored formula contains at least one red or blue symbol a colored formula that only contains red and grey symbols is called a red formula similarly a blue formula is a colored formula containing only blue and grey symbols in the rest of this paper red formulas will be denoted by r blue formulas by b and grey formulas by g possibly with indices definition let us call an any derivation satisfying the following conditions rb for every leaf c of one of the following conditions holds r t c and c lr or b t c and c lb rb for every inference c cn c of we have c cn t c we will refer to property rb as soundness we will be interested in finding reverse interpolants of r and b the case lr lb is obvious since in this case r is a reverse interpolant of r and b likewise if lb lr then ¬b is a reverse interpolant of r and b for this reason in the sequel we assume that lr lb and lb lr that is both r and b contain at least one colored symbol we are mostly interested in a special kind of derivation intro in and called local or sometimes called the definition of a local derivation is relative to formulas r and b definition local an inference c cn c in an is called local if the following two conditions hold l either c cn c lr or c cn c lb l if all of the formulas c cn are grey then c is grey too a derivation is called local if so is every inference of this derivation in other words l says that cannot mix no inference contains both red and blue symbols condition l is natural should not introduce irrelevant symbols but it is absent in other works condition l is however essential for us since without it the proof of theorem does not go through note that standard derivations produced by theorem provers often contain l especially in instantiation rules ar where r is a red term however such can be removed from derivations without l we will now formulate one of the main theorems of on the extraction of interpolants from local proofs and explain the structure of interpolants obtained by the algorithm of consider any note that by the soundness condition rb we can replace every formula c occurring in this derivation by its universal closure c and obtain an where are only performed on closed formulas we will call such derivations closed and assume for simplicity that we are dealing only with closed derivations we call a inference any inference that is either a grey leaf g of such that r t g or has the form a · · · an g such that g is grey and and at least one of the formulas a an is colored any such inference eliminates at least one colored symbol one could also call such the following theorem is proved in theorem let be a closed local then one can extract from a reverse interpolant i of r and b this reverse interpolant is a boolean combination of conclusions of symbol eliminating of the proof of theorem in gives an algorithm for extracting an interpolant from a by a close inspection of the algorithm of we noted that not all conclusions of occur in the extracted interpolant to the set of all formulas occurring in the interpolant in this paper we introduce a new notion called the digest of a as given below definition digest consider any conclusion g of a inference if the inference eliminates a red symbol then it has the form · · · r · · · g consider the path from g to the bottom formula of the · · · r · · · g we say that g belongs to the digest of the if either all formulas on the path are grey or the first to g colored formula on the path is blue likewise for a blue symbol eliminating inference · · · b · · · g g belongs to the digest of the if at least one formula on the path is colored and the first to g colored formula on the path is red note the slight in definition between red and blue symbol eliminating which is due to the interpolant generation algorithm of using the notion of digest we can now refine theorem as follows theorem let be a closed local then one can extract from a reverse interpolant i of r and b this reverse interpolant is a boolean combination of the formulas in the digest of in what follows we will refer to the interpolant obtained from a as described in theorem as the interpolant extracted from proof extracting interpolants from proof requires a special prover or a prover producing local proofs while as reported in the theorem prover can search for local proofs only and hence the algorithm of can be used in firstorder resolution proofs most provers and smt solvers do not necessarily generate local proofs one of the main of this paper was to check how our technique works on examples taken from static analysis of software although such benchmarks exist they can only be solved using an smt solver which in general produces nonlocal proofs in is interesting that in examples especially those taken from bounded model checking all the colored symbols are normally uninterpreted constants representing state variables from intermediate states in this section we show that for such examples one can transform arbitrary proofs into local ones at the cost of some formulas in the proof this idea has already appeared in see lemma below the of this approach is that a ground can become a one thus the extracted interpolant may contain quantifiers once we have a local proof the number of such quantifiers can be reduced using the technique of section line of algorithm lemma consider two formulas aa and a such that aa t a and a is an uninterpreted constant not occurring in a then aa and a this lemma can be used to nonlocal derivations by away colored constants that result in theorem given two formulas r and b such that r b and all the colored symbols of r and b are uninterpreted constant symbols then any proof of r b can be translated into a local proof l proof let us take a nonlocal of r b this means that contains at least one inference that violates conditions ll of definition the proof is by induction on we will eliminate all color conflicts one by one starting from the bottom of the proof thus for every conflicting inference we can assume that the derivation below it is already local in particular the conclusion of the inference cannot mix consider the case when the conclusion is blue other cases are similar then the inference has the form r · · · rn a · · · am a where a a am are either grey or blue and r rn are red let r rk be all the red constants occurring in this inference and formulas ri are obtained from ri by replacing r rk by fresh variables x xk note that all of the ri are either grey or blue the above nonlocal inference can then be replaced by x rn a · · · am a this inference does not contain the red color and we are done note that the premises of the formula x rn are given by the union of the premises of r rn the correctness of the transformation is guaranteed by lemma the above transformation can also be applied on where a premise contains both a red and a blue symbol the nonlocal inference is replaced by a local inference at the cost of using existential quantifiers over the premise with colored symbols this theorem gives us an algorithm for changing any nonlocal to a local one provided that the condition on colored symbols is satisfied figure illustrates how the nonlocal proof given in figure a is translated into the local proof listed in figure b in the grey area this section presents the main idea of this paper it is based on the following observation one can change sometimes considerably the grey areas that is areas consisting of grey formulas of the proof without locality in addition such proof transformations can change the extracted interpolant we will only consider one kind of proof transformations called here grey slicing other proof transformations can be proposed as well but are beyond the scope of this paper definition grey slicing consider any derivation containing a of the form an · · · am a · · · an a a where n we say that a derivation is obtained from by slicing off a in or simply slicing off a if is obtained from by replacing the by a · · · an an · · · am a when a is a grey formula we will refer to this transformation as grey slicing grey slicing preserves properties of definition so it transforms an into an it is also easy to see that grey slicing can violate the locality conditions l of definition for example slicing off g in r b g g yields a nonlocal derivation b r g consider now an example showing that grey slicing transformations can change the digest and hence the extracted interpolant qx r r qb r r qx r r y qx y y y qb y y y qb y y a b figure proof of proof a into proof b example take the following r g b g g g g r g r g the digest of this is g g and the extracted reverse interpolant is g g slicing off g in results in the r g g b g g r g r g with the digest g g and the extracted reverse interpolant g g slicing off now g in results in r g g b g r g r g with the digest g g and the extracted reverse interpolant g g we can slice off g in and obtain the r g g b g r g r with the digest g and the reverse interpolant however if we slice off g in the original derivation we obtain the b g r g g g r g r g in which slicing off g would violate the locality of the resulting example gives us the following observations grey slicing can change the extracted interpolant and sometimes considerably compare g g and a grey slicing step can prevent other grey slicing steps thus preventing previously possible interpolants the main question we are going to answer in this section is how to use grey slicing to obtain smaller and even minimal in some sense interpolants to this end we will use the following ideas first we will introduce a set v of propositional variables expressing some properties of obtained by grey slicing from a given proof next we will define propositional formulas p of the variables v that express locality thus every obtained from by grey slicing is local if and only if it satisfies p this means we can use a sat solver to compute all local that can be obtained from by grey slicing finally we introduce propositional formulas expressing the digest of this set of propositional formulas allows us to use an smt solver or a optimisation tool to find the digest in various ways let us now this idea in the rest of this section when we about a formula from a derivation we will normally mean a concrete node in the derivation containing this formula note that a derivation may contain more than one node with the same formula later we will also discuss derivations in the dag form nonetheless for simplicity for the moment we prefer to deal with trees instead of dags the first thing to note is that every derivation is also a set of nodes occurring in it and slicing off simply removes one node from this set this means that a sequence of slicing off transformations removes a subset of nodes every removed node g at the point of removal is replaced by a set of other nodes occurring in the derivation namely the premises of g at that point each of the nodes in this set can in turn be removed and replaced by other nodes etc so eventually the place of any removed node will be taken by a set of nodes occurring in the final derivation we will call this set a trace of f and define it formally below definition trace let s k be a sequence of derivations such that each member in the sequence except is obtained by slicing off a single grey node from the previous one for every grey node g in we define a set of formulas call trace of g with respect to s as follows if g was never off that is it occurs in k then def g suppose g was off at some point that is g is the formula a as in definition then def trace am denote any sequence s of slicing off transformations with the initial derivation and final derivation by it is not hard to argue that the following lemma holds lemma the trace of a node does not depend on the sequence of transformations s but only depends on the initial and the final derivation in s that is for every two derivations of the form with the same initial derivation and final derivation and for every grey node g in the trace of g is the same in both derivations in the rest of this section we will normally assume a fixed initial derivation and various sequences in view of this lemma we will simply about the trace of g in suppose is a sequence of transformations let us introduce some propositions the behaviour of grey nodes in on this sequence sg g was off rg the trace of g contains a red formula bg the trace of g contains a blue formula gg the trace of g contains only grey formulas dg g belongs to the digest of we define the set v of propositional variables as consisting of all the variables sg rg bg gg dg denoting these later we will add to v more variables then for every sequence of transformations and every grey node g in each of the above propositions is either true or false on this sequence therefore if we take any propositional formula built from these propositions it is also either true or false on this sequence expressing the digest our next aims are to write down a propositional formula that expresses that is local and also represent the digest of any local to this end we will first introduce propositional variables and formulas over grey nodes then write down further formulas of these propositions that are satisfied when is local and finally show that satisfiability of these propositions implies locality of propositions rc and bc take a local derivation with for each grey node g in we first introduce the propositions and expressing that g is not off and is a conclusion of a inference in with at least one red respectively blue premise the propositional variables and are added to v we will only define since the case of bc is symmetric consider the following cases depending on the inference introducing g in g is introduced by an inference with only grey premises g · · · gm g we then write rg the conditions on the traces of g gm ensure that g can be written as the conclusion of a symbol eliminating inference with at least one red premise namely if holds then by slicing off gi and some of the grey nodes from its derivation g becomes the conclusion of a symbol eliminating inference with at least one red premise g is introduced by an inference with at least one red premise r · · · rn g · · · gm g we then have g is introduced by an inference with at least one blue premise b · · · bn g · · · gm g due to the locality of derivations we write equations are added to the set of propositional formulas p over v propositions rf and bf we introduce the propositions rf g and bf g for every grey node g and add the corresponding variables to v these propositions are closely related to the definition of digest the proposition rf g holds iff on the path from g to the root of either i all nodes are grey or ii the first colored node is a blue one likewise the proposition bf g expresses that on the path from g to the root of there exists a colored node and the first colored node is a red one we will only write down properties of rf the case of bf is similar we define rf inductively starting from the root the bottom formula of the derivation if the successor of g in is a red formula then we write g if the successor of g in is a blue formula then we write rf g finally if the successor of g in is a grey node g then we write rf g rf g equations are added to p proposition d by straightforward inspection of the definition of digest it is not hard to argue that dg can be expressed as follows dg rf g bf g we add to p expressing locality take a local derivation and a grey node g in it depending on the inference introducing g there are four possible cases g is a leaf of g is introduced by an inference with grey premises g is introduced by an inference with at least one red premise g is introduced by an inference with at least one blue premise in this case due to the locality of all premises in the derivation tree of g are either blue or grey for each of these cases we will show how to write down formulas expressing that results in a local derivation that is is local each below listed propositional formulas is added to p general properties of grey nodes note that if a node g is not off then its trace is g so we have gg gg we also know that a node which is off cannot belong to the digest sg observe that equations do not make use of the assumptions that is local that is hold for arbitrary derivations further note that for local derivations the properties b r and g are mutually exclusive therefore for every grey node node g we add the following properties expressing mutual exclusion color g def bg rg gg bg rg gg g is a leaf in this case g cannot be off and we have leaf g def gg g is introduced by an inference with grey premises g · · · gm g the locality of implies that if the trace of any g gm contains a red respectively blue formula then the traces of g gm cannot contain a blue respectively red for to further reason about the trace of g consider the following cases i if g is never off in then the trace of g is clearly grey whether g is a conclusion of a symbol ing inference only depends on whether the trace of some of the g gm contains either a blue or a red formula ii if g is off then the color of the formulas in the trace of g depend on the color of the formulas from the traces of g gm based on the above reasoning we introduce the following for capturing the properties of the trace of g def rg bg sg rg rg sg bg bg sg gg gg gg g is introduced by an inference with at least one red premise r · · · rn g · · · gm g in this case the locality of implies that the trace of g can contain only red and grey formulas moreover the color of the formulas from the trace of g only depends on whether g is off as follows i if g is off then the trace of g depends on the traces of r rn g gm and hence the trace of g contains at least one red formula also note that if g is off then g cannot belong to the digest of ii if g is not off then g hence the trace of g only contains grey formulas moreover note that g is the conclusion of symbol eliminating inference thus g also belongs to the digest of we therefore introduce the below formula for g capturing the properties of the trace of g red g def sg rg gg g is introduced by an inference with at least one blue premise b · · · bn g · · · gm g similarly to the previous case we introduce the following formula def sg bg gg this completes our construction of the propositional variables and formulas explained in the beginning of this section namely the set of variables v consists of all variable sg rg bg gg rf g bf g and dg and the set p of formulas are all formulas ­ our construction clearly implies the following result theorem let be a local derivation then a sequence satisfies all formulas from p if and only if is local moreover the propositions rg bg gg rf g bf g and dg have their intended meaning in particular in every model of these formulas g belongs to the digest of if and only if dg holds on derivations as dags found by theorem provers are normally dags transforming a dag to a tree can result in an exponential growth in size therefore it is desirable to change our technique to deal with dags the modification is quite simple we allow a formula in a dag to be off only if all the tree derivations corresponding to the resulting dag are local note that this may result in a smaller choice of grey slicing transformations as compared to as trees and hence larger interpolants nonetheless expanding dags to trees may turn to be therefore our implementation uses dags to build propositional formulas expressing locality on dags one should only modify the propositions rf g and bf g propositions rf and bf for dags the proposition rf g holds iff on all paths from g to the root of either i all nodes are grey or ii the first colored node is a blue one likewise the proposition bf g expresses that on all paths from g to the root of the first colored node is a red one the of these propositions is given below and are replaced by the below formulas in p we will only define rf since the of bf is similar it is defined inductively starting from the root the bottom formula of the derivation suppose at least one of the successors of g is a red formula in this case we write g otherwise all the successors of g are either grey or blue g g · · · gm b · · · bk in this case we write rf g rf g rf gm interpolants in local proofs theorem shows how one expresses locality and digest using the propositional formulas p this allows us to introduce various measures of quality of interpolants and use these measures together with an smt solver to find local proofs giving interpolants that are better in these measures as usual we define a clause to be a disjunction possibly empty of literals that is atomic formulas and their since most theorem provers and smt solvers present proofs as dags of clauses apart from some preprocessing deriving a set of clauses from r b and the theory we assume that the digest of a proof is a set of clauses if such a clause contains free variables it is assumed to be implicitly universally quantified we know that the interpolant extracted from a proof is a propositional combination of clauses occurring in this proof if a particular clause is a propositional combination of smaller formulas then the interpolant can be considered a propositional combination of these smaller formulas the smallest formulas of this form are in the automated deduction community and called components we will take a slightly modified definition of components from definition component a component of a clause c is either a ground atomic formula occurring in c or a clause c such that c has the form c c both c and c are nonempty and the only component of c is c itself a clause c is said to be a if c is the only component of itself for example the clause px a qx has two components px qx and a note that we have the following equivalence a qx qx ¬a in general the universal closure of every clause is a boolean combination of the universal closures of its components therefore the extracted interpolant is a boolean combinations of which are components of the formulas in the digest the problem of generating minimal interpolants can be thus reduced to the problem of in some sense the set of used in the interpolant as of interpolants is not we introduce various measures for the size of interpolants namely we are interested in interpolants with respect to i the number of and ii the total weight of counted as a number of symbols one can also argue that ground interpolants are more useful than those containing quantifiers so in addition when the is we can also iii the number of quantifiers in the for doing so we use the fact that the digest of a derivation can be expressed using propositional variables dg over grey nodes g and transform the problem to solving a optimisation problem over v as explained below we consider a local for every component g of a grey clause g of we introduce a distinct propositional variable vg intuitively this variable will denote that g occurs in the digest of the transformed proof for every grey node g in let g gk be all of g we then introduce the following axiom dg vg in what follows let g gm be all occurring in all grey nodes of let w be the total weights of these atoms respectively we denote by q qm the number of quantifiers used respectively in g gm the problem of interpolants is then reduced to the problem of one of the following sums def vg def def each of these sums is expressed as a constraint over the g gm a solution to the problem of the lefthand side of gives us a subset of g gm such that the interpolant constructed from the boolean combinations of the formulas in this subset is a smallest interpolant among all interpolants that can be extracted from the various local resulting from grey slicing of gives the smallest interpolant in the number of distinct likewise the minimal values of and correspond to the interpolant with the smallest total weight and the smallest number of quantifiers respectively algorithm puts together the algorithm for interpolants algorithm interpolants input closed formulas r and b such that r ¬b and a from r b output interpolants of r and ¬b assumption all colored symbols of r and b are uninterpreted constants begin i proof compute local proof l from using theorem ii expressing locality g p for each grey node g in l do express dg let p p express general properties let p p if g is a leaf p p if g is introduced by an inference with only grey premises p p if g is introduced by an inference with a red premise p p if g is introduced by an inference with a blue premise p p compute g g · · · gk where gi are g g g gk p p iii interpolants min gi p min gi p where wi denotes the weight of gi min gi p where qi denotes the number of quantifiers uses in gi return end algorithm uses the result of theorem and starts with translating the input of r b into a local one l line note that this step is only applied when is nonlocal more precisely when the nonlocal steps of contain colored constants further the set g of from l and the set p of constraints expressing locality of l are line next for each grey node g in l the constraints expressing locality conditions over the digest and of l are constructed lines note that the propositional formulas rf g and bf g are expressed based on the of proofs the set of of g is extracted and added to g lines then the property whether g is in the digest of l is expressed in terms of and added to the constraint set p line as a result of these steps at the end of line of algorithm the constraint set p is expressed as a set of clauses ensuring the locality of l theorem next minimal interpolants wrt to the number of line the total weight of line and the number of quantifiers in the line are derived by solving a optimisation problem over to this end the interpolation procedure of is called to generate interpolants as boolean combinations of the derived minimal set of lines theorem algorithm is correct that is given two formulas r and b and a algorithm returns the minimal interpolants of r and ¬b wrt the imposed measures among all interpolants extracted from proofs obtained by grey slicing of we next show that finding minimal interpolants by algorithm is nphard theorem given two formulas r and b and a of r b extracting a minimal interpolant from by grey slicing is an nphard optimisation problem proof we use a reduction from finding a maximal independent set of a graph gv e with a set of vertices v v vm and a set of edges e u w un wn which is known to be nphard to conditions of theorem we first fix a background theory t for each vertex v v we introduce a propositional grey variable also denoted by v of weight further for each edge u v e we add u v to the theory t introduce also a blue propositional variable b and a red propositional variable r define b to be the blue formula v · · · vm b and r to be the red formula · · · r further for each edge u w e we introduce the following derivation uw b u w note that this derivation is sound in the underlying theory t we next construct the proof tree to be symbols some interpolant size decrease to table results on problems with nontrivial interpolants bb u un w wn r where the weight of is considered to be zero observe that is a valid of r b also note that building a minimal interpolant from reduces to finding a derivation obtained from by grey slicing with a minimal number of let be any derivation obtained from by grey slicing denote by d the digest of for every edge u w e the uw either remains a of or u gets off in the first case we have u d in the second case w d therefore either u v d or w v d which implies that v d is an independent set using similar arguments one can prove that every independent set s of vertices is a subset of v d for some digest d of a derivation obtained from by grey slicing as each set v d is an independent set as well for every maximal independent set s there exists a digest d such that s is equal to v d therefore finding a digest of the minimal size is equivalent to finding a maximal independent set let us finally note that our method can be extended with other proof transformations and optimisation criteria eg to improve the quality of interpolants for example many approaches use templates to identify predicates desirable to be used in invariants or interpolants algorithm thanks to its generality can easily be modified to give preference to predicates matching templates we therefore believe that our method is of an independent value since one can first the interpolant and then try to make it semantically better using other methods another important feature of our algorithm is that it the proof globally that is the optimal solution is not necessarily a sum of optimal solutions given by local proof transformations we believe this a very essential property of the algorithm not shared by other known approaches to interpolants experimental results implementation we implemented our interpolant method in c and integrated it in version of the theorem prover for the set of constraints we used version of the smt solver due to the lack of realistic verification benchmarks that is examples coming from some project we evaluated our method on the following two classes of problems first we took a collection of examples over firstorder logic with equality from the library we interpolants in the firstorder proofs generated by second we considered smt benchmarks from the library that come from bounded model checking we proofs generated by the z smt solver we used version of z without any modification however for interpolants from z proofs we implemented a parser for processing and translating z proofs into local proofs to this end we used our algorithm for proof see proof of theorem before after table number of symbols in benchmark interpolants before and after all experiments reported in this paper were carried out using a bit core server with gb ram firstorder problems for this part of the experiments we took a collection of firstorder problems from the library we started with annotating these problems with coloring information using the following coloring strategies we order symbols by the number of their occurrences in the problem and starting with the symbols occurring the least number of times we attempt to assign to them a color can be assigned to a symbol if the symbol does not occur in a formula with a symbol that was already assigned with the opposite color the are being assigned in an alternating manner if the last assigned color was red we first attempt assigning blue to the next symbol and try to assign red only if this the blue color in an assignment ie an input formula with two different colored symbols is obtained we stop when we have to assign a color to all the symbols the previous assignment strategy is more or less random to use interpolants in a more logical way we used the following idea typically problems come with annotations formulas from a problem into axioms and hypotheses we have to prove the conjecture from the axioms and hypotheses it is commonly the case that axioms some theory so we have to prove that the hypotheses imply the conjecture in the theory given by the axioms this gives us the following way of coloring the problem symbols we assign blue color to symbols appearing only in the formulas of the conjecture ie formula b and red color to symbols occurring only in hypothesis ie formula r the symbols shared by the conjecture and the hypotheses are considered grey as well as the symbols occurring only in the axioms local proofs for the colored problems were generated using the interpolation mode of we evaluated our method on colored examples out of the problem instances problems had trivial interpolants that is the interpolant was either or this left us with problems with nontrivial interpolants we were interested to see how our algorithm performs on these problems to this end for each of the problems our method took the corresponding local proof generated by and derived the smallest interpolants by i the number of symbols ie total weight and ii the number of in the interpolant table gives a summary on how the size of the interpolant decreases after as compared to the interpolant extracted from the original proof rows and of table show respectively the changes in the interpolant size after the number of symbols respectively the number of in the interpolant for each imposed measure column of table lists the number of examples where the size of the interpolants has only by a small amount the numbers shown in column resp in column column and column correspond to the number of those examples whose interpolants resp and more than times smaller after column gives the number of examples whose interpolants trivial after even though the interpolants were nontrivial quantifiers table results on smt benchmarks in table we report on the number of symbols in the interpolants before row and after row each column of table gives the number of interpolants whose number of symbols satisfy the numeric constraint given in the first cell of the column that is column gives the number of trivial interpolants the number of symbols is column shows the number of interpolants with less than symbols column reports shows the number of interpolants that contain between and symbols etc by the results of table we note that for respectively examples the number of symbols respectively the number of of the interpolant by at least a factor of however we also note that for respectively problems out of the examples we tried did not improve the size these examples are omitted in table as the studies of interpolants is a challenging topic we believe that the experimental results reported in table show the potential of our method in generating better interpolants in figures and we show a colored proof of a problem before and after minimization formulas appearing in the interpolant are given in while other consequences of symbol eliminating in red symbols in the proof are whereas blue symbols are figures and show the proof before and after in a tree form as mentioned formulas denoted by r resp by b or g refer to red resp blue or grey formulas the formulas g and g appear in the original interpolant but when g g and g are off by the algorithm the new interpolant formulas are g and g this is because the formula g is eliminating red symbols from the premises it received as a result of the slicing the formula g now appears in the interpolant because it is an ancestor of a red symbol eliminating formula even though we still have two formulas in the interpolant its size because g is a trivial formula when compared to figure note that the number of grey formulas in figure has due to grey slicing experiments with smt problems we used a set of benchmarks coming from bounded model checking variables in these problems correspond to state variables representing various unrolling steps of loops these variables are typically indexed by integer constants where the integer index expresses the unrolling step to which the state variable belongs to translating and z proofs we generated proofs of smt problems by using z z proofs are expressed in the sequent calculus while our proof and algorithms work with proofs we therefore parsed and translated z proofs into our framework by using a simple lisp parser to this end we replaced z formulas of the form a an f by implications a an f the coloring strategy we used for the smt benchmarks was as follows except the state variables all other symbols were colored grey we divided the set of state variables into three parts state variables corresponding to the middle loop unrolling step were left grey variables from earlier states were marked red and those from later states were colored blue in our experiment this coloring strategy turned out to be successful in of all examples we ¬ ¬ ¬ ¬ ¬ ¬ ptp ptp xx ¬ ¬ ptp xx ptp ¬ ptp ¬ input ¬ input ¬ input input ¬ ¬ input ptp input ¬ input ¬ ¬ input ¬ input input figure proof of the problem from the library tried input formulas have been translated into formulas colored by at most one color however the usage of nonlocal z proofs in more than of all examples we tried we translated nonlocal z proofs into local ones by applying our proof algorithm to this end we always used existential quantification to eliminate red symbols from nonlocal as the size of generated interpolants depends on the introduced quantified formulas we believe that a dynamic analysis over the colored symbols to be eliminated for example eliminate blue symbol instead of a red one is an interesting topic for further the result of proof was further used to interpolants local smt proofs we used smt benchmarks out of these examples we generated interpolants for problems we these interpolants below and summarize our results in table the remaining smt problems we could not fully process this was due to a s time limit which we imposed as the processing time of one problem including proof translation coloring and in cases the run was terminated by reaching the time limit in translating and coloring z proofs in cases the timeout was reached in the proof phase and for benchmarks the time limit was reached during the minimization phase in constructing and the set of propositional formulas among the interpolants interpolants were trivial and contained existential quantifiers introduced by proof the number of symbols in the interpolants was by our algorithm for interpolants out of which interpolants had a decrease by more than two times the number of in the interpolant for interpolants whereas the number of quantified variables was for ¬ ¬ ¬ ¬ ¬ ptp ptp xx ¬ ¬ ptp xx ptp ¬ ptp ¬ input ¬ input ¬ input input ¬ ¬ input ptp input ¬ input ¬ ¬ input ¬ input input figure transformed proof of figure by slicing off formulas using weight minimization interpolants table shows the distribution of the number of symbol occurring in interpolants before row and after minimization row the distribution of the number of row and quantifiers row in interpolants is shown only before minimization because the effect of on these values was not significant each column of table gives the number of interpolants whose number of are bounded by the numeric value given in the first cell of the column that is for examples the number of symbols in row column interpolants is between after the numbers given in column of table correspond to the number of trivial interpolants the experiments show that our algorithm is not very efficient on this benchmark suite compared to the firstorder benchmarks we believe that the problem is not in the method but in the way z produces proofs since the produced proofs were not intended for interpolation it was often the case that the proofs contained very large formulas sometimes in these formulas the formulas are then quantified by other algorithm and cannot further be removed from the proof thus the statistics these formulas are normally large conjunctions or ifthenelse expressions which can also be represented as conjunctions and could have been split into smaller ones this would not only replace large formulas by smaller one but also improve coloring of proofs and reduce or eliminate the to quantify formulas in them we believe that our technique will work very well if smt solvers are modified to obtain proofs of a better quality moreover once a proof is found post processing can also be done and one may try to change nonlocal parts of the proof again by theorem proving related work interpolation has a number of application in formal verification ranging from the set of reachable sets in predicate abstraction to invariant generation of loops formal verification thus depends to which extent good interpolants can be automatically generated g b b g r r r r b g g g g b g g r r b g b g g g b b g g g figure proof tree for figure general criteria for comparing interpolants can be defined by the logical strength of the interpolant see eg the approach described in the sequence of resolution steps in a proof to the derived interpolants the main heuristic used for proof transformation is to make resolution steps on variables before those on grey variables the work of extends and gives a theoretical investigation on the logical strength of propositional interpolants extracted from resolution proofs the approach uses the notion of labeling functions which essentially label literals by red blue or grey labels the differences among the labeling functions come from how grey literals are labeled red blue or grey the strength of the various labeling functions is compared and weaker or stronger interpolants are derived by changing the labeling functions and some nodes in the derivation examples of that weaker interpolants might lead to better performance whereas experimental results of show that stronger interpolants can speed up the convergence of a software model checker based on predicate abstraction interpolants by only using the logical strength of the interpolant as a selection criteria is thus not always the best way to go in designing efficient interpolation algorithms the logical strength of the interpolant is also evaluated in in the context of verification of programs with loops although one can derive various program properties by loop iteration the resulting set of program properties is a sequence of formulas in interpolants are generated by searching the proof space and avoiding divergence by deeper of loop iterations the method is further extended in to infer quantified interpolants it is shown that by bounding the behavior of the prover eg delaying over colored or grey symbols divergence is and an inductive invariant is eventually produced from quantified interpolants a related approach is presented in where quantified interpolants are extracted from firstorder local proof these techniques generate interpolants by taking the boolean combinations of the grey conclusions of the largest colored the works of evaluate the quality of interpolants by using in some sense a different selection criteria these methods are motivated to generate interpolants that are small in the number of their components and describe interpolation procedures for the theory of linear integer arithmetic wo uninterpreted function and predicate symbols the approach of computes ground interpolants that are exponential in the size of the proofs the method is improved in by restricting the logical power of the prover and is further extended in by handling uninterpreted function and predicate symbols to this end shows that quantified interpolants are needed however by using guarded quantifiers and predicates the quantified interpolants can be translated into equivalent quantifierfree formulas a similar problem is addressed and solved in where functions are used to avoid quantified interpolants and generate quantifierfree interpolants of quantifierfree formulas in linear integer arithmetic functions are handled in the prover by replacing every term by a fresh integer vari r r g g b b g b g g g g b r r b g b g r r b b g g g figure proof tree for the proof of figure able inequality constraints over the newly introduced integer variables are added to capture the semantics of terms whereas show good performance on experiments due to the lack of realistic benchmarks it is hard to draw broad conclusions whether the interpolants generated by these works are the best in size and expressiveness contrary to all works we define a set of constraints over the grey formulas of the proof any solution to this set of constraints gives a different interpolant and any interpolant can be expressed as a solution of the constraint set the proof transformations carried out in our approach use only slicing off formulas that are logical consequences of other formulas furthermore we evaluate the logical strength of interpolants by the size the total weight and the number of quantifiers unlike our method can generate and interpolants of quantified formulas when compared to our experiments show that we get better interpolants then the ones of extracted from the largest colored more generally our algorithm can be applied to any input proof provided that the input proof can be translated into an equivalent local proof a special case of such proofs are those whose only colored symbols are uninterpreted constants although such a condition might sound it turns out that in practice a large class of examples satisfy this imposed restriction interpolation benchmarks in the combined theory of uninterpreted functions predicates and linear integer arithmetic coming from the smt community satisfy this coloring constraint conclusion we described how interpolants extracted from arbitrary proofs can be obtained and in various ways giving smaller interpolants our method takes an arbitrary proof translates it into a local one provided that all colored symbols are uninterpreted constants applies based on analysis of grey areas in the and computes a minimal interpolant by using optimisation our method is very general and can be used with any theory and in conjunction with any theorem prover that outputs proofs of interpolation problems the evaluation of our method on firstorder and smt bounded model checking benchmarks shows that in many cases considerably decreases the interpolant size we intend to integrate our method into concrete verification tools and evaluate our approach on more realistic verification benchmarks an interesting question we plan to address in the future is how the quality of interpolants effects the efficiency of verification methods using a highly solver instead an smt solver is left for further experiments we believe that our method a new on research in methods indeed other proof transformation methods can be used as well for example we can quantify away not only red but sometimes also blue symbols or slice off colored formulas in addition as we pointed out in section better proofs can considerably improve the quality of interpolants acknowledgments we from the university of and an grant the research grant tn and the national research network rise sn and an grant references l and h resolution theorem proving in a and a editors of automated reasoning volume i chapter pages ­ science c a and c the satisfiability modulo theories library d t a henzinger and g lazy shape analysis in proc of cav pages ­ a d p and t an sequent calculus for quantifierfree presburger arithmetic in proc of pages ­ a d p and t beyond quantifierfree interpolation in extensions of presburger arithmetic in proc of pages ­ a a a i and m a software model checker for in proc of cav pages ­ w craig three uses of the theorem in relating model theory and proof theory journal of symbolic logic ­ l de and n z an efficient smt solver in proc of tacas pages ­ v d m and g interpolant strength in proc of pages ­ b and l de a fast solver for in proc of cav pages ­ a t t h le and r efficient interpolant generation in satisfiability modulo linear integer arithmetic in proc of tacas pages ­ t a henzinger r jhala r majumdar and k l abstractions from proofs in proc of popl pages ­ k l and a interpolation and symbol elimination in in proc of pages ­ r jhala and k l a practical and complete approach to predicate refinement in proc of tacas pages ­ r jhala and k l array abstractions from proofs in proc of cav pages ­ r jhala and k l transition relation approximation logical methods in computer science d r majumdar and c g interpolation for data structures in pages ­ l and a interpolation and symbol elimination in proc of pages ­ d j and p quantifierfree presburger arithmetic in proc of pages ­ k l an theorem prover theor comput sci ­ k l quantified invariant generation using an saturation prover in proc of tacas pages ­ r and a theorem proving in of automated reasoning volume i chapter pages ­ a and a splitting without backtracking in proc of pages ­ a and a the design and implementation of ai communications ­ g the problem library and associated infrastructure j reasoning ­ 