urweb a simple model for programming the web mit popl consist complete well easy to abstract the world wide web has from a document platform to an architecture for distributed programming this largely evolution is apparent in the set of languages and protocols that any web application must this paper presents urweb a domainspecific statically typed functional programming language with a much simpler model for programming modern web applications model is unified where programs in a single programming language are compiled to other web standards languages as needed supports novel kinds of encapsulation of state and simple concurrency where programmers can reason about distributed multithreaded applications via a mix of transactions and we give a introduction to the main features of urweb and discuss the language implementation and the production web applications that use it categories and subject descriptors d software engineering design tools and techniques modules and interfaces d programming languages language concurrent distributed and parallel languages applicative functional languages keywords web programming languages encapsulation transactions remote procedure calls message passing relational databases programming introduction the world wide web is a very popular platform for programming certain kinds of distributed applications with graphical user interfaces complex of web standards was not rather it from the starting point of the web as a system for static documents the result is not surprising there are many points in implementing rich functionality on top of the particular languages that and servers at a minimum rich applications must generate html for document structure for document javascript a language for and http a protocol for sending all of the above and more to and from most recent popular applications also rely on a language like for complex datatypes permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm for network communication and on a language or api like sql for storing persistent structured data on servers code fragments in these different languages are often embedded within each other in complex ways and the popular web development tools provide little help in these are not new nor are languagebased solutions the links project the programming approach combining all the pieces of dynamic web applications within one statically typed functional language more recent designs in the some similar benefits as in web and closure systems for adding compilation on top of languages and for typesafe to sql databases and more within generalpurpose languages such established systems provide substantial benefits to web programmers but there is more we could ask for this paper focuses on a language design that advances the state of the art by addressing two key first we bring encapsulation to rich web applications supporting program modules that treat key pieces of web applications as private state second we expose a simple concurrency model to programmers while supporting the kinds of nontrivial communication between clients and servers that applications take advantage of most web programmers seem of either property as something that might be worth for so part of our in this paper is to for them we present the urweb programming language an extension of the ur language a statically typed functional language inspired by dependent type theory a prior paper described ur and its type system but did not discuss the extensions implementations of urweb have been available since and several production web applications use the language including at least one commercial site urweb reduces the nest of web standards to a simple programming model coming close to just the essence of the web as an application platform from the of security and performance · an application is a program in one language urweb that runs on one server and many clients with automatic compilation of parts of programs into the languages appropriate to the different nodes eg javascript the server is completely under the programmers control while clients may arbitrarily from code we provide to them to run for reasons of performance scaling or reliability we may use multiple physical machines to implement server functionality but it is sound for the programmer to imagine all server code running in a single isolated machine · all objects passed between parts of the application are strongly typed applications may be written with no explicit or other conversion of data between formats where of code appear as firstclass values they are presented as abstract syntax trees out like code injection that rely on surprising consequences of · the only persistent state in the server in an sql database accessed through a strongly typed sql interface · the server a set of typed functions that are a client begins interacting with the application in a new browser by making a remote procedure call to one of these functions with arbitrary correctly typed arguments the server runs the associated function atomically with no to observe interference by any other concurrent operations generating an html page that the client · the html page in a client may contain traditional links to other pages which are represented as suspended calls to other functions to be forced when a link is followed to generate the new html page to display · any html page may also contain embedded urweb code that runs in the client such code may spawn as many threads as is convenient and the threads a semantics where one thread runs at a time and we only switch threads during welldefined blocking operations threads may modify the shown to the user via a programming system that dataflow programming with imperative callbacks · thread code may also make blocking remote procedure calls treated similarly to those for regular links such a call may return a value of any type not just html pages and the thread receiving the function result may compute with it to change the visible rather than by loading a completely new page as before every remote procedure call appears to execute atomically on the server · server code may allocate typed channels which may be both stored in the database and returned to clients via remote function calls the server may send values to a channel and a client that has been passed the channel may receive those values channel sends are included in the guarantee of atomicity for remote calls on the server all sends within a single call execution appear to transfer their messages to the associated channels atomically the next section expands on these points with a introduction to urweb we the impact on the language design of our goals to support encapsulation and simple concurrency next we describe key implementation techniques in the urweb compiler and runtime system and we evaluate the effectiveness of the language through applications that use it the implementation of urweb is available at a introduction to urweb we will introduce the key features of urweb through a series of refinements of one example a application to the site choose from a selection of each of which maintains a log of messages any to a room may append any line of text to the log and there should be some way for other users to on log additions we start with a simple implementation in the style of web applications before it common to do significant client table room id int title string table message room int when time text string fun id let fun say r dml insert into message room when text values id id in title select from room where id log select from message where id order by fn r return room form add message form hr log end fun main select from room order by fn r return of figure a simple application side we toward a version with instant updating upon all message additions where a room runs within a single html page updated incrementally by code along the way we our running of encapsulation and simple concurrency html and sql modern web applications manipulate code in many different languages and protocols urweb most of them within a unified programming model but we decided to expose two languages explicitly html for describing the structure of web pages as trees and sql for accessing a persistent relational database on the server in contrast to practice urweb represents code fragments in these languages as firstclass strongly typed values we use the type system of ur to define rich syntax tree types where the generic type system is sufficient to enforce the typing rules of the embedded languages html and sql going into the details of type encoding would take us in this paper so the reader may that urweb includes special builtin support for typechecking html and sql figure gives our first implementation relying on embedding of html and sql code while in general urweb programs contain code that runs on both server and clients all code from this figure runs on the server where we are able to enforce that it is run exactly as written in the source code the first two lines show declarations of sql tables which can be thought of as mutable global variables of type multiset of records table records contain integer ids and string while table messages records contain integer room ids timestamps and string messages the former table represents the set of available while the latter represents the set of all messages sent to all it is for a programming language to treat sql tables as declared within the language the more common view is that the sql database exists as a resource out there and the programming language merely to it our choice has important consequences for encapsulation which we will get to we direct the readers attention now to the declaration of function main the end of figure here we see syntax extensions for embedded sql and html code such notation is into calls to constructors of abstract syntax tree types at which point the normal ur typechecker may validate the of embedded fragments the main definition demonstrates two notations for or inserting ur code within a code fragment the notation e to evaluate expression e to produce a to be inserted at that point and notation e adds a further stage of e as a literal of the embedded language using type classes as in haskells show note that we are not syntax trees to the programmer as strings so neither form presents any of code injection attacks where we interpret user input as code what exactly does the main definition do first we run an sql query to list all in our examples we will call a variety of functions from standard library especially various higherorder functions for using sql query results we adopt a convention for each library function briefly starting with used in main run an sql query that returns columns from a single table leading to the in the identifier calling an argument function on every result row since just a single table is involved the input to the argument function can be a record with one field per column returned by the query the argument function should return xml fragments leading to the x in the identifier and all such fragments are together in order to form the result of note that a function like main in a distinguished monad for inputoutput as in haskell since ur is purely functional thus we use the notation to run an effectful computation and bind its result to a variable and we call the return function to lift pure values into trivial computations the remaining interesting aspect of main is in its use of an html a tag to generate a instead of denoting a link via a url as in standard html we use a link attribute that accepts a suspended urweb remote function call in this case we call which is defined earlier the urweb implementation handles proper of arguments in suspended calls now let us examine the implementation of function providing a page for the current message log of a room first there is a nested definition of a function say which will be called to append a message to the log dml run a piece of sql code for its side effect of the database the function name refers to data manipulation language this particular invocation of dml inserts a new row into the message table with the current timestamp after which we display the same page as itself would generate note that say like all functions appears to execute atomically so the programmer need not about interleavings between concurrent operations by different clients to performance programmers might want to indicate the boundaries of atomic execution units explicitly but we have found that it works well to make the atomic units be precisely the remote calls which programmers from to write any explicit code to begin or end transactions the main body of runs appropriate queries to the room name and the full sorted message log run an sql query that should return just one result row containing just a single column the that is computed using an arbitrary sql expression the e that one result value becomes the result of the call we the query results into the returned page in an way the only new feature involves html forms in general we tag each input with a record field name and then the of the form includes in its action attribute an urweb function that should be called upon on a record built by combining the values of all the input we will not say any more about html forms which to some extent represent a aspect of html that has been by forms are a language for input and these it is more common to use a language javascript for the same task note that this first example already a small bit of encapsulation the local function say may only be referenced within the declaration of clients may ignore the intended order of and visit say directly but we at least know our application itself will not generate links to say outside the intended scope compiling an application to run on the real web platform requires functions like main and say via urweb automatically generates url schemes by the expressions that appear in places like link attributes for instance the link to in the declaration of main is compiled to a url where nn is a textual representation of the room id the link to say within the above is compiled like including the value of a local variable id implicitly captured in the function the urweb compiler handles generation of url schemes in such a way that it is guaranteed that no two functions will up with conflicting schemes this approach with the manual url routing found in most frameworks there are serious costs to modularity when composing two libraries requires understanding their url schemes some other systems like the plt scheme web server and links avoid the problem by generating for continuation references we prefer to keep readable since they serve as a common interface with the world however links many of the other design elements on display in figure including typesafe combination of html and database code within a single language one further key difference is that urweb works with direct embedding of sql code whereas links to sql from a subset of itself presented as a monadic query language the key distinguishing elements of design in comparison to past languages become when we turn to taking better advantage of encapsulation before doing so we to discuss some relative and of the html and sql encodings in urweb urweb effectively encodes xml with algebraic datatypes which are not expressive enough to capture all of the constraints associated with xml schemas regular expression types are an established approach to enforcing the rules of xml more and they have been integrated with languages in the project programmers may benefit from that style of more precise typechecking on the other hand more complex static checking of xml may be more difficult for programmers structure room sig type id val transaction list id id title string val id transaction page end struct copies of old definitions of room message and val select from room order by end fun main return of fn r figure a modular of the first application to understand an additional benefit of approach is that xml checking need not be built into the language as it is in eg but is instead encoded as a library using rich but generalpurpose type system we use row types to encode context constraints on xml elements so that the generic ur engine may do the rest of the work a similar comparison may be drawn with other approaches to encoding relational database queries the query approach represents queries within a restricted subset of the host programming language rather than working with explicit embedded syntax of a language like sql is the wellknown example that gives the approach its name but the links language uses static type checking and term rewriting to provide more guarantees about which expressions will compile to sql successfully urweb encodes sql as a library with no special support required in the compiler and the programmer benefits from the explicit control over exactly which code will be passed to the database system performance may be most effective with this sort of direct approach on the other hand explicit manipulation of query syntax can be more tedious than writing query code directly in the host language relying on compilation to the language of a database system and the use of multiple languages some amount of duplicate definition of library functions overall on this comparison point the author is and could imagine a successor to urweb being developed with query adding more encapsulation the application in figure is rather monolithic the database state is exposed without restrictions to all parts of the application we would not such a lack of encapsulation in a large traditional application chunks of functionality should be eg into classes implementing data structures the database tables here are effectively data structures so why not try to them as well the answer is that as far as we are aware no prior language designs allow it as we above the general model is that the sql database is a resource and any part of the application may create an interface to any part of the database we such a scheme to an objectoriented language where all class fields are public it on some very useful of modular reasoning it is important that modules be able to create their own private database tables without requiring any changes to other source code application configuration files etc for the same reason that we do not want client code of a dictionary class to change when the dictionary switches to being implemented with hash tables instead of search trees figure shows a of our application code to present the table as a mutable abstract data type we use module system which is in the ml we have modules that implement signatures which may impose information hiding by not some members or by making some types abstract figure defines a module room all database access the signature of room appears between keywords sig and end we expose an abstract type id of identifiers urweb code in other program modules will not be able to take advantage of the fact that id is really int and thus cannot new ids out of the signature two methods to list the ids and of all and exactly the function we before but typed in terms of the abstract type id each methods type uses the transaction monad which is like haskells io monad but with support for executing all side effects atomically in a remote call the implementation of room is mostly just a of the of the code from figure we only need to add a simple implementation of the method return as a list the l the results of a query that only returns columns of one table the apply an function to each element of a list then together the resulting xml fragments to compute the result of the code for main changes to call methods of room instead of inlining database access this sort of separation of a data model is often implemented as part of the pattern to our knowledge that pattern had not previously been combined with guaranteed encapsulation of the associated database tables it also seems to be novel to apply type abstraction to database results as in our use of an id type here we hope this example has one basic message giving firstclass status to key pieces of web applications makes it easy to apply standard languagebased encapsulation mechanisms strong encapsulation is not automatic when using conventional database the database server will generally be to allow adhoc by and other applications where the data abstraction in a particular urweb application need not be we imagine a future version of urweb with data storage integration where by default only an application itself may access particular tables for now though data abstraction for sql tables remains useful as a way to reason about urweb programs and it is possible to associate each application with a new database user whose authentication are only given to the application the urweb compiler will automatically initialize the schema of a database and each application checks on that the schema matches what is present in its source code we will develop two more variations of the application our modifications will be confined to the implementation of the room module its signature is already sufficient to enable our experiments and we will keep the same main function code for the rest of the our first extension takes advantage of to make applications more without the need to load a completely fresh page after every user action web applications are with javascript but as in links and similar structure log sig type t val create transaction t val append t string transaction val t end struct datatype log nil cons of string source log type t head source log tail source source log val create s source nil s source s return head s tail s fun append t text s source nil get set cons text s set s log get case log of nil set cons text s return fun log case log of nil xml cons text rest xml dyn signal rest return log xml fun t xml dyn signal return log xml end figure a module implementing a for an log languages urweb is done in the language itself which is compiled to javascript as needed reactive urweb programming follows the style that is to a large extent the visible page is described via dataflow as a pure function over some primitive streams of values as the primitive streams the language runtime system automatically just those parts of the page that are affected languages like and adopt the stream where the primitive streams represent eg made by the user urweb a less pure style where we retain the event callbacks of imperative programming these callbacks modify data sources which are a special kind of mutable reference cells the only primitive streams are effectively the sequences of values that data sources take on where new entries are pushed into the streams mostly via imperative code in callbacks as a basic to these concepts in urweb here is their type signature we write to a kind to a typelevel identifier where for instance type type indicates a type family parameterized over one type argument we write to a type to a identifier as types and values different we often reuse an identifier eg source to stand for both a type and the runtime operation for allocating one of its instances source type type source transaction source get source transaction set source transaction signal type type s m monad signal signal source signal that is data sources are a polymorphic type family with operations for allocating them and reading or writing their values all such operations live inside the transaction monad which contains imperative side effects in the manner of haskells io monad signals or values are another polymorphic type family which happens to form a monad with appropriate operations as indicated by the presence of a firstclass dictionary s m their one more key operation with signals is producing them from sources via the signal function which turns a source into a stream that documents changes to the sources contents figure demonstrates these constructs in use in a module implementing a for the module signature declares an abstract type t of we have methods create to allocate a new log append to add a new string to the end of a log and to produce the html representing a log the type of may be in its simplicity urweb html values as in the type of html that in a document body actually are all implicitly parameterized in the dataflow style and they are equipped to themselves after changes to the data sources they depend on the data structure of is an algebraic datatype log which looks almost like a standard definition of lists of strings the difference is that the tail of a nonempty log has type source log rather than just log we effectively have a type of lists that supports imperative replacement of list but not replacement of heads the type t of is a record of two fields field head is a modifiable reference to the current log state and tail is a pointer to a pointer us which source cell we should next to append to the list methods create and append involve a bit of to update these fields properly but we will not on the details we only mention that the point of this complexity is to avoid the whole log each time an entry is instead only a constant amount of work is done per append to modify the document tree at the end of the log that sort of pattern is difficult to implement with pure programming the most interesting method definition is for our prior examples only showed building html fragments that are we create dependencies via an html called dyn the signal attribute of this tag accepts a signal a value us what content should be displayed at this point on the page at different times the signal monad rules out imperative side effects instead capturing pure dataflow programming since it is a monad we have access to the usual monad operations and return in addition to the signal function for lifting sources into signals let us first examine the definition of a recursive function for the type of is log a log as html empty are displayed as empty html fragments and nonempty are with their textual heads followed by recursive of their however the recursive call to is not direct instead it appears inside a dyn we indicate that this depends on the current value of the tail a data source giving the computation to translate from the value to html now it is easy to define mostly just the last part of an important property of this module definition is that a log automatically updates in the browser after every call to append even though we have not coded any explicit between these methods the urweb runtime system takes care of the details once we express via parameterized dataflow client code may use without knowing implementation details the standard web model involves imperative mutation of the document tree which is treated as a public global variable in one code module may subtrees that other modules believe they control for instance subtrees are often up by string id creating the possibility for two different libraries to choose the same id for different subtrees with the urweb model the author of module log may think of it as particular subtrees of the html document as private state standard module encapsulation the underlying data sources from direct modification by other modules and only have dataflow dependencies on the values of those sources classic pure frameworks provide similar advantages but it can be challenging to fit a full application into the model of pure stream transformers in our experience many programmers find the callback style easier to wrap their heads around consider the example of the log module we could express the log creation or method as a function over a stream of requests to append entries however building these streams in practice may be nontrivial forcing explicit of the variety of user actions and network responses that may produce log entries we see an example of multiple sources in the next subsection the usual modularity advantages of mutable state fit well in this domain and they are compatible with maintaining the dataflow part of supports the imperative model via a method for events into any stream even those that we might wish client code saw as readonly but this method is suggested for use only in with code remote procedure calls the for the log is only one half of the if we are to write an application that runs within a single page we also need a way for this application to the server to trigger state modifications and receive updated information first solution to that problem is remote procedure calls allowing client code to run particular function calls as if they were executing on the server with access to shared database state client code only needs to wrap such calls to functions within the rpc keyword and the urweb implementation takes care of all network communication and every rpc appears to execute atomically just as for other kinds of remote calls figure the room module to take advantage of and the log as in ml step through a list applying a function f to each element so that given an initial a and a list x xn the result is f xn f x a apply an effectful function to every element of a list in order the code actually contains few new our basic strategy is for each client to maintain the timestamp of the most recent message it has received the for user input is associated with a allocated source string via the c is for whenever the user structure room sig type id val transaction list id id title string val id transaction page end struct table room id int title string table message room int when time text string val select from room order by new code wrt figure starts here fun id let fun say text dml insert into message room when text values id text select from message where id and order by val fn r acc max acc in title select from room where id initial select from message where id order by text source log source initial return fn r log initial room add message get text set text get rpc say set fn r log hr log end end figure a application modifies the text shown in this box the associated source is automatically to contain the text when the user a to send a message we run the callback code in the attribute on the client whereas the code for this example outside of on attributes runs on the server this code makes an rpc the server both the new message text and the last timestamp that the client knows about the server sends back a list of all messages than that timestamp and client code iterates over that list adding each message to the log and then updates the timestamp accordingly taking advantage of the fact that the rpc result list will never be empty as it always contains at least the message that this client just sent an event handler in the body tag initialized the log in the first place each entry returned by an initial database query note how is the use of the log module we allocate a new log drop its into the right part of the page and fun main tag source image source xml return tag get tag found rpc tag if found then set image xml else return br dyn image figure partial urweb code for example append to it pure programming would require some to the event streams generated as input to the log system from the two syntactically distinct calls to another challenge is effectful into a pure framework supports injection of in pure code with a novel mechanism to allow local computation to continue while waiting for rpc responses it is not clear how to extend such a technique for impure which are useful for precisely the kind of call we use in figure to modify a shared database for pure we can realize similar semantics to merely by in their own threads which write to sources after complete for instance consider the third example from a paper about where users type text into a and an image on the same page updates according to the result of an query to a remote server using the text here is an of the code tags enter a tag tags lift lift tags async tags builtin function makes an http request and builtin function async causes evaluation to run in a separate thread the essential dataflow action in this example is from tags a stream recording successive contents of a created into the details of the http request to be made via we can actually duplicate the same functionality in urweb in an equally pure way by taking advantage of the fact that the html tag already has built into it the idea of a remote server to an image by url a dynamically varying piece of html may simply contain different tags at different times and the browser handles as usual however for a comparison we should consider an interaction that does require some custom logic figure shows urweb code for a variant approach where whenever the contents of the tag change we first ask the server by rpc if any image exists matching that tag if none exists we make no changes to which image is displayed if a match is found we change to the new image using the builtin function url which a remote function call into an abstract type of in this case the url is for a function that computes an image based on input text all of the reactive computation happens inside an handler for the called whenever the text changes the code in figure blocks the whole application while an rpc runs but that problem is easily solved by putting the whole attribute code into a new thread with the spawn keyword that we say more about in the next structure room sig type id val transaction list id id title string val id transaction page end struct table room id int title string table message room int when time text string val select from room order by new code wrt figure starts here table room int chan channel string fun id let fun say text dml insert into message room when text values id text select from where id fn r send text in chan channel dml insert into room chan values id chan title select from room where id initial select from message where id order by text source log return let fun text recv chan log text in spawn fn r log initial end room add message get text set text rpc say hr log end end figure final application tion overall the urweb version of this functionality is more complicated than the version but all of the imperative side effects can be within a module in the style of log from figure creating an observationally pure some functionality like that of the log module itself is inherently easier to with mutable state allowing widely separated parts of a program with their own private state to create data flows into a shared component with no explicit merging their different streams from server to client web make it natural for clients to servers via http requests but the other communication direction may also be useful one example is our application where only the server knows when a client has a new message and we would like the server to all other clients in the same room clients can the server with periodic http requests that the to learn of a new message will not the period realworld applications often use a technique called long where a client a connection and is to wait an arbitrary period of time for the servers response the server can hold all of these connections open until there is a new event to the are in recent with the protocol providing an abstraction of bidirectional streams between clients and servers urweb presents an alternative abstraction implemented with long where servers are able to send typed messages directly to clients the abstraction is by concurrent programming languages like and concurrent ml communication happens over channels every channel has an associated client and a type the server may send any value of that type to the channel which conceptually adds the message to a queue on the client clients receive messages from channels for which they have handles conceptually from local queues blocking when queues are empty any remote call may trigger any number of sends to any number of channels all sends in a single remote call appear to take place atomically atomicity will be important in our example to preserve a consistent global view of message order when many simultaneous may be the same set of clients with different messages the api for channels is straightforward channel type type channel transaction channel recv channel transaction send channel transaction one is that channel and send may only be called in code while recv may only be called in code a compiler analysis makes sure that functions are not called in the wrong places and we have considered changing the types of the basic operations in a future urweb version so that standard type inference verifies properties figure gives another of room this time using channels to keep clients synchronized at all times modulo small amounts of we retain the same room and message tables as before but we also add a new table tracking which clients are for about which thanks to approach to encapsulation of database tables we need not change any other source or configuration files just because we add a new private table every row of has a room id room and a channel chan that is able to receive strings now the method begins by allocating a fresh channel with the channel operation which we immediately insert into compared to figure we drop the timestamp tracking instead the server will use channels to all clients in a room each time a new message is there in particular see the definition of say run an sql query returning columns from just a single table the applying a function to each result in order solely for its imperative side effects the i we loop over all channels associated with the current room sending the new message to each one there is one last change from figure the attribute of our body tag still contains code to run immediately after the page is loaded this time before we initialize the log structure we also create a new thread with the spawn primitive that thread loops forever blocking to receive messages from the created channel and add them to the log threads follow a simple semantics where the programming model says that at any moment in time at most one thread is running across all clients of the application execution only switches to another thread when the current one terminates or executes a blocking operation among which we have and channel recv of course the urweb implementation will run many threads at once with an arbitrary number on the server and one javascript thread per client but the implementation ensures that no behaviors occur that could not also be simulated with the simpler model this simple approach has consequences for program modularity the example of figure only shows a single program module taking advantage of channels it is possible for channels to be used freely throughout a program and the urweb implementation takes care of routing messages to clients while maintaining the simple thread semantics for instance the log module could use channels without the use of channels in room manual approaches require explicit dispatching logic to the different parts of an application waiting for server because in practice a client can only to have one connection active at once figure contains no explicit deallocation of clients that have the urweb implementation detects client using a mechanism when a client the runtime system atomically from the database all references to that clients channels in this respect channels in the database act like weak pointers a database row with a field typed like channel t will be deleted when the client when a row contains a field of type option channel t which may hold either a channel or a null value references to dead channels are merely out all operations described in the last two commute with each other so there is no need to specify the order in which different channel references for a single client are dealt with automatic deletion of channel references provides a kind of modularity similar to what garbage collection provides for objects before up the part of the paper we want to emphasize how this sequence of examples has demonstrated key urweb design principles early in the sequence we on one interface for the room module as we through implementations no changes were required to the main function or any global application configuration file strong encapsulation of module state guarantees that code outside the module cannot distinguish between alternatives throughout all versions of the application we also maintained the simple concurrency abstraction of one thread running at a time with context switches only at welldefined points implementation the urweb compiler is implemented in standard ml in about lines of code it urweb source files to run on the server as native threads via c and on the client as javascript compiled applications are linked with a runtime system with both a server part in about lines of c and a client part in about lines of javascript we summarize here some of the less obvious aspects of the implementation atomic execution of database operations the focus on atomic execution in urweb is inspired by the database of experience with transactions an idea that in that world many database servers support various of atomicity since version has supported atomic transactions in other words it looks to arbitrary database clients as if their sequences of sql operations execute without interference by other threads we using urweb with but it is also possible to use other that do not quite provide transactions at the cost of weakening operational semantics we have been at the absence of programming frameworks that take advantage of or database transactions typically database implement these abstractions with combinations of locking and optimistic concurrency in either case it is possible for operations to failures with locking because of deadlock and with optimistic concurrency because a conflict is detected popular sql client libraries indicate failure as just another error code by any operation applications must check for this code after every operation being to do something sensible when it appears in contrast urweb failures completely any failure in an urweb transaction execution and the transaction the transaction monad is carefully designed so that all side effects may be as necessary the urweb runtime system uses cs to allow to the start of a transaction from arbitrary code running within it since server threads share state only through the database it is easy to run each remote call with a fresh private heap so that heap effects is a operation by hiding failures automatically urweb is able to present to programmers the clean transactional abstraction sketched in the last section message routing with channels it would violate the transactional abstraction to send messages to clients immediately during send operations instead sends are to a threadlocal log at a transactions commit point where all operations have completed without failures we atomically execute all message sends the server may not connect directly to clients to hand off messages instead clients open connections to the server if a client is connected at the point where the server wants to hand off a message the message is written directly to the client and the connection is closed otherwise messages for clients are to buffers maintained per client if a client again when its buffer is nonempty all messages are sent immediately as the http response and the connection is closed the last implicit of message routing is dead channels a mechanism detects dead clients for each application the compiler generates a c function parameterized on a client id to remove all database references to that client whenever a client that c function is run inside a transaction of its own since client data structures may be reused across this use of database transactions with transactions for normal remote calls to ensure that messages are not sent to new clients who have taken over the data structures of intended who have already from the perspective of an atomic remote call any client is either fully present or fully absent for the whole transaction implementing in earlier sections we discussed how urweb html fragments are implicitly instrumented for incremental via the signal monad each fragment is conceptually a function over the current values of all data sources and the runtime system should understand well enough which sources matter for each fragment to avoid of fragments that do not depend on a set of source changes implementing this semantics requires using custom data structures that are transformed and into normal data structures for dynamic html trees called the document object model dom one key data structure appears in the javascript parts of the runtime system rather than representing html fragments as strings we instead use what is an algebraic datatype with constructors the simplest constructor literal html strings a constructor two values finally one constructor a javascript function compiled from urweb code that will be used as an event handler or signal eg in an or dyn signal attribute this datatype is easily forced into normal html code but the explicit closures within it force the javascript garbage collector to keep any objects that the handlers depend on a crucial piece of logic appears in the implementation of the dyn which signals into html fragments the runtime system begins by evaluating the signal with the current data source values producing a value in the datatype from the prior that value is then forced into a normal html string replacing all closure references with reads from positions of a global array where we have the closures in the new dom tree node created from this code we also record which slots in that closure array we have used additionally the signal evaluation process saved the set of sources that were read we only need to the signal if any of these sources change this set of sources is also saved in the new dom node data sources are represented as records containing data values and sets of dom nodes that are for changes whenever a source changes all nodes must be needs to the old html contents of a node including its global closures and removing it and its subtrees from the sets of sources it is precisely to enable this that we save sets of closure slots and sources in each dom node must also update these sets appropriately evaluation in this section we evaluate the effectiveness of the urweb implementation as a practical programming tool considering both performance and programmer we start with a discussion of some and then turn to a summary of urweb applications readers might that higher abstraction level vs frameworks may bring an performance cost we briefly consider performance via where in important cases we find exactly the opposite comparison to less abstract frameworks an urweb solution was entered into the web framework benchmarks a comparison run independently of the author of this paper using benchmark solutions from different including an urweb solution written in part by the author evaluation on of web applications or how many concurrent requests their pieces can handle per second time to service a single request is also measured but not as much on the results pages urweb does particularly on a test with many database writes most frameworks in the do not enforce transactional semantics as urweb does and on every remote call we pay a performance cost for runtime analysis of transactional operations the even higher cost of transaction when there is much contention we hope to the benchmark to add a version of this test where implementations are required to use transactions however on more realistic urweb does very well exactly one test involves actual generation of html pages based on results of database queries on the benchmarks server with hardware threads all running urweb server threads urweb achieves the best ms and the about requests per second among all frameworks this test in round of the benchmarks involved about different configurations of about different frameworks including almost all of the most popular frameworks for realworld applications we think these results are particularly given that our are mostly not running within sql transactions ie they provide weaker semantics that make programming more challenging applications the urweb implementation has been available as open source for long enough to develop a community of users the author of this paper users have several serious urweb applications have also been on the web in this subsection we summarize the ones we are aware of each is written by programmers outside the core urweb development team and there are no duplicate authors among the applications we survey with one exception as noted below table lists the applications and their and authors nearly all of these applications also use function interface for with c and javascript libraries we especially want to the first entry in the table a based on an urweb application reader is a reader for of content via formats like and atom it provides similar functionality to the late reader but with many like reading comments on in the same interface mostly uses reactive features and via our to a database that is kept by a separate haskell as of this writing there are about active users with average load on the application is about with above the urweb source code of reader is available on the next two applications were developed by a single author both relate to the cryptographic the exchange previously allowed to to do the equivalent of domain names within an alternative protocol for name mapping it was recently after years of operation the notes that most similar services were by generic web security problems eg request in that period but the exchange maintained a record the merge pool has been running since a of at its in about of global progress in through this application it serves about requests per second on average this family of applications has mostly sql interface rpc system and interface to connect to implementations of nontrivial cryptographic protocols the big map of is an presentation of that regions history the user moves a to step through time which places various around a map indicating events in categories like and the environment on an an with an illustrated article going into more detail there is also a interface for editing the history database with conventional html forms serves for network hardware devices which connect to the urweb application via an api a more traditional also statistics on recent activity urweb source code is available on is a graphical interface to proofs intended for use in logic to proof problems appear embedded within documents each solution is a tree of deduction steps where the user adds a new step by on the right the trees appear in classic notation the for executing proof steps is the coq proof assistant invoked via and the with some haskell code involved most of these applications developers have no special connection to the urweb development team so their decisions to adopt urweb provide some validation of the language design we developers what they saw as the positive and negative points of urweb there was a clear consensus that the plus was the simple model for coding that interact easily with code the most mentioned point was the way that the urweb compiler checks that code does not call functions that only make sense in the client or vice versa in designing the language we were that it would be too complex to extend the type system to track such constraints tagging monadic computation types with information however the approach we adopted instead with adhoc static analysis on whole programs at compile time leads to error messages that even urweb programmers in general improvements to error messages and performance of the compiler which does specialized optimization are high on our list of future one of the main for designing the ur language was supporting complex with detailed compiletime checking of inspired by dependent type theory as far as we know the production urweb applications are currently making only use of eg for small convenience operations related to polymorphic record and variant types the html and sql encodings make extensive use of features that go beyond those of ml and haskell but there has not yet been much direct adoption of such features outside the urweb standard library related work was an early domainspecific language for safe programming of web applications the compiler did static verification of html validity and of compatibility between forms and handlers included no features for building libraries of abstractions as it together forms and handlers via fixed sets of template files web application systems make a different set of tradeoffs than urweb does in supporting abstraction the plt scheme web server provides completely firstclass sup application reader big map of merge pool exchange now url author daniel double double z yang table urweb applications port for making it very easy to construct many useful abstractions this platform works without a static type system the of many programmers as a consequence however many kinds of strong encapsulation are impossible for instance the ability of programs to generate arbitrary html and javascript as strings means that any component discipline can be provides strong encapsulation guarantees at the of not continuations as firstclass component system also only runs code uses the normal javascript model with the document exposed as a mutable global variable with subtrees assigned names from a global as far as we are aware no systems give persistent resources like database tables firstclass status which prevents encapsulation of these resources that design decision makes it easier to build on top of existing programming languages and provide simpler libraries we expect that different developers will prefer different positions in this design space we hope that many of strong encapsulation in objectoriented and functional languages will prefer the style in this paper we have not found any previous of that style so part of our in this paper is to add such a to the larger mutable state enables new modularity disciplines web cells are a variant of mutable references implemented in the plt web server that provide the abstraction of each web page having its own copy of the heap while efficient implementation initial web cells implementations only with storage of all continuations which imposes significant storage requirements more recent work has shown how to represent continuations enough that these continuations may be in full within more static approach makes it possible for an algorithm to find all possible entry points to an application enabling rigorous verification and testing as in some past work doing static analysis on urweb code for security while the plt approach is more lightweight and easier for programmers to learn the links language strong static checking of web applications where the code for all is collected in a single language where urweb includes explicit eg rpc of control transfer between client and server links follows a more implicit approach where different firstclass functions are tagged as belonging to different sides and are automatically run on those sides when called links also includes a novel means of abstraction for html forms based on idioms still much of urweb is inspired closely by links and can be thought of as modularity features upon that foundation links does not include a module system or other for type abstraction and any piece of links code may access any database table or dom subtree by referring to its textual name some other similar systems have been presented including which is a java extension based around new types and program analysis is another unified web programming language this time dynamically typed and based on scheme many elements are quite similar to the patterns demonstrated in our urweb examples including a simple rpc syntax to server called services and a and convention for easy of server and code interaction follows the usual browser model where a page is a mutable tree that can be arbitrarily by any code is based on no distinguished database integration instead supporting access to a variety of database systems via libraries servers support a novel means of concurrency for pipeline execution but we do not believe that any model has been implemented and it does not seem obvious how to implement such a configuration without more fundamental language support the extension uses synchronous reactive programming to support a different declarative style of interactions between stages of processes that span clients and servers is an platform for building dynamic web sites in a unified language with static typing that rules out many potential programming the concurrency model is on both client and server the includes libraries for both statically typed sql database access and message passing the latter via a mechanism called there is no support for the two sorts of actions into transactions rather the semantics is the usual interleaving one with points the sql library also allows arbitrary access to any table from any module that knows its string name even allowing different modules to declare different versions of a table with different incompatible types there is optional library support for a programming style the language is another statically typed unified language for web applications its database integration is with the system which does not support transactions so inherits a semantics that interleaving of concurrent requests supports a to the sort of database table encapsulation that we have described where modules may declare private components of the database state however the mechanism forces programmers to assign components names in a global the compiler will prevent duplicate use of a name which against encapsulation but which also forces authors of different modules to coordinate on a naming scheme similar issues arise in use of a mostly standard model of where elements are assigned textual names in a global and where the visible page is changed by elements directly strong encapsulation has been supported through capability systems including the system for web is built on top of java so compared to urweb it provides an easier migration path for programmers however does not support database access and among and other persistent values that are supported true encapsulation is not possible the reason is that a application must contain trusted code to persistent resources to components which implies that a component must know which resources its use in urweb components use special declarations like table to in effect their initial capability sets in a static and modular way some subsets of javascript have been proposed including formal analysis using operational semantics has holes in some of these languages and suggested practical formal conditions that guarantee absence of holes that line of work is complementary to our approach from this paper as it provides a simple foundation without which abstractions should be built on it with current implementation we depend on the fact that all modules are compiled from urweb source instead we could target some common safe javascript subset ensuring safe with components built directly in javascript or with other compilers several other languages and frameworks support programming for web including which is available in one as a javascript library and a new programming language these libraries implement the original pure version of programming where key parts of programs are written as pure functions that transform input streams into streams of visible content such a style is elegant in many cases but it does not seem compatible with the modularity patterns we demonstrated in section where it is natural to input sources to a single stream across different parts of a program urweb supports that kind of modularity by a hybrid model with imperative event callbacks that trigger of pure code as far as we are aware urweb was the first web programming tool to support impure programming but the idea of reactive programming in javascript is now and too many frameworks exist to detail here one popular javascript framework is distinguished by its support for a particular reactive programming style it well with web development tools and libraries which is a nontrivial advantage for most programmers its standard database support is for with no transactional abstraction or other way of simultaneous complex state updates like allows modules to named database elements but an exception is if two modules have chosen the same string name for their elements module authors must coordinate on how to divide a global supports automatic of database changes into caches and then from those caches into pages in addition to automatic updating of pages based on state changes a standard api for document structure and making changes is provided though it is not very machinery for reactive page updating involves a more complex api than in urweb its central concept is of imperative functions that need to be when any of their dependencies change where urweb describes reactive computations in terms of pure code within the signal monad such that it is easy to only part of a computation when not all of its dependencies have changed forcing purity on these computations helps avoid the consequences of side effects being repeated on each change to dependencies the lines of code the start of section together with the dyn give the complete interface for reactive programming in urweb in contrast with of pages of documentation of dynamically typed functions for other popular javascript frameworks include and a among these libraries seems to be approaches to the basic structure of reactive with builtin concepts of models views templates components etc in contrast urweb has its line api of sources and signals these javascript frameworks tend to force elements of reactive state to be explicitly as fields of some distinguished object instead of allowing data sources to be allocated dynamically throughout the modules of a program and kept as private state of those modules is another recent web language design intended to to allows client code to manipulate distributed data structures directly applying techniques automatically to enforce eventual consistency consequences of such changes flow automatically into affected parts of documents in a style allowing direct manipulation of data structures by clients raises security concerns which urweb avoids by all such through from client to server running code in a trusted environment where appropriate checks may be applied with the to use channels to clients of updates in a globally consistent order in general the model seems for to web programming while urweb offers better in a few the transactional abstraction has also been exposed in highlevel programming languages via the software transactional memory model for instance in ghc haskell such systems provide a transactional interface over the classic model of mutable linked objects in a heap transaction monad is actually much closer to the original idea of transactions from databases the only mutable state in an urweb application is in the sql database where columns have only primitive types and in message queues of channels so there is no need to do eg conflict analysis on traces of accesses to data structures conclusion we have presented the design of urweb a programming language for web applications focusing on a few ideas that apply to a class of distributed applications our main is to two that programmers should be for in their web frameworks but which seem almost absent from discussion first while practice is further away from the conceptual simplicity of transactions and atomic execution of units of concurrent work we suggest holding on to simple concurrency models unless forced away from them by performance concerns second while encapsulation is widely for conventional data structures we suggest that it to be generalized to key pieces of web applications like database tables and html subtrees familiar benefits with new urweb is already being used in serious production applications and we hope languages our principles can continue to help programmers realize nontrivial functionality with less effort and more in correctness acknowledgments for their bug reports feature requests and we thank the early of urweb including the application authors earlier but also many others we also thank liskov and the anonymous for their helpful feedback on of this paper this work has been supported in part by national science foundation grant references j ­ a survey of the language and its applications in proc pages ­ d t ball m g k p and k experience with a domain specific language for services in proc v typing web interaction with objective caml in proc ml workshop v j and b experience report a web programming framework in proc icfp pages ­ acm g and m and web in proc pages ­ s m p de s m n and j its continuous feedback in ui programming in proc pldi pages ­ acm j s and p wadler a practical theory of query in proc icfp pages ­ acm a ur with typelevel record computation in proc pldi pages ­ acm a static checking of security policies in applications in proc pages ­ a s a and m i extending java for highlevel web service construction toplas ­ november e cooper s p wadler and j links web programming without in proc pages ­ e cooper s p wadler and j the essence of form abstraction in proc pages ­ springerverlag e e cooper and p wadler the rpc calculus in proc pages ­ acm e and s asynchronous functional reactive programming for in proc pldi pages ­ acm s a and l ­ a multiple control flow web application framework in european smalltalk user group ­ research track a ocaml in proc icfp pages ­ acm j gray the transaction concept and limitations paper in proc pages ­ t s s and m composable memory transactions in proc pages ­ acm h j and b c pierce regular expression types for xml in proc icfp pages ­ acm s p w j p t g and m felleisen implementation and use of the plt scheme web server higher order symbol comput ­ a a and d finegrained separation for web applications in proc h m computer systems ma usa isbn d macqueen modules for standard ml in proc lfp pages ­ acm s j mitchell and a object capabilities and isolation of untrusted web applications in proc ieee sp pages ­ j automatically web applications or marking modular continuations in proc icfp acm j and s state for the web in proc scheme and functional programming e b and g objects relations and xml in the net framework in proc pages ­ acm l a a j g h cooper m a and s a programming language for applications in proc oopsla pages ­ acm s l peyton jones and p wadler imperative functional programming in proc popl pages ­ acm d r k ports and k isolation in proc ­ aug j h concurrent programming in ml cambridge university press isbn m a fast server for the web in proc coordination pages ­ springerverlag m e and f a language for programming the web in proc n and d software transactional memory in proc pages ­ acm n m j de and m programming mobile devices via in proc pages ­ acm j lwt a thread library in proc ml workshop pages ­ acm p wadler and s how to make adhoc polymorphism less ad hoc in proc popl pages ­ acm 