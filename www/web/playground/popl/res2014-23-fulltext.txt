replicated data types specification verification optimality microsoft research software institute yang university of oxford inria abstract distributed systems often rely on replicated eventually consistent data stores to achieve availability and performance to resolve conflicting updates at different researchers and have proposed specialized consistency protocols called replicated data types that implement objects such as registers counters sets or lists reasoning about replicated data types has however not been on par with comparable work on abstract data types and concurrent data types specifications correctness proofs and optimality results to fill in this gap we propose a framework for specifying replicated data types using relations over events and verifying their implementations using simulations we apply it to existing implementations of data types with nontrivial strategies and optimizations register counter register and set we also present a novel technique for obtaining lower bounds on the worstcase space overhead of data type implementations and use it to prove optimality of implementations finally we show how to specify consistency of replicated stores with multiple objects in analogy to prior work on weak memory models overall our work provides foundational reasoning tools to support research on replicated eventually consistent stores categories and subject descriptors d software engineering verification f logics and meanings of programs specifying and verifying and reasoning about programs keywords replication eventual consistency weak memory introduction to achieve availability and scalability many computing systems rely on replicated stores allowing multiple clients to issue operations on shared data on a number of which communicate changes to each other using message passing for example services rely on which places data in distinct locations and applications for mobile devices store locally to support offline use one benefit of such architectures is that the remain locally available to clients even when network connections fail unfortunately the cap theorem shows that such high availability and to network partitions are incompatible with strong consistency ie the of a single replica handling all operations for this reason modern replicated stores often permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm provide weaker forms of consistency commonly eventual consistency eventual usually refers to the guarantee that if clients stop update requests then the will eventually reach a consistent state eventual consistency is a hot research area and new replicated stores implementing it appear every year unfortunately their semantics is understood the very term eventual consistency is a and different stores to be eventually consistent actually provide different guarantees the property which is a form of consistency is too weak to capture these although it requires the to converge to the same state eventually it doesnt say which one it will be furthermore does not provide any guarantees in realistic scenarios when updates never stop the difficulty of reasoning about the behavior of eventually consistent stores comes from a of choices to be made in their design some of which we now explain allowing the to be inconsistent enables eventually consistent stores to satisfy clients requests from the local replica immediately and broadcast the changes to the other only after the fact when the network connection permits this however this means that clients can concurrently issue conflicting operations on the same data item at different furthermore if the are these operations will be applied to its copies in different states for example two users sharing an online store account can write two different codes into the address the same users connected to with different views of the can also add and concurrently remove the same product in such situations the store needs to ensure that after the exchange updates the changes by different clients will be merged and all conflicts will be resolved in a meaningful way furthermore to ensure eventual consistency the conflict resolution has to be uniform across so that in the end they converge to the same state the protocols achieving this are commonly within replicated data types that implement objects such as registers counters sets or lists with various strategies the strategies can be as simple as establishing a total order on all operations using timestamps and letting the last writer but can also be much more subtle thus a data type can detect the presence of a conflict and let the client deal with it eg the register used in store would return both conflicting codes in the above example a data type can also resolve the conflict in an way for example the set processes concurrent operations trying to add and remove the same element so that an add always an outcome that may be appropriate for a replicated data type implementations are often nontrivial since they have to maintain not only object state but also metadata needed to detect and resolve conflicts and to handle network failures this makes reasoning about their behavior challenging the situation gets only worse if we consider ple replicated objects in this case asynchronous propagation of updates between may lead to behaviors in database terminology the following code illustrates an in real replicated stores replica r i comment replica r j empty we have two clients reading from and writing to register objects x and y at two different i and j are variables the first client makes a post by writing to x at replica r and then comments on the post by writing to y after every write replica r might send a message with the update to replica r if the messages carrying the writes of post to x and comment to y arrive to replica r out of the order they were in the second client can see the comment but not the post different replicated stores may allow such an or not and this has to be taken into account when reasoning about them in this paper we propose techniques for reasoning about eventually consistent replicated stores in the following three areas specification we propose a framework for specifying the semantics of replicated stores its key novel component is replicated data type specifications § which provide the first way of specifying the semantics of replicated objects with advanced conflict resolution like abstract data types we achieve this by defining the result of a data type operation not by a function of states but of operation contexts sets of events the result of the operation together with some relationships between them we show that our specifications are sufficiently flexible to handle data types representing a variety of strategies register counter register and set we then specify the semantics of a whole store with multiple objects possibly of different types by consistency axioms § which constrain the way the store processes incoming requests in the style of weak models and thus define the allowed as an illustration we define consistency models used in existing replicated stores including a weak form of eventual consistency and different kinds of consistency we find that when specialized to registers these specifications are very close to fragments of the cc memory model thus our specification framework generalizes axiomatic models to replicated stores with nontrivial conflict resolution verification we propose a method for proving the correctness of replicated data type implementations with respect to our specifications and apply it to existing implementations of the four data types mentioned above including those with nontrivial optimizations reasoning about the implementations is difficult due to the highly concurrent nature of a replicated store with multiple simultaneously updating their object copies and messages we address this challenge by simulations § like classical simulations from data refinement these associate a concrete state of an implementation with its abstract on events in our case to the complexity of replication they consider the state of an object at a single replica or a message in separately and associate it with abstract descriptions of only those events that led to it verifying an implementation then requires only reasoning about an instance of its code running at a single replica here however we have to deal with another challenge code at a single replica can access both the state of an object and a message at the same time eg when updating the former upon receiving the latter to reason about such code we often need to rely on certain agreement properties the abstract descriptions of the message and the object state establishing these properties re global reasoning fortunately we find that agreement properties needed to prove realistic implementations depend only on basic facts about their behavior and can thus be established once for broad classes of data types then a particular implementation within such a class can be verified by reasoning purely locally by carefully structuring reasoning in this way we achieve easy and intuitive proofs of single data type implementations we then lift these results to stores with multiple objects of different types by showing how consistency axioms can be proved given properties of the layer and data type implementations § optimality replicated data type designers to optimize their implementations knowing that one is optimal can help guide such efforts in the most promising direction however proving optimality is broad as it requires over all possible implementations satisfying the same specification for most data types we studied the primary optimization target is the size of the metadata needed to resolve conflicts or handle network failures to establish optimality of metadata size we present a novel method for proving lower bounds on the worstcase metadata overhead of replicated data of metadata relative to the content the main idea is to find a large family of executions of an arbitrary correct implementation such that given the results of data type operations from a certain fixed point in any of the executions we can recover the previous execution history this implies that across executions the states at this point are distinct and thus must have some minimal size using our method we prove that four of the implementations we verified have an optimal worstcase metadata overhead among all implementations satisfying the same specification two of these counter register are wellknown one optimized set is a recently proposed nontrivial optimization and one optimized register is a small improvement of a known implementation that we discovered during a failed attempt to prove optimality of the latter we summarize all the bounds we proved in fig we hope that the theoretical foundations we develop will help in exploring the design space of replicated data types and replicated eventually consistent stores in a systematic way replicated data types we now describe our formal model for replicated stores and introduce replicated data type implementations which implement operations on a single object at a replica and the protocol used by to exchange updates to this object our formalism follows closely the models used by replicated data type designers a replicated store is organized as a collection of named objects obj x y z each object is at all r s the sets of objects and may be infinite to model their dynamic creation clients interact with the store by performing operations on objects at a specified replica each object x obj has a type type whose type signature op val determines the set of supported operations op ranged over by o and the set of their return values val ranged over by a b c d we assume that a special value val belongs to all sets val and is used for operations that return no value for example we can define a counter data type ctr and an integer register type with operations for reading or writing an integer a z rd inc and rd a z we also assume sets message of messages ranged over by m and timestamps timestamp ranged over by t for simplicity we let timestamps be positive integers timestamp n definition a replicated data type implementation for a data type is a tuple d m do send receive where figure of a concrete a and two abstract executions b c r send r a r vis b receive vis to r send vis c vis receive receive vis m message and do op × × timestamp × val send × m receive × m we denote a component of d such as do by d do a tuple d defines the class of implementations of objects with type meant to be instantiated for every such object in the store is the set of states ranged over by used to represent the current state of the object including metadata at a single replica the initial state at every replica is given by d provides three methods that the rest of the store implementation can call at a given replica we assume that these methods execute atomically we store executions resulting from repeated calls to the methods as in fig a by the calls on several vertical corresponding to at which they occur and denoting the of messages by diagonal arrows in § we formalize them as sequences of transitions called concrete executions and define the store semantics by their sets the intuition given by fig a should suffice for the following discussion a client request to perform an operation o op the call t eg event in fig a this takes the current state of the object at the replica where the request is and a timestamp t timestamp provided by the rest of the store implementation and produces the updated object state and the return value of the operation the data type implementation can use the timestamp provided eg to implement the strategy mentioned in § but is free to ignore it nondeterministically in when the network is able to accept messages a replica calls send given the current state of the object at the replica send produces a message in m to broadcast to all other event in fig a sometimes send also the state of the object using broadcast rather than communication does not limit generality since we can always tag messages with the intended receiver another replica that receives the message generated by send calls receive to merge the update into its copy of the object state event in fig a we now three replicated data type implementations due to shapiro et al they fall into two categories in implementations each message carries a description of the operations that the sender has performed and in statebased implementations a description of all operations it knows about counter ctr fig a shows an implementation of the ctr data type a replica stores a pair a d where a is the current value of the counter and d is the number of increments performed since the last broadcast we use brackets for tuples representing states and messages the send method returns d and it the receive method adds the content of the message to a this implementation is correct as long as each message is exactly once we show how to prove this in § since inc operations commute they never conflict applying them in different orders at different yields the same final state statebased counter ctr the implementation in fig b summarizes the currently known history by recording the figure three replicated data type implementations a counter ctr n × n m n r a d t a d a a d t a d send a d a d receive a d d a d d b statebased counter ctr × n r r s m n r v t r v vs s r v t r vr vr send r v r v v receive r v v r s v s c statebased register z × timestamp r m a t t a t a a t t if t t then a t else a t send a t a t a t receive a t a t if t t then a t else a t of every replica to the counter value separately of vector clocks a replica stores its identifier r and a vector v such that for each replica s the entry vs gives the number of increments made by clients at s that have been received by r a rd operation returns the sum of all entries in the vector an inc operation increments the entry for the current replica we denote by vi j the function that has the same value as v everywhere except for i where it has the value j the send method returns the vector and the receive method takes the maximum of each entry in the vectors v and v given to it this is correct because an entry for s in either vector reflects a prefix of the sequence of increments done at replica s hence we know that v s increments by s are taken into account both in vs and in v s statebased register unlike counters registers have update operations that are not commutative to resolve conflicts the implementation in fig uses the strategy creating a total order on writes by associating a unique timestamp with each of them a state contains the current value returned by rd and the timestamp at which it was written initially we have instead of a timestamp a compares its timestamp t with the timestamp t of the current value a and sets the value to the one with the timestamp note that here we have to allow for t t since we do not make any assumptions about timestamps apart from uniqueness eg the rest of the store implementation can compute them using physical or lamport clocks we show how to state assumptions about timestamps in § the send method just returns the state and the receive method chooses the winning value by comparing the timestamps in the current state and the message like wr statebased vs statebased implementations converge to a consistent state faster than implementations because they are meaning that they can propagate updates indirectly for example when using the counter in fig b in the execution in fig a the read at r event returns even though the message from r has not yet because r about rs update via r statebased implementations are also against failures like message loss reordering or duplication implementations require the replicated store using them to mask such failures eg using message sequence numbers buffers or buffers the potential of statebased implementations is the size of states and messages which our of space optimality in § for example we show that the counter in fig b is optimal meaning that no counter implementation satisfying the same requirements transitive and against message loss reordering and duplication can do better specifying replicated data types and stores consider the concrete execution in fig a what are valid return values for the read in event intuitively or can be but not we now present a framework for specifying the expected outcome without referring to implementation details for example we give a specification of a replicated counter that is satisfied by both implementations in fig a b in presenting the framework we rely on the intuitive understanding of the way a replicated store executes given in § later we define the store semantics formally § which lets us state what it means for a store to satisfy our specifications § and § abstract executions and specification structure we define our specifications on abstract executions which include only events corresponding to do calls and describe the other information about the store processing in an form informally we consider a concrete execution correct if it can be justified by an abstract execution satisfying the specifications that is similar to it and in particular has the same operations and return values abstract executions are inspired by axiomatic definitions of weak models in particular we use their previously proposed with visibility and relations which are similar to the and coherence relations from weak models we provide a comparison with models in § and with in § definition an abstract execution is a tuple a e repl obj ro vis ar where · e event is a set of events from a countable universe event · each event e e describes a replica performing an operation on an object obj which returns the value · ro e × e is a replica order which is a union of transitive and total orders on events at each replica · vis e × e is an acyclic visibility relation such that e f e e vis f · ar e × e is an relation which is a union of transitive and total orders on events on each object we also require that ro vis and ar be wellfounded in the following we denote components of a and similar structures as in we also use e f r and e r f informally e vis f means that f is aware of e and thus es effect can influence f s return value in implementation terms this may be the case if the update performed by e has been to the replica performing f before f is the exact meaning of however depends on how much information messages carry in the implementation for example as we explain in § the return value of a read from a counter is equal to the number of inc operations visible to it then as we formalize in § the abstract execution illustrated in fig b the implementation in fig a reading in the concrete execution in fig a the abstract execution in fig c the statebased implementation in fig b reading due to transitive § there is no abstract execution that would justify reading the ar relation represents the comment ordering information provided by ro ar vis ro the store eg via timestamps on the right we show an ab empty execution corresponding to ro vis a variant of the the ar edge means that any replica that both writes to x should assume that post empty we give a store specification by two components abstract executions replicated data type specifications determine return values of operations in an abstract execution in terms of its vis and ar rela tions and thus define policies for individual objects in the store the specifications are the key novel component of our framework and we discuss them next consistency axioms constrain vis and ar and thereby and extend the semantics of individual objects to that of the entire store we defer their discussion to § see fig for their in particular the above each of these components can be separately and our spec will define the semantics of any possible combination given a specification of a store we can determine whether a set of events can be observed by its users by checking if there is an abstract execution with this set of events satisfying the data type specifications and consistency axioms replicated data type specifications in a sequential setting the semantics of a data type can be specified by a function s op val which given a nonempty sequence of operations performed on an object specifies the return value of the last operation for a register read operations return the value of the last preceding write or zero if there is no prior write for a counter read operations return the number of preceding increments thus for any sequence of operations rd a if wr and does not contain wr operations rd the number of inc operations in inc in a replicated store the is more interesting we specify a data type by a function f generalizing s just like s this determines the return value of an operation based on prior operations performed on the object however f takes as a parameter not a sequence but an operation context which includes all we need to know about a store execution to determine the return value of a given operation set e of all events that are visible to o together with the operations performed by the events and visibility and relations on them definition an operation context for a data type is a tuple l o e vis ar where o op e is a finite subset of event e op vis e × e is acyclic and ar e × e is transitive and total we can extract the context of an event e ae in an abstract execution a by selecting all events visible to it according to e g where g and is the restriction to events in g thus in the abstract execution in fig b the operation context of the read from x includes only one increment event in the execution in fig c it includes two definition a replicated data type specification for a type is a function f that given an operation context l for specifies a return value f l val note that f o returns the value resulting from performing o on the initial state for the data type eg for the we specify multiple data types used in a replicated store by a partial function f mapping them to data type specifications definition an abstract execution a satisfies f written a f if the return value of every event in a is computed on its context by the specification for the type of the object the event accesses e ae e we specify a whole store by f and a set of consistency axioms § this lets us determine if its users can observe a given set of events by checking if there is an abstract execution with these events that satisfies f according to the above definition as well as the axioms note that f is deterministic this does not mean that so is an outcome of an operation on a store rather that all the nondeterminism arising due to its distributed nature is resolved by vis and ar in the context passed to f these relations are chosen arbitrarily subject to consistency axioms due to the property two events that perform the same operation and see the same set of events produce the same return values as we show in § this property ensures that our specifications can formalize eventual consistency in the sense of we now give four examples of data type specifications corresponding to the four strategies mentioned in § and § operations commute so no conflicts arise last writer all conflicting values are returned and conflicts are resolved in an way we start by specifying the data types whose implementations we presented in § counter ctr is defined by e vis ar e vis ar e e inc thus according to def the executions in fig b and c satisfy the counter specification both and are valid return values for the read from x when there are two concurrent increments is defined by e vis ar where denotes the sequence obtained by ordering the operations performed by the events in e according to ar thus the return value is determined by establishing a total order of the visible and applying the regular sequential semantics for example by def in the example execution from § the read from x has to return empty if we had a vis edge from the write of post to the read from x then the read would have to return post as we show in § weak models are obtained by our framework to stores with only we can obtain a concurrent semantics f of any data type based on its sequential semantics s similarly to for example defined above is equivalent to what we obtain using this generic construction the next two examples go beyond this register this register has the same operations as the but its reads return a set of values e vis ar a e e e wr e vis f we write for an expression whose value is irrelevant a read returns the values written by currently conflicting writes defined as those that are not in vis by later writes ar is not used for example a rd would return in the context on the right wr vis wr vis vis wr wr figure the set of configurations and the transition relation d × event × for a data type library d we use e h u h u to abbreviate he u and he u we r where convenient obj x obj xx × obj × d m × t a e act do obj x repl r o time t a rx r t ed rx r t m mid e act send obj x repl r msg mid rx r t ed rx r t mid r x m m rr e act receive obj x repl r r msg mid rx r t mid r x m ed rx r t mid r x m set how do we specify a replicated set of integers the operations of adding and removing different elements commute and thus do not conflict conflicts arise from concurrently adding and removing the same element for example we need to decide what rd will return as the contents of the set in the context rd e f vis ar where add and remove if we use the generic construction from the the result will depend on the relation if e ar f and otherwise an application may require a more consistent behavior eg that an add operation always against concurrent remove operations or set achieves this by that remove operations only the add operations that are visible to them e vis ar a e e e e vis f in the above operation context rd will return if e vis f and otherwise the is that in the former case add and remove are not concurrent the user who the remove that was in the set and thus meant to remove it in the latter case the two operations are concurrent and thus add as the above examples illustrate our specifications can describe the semantics of data types and their policies without referring to the of their implementations in this sense the specifications generalize the concept of an abstract data type to the replicated setting store semantics and data type correctness a data type library d is a partial mapping from types to data type implementations d from def we now define the semantics of a replicated store with a data type library d as a set of its concrete executions previously introduced informally by fig a we then state what it means for data type implementations of § to satisfy their specifications of § by requiring their concrete executions to be justified by abstract ones in § we generalize this to the correctness of the whole store with multiple object with respect to both data type specifications and consistency axioms semantics we define the semantics using the relation d × event × in fig which describes a single step of the store execution the relation transforms configurations r t describing the store state r gives the object state at each replica and t the set of messages in between them each identified by a message identifier mid a message is annotated by the origin replica and the object to which it we allow the store to contain only some objects from obj and thus allow r to be partial on them we use a number of functions on events such as act obj etc to record the information about the corresponding transitions so that d is implicitly parameterized by them we give their full list in def below the first rule in fig describes a replica r performing an operation o on an object x using the do method of the corresponding data type implementation we record the return value using the function to communicate the change to other we can at any time perform a transition defined by the second rule which puts a new message m created by a call to send into the set of messages in the third rule describes the of such a message to a replica r other than the origin replica r which a call to receive note that the relation d does not make any assumptions about message messages can be in any order multiple times or not at all these assumptions can be introduced separately as we show later in this section a concrete execution can be thought of as a finite or infinite sequence of transitions r t e r t e en rn tn where all events ei are distinct to ease mapping between concrete and abstract executions in the future we formalize it as a structure on events similarly to def definition a concrete execution of a store with a data type library d is a tuple c e eo pre post act obj repl time msg here e event the execution order eo is a wellfounded transitive and total order on e relating the events according to the order of the transitions they describe time is injective and pre post e form a valid sequence of transitions e e e d e f e e eo f e eo g eo f we have omitted the types of functions on events which are easily inferred from fig eg act e do send receive and time e timestamp defined only on e with do we denote the initial configuration of c by where e is the minimal event in if ce is finite we denote the final configuration of c by where ef is the maximal event in the semantics d of d is the set of all its concrete executions c that start in a configuration with an empty set of messages and all objects in initial states ie x obj x x where is the function layer specifications data type implementations such as the counter in fig a can rely on some guarantees concerning the of messages by the rest of the store implementation they may similarly assume certain properties of timestamps other than uniqueness guaranteed by the of time in def we take such assumptions into account by only a subset of executions from d that satisfy a layer specification t which is a predicate on concrete executions thus we consider a replicated store to be defined by a pair d t and the set of its executions be d t even though our definition of t lets it potentially restrict data type implementation the particular instantiations we use only restrict message and timestamps for technical reasons we assume that t always satisfies certain closure properties for every c t the projection of c onto events on a given object or a subset of events forming a prefix in the eo order is also in t as an example we define a layer specification ensuring that a message is to any single replica at most once as required by the implementation in fig a let the relation ce × ce pair events sending and receiving the same message e f e f send receive then the desired condition on concrete executions c is e f g ce e f e g f g data type implementation correctness we now state what it means for an implementation d of type from def to satisfy a specification f from def to this end we consider the behavior of d under the most general client and layer performing all possible operations and message formally let d be the set of executions c d of a store containing a single object x of a type with the implementation d ie r for some r such that x then d should satisfy f under a specification t if for every concrete execution c d t we can find a similar abstract execution satisfying f and in particular having the same operations and return values as it happens all components of the abstract execution except visibility are straightforwardly determined by c as explained in § we have some freedom in choosing visibility we define the choice using a visibility witness v which maps a concrete execution c d to an acyclic relation on defining visibility here is the restriction to events e with do let e f e f e arc f e f then the abstract execution c d is defined by v vc arc definition a data type implementation d satisfies a specification f with respect to v and t written d t f if c d t v f where is defined in def as we explained informally in § the visibility witness depends on how much information the implementation puts into messages since statebased implementations such as the ones in fig b c are § for them we use the witness by the definition of and is acyclic so is welldefined statebased implementations do not make any assumptions about the layer in this case we write t in contrast implementations such as the one in fig a require t since such implementations are not the witness is not appropriate for them we could attempt to define a witness for them by straightforwardly lifting the relation e f e f e f e e f f however we need to be more careful since for implementations e e f f does not ensure that the update of e is taken into account by f if there is another send event e in between e and e then e will capture the update of e and e will not hence we define the witness as e f e f e f e e f f e e e send we next present a method for proving data type implementation correctness in the sense of def in § we lift this to stores with multiple objects and take into account consistency axioms proving data type implementations correct the straightforward approach to proving correctness in the sense of def would require us to consider global store configurations in executions c including object states at all and all messages in making the reasoning and to deal with this challenge we focus on a single component of a store configuration using simulation relations rr and m analogous to simulation relations used in data refinement the rr relation associates the object state at a replica r with an abstract execution that describes only those events that led to this state m does the same for a message for example when proving in fig b with respect to in m associates a message carrying a vector v with executions in which each replica s makes vs increments as part of a proof of d we require checking that the effect of its methods such as d do can be simulated by appropriately transforming related abstract executions while preserving the relations we define these transformations using abstract methods do send and receive as illustrated in fig a b for example if a replica r executes d do from a state related by rr to an abstract execution i we explain the use of i instead of a later we need to find an i related by rr to the resulting state we also need to check that the value returned by d do on is equal to that returned by f on i these conditions consider the behavior of an implementation method on a single state andor message and its effect on only the relevant part of the abstract execution however by the reasoning in this way we lose some global information that is actually required to verify realistic implementations in particular this occurs when the obligation for receive in fig b taking a global view and m there are meant to come from the same configuration in a concrete execution c i and j are meant to be fragments of the same abstract execution v in this context we may know certain agreement properties i and j eg that the union of their visibility relations is itself a wellformed visibility relation and is thus acyclic establishing them requires global reasoning about whole executions c and v fortunately we find that this can be done knowing only the abstract methods not the implementation d furthermore these methods state basic facts about the behavior of implementations and are thus common to broad classes of them such as statebased or this allows us to establish agreement properties using global reasoning once for a given class of implementations at this stage we can also benefit from the layer specification t and check that the abstract methods construct visibility according to the given witness v then a particular implementation within the class can be verified by local obligations such as those in fig a b while assuming agreement properties this yields easy and intuitive proofs to summarize we deal with the challenge by a distributed data type implementation by reasoning about it into figure diagrams simulations a io do io rr rr d do b io j receive io rr rr m d receive c do ed do g c g e c global reasoning done once for a broad class of implementations and local reasoning we start by present ing the general form of obligations to be for a single implementation within a certain class § and the particular form they take for the class of statebased implementations § together with some examples § we then formulate the obligations to be for a class of implementations § which in particular establish the agreement properties assumed in the obligations in we give the obligations for implementations together with a proof of the counter in fig a an reader can move on to § after § and come back to § later since def considers only executions we fix an object x of type and consider only concrete and abstract executions over x whose sets we denote by and simulations as is typical for proofs we need to use auxiliary state to record information about the computation history for this reason actually our simulation relations associate a state or a message with an instrumented pair a of an abstract execution a and a function ae tagging events with auxiliary information from a set as we show below can be chosen once for a class of data type implementations eg timestamp for statebased ones § we use i and j to range over instrumented executions and eg to ie for a partial function h we write hx for x domh and adopt the convention that hx y implies hx definition a simulation between d and f with respect to and abstract methods do send and receive is a collection of relations rr m r satisfying the conditions in fig here and abstract methods are meant to be fixed for a given class of implementations such as state or to prove a particular implementation within this class one needs to find simulation relations satisfying the conditions in fig for example as we show in § the following relation lets us prove the correctness of the counter in fig b with respect to and abstract methods appropriate for statebased implementations s v rr i r s v m i v m e repl obj ro vis ar s vs e e inc s init in fig associates the initial state at a replica r with the execution having an empty set of events do send and receive formalize the obligations illustrated in fig a b note that do is parameterized by an event e required to be fresh in instantiations and the information about the operation performed the abstract methods are partial and the obligations in fig assume that their applications are defined when instantiating receive for a given class of implementations we let it be defined only when its arguments satisfy the agreement property for this class which we establish separately § while doing this we can also establish some execution invariants holding of single ex figure definition of a simulation rr m between d and f all free variables in each condition are implicitly universally quantified and have the following types m m i i j e event r o op a val t timestamp rr × r m m × do × event × × op × val × timestamp send × receive × init d r rr i where ie do do i e r o a t i d t a rr i rr i a f a e send send i i j d send m rr i rr i m m j receive receive i j rr i m m j d receive m rr receive i j supplied as parameters to do and send we similarly assume them in fig via the of these abstract methods instantiation for statebased implementations fig defines the domain and abstract methods appropriate for statebased implementations in § we show that the existence of a simulation of def with respect to these parameters implies d f theorems and the do method adds a fresh event e with the given attributes to i its timestamp t is recorded in in the resulting execution i the event e is the last one by its replica all events in i and the place in consistent with t the send method just returns i which formalizes the intuition that in statebased implementations send returns a message capturing all the information about the object available at the replica the receive method takes the union i j of executions i related to the current state and j related to the message applied recursively to the components of ia and ja we also assume that i j the relation in the resulting execution from the timestamps this is the reason for recording them in we would not be able to construct receive i solely from and the agreement property j guarantees that i j is wellformed eg its visibility relation is acyclic and that for each replica i describes a computation extending j or vice versa the latter follows from the observation we made when the statebased counter in § a message or a state in a statebased implementation reflects a prefix of the sequence of events performed at a given replica the first conjunct of the execution invariant inv requires to be consistent with event timestamps the second conjunct follows from the definition of § when the obligations in fig with respect to the parameters in fig for a particular implementation we can rely on the agreement property and the execution invariant examples we illustrate the use of the instantiation from § on the statebased counter and in we also give proofs of two register implementations counter in fig b and in the obligations in fig for the simulation is easy the key case is receive where the first conjunct of agree in fig ensures that v s increments by a replica s are taken into account both in vs and in v s r v rr i v m j s v s e ie inc s figure instantiation for statebased data type implementations in do we omit the straightforward definition of ar in terms of and t timestamp j r e ie r is a prefix of e r or vice versa i j e f ie e f do i e r o a t i if e ie i where i ie e r x o a f e f ie r f e f ie ar t send i i i if receive i j i j if j this allows establishing receive r v v rr i j thus formalizing the informal justification of correctness we gave in § in fig c and in we associate a state or a message a t with any execution that contains a event with the timestamp t maximal among all other wr events as per by inv in fig this event is maximal in which implies that rd returns the correct value the other obligations are also easily formally r rr m and a t m e repl obj ro vis ar t a e wr t e e t f e wr t optimized in fig and in a problem with implementing a replicated set is that we often cannot discard the information about an element from a replica state after it has been removed if another replica of the removal sends us a of its state containing this element the semantics of the set may require our receive to keep the element out of the set as we prove in § for the keeping track of information about removed elements cannot be fully avoided which makes its implementation very challenging here we consider a implementation that as we show in § has an optimal space complexity it improves on the original implementation whose complexity was we have proved the correctness of the latter as well see an additional challenge by the is that according to a remove operation may behave differently with respect to different events adding the same element to the set depending on whether it them or not this causes the implementation to treat internally each add operation as generating a unique instance of the element being added further increasing the space required to this the implementation summarizes information about instances an instance is represented by a unique instance identifier that is generated when a replica performs an add and consists of the replica identifier and the number of adds of any elements performed at the replica until then in a state r v w the vector w determines the identifiers of all instances that the current replica r has ever observed for any replica s the replica r has seen ws successive identifiers s s s ws generated at s to generate a new identifier in the replica r increments wr the connection between the vector w in a state or a message and add events in corresponding executions is formalized in lines of the simulation relation also shown in fig in receive we take the pointwise maximum of the two vectors w and w like for the counter the first conjunct of agree implies that this preserves the clauses in lines figure optimized implementation and its simulation × z × n × n r r a s s m z × n × n r v w t r a s if a a s r then wr else v a s wr wr r v w t r a s if a a then else v a s w r v w t r v w a s v a s send r v w r v w v w receive r v w v w r a s if v a s ws v a s v a s w s v a s then else a s v a s s w s s v w rr i r s v w m i v w m e repl obj ro vis ar distinct s k ws e e add s k j s ro j k a s v a s ws v a s as v a s k ws e as vis f a s k e k v a s f e vis f the component w in r v w records identifiers of both of those instances that have been removed and those that are still in the set are active the component v serves to distinguish the latter as it happens we do not need to store all active instances of an element a for every replica s it is enough to keep the last active instance identifier generated by an at this replica if v a s this identifier is s v a s if v a s all instances of a generated at s that the current replica knows about are the meaning of v is formalized in the simulation each instance identifier given by v is covered by w line and if v a s then the event as performs line is the last by replica s line and has not been observed by a line finally the events that are not seen by a in the execution are either the events as or those by them lines this ensures that returning all elements with an active instance in rd matches when a replica r performs we update v a r to correspond to the new instance identifier conversely in we clear all entries in v a thereby all instances of a however after this their identifiers are still recorded in w and so we know that they have been previously removed this allows us to address the problem with implementing receive we mentioned above if we receive a message with an active instance s v a s of an element a that is not in the set at our replica v a s but previously ws v a s this means that the instance has been removed and should not be active in the resulting state the entry for a s should be we also do the same check with the state and the message as the above explanation shows our simulation relations are useful not only for proving correctness of data type implementations but also for their designs obligations in fig requires some work for the due to space constraints we defer this to figure function step that the effect of an event e c e from c in d defined when so is the abstract method used e d dr do dr e r c c c if c do c r e d dr i c j if c send c r c send dr i j e d dr receive dr dc if c receive c r soundness and establishing agreement properties we present conditions on and abstract methods ensuring the soundness of simulations over them and in particular establishing the agreement property and execution invariants assumed via the of abstract operations in fig theorem soundness assume do send receive v and t that satisfy the conditions in fig for some g if there exists a simulation between d and f with respect to these parameters then d t f conditions in fig require global reasoning but can be once for a class of data types for example they hold of the instantiation for statebased implementations from § as well as one for implementations presented in theorem there exists g such that for all d the parameters in fig satisfy the conditions in fig with respect to this g v t the proofs of theorems and are given in to explain the conditions in fig here we consider the proof strategy for theorem to establish d t f for any c d t we need to show v f we prove this by induction on the length of c to use the conditions in fig we require a relation g associating c with a decomposed partial function d that gives fragments of v corresponding to replica states and messages in the final configuration of c we write for the set of all decomposed executions so that g × the existence of a decomposed execution d such that c g d forms the core of our induction hypothesis in fig checks that the abstract methods construct visibility according to v it requires the context of any event e by a replica r to be the same in dr and v together with do in fig this ensures v f we write c c e r t when c is an extension of c in the following sense c e ce e the other components of c are those of c restricted to ce e is last in c eo and c r t for the induction step assume c g d and c c e r t see fig c then the decomposed execution d corresponding to c is given by e d where the function step in fig the effect of the event e from c in d using the abstract methods ensures that it preserves the relation g also requires us to establish the of step and thus the corresponding abstract method this the agreement property and execution invariants encoded by the and allows us to use the conditions in fig to complete the induction we also require which establishes the base case and which a technical restriction on v finally the conditions in fig allow us to use the specification t by considering only executions c satisfying it space bounds and implementation optimality object states in replicated data type implementations include not only the current content but also metadata figure proof obligations for abstract methods free variables are implicitly universally quantified and have the following types c c t d r e event r t c g d e ve r e v e c c e r t c g d e d c g e d ce e e d c g e d where d is such that r e ve c is a prefix of c under c eo v e v e needed for conflict resolution or network failures space taken by this metadata is a major factor determining their efficiency and feasibility as illustrated by the in § this is so for statebased implementations ie those that satisfy their data type specifications with respect to the visibility witness and the layer specification we now present a general technique for proving lower bounds on this space over head which we use to prove optimality of four statebased imple we leave other implementation classes for future work see § as in § we only consider executions over a fixed object x of type metadata overhead to measure space we need to consider how data are represented an encoding of a set s is an injective function enc s where is some chosen fixed finite set of characters left unspecified sometimes we the domain being encoded using a subscript eg for s s we let be the length of the length can vary eg for an integer k k lg k we use standard encodings listed in for return values of the data types we consider and assume an arbitrary but fixed encoding of object states to distinguish metadata from the content of the object we assume that each data type has a special rd operation that returns the latter as is the case in the examples considered so far for a concrete execution c d over the object x and a read event e we define to be the state of the object accessed at e rx for r we now define the metadata overhead as a ratio by the size of the object state by the size of the observable state we then quantify the worstcase overhead by taking the maximum of this ratio over all read operations in all executions with given numbers of n and update operations m to define the latter we assume that each data type specifies a set upd op of update operations for all examples in this paper upd op rd definition the maximum metadata overhead of an execution c d of an implementation d is c max e the worstcase metadata overhead of an implementation d over all executions with n and m updates n m is n m c c d n e ce m e ce upd we consider only executions with m n since we are interested in the asymptotic overhead of executions where all are ie perform at least one update operation figure summary of bounds on metadata overhead for implementations as functions of the number of n and updates m type existing implementation any implementation algorithm ref overhead overhead ctr fig b n n fig fig fig c fig fig new n lg m m lg m lg m n lg m n lg m n lg m lg m n lg m assuming timestamp encoding is m satisfied by lamport clocks an optimization of discovered during the optimality proof definition assume d and a positive function f n m · f is an asymptotic upper bound d of n m if n mf n m ie k m n n m n m · f is an asymptotic lower bound d f n m if n mf n m ie k m n n n m n n m n m · f is an asymptotically tight bound d f n m if it is both an upper and a lower asymptotic bound fig summarizes our results as described in § we have proved all the implementations correct matching lower and upper bounds indicate worstcase optimality of an implementation note that this is different from optimality in all cases the derivation of upper bounds relies on standard techniques and is deferred to we now proceed to the main challenge how to derive lower bounds that apply to any implementation of we present proofs for ctr and and are covered in experiment families the goal is to show that for any correct implementation d ie such that d f the object state must store some minimum amount of information we achieve this by constructing an experiment family which is a collection of executions c where q for some index set q each experiment contains a distinguished read event e the experiments are designed in such a way that the object states must be distinct which then implies a lower bound lg q on the size of their encoding to prove that they are distinct we construct tests that execute the methods of d on the states and show that the tests must produce different results for each provided d is correct formally the tests induce a function rb that satisfies we the core argument in the following lemma definition an experiment family for an implementation d is a tuple q n m c e rb where q is a finite set n m and for each q c d is an execution with n and m updates e and rb d q is a function satisfying lemma if q n m c e rb is an experiment family then n m lg q proof since the states are pairwise distinct and so are their encodings since there are fewer than q strings of length strictly less than lg q for some q we have lg q then n m c lg q max q to apply this lemma to the best effect we need to find experiment families with q as large as possible and as small as possible finding such families is challenging as there is no systematic way to derive them we on about which situations force to store a lot of information when searching for experiment families driver programs we define experiment families using driver programs eg see fig these are written in imperative and use traditional constructs like loops and conditionals as they execute they construct concrete executions of the data type library d by means of the following instructions each of which a transition from fig o t do operation o on x at replica r with timestamp t u o t same but assign the return value to u send a message for x with identifier mid at r receive the message mid at replica r programs explicitly supply timestamps for do and message identifiers for send and receive we require that they do this cor eg respect uniqueness of timestamps when a driver pro gram terminates it may produce a return value for a program p an implementation d and a configuration r t we let r t p be the concrete execution of the data type library d starting in r t that results from running p we define r t p as the return value of p in this run lower bound for statebased counter ctr theorem if then is n we start by a suitable experiment family lemma if n and m n is a multiple of n then tuple q n m c e rb as defined in the left column of fig is an experiment family the idea of the experiments is to force replica to remember one number for each of the other in the system which then introduces an overhead proportional to n cf the implementation in fig b we show one experiment in fig all experiments start with a common initialization phase defined by init where each of the n performs mn increments and sends a message after each increment all messages remain until the second phase defined by exp there replica receives exactly one message from each replica r n selected using r an experiment concludes with the read e on the first replica the works by performing separate tests for each of the r n defined by for example to determine which message was sent by replica during the experiment in fig the program test reads the counter value at replica getting the final message by replica to it and reads the counter value at replica again getting by observing the difference the program can determine the message sent during the experiment proof of lemma the only nontrivial obligation is to prove let r t then r i r t init exp r t test r ii x rx test r r figure experiment families q n m c e rb used in the proofs of theorem ctr and theorem ctr conditions on n m number of mn mn m mod n m mod n index set q q n m n q n m n family size q q m n n q m n n driver programs procedure init procedure init for all r n for all i m n inc ri for all r n for all i m n add ri procedure exp procedure exp for all r n for all r n rr rr do rd nm read e procedure do remove nm do rd nm read e procedure u do rd nm receive mid r m n u do rd nm return m n u u for all i m n ri u do rd if u return i return m n definition of executions c c r t init exp where r t x d definition of function rb d q rb r x where r t init figure example experiment n and m and test for ctr gray dashed lines represent the configuration x rx where the test driver program is applied test exp init receive receive receive e rd mid mid mid mid mid mid mid mid mid mid mid mid mid mid mid u rd receive u rd where i this is due to as we explained informally above let c r t init exp then the operation context in of the first read in contains n r r increments while that of the second read contains mn r more increments ii we have t because exp does not send any messages also r and x rx can differ only in the states of the n these cannot influence the run of since it performs events on replica only proof of theorem given n m we pick n n and some m n such that m is a multiple of n and m n take the experiment family q n m c e rb given by lemma then for any is at most the total number of increments m in c using lemma and m n for some constants k k k k independent from n m we get n m lg q k lg m n n m k n lg m n lg m k lg m kn lower bound for statebased theorem if then is n lg m lemma if n and m n is such that m is a multiple of n then the tuple q n m c e rb on the right in fig is an experiment family the proof is the same as that of lemma except for obligation i we therefore give only informal the main idea of the experiments defined in the lemma is to force replica to remember element instances even after they have been removed at that replica cf our explanation of the challenges of implementing the from § the experiments follow a similar pattern to those for ctr but use different operations in the common init phase each replica n performs m n operations adding a designated element which are interleaved with sending messages in the experiment phase exp one message from each replica r n selected by r is to replica at the end of execution replica removes from the set and performs the read e the return value of this read is always the empty set to perform the of r for r n all messages by replica r to replica in the order they were sent and after each such checks if replica now reports the element as part of the set from and the definition of we get that exactly the first r such will have no effect on the contents of the set the respective add operations have already been observed by the remove operation that replica performed in the experiment phase thus if appears in the set right after the ith message of replica r then r i and if does not appear by the time the loop is finished then r m n proof of theorem given n m we pick n n and some m n such that m is a multiple of n and m n take the experiment family q n m c e rb given by lemma for any q which can be encoded with a constant length using lemma and m n for some constants k k k we get n m lg q kn kn lg m kn lg m store correctness and consistency axioms recall that we define a replicated store by a data type library d and a layer specification t § and we specify its behavior by a function f from types to data type specifications and a set of consistency axioms § the axioms are just constraints over abstract executions such as those shown in fig from now on we denote their sets by x so far we have on single data type specifications f and their correspondence to implementations d as stated by def in this section we consider consistency axioms and formulate the notion of correctness of the whole store d t with respect to its specification f x our first goal is to lift the statement of correctness given by def to a store d t with multiple objects of different data types to this end we assume a function v mapping each type to its visibility witness v this allows us to construct the visibility relation for a concrete execution c d t by applying v to its projection onto the events on every object of type c x obj where projects to events over x then the correctness of every separate data type in the store with respect to f according to def automatically ensures that the behavior of the whole store is consistent with f in the sense of def proposition d t f c d t f this the following definition of store correctness let us write a x when the abstract execution a satisfies the axioms x definition a store d t is correct with respect to a specification f x if for some v i d t f and ii c d t x we showed how to i in § the validity of axioms x required by ii most often depends on the layer specification t eg to the from § t needs to provide guarantees on how messages to different objects are however data type implementations can also enforce axioms by putting enough information into messages eg implementations correct with respect to from § ensure that vis is transitive regardless of the behavior of the layer fortunately to establish ii in practice we do not need to consider the of data type implementations in knowing the visibility witnesses used in the statements of their correctness is enough as formulated in the following definition definition a set w of visibility witnesses and a layer specification t validate axioms x if c v c t v w x since visibility witnesses are common to wide classes of data types eg state or our proofs of the validity of axioms will not have to be if we add new data type implementations to the store from a class already considered we next present axioms formalizing several variants of eventual consistency used in replicated stores fig and and w and t that validate them we then use this as a basis for discussing connections with weak models due to space constraints we defer technical details and proofs to basic eventual consistency eventual and define a weak form of eventual consistency eventual ensures that an event cannot be to infinitely many other events on the same object and thus implies from § informally if updates stop then reads at all will eventually see all updates and will return the same values § however eventual is stronger than consistency the latter does not provide any guarantees at all for executions with infinitely many updates to the store whereas our specification implies that the return values are computed according to f using view of the store state we formalize these relationships in values from appearing like in fig a recall that registers are initialized to cycles in ro vis that lead to usually arise figure a selection of consistency axioms over an execution e repl obj ro vis ar auxiliary relations f causality happensbefore order ro vis causality happensbefore order hb ro vis axioms eventual e e ¬ infinitely many f e f vis f ro vis is acyclic visibility vis ar visibility hb vis hb ar is acyclic figure allowed or by different axioms a by x y i j ro vis vis ro b by x i j ro vis ro vis c allowed by and x y i j ro ro from effects of speculative computations which are done by some replicated stores is validated by and and eventual by and the following condition on c ensuring that every message is eventually to all other and every operation is followed by a message generation e ce r r send r r r f r e f e ce do f send e f where is to events on the same object causality guarantees many replicated stores achieve availability and partition while providing stronger guarantees which we formalize by the other axioms in fig we call an execution respectively consistent if it is eventually consistent as per above and satisfies the axioms and respectively and guarantees that an operation all operations connected to it by a chain of events on the same object also considers chains via different objects thus the execution in fig b and the one in § corresponding to from § and similarly require to be consistent with causality the axioms the principle of formalizing stronger consistency models including more edges into vis and ar so that clients have more information consistency is implemented by eg and it is weaker than strong consistency as it allows reading data for example it allows the execution in fig c where both reads fetch the initial value of the register despite writes to it by the other replica it is easy to check that this outcome cannot be produced by any interleaving of the events at the two and is thus not strongly consistent an interesting feature of consistency is that statebased data types ensure most of it just by the definition of is validated by and if the witness set is then we need t to guarantee the following informally if a send event e and another event f are connected by a chain of events on the same object then the message created by e is to by the time f is done is validated by and the layer specification arc this states that timestamps of events on every object behave like a lamport clock conditions for and are similar there also exist consistency levels in between basic eventual consistency and consistency defined using socalled session guarantees we cover them in comparison with consistency models interestingly the of the consistency levels defined by the axioms in fig to the type of are very close to those adopted by the memory model in the c and c standards thus and define the semantics of the fragment of cc restricted to socalled relaxed operations there this semantics is defined using coherence axioms which are analogous to session guarantees and are close to the semantics of cc restricted to operations however cc does not have an of eventual and does not validate since it makes the effects of visible to the programmer we formalize the correspondence to cc in in the future this correspondence may open the to applying technology developed for models to eventually consistent systems promising directions include model checking automatic inference of required consistency levels and compositional reasoning related work for a overview of replicated data type research we refer the reader to shapiro et al most papers new data type implementations ­ do not provide their formal declarative specifications save for the expected property of consistency or first specification attempts for sets of eventual consistency have either expressed consistency or gave lowlevel operational specifications an exception is the work of et al who proposed an axiomatic model of eventual consistency based on visibility and relations and an operational model based on diagrams their store specification does not provide consistency guarantees and their data type specifications are limited to the sequential s construction from § which cannot express advanced conflict resolution used by the register the and many other data types more significantly their operational model does not support general op or statebased implementations and is thus not suited for studying the correctness or optimality of these commonly used patterns simulation relations have been applied to verify the correctness of sequential and concurrent data type implementations we take this approach to the more complex setting of a replicated store where the simulation needs to take into account multiple object copies and messages and associate them with structures on events rather than single abstract states this technical challenges not considered by prior work which we address by our novel notion of simulations the distributed computing community has established a number of asymptotic lower bounds on the complexity of implementing certain distributed or concurrent abstractions including one timestamp objects and counting protocols these works have considered either programming models or metrics significantly different from ours an exception is the work of who proved that the size of vector clocks is optimal to represent the happensbefore relation of a computation similar to the visibility relation in our model specifications of and rely on visibility however result does not directly translate into a lower bound on their implementation complexity since a specification may not require complete knowledge about the relation and an implementation may represent it in an arbitrary manner not necessarily using a vector conclusion and future work we have presented a theoretical to advance the study of replicated eventually consistent stores by methods for specifying the semantics of replicated data types and stores abstractly verifying implementations of replicated data types and proving that such implementations have optimal metadata overhead by proving both correctness and optimality of four nontrivial data type implementations we have demonstrated that our methods can indeed be applied to the kinds of patterns used by and researchers in this area although our work marks a big step forward it is only a beginning and creates of opportunities for future research we have already made the first steps in extending our specification framework with more features such as of consistency levels and transactions see in the future we would also like to study more data types such as lists used for editing and to investigate metadata bounds for data type implementations other than statebased ones including more detailed overhead metrics capturing optimizations to the worstcase overhead analysis even though our execution model for replicated stores follows the one used by replicated data type designers there are opportunities for it closer to actual implementations thus we would like to verify the algorithms used by store implementations that our semantics abstracts from this includes and session migration protocols which permit clients to interact with multiple physical while being provided the of a single virtual replica finally by together prior work on models and data replication we wish to an exchange of ideas and results between the research of programming languages and verification on one side and distributed systems on the other acknowledgements we thank and shapiro for comments that improve the paper was supported by the eu project and yang by references store s v and k shared memory consistency models a computer j d v and m software verification for weak memory via program transformation in esop m m and a library abstraction for cc concurrency in popl m s s sarkar p sewell and t c concurrency in popl a m n m shapiro c v and s an optimized replicated set technical report inria a m n m m shapiro c v and s brief semantics of eventually consistent replicated sets in am and m a formal model for eventual consistency semantics in s r and m m k martin checking consistency of concurrent data types on relaxed memory models in pldi s m d and b p types for eventual consistency in ecoop s a and h yang understanding eventual consistency technical report microsoft research s a h yang and m replicated data types specification verification optimality extended version s d m and m sagiv eventually consistent transactions in esop b concerning the size of logical clocks in distributed systems information processing letters jy chen and g optimal aggregate computation in n r p j m and d logic and lattices for distributed programming in a d gupta v n and a data services in g et al highly available store in s and n conjecture and the feasibility of consistent available web services m l e and p the space complexity of and timestamp implementations in c a r hoare proof of correctness of data representations inf l lamport time clocks and the ordering of events in a distributed system acm c li d a r n and j making systems fast if possible consistent when necessary in h x and m fu a simulation for verifying concurrent program transformations in popl b liskov and s programming with abstract data types in acm symposium on very high level languages f n n m t and e dynamic synthesis for relaxed memory models in pldi w m j m and d g dont for eventual scalable consistency for storage with in j w and s v the java memory model in popl f virtual time and global states of distributed systems parallel and distributed algorithms s g and i concurrent counting in m js and j lee replicated abstract data types building blocks for applications j parallel comput m shapiro n c and m a study of and commutative replicated data types technical report inria m shapiro n m c and m replicated data types in y r power m k and j li transactional storage for systems in d b a j demers k m m and b w session guarantees for weakly consistent replicated data in d b m m k a j demers m j and c h update conflicts in a weakly connected replicated storage system in m a v s c m shapiro and n integrated all the way to the client machine technical report inria 