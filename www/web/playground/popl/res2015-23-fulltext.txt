principal type schemes for gradual programs software lab department of computer science university of university abstract gradual typing is a discipline for integrating dynamic checking into a static type system since its introduction in functional languages it has been adapted to a variety of type systems including objectoriented security and this work studies its application to implicitly typed languages based on type inference siek and designed a gradual type inference system and algorithm that infers gradual types but still illtyped static programs however the type system requires local reasoning about type substitutions an imperative inference algorithm and a subtle correctness statement this paper introduces a new approach to gradual type inference driven by the principle that gradual inference should only produce static types we present a static implicitly typed language its gradual counterpart and a type inference procedure the gradual system types the same programs as siek and but has a modular structure amenable to extension the language admits and its dynamics are defined by translation to the polymorphic blame calculus ahmed et al the principal types produced by our initial type system mask the distinction between static parametric polymorphism and polymorphism that can be attributed to gradual typing to expose this difference we distinguish static type parameters from gradual type parameters and gradual type consistency accordingly the resulting extension enables programs to be interpreted using either the polymorphic or monomorphic blame calculi introduction interest in integrating static and dynamic checking is increasing among language researchers and language designers eg et al et al et al and felleisen et al among the proposed foundations for such languages gradual typing due to siek and has been used to integrate dynamic checks into a variety of type structures including objectoriented siek partially by an discovery grant partially by nsf grant permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm and et al and ownership types and clarke the key technical of gradual typing are the unknown type the consistency relation among gradual types and support for the entire between purely dynamic and purely static checking a gradual type checker type in programs accepts statically safe code and code that could be safe with runtime checks this paper applies the gradual typing approach to implicitly typed languages like standard ml ocaml and haskell where a type inference type reconstruction procedure is integral to type checking this problem was investigated first by siek and defining a gradual type inference system and algorithm that infers gradual types but illtyped static programs this paper principles that a gradual implicitly typed language should satisfy demonstrates how several approaches fail and ultimately produces a type system and type inference algorithm though the results satisfy the criteria for gradual typing the type system requires special care in its handling of type variables subtle statements and proofs of correctness and a imperative inference algorithm these make it how to adopt adapt and extend this approach with modern features of implicitly typed languages like and firstclass polymorphism furthermore extending an existing implicitly typed language implementation with support for gradual typing would require a rewrite or substantial of the type to support the extension of implicitly typed languages with support for gradual typing this paper introduces a new foundation for gradual implicit typing in particular we make the following contributions we introduce a specification of static implicit typing that the inputoutput modes of the type system in particular the types of subterms are viewed as opaque and we rely on partial functions to structure the system this structure leads to a natural of gradual implicit typing that is easy to reason about and extend the key insight underlying the design is to only allow fully static types to be implicit gradual types in our approach must in the program text siek and type system is based explicitly on inferring gradual types and type precision a substantially different conceptual foundation nonetheless we prove that the two foundations coincide both type systems accept exactly the same programs et al also combine gradual typing and type inference but focus on improving performance rather than detecting sec we define a corresponding constraint typing judgment and constraint solver central to its design is that we choose to limit the type inference problem to only static types in addition to the standard equality constraints between static types we require consistency constraints between gradual types our solver naturally extends unification to support them to the of the type system we extend it with support for using the standard approach off the we give the language dynamics by translating it to the polymorphic blame calculus ahmed et al the translation the analogous translation of hindleymilner typing to system f that recent approaches to firstclass polymorphism may also apply we observe that the principal types of the initial system mask the distinction between static parametric polymorphism and polymorphism due to gradual typing to expose this difference we distinguish static type parameters from gradual type parameters and gradual type consistency accordingly the resulting language can be interpreted using either a monomorphic or polymorphic intermediate language implicit typing and type inference this section briefly introduces the implicitly typed static language its main purpose is to introduce the core type system that we extend with gradual typing as well as to briefly review the principles of implicit typing we some particular details of our presentation that are important to the overall approach a t type x var b bool n z t term v value var type t a int bool t t types t n t t b if t then t else t terms x xt x tt t t t t v n b x xt x tt syntactic values figure static language syntax fig presents the syntax for by implicit typing we mean that the language is statically typed but programmers may omit type annotations in particular this language provides function expressions xt that require no type annotation on their parameter in contrast to the annotated form x tt which it also supports as a convenience the language also provides type t t which could already be simulated as x tx t the implications of these language features become in the type system specification presented in fig the t rule uses the type annotation on a function parameter to type its body the t rule on the other hand types a functions body with any parameter type that works the impact of this is that a function like x has only one legal type int int but a function like xx can be given many types specifically any type of the form t t this flexibility reduces the annotation overhead for programmers while static safety and increases the expressiveness of the language if a polymorphic let construct is added see sec presentation style there are some differences between the presentation in fig and the typical presentation cf pierce they do not affect the meaning of this type system definition but they play an important structuring role that we exploit when we extend it to support gradual typing the type system definition particular attention to the mode of the typing judgment in the sense of logic programming and in particular the type context and term are interpreted as inputs to the typing judgment while the terms type is tx x t xt tn n int tb b bool t t t t t t t t t t t t t t t bool if t then t else t t t t t t t t int t int t t int t x t t t xt t t t x t t t x tt t t t t t t t t t t dom type type t t undefined otherwise type type t t t undefined otherwise type × type type t t t undefined otherwise figure static language type system viewed as an output the impact of this interpretation on the structure of the definition is as follows and can be seen in the rule though the structure of the terms t in the conclusions of rules are analyzed using syntax the type position of each typing judgment in the premise is stated abstractly as some type t for instance the type rule for application usually has a premise t t t but in contrast the rule only assumes that the result is a type t in of pattern matching on a function type the rules to partial functions that are defined only for types with the proper shape these partial functions name the result type of a term eg t and assert properties that must hold between interacting types eg t our partial functions are responsible for requirements on types for instance reference to in a rule implies that t t t for some t t so this requirement does not need to be explicitly stated in the rule if is undefined then the rule does not apply using partial functions to abstract away type requirements is critical to our subsequent development of gradual typing a particularly interesting example of this arises in the rule the requirement that t must be bool is standard but the result type of the term is a partial function t that is defined only when the two types are equal in which case it is the type itself typically this rule is expressed by using pattern matching on the results of typing t and t to force them into the same type and then providing that type as the final result instead we keep the result types abstract and to a partial function to combine them in summary we use predicates only to express relationships between types that do not imply some result type for all cases where we need to determine a type in terms of subterm types we defer to a partial function in propositions that refer to partial functions we interpret as kleene equality both sides of the equation must either be defined and equal or undefined type polymorphism as we mentioned earlier a function like xx can be given the types int int bool bool and any other type of the form t t we would like to express this polymorphism but our language does not support firstclass polymorphism each type is concrete for this purpose we the language with a set of type parameters a which are uninterpreted types in the sense that the type system gives them no special treatment as a consequence any situation where a type parameter a is used any other particular type could appear let us formalize this observation definition let sa type denote type parameter substitutions or notation if s is some sort of substitution function then we use st s and st to denote the compatible closure of substitution over types type contexts and terms respectively the give meaning to type parameters with this we can treat them as for type polymorphism proposition if t t then sa sat sat for any sa proof straightforward induction on derivations of t t prop shows us that a type with parameters can be made more specific arbitrarily regarding the dual consideration we can ask about the presence of a most general type for a program definition principal type if t t then we say that t is a principal type of and t if whenever t t holds then t sat for some sa principal types summarize all possible types of a program this particular language has principal types for every program we establish this once and for all in the typed setting type inference while this type system specification has great the question arises as to whether it can be effectively type checked indeed it can and a broad array of literature has discussed approaches to doing so we even more flexibility than the language provides to do so we generalize the problem beyond purely type annotations to check implicit types we must deduce types that are not present in the program text to represent this problem in a context we introduce notions of type variables and type expressions x t x t x x a int bool t x t x a type variable is a for one or more possible types directly analogous to variables in school algebra then a type expression t x is just a type where some of its has been filled with type variables this idea extends to term expressions tx and type expression contexts x var we write x for the set of type variables in t x the function vars extends to terms and type contexts in the expected way and in the remainder of the paper we simply write o on for for some n and where oi can be a type a term or a type context for i n note that type variables and type parameters are distinct concepts type parameters actually are types while type variables are merely just as variables in algebra are not numbers however all types count as type expressions too ie type the analogous status also holds for term expressions var x u xu abs x u t u x ut u u t u u t u t t u u u app t t u t t figure simply typed gradual calculus and type expression contexts we give all of these expression forms meaning by substituting types for type variables definition let sx type type variable substitutions or observe that these substitutions produce real types terms and type contexts in with the source language definition let sx and sx be two type variable substitutions and let x we say that sx with sx over x whenever for all variables x x it holds that in algebra we use variables to write down equation expressions which are problems that may have solutions by analogy we use our expressions to formalize the type inference problem and to characterize its solutions definition type inference problem given a type expression context x and a term expression tx the type inference problem for if t for some sx and type t only the context and term are expressions here a type then is a decision procedure for the type inference problem we do not present a type inference algorithm for this static language however such an algorithm can be extracted directly from the gradual type we present below introduction to gradual typing gradual typing is a type discipline introduced by siek and to extend an existing type system with support for static and dynamic checks such a language supports both of checking fully static and fully dynamic as well as any point in between the gradual type system uses available type information to detect between types typing conditions that cannot be determined statically are checked at runtime using casts to achieve these goals gradual typing extends an existing type system with an unknown type for example the corresponding gradual types for the language from the last section are as follows u u a int bool u u gradual types based on this definition every static type is also a gradual type fig presents the type system for the simply typed gradual calculus siek and the rules for variables and functions are standard but the rules for function application are not the app rule applies when the operator has the unknown type since the result could be a function the program type checks and the result type of the application is unknown in turn the rule applies when the operator has some function type unlike static typing the rule does not require that the operand have the same type as the domain of the operator but simply that two types be consistent written u u we define consistency as some of type inference use a single entity for both concepts we distinguish them for clarity and to support our development in sec follows int int bool bool aa u u u u u u u u u u the intuition behind this definition is that two consistent gradual types need only agree on their statically known parts consistency is one of the key of the gradual typing approach the type system must be a conservative extension of the un type system this means that programs without any dy must type according to the underlying static type system since consistency reduces to equality in the absence of it follows that the type system conservatively extends its simply typed counterpart a programmer development environment or source language then introduces by to program subterms see sec in addition to consistency gradual types impose a notion of type precision as a partial order which indicates that one type is less unknown than another u u u u u uu u u u u this relation coincides with the subtyping relation of wadler and findler to support gradual typing programs are instrumented with typedirected runtime checks that ensure that consistency checks that cannot be fully resolved at typechecking time are verified in short a gradual type system takes an optimistic approach to checking that two types are compatible only statically combinations that exhibit and dynamically verify ing any remaining checks a gradual implicitly typed language this section presents our of gradual typing for an implicitly typed language the ideas from the last two sections combine to yield a design that differs from in its foundations but is ultimately equivalent fig presents the syntax of the implicitly typed gradual language as with standard practice the difference is lifting of static types t to gradual types u every static type annotation can now be replaced with a gradual type annotation a t type u x var b bool n z t term v value t a int bool t t static types u a int bool u u gradual types t n t t b if t then t else t terms x xt x ut t t t u v n b x xt x ut syntactic values figure gradual language syntax the type system presented in fig builds on the type system from sec most of the rules have the same structure except their static types have been lifted to gradual types and the predicates and partial functions on static types have been lifted to consistent predicates and partial functions on gradual types a straightforward example of this is the u rule which replaces type equality with type consistency and static types with gradual types if we compare this type system to we notice that the former has one rule for function application while the latter has we avoid calling it subtyping because it does not characterize ux x u xu un n int ub b bool t u t u u t t t u t u t u u bool if t then t else t u u u t u t u u int u int t t int u x t t u xt t u u x u t u x ut u u tu u u u t u u dom u u dom undefined otherwise u u u undefined otherwise × t t t u u u u u u u u u u u u undefined otherwise u figure gradual language type system two and app in this case the dom partial function provides the necessary abstraction to combine the two rules into one the dom function is defined with two cases folding them into the rule along with would recover the two rules of consider the rule most of the structure is as expected but its result type is u u the greatest lower bound or meet of u and u according to the precision relation in fact the meet is the gradual partial function that corresponds to to see how consider the two gradual types int and bool the only hope for some u to be a welldefined result of combining them is for u to be bool int naturally one can always coerce two inconsistent branches to typecheck using type implicit types must be static types the u rule implicit typing in the corresponding rule types the body of the function using some arbitrary type and the gradual type system does the same to understand why the arbitrary type is static rather than gradual consider the program xx x this program has no unknown type annotations so it is in the language of the type system which cannot type it as such the gradual type system must reject it as well if the gradual type system could arbitrarily type x as however then this function would type check even though the programmer introduced no annotations the key insight is that is introduced only via program annotations the type system itself must never introduce of its own as we see next this insight has implications gradual inference of static types as with we generalize type inference taking into account the insight that our type system need only infer static types to state the gradual type inference problem we introduce corresponding type expressions term expressions and type context expressions for brevity we present only the gradual type expressions ux u x x a int bool u x u x gradual type expressions u x now include since we are in a language however we do not update the definition of type variables map to static types this property generalizes the reasoning underlying the u rule we only allow gradual types to be explicitly introduced in a program as a means to ensure that the type system cannot introduce without prompt and thereby inconsistency checking definition gradual type inference problem given a gradual type expression context x and a term expression tx the gradual type inference problem if there is an sx and gradual type u such that u in contrast siek and infers gradual types with restrictions in the next section we this difference types the same programs siek and analyze the concept of gradual type inference and design a language that formalizes and their approach the language and types correspond to our gradual type expressions but the type theoretic foundations differ substantially in particular is based on inferring gradual types not just static types but in a controlled manner to formalize this we introduce a new notion of substitutions sg x the type system is presented in fig it is based on the judgment sg x tx u x x which intuitively means that sg and x solve a constrained variant of the type inference problem x and tx for sec where extra variables x and their mappings are involved in the typing process more precisely it means that in x and moreover every type variable x used to type tx ie present in tx or x must map to some such that u for every gradual type u that it is consistent with according to the typing derivation the first criteria is essentially the standard type inference problem but with gradual types in the substitution the second criteria is their approach to preventing the type system from introducing every type variables mapping is constrained by the static types it with but types that in the program text are unconstrained notation we write in xi to mean that the given variable sets are mutually disjoint ie i nj ni j xi xj most of the typing rules are standard in structure the rule for function application is the most interesting where imposes a consistency relation between the type of the operand and the operator this type system to a judgment sg ux ux which means that and moreover that sg respects the criteria for all variables in ux and ux the judgment type expressions to check for consistency upon reaching a type variable it to the judgment sg u ux which means that u the key rule of this judgment is the variable case if the presentation has been to match this paper sg x tx u x x x gx x u x x sg x x u x gn sg x n int gb sg x b bool sg x t ux x sg x t ux x sg ux ux x x x x sg x t t x x x x g sg u x u x sg x x ux t ux x sg x x ux ux x sg bool bool sg int int sg a a sg u x sg u x sg ux ux sg ux ux sg ux ux ux ux sg ux sg x ux sg u u x sg ux sg ux x u sg u x sg bool bool sg int int sg a a sg u sg ux ux sg ux ux sg ux ux ux ux figure type system u then the is our global criterion holds only if the two types are equal this type system satisfies the goals of gradual type inference but its structure is a substitution is incorporated explicitly into the judgment instead of simply appearing in the statement of the type inference problem this structure leaks into the corresponding constraint typing relation and the result is a type inference procedure that differs significantly from a common type existing type inference systems and procedures would be hard to extend with this approach fortunately and surprisingly the type inference problems for and coincide even though is allowed to infer gradual types the key to understanding this is that the type system must reject any program that has a static inconsistency even after taking its type annotations into account the type system cannot infer a that such a conflict as such any that appears in an inferred type must be and with a static type the propositions below formalize this insight definition we use the name unknown substitution to refer to those s such that either sa a or sa these theorems consider only the corresponding subset of we use unknown substitutions to show that is never needed in practice the property we exploit is that all substitutions sg can be into some composed with some unknown substitution sg s sx and any such factoring will do proposition suppose sg s sx then sg ux implies sx ux suppose sg s sx then sg ux ux implies sx ux ux suppose sg s sx then sg x tx u x implies sx x tx u x proof by induction on derivations prop tells us that with to solving the type inference problem for we need only look to sx just as for thus we restrict consideration to for the type system which allows us to connect the two type systems more directly proposition completeness if sx x tx u x x then u for some u such that x u proof by induction on sx x tx u x x the intuition behind this proposition is that since imposes only a consistency on the type of the result type can be an arbitrary static type if the codomain of the operator is in contrast propagates the gradual domain of the operator proposition soundness if u then given any finite x that contains x sx x tx u x x where x x for some sx that with sx except at x and x u proof by induction on u we have designed an interesting gradual type system with support for implicit typing and have established that it types the same programs as in section we deduce a type inference process that corresponds naturally to our type system and conservatively extends the corresponding static procedure application migration now that we have seen the syntax and static semantics of the question remains what can we do with it we have already seen that conservatively extends accepting and programs in the syntax exactly as that type system does furthermore the last section demonstrates that subsumes and siek and demonstrate how programmers can the flexibility of gradual typing to write programs that would not be accepted by a purely static type system as such shares s example programs and we defer to that paper for applications in this section we consider the converse question how does serve the programmer gradual typings goal is to serve both the space between static and dynamic while both we demonstrate how addresses the dynamic side of this goal we present a dynamic counterpart to and demonstrate by a result of siek and that it amounts to a syntactic discipline over we then present a hybrid surface language that is suitable for migration between dynamic and static programs these language designs are straightforward into a dynamic language if we the static language the syntax of its natural dynamic counterpart which we call dl simply amounts to type information e dynamic e n e e b if e then e else e terms x xe e e its immediately clear that dynamic term every dl program looks exactly like an program but looks can be in particular one consistent property of dynamic languages is that any program in the syntax of the language has semantics in contrast only gives meaning to programs that are welltyped for instance xx x is a fine dl program but it is not a legal program because it is not welltyped the field of has a term for this two expressions sometimes in different languages that might be for having the same meaning but do not are called false in natural languages they lead to between native of different languages in programming languages the how do we these syntactic but semantic differences between and dl the key lies in we define both languages by translation to the translation for is trivial because it immediately the translation for dl siek and on the other hand has dynamic term gn n gb b gx x ge e ge ge e then e else e if ge then ge else ge x ge ge e ge ge under this translation x x x x which is a welltyped program as are all of dl programs proposition siek and let x be the free variables of e and x x x then ge as we all terms in dynamic are welldefined dl programs a hybrid language for migration with a semantics for dl and a trivial semantics for we can now combine them the result is a hybrid semantics which we call hl that supports migration between the dl and languages and findler and felleisen wadler and findler ed dynamic es static es n es es b if es then es else es x x es es es t ed ed n ed ed b if ed then ed else ed x ed ed es static dynamic the hl syntax combines and dl allowing each to include the other its semantics is defined by combining the two translations to yielding a gradual language where each type is either precisely static or completely unknown taking the dynamic language as primary hl clearly between the dynamic program xx x the hybrid program x x x and the static xx x dl and hl have close to research on using types to im prove the performance of dynamic languages cartwright and et al et al by analogy the goal in that approach is to transform a dl program into a corresponding hl program by automatically inserting transitions to the static language for as much code as possible while and behaviour this problem has been using typebased analyses that do infer unknown types constraints and constraint generation we have specified an implicit type system demonstrated its expressiveness and formalized the type inference problem for it now we must solve the problem to do so we follow the approach of wand a generate constraints for and solve them by the definition of the type system and properties of our gradual partial functions and predicates we define a constraint typing judgment which indicates what constraints must hold for a particular type pair to be constraint typing judgments we first introduce a set of constraints c that need to be solved during type inference fig there are two kinds of constraints the standard equality constraints on static types and new consistency constraints on gradual types ultimately we want to determine whether a set of constraints can be instantiated using some substitution definition constraint satisfaction sx ux ux if and only if sx tx tx if and only if sx c if and only if sx c for each c c constraint typing fig presents the constraint typing judgment x tx u x c x it means that the type expression context x and term expression tx can be given type expression u x so long as the constraints c can be satisfied where x are any extra variables needed to express the constraints since it involves type variables the constraint typing judgment denotes a problem definition constraint typing problem given a gradual type expression context x and a term expression tx the constraint typing problem if there is a sx such that x tx u x c x and sx c auxiliary constraint typing constraint typing to three auxiliary constraint judgments which reduce complex conditions to consistency constraints on gradual types and equality constraints on static types they are presented in and the ux c x judgment means that the codomain of gradual type expression ux is ux so long as the con c can be satisfied the ux c x ment means that the domain of gradual type expression ux is con with the ux ux so ux as the constraints c can be satisfied fi c x judgment means that the meet of gradual type expressions ux and ux is ux so long as the constraints c can be satisfied in each case x names any extra type variables needed to express the constraints the rules for these judgments are based on the properties of the corresponding gradual operations these constraint judgments are not defined for all inputs for in the constraint meet judgment is not defined for int and bool any result would be so rather than relating these type x tx u x c x x x cx x u x x x x u x cn x n int cb x b bool c x tx ux c x x tx ux c x x x c c c x x x x tx tx int c ux int ux int x x tx ux c x x tx ux c x x ux tx ux c c x x x x x x x x x x x c c c c c x if tx then tx else tx ux c ux bool x x tx x x x x x x x tx ux c x ux c x x x x x x c c c c c x tx tx ux c x x x x tx u x c x x x c x x u x c x x c x x ux tx ux c x x x ux ux c x x tx u x c x c x tx ux ux c u x ux x c constraint c c u x u x t x t x figure constraint typing judgment ux c x x x x x x x x ux ux figure constraint codomain judgment ux c x x ux ux x x x x ux x x ux ux ux ux dom ux ux figure constraint domain consistency judgment ux ux ux c x x ux int int int bool bool bool a a a ux ux ux ux ux ux x ux x x ux ux ux x x ux x ux ux ux c x ux ux ux c x c c c x x x x x ux ux ux ux ux ux c x figure constraint meet judgment expressions to an arbitrary variable and unsatisfiable constraint the judgment simply fails to hold correctness and decidability of constraint typing we must prove for each constraint judgment that if a substitution can satisfy the given constraints then that substitution and the program type that it produces solves the type inference problem proposition constraint soundness if x t u x c x and sx c then x proof by induction on x t u x c x with lemmas to address auxiliary constraint judgments proposition constraint completeness if u then for finite x st tx x x tx u x c x where x x and furthermore there is an sx that with sx except at x where sx c and x u proof by induction on u with lemmas to address auxiliary constraint judgments the constraint completeness proposition must account for the extra variables x used by constraint typing which do not necessarily hold for an arbitrary substitution that solves the type inference problem the key is that given an arbitrary substitution sx that solves the type inference problem its always possible to it into a slightly different sx that produces the same solution but also satisfies the constraints gradual unification in this section we present a procedure that generalizes unification to account for consistency constraints and relates constraints to solutions where possible since each rule of the judgment is invertible and simplifies the constraints together they induce a straightforward decision procedure bottomup proof search for gradual constraints proposition consistency inversion if u u then u u if t t then t t u × u sa c u sx c x x u sx c u sx c u x u sx c u sx c u x u sx c u sx c int int u sx c u sx c bool bool u sx c ux ux ux ux u sx c ux ux ux ux u sx c x u x u sx u x c u x x u sx c x u x u sx u x int bool c x u x u sx c x xx x x x ux ux x ux u sx c x ux ux u sx c u sx c int int u sx c u sx c bool bool u sx c t t t t u sx c t t t t u sx c x t u sx x c t x u sx c u sx c x x u sx x t c u sx x c x t u sx x t figure unification if u u u u then u u and u u proof straightforward fig presents the gradual unification judgment c u sx which means that the sx satisfies the constraints in c recall that satisfaction was defined in sec throughout we assume that c c implies c c most of the cases are straightforward the most interesting case is for x ux ux since x represents a static type we expand it to x x and make each component consistent to its corresponding gradual type equality would not work in general since the type on the right hand side is gradual furthermore the added consistency checks ensure that any s contained within the underlying types are ignored we let sa denote a map from type variables to type parameters this function is responsible for transforming any unconstrained type variables into type parameters notation the notation x fresh means that if the of the rule is c u s then x the notation x t stands for x t the type substitution that is identity everywhere except for x which it maps to t proposition unification soundness if c u s then s c proof by induction on the structure of c u s proposition unification completeness if sx c then c u sx for some sx and furthermore sx sa sx for some sa proof by induction on the of constraint sets c by the unification rules this is dependent on that decomposition structure being proposition unification is decidable backward proof search on c u sx driven by c is decidable proof consider the relation on constraint sets determined by how each rule read bottomup transforms them given soundness and completeness it suffices to prove that this relation is a unlike other unification relations the search structure cannot be ordered on the number of type variables instead we can represent the set of constraints as a directed graph of constraint paths and show that a metric on the graph decreases at every step principal types we establish our notion of principal types using the standard notion adapted to account for the separation between type variables and type parameters definition substitution preorder let sx and sx be then sx sx if and only if sx sa sx for some sa definition principal sx u is a principal solution for a gradual type inference problem if sx is least among the substitutions of all other solutions to the problem in that case u is a principal type for the problem proposition principal types suppose x tx u x c x then sx c for some sx implies that c u sx and sx x is a principal solution for x and tx proof follows from prop this proposition establishes that our type inference procedure produces the best type possible which implies that the type system indeed has a welldefined notion of best types let polymorphism implicitly typed functional programming languages usually sup port introduced by milner siek and left this as an open problem for gradual type inference here we demonstrate that supporting let polymorphism follows the same approach as for a static implicitly typed lan guage wright wright and felleisen to extend with we introduce two new rules v u u let x v in t u t value xt t u let x t in t u if the bound expression is a syntactic value then it is treated otherwise the value is given a monomorphic type x u t u x ut u u x t t u xt t u x x x x x let xt t u t value let x t in t u v u x t u ai let x v in t u figure typing key rules according to the standard let translation these typing rules yield the corresponding constraint generation rules x vx ux c x x ux c x x x x let x vx in tx ux c c x x tx value x tx u c x x let x tx in tx u c x the presentation of let polymorphism is simple and clear but for implementations so we also present an equivalent presentation based on type schemes of type polymorphism in the language in the next section we use this type system to with dynamic semantics the type system is modeled after milner it has the same terms and types as the original but the typing judgment changes the key difference is that the type context now maps variables to type schemes xu x instead of types var xu x this allows us to type polymorphic let expressions without to substitution by introducing polymorphic assumptions we can represent a type u as a type scheme u by convention all type schemes must be closed the type system then requires a few changes fig the and rules now introduce type schemes into the context when typing function bodies the x rule a variables corresponding type scheme to some gradual type in the system this variable would have been replaced with a full syntactic value which its polymorphism implicitly as well see this corresponds directly to the translation from to parametric polymorphism type schemes with no type variables naturally instantiate to their underlying type the rule exploits the polymorphism of type parameters abstracting some that are unconstrained ie do not appear in the type context to form the type scheme that is used to type the body this formulation corresponds directly to the specification definition let be u u for notational convenience we write here we assume a callbyvalue semantics but in general that is not necessary a u x x var b bool n z t term v value u x a int bool u u xu types t n t t b if t then t else t terms x x ut t t xt tu let x u t in t u u t v n b x x ut xv syntactic values figure polymorphic blame calculus syntax proposition substitution if v x for ai and x x t u then u proof by induction on the structure of t proposition abstraction if u and v u for some u then v x and x x t u for some u x ai and xi proof by induction on the structure of t proposition t u if and only if t u proof both directions are by induction on the structure of the corresponding typing judgment dynamic semantics typed languages are defined by typedirected translation to an intermediate language with runtime casts we do not need to develop a new intermediate cast calculus for we can translate it to the polymorphic blame calculus ahmed et al fig presents the syntax of adapted to our notation the language extends the polymorphic lambda calculus girard reynolds with support for runtime casts at runtime the calculus also uses runtime sealing to typed values in an effort to enforce even in the face of casts and ahmed the language supports firstclass polymorphism using terms xt and types xu x which type schemes but only abstract a single type variable and can be open fig presents the type system of the polymorphic blame calculus for the most part the type system is standard but it also supports casts u u t to type terms the polymorphic blame calculus presents a more complex consistency relation but in the absence of firstclass polymorphism it reduces to fig presents a typedirected translation from the typing judgment for to in practice the type derivation is produced by type inference most of the rules are straightforward compositional translations type abstractions and applications are introduced where necessary several of the rules insert casts as needed in positions where consistency is needed the u u t function inserts a cast when the type translation is nontrivial definition context translation x x xu x x x x x x x x x xu x x x xu x x x x x x x u xu n n int b b bool app t u u t u t t u if t bool t u t u if t then t else t u t int t int t t int x u t u x ut u u x t u xt xu t xu tu t u u u u u t u figure polymorphic blame calculus type system proposition welltyped translation if t then x x t u t u proof by induction on the derivation of t t u in principle semantics can also be defined using the approach which essentially programs at the of code explosion taking this approach the image of the translation is the blame calculus siek et al wadler and findler which is the monomorphic fragment of the static and gradual polymorphism this section siek and analysis of gradual type inference their about parametric polymorphism led them to design an inference algorithm that does not always yield principal types our analysis of that variance a distinction among type parameters we extend our type system and inference procedure to expose this distinction and thereby give foundation to this idea to their design siek and consider how best to answer the following type inference problem x y xy x clearly this program is but what type should x get our type makes it a type parameter producing the type a but siek and type inference algorithm produces their reasoning is that the type a implies parametric polymorphism and with it the idea that the type can be changed arbitrarily without the programs behavior however this simple program gets the value of y from a value of type which assuming a model could trigger a cast error depending on which type is assigned to x in their view type signatures with type parameters should indicate static parametric polymorphism and this type does not this observation suggests a distinction that we currently sometimes type parameters indicate parametric polymorphic in the traditional sense irrelevant to program execution other their system precedes and its dynamics had no runtime sealing x x x x x n n n int b b b bool app t t u t u t u t t u t u t if t t u t t u t t u u bool u u u if t then t else t if bool u t then u u t else u u t u t t u t t u u int u int t t int u t int u t int x u t t u x ut x ut u u x t t t u xt x tt t u let xt t t u t value let x t in t t u v v u x t t u ai let x v in t x t u t u t u u u t u u u t u u u t t u u t u u t if u u figure gradual language translation times type parameters indicate that a values only constraint is that it may be cast to and from which may introduce casts we distinguish this latter as an instance of gradual polymorphism the exact that the polymorphic blame calculus was designed to address to clearly this typelevel distinction we extend our languages with another class of type parameters in addition to the gradual type parameters a we introduce static type parameters b fig in these type parameters would all be equivalent however when we transition to gradual typing these types are distinguished from their the gradual types extend the static types as usual thereby creating the universe of types for this language the type distinction however leads to several families of static and gradual types types w are those static types that can be passed to the dynamic world their two properties are the absence of the unknown type and the static type parameter b which may not pass to the dynamic world indeed there is a gradual counterpart y b t type u w y v type z t a b int bool t t u a b int bool t t w a int bool t t y a int bool t t figure gradual and static type parameters syntax the static and gradual types that do not appear in these sets make up the static types v and gradual static types z these latter two refer to those types that represent pure parametric polymorphism in this new model the unknown type no longer represents all possible static types but only the types in in they do not include the static types any type that contains a static type parameter the most immediate change that results from this interpretation is that not all types are consistent with in particular z for any z in fact it follows that any type containing a static type parameter b is not consistent with the relevant changes to consistency are as follows bb y y static type parameters are consistent to themselves as is standard but now is consistent to only the gradual types y not all gradual types u in the consequence is that the language has more type variables which to date has not been a problem in practice for instance the program xx may be given type a a using the gradual type parameters but our earlier program can at best be given the type b b using static type parameters furthermore this extension changes the nature of our type poly morphism theorem definition let sa denote the gradual type parameter substitutions or let sb type denote the static type parameter substitutions or let sp sa sb sa sb denote the type parameter substitutions or p substitutions these two substitutions the semantics of polymorphism gradual type parameters a represent types w conversely static type parameters b represent all static types including the gradual type parameters a in practice we are interested in substitutions sp sa sb which simultaneously map gradual and static type parameters to types and static types respectively these p substitutions capture our new notion of type polymorphism proposition if t u then sp sp t sp u for any sp proof straightforward induction on derivations t u type inference for pure parametric polymorphism now that we have described an implicitly typed language with two of parametric polymorphism how do we infer these two types doing so requires only a small extension to our type inference approach our type up to now has simply discarded constraints that require a type to be consistent with since this was true of every type now we must consider them because they make the difference between a static parametric type and a gradual one to account for the type distinction we extend the unification relation to be a relation u × × where t c u s means that the constraints c plus u x for each u x t are unified by s we modify the previous unification relation as follows t ux c u s t u sb ai t c u x u s t ux c u s t c u x u s first we no longer discard constraints that u x because we must now ensure that su x to secure the type distinction second to satisfy an empty constraint set the corresponding substitution s must map all type variables in t to gradual type parameters ai the remaining type variables have no constraints so they can safely be mapped to static type parameters bi with these few extensions the corresponding notions of soundness and completeness of unification as well as principal types hold proposition principal types suppose x tx u x c x then if sx c for some sx it follows that c u sx and sx x is a principal solution for x and tx proof follows from completeness of unification this proposition establishes that our type inference procedure produces the best type possible and along the way proves that the type system has a welldefined notion of best types dynamic semantics this new type distinction suggests two more interpretations of these interpretations differ with respect to whether or not they enforce at runtime and conversely with respect to the complexity of the necessary runtime support our language from sec corresponds to interpreting both static and gradual type parameters using runtime sealing a more refined language could use static parametric polymorphism for static type parameters and runtime sealing only for gradual type parameters viewed from this perspective siek and interpret all gradual type parameters as leaving only the static type parameters this language model can be translated to the monomorphic blame calculus static type parameters in the standard way note however that this translation of bs to s implies a syntactic of our programs in particular since our type system does not infer gradual types this corresponds to a refinement process on programs that introduces new type annotations to a program that change some parameters to gradual types the language these types without since gradual types were always but at the cost of a complex type system and discussion construction of the type system and inference was systematic and driven by underlying principles of the static type system the structure of light on the structure of the simply typed calculus type system in particular the origin of the two typing rules for function application the constraint typing judgment does not hold for every term pair this property out of our decision to reduce all gradual predicates and functions to consistency constraints on gradual types and equality constraints on static types alternatively we could have produced constraints that directly correspond to those operators doing so would force us to also support gradual type variables at least to account for the meet operator when typing if expressions this design simplifies the constraint typing judgment at the of the unification judgment which would have to process more constraints and be of the order in which they are processed reducing constraints imposes fewer extensions on the corresponding static unification judgment the type system can be easily shown to conservatively extend the type system in particular the gradual operators all reduce to their static counterparts when applied to static types in contrast siek and requires explicit reasoning to establish this property distinguishing type parameters from type variables was central to understanding the distinction between static polymorphism and gradual polymorphism both of which are orthogonal to the type inference problem this distinction explains siek and observation about assigning the unknown type such types are not principal according to their type system but they arise naturally from interpreting gradual type parameters in our system as the ease with which extends with suggests that the language may be amenable to other common features of hindleymilner type systems like row polymorphism wand b and restricted firstclass polymorphism peyton jones et al we intend to explore some of these more advanced features in the future furthermore we believe that the connection between this system and its underlying static language suggests that it may be reasonable to extend an existing language implementation to support gradual type inference although can be safely translated to either the blame calculus bc or the polymorphic blame calculus we do not yet understand all the tradeoffs involved the bc imposes less runtime overhead since it does not require runtime sealing but the enforces extending the language with firstclass polymorphism and implementing gradual type inference in a real language may provide further insight related work aside from siek and the most closely related work to ours is et al it presents an approach to type inference for a variant of the language that combines static and dynamic checking although both works involve and inference the two have essential differences that make them complementary first the two approaches start with different kinds of languages we begin with an implicitly typed functional language for which types are typically inferred using unification et al start from a objectoriented language for which unification is to infer types second the two approaches start from different conceptual foundations et al begin with a typed language in the style of siek and where missing type annotations are syntactic sugar for annotations and extend it with support for type inference to do so they missing type annotations as type variables and solve for gradual types using a algorithm we begin with an implicitly typed language and extend it with gradual typing in doing so we infer the same static types as the underlying language it is interesting to observe however that siek and start from similar foundations to et al but arrive at a type system like ours third the two approaches have distinct goals et al are interested in reducing the performance overhead of gradual typing by removing dynamic checks where possible without changing the runtime error behaviour of programs we are interested in reasoning about programs in terms of the underlying type system ultimately the two approaches are complementary in particular we believe that techniques similar to et al could be applied to to reduce runtime overhead one open problem in this direction is the interaction between inference and runtime sealing conclusion dynamic checking is often characterized as the practice of checking at runtime those expressions that lack type annotations static checking on the other hand is associated with introducing type annotations to achieve more safety this paper the combination of dynamic and static checking and finds that the tables reverse in the foundations of gradual type inference there can be no without annotation acknowledgments the authors would like to thank siek ahmed bob harper and the anonymous reviewers for comments and suggestions about this work references a ahmed r b findler j and p wadler blame for all in proc st workshop on script to program evolution stop pages ­ new york ny usa acm a ahmed r b findler j g siek and p wadler blame for all in proc symposium on principles of programming languages popl pages ­ new york ny usa acm g e and m adding dynamic types to c in t editor proc th european conference on objectoriented programming ecoop number in lecture notes in computer science pages ­ june springerverlag r cartwright and m soft typing in proc conference on programming language design and implementation pldi pages ­ new york ny usa acm d a dictionary of and s k and d s automatic mode inference for logic programs journal of logic programming ­ sept jy girard et des de phd thesis paris vii j k a s n and c flanagan hybrid checking for flexible specifications in proc scheme and functional programming workshop pages ­ j and a ahmed parametric polymorphism through runtime sealing or theorems for low low in proc european conference on programming languages and systems pages ­ berlin springerverlag j and r b findler operational semantics for programs acm transactions on programming languages and systems ­ r milner a theory of type polymorphism in programming journal of computer and system sciences ­ aug a a simple semantics for ml polymorphism in proc international conference on functional programming languages and computer architecture pages ­ new york ny usa acm s peyton jones d s weirich and m practical type inference for types journal of functional programming ­ jan b c pierce types and programming languages mit press cambridge ma usa a a and b the ins and of gradual type inference in proc symposium on principles of programming languages pages ­ new york ny usa acm j c reynolds towards a theory of type structure in programming symposium proceedings la pages ­ london uk uk springerverlag j a a logic based on the resolution principle j acm ­ jan i and d clarke gradual ownership types in h editor proc european symposium on programming languages and systems volume of esop pages ­ springerverlag j siek and w gradual typing for objects in e editor proc european conference on objectoriented programming number in ecoop pages ­ berlin germany july springerverlag j siek r and w exploring the design space of higherorder casts in proc european symposium on programming languages esop pages ­ berlin springerverlag j g siek and w gradual typing for functional languages in proc scheme and functional programming workshop pages ­ sept j g siek and m gradual typing with inference in proc symposium on dynamic languages pages ­ new york ny usa acm n c fournet a k j chen py and g gradual typing embedded in javascript in proc st acm sigplansigact symposium on principles of programming languages popl pages ­ san diego ca usa jan acm press s and m felleisen migration from scripts to programs in companion to the st acm sigplan symposium on objectoriented programming systems languages and applications oopsla pages ­ new york ny usa acm isbn x s and m felleisen the design and implementation of typed scheme in proc th acm sigplansigact symposium on principles of programming languages popl pages ­ san francisco ca usa jan acm press p wadler and r b findler welltyped programs cant be in proc european symposium on programming languages esop pages ­ berlin springerverlag m wand a simple algorithm and proof for type inference ­ a m wand complete type inference for simple objects in proc nd ieee symposium on logic in computer science pages ­ b r r and j gradual typestate in m editor proc european conference on objectoriented programming volume of lecture notes in computer science pages ­ uk july springerverlag a k wright simple imperative polymorphism lisp comput ­ dec a k wright and m felleisen a syntactic approach to type soundness journal of information and computation ­ t f s j and j integrating typed and untyped code in a language in proc th annual acm sigplansigact symposium on principles of programming languages popl pages ­ jan acm press 