on the complexity of lrk testing b iii university of thomas jeffrey princeton g and d ullman university abstract in this paper we derive upper bounds on the complexity of lrk test k is considered to be a fixed integer and also when k is considered to be a of the problem in the latter case we show that the lower bounds on the running time of such algorithms depend very strong ly on the representation chosen for k s lrk testing is npcomplete when k is expressed in unary and complete for exponential time when k is expressed in binary these results carry over to many other parameterized classes of grammars such as the strong strong and extend ed precedence lk grammars i introduction it has long been known that lrk parsers can have a number of states which is exponential in the size of the grammar which they parse nevertheless for any fixed value of k there is a polynomial time algorithm for testing whether an ar grammar the lrk property a class k of on algorithms t work supported by nsf grant gj tt work supported by us grant we consider the sum of the of the grammar the size of a grammar to be lengths of the productions and denote this size by n are implicit in whereas a class of o n k algorithms are presented in in section of this paper we shall this bound by presenting a class of k o n algorithms in section we shall consider lower bounds on the complexity of any uniform algorithm for lrk testing that is any algorithm which accepts both k and the grammar in question as parameters more specifically we shall show that the prob lem of testing whether a grammar is lrk is complete for nondeterministic polynomial time if k is expressed in unary as an input to the algorithm exponential chosen complete for nondeterministic time if the natural of k as a binary integer moreover these results carry over to many other parameterized classes of grammars throughout this paper we shall use the notation k to refer to any of the following classes of grammars strong strong lrk similarly will refer to the and ex i by exponential some polynomial time p we mean pn for precedence lk classes of grammars the rest basic notions of this related section to lrk parsing the then for let g any a e v we define be a cfg xi a x and x k similarly we define k x u r xy but b for any nonterminal a definition let g be a cfg let and s be symbols not in v we define the grammar de from g or simply the grammar when k is understood to be with these we may de fine an lrk grammar as follows definition grammar augmented lrk if let g be a context free and g be its k grammar g is said to be the three conditions jm s aw imply that some additional terminology is before we state a lemma which will lead into the results of section definition suppose that s rm rm is a rightmost derivation in grammar g then any prefix y of ub is said to be a prefix of g moreover if and u c p l then we say that a b u is a valid lrk item for al the following equivalent definition lemma provides an of lrk grammar lemma let g be an text free grammar then iff there exist augmented g is not a string u e a prefix y two distinct lrk items a au and b bv such that a and i are both valid b u c for y section upper bounds in this section we shall consider the problems of testing whether a grammar is lrk both when k is fixed in advance and when k is a parameter of the decision pro the bounds which we obtain repre sent a marked improvement over those re in which prefixes which right we need one preliminary definition we shall be able to associate with those strings of k symbols may follow them in a form by definition let of g k u is said to be a if there exists a y be a lookahead derivation prefix for y with note u c b z and k the use of y a rather than yields an equivalent definition rithm which very the key construction used by our algo is described in the next lemma in we show that the set of pre having a given lookahead string has a simple structure lemma let k then there finite state g be an exists a nondeterministic automaton mu such cfg and that mu accepts precisely prefixes of g which lookahead string those have u as a define mu as let q xv and q a a and let q ia ve define a a zi a a b c z x zz e u d x ai t z a call these transitions type a b respectively c and d let qo s a let f a i bz i uc it is straightforward to verify that i x e iff w such that s with z c il suffix ii a b iff a such that y s rm this definition establishes z e fi fact in conjunction with of the set of final states part of the lemma the f next we must bound clearly lp kl the size of m and iq g kl consider next the transitions of foreach production of g there are exactly kl transitions of type a hence the total number of type a transitions is p kl the number of type b transitions is exactly and for each of the states in q there can be at most the most tions kl transitions number of type n hence the of is kn of type c d transitions total number of thus finally is at kn the construction efficient lrk test on the ability to efficiently detect the presence of lrk conflicts we formalize this notion in the following definition definition let g be a cfg let mu be constructed for grammar corresponding according to lemma and the to ue ek define y i contains or more final states proposition g is lrk iff for a proof directly from lemma and lemma tl the next corollary if lrk conflicts occur also occur on relatively demonstrates that at all then they short strings corollary there length lrk if g is not lrk exists a prefix of which conflict then g of an pt by proposition for some u let string in length of y y be the and let shortest us bound the consider any two computations of m on y which accept y by different final states the standard repeated pairs of corresponding states argument to show that the bound mentioned in the statement of this corollary may be achieved by noting that the lookahead component of the states in any tion must be ing hence y can be partitioned into at most kl segments in which the lookahead component of the states of both computations remains constant in any computation at least state of q must appear between any two grammar f a computation of m on string u is a such that each si eq each xi and a xx xm o s symbols thus no segment as defined above of y can be as long as or else there would exist a member of which is lemma k emptiness than y hence let g be a cfg and then may be tested in for a deterministic time kn b nondeterministic time ok n m a first we construct mu augmented grammar g the only for the parts of this construction which cannot ob be done in steps are determining the transitions of type c and computing the set of final states f to do these z we construct in which a grammar and a e p u notice that and that w iff g w can be converted to form ie the right side of any production is of length o or without alter ing its size or deleting any als if we now apply algorithm we can compute to and ua lk a a table t such that ab i ai construction of this then makes it trivial type c transitions in m table takes steps this table to compute which are to be included a similar compute f to construct construction allows us to thus the total time necessary mu is kn steps we shall constructing test a set for c a such that s represents the which are mutually string of distinct final set of pairs of states reachable on some input is empty iff no pair states is a member of s the set s will be stored as a bit matrix we will also maintain a stack stack of members of s the algorithm for computing s appears below procedure pq s then begin add pq to stack en d end insert s insert while stack begin pop w empty do pq from stack e a insert pq vp s qa insert pq if p and q b w and x y then insert en d en d it should computes s work performed statements be clear that let us consider by each of the the algorithm the amount of since no pair of states is ever twice statements and require a maximum of iq kn work in the worst case statements and will be ex for every pair pq of the amount of work done in statement will then be z i representing traversal of the pa list for each p and q however z z z pq kn kn as explained in the proof of lemma hence the work and similarly to to statement statement is b in order to test we simply guess a string y and test whether y e by corollary we may assume that we must next verify that y supports two accepting with distinct final states in order to check this condition those we need only construct which are actually used in either accepting computation observe that any computation of m on u contains at most k transitions of type c ia tions of type b and as many as transitions of types a and d recall that it is possible to non test whether in time since the sum of the lengths of the lookahead component pro by each type c transition in an accepting computation is exactly k we may guess which type c transitions we shall need using a total time of finally we may nondeterministically any portion of the computation which consists only of type a and d tions each such requires unit time if we have the set xy i x y in time n which may be constructed since upper each test takes kn time and there are at most such strings we have the desired bound similar techniques yield similar bounds for testing whether a grammar is or extended precedence k moreover since the methods of may be adapted to reduce or testing to lrk testing and strong and strong testing to testing we conclude theorem for there exists a time algorithm grammar is ck every k for deterministic for testing all l and polynomial whether a k it is important to note that this theorem k before selecting the sion procedure that is it establishes the existence of separate and distinct polynomial time algorithms for co testing testing etc we can also apply theorem case in which we have a single which takes both k and as inputs to the decision a grammar theorem an arbitrary tested for membership in nondeterministic is polynomial in both in l k and n grammar can be in ck or in time which k and n poly section lower bounds thus a representation ing computation of a can in time kn of an constructed the above lemma leads directly first major result of this section to the theorem an arbitrary cfg can be tested for the lrk property in a nondeterministic time kn b deterministic time ok n k proof a we can determine that g is not lrk by some string u and testing whether is empty by lemma b this requires at most kn time b to perform we merely emptiness this test test for for each of the strings u in this section we develop an idea of to yield lower bounds on the complexity of lrk testing suppose that m is a nondeterministic turing machine which always halts before taking more than tn steps on any input of length n given an input string x we can construct two context free languages li mx and such that o is the initial id of x configuration z o lo z is an accepting of m configuration o i y and z are configurations of m and y z o it is easy to accepts x iff l ln moreover jl l and l are l l generated by that is gram in which every right side of a tion begins with a terminal and no two productions for the same nonterminal with the same terminal lemma let m t and x be as above t xl then in time and g each g where c depends only on following are equivalent we can of size m such find lx that the m accepts x lg some pair of words in and lg have a common prefix of size k is ambiguous is not ck is not lk for any is not g and g are the gen and respectively is the all of the along with grammar whose productions s i productions of g and g a and b are the equivalence of the conditions should be obvious marks preceding the statement first four from the the lemma class verify condition clearly and moreover represented by a that g can fail implies conditions for each grammar it is possible to to be in g only if thus the last tions first of the lemma are equivalent four to the finally we point out that in the case of representing the class of ex precedence grammars it is necessary to perform minor on g to make it uniquely invertible before the above lemma rl let us turn next to the this section namely uniform for k testing main topic algorithms of theorem let q be any algorithm which takes a context free grammar g and an integer k pair of integers l and k as inputs and determines whether g is lk lk then there exists as constant c such that requires units input pairs of gk infinitely more many proof directly from lemma n the in terms represent next theorem this result of the amount of space needed to both input parameters theorem the problem of determining whether g is ck or lk with both and k or t and k considered to be parameters is g a complete for nondeterministic poly time if k or l and k are expressed in unary b complete for nondeterministic time if k or l and k are expressed in binary the fact that the problems can be done within the required time bounds follows directly from theorem to complete of space grammar see that the problems are in fact we need only consider the amount needed to represent both the g and the value of k mentioned in lemma let be the space when k appears in unary and s x space used when a binary representation needed be the is employed then log if t is a polynomial function then s is also a polynomial function if t is an exponential function then s is still a polynomial function n note that we have shown testing to be at least as hard as the above but have not provided the upper bound as we did for the classes represented by k and ck conclusions the undecidability of problems ing context free grammars is an accepted fact we have shown that even if one restricts the questions which one is allowed to ask for example by whether a grammar is lrk for some particular k rather than whether there exists a k for which the grammar is lrk then the resulting problems are still more specifically we have shown that no good uniform algorithm exists for testing or any of a number of similar properties if k is allowed to be a parameter of the algorithm we leave as an open question whether there exist algo for specific values of k which are faster k than the on class of algorithms presented references hb iii tg and jd unman operations on sparse re and efficient for grammar problems ieee conference record of th annual and automata symposium on theory j contextfree languages and turing machine computations pro applied math volume pp aho av and jd unman the theory of translation and and f knuth de on the translation of languages from left to right mation and control pp aj and hopcroft simple deterministic ence record on switching languages of th annual and automata ieee theory pp bm deterministic trans grammars tr center for research in computing technology university recognition of contextfree languages and parsing in time n information and control pp 