of data languages v aho bell hill new and jeffrey d princeton princeton new abstract we consider the question of how powerful a relational query language should be and state two principles that we feel any query language should satisfy we show that although relational algebra and relational calculus satisfy these principles there are certain queries involving least fixed points that cannot be expressed by these languages yet that also satisfy the principles we then consider various extensions of relational algebra to enable it to answer such queries finally we discuss our extensions to relational algebra in terms of a new programming language oriented model for queries introduction one facility provided by a database system is a query or data language whose primary function is the extraction of information from the database the data by a single query can range from a small simple subset of the database as in print the name and address of the with number to a large complex subset as in print the names of all under whose last three raises have been above average a query will be treated as a mapping on the contents of the database which we here regard as a col of relations cl the value returned by a query will also be a relation that is a set of k tuples for some kl one key question concerning query languages is what power they should have for example should a query language be able to specify any mapping from lists of relations to relations it is our point of view and one held widely that a query language should provide physical data independence that is the result of a query should not depend on the representation of the data we also feel that the role of a query language should be primarily the selection of data from a database rather than arithmetic computation on this data the computational capability if desired should be separate from the capability this separation of function has a number of t work partially supported by nsf grant e benefits such as simplifying the optimization of both the computational and the query operations we therefore two principles that a query language should in essence these principles state that the value produced by a query should be independent of the manner in which the data are actually stored in a database and that a query language should treat data values as essentially uninterpreted objects although certain properties such as a linear ordering on certain domains can be built into the query language these principles are defined more formally in section the relational algebra and calculus of c satisfy these principles and are often used as models of a query language one purpose for which introduced these languages was to provide a for the relative power of query languages there is however an important family of least fixed point operations that still satisfy our principles but yet cannot be expressed in relational algebra or calculus such fixed point operations arise naturally in a variety of common database applications in an system for example one may wish to determine the number of possible between two during a given time period in a network analysis system one may wish to determine whether there is an active circuit connecting two points in a management system one may wish to determine the manager common to a group of none of these queries can be in relational algebra in the appendix we give a formal proof that the transitive closure of a binary relation an elementary example of a least fixed point operation cannot be expressed in relational calculus in sections and we consider extensions to relational algebra to enable queries such as these to be expressed in section we discuss various methods by which relational algebra expressions containing least fixed point operators can be efficiently implemented finally in section we examine the of our extensions in terms of a new programming language that is intended to serve as a model of computation for query languages we show that the programming language is at least as powerful as relational algebra with a least fixed point operator we also show that original formulation of relational algebra is equivalent to this language with a restrictive interpretation of the semantics of the for statement in this language two principles for data languages the general consensus is that at least for query languages based on the relational model one does not wish to have general turing machine see hu eg capabilities in particular one wants the query language to be sufficiently high level that it deals with relations as sets of tuples meaning that the order in which the tuples are considered should not influence the result in this sense the turing machine working on an input tape con lists of tuples is too powerful a model this is the basis of the first of our two principles regarding what pro a relational query language should have the result of a function on relations should depend only on the values of the relations as sets of tu the result should not depend on the order in which the tuples are stored our formalization of the second principle is related to an idea used independently by and b to characterize certain aspects of relational queries their idea is that queries should preserve that exist among the values that appear in argument relations more formally assume d is the domain from which all values for the components of relations are taken let k be a mapping of d into itself d is infinite call a renaming if f is a function that takes n relations as arguments we say f with k if r wr let us call f an acceptable if f with every renaming in this sense operations like the union or cartesian pro of relations are acceptable so is the transitive sure of a binary relation there are however other queries we might well regard as acceptable that do not commute with arbitrary for example print the name of the with number does not commute with that do not map to itself saying that the renaming should also apply to in the query the issue that we are concerned with a class of abstract functions on relations and such functions need not have a concrete representation where a treated constant like is explicitly named another problem comes up when we want to use a relationship like as in age we would not expect such a function to commute with those that did not preserve the order on d we thus extend the in the following way we the existence of a collection of p on the domain d these could be sort of predicates for example a unary predicate like x or a binary predicate like x y intuitively one might expect that a function f uses some finite sub set of the available predicates in p to extract or select in formation from its argument relations we would not therefore expect that would commute with that did not preserve the predicates we say p preserves predicate p xl x if xn is true if and only if is true for example if p is x then p preserves p if and only if it maps and therefore no other value to k preserves if px if and if x y we can now state our second principle formally principle a function f is with respect to a set of predicates p on domain d if only if there is a finite subset pi c p such that f with every renaming that preserves the predicates in pi in what follows we shall always talk as though d were a set containing integers reals and character strings with defined in the obvious manner when applied to values of the same type we shall also take the set of predicates p to be boolean combinations of statements of the form x y and x c for some constant c in d the ideas extend to other sets of predicates although if we use too rich a set such as xyz and we can with a finite set of predicates pi that only the identity mapping preserves pi thus making every f we shall not take ii position on the correct set of underlying predicates but we shall take the two principles above as a definition of what properties a complete query language should have relative to a given set of builtin predicates p relational algebra cl is often used as a model of a query language that is as a minimal set of operations that every query language should have we shall describe relational algebra in the next section it will be obvious that all queries in relational algebra satisfy the two principles above if the predicates are taken to be x y and x c for all constants c relational algebra in this section we shall define a set of relational algebra expressions that is complete for relational calculus which is the first order theory of relations tuples with comparison operators and on components of tuples c the operands of an expression are either constant unary relations or variables representing relations the operators of an expression are the following cartesian product if r and s are relations consisting of r tuples and s tuples respectively then r x s is the set of rs of which the first r components are an r tuple in r and the last s components are an s tuple in s set union if r and s are relations whose tuples are of the same length then r u s is the union of the tuples in r and s set if r and s are whose tuples are of the same length then r ­ s is the set of tuples that are in r but not in s selection let f be a predicate built from i the logical operators and a or v not ii the arithmetic relational g and operators iii operands of the form i for the ih component of a tuple then r t i for some tuple t in r f becomes true when i is replaced by the ih component of t projection tz r t i for some t in r t is the k tuple whose jth component is the h component of t we assume ik have no although this constraint is not essential and the s are not assumed to be in any particular order all expressions in relational algebra produce relations as values when given relations as arguments moreover the value of an expression cannot involve a symbol in a tuple if that symbol was not part of some tuple of some argument relation therefore if the operands in a relational expression are all finite relations then the value of the expression is also a finite relation example let r t then r and as another example we can define the composition of two binary relations r and s by r s r x s this shorthand will be used subsequently u the least fixed point operator consider an equation of the form r fr where fr is a relational algebra expression with operand r perhaps among other operands such that the degree ie the number of components in each tuple of r and fr are the same a least fixed of equation l denoted fr is a relation r such that i r fr and ii if r is any relation such that r fr then rc r in general there may not be any r satisfying i or any satisfying ii however t us that a unique least fixed point exists if f is monotone which in the context of the partial order c on relations means that if ri g r then fr c fr or equivalently u r u fr t throughout we shall indicate a tuple such as by the sequence there is a stronger condition called expressed by u u obviously implies so every additive f is monotone if f is monotone then by induction on i we can show that f c f where f is f applied i times if all argument relations are finite then since no new component values are introduced by the relational algebra operators we know that there is some finite relation of which each f is a subset therefore there must be some no such that f we shall use the term f n for it is easy to check that f is a fixed point of r an induction on i shows that f is contained in any fixed point of equation therefore f n is the n least fixed point of l example the transitive closure of a binary relation r is the least fixed point of r if we let fr r tj ro then fl i times as may be proved by an easy induction on n thus by the least fixed point of r fr is what we normally call the transitive closure that is i times example suppose we have a database representing containing the relation where source and indicate the source and destination and indicate the and times we might wish to compute a relation with the same four components that includes and in addition represents all finite sequences of such that in each sequence i the destination of each except the last is the source of the next and ii the time of each except the last occurs before the time of the next we could express this relation as the least fixed point of the equation u h md x note that when we treat as an equation of the form r fr then n is u x r and is an operand that is to be a constant as far as the taking of a fixed point is concerned u the following theorem is easy to prove by induction on the number of operators in a relational expression theorem any relational algebra expression that does not use the set difference operator is additive in all its variables u on the other hand a expression can have a least fixed point and not every expression involving the difference operator fails to be monotone embedding the least fixed point operator in a query language the problem of how to incorporate a least fixed point lfp operator into a query language in a useful manner is not trivial to begin it may be hard just to determine whether the lfp of an equation exists let alone to what it is also evaluating a lfp in a straightforward way may be computationally infeasible unless some advantage is taken of the of a relation or the special nature of the expression involved in this section we propose three syntactic mechanisms the lfp operator can be made available to a query language modeled after relational algebra provide specialized operators such as closure or transitive closure that can be applied to certain relations such are clearly useful but they do not provide us with the of the lfp operator witness example standard methods for computing the transitive closure will probably be expensive unless they take into consideration the likely of a relation recently an algorithm for transitive closure that is optimal in an expected time sense has been given s a facility to define transitive closures but not general is available in z provide a syntactically way of saying let s be the lfp of r fr where f is an expression in relational algebra perhaps with other fixed point operators in essence here we are that the user be able to write down an equation that his relation satisfies but no smaller relation satisfies if he does so and his intuition is correct r fr will have a lfp if f is monotone the lfp can be computed using where as we have mentioned only a finite number of terms need be taken before we obtain the limit there is however no a priori upper bound on the number of terms to be taken provide a procedural method of constructing a relation r inductively that is we provide a basis rule that says r g r for some relation ro which may be an algebraic expression of existing relations we then provide an inductive rule that says g g r where g is some function of r expressed in relational algebra that has as value a relation with the same degree as r by implication we assume an exclusion clause saying that nothing is in r unless it follows from the basis and induction rules we might express such a procedure in terms of a simple do rr r r u gr while r r now the value of r can be computed as the limit of the sequence xo xl where x r and t gl u ki for il if g is monotone and fr ro u gr u r then f is also monotone and x g f g x for all i as an easy induction on i shows as the limit of f n exists the limit of x exists and the limits are the same conversely if f is monotone then the lfp of r fr can be expressed by giving the basis rule g r and the induction rule fr g r as f c f follows from monotonicity and tion on i we see that f therefore for functions and are equivalent in their ability to define relations however method has the additional advantage that the limit is known to exist independent of whether g is monotone since when g is a relational algebra expression there are only a finite number of symbols that can appear in the tuples of any x and optimization of queries with the lfp operator the mechanical optimization of queries that is possible when the operators are union selection projection and cartesian product cm does not seem to be available when the lfp operator is included a alternative is to develop laws for the lfp operator similar to those developed for other relational operators by sc most important is a method for evaluating of lfp operators for example this change can convert a general transitive closure problem into a single source shortest path problem we shall present a method for over a lfp operation provided that in the expression fr the function f is such that it has only one instance of r there are certain restrictions on the form of the selection as well since selection does not commute with cartesian product in we also assume either that f is monotone or that the semantics of the lfp operator are such that the limit of the series is what is let us begin with an example that will introduce the general method example the transitive closure a relation r is r o r ij r if we want to know the points accessible from a given point ao we could write r o r j ro however computing the desired relation s is in rj requires that we first compute j an operation that is far more expensive than we need our goal is to in a sense move inside the lfp operator so s can be computed directly our approach is to replace the expression r u rj by its infinite expansion obtained by repeatedly replacing r by r o r u ro expression has the form u ro since tion across union we can rewrite as u where expression x has the form y o ro and y we would now like to the selection operator across the composition but we may not do this in general if the selection involves only the first or second argument of the composition however then it is possible to move the selection through the composition operator since involves only the first argument here we can replace by y o ro u we now note that y looks exactly like our original expression if we use e to denote the value of we obtain the following fixed point equation for e e e u lo the value of equation can be computed relatively efficiently by expanding according to note that we never put into t any tuple ab with a ao u the above example works because several conditions hold the function fr r o ro u ro is monotone so the infinite expansion makes sense and the con function o is also monotone we are able to the selection operator through every subexpression of c we obtain a subexpression which has the same form as our original expression condition turns out to hold without loss of generality holds this follows from the fact that the selection cannot change substantially as it is dis it can only apply to different components or entirely thus only a finite number of tions are ever applied to the various subexpressions we can now state our general algorithm for taking an expression of the form a fr where fr has only one occurrence of r and is monotone and converting it to a particular expression h lfp sg s the work involved in computing the latter expression is of no greater order than that to com the former and in some will be an order of magnitude less algorithm distribution of selection through the lfp operator input an expression lfp r fr where fr has only one occurrence of r and is monotone an equivalent expression g method we construct a sequence of expressions eo el each with one occurrence of the operand r by the following rules basis eo is induction suppose we have constructed e if e has a subexpression of the form then in e replace by uc f r since fr has one occurrence of r the resulting expression will also have one occurrence of r we now attempt to the selection operator through fr as far as possible using the following identities if uc is applied to yx z the following rules apply i if c applies only to components that come from y ii if uc applies only to components from z g is g with the component numbers appropriately iii if neither y nor z by itself includes all com mentioned in g we cannot the selection through the cartesian product lj z gy u az y where g is g with component numbers appropriately as a special case if the selection is not distributed to the subexpression of fr that contains r then apply the trivial selection that is satisfied by every tuple to that subexpression this is done for convenience to ensure some selection will eventually reach the argument r expression el results from applying these rules as far as possible we continue the induction with el in place of e except in two cases if we are unable to pass a selection through a cartesian product of terms one of which involves the ar r then we fail to commute of with the lfp operator if e is of the form h g and for some j e is of the form h then we have found g and h from el we construct the expression gs theorem if f is monotone algorithm succeeds in producing an equivalent expression h gs if no relation appearing as an operand in f or as the result of evaluating a subexpression of f is empty then the time to evaluate h lfp sg s is no greater than a constant times that needed to evaluate m r f r and in general may be much less some extensions the same technique as described above for can also be used to some projections into a lfp operator in fact projections always pass through a cartesian product so there is no of failure from that t we could combine the two but we assume within f have been distributed as much as possible and to combine here may make it impossible to pass our selection through a cartesian product source we may also generalize what we have done to lfp operators that simultaneously define several relations toward an improved model relational query language in this section we define a language that we feel can serve as a model of computation for relational database operations the language the principles specified in section and has the ability to create new tuples from given tuples by selecting certain components from the given tuples and them in some order create new relations copy relations iterate over all tuples of a relation in an unspecified order make tests based on some property of a given tuple provided that property involves only arithmetic comparisons among components of the tuple and perhaps constants make tests based relation although we cannot prove that we have found the maximal class of queries that respect the two principles of section we nevertheless feel that our language serves as one natural benchmark against which other notations can the same way that relational calculus serves as a benchmark under one natural interpretation of the iteration statement our language is equivalent to relation calculus or algebra under another more general interpretation it is at least as powerful algebra with the fixed point operator and we conjecture that it is strictly more powerful a language for data we now define our data language the statements of the language are as follows tn here t and variables and is a func tion that produces from tuples particular tu ple where tj is the jth com t r here variable a relation variable rs r is a relation variable and s is a relational variable or constant r do statement here t is a tuple variable whose scope is local to the for statement and r relation variable any tuple variable assigned within the for statement is assumed local to that for statement we shall see that the precise semantics of the for statement determines the class of functions definable in the language statement else statement here t is a tuple variable is a predicate built from the arithmetic comparison operators and the logical con and or not r then statement else statement again a relation variable begin statement list end this statement defines a tuple t whose scope is local to the block in which this define is contained a program in this language is a statement which can be a block the input to a program is the set of relation variables in the program that are referenced but not previously defined one relation variable is designated as being the output relation variable thus a program computes a function whose arguments are the input relation variables and whose value is that of the output relation variable we assume that for each relation variable there is a fixed degree and all tuples in the relation have this number of components we also that there is a fixed arity for each tuple variable finally we assume each component of each relation is selected from a known finite domain for component the four interpretations of the for statement the semantics of for statement for t in r do statement can be defined in different ways there are two orthogonal issues the statement should be executed for each tuple of r but should the execution be in parallel or should we iterate over t in r the second issue is should the value of r be bound on entry to the for loop or should it be allowed to change within the loop in each case we get a class of functions let us consider the four interpretations and the resulting classes of functions in turn r bound before the loop parallel execution in this interpretation we associate with each tuple variable a set of tuples the following rules are used to interpret the statements t to t the set of tuples formed by taking one tuple in each set for t i n and applying f to those tuples for example if the assignment is t of tuples denotes concatenation then the set for t is the cartesian product of the sets for t r and r are executed by setting r to r u t and r ­ t respectively where t is the set of tuples associated with t r s has the obvious meaning and does not the sets associated with tuple variables for do statement the set associated with t is r at the beginning of statement the tuple variable t is local to the for statement if pt then statement else statement let t be the set associated with the tuple variable t before the if statement let t be the set s i s is in t and ps within statement set t is associated with tuple variable t and within statement if it is present t is associated with t after the if statement t is again associated with if at that time the union of the two sets associated with t is not t note that we in effect define a new t local to the if statement if then statement else statement the meaning of this statement is similar to with t begin statement statement end any changes to the set associated with a tuple variable lo cal to the block made by statement i carry over to the next statement unless the rule for statement i causes the value for that variable to be changed as in example consider the program in fig which com t suppose r ab ac bc and s aa cb initially after statement t rs the sets as with tr and s are ah ac be and aa cb respectively the state ment insert u t sets t to ab bb which is r os u begin ta for sin s do for r in r do begin local u if t t then begin u t t insert u t end end end fig program to compute composition theorem the set of functions computable by programs with t bound to the current value of r in for t in r do and parallel interpretation of for loops is with the functions computed by relational algebra expressions r not bound before the loop parallel execution there is the possibility that r changes within a for loop and if so we might wish to consider the possibility that the set associated with t in the loop for t in r do changes as r changes one way to effect such changes might be to modify the set associated with t after an assignment insertion or deletion to r within the loop it is not hard to show that such an interpretation does not add to the capability of the language to produce new functions the language is still equivalent to relational algebra a second interpretation is to fix the set associated with to repeat the for loop with t associated with the set of tuples added to r at the previous until at some point no new tuples are added to r let us call this interpretation the interpretation of programs theorem every function expressible by the method method of specifying fixed points can be computed under the interpretation serial execution let us now consider interpretations of for t in r do statement that select an arbitrary ordering for the members of r and execute the statement once for each value of t we may either fix the set of ts before entering the loop or we may allow the set to adapt to changes in r within the loop the method of adaptation could be either of those suggested in section or we could at each iteration of the for loop select a t currently in r that has not been selected before unlike the interpretation this interpretation permits the loop to to within the loop we shall not fix on a serial interpretation with r not bound on entry to the loop because our negative remarks about the serial interpretation with r bound on entry to the loop apply to all these interpretations as well and our conclusion is that serial interpretations must be rejected as candidates for universal database languages our principal to serial interpretations is that they can violate the first principle order independence it is easy to construct programs whose output is determined by the order in which tuples in some relation are considered while we do not serial interpretations of our language as candidates for the notion of a universal data manipulation language we shall state the following theorem which places the interpretation above into theorem every relational algebra expression can be computed by a program under the fixed binding serial interpretation a v aho j e hopcroft and j d unman the design and a of computer algorithms addisonwesley reading mass a v aho y sagiv and j d unman equivalences among relational expressions siam j computing b f on the completeness of query languages for relational expressions de no france may cl e f a relational model for large shared data comm acm june c e f relational completeness of data base in data base systems r cd prenticehall n j pp ch a church introduction to mathematical vol princeton university press logic cm a k and p m optimal implementation of conjunctive queries in relational data bases proc a a cm symposium on theory of computing may pp d c j date an introduction to database systems addisonwesley reading mass j e hopcroft languages and addisonwesley and j d unman formal their relation to automata reading mass p j information processing letters s c p an algorithm for transitive closure with linear expected time siam j computing may sc j m smith p yt optimizing the performance of a relational algebra database interface comm acm oi oct y sagiv and m equivalence among relational expressions with the union and difference operation s proc acm international conference on ve large data bases sept t a a fixpoint theorem and its applications j mathematics june z m m a database language ibm syst j pp appendix in this appendix we prove that the transitive closure of a relation cannot be as an expression of relational it is interesting to note that both b in essence characterize relational algebra as equivalent to the set of mappings principle with respect to an empty set of predicates however transitive closure this principle there is no contradiction in bp it is shown that for every relation r there is a relational algebra expression e such that e r r the transitive closure of r what we show is that for no relational algebra expression e is er r for all r theorem for an arbitrary binary relation r there is no expression er in relational algebra equivalent to r the transitive closure of r suppose we have an expression er that is the transitive closure of r let z al aj al be a set of arbitrary symbols let ri be the finite relation aa aa all al ri represents the graph o we shall show that for any relational expression e there is some value of for which e rl is not r in particular we shall show by induction on the number of operators in e that er can be expressed as b b b i bz b where t is the logical or of clauses each clause is the logical and of atoms an atom is a formula bc bc b where not necessarily positive constant and bj c is short for that am such that b am c the bs are assumed to range over al a al where i is understood the assertion b b c says that b is c nodes down the chain formed by the graph of r from bj note that is not precisely a predicate of relational calculus since the bs have a fixed domain al al also it should be understood that the als are abstract objects and may not be ordered by arithmetic although ri ap to do this that is the expression rl x rr does not compute r rather it is because ul makes no sense when applied to a set of pairs of abstract a s the following lemma states a useful fact about logical expressions we shall manipulate lemma any logical expression consisting of the cal operators a v applied to atoms is equivalent to an expression consisting of clauses separated by such an expression is said to be in disjunctive normal form or dnf proof any expression in propositional calculus can be written as the disjunction of clauses consisting of the logical and of which are propositional vari ables or their negation the lemma follows since the ne t this claim appears in d p without proof or citation of an atom is an atom u we now prove the characterization of the values that may take for any relational algebra expression e lemma if e is any relational algebra expression then for sufficiently large er bl b i k for some k and some dnf expression v where the bs range over the set al az al proof the proof is an induction on the number of operators in e basis zero operators either the operand is r or a constant relation of degree the relation ri can be expressed as while the constant set cl c cm can be expressed as note the cs must be as for expression e to make sense all but projections are easy case e el u ez el ­ ej or el x ez let el have value bl bk i o b and ez have value b b i b if e or e then m k for e to make sense the value of el u e is b b i b b the value of is b bk b a bk in this case t a p must be transformed to dnf which we know can be done by lemma the value of el xe is b bj i bl b b in this case v a if be transformed into dnf case e let the value of el be b bk i bk if formula f involves an arithmetic comparison other than or then e makes no sense since the as are not comparable by thus f involves only and logical operators we may therefore express e as b b i b b and put the resulting formula into case e m el to begin we can express each projection as a of projections that the order of components and projections that eliminate the last component only let el have value bl bk i b if is a permutation then the value of e is easily obtained by bl b in appropriately now consider the case where m projects out b the value of el is bl b i bk as v is in dnf we can write substitute aj bc bk a true if jr false if jr b ac false if c b ac false if c r into b bd b false if b b fig result of substitutions b bd bw a if dj b b v tm where each t is the logical and of atoms for sufficiently large the value of e is b bk bk as we can handle unions by case let us consider only the case where itself is a single clause there is no atom of the form b v the logical and of all the atoms of w that do not involve bk any such must have the relation then the value of e is bl i w bl bk in proof note that for any fixed tuple bl that satisfies w we can pick bk to be al for some sufficiently large that all atoms of the forms bk zj b bk c or bk b c are true thus if bl bl satisfies it also satisfies bk conversely if b bk satisfies bk then bl satisfies all atoms that do not mention bk there is some atom bk aj b bk c or bk b c substitute for bk in all the other atoms of the expression a b ­ c or b c respectively the result is always equivalent to some atom or a logical constant which we take to be the result of the substitution as indicated in fig an atom with the value true a false atom causes the value of e to become the empty set which we may represent by b i bl bl if no atom is false the value of e is bl i where of the logical and of the following atoms the atoms of w modified by the substitution of fig in the case bk bc c was the substituted atom we add the atoms b a for j and in the case bk c was the substituted atom we add the atoms b aj for j c u now we return to the proof of the theorem suppose that er r for some expression e and any relation r then for sufficiently large ri can be expressed as b where v is in dnf case every clause of has an atom of the form bl a bz a or bl bj c or equivalently b consider the pair bb and where m is larger than any i such that bl a or b a is an atom in where d is positive and larger in magnitude than any c such that bl b c is an atom of v then bl am b ad satisfies no clause of however for sufficiently large am a is in r but not in e rl a contradiction case some clause of t has only atoms with the relation then consider the pair ada where no atom b am or b ad appears in and d is positive and larger in magnitude than any c such that bl bz c or b bl c appears in v note that from the construction of w in the case of projections in lemma that all atoms b aj added have j either close to zero or close to i where close means within some constant that depends on e but not on thus for sufficiently large ada is in e rl but not in ri another contradiction we conclude that for any e there is always an for which ez r u 