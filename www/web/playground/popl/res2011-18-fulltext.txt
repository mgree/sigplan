generative type abstraction and typelevel computation weirich university of pennsylvania pa usa simon peyton jones microsoft research cambridge uk university of pennsylvania pa usa abstract modular languages support generative type abstraction ensuring that an abstract type is distinct from its representation except inside the implementation where the two are we show that this feature is in with the features of type systems such as indexed type families and gadts in this paper we solve the problem by using kinds to distinguish between parametric and contexts the result is directly applicable to haskell which is developing support for typelevel computation but the same issues should arise whenever generativity and features are combined categories and subject descriptors d language constructs and features abstract data types f studies of program constructs type structure general terms keywords haskell deriving type functions introduction generative type abstraction allows programmers to introduce new type constants in their programs that are isomorphic to existing types examples include module system milner et al pierce ch and haskells construct peyton jones et al type generativity is important because it supports modularity by enforcing abstraction the of a module can move freely between the abstract and representation types whereas to the client of the module the two types are completely distinct there is growing interest in languages that support some form of typelevel computation including haskells type classes hall et al and indexed type families et al however there is a fundamental between typelevel computation and generative type abstraction at least in the more flexible forms to summarize very briefly the conflict is this · to reuse and convenience it is very desirable for the to be able to treat the abstract type a and its concrete representation type c as ­ we call this flexible type generativity permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm · however given typelevel function f the result of f a and f c may differ so a and c cannot be this conflict is the subject of this paper specifically our contributions are · we show in section that the naive combination of type generativity and typelevel features can violate soundness a problem that already in the glasgow haskell compiler and affects not only typelevel functions but also other forms of constructs such as generalized algebraic datatypes gadts and et al peyton jones et al xi et al · we formalize a solution to this problem that flexible type generativity and type functions in section our language fc builds on existing core language system fc et al which supports typelevel coercions the key in our solution is to employ kinds with roles to mark the that type contexts may make · we prove that fc programs are type safe provided that user axioms and definitions give rise to consistent axiom sets section · we give sufficient conditions for showing the consistency of an axiom set for our proofs we introduce a rewrite system for types that is novel in two dimensions rewriting i is and ii need not be strongly normalizing section · we present a result we show how haskell source programs that may involve type contexts and flexible type generativity can be translated to yield provably consistent fc axiom sets section · our core language is an improvement of system fc since it permits safe flexible type generativity but also type functions perhaps surprisingly our language is additionally a significant simplification of the original system fc which removes several of the original coercion constructs that we have identified to be even in the original system fc we discuss these differences in section for the sake of we build our presentation around haskell and system fc since this setting allows us to demonstrate our points with real code instead of using a calculus however we that our work is applicable whenever flexible type generativity and typelevel features are combined for example the very same issues could arise in extensions of the ml module system we discuss related work in section some of the technical material has been from this version of the paper for space although this paper is self contained more details are available at the problems with generative type abstraction generative type abstraction is an extremely useful mechanism for enforcing abstraction barriers and for refining interfaces to see this benefit let us consider the haskell of type generativity namely definitions in haskell the programmer may declare a age with concrete representation type int thus age int the uses the data constructor to coerce an int to an age and pattern matching to effect the inverse coercion for example age int age a n an the client in contrast can be from making such conversions by using the module system to hide the constructor module age where age definition and implementation coercion lifting in describing we data constructor in because although it behaves in many ways like a data constructor its cost model is different specifically a definition guarantees that the abstract type really is represented by the concrete type so the runtime conversion cost is zero that would not be true if age were instead declared with data instead of so age can be to an int and vice versa for without runtime it is an int we say that int age where we use for type equality but what about say maybe age data maybe a nothing just a obviously maybe age should be freely to maybe int because the two are represented in haskell one would have to write maybe age maybe int t a a t a b maybe a maybe b this is for several reasons a it is tedious for the programmer b it may be difficult to implement the necessary map function c it is hard for the compiler to eliminate a runtime call to the map function let alone to guarantee to do so especially if the map function is recursive as an example of b consider the mapping function for the type t shown below with co and and higher kinds data t a f t a t a int t f t a f t a f these difficulties are because we know that say t age maybe is represented to t int maybe so let us imagine a extension of haskell that provides lifted coercions that is it implements the following rule there are too many sorts of coercion lifting if for two types and we have for example if they are the abstract and concrete types of a declaration then t t for any type constructor t in fact this extension is not so because such a rule is the basis of the socalled deriving feature implemented by ghc it is not difficult to use deriving to define an identity function whose type is c c int c age ml supports coercion lifting even more directly within a structure the abstract and the representation types are considered entirely for example in standard ml one might say signature age sig type age val age int age end structure age struct type age int fun a n an end inside the two types are and so need not convert in either direction however the point of this paper is that the and lifting of type identities becomes unsound when combined with typelevel computation as we show in the next section typelevel computation one very popular extension to haskell is that of generalized algebraic data types gadts peyton jones et al with which we assume the reader is somewhat familiar in ghc one could declare a gadt with two constructors like this data k a where k age k int now consider these definitions using from section k age get k age string get age since gets type signature declares that its argument is of type k age the patterns in get are exhaustive but consider the call get it is well typed yet the pattern match in get will fail recall that is operationally the identity function and if the compiler assumed otherwise a runtime crash could result in the last few years we have beyond gadts by extending ghc with typelevel functions et al ab et al the reader is to these papers for motivated examples of type functions but for the purposes of this paper we content ourselves with a small but example type family f a type instance f age char type instance f int bool here the type function f maps the type age to the type char but it maps int to bool however the existence of such a typelevel function not just pattern but type soundness itself consider the type bool this type is equivalent to f int by the equation for f and by coercion lifting that should be equivalent to f age and that is equivalent to char by the other equation for f we can coerce bool to char which is obvious what wrong maybe it should be illegal for a type function to behave differently on two types such as age and int but in fact haskell programmers often use precisely so that they can give a different instance for comparison say for age than for the underlying int type functions are no different indeed they are often introduced as an associated type of a type class et al and hence just as the type class distinguishes between the abstract and concrete type so must the type function how else might we fix the problem perhaps in the definition of coercion lifting we should not allow t to range over type functions such as f or gadts such as k indeed we should not but that is not enough consider data tf a f a now should coercion lifting allow us to coerce tf age to tf int obviously not otherwise we could write to bool tf int to b b from tf age char from c c and now the composition from to is welltyped via coercion lifting but obviously unsound so in the the definition of coercion lifting as well as type functions and gadts we must data types like tf that use their type arguments summary at this point it should be clear that a naive combination of · typelevel dispatch whether by gadts or by type functions · unrestricted coercion lifting simply does not work this interaction was far from obvious to us initially and indeed ghc has a bug that arises directly from this interaction yet both typelevel dispatch and coercion lifting restricted are valuable the purpose of this paper is to show how they may be soundly combined this problem is important not only because it arises in ghc which is our main source of motivation but also because the same issues will arise in any type system that combines typelevel dispatch and coercion lifting haskell is the first programming language that has pushed the type system far enough for these problems to arise in practice but others may do so in the future however these different languages may expose the coercions between abstract and concrete types in different ways possibly explicitly as in haskell or implicitly as in ml in a way that is connected with type inference to avoid the complications associated with type inference in this paper we focus on an intermediate language in which coercions are explicit whether they come directly from the source program or from elaboration by the type checker is the fc language codes versus types our goal is to resolve the between generative types which allow programmers to express the that two types have identical representations and type functions which can distinguish two types even if they have the same underlying representation the for our solution comes from encodings of generic programming in dependently typed languages et al these encodings use codes to represent types as a form of data for example the code may be the code for the type int functions branch on codes and thus have a different type from parametric functions in this context we can view age and as two different codes that both map to the type int however this encoding requires significant syntactic overhead as we must have a code for every type and must explicitly map codes to types when they are used to classify expressions however the important distinction between codes and types is that they have different definitions of equality in the encoding above the codes age and are different codes but their interpretations are equal types therefore we use this idea in fc to define roles which support different notions of equality for the same data in this language age and int are distinct when viewed at role code but equal when viewed at role type code equality is used to reason about the meaning of functions and is than type equality which is used to determine which type coercions are safe importantly fc distinguishes type functions by what equivalences they respect parametric functions respect the role type whereas functions that distinguish between age and int do not fc an overview these ideas are best explained in terms of an intermediate language that the differences between the code and type roles and makes explicit the uses of the two kinds of equality mentioned above thus the remainder of this section describes fc our new variant of system fc et al a model of the intermediate language used in ghc as such it is expressive enough to capture indexed type functions and deriving gadts existential and nested datatypes and much more figure summarizes the syntax of fc which at the term level e is just the polymorphic lambda calculus with two extensions first fc provides polymorphic datatypes introduced by data constructors k these datatypes are eliminated using a case construct that should be familiar from haskell or functional describe how datatypes and case are in section second fc includes firstclass proofs of type equality that witness safe coercions introduced during compilation programs in fc can abstract over coercions a particular type equality written c e pass a coercion as an argument to such a function written e and use a coercion to cast a term from one type to another written e these explicit coercions written make typechecking fc programs is the syntax of an fc term encodes its typing derivation why is this important the idea is that the compilers front end performs type inference on the source program and records the proofs generated by inference directly in the syntax of the fc intermediate language the transforms fc terms perhaps at any point one can check the consistency of the resulting fc program using a simple fast syntaxdirected typechecker this consistency check has proven to be an extremely powerful aid to getting the compiler right it is just as easy to find the type of an arbitrary fc term an ability that is used extensively inside ghc figure shows the typing rules for the terms of fc the first five rules through are completely standard we defer explanation of the remaining rules until we build up technical machinery having to do with distinction between codes and types and the rules by which explicit coercions can themselves be combined we describe these aspects of fc next kind r c t role r kind and role h t f a h a type constants datatypes arrow equality codes and types variables constants application polymorphism c sym nth k a coercion proof assumption symmetry transitivity application polymorphism instantiation e expressions x variable x e abstraction e e application ae type abstraction e type application k data constructor case e of case analysis c e proof abstraction e proof application e coercion ki ei in branches binding a type variable h type constant c r coercion x term variable k data constructor · context · a type context e argument · a empty expression type type variable equality v x e ae values c e k t value types a figure syntax e x x x e x e e e e e a e ae a e a e a t k a t a k a t a e t t for each ki ki a i i a i t ei i case e of ki ei i c c e c e e c e e t e figure typing rules r r ct rr ar r r a r h h r r r r r a r a r · · figure fc types and kinds types in fc are classified by pairs of the form r where the kind ensures as usual that types are wellformed structurally and the role r that determines the precision at which they can be analyzed codes which distinguish age and int have role c whereas types which identify them have role t this syntax is summarized at the top of figure while the rules are in figure the distinction between codes and types allows us to give informative kinds to type constructors · the maybe type section has kind t indicating that maybe treats its argument · the types k f and tf section all use type indexing and therefore have kind c these kinds in turn support the key insight of this paper it is only safe to lift coercions through functions with parametric kinds so maybe age maybe int holds but tf age tf int the rules for constructing coercions are given in section but first we must deal with the rules for types the critical rule is in figure which deals with type application it is quite conventional except for the treatment of roles consider these type declarations data tf a f maybe a data tf a maybe f a data tf a maybe maybe a in the first two cases type variable a is used intuitively under a type function so tf c and similarly for tf in contrast tf treats a so tf t the min in rule achieves these by combining the role of the context and the argument role of the function to get the role of the argument in fact min is just the least upper bound induced by an inclusion relation c t on roles see the top of figure this inclusion makes explicit the fact that code equality implies type equality but not for example consider data tf a f a a here a is used both as an argument of f and as a plain argument of so a has role c which makes sense just because a type can be analyzed does not mean that it must be despite these nonstandard kinds the types of fc are mostly standard codes and types are drawn from the same syntax see figure although we use two different metavariables as a of the intended role the type language includes type variables a type constants h applications and polymorphic types a type constants h include datatypes t and type functions f for the most part datatypes and type functions are treated uniformly but there are two important · datatypes must be injective while type functions need not be is important because equalities between applications of injective functions imply equalities between their arguments see rule in section · datatypes are by values but type functions are not there are no values v with types that are by f there are values with such types but no raw values this distinction is key to the definition of consistency in section are not by raw values so we treat them like type functions ranged over by f unlike type functions however are injective at role all the essence of generativity is that create a fresh for now we will not take advantage of that fact leaving it for discussion in section the set of type constants also includes the familiar arrow type constructor and a family of constructors which construct functions that abstract over coercions the kinds of these constants are t t c c t we discuss in sections and why the kind of must require role c for its first two arguments type constants are generally applied prefix but for these two constants we define infix syntactic sugar in the latter case because the syntactic sugar lacks the annotation we only use this notation in contexts where the kind of and is irrelevant rule follows this shows that this family of type constructors is used to give a type to terms of the form c e which abstracts over an equality proof in the body e note that this rule applies only to code equalities abstraction over type equalities is not needed for compilation of haskell and it while straightforward would require extra syntactic complexity figure defines the rules for fc using judgments of the form here the context maps type variables to their pairs and type constants and type functions to their kinds this judgment relies on a judgment shown in the extended version that checks that contexts are well formed these checks ensure that constants and have the right kinds that data constructors and term variables have wellformed types and that coercion axioms introduce equalities between wellformed codes and types rule allows a type constant to play either role although a type constant may be given role c its kind may well involve arguments with role t for example see the signature for above it follows that closed types can play both roles independently of whether they contain or type functions for example c and t both hold together these rules implement a subsumption relation that includes codes into the language of types lemma if c then t on the other hand types have only one kind regardless of their role lemma if r and r then note that the judgment like term typing is syntaxdirected see the remarks in section in particular the role component r of the in this judgment is treated as input to the algorithm and the is an context in which is used determines what the role should be the only interesting case from this perspective is in which must be checked first to obtain r so that the minimum of r and r can be passed as an input when checking coercions and equality in fc a coercion is a proof term that witnesses the equality of two types coercions are used to change the type of a term thus figure e t e here is a coercion the equality in role t given that e has type we can use to let us treat the term as c a r r r r c a a r sym r r r r t t t t r nth k r r nth k nth k nth k r a r a a a r call a a r a a r · · · · cnil figure coercions ing type at compile time these explicit coercions ensure that typechecking fc programs is completely syntax directed such coercions have no runtime effect they will be erased by the compiler before the program is run nevertheless operational semantics includes coercions thereby allowing us to establish type safety using standard techniques section the translation of a source program into fc may extend the type environment with new equality axioms for example the age definition generates the axiom where is a coercion constant c age note that requires and to be equal when considered in role t which is consistent with the idea that type equality determines when it is safe to coerce on the other hand source programs can also introduce code equalities for example the type function f section generates the two axioms f int f age however all code axioms can be used to prove type equalities as code equality is a refinement of type equality more generally we permit axiom schemes for example the source language declaration type instance a aa would create the axiom scheme a c a in general as shown in figure the context includes bindings of the form c r for coercion axioms the metavariable stands for a type variable context a list of quantified type variable bindings of the form a the same binding form is used both for axioms introduced at top level and with empty for local assumptions introduced in figure of course it is important to know that the toplevel axioms are would be unsound to assert that bool for example section gives a sufficient set of conditions for ensuring that source programs generate consistent axioms next we need a way to compose coercions together to construct other coercions our goal is to have rules that allow the creation of composite coercions such as list list age list list int list on the other hand the coercion formation rules should the formation of a coercion of the form f age f which creates the described in section figure gives the syntax of coercion terms and figure gives their typing rules coercions are using the judgment r which asserts that the type of a coercion is an equality proposition r this proposition in turn implies that and both have kind and are equal in role r it is technically convenient to include in the syntax of the judgement to enforce that both types have the same kind however this component is not always relevant so we sometimes omit the part as we have done in the examples above rule an axiom scheme with types using an auxiliary judgment defined at the bottom of figure to ensure that each variable is instantiated with a type of the matching kind and role the notation a together a list of type variables and a list of kinds to create a type variable context these two lists must have the same length for the notation to be welldefined the notation a applies a of the types for each of the corresponding variables in the list a rule shows that any type can be lifted to a reflexive coercion while and add symmetry and transitivity ensuring that equality is an equivalence relation the rules and call extend equality over applications and polymorphic types their structure is analogous to the corresponding rules in figure rule is particularly important because it implements the key coercion lifting idea we discussed in section using kinds to prevent the formation of the coercion f age f to see why recall that f has kind c but the axiom holds only at role equalities cannot be lifted through code functions another example of a coercion that is correctly rejected by the application rule because of the kind of is int this coercion proves age int int int an equality that could be used to introduce a assumption that age and satisfy it with for int as well as composing coercions to witness the equality of types it is also essential to do the reverse to decompose equalities over complex types to give equalities of simpler types decomposition is required by operational semantics section and it also makes the language more expressive rule allows equalities between polymorphic types to be instantiated the other more important decomposition rule is which the application of a datatype constant to arguments for example given a coercion list int list at we can use nth to conclude that int at the soundness of this rule depends on the fact that datatypes are injective in general type functions are not and hence is restricted to datatypes t in rule the notation t the t n for n in in the conclusion of the rule the notation nth k accesses the kth element of the sequence of types and nth k accesses the kind of the kth variable binding both of these notations are undefined if k is not less than the length of the sequence the sequence of types is determined by the kind of the datatype using the following notation definition we define by induction on as follows · the coercion judgment satisfies a number of checking properties first coercions are between wellformed types lemma coercion if then and next each coercion proof is for one pair of lemma unique types if r and r then and and finally equality for cs is a refinement of that for ts that is code equality implies type equality but not vice versa lemma if c then t coercion lifting the application rule described in the previous section allows us to lift equalities through arbitrary type constructors that is for all datatypes t of kind t we have a coercion that shows t age t int t in fact this notion of coercion lifting is not restricted to datatypes like list but is available for more general contexts more precisely given an arbitrary type with free variable a of kind t we can also create a coercion a age a int t we create such coercions with the lifting operation this operation replaces type variables by coercions in types to produce a new coercion relying on the fact that the syntax of types is a subset of the syntax of coercions definition lifting operation define the lifting operation written a by induction on aa ba b h a h a a a b a b a when a b the lifting operation produces a valid result as long as the role of the lifted coercion matches the role of the type variable in the type lemma lifting if ar and r then a a a in other words if a were used in some indexed context in that is if its role were c then we would not be able to lift the coercion age int t in we generalize lifting to replace multiple type variables simultaneously in the obvious way with notation a pattern matching and datatypes fc includes a formalization of recursive datatypes these datatypes include all ghc extensions to standard datatypes empty datatypes nested datatypes existential types firstclass polymorphism and gadts both datatypes t and data constructors k must be declared in a context before they can be used for example using the syntax for in figure the declarations for the data constructors of list are list t nil a t list a cons a t a list a list a what about gadts an example in haskell data rep a where rep int rep a rep list a although a haskell programmer writes the data constructors of a gadt with result types in the internal type system it is simpler in the formalization for the result type of a data constructor to take the form t a an where the a are the type parameters using equality constraints to express the indexing thus rep c a ca int rep a a c b ca list b rep a notice here that reps kind expresses that its argument is an index role c rather than a parameter role t in fact the c role for variable a out naturally because a appears as argument to the constructor in the type of and which in turn requires it to have role c more generally we use the notation of de bruijn to express the types of data constructors figure defines a like this · a a is like a a list of type variable bindings equality propositions between codes only and types that classify each argument of the data constructor note that a type variable context is also a we define the syntactic sugar as follows definition syntactic sugar · a a at each use of a data constructor rule we check that the declaration of a data constructor is of the form k a t a where a lists the type parameters of the datatype describes the types of the arguments to the data constructor and t a is syntactic sugar for the application of t to those parameters ie t a an for example the list type has a single parameter a t the constructor cons has a list a · and constructs type list a likewise the rep type has the parameter a c the for is b c a list b rep b · and the result type is rep a sym nth nth x e e x e e a a t ae ae a t nth sym nth nth c e c e t t t k a case k of case k a nth of · · e e a a c figure rules figure operational semantics push rules notation is also used for case expressions in rule figure the type of the of the case must be by a datatype constant t furthermore for each data constructor that could create a t there must be a corresponding branch the function looks up the constructors of t from the context after substituting for the parameters the branch for data constructor ki must abstract the same arguments as ki and return the same result type as the entire case to make sure that typechecking is syntax directed even when there are no branches for empty datatypes the case expression is annotated with its result type and we must check that this type is wellformed in the current context operational semantics coercions the operational semantics of fc is based on a smallstep callbyname operational semantics for a polymorphic lambda calculus although this language includes explicit type abstraction and application as well as explicit coercion proof abstraction and application types and coercions are not relevant at run time all such abstractions and applications as well as uses of coercions e may be erased prior to execution and so impose no runtime costs as to above this operational semantics preserves coercion proofs which allows us to establish type safety using standard syntactic proofs of progress and preservation described in the next section the most important rules of the operational semantics are those that push coercions when they appear in active positions so that they do not interfere with reduction figure shows the relevant rules the complete rules of the operational semantics are listed in the extended version in some of the push rules the coercion must be checked to constrain the types that it proves equal this checking happens in a global context that contains only the definitions of data constructors data types and coercion axioms note that these checks are not actually necessary at runtime in a consistent context these checks will always succeed the first three rules show how in an application of a abstraction the term steps to a new application where the coercion has been decomposed into a coercion for the body of the abstraction and a coercion of the argument for example consider here the is a coercion between some function types and the rule uses nth and sym to decompose into two coercions one from the order is to account for and one from these new coercions can be pushed to the body of the lambda and the function argument the reduction rules and work analogously note that the kind of which requires that the first two arguments be codes if we had assigned the parametric kind t t t then the coercions and in the rule would both be type coercions however type coercions cannot be composed with to form a code coercion which is the role required for the right hand side of the rule to typecheck the last rule pushes the coercion of a data constructor in the position of a case expression into coercions of the arguments of the data constructor the arguments of a data constructor can either be an expression a type or a coercion e if the declared type of the data constructor k is a t a and the type parameters are then we know that the arguments can be typed using a see figure however the coercion changes the type parameters to be so the new arguments must have type a these new arguments are produced by the list of arguments with the coercion generated by lifting as described above the notation a nth means that variable ai is lifted to coercion nth i once this coercion has been defined by lifting we use it to coerce the list of arguments of the data constructor with the following operation definition define argument coercion by induction on · · e e a sym argument coercion a list of arguments as described by the following lemma lemma if and t then type safety and consistency the fc language supports a straightforward proof of type safety based on the usual preservation and progress theorems importantly the progress theorem holds only for consistent contexts those that cannot int and char for example below we state the progress and preservation theorems and give a precise definition of consistency in the next subsection we formulate sufficient conditions for proving that a context is consistent preservation and progress the preservation proof for fc is standard relying on the usual and substitution lemmas for the various judgement forms for space reasons we omit those definitions here and instead refer the reader to the extended version theorem preservation if e and e e e then the progress theorem holds only for closed consistent contexts a context is closed if it does not contain any term variable bindings we use the metavariable for closed contexts the definition of consistency and the canonical forms lemma necessary to show the progress theorem are both stated using the notions of values and their types value types value types include all types except those that are by a variable a or type f formally we define values v and value types with the following grammars t a v x e ae c e k the canonical forms lemma tells us that the shape of a value is determined by its type lemma canonical forms say v then is a value type furthermore if then v is x e or k if a then v is ae or k if then v is c e or k if t then v is k in fc not all irreducible forms are values evaluation can also produce a value of the form v which to a value when coercions are to prove the progress theorem we must reason about what sort of coercion could be so that we can appropriately apply the push rules in figure in the statement of the progress theorem because the value v we know by and canonical forms that the left type is a value type consistency of the axiom set us that if is also a value type it must have the same head form definition consistency a context is consistent if whenever t it is the case that if is t then is t if is then is if is then is if is a then is a putting these observations together we obtain theorem progress if is consistent and e and e is not a value v or a value v then there exists an e such that e e determining consistency although the previous subsection gives a definition of when contexts are consistent it does not provide any mechanism for determining whether a set of axioms leads to a consistent context this subsection defines sufficient conditions written good for establishing context conditions are not the only way to show consistency they are not necessary but they are permissive enough to cover the axioms generated by compilation of type family declarations and definitions note that all forms of value type must include partial applications of data constructors a r r a a r h r h h r a r a a r h r r c h r h r r · · r r r r figure type rewriting as in the previous version of fc we show consistency by i defining a rewrite system for types and ii proving that two types are share a common if and only if there is some coercion proof between those types the rewrite system guarantees that value types preserve their head form throughout rewriting and therefore value types with different head forms can never be rewriting and figure gives our rewrite relation which is a variant of parallel looks throughout the type trying to reductions the reduction of a type by a constant h is implemented in rule if after the arguments to h have been reduced to there is some instantiation of an axiom such that h applied to some prefix of the matches the lefthand side of the coercion then the type may reduce to the type importantly rewriting very much like takes roles into account rewriting occurs at some role r which specifies what axioms are available for example at role t we can rewrite a age to its definition int but at role c we cannot notice that rules and overlap the term h may reduce using a matching axiom for h via rule but not necessarily via with rule the rewrite relation is reflexive lemma if then the relation below is simply reduction to a common after zero or more steps definition two types are if they share a common define if and of the rewrite relation is crucial for of type applications with multiple arguments consider the axiom c f int f int f and the following two types t f int f int f int t f int f int f int certainly like and to be reducible to a common after all there exists a coercion term between them but the first argument of t in behind compared to the first argument of t in whereas the second argument in advances compared to the second argument in allows us to the reduction of the second argument in while reducing the first and similarly for which allows us to join the two types soundness and completeness of the rewrite relation we now give sufficient conditions on contexts which ensure that the rewrite relation of figure is sound and complete with respect to hence these are sufficient conditions for consistency definition good contexts we have good when the following conditions hold all axioms in are of the form c f r let a dom and be the corresponding kinds for every well kinded and result types such that a r it must be a for some with r there is no overlap between axioms for each f there exists at most one prefix of such that there exist c and where c f this c is unique for every matching f the first condition above restricts the declared arguments of type functions to behave like patterns it merely states that all the reductions that can possibly happen when we substitute types for do not involve reductions from but only reductions inside those substituted types this condition is a generalized and more form of the current ghc restrictions on type family declarations which only allow value types or variables as the second condition is simply a strong condition interestingly the first condition on the arguments to type functions restricts the kind that a type function may have for example recall the axioms for f from section f int f age for this to be a good axiom set the kind of f must be c because the age is irreducible only in role c in the rest of this section we sketch the proof that our conditions are sufficient for consistency soundness is a straightforward proof theorem soundness if if good and then there is some such that the three key lemmas of the completeness proof are that is preserved under application and substitution and a local property of rewriting lemma application if good and r r and r then r theorem local property if good and and then there exists a such that and lemma substitution if good and a and then there is some a a from these lemmas we see that is complete theorem completeness if good and then theorem consistency if good then is consistent proof suppose r where and are two value types by completeness we have that those two types are ie that there is some such that r and r however by inversion on the rewriting relation we see that it preserves the head forms of value types since there exist no axioms for those by the first condition of good thus and and have the same head form a different of our approach compared to previous work et al is that establishing the completeness theorem and therefore type soundness does not depend on strong normalization our definition of good that i forces the declared type family arguments to behave like patterns and ii imposes strong stronger than the previous work conditions is sufficient to show completeness with this new approach a programmer can be that even in the presence of possibly nonterminating type functions if the compiler can show that the program is welltyped then the program will not crash although type checking is undecidable in general without strong normalization there may be many programs that the compiler can actually type check and this approach shows that those programs are type sound compilation from source haskell in the previous sections we have informally presented the translations of haskell source features such as datatype type family and declarations into fc we summarize them here data t where ki t ki type family f c f c type instance f cf f c m a m m a t in addition uses of the data constructor of a both in terms and patterns are translated to a use of the corresponding coercion in the obvious way the important parts of these definitions are that i type families accept code arguments ii type instances give rise to code equalities and iii definitions give rise to type equality axioms the bindings generated in this way can be easily checked for wellformedness if in addition the resulting context is good see section the only possible problem is the potential to generate overlapping type instance the context is consistent which in turn guarantees type safety notice that the source language features in this translation have been already annotated with their kinds this is a reasonable assumption prior to type inference which translates a source declaration to an fc binding we must have determined the kinds involved in the declarations for the purposes of this paper we assume that the kinds are practice they would be the output of a kind inference process potentially by the user to role information and higherorder kinds deriving generative type abstraction is achieved in haskell using the deriving mechanism which allows type classes to be automatically lifted to new types for instance we may write age int deriving eq the type class eq a is a standard class in haskell signature in ml terminology that defines one method eq a a bool for the type checker a type class is nothing but a record type containing the method eq the deriving line automatically generates an implementation of eq age from a instance eq int this can be done by simply applying a coercion eq int eq age to the old record it is straightforward to construct this coercion lift the age int axiom from the definition over the eq constructor and apply symmetry importantly this lifting is safe because eq has a parametric kind of the form t however if a type class has a indexed kind of the form c deriving is no longer sound for example class c x where op f x x instance c int where age int deriving c it is unsound to lift the c int implementation to a c age precisely because x has role c the ghc bug mentioned earlier arises precisely as the result of such an unsound lifting over a type class discussion decomposition recall the coercion decomposition rule from figure this rule allows us to an equality of the form t t t in effect it asserts that data constructors are injective the rule is important because it is used in the operational semantics to ensure subject reduction however the decomposition rule may be somewhat restrictive for some haskell source programs consider the following m a maybe a data eq a b where eq eq a a f eq m a m b a b f eq x x pattern matching against the eq constructor introduces a coercion between m a and m b which cannot be decomposed using the rule to obtain a b so this program cannot be typed nevertheless we know that m is injective because m a is defined to be equal to maybe a which is clearly injective on the other hand the following is not injective type instance g a char n a g a here it is possible to derive n int n char t using the axiom for g even though int is not to char it turns out that definitions are always injective with respect to code equality but they might not be injective with respect to type equality as illustrated by the two examples above thus it would be sound and potentially useful but not necessary for type soundness to introduce yet another decomposition rule for definitions that takes advantage of with respect to codes we use metavariable n n n c n r nth k nth k nth k nth k r the only subtle part of this rule is that r is not related to r since the equality n n c is a and r c decomposition for injective type functions is also desirable were we able to effectively specify and check that property other technical differences of fc from system fc the intermediate language fc described in this paper is a significant modification of system fc et al due to the introduction of codes however fc also makes a number of technical simplifications · the original system fc presentation includes coercion kinds the original coercion language includes three additional constructs one to coerce coercions and two more to decompose coercion kinds by treating as the application of a constructor we no longer need any of these constructs in the operational semantics nor have we identified any uses of these constructs that are not · the operational semantics rules of fc in figure not only use simpler coercion constructs but are also expressed without need for substitutions contrary to their original fc versions · fc replaces the fc coercions left and right which decomposed arbitrary type applications by nth which only the application of a datatype constructor this allows us to lift a restriction in in system fc namely that type functions were required to be saturated type family saturation was necessary in fc in order to prevent the decomposition of equalities as f a maybe a via left or right allowing functions increases the expressiveness of fc because we can now abstract over type and also new directions for future research on type inference in the presence of type functions · however using nth instead of left and right does carry a small price generalizing the example from section should this program be well typed data eq a b where eq eq a a f eq p q r s q s f eq x x to type it we must decompose a proof that p q r s to get a proof that q s which right could do but nth cannot some other differences are · system fc used a common syntax for types and coercions which is a convenient but has turned out to be more than helpful in fc we use a distinct syntax for types and coercions figure · in fc we define toplevel axiom schemes c r directly and fully instantiate them at every occurrence with the form c figure system fc instead defined a toplevel axiom scheme as an equality between thus c here again fc is but not wrong so in fc we opt for the more directly with slightly more syntax moreover the rules for and call can that the body of the forall has kind as is conventional · using in the treatment of datatypes simplifies the operational semantics rules but is also only slightly more expressive the types of data constructors do not have to have their quantified variables preceding their coercion and term arguments instead allow arbitrary interleavings related work previous work on system fc et al discusses a significant amount of related work in typed languages with explicit proof witnesses and harper shao et al or in calculi that support coercions et al below we present related work in generativity and abstraction constructs and the separation between codes and types generativity abstraction and module systems generativity and abstraction has been studied extensively in the context of ml module systems milner et al shows how generativity in module systems is connected to existential quantification and dreyer has studied this connection in the presence of recursive modules and refine this connection by introducing open existential types uses flexible generativity to explain module sealing type abstraction can be understood in terms of dynamic name generation et al which can abstraction properties in languages with dynamic type analysis et al prove a parametricity theorem in this setting in addition they use a translation from polymorphism to generative types to establish the parametric behavior of certain functions although they work in a language although many of these languages support type generativity and features they do not exhibit the soundness problems described in the paper mainly due to the absence of typelevel type dispatching nevertheless the techniques developed in the related work would be valuable in the formal study of the parametricity properties of fc types although many systems for generic programming support dynamic computation based on types very few systems allow the structure of types to be to produce other types however such facility is often necessary to describe the type of generic programs for example harper and morrisett include a typerec operator to their typed intermediate language mi l harper and morrisett to describe typedirected optimizations they credit mechanism of universe elimination in as the for this operation and to support generic programming in source languages and added datatypes et al to the generic haskell front end in later work et al b introduced associated data families in ghc which are datatypes associated with type class instances extending this work they later introduced associated type et al a which are proper typelevel functions with instances associated with type class instances currently the source language of ghc also supports typelevel type functions often referred to as indexed type families et al et al a feature that we have extensively used in our presentation codes types and interpretations our distinction between codes and our inspired by similar notions in intuitionistic type theory et al there types sets are constructed as the recursive interpretation of codes which inductively constructed code a definition can be viewed as giving rise to a new code an open universe of codes and whose interpretation coincides with the interpretation of its definition languages based on dependent type theory such as agda et al or coq the coq team naturally offer typelevel computation to construct types but they allow elimination of codes only not types therefore they do not exhibit the same soundness problem as the expressiveness of these languages can readily enforce the distinction between types and codes the is the extra programming of explicit definitions and interpretations of codes to better support generic programming the language et al identifies types with their code the lx language crary and weirich also uses universe constructions to solve problems with typedirected compilation when the type translation in a compiler pass is not the identity then type dispatch must be compiled to code dispatch so the generated code can dispatch on source types instead of target types the interpretation of codes is then the type translation to support lx includes for codes and primitive recursive functions over for their interpretation at types in lx source types age and int would be mapped to definable codes and and would be by an interpretation function such that equals int and equals int therefore the problem with generativity would not show up in that context if one to solve the problem in this paper along the lx lines one would have to translate source haskell types to void types that stand in as codes and handle the interp function as any other type function this function as well as interpreting the codes as types would have to be with suitable congruence axioms like t t explicitly introducing these axioms means that coercions would be significantly more our system with an explicit interp function by using the roles in the judgements to determine whether we wish to derive an equality between codes or between their interpretations conclusions and future work in this paper we have identified a problem for the safe interaction of flexible type generativity and typelevel computation we have proposed a solution that distinguishes between indexed and parametric type contexts by extending the language of kinds and formalized the solution in the fc language we have several for future research in mind which we outline below source language technology we would like to work on ways to expose the fc expressive features to programmers specific directions are the kind declarations with the ability to declare parametric or indexed typelevel constructs introducing type family annotations extending kind inference with roles and extending type inference to support functions using the more sophisticated kinds the of codes with terms we are currently working on the universe of codes with constants or functions drawn from the term syntax such as data constructors in order to enable direct programming in haskell more roles lemma asserts that the equivalence classes induced by are refined by however our approach readily extends to arbitrary lattices of roles with more refined equivalence classes as we move down the relation consider for example a lattice with new roles c and c each between c and t but incomparable with each other these two roles model partial knowledge of equalities for example perhaps c identifies age and int but distinguishes a different from its definition bool conversely c can identify and bool and distinguish age and int these more precise roles could be used to give more precise types to functions by identifying exactly which equivalences they do and do not respect however we have not yet explored the practical implications of this precision furthermore one could explore adding a role above t type functions with kind t are not necessarily parametric in fc for example because g below does not match it may be assigned either kind t or c g int g bool to distinguish parametric functions from those like g we could add a role p induced by the relation that all types of the same kind as this equivalence is than t it could not and should not in coercions however this new role would provide a yet more kind for type functions acknowledgements we thank and the of the type system sessions at cambridge for many useful discussions we this paper using the tool this work was partially supported by grants from and nsf and a foundation references m p and p for generic programs and proofs in dependent type theory j of computing ­ a p and u a brief overview of agda a functional language with dependent types in proceedings of the nd international conference on theorem proving in higher order logics pages ­ berlin springerverlag v t coquand c a and a inheritance as implicit coercion information and computation ­ m m t g and s peyton jones associated type in icfp proceedings of the acm sigplan international conference on functional programming pages ­ new york ny usa a acm m m t g s peyton jones and s associated types with class sigplan not ­ b j p c and p morris the art of in proceedings of the acm sigplan international conference on functional programming icfp md usa september to appear j and r firstclass types tr cornell university r l intensional analysis of functions and types technical report department of computer science university of edinburgh june r l and d r the type theory of acm transactions on programming languages and systems ­ jan k crary and s weirich flexible type analysis in proceedings of the fourth acm sigplan international conference on functional programming pages ­ paris france sept n g de bruijn mappings in typed lambda calculus inf comput ­ d dreyer recursive type generativity in icfp proceedings of the acm sigplan international conference on functional programming pages ­ new york ny usa acm p a general formulation of simultaneous definitions in type theory journal of symbolic logic ­ c v hall k s l peyton jones and p l wadler type classes in haskell acm transactions on programming languages and systems ­ mar r harper and g morrisett compiling polymorphism using intensional type analysis in popl proceedings of the nd acm sigplansigact symposium on principles of programming languages pages ­ new york ny usa acm isbn r j and a data types in b m editor proceedings of the international conference on mathematics of program construction pages ­ germany july o s peyton jones and c fun with type functions springer d r and r harper a formulation of dependent ml with explicit equality proofs technical report carnegie mellon university department of computer science p an intuitionistic theory of types predicative part in proceedings of the logic colloquium volume of studies in logic and the foundations of mathematics pages ­ northholland r milner m tofte and d macqueen the definition of standard ml mit press cambridge ma usa isbn b and d modeling abstract types in modules with open existential types in popl proceedings of the th annual acm sigplansigact symposium on principles of programming languages pages ­ new york ny usa acm g d dreyer and a parametricity in icfp proceedings of the th acm sigplan international conference on functional programming pages ­ new york ny usa acm isbn s peyton jones et al the haskell language and libraries the revised report journal of functional programming ­ jan s l peyton jones d s weirich and g simple type inference for gadts in international conference on functional programming icfp portland or usa sept b c pierce editor advanced topics in types and programming languages mit press a dynamic with abstraction kinds and higherorder coercions notes theor comput sci ­ a generativity and dynamic for abstract types in proceedings of the th acm sigplan international conference on principles and practice of programming pages ­ new york ny usa acm isbn c v types for standard ml modules in proceedings of the international conference on principles and practice of declarative programming pages ­ london uk springerverlag isbn t s peyton jones m and m type checking with open type functions in icfp of the th acm sigplan international conference on functional programming pages ­ new york ny usa acm z shao v b and n a type system for certified acm trans program lang syst ­ m m m t s peyton jones and k system f with type equality coercions in proceedings of the acm sigplan international workshop on types in languages design and implementation pages ­ new york ny usa acm the coq team coq url d g and s weirich an open and typecase in acm sigplan workshop in types in language design and implementation long ca usa jan h xi c chen and g chen guarded recursive datatype constructors in popl pages ­ 