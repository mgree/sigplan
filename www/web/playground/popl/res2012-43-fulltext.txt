a mechanized semantics for c object construction and destruction with applications to resource management inria texas am university leroy inria abstract we present a formal operational semantics and its coq for the c object model object construction and destruction shared and repeated multiple inheritance and virtual function call dispatch these are key c language features for highlevel system programming in particular for and reliable resource management this paper is the first to present a formal mechanized account of the metatheory of construction and destruction in c and applications to popular programming techniques such as resource acquisition is initialization we also report on and apparent in the c and c standards categories and subject descriptors d programming techniques objectoriented programming d software engineering d software engineering design tools and design methods d software engineering proofs d programming languages language constructs and and objects inheritance f logics and meanings of programs studies of program constructs general terms languages verification introduction one of the decisions for c in was to provide language support for the construction and destruction of objects code fragments called constructors are automatically executed when a new object is created and before it is made available to the rest of the program these constructors can execute arbitrary code sequences and are intended to establish the execution environment for operations by fields and maintaining invariants the language also supports destructors which are executed before an object is at times such general constructors are now available in most programming languages supporting object partially supported by nsf grants and partially supported by grants and ins permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm oriented programming many languages also provides some support for of objects at the end of their lifetime eg finalizers executed at times or statements allowing a programmer to explicitly request because it is enforced by the programming language itself and not by coding conventions the object construction and destruction protocol provides strong guarantees that can be by good programming this is the case for resource acquisition is initialization a popular c programming idiom for safely system resources such as file descriptors with resource acquisition is always performed in constructors and resource release in the corresponding destructors since c guarantees that every execution of a constructor is eventually matched by an execution of a destructor the of resources as practically useful as they are constructors and destructors raise issues for the programmers for static analysis tools and even for language designers while an object is being constructed or it is not in a fully operational state this raises the question of what operations code should be allowed to perform on this object and what semantics to give to these operations a typical example of this is virtual method dispatch in java and c unrestricted virtual method calls are allowed in constructors with the same semantics as on fully constructed objects in contrast c takes object construction states into account when virtual function calls in a way that provides stronger soundness guarantees but semantics and compilation section the main features of c object construction and destruction this paper reports on a formal mechanized semantics for construction and destruction in the c object model this model is especially rich it features multiple inheritance both shared and repeated fields of structure and structure array types as well as subtle interactions between construction states virtual function calls and dynamic casts our semantics fully mechanized in the coq proof assistant is to the best of our knowledge the first to capture these interactions as intended by the c standard this semantics described in section is the first contribution of the paper the second contribution in section is the specification and formal verification of several expected properties of the protocol ranging from properties such as any subobject is constructed or at most once to the first precise characterization of the properties that make the programming idiom work in practice we also study the of the dynamic types of objects throughout their life cycle and formally justify the program points where compilers must generate code to update dynamic types as a third contribution this work some and apparent in the c and c summarized in section these have been reported to the c some were resolved in c others will be in future we finish the paper with a few words about verified compilation § a discussion of related work § and future work § and remarks § all results presented in this paper were mechanized using the coq proof assistant the coq development is available at by lack of space some aspects of the semantics are only sketched in this paper a full description can be found in the first authors phd thesis part object construction and destruction in c a constructor is a special function that turns raw memory into an object its purpose is to create an environment where class invariants hold and where the member functions will operate conversely at the end of the useful life of an object another special function called destructor any acquired resources and turns the object back to raw memory the time span between the completion of a constructor and the start of a destructor is the lifetime of the constructed object the c language rules were designed to guarantee that class invariants set up by a constructor hold through the entire lifetime of an object for example a complete objects dynamic type does not change during its lifetime cs object construction and destruction mechanism is rooted in a few design principles i every object and each of its subobjects if any is constructed exactly once ii no object construction should rely on parts yet to be constructed and no object destruction should rely on parts already iii every object is in the exact reverse order it was constructed these principles independently of implementation considerations enable support for reliable modular software development principle i supports the idea that a resource acquired by an object say a file lock is acquired exactly once principle ii a notion of locality and scoping while the constructor is creating the computation environment for member functions very few class guarantees can be made it is desirable to the complexity andor needed to correctly call a function in a few specific places before an object begins its lifetime furthermore the author of a class should not have to about which data members of possible derived classes are correctly initialized during the execution of a constructor on the other hand she should be able to rely on invariants consider the following example struct a int b xa yb show virtual void show const x y protected int x int y struct a int b const vector v b void show const x y features private vector features construction of a object entails constructing its subobject followed by of its features field from the v parameter if in the constructor the call to the virtual function show resolved to the final as in java or c it would access the field ­ an and outcome consequently principle ii for the call in the constructor to an not from a derived class here it is finally principle iii supports and reliability for instance if an object acquires n resources through the construction of its subobjects in general one would want to release them in the reverse order of acquisition or else a deadlock might these general principles and their implications into executable specification in the face of objectoriented language features such as multiple inheritance both repeated and shared late binding function dispatch virtual function calls type queries etc is an interesting challenge on the other hand their leads to interesting soundness results and more importantly reliable software development techniques for the programmer initialization versus assignment there is a difference between initialization and declaration followed by a assignment and it is not a distinction subobjects and data members are constructed before the proper body of the constructor is executed for subobjects are specified in a list before the opening of a constructor body see the definition of the constructors for and in the previous example in particular there is no other way to initialize subobjects const or reference data members a subobject or a data member not mentioned in the list is implicitly initialized with a default constructor ie a constructor that can be called with no argument consequently the language rules imply that all subobjects are constructed by the time the first statement of the constructor body if not empty is executed the constructor for could have been written as a int b const vector v features v in this variation the subobject is initialized the data member features is default constructed and finally the constructor body assigns the value of v to features in c assignments of objects of class types are generally implemented by userdefined functions these functions must assume that the left hand side of the assignment is an object already constructed and in a valid state in particular vectors assignment function must carefully check for to avoid memory release it must properly release the resources the object was before taking hold on the new ones by contrast during the object being constructed has not acquired any resources yet so the implementation code of the is usually far simpler than that for assignment initialization order principle iii has an interesting implication on the construction order of the of an object observe that there is exactly one destructor per class and that there can be as many constructors per class as necessary by the programmer therefore for a given class subobjects in all constructors must be initialized in the same order for that order must be the reverse destruction order of the unique destructor any welldefined order can do however for simplicity a natural choice is the declaration complete object or subobject inheritance subobject direct and direct indirect nonvirtual data virtual bases members bases direct nonvirtual data bases members figure a recursive tree representation of the subobjects of a class such that a depthfirst lefttoright traversal yields the subobject construction order order initialization of all subobjects in the lefttoright order of declaration in the class definition followed by initialization of all data members in their order of declarations in the class definition this construction order is simple and reflects the compositional aspect of class growth however shared inheritance virtual base classes a problem for the principle of base before derived and strict order of declaration construction indeed consider the following hierarchy of io stream classes struct virtual struct virtual struct where the class maintains states and implements operations common to both input and output streams the classes and implement input and output stream the class combines both input and output facilities if an object was to be constructed according to the declaration order outlined above the corresponding subobject would be constructed twice once when the subobject is constructed and a second time when the subobject is constructed this problem is resolved by executing constructors for virtual bases in declaration order before all other constructors more generally c the following order construction for a complete object also depicted on figure virtual subobjects are constructed in a depthfirst lefttoright traversal of the inheritance graph direct nonvirtual subobjects are constructed in declaration order data members are constructed in declaration order builtin object types the c programming language was designed with two ideals a sound highlevel object model with equal support for userdefined types and builtin types and a compatibility with c for system programming the resulting has made the general model of object construction and destruction grow indeed c lacks the notion of object construction so central to cs object model but in both languages agree on the semantics of programs that read from uninitialized objects undefined behavior except in very limited cases where a read access is done as raw memory in c object initialization is usually expressed in terms of storage acquisition followed by assignment c distinguishes assignment from construction to achieve the same semantics and to support generic programming c extended the notion of constructor and destructor to builtin types a builtin data member can be explicitly initialized with default value using the default construction syntax struct x y here the default constructor explicitly constructs the data members x and y with a default value zero so that in the complete object declaration origin the origin object has its initialized to zero would the semantics be the same were x and y not explicitly listed in the list the answer is no objects of builtin type with no explicit are constructed but left with values this was introduced as a way to satisfy the practice in c where objects are given values long after their declarations this and others related to destructors for builtin types the c semantics rules as well as formalization however they are not fundamental to the object model in fact the c standards is considering unifying initialization and lifetime rules in a standard we hope this work will help in that formal operational semantics syntax of the core language we focus on a core language of objects that features the main aspects of the c object model construction and destruction multiple inheritance both virtual and nonvirtual virtual functions and data members fields of scalar array or complete object types to simplify the presentation we formalize only fields that are arrays of object types a field of object type t as a array of type t the core language is a language of statements operating over variables in address style we assume that typechecking was performed static overloading was resolved and expressions were decomposed into elementary statements the syntax of statements follows op op builtin operations var var variables b c class classes field field names method method names stmt skip var do nothing builtin operation var var c var c var var var var var field read scalar field write array cell access dynamic cast b c var dynamic cast var c virtual function call stmt stmt statement sequence return function return c var var count stmt object the coq formalization also features simple control structures ifthenelse infinite loops with early exits as well as static casts we leave these extra features out in this paper to concentrate on the essential features of the language accesses to fields virtual function calls dynamic casts and objects the statement c xn stmt allocates an array of n objects of type c constructs each of its elements according to the list of binds the array to variable x executes the block body stmt each element of the array x and finally the whole array are syntactically presented in c as constructor calls with expressions as arguments since our language lacks expressions we model as a statement which evaluates the expression arguments into temporary variables followed by an invocation of a constructor for object fields or the initialization of a scalar field stmt class object stmt scalar field structure field one for each array cell init arguments to functions and constructors can be scalar values ie integers or floating point data or pointers to objects we do not model passing objects by value this raises issues with the construction and destruction of temporary objects discussed in § constructor destructor virtual void virtual function stmt method scalar data member struct field base b virtual b struct c base class definition program program a complete program consists of a hierarchy of classes each class definition contains a list of virtual and nonvirtual base classes a list of data members fields definitions for virtual functions methods one or several constructors and one destructor each constructor consists of a parameter list a sequence of for direct nonvirtual bases fields and direct or indirect virtual bases and a constructor body an arbitrary statement destructors take no parameters and consist only of a body subobjects a crucial issue in formalizing the c object model is to capture the fact that each object of a class c contains subobjects one for each base and each field of c subobjects can be arbitrarily nested but can also be shared along several inheritance paths to virtual inheritance for this reason a subobject cannot be identified by a store locations instead it is described by a pair of the location of the array of complete objects containing it and a path from this array to the desired subobject intuitively a path is a sequence of selection operations of the form select a base class or select a field or select an element of an array this approach was introduced by and friedman later mechanized in by et al and further extended with structure array fields and mechanized in coq by et al we now briefly recall this formalization referring the reader to for full details an inheritance path is a pair h l of an inheritance kind h repeated shared and a list of class names l such a path a subobject of some type a of an object of type c if h repeated it is a path through the repeated or nonvirtual inheritance graph each path from c to a corresponds to a distinct copy of a within c if h shared it is a path from a virtual base b of c to a regardless of how the virtual base b is reached not all paths are valid with respect to the class hierarchy the following inference rules define the relation c h l i a meaning that h l is a valid inheritance path from c to a subobject of c of static type a c repeated c i c b direct nonvirtual base of c b repeated l i a c repeated c l i a b virtual base of c b h l i a c shared l i a an object is said to be a object if and only if it is not a subobject of any other object a object of type c is designated by the trivial inheritance path repeated c inheritance paths compose naturally if c h l i b and b h l i a we have c h lh l i a here is the cast to base operator defined as follows for a cast through nonvirtual inheritance h b l h ll whereas through virtual inheritance we have h l shared l we write for list concatenation in the presence of fields that are structures or arrays of structures the notions of paths and subobjects must be extended to allow selecting elements of arrays of structures et al define array paths as lists of i f triples where i is an array index an inheritance path and f the name of a structure array field an array path goes from an array of n structures of type c to an array of n structures of type c which we write cn a c n and define by the inference rules below an auxiliary predicate cn i ci a captures the selection of the ith element of an array followed by the extraction of a subobject of type a i n c i a cn i ci a n n cn a cn f f d m is a structure field defined in a cn i ci a dm a c n cn i f a c n in the core language of § a complete object bound to a variable x by a block statement is always an array of structures with type cn a subobject of type a of such a complete object is therefore a triple i where is an array path from cn to some c n and i n is an index in the array of type c n and is the inheritance path for a subobject of c of type a we write cn i a to mean that i a valid subobject of type a of the array cn this relation is defined by cn a c n i ci a cn i a then a subobject of a complete c object is a c object if and only if it can be written as i repeated c where cn i c n and i n in practice this means that a object corresponds to a cell of a structure array the array being either the complete c object itself or some structure field of a subobject of the complete object our operational semantics uses these notions to identify complete objects by locations in the store subobjects by pairs i of a location and a subobject and fields by triples i f of a subobject of some type a and a name f of a field declared in a construction states in the c language the behaviors of operations over objects depend on the construction state of these objects for example it is not possible to invoke a virtual function of a class c if the base classes of c have not been constructed yet or are destruction likewise as described in § virtual method dispatch behaves differently when a object is fully constructed and when it is construction or destruction our operational semantics therefore associates a construction state to every subobject and every field and updates these states during construction and destruction steps a given subobject can be in one of construction states whose meanings differ slightly depending on whether the subobject is a subobject eg an element of a structure array or a subobject for a object the construction states and their meanings are construction has not started yet the construction of has started but not the fields the subobjects are completely constructed now constructing the fields or executing the constructor body constructed the constructor body has returned and destruction has not started yet the body of the destructor is executing or the fields are destruction the fields have been completely bases are destruction all bases and fields have been for a subobject we need to virtual bases from the meaning of its construction state indeed as discussed in § and shown in figure virtual bases are attached to the enclosing object not to the subobject therefore for those base class subobjects that are not objects we four of the construction states as follows construction of the nonvirtual part has not started yet however virtual bases may have been already constructed the construction of nonvirtual subobjects has started but not the fields the fields have been completely nonvirtual bases are destruction all fields and nonvirtual bases have been then the lifetime of a subobject can be defined as the set of execution states where its construction state is exactly constructed construction states are naturally ordered by we write c c to say that state c occurs earlier than state c in the enumeration above and sc to denote the state immediately following c if it exists finally fields also carry a construction state one among constructed and with similar meaning as for subobjects as an example of use writing to a scalar field is possible only if it is in state constructed therefore preventing accesses to an or already field operational semantics the semantics of the core language is stated in terms of of a global state g which contains four partial maps · maps locations of complete objects to pairs c n representing the types cn of the complete objects · associates values to pairs f of a subobject and a scalar field f · associates construction states to subobjects · associates construction states to fields f we write eg c n to denote a lookup in a component of the state and c n to denote an update the main challenge in this semantics is to formalize the object construction and destruction protocol other aspects of our language such as accesses to fields dynamic casts and virtual function dispatch are semantically well understood from the work of et al at a high level of abstraction construction of a complete object corresponds to its subobjects according to a depthfirst lefttoright traversal of the construction tree depicted in figure the encountered during this traversal are then executed to determine the arguments to the constructors followed by invocations of the designated constructors for bases and elements of structure array fields or field assignments for scalar fields construction states of subobjects and fields are updated along the way destruction is similar but proceeds in the exact reverse order traversal of the construction tree the description above strongly suggests a bigstep operational semantics or equivalently a definitional interpreter since the recursive structure of these semantics matches well the recursive nature of the construction tree however there are two reasons why we want a smallstep transition semantics instead first statements constructors and may fail to terminate and we would like to account both for terminating and executions second and more importantly we need our semantics to the context in which a constructor or destructor executes or in other terms the continuation of all pending invocations which will be when the current being able to reason on this explicit is necessary in order to prove most of the highlevel semantic properties of § the operational semantics therefore is presented in smallstep style as a transition relation p k g p k g operating over triples of a control point p a continuation k and a global state g we distinguish kinds of control points p · stmt env block about to execute statement stmt followed by the list of statements stmt under variable environment env block is the list of all blocks enclosing the current statement where a block is a pair stmt of a complete object to at block exit and the remaining statements to execute after from the block · l env about to construct the list l of the bases or fields of the subobject are to be for using constructor and they operate on the variable environment env to pass arguments to their constructors is one of or or fields to request the construction of respectively direct nonvirtual bases or virtual bases or fields of · n i c env about to construct cells i to n of type c of the array from the complete object using the to initialize the cells and env as variable environment to execute the · l about to the list l of bases or fields of the subobject · i c about to cells i down to of type c of the array from the complete object we omit the grammar of continuations k which can be found in chapter the operational semantics is composed of inference rules defining the transition relation p k g p k g for a total of about lines of coq definitions we show some rules to give the general and refer the reader to the first authors thesis chapter for a full listing field accesses reading from a scalar field is modeled as follows env var g c f sc t fc f res env env var res f l env b k g l env b k g likewise for an assignment to a scalar field we have env var g c f sc t f c f constructed env var res g f res f var l env b k g l env b k g note the side condition preventing assignment to a scalar field that is not constructed for reads this conditions is not necessary theorem below shows that if a field has a value then it is constructed similarly dynamic casts are handled as in et al using the generalized dynamic type instead of the most derived object the transition rule is omitted for brevity but can be found in chapter destruction we now give the of the object construction and destruction protocol starting with the simpler of the two namely destruction destruction starts when the body of a block has reduced to skip or return st skip l st return c n l env l b k g l n c env l b k g the execution state requests the destruction of all elements of the structure array cn at starting with the last element n eventually we reach a state where no more elements remain to be in which case we effectively exit from the block dynamic types virtual function calls and dynamic casts both involve the notion of dynamic type of a subobject which the c standard defines as its object during the lifetime of the latter however the standard also permits virtual function calls and dynamic casts during the execution of the constructor body or field or destructor body corresponding to the subobject to unify these two cases we introduce the notion of generalized dynamic type we define the predicate i b meaning that the subobject of static type b is the generalized dynamic type of the subobject i with d n dn a cm i ci b i repeated c constructed g i c repeated c d n dn a cm i ci c i c c c c i b g i c the semantics of virtual function calls is similar to that given by et al except that we use the generalized dynamic type instead of the object if c is the generalized dynamic type of subobject the predicate f b determines the subobject b of c containing the definition of virtual function f that must be invoked following the same algorithm as in determine the static subobject f f choose the final for the method the final is the inheritance subobject between c and f to c and f the transition rule for a virtual function call is then env var i g i c f b b f f j env var j vj env v i var var n l env b k g env l env b k g c env l b k g l env b k g when the destruction of a object ie a structure array cell is we first enter the body of the associated destructor in a variable environment that binds this to the object i i repeated c env this g i c k g env i c k g when the destructor body returns the fields of the subobject have to be in reverse declaration order i h l c l stmt env k g fields l k g a scalar field its value and changes its construction state to before with the remaining fields f sc t g f f fields f l k g fields l k g a structure array field changes its construction state to then requests the destruction of the array starting from its last cell and the remaining fields through in the continuation i f st c n i f g f fields f l k g n c fields f l k g then once all cells have been the field enters the state and we proceed with the destruction of the remaining fields g f c fields f l k g fields l k g eventually all fields have been the subobject then changes its construction state to at this point no virtual function call nor dynamic casts may be used on this subobject the destruction of the direct nonvirtual bases starts in reverse declaration order i h l c l vc g fields k g l k g a virtual or direct nonvirtual base b of enters its destructor the other bases through b env this g bases b l k g env bases b l k g eventually we reach a state where all direct nonvirtual bases of have been there are two cases to consider depending on the top of the continuation stack in the first case the continuation stack starts with a bases b l indicating that is not a object in this case there is no need to the virtual part of this will be done later by the enclosing object and we are done with the subobject its construction state becomes and we proceed with the destruction of the remaining bases of g bases b l k g bases l k g the second case is when the continuation stack starts with a then must be a object and its direct and indirect virtual bases need to be according to the c standard virtual bases must be in reverse inheritance graph order consider the following recursive function shared × c vo vo b q b q b where db is the list of direct bases of b in declaration order tagged with nonvirtual bases or virtual bases and is list concatenation with elimination of l l def ll l it is easy to see that the list l contains all the direct and indirect virtual bases of c exactly once each and contains no other classes moreover the order in which virtual bases appear in list l is consistent with the inheritance graph order in particular if a and b are virtual bases of c such that a is a virtual base of b then a appears before b in l l i c k g l k g finally when all virtual bases have been the subobject under consideration necessarily a object becomes and we proceed with the destruction of the preceding structure array cells c i h l g k g i c k g construction to execute a block statement we allocate memory for the structure array declared in the block then start the construction protocol by the construction of the first element of this array g c n env env c ptr repeated c cn st st env bl k g n c env env st bl k g the construction protocol implements the necessary traversal of all subobjects of c using the same style based on continuations that was illustrated above in the case of destruction there are two main differences first the construction order is the exact opposite of the destruction order instead of array cells by decreasing indices fields and nonvirtual bases in reverse declaration order and virtual bases in reverse vo order we enumerate array cells by increasing indices fields and nonvirtual bases in declaration order and virtual bases in vo order second and more importantly we need to execute the that compute initial values for scalar fields and the arguments to be passed to constructors adding a number of transition rules we refer the reader to chapter for full details properties of construction and destruction in this section we state and sometimes outline the proofs of several semantic properties of interest for construction and destruction some are technical consequences of the definition of our semantics but others capture higherlevel properties that c programmers often rely on such as the principle runtime invariant our transition rules and grammars for execution states are lax in that they put very few constraints on the general shapes of states however in transition sequences starting from the initial state the reachable states are a small subset of all possible states and many lowlevel properties that are essential to prove the highlevel theorems in this section we about such properties in one invariant inv and proved that this invariant is satisfied by the initial state and preserved by the transition rules this is the largest part of the coq about lines of coq and taking about to the proof a detailed explanation of the invariant is given in section here we just show the two most interesting consequences of the invariant which relate the construction states of certain subobjects let p p be two subobjects of the same complete object we say that p is a direct subobject of p if either p is a direct nonvirtual base of p or p is a object and p is a virtual base of p or p is a field subobject of p that is p is a cell of a structure array field of p lemma vertical relations on construction states assume that p is a direct subobject of p the construction states of p and p in any execution state satisfying inv are related as follows if p is constructed then p is if p is field subobject of p constructed if p is a base subobject of p constructed constructed if p is a base subobject of p if p is a field subobject of p let p be a subobject of static type c and p p be two direct subobjects of p we say that p occurs before p if either p is a object and p p are two virtual bases of p in inheritance graph order p and p are two direct nonvirtual bases of p in declaration order p and p are two cells of the same array field in the order of their within the array p and p are two cells of two different fields in declaration order p is a object and p is a virtual base and p is a direct nonvirtual base of p or a cell of an array field p is a direct nonvirtual base of p and p is a cell of an array field lemma relations on construction states assume that p occurs before p the construction states of p and p in any execution state satisfying inv are related as follows if p is then p is constructed in an arbitrary state in the remainder of this section we only consider execution states that can be reached from the initial state and therefore satisfy the invariant inv progress to check that our transition rules make sense and that no rule is missing we prove a progress property of construction and destruction once construction of a complete object starts it always eventually reaches a point where the object is fully constructed without getting stuck in the middle and likewise for destruction this result is false in general since constructors and destructors can perform arbitrary computation they can get stuck on eg an attempt to assign an scalar field however we can prove the expected result if we restrict ourselves to nearly trivial constructors and trivial destructors we say that a class c has a nearly trivial constructor if c has a default constructor with no arguments and return as its body for bases and fields just call the default constructors without any other computations scalar fields are initialized with constants for each structure array field f of c if f has type b then b has a nearly trivial constructor this notion extends the concept of trivial constructor from the c standard eg by allowing virtual bases and virtual functions theorem construction progress let p k g be an execution state where p cn st ie we are about to execute a block statement assume that c is a class having a nearly trivial constructor and that the list calls the default constructor for every array cell then there exists a state p k g such that · p k g p k g · p ie construction has terminated and the block body is about to be executed · in state g all cells of the array c are in the constructed state a similar theorem holds for destruction here we use unchanged the notion of trivial destructor from the c standard a class c has a trivial destructor if its destructor is just return all virtual bases and direct nonvirtual bases of c have trivial destructors for each structure array field f of c if f has type b then b has a trivial destructor safety of field accesses and virtual function calls the rule for reading the contents of a scalar field puts no precondition on the initialization state of the field we can however show that this rule gets stuck whenever the field is not in the constructed state theorem a scalar field has a welldefined value only if it is constructed proof follows from inv and the fact that setting the value of a scalar field only occurs in two cases either on an ordinary scalar field which is forbidden if the field is not constructed or on scalar field initialization which turns the field construction state to constructed moreover our semantics the value of the scalar field when it like c itself our semantics allows fields to have no and therefore remain without a defined value after construction however we also proved that if we remove the transition rule allowing fields without to proceed a scalar field has a welldefined value if and only if it is constructed virtual functions have no initialization state per se however the c semantics for virtual function calls provides a very useful guarantee concerning the construction state of the this subobject theorem whenever a virtual function is called the subobject bound to its this parameter is in state or constructed or and all its subobjects are in state constructed proof consider a call to a virtual function f on a subobject p since this call does not go wrong the generalized dynamic type po of this subobject is defined by definition of generalized dynamic types po is in state or constructed or invariant inv then guarantees that all subobjects of po are constructed from lemma the final for function f being either po or one of its subobjects the result follows in other words a virtual function can always safely assume that bases have been properly constructed it cannot however assume that fields of its defining class are in the constructed state since for these fields can call the virtual function as discussed in § and by qi and myers java does not provide a similar guarantee through inheritance and method overriding it is possible for a method to be invoked before its super classes have completed their initialization evolution of construction states lemma if s s is a transition step of our smallstep operational semantics and if the construction state of the subobject p is c in s and c c in s then c sc and any other subobject p p keeps its construction state unchanged proof by case analysis on the transition rules with the help of invariant inv corollary any subobject is never constructed or more than once in particular any virtual base subobject is constructed or at most once despite being potentially reachable through several inheritance paths also if an object goes from one construction state to another then it must go through all construction states in between theorem intermediate values theorem if s s then for any subobject p and for any construction state c such that p c sc p there exist changing states s s such that s s s s and p c and p sc here for a state s p k g we write for object an important design principle of c is that destruction is performed in the exact reverse order of construction we now formalize and prove this property along with more general properties about the relative of two subobjects two subobjects of the same complete object let be a complete object of type cn theorem if p and p are two subobjects of the complete object either the lifetime of p is included in that of p or the lifetime of p is included in that of p to prove this theorem we need to characterize the construction order between subobjects we write p cn p to say that p occurs before p in the depthfirst lefttoright traversal of the construction tree in figure see chapter for a formal definition in terms of the direct subobject and occurs before relations of § the two crucial properties of this construction order are the following lemma the construction order is total if cn p b and cn p b then either p cn p or p cn p lemma construction order and for any reachable execution state s and any complete object of type cn if p cn p and p constructed then p constructed in other words if p cn p then the lifetime of p is included in the lifetime of p theorem then follows directly from the two lemmas above using lemma and the definition of cn we have the following stronger special case theorem if p is a subobject of p then the lifetime of p is included in that of p as a corollary of theorem it follows that if p is constructed before p then p is before p theorem destruction in reverse order of construction let be a complete object of type cn and p p be two subobjects of consider the reduction sequence below where p is constructed before p then later p is s s s s s s c c c we write ci below a state s to denote that pi is constructed in state s and to mean that pi is not constructed then there exist intermediate states s s such that p stops being constructed between these two states s s s s s s s s c c c c proof at state s p is constructed but p is not hence the lifetime of p cannot be included in that of p by theorem the lifetime of p is therefore included in that of p since p is no longer constructed at state s so is p at state s since at most one subobject changes construction state during a given transition lemma p p and p is no longer constructed at state s the result then follows from the the intermediate values theorem theorem subobjects of different complete objects in the full c language including dynamic allocation the of two subobjects of different complete objects are in general new and delete operations can be interleaved arbitrarily in our core language complete objects can only be created by block statements and therefore follow a stack discipline theorem the of two subobjects p and p of different complete objects are either disjoint or included in one another this result follows from theorem and the stronger property below which shows that throughout the execution of a block the construction states of subobjects of complete objects do not change lemma let s s s s be the execution of a block the transition s s enters the block and allocates a fresh complete object the transition s s exits this block for all complete objects already allocated in state s the allocation states of its subobjects p are identical in s and s resource acquisition is initialization is a programming discipline where program resources such as file descriptors are systematically in classes all of such resources are performed within constructors of the corresponding class and all of such resources are performed within destructors of the corresponding class we cannot prove a general result the proper encapsulation of resources in classes this is a matter of program verification we can however prove that in a terminating program every construction of a subobject is correctly matched by a destruction theorem consider a partial program execution s s where the transition s s marks the end of a block statement that allocated the complete object then between the initial state and s the following events occurred in this order · every subobject of was constructed exactly once · every subobject of was exactly once in reverse order of construction proof the invariant inv implies that at state s all cells of the structure array are and so are all of their subobjects consider a subobject p its state is in the initial state and in s therefore by the intermediate value theorem theorem it must have entered state constructed at some point then left state constructed at some later point meaning that p has been initialized once then once the claim on construction and destruction order follows from theorem generalized dynamic types we finish this section with interesting properties of generalized dynamic types which were introduced in § to give semantics to virtual function calls and dynamic casts a b b c b b a a bc cs sd db b c b b bc cs sd db b c b b bc cs sd db c c bc cs sd db bc cs constructed sd db figure evolution of the dynamic types of an instance of c and of its subobjects in the example of § dynamic types are undefined at points where the signal is low and defined and equal to the indicated type when the signal is high vertical transitions denote points where a compiled implementation must update pointers to theorem the generalized dynamic type of a subobject if defined is unique proof the result is trivial if the object is constructed since it is then equal to the generalized dynamic type otherwise we observe that the object can have at most one base class subobject in state or as a consequence of invariant inv and conclude a subtle aspect of generalized dynamic types is that they do not exist as the construction or destruction of a object proceeds the generalized dynamic type of one of its subobjects between defined and undefined consider the following program struct a virtual void f struct b virtual a struct b virtual a virtual void f struct c b b figure shows the evolution of the dynamic type of an instance of c and of its subobjects while this instance construction then destruction for example during the construction of base b the subobject b is already constructed but its generalized dynamic type is undefined the constructor of b has returned but c is not yet constructed and calling f on b has undefined behavior theorem let i be a subobject and i be its most derived object ie repeated c consider a transition s s where the construction state of i changes then the generalized dynamic types for all subobjects in the program as shown in table in a compiled implementation dynamic types are as extra fields in the representations of objects these fields containing in general pointers to when the generalized dynamic type of a subobject is undefined its dynamic type field can contain any value however when the generalized dynamic type is defined the dynamic type field must contain a pointer to the corresponding vtable theorem therefore exactly the program points where the compiled code must update dynamic type fields when all bases of a subobject are constructed and just before the construction of fields begins dynamic type fields must be updated for the subobject in question and all of its bases likewise when the subobject destruction at the point where the destructor is entered impact on the c language specification the development of the formal semantics reported in this paper several issues with the c standard they were reported to the c some of them were fixed in time for the c standards others will be addressed in future virtual functions calls during object construction and destruction the formulation of c of the behavior of the abstract machine when a virtual function is called during construction or destruction was and did not clearly support the original correctly modeled in this paper this was reported to the c as issue number the formulation was in time for adoption in c conflicting description of end of object lifetime although the language formally defined in this paper does not allow explicit management of object lifetime coming up with a simple coherent unified and faithful description of object lifetime led us to discover conflicts and semantics in the c documents both c and c the c standard has a conflicting description of the effect of calling a destructor two p and p claim that an objects lifetime ends when a call to a nontrivial destructor occurs or its storage is reused or released however another p claims that once a destructor is invoked its the object no longer exists this issue will be resolved after c is published we expect that for consistency the resolution will not consider of the destructor to determine when an objects lifetime ends effect of calling destructor for builtin types c allows an expression of the form pt where t is a type name and p is an expression that points to a t object this form was introduced to support function templates explicitly object lifetime without forcing the author to distinguish between builtin types and class types it was also intended to bring however the formulation of the behavior of the abstract machine appears to indicate that the following program fragment has a welldefined meaning for any scalar type t t ft x t t x tt return t this is in a clear conflict with the case where t is a class type indeed for every class type t that function leads to an undefined behavior as it attempts to the local variable t twice once explicitly through the call to the destructor and a second time implicitly when the function exits finally it appears that the program is and a is required when t is an array type lifetime of array objects the c standards explicitly indicate that the lifetime of an array object starts as soon as storage for it has been allocated regardless of when the lifetime of its elements starts in general a complete objects lifetime starts after all its subobjects have been constructed this appears to be a from c in its formulation it will be after publication of c along with a more unified treatment of the lifetime of objects of builtin types application to verified compilation to in the semantics presented here and its the first author developed and proved correct a simple compiler that translates the core language presented in this paper when the subobject i i i with i i i with i i i goes from constructed constructed any to constructed constructed any then the gen dynamic type of i i i not a base of i i not a base of i i i i not a base of i i not a base of i i with i i goes from undef undef undef undef undef undef undef undef to undef undef undef undef undef undef undef undef does not change table of generalized dynamic types when the state of a subobject i of object changes to a simple intermediate language similar to cminor this verification is described in chapter the compiler proceeds in two passes using as intermediate language the language of et al extended with a operation that explicitly modifies the dynamic type of an object the first translation pass is similar to that outlined in thesis constructors and destructors into nonvirtual function calls however operations are inserted at the program points characterized by theorem to implement the proper semantics for virtual function calls and dynamic casts following a popular optimization two versions of every constructor are generated one for the most derived case the other for the inheritance subobject case the second translation pass extends our earlier work on object layout the proofs of semantic preservation are standard arguments by forward simulation diagrams § the proofs are rather big about lines of coq for each pass because there are many cases to consider along with complex invariants relating execution states but present no major conceptual difficulties related work formal semantics for c describes a formal semantics for c that was mechanized in hol his semantics describes a much larger subset of c than ours including in particular expressions with side effects and evaluation order exceptions free store new and delete and temporary objects construction and destruction are modeled by dynamic translation the reduction rule for the construction of an object produces on the a statement containing the necessary invocations of and constructors for fields and bases this statement is then reduced normally as a way to state the semantics approach is simpler than our of the protocol however we that approach would make it more difficult to prove about construction states and in the style of § additionally we that semantics does not correctly capture the interaction between construction destruction and virtual function calls consider struct b b b virtual int f return b struct d b virtual int f return int main d d return in bs constructor the initialization in b a pointer whose dynamic type is b correctly at that time however after completion of ds constructor the dynamic type of b is not updated to d causing the wrong f virtual function to be in main the semantics of and tip is a major starting point for our work it does not cover object construction and destruction phd thesis describes this semantics and its formalization in greater details as well as a static unverified translation of construction and destruction into nonvirtual function calls this translation fails to correctly implement cs semantics for virtual function calls in the translated program the dynamic type of a subobject is always its most derived object regardless of construction state we are not aware of any other formal semantics for c that addresses construction and destruction type systems for safe object initialization several research projects develop type systems for objectoriented languages that enforce safety guarantees about object initialization such as the fact that welltyped programs never read fields of an uninitialized object and introduce a type system to remove useless field to null while still ensuring safe object initialization qi and myers introduce a more general type system to precisely and statically determine at each program point which fields may be read or not et al formalize a type system for safe java object initialization using the coq proof assistant their type system shares with our operational semantics the use of construction states for objects but in their case construction states are lifted to the type level and maintained at compiletime this enables their system to statically check contracts over methods that constrain the construction states of some of the arguments for instance our work makes no attempt at providing static typing safety properties beyond the few by c instead we aim at a precise description of the dynamic semantics of construction and destruction in the presence of multiple inheritance the type systems mentioned above are based on the java and c object models moreover they only deal with object initialization without object destruction or finalization indeed in java object finalization is weakly specified although the java language specification requires objects to be it does not describe more precisely when object finalization should occur c offers a destruction mechanism namely object but it must be called explicitly by the programmer extending the semantics our semantics presents the core features of c object construction and destruction as as possible towards the standard however it can be extended in a number of directions manual memory management we no difficulties with supporting free store objects ie the new and delete operators only slight modifications to the operational semantics appear necessary of course theorem would be since objects no longer follow a stack discipline however it appears very difficult to formalize more general manual memory management allowing for instance explicit destructor calls and the use of placement operators such as c to construct an object at a given memory location temporary objects of class types expression evaluation passing arguments by value to functions or returning results by value construction and destruction of temporary objects while the lifetime of these objects are welldefined by the c standard and they follow a discipline their storage are not specified in fact we found between the definitions of storage as specified by the c standards and the c standards for temporary objects beyond scalar values returned by functions or passed as arguments will require nontrivial extensions to our semantics copy constructor more challenging is to give semantics to functions that return values of class types they are objects constructed in the callee but in the caller at the end of the full expression containing the call for c has allowed of copy constructors even if they have observable behavior that would normally copy a local object to the temporary return value provided certain conditions easy to check are met these program transformations are necessary in practice to obtain good performance but are not in the traditional sense the same applies for the c notion of move constructors exceptions it is easy to capture a key aspect of c exceptions in our semantics objects are properly when an exception is exception objects are temporary objects with lifetime dynamically controlled by exception handlers much like function invocations with the exception object as argument c allows exceptions by value so our observations for function call argument by value apply here furthermore the semantics of constructors need to be to invoke destructors for completely constructed subobjects in presence of exception similarly the semantics for destructors should be to include program if a subobject destructor raises an exception finally interaction between construction of dynamic objects and exceptions both of which reflect related design decisions should be investigated these features are at the basis of generalized techniques for dynamically controlled resources popular examples include smart pointers such as and remarks we hope that this work light on the precise semantics of construction and destruction in c and what they actually guarantee to the working programmer several features remain to be addressed but the subset that was formalized is already quite realistic and similar to subsets for critical embedded systems the semantics implements a pattern for a tree traversal which could perhaps be generalized and abstracted over finally it would be interesting to exploit this semantics in the context of type systems and other static analyses that verify stronger safety properties about initialization references the coq proof assistant ­ url m a and b the annotated c reference manual addisonwesley m and s establishing object invariants with delayed types in nd conf on objectoriented programming systems and applications oopsla pages ­ acm j b g steele and g the java language specification rd edition edition l t v and d enforcing secure object initialization in java in computer security ­ volume of lecture notes in computer science pages ­ springer international standard programming languages c international organization for standards international standard programming languages c international organization for standards x leroy a formally verified compiler journal of automated reasoning ­ martin joint c coding standards for the system development and program url m a formal semantics for c technical report x qi and a c myers masked types for sound object initialization in th symp principles of programming languages popl pages ­ acm t mechanized formal semantics and verified compilation for c objects phd thesis paris jan t g and x leroy formal verification of object layout for c multiple inheritance in th symp principles of programming languages popl pages ­ acm j g and d p friedman an algebraic semantics of subobjects in th conf on objectoriented programming systems languages and applications oopsla pages ­ acm b classes an abstract data type facility for the c language sigplan not ­ january b the design and evolution of c acm co new york ny usa d from formal semantics to verified slicing ­ a modular framework with applications in language based security phd thesis oct d t g and f tip an operational semantics and type safety proof for multiple inheritance in c in st conf on objectoriented programming systems languages and applications oopsla pages ­ acm 