deciding choreography realizability state university email university of california email university of email abstract since software systems are more concurrent and distributed modeling and analysis of interactions among their components is a crucial problem in several application domains communication is used as the interaction mechanism and the communication contract among the components of the system is specified semantically as a state machine in the computing domain such communication contracts are called choreography specifications a choreography specification identifies ordering of message in a distributed system a fundamental question about a choreography specification is determining its realizability ie given a choreography specification is it possible to build a distributed system that exactly as the choreography specifies checking realizability of choreography specifications has been an open problem for several years and it was not known if this was a decidable problem in this paper we give necessary and sufficient conditions for realizability of we implemented the proposed realizability check and our experiments show that it can efficiently determine the realizability of web service os channel contracts and communication diagrams categories and subject descriptors d verification formal methods general terms verification keywords interactions choreography realizability introduction most software systems involve concurrent or distributed behavior or both they run concurrently on hardware interact with each other over the network and access data and computational resources distributed over the compute an important concern in construction of concurrent and distributed software systems is the coordination of different components that form the whole system in order to complete a task components of a software system have to coordinate their executions by interacting with each other and specification and analysis of such interactions is a challenging problem communication is a common interaction mechanism used in concurrent and distributed systems where components permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm interact with each other by sending and receiving messages specification and analysis of interactions has been an active research area studied in several application domains including coordination in computing interactions in distributed programs and process isolation at the os level a crucial problem in all these domains is the choreography realizability problem a choreography specification identifies the set of message exchange sequences among the components peers of a distributed system a choreography is realizable if there is a way to implement a set of components that to the choreography many systems use asynchronous where components interact with each other by sending and receiving messages over unbounded fifo channels even when the behavior of each component is modeled as a finite state machine if asynchronous communication is used the state space of the overall system is infinite in fact finite state systems communicating with unbounded fifo communication channels are powerful enough to simulate turing machines and hence many verification and analysis problems for them are undecidable determining realizability of choreography specifications for communicating systems has been an open problem for several years and it was not known if it is decidable more precisely the choreography realizability problem is given a choreography specified as a finite state machine is it possible to determine if there exists a set of communicating finite state machines that generate precisely the set of message sequences specified by the choreography specification note that given a set of communicating finite state machines it is not possible to automatically determine the set of message sequences generated by them however in this paper we show that the realizability of a choreography specification is decidable and we give a necessary and sufficient condition for determining realizability there have been earlier results in this area that provide sufficient conditions for choreography realizability eg to the best of our knowledge this is the first paper that identifies a necessary and sufficient condition and demonstrates the decidability of the choreography realizability problem we have also evaluated our approach by checking the realizability of channel contracts web service and diagrams rest of the paper is organized as follows in section to our work we discuss how the realizability problem arises in different domains we also give a high level overview of the proposed approach in section we formally define the realizability problem by formalizing the communication contracts as finite state conversation protocols and a distributed system as a set of finite state peers communicating via messages over fifo message queues in section we present our main results on realizability in section we discuss our implementation using the in section we discuss the related work and in section we conclude the paper interaction exchange name send exchange interaction or r a r r or r offer o r r ar r c r r c r r accept figure part of the choreography specification for a protocol and the corresponding state machine motivation and overview in this section we our work by describing four application domains where the choreography realizability problem appears and therefore the results from this paper are directly applicable service interactions choreography specifications service oriented computing provides that enable multiple to integrate their over the typical execution behavior in such a distributed system involves a set of peers interacting with each other through messages for instance consider a group of that wish to integrate their online the front end that enables user interaction via web may within one organization however in order to serve a user request this front end may send and receive messages from software components that in other the goal of web services standards and is to facilitate this type of to integration modeling and analysis of interactions is a crucial problem in this domain due to several distinguishing features of such systems first may not want to share the internal structures of their software components with other they intend to do with this type of requires and rich interface specifications that enable integration of software components that may be written using different languages and implementation platforms in order to achieve such a among different components it is necessary to specify the interactions among different components without referring to the details of their local implementations we use peer to denote a that with other second modeling and analyzing the global behavior of such distributed systems is challenging since no single party may know the full details of all the components in such a system in the absence of detailed models for the distributed components that in such a system the desired global behaviors have to be specified as constraints on the interactions among different components since the messages among different components are the only observable global behavior moreover for this type of distributed systems it might be to model the interactions among different software components before the components are written this type of topdown design may help different to better coordinate their development efforts choreography specification languages target specification of this type of interactions for example web services choreography description language is an language for describing the interactions among the peers in a composite web service a choreography specification in corresponds to a global ordering of the events among the peers in a composite service ie a choreography specification identifies the set of message sequences for a composite web service figure presents a of a specification for two services as r ie role and r ie role in a process where each service continues sending offers to the other until one of them accepts the offer or the process the specification contains information regarding the roles description of every action in terms of the sender receiver and the message content and type and the ordering branching and sequencing of actions interactions among concurrent processes channel contracts is a new experimental operating system developed by microsoft research to explore new approaches to os design one of its main goals is to improve the of software systems by some design decisions that have largely operating system architecture to date process isolation is a design principle of the operating system to achieve this certain constraints are enforced to ensure process independence among these is the rule that processes cannot share memory with each other or the kernel all communication in therefore occurs via over bidirectional called channels channels have two end points referred to as the client and the server the client and the server processes use the channel to communicate with each other by sending and receiving messages communication through channels corresponds to asynchronous communication via fifo queues in each channel is by a channel contract a channel contract is basically a state machine that specifies the ordering of messages between the client and the server hence channel contracts serve the same purpose that choreography specifications serve in computing processes are written in an extension of c called it provides constructs for writing channel contracts and its compiler statically checks that the processes communicating over a channel to its contract figure presents a simplified version of a contract a channel used by for interacting with a device this contract defines three states start ready and waiting and the evolution among states correspond to message contracts are written from the perspective of the server where send actions by the server are with to denote communication from the server to the client and receive actions by the server are with to denote communication from the client to the server public contract state start success ready state ready waiting or ready state waiting ready ready s c start s success c s c c s c s waiting ready ready s c s c figure a simplified channel contract from the os for interaction written in and the corresponding state machine server state start ok active error stop state active ls files active active stop s error start cs c sc ok stop active sc files cs ls s c sc cs figure part of a communication contract for a distributed program written in and the corresponding state machine interactions among distributed components contracts is a general purpose concurrent programming language that was developed initially at for improving the of applications in processes do not share memory and only interact with each other via messages is a language for specifying communication contracts in distributed programs figure presents partial specification of a server interface specification and describes the evolution of the server from one state start active etc to another in response to external ls etc contracts are based on finite state machines given a state eg start a transition from that state identifies a sequence where after receiving a message eg the process sends a response eg ok and moves to the destination state eg active interaction specifications diagrams diagrams called communication diagrams in provide a convenient formalism for specifying the interactions among the participants of a distributed system a diagram is a representation of a set of peers a set of communication links among them and an ordering of the message among the peers unlike diagrams specify the global ordering of send events rather than the local ordering of send and receive events the semantics of diagrams can be formalized as a state machine characterizing all ordering of message in a distributed system hence for example diagrams can be used as a formalism for representing web service overview of the proposed approach web service choreography specifications channel contracts contracts and diagrams are all different mechanisms for specifying ordering of messages among a set of concurrent or distributed processes analysis of interactions is an essential problem for all these languages and although these languages target different application domains the interaction analysis problem remains the same in short a communication contract specifications cut across a wide range of application domains computing new for os embedded systems b communication contracts are used to specify interactions among peers services realtime software and finally c one key problem for communication contracts used in each of these application domains is to check whether a given communication contract can be realized in this paper we present a necessary and sufficient condition for realizability and show how it can be applied to multiple domains in our approach we first translate communication contracts specified in different languages into a conversation protocol which is a finite state machine that specifies the sequences of messages ie among a set of peers for instance the state machine shown in figure oi offer ai acceptance and ci sent by ri is the conversation protocol for the corresponding choreography specification we label the transitions of the conversation protocols with sender denoting the sending of message msg from the sender peer to the receiver peer the state machines shown in figures and are the conversation protocols for the corresponding channel contract and the communication contract specifications respectively in the following section we give a formal definition of conversation protocols in order to analyze realizability of conversation protocols we also need a formal model of distributed systems that interact with messages we model such systems as a set of peers where the behavior of each peer is specified as a finite state machine we assume that each peer has a fifo message queue that stores messages sent to it by the other peers when a peer executes a send transition the sent message is to the message queue of the receiving peer a peer can only execute a receive transition if the transition matches the message at the head of its receive queue when a peer executes a receive transition the message at the head of its receive queue is removed the behavior of the overall system is defined by interleaving the executions of peers a conversation protocol is said to be realizable if and only if there exists a set of peers whose interactions to the contract note that by interactions we mean send sequences ie the receive actions occur locally when a peer a message from its own this is in contrast to the earlier work on realizability of for example in where both the send and receive actions are considered the realizability problem is undecidable it is not immediately clear if ignoring the receive actions simplifies the realizability problem since the basic formal model we are looking at involves peers that are interacting in an asynchronous fashion and each peer is assumed to have a of unbounded size as a result the state space of the global system consisting of multiple peers may be infinite the main result we present in this paper is that choreography realizability problem is decidable which has been an open problem for several years we provide a necessary and sufficient condition for realizability which states that a choreography specification is realizable if and only if · its behavior is language equivalent to the bounded system of communicating peers where each peer behavior is obtained from the projection of the choreography on each peer and where each peer has a message queue of size equivalence condition and · the bounded system satisfies a specific temporal property wellformedness condition since the choreography specification and the bounded system both have finite state spaces we were able to implement an automated choreography realizability checker using existing equivalence checking and model checking tools realizability we formalize choreography specifications using and conversation protocols section define distributed systems with asynchronous communication section and present different variations of choreography realizability section we use state machines to characterize conversation protocols peer behaviors and distributed systems that consist of communicating peers definition conversation protocol a conversation protocol is represented by c p sc sc l c where p is a finite set of peers sc is a finite set of states sc c is the initial state l is a finite set of message labels and finally c sc × p × l × p × sc is the transition relation a transition of the form sci p m p c represents the sending of message m from p to p p p p figures and present the communication contracts from three different domains and the corresponding conversation protocols the start states are denoted by an incoming arrow without a source state each transition is labeled with a message along with the sender and the receiver of the message we denote the transition labels as mp p where m is the message being sent by p to p systems definition peer behavior the behavior b of a peer p is a finite state machine m t t where m is the union of input m in and output m out message sets t is the finite set of states t t is the initial state and t × m × t is the transition relation a transition can be one of the following three types a of the form t m t which sends out a message m m out a of the form t m t which a message m m in from peers input queue and an transition of the form t t we write t a t to denote that t a t figure illustrates the behaviors of two communicating peers p and p with send and receive actions a b and c definition system behavior given a set of peers p p pn with bi mi ti ti i denoting the behavior of pi and mi such that i i j i j a system behavior or simply a system over p is denoted by a state machine possibly infinite state i p s s m where m s q × t × q × t qn × tn such that i n qi s s such that s t t tn and s × p × m × p × s and for s q t q t qn tn s and s q t q t qn tn s a s s if i j n m i ti m ti i ii qj iii k n k j qk qk and iv k n k i tk tk send action b s s if i n m i ti m ti i ii qi iii k n k i qk qk and iv k n k i tk tk receive action c s s if i i n ti ti i ii k n qk qk and iii k n k i tk tk internal action the above definition states that peers in the system communicate in an asynchronous fashion each peer has an unbounded message queue qi and a message sent to a peer gets inserted to the tail of the queue while a message consumed by a peer is consumed from the head of its message queue note that send actions involve two peers the peer sending the message and the message queue of the receiver peer on the other hand the receive action is local and involves only the receiver peer the behavior of the system depends on the order the send and receive actions as well as the size of the message queues associated with each peer in the system in the following we define systems where each peer has a message queue of size k the send actions in such a system is blocked if the receiver peers message queue is full ie contains k pending messages to be consumed definition system a system denoted by ik is a system where the length of message queue for any peer is at most k the description of system behavior is therefore realized by condition a in definition to include the condition qj k where qj denotes the length of the queue for peer j figure illustrates the behavior of i obtained from the two peers p and p with asynchronous communication for brevity we only show the transitions that involve send actions we also define synchronous behavior of a system where every send action by a peer is consumed immediately by a receiver peer ie the peers interact this can be viewed as the case where the peers do not have any message queues definition synchronous behavior given a set of peers p p pn with bi mi ti ti i denoting the behavior of pi and mi such that i i j i j the synchronous system behavior containing the peers in p is denoted by a state machine i p s s m where m s t × t × × tn s s such that s t t tn and and for s t t tn s and s t t tn s a s s if i j n m i ti m ti i ii tj m tj j iii k n k i k j tk tk synchronous action b s s if i n i ti ti i ii k n k i tk tk internal action the synchronous composition of behaviors b and b of peers p and p respectively in figure would have a structure that is identical to b with one branch having transitions app followed by followed by and the other branch having transitions app followed by followed by proposition the synchronous system behavior containing a set of peers p p pn with peer behaviors bj j n where each peer behavior bj j n is deterministic is also deterministic ie the labels on any pair of outgoing tions from a state are distinct any peer behavior with finite can be and a system i resp ik k obtained by the peer behaviors is denoted by resp finally we define the concept of wellformed systems definition wellformed system a system containing a set of peers p p p pn with peer behaviors bj j n is said to be wellformed if and only if every message sent by any peer can be eventually consumed along some path in the system by the receiver of the message this can be expressed precisely in temporal logic ctl as the property states that whenever the size of the receive queue qi of the ith peer is greater than ie qi is nonempty the system can eventually move to a state where qi is empty all synchronous systems i are wellformed by definition for all asynchronous systems it can be automatically verified via model checking whether the system is wellformed or not any system has finite one can model check such a system against the ctl property equation if a system ik is wellformed we say that note that wellformedness checking for asynchronous systems where message queues are unbounded is undecidable in general realizability we consider two variations of realizability we refer to these variations as realizability and realizability definition realizability a conversation protocol c defined over a set of peers p p p pn is said to be realizable according to realizability or realizability if and only if there exists some peer behaviors bj j n and a system i defined using these behaviors such that realizability for all i c is equivalent to ii and or realizability c is equivalent to i and respectively realizability requires the existence of a system such that its behaviors for all possible receive queue sizes are equivalent to c realizability requires the existence of a system such that its behavior is equivalent to c when unbounded receive queues are used note that the above variations realizability and realizability require the equivalence between the conversation c and the systems and i respectively we consider language equivalence which ensures that any linear temporal logic property satisfied by the conversation protocol is also satisfied by the system that the conversation earlier work on choreography realizability has focused on language equivalence and realizability where sufficient conditions for determining realizability have been provided it may appear that realizability is a stronger notion compared to realizability in the sense that if c is realizable according to realizability then it is also realizable according to realizability however we show in this paper that realizability and realizability are equivalent language equivalence preorder language equivalence for a conversation protocol the alphabet is mp p where p p are peers in the conversation and mp p is a send action definition we denote the language of a conversation c as lc which contains any sequence over from the start state for example the language of the conversation in figure includes a sequence where or r is eventually followed by ar r and in between there are finite number of of the form or r for a peer behavior the alphabet is m in m out where m in and m out are receive and send actions of the peer respectively definition we denote the language of a behavior b of a peer p as lb for example in figure the behavior b of p includes the sequence abc in its language for a system the alphabet is mp p where p p are peers in the system and mp p is a send action in the behavior of peer p definition we denote the language of a system i resp ik as li resp for example the language of the system i in figure includes the sequence app based on the definition language realizability requires that lc for all i for realizability and lc li for realizability ordering we also require the concept of an ordering between systems and peers in terms of their language ordering with respect to language can be easily obtained using the subset relation deciding realizability in this section we prove that determining realizability is decidable present the necessary and sufficient condition for checking realizability of a given conversation protocol and show that this condition can be efficiently computed using existing techniques for equivalence checking and model checking we prove that a conversation protocol c is realizable if and only if it is realized by a wellformed system obtained from peer projections of c we define the peer projection of a conversation protocol as follows definition peer projection the projection of a conversation protocol c on one of the peers p in the conversation is denoted by cp and is obtained from c by performing the following updates to the state machine describing c · if a transition label is mp p then replace it with m · if a transition label is mp p then replace it with m · otherwise replace transition label with we denote the synchronous asynchronous and unbounded asynchronous systems obtained from the peer projections of c by ic and ic respectively for example figure presents a conversation protocol c and its projections to peers p and p next we proceed by first considering realizability section followed by realizability section and finally summarize our in section deciding realizability in this section by realizability we mean realizability unless otherwise mentioned the following the steps of the proof establishing the decidability of realizability outline behavioral ordering we prove that if the conversation protocol c is equivalent to then is the smallest system with communicating peers that is language equivalent to c theorem checking the conversation protocol c is realizable according to realizability if and only if it is equivalent to ii for all i and are wellformed see definition that is c is equivalent to ii of the size i of the receive queues we use the concept of of a system a system is if and only if the system behavior over send actions remains for any receive queue size we show that i are equivalent to i ie i is if and only if i is equivalent to i theorem wellformedness checking realizability also requires that the system that the conversation must be wellformed we present the conditions when the systems are wellformed specifically we prove that a system i is wellformed if and only if i is wellformed theorem finally we show that deterministic systems are always wellformed theorem realizability checking finally using the above theorems we obtain that the conversation c is realizable if and only if is and wellformed and c is equivalent to this statement holds if and only if c is equivalent to recall that denotes the system over peer behaviors obtained by the projection of c over peers as both c and ic are finite state systems verification of equivalence can be done effectively theorem languagebased ordering for the step noted above we discuss certain ordering properties of the systems and peer behaviors to what we mean by the smallest system with communicating peers proposition c lc and i proof the proof follows from the following observations the peers in ic are obtained from projections of c therefore any path in terms of send actions from any state in c is also present in ic any ii can the behavior in terms of send actions of ii by avoiding the paths that occur due to the usage of message queues of length i definition let p p p pn be a set of peers let i be a synchronous system obtained from the bi i n and i be a synchronous system obtained from the bi i n we say that i l i if and only if i i n in the above we define the ordering relations l between systems based on the ordering between the behaviors of the corresponding peers that constitute the respective systems proposition let p p p pn be a set of peers let i ik i denote the synchronous asynchronous and unbounded asynchronous systems where the ith is bi for i n and i ik i denote the corresponding systems where the ith is bi for i n i l i li li li li proof the proof follows from the definitions and i l i implies that the the language of any peers behavior in i is a subset of the language of the corresponding peers behavior in i definition ie any sequence of the ith peer behavior in i is also present in the ith peer behavior in i as a result from definition li li theorem given a conversation protocol c over a set of peers p the following holds for all synchronous systems i defined over a set of peer behaviors for the peers in p lc i lc li l i proof assume that there exists an i such that lc li and l i let the behaviors of the ith peer in and i be bi and bi respectively note that are deterministic in therefore there exists an i such that definition that is there exists at least one path in bi which is not present in bi recall that bi is and is each path in bi corresponds to at least one path in c definition therefore absence of a path in bi implies at least one of the paths in c is not realizable using i this results in contradiction checking as mentioned in the outline item a conversation c is realizable according to realizability if and only if it is equivalent to systems ii for all i the following theorem due to establishes a a a b c b c c b c b b b a pp a pp c pp pp b i figure two peer behaviors that are language the necessary and sufficient condition under which the behaviors of i ii are language equivalent this is referred to as the condition theorem i is language ie i and only if li li consider the behaviors b and b of peers p and p respectively in figure the synchronous system i obtained from these peers has a behavioral structure similar to that of b there are two nondeterministic branches along which a is sent from p to p along one branch b is before c and in the other branch c is before b the bounded asynchronous behavior on the other hand see figure allows all possible ordering for communicating b and c along both the nondeterministic branches the languages of i and i are identical therefore the system obtained from p and p is language language wellformedness we present the condition under which a language system is wellformed see item of outline of proof above for realizability we also use this result in the context of realizability see section theorem wellformedness a system i is wellformed if and only if i is wellformed proof it is immediate that i is wellformed implies that i ii is wellformed for proving the other direction assume that i is and therefore there exists a k such that and there exists a path in ik over a sequence of states t t tl tl with i l ti ti and the message ml is never consumed by peer pl recall that as i is language any sequence of send actions in ik is also present in i from these observations we iteratively construct a path in i we denote the sequence of send actions causing violation of wellformedness in ik as consider the path in the behavior of peer pl over the sequence of local states identical to the local states of pl in the sequence t t tl in ik as i is consider a path over a sequence of states t t tl tl in i that results in the same sequence of send actions and where all send actions are immediately consumed by the receiver peer such a path is possible as i i and ik contain identical sequences of send actions note that this path in i is wellformed consider the path in the behaviors of all peers other than pl over the sequence of local states that are identical to their local states in the sequence t t tl construct a path in the system by considering the local states of pl item above the local states of all other peers item above and proceed by sequentially matching the send action sequence in this path if at any point a transition results in a message sent from a sender peer ps to a receiver peer pr whose receive queue contains one message to be consumed we delay this transition by moving some transition that occurs after it and does not involve the peers ps and pr a given the sequence if the above operation can be performed the action then a new path is obtained along which none of the receive queues contain more than one pending message to be consumed ie a path in i is obtained further note that as we have considered the path of pl where it does not consume the last message ml i is not that is when i is b consider that such item above can be performed on the prefix such that b after which the operation of moving b before is not possible without allowing at least one peers receive queue to hold more than one message in the above and are sequences of send actions let the of in a new sequence observe that b is a sequence in ik and it not repeat the above steps starting from item with this new sequence b note that in new iteration we are still considering the same path in peer pl item above but considering new paths for all peers other than pl the new paths will ensure that all send actions are immediately received making room for at least one more send action ie b to be performed without forcing any peers receive queue to contain more than message as i is the above iteration will always terminate in step a proving that when i is theorem determinism wellformedness a system i consisting of deterministic peers is wellformed proof a system is and consists of deterministic peers imply that li li and i is deterministic assume that i is not wellformed there exists a sequence of send actions mm m which leads to a state t from where a message m is never consumed due to the same sequence of send actions is also present in i where each message sent is immediately consumed a similar path is present i where every send action is immediately followed by the corresponding receive action resulting in the same sequence of send actions recall that all peers are deterministic therefore i cannot contain two different paths with the same send sequence where one path leads to a state from where m is never consumed and in the other all sent messages are consumed in other words a deterministic i containing deterministic peers is wellformed from theorem the corresponding system i is wellformed and therefore i also holds deciding language realizability based on the above theorems and propositions we now proceed to present the necessary and sufficient conditions for language realizability according to realizability theorem c is language realizable following realizability lc proof to prove c is language realizable according to realizability implies lc assume that c is language realizable and lc ie lc proposition as c is language realizable according to realizability there exists a i such that i lc therefore i is ie lc li lc li from theorem we first establish that for c to be realizable lc must be identical to or peers does not alter the language of the system assuming lc from proposition we have lc this implies that there exists a specific ordering of send actions involving two independent pairs of peers in other words c has a state from where app is followed by and are distinct and the reverse order followed by app is not allowed from the same state in c such a conversation c cannot be realized by any system as the send actions a and b are independent and any specific ordering required by c cannot be obtained therefore if c is realizable then lc ld e t e from theorem it follows that l i this implies that i where bi and bi denote the behavior of the ith peer in and i respectively recall that in the peer behaviors are ie bi is deterministic further from proposition we have li this leads to a contradiction as we have assumed lc li and lc therefore c is realizable according to realizability implies lc li and note that is wellformed theorem next lc lc proposition i lc theorems c is language realizable according to realizability definition app a pp c a a a a b c b b c b b b a b c a b c pp a c pp figure a conversation protocol that is language realizable according to realizability consider the conversation specification c in figure the system behavior of the receive queue size based on peers behaviors is language equivalent to c and is therefore c is language realizable according to realizability deciding language realizability theorem c is language realizable following realizability lc proof the proof proceeds by showing the equivalence between realizability and realizability c is language realizable following realizability i lc definition lc theorem lc theorem lc theorem i lc li c is language realizable following realizability therefore from theorem c is language realizable following realizability lc the conversation in figure is realizable as per realizability the peer behaviors obtained from projection of the conversation and results in a system that is wellformed and language equivalent to the conversation summary of the results theorems and lead to a methodology for automatically checking the realizability of a conversation specification c for realizability and realizability deciding realizability was an open problem we have proved that realizability can be verified by checking the language equivalence between c and bounded system over a set of peers obtained from projection of c on peers and verifying the satisfiability of a temporal property by the bounded system wellformedness verification both equivalence checking and wellformedness verification can be performed automatically using existing tools as the bounded system and the conversation representing the choreography specification both have finite furthermore we have proved that realizability and realizability are equivalent when language equivalence between choreography and system is considered the complexity for wellformedness verification is linear to the size of the bounded system and the size of the ctl formula specifying the wellformed property complexity for ctl model checking the complexity for language equivalence checking is for language equivalence the conversation protocols shown in figures and are language realizable according to realizability and realizability experimental evaluation we have automated our approach for checking realizability of conversation protocols the which provides a wide range of constructs for representing communicating finite state machines and mechanisms for checking equivalences between such state machines we have implemented a translator which takes a conversation protocol specification as input specified in the conversation protocol format of the web service analysis tool and generates two specifications the specification language for a one that corresponds to the conversation protocol itself and b another one that corresponds to the projection of the protocol we have developed scripts that automatically construct state machine representations from the specifications and check language realizability by tool which reduces the state machines and checks equivalence between them in an optimized fashion conversation protocol to translation in processes are declared as process m exit behavior where process is a keyword proc is the process name m m are the messages that are sent and received by this process and behavior describes the process behavior the process behavior specifies the message exchange order using the operators the sequential ordering is specified using the operator where eg mm means that message m must message m choices are specified using the operator where mm means that only one message can be executed looping behavior is encoded as a process with a recursive behavior the internal action and the system termination are described using the messages i and exit respectively consider the figure which describes the interaction between a server and its client below we show a portion of the automatically generated code for this contract we use the suffix s c to denote the messages sent by the server to the client and we use the suffix c s to denote the messages sent by the client to the server the process starts with the message success s c which is sent from the server to the client and then the contract makes a transition into a looping process which starts at the ready state shown in figure this looping process describes all possible behaviors starting from the ready state process exit where process exit bounded asynchronous projection in the language does not support asynchronous communication directly in order to generate the bounded asynchronous model in we create a bounded fifo queue process which can store at most one message for each message queue given a conversation protocol we need to create a message queue for each process generated from its projection for instance the projection of the generates two processes namely server and client in order to generate the asynchronous version of the server process we compose the server and the queue process using composition operator m m where both processes on shared messages m m this queue is responsible for storing the at most one messages to be consumed by the server process exit server queue nil the queue associated with the server with the client by receiving the actions sent by the client it also with the server by sending the actions that are consumed immediately by the server the synchronized actions between the queue and the server are hidden during the composition and become internal transitions in ie transition as per our notation similarly we generate the asynchronous version of the client process by composing the clients receive queue and the client process finally the overall bounded asynchronous model is obtained by composing the async server process with the async client process using the operator these two processes on the message send events equivalence checking after generating the specifications for the conversation protocol and bounded asynchronous projection models we generate the two corresponding using the state space generation tools in the we check the equivalence of the two to determine realizability of the protocol during the equivalence checking the receive actions are hidden as internal action and the send actions are left visible in order to check the language realizability in an optimized way we first reduce the resulting modulo weak trace relation which reduces the transition systems without modifying their visible traces then we check the equivalence of reduced for the conversation protocol and its projection using the weak trace equivalence relation if the two are equivalent this means that for the conversation protocol and its projection are identical and hence the conversation protocol is if the two are not equivalent then we conclude that the conversation protocol is not mean min max conversation protocol size c async model size c analysis time seconds reduction equivalence table protocol and model sizes and analysis time for the experiments on the realizability of conversation protocols c the number of states the number of transitions channels diagrams conversation protocols language realizable table results of the experiments on language realizability experiments we applied our approach to conversation protocols which describe web service os channel contracts and diagrams all these specifications were first automatically translated to conversation protocols in the conversation protocol format of the web service analysis tool using the described in and respectively then we used the conversation protocol to translator we described above to generate the specifications for the conversation protocol and the bounded asynchronous projection we report the results of our analysis in table showing the sizes of the conversation protocol specifications asynchronous models and the execution times for the reduction and the equivalence checking steps the conversation protocol specifications are not very large the one has states and transitions bounded asynchronous model can be very large in some cases however the reduction techniques we use reduces the sizes of the models significantly the reductions take about seconds on average and the equivalence check takes about seconds on average so realizability of a conversation protocol can be determined in about seconds on average according to the results of our analysis see table all conversation protocols in our base are language realizable except four two of the four that fail the realizability check are channel contracts which were by the developers to be related work the languagebased choreography realizability problem for conversation protocols was first proposed in where sufficient conditions for realizability were given the work on session types is also related to the realizability of conversation protocols and has been used as a formal basis for modeling choreography languages the restrictions used in session types to guarantee that local implementations follow the global interaction protocol are similar to the sufficient conditions for realizability given in and they are not necessary conditions ie there are realizable choreography specifications which fail the conditions given in these earlier results in particular both of these earlier approaches do not allow a protocol containing a state with an arbitrary ie a state where more than one peer could send the next message and the protocol works fine for either case protocols which are of this type and are realizable appear in practice for example protocols where one of the peers can the interaction at an arbitrary point and cannot be shown to be realizable with these earlier approaches choreography realizability problem for several different communication models have been investigated in however the presented techniques can only show realizability if the asynchronous projection of the protocol has a finite state space which would not be the case if the protocol has a single self loop for example more recently presented an approach that only allows specification of realizable but like the approaches discussed above this approach does not allow specification of realizable that have arbitrary states finally proposed a new realizability check that correctly identifies the realizability of many arbitrary protocols however like all the earlier results it still provides a sufficient condition for realizability and decidability of the realizability problem has open in this paper we give a necessary and sufficient condition for realizability and show that it is a decidable problem interestingly the similar realizability problem for the which is an extension of is undecidable realizability of diagrams has been studied and it has been showed that language realizability for diagrams can be checked by checking the equivalence of the choreography model with the bounded asynchronous model however the diagram model used in is not as expressive as the conversation protocols and cannot model the contracts and the web service we analyzed in our experiments realizability of channel contracts have been first studied in using the realizability conditions from the realizability check we present in this paper can identify some channel contracts as realizable for which the realizability check used in gives false positives message patterns expressed with petri nets using synchronous communication are in that is one is interested in finding a specification that produces the same pattern of messages when communications become asynchronous this work however already assumes that a conversation is realizable and does not provide realizability conditions the work presented in checks choreography realizability using the concept given a choreography description a monitor service is computed from that choreography and is used as a of the interaction to compute the distributed peers the choreography is said to be realizable if the monitor service is that is there exists a set of peers such that the composition of the monitor service and those peers is our approach is different since the distributed peers are computed without the ie the realizability notion we study in this paper does not require a monitor service and our techniques for checking realizability rely on equivalence checking rather than checking conclusion in this paper we prove that the choreography realizability problem is decidable for systems communicating with asynchronous messages using unbounded fifo message queues we provide a necessary and sufficient condition for realizability which states that a choreography specification is realizable for systems with communicating peers over unbounded message queues if and only if the choreography specification behavior is equivalent to the behavior of a wellformed bounded system where each peer behavior is obtained from the projection of the choreography on each peer and where each peer has a message queue of size as the choreography specification and the bounded system both exhibit finite checking language realizability of the choreography specification can be automatically performed using existing equivalence checking and model checking tools we have also implemented our technique for realizability checking in a prototype tool using and verified the realizability of a wide range of choreography specifications that describe web service interactions os contracts and diagrams the authors thank for discussions on the implementation this work has been partially supported by the us national science foundation grants and project by the of and science and references r k and m realizability and verification of graphs in proc th int on automata languages and programming pages ­ j getting to talk to the outside world in proc acm sigplan work on pages ­ j programming software for a concurrent world pragmatic g t r e and d c a case for message oriented in proceedings of the th int symp distributed computing pages ­ s and t choreography via in proc th int world wide web conf d and p on communicating finitestate machines journal of the acm ­ t c and x fu a tool for choreography analysis using diagrams in proc th ieee int conf web services t and x fu specification of realizable service using diagrams service oriented computing and applications ­ m k honda n yoshida r milner g and s a theoretical basis of concurrent programming wc note october em clarke o and d a model checking the mit press cambridge massachusetts g a p f m and n service in proc pages ­ m m aiken c o g c j r and s language support for fast and reliable communication in os in proc conf pages ­ c and j what are web services comm of the acm ­ june x fu t and j su conversation protocols a formalism for specification and analysis of reactive electronic services theoretical computer science ­ november x fu t and j su a tool for formal analysis of web services in proc th int conf on computer aided verification pages ­ h and lang a language for compositional verification in proc pages ­ h r f lang and w a for the construction and analysis of distributed processes in proc th int conf computer aided verification s and t realizability analysis for interactions using projections in proc th acm int sym foundations of software engineering pages ­ k honda v t and m language primitives and type discipline for structured programming in proc th european symp on programming languages and systems pages ­ k honda n yoshida and m multiparty asynchronous session types in proc th acm sigplansigact sym principles of programming languages pages ­ g c and j r the software stack operating systems review ­ conversation support for agents and component integration java api for xml java message service r and m analysis of realizability conditions for web service in proc pages ­ n and k realizability is in proc st work on services and their composition pages ­ a protocol contracts with application to multiparty service oriented computing and applications ­ d a vs rpc communication models for distributed applications ieee computing ­ message sequence z microsoft message service e understanding web services xml and springer g and t realizability of using process algebra encodings in proceedings of the th international conference on integrated formal methods pages ­ design note channel contracts documentation v z and t analyzing channel contracts in proceedings of the th international symposium on software testing and analysis pages ­ s j and j incremental elaboration of specifications and behavior models using implied scenarios acm transactions on software engineering and methodology ­ unified modeling language version http october web service choreography description language 