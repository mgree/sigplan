on the complexity of the circularity test for attribute grammars m university of north w f case university w c university of abstract it is shown that both the upper and the low er bounds on the time complexity of the circular ity test for attribute grammars are ex functions of the size of the grammar description this result implies the ability of the circularity test in the sense that the implementation of a general algorithm is not feasible another of this result is that this is one of the first problems actually arising in practice which has been proven to be of exponential time complexity i summary in section ii we will review attribute gram as defined by knuth and discuss the problem associated with them in section iii we will concentrate on the complexity of any algorithm to test an arbitrary attribute grammar for circularity by embedding into the circular ity problem the membership problem for writing pushdown which is known to be tial we derive a lower bound of for the time complexity of the circularity test in section iv we propose an algorithm for the test which implicitly provides us with an upper time bound of cn for the circularity test finally in section v we will briefly discuss the implications of these results ii attribute grammars history attribute grammars were defined by knuth in as a tool for formally defining the syntax and semantics of programming as well as natural languages they were subsequently used by different to define the languages and pl these applications seem to support original contention that the attribute grammars are a very natural method of language definition related to the idea of attribute grammars are syntaxdirected translations and attributed translations definition and example an attribute grammar is a contextfree mar g with the following additions gram t each nonterminal has a fixed set of attributes associated with it a fixed subset of these are of type synthesized and the rest are in associated with each production x b are a number of semantic rules specifying how to the values of the synthesized attributes of the lefthand side nonterminal x and the inherited attributes of the nonterminals in the righthand side string b the semantic rule for evaluating each attribute can be any computable function of the attributes of any nonterminal appearing in the same production the attributes serve to specify the contextsensitive features as well as the se of the language an example attribute grammar g is shown in table i table i start symbol a nonterminals a b c terminals x y z attributes synthesized al bl cl inherited a b c c productions semantic rules a a b b c c the work of this author while a at case university was partially supported by the advanced research projects of the department of under contract number bl b b bx h b c y notes c f is a known function in production the subscripts are used in order to distinguish between the attributes of the left hand side b and the right hand side b in practical applications these attributes could denote a variety of things they could the data type of the nonterminal its location in memory etc most interesting context free grammars can generate an infinite number of derivation trees an attribute grammar is said to be wellformed if and only if the attributes at any node of any derivation tree of the grammar can be evaluated dependency graphs looking at the definition of g in table i we see that al for example cannot be evaluated in any derivation tree unless bl is already eval and bl in production depends on the right hand side b and in production it depends on b and so on we can follow this path for a information more easily dependency graphs are introduced a de graph for a production consists of a node for each attribute of the nonterminals of the pro and an arc from attribute ai to attribute aj if ai is used in the evaluation of a figure shows the productions in tree seman tic rules and the dependency graphs of grammar g fig al b bl bz cc c b x b o b bl b q h q bl b bl b x b bz y c notice that the semantic rules provide for information flow throughout the tree and dependency graphs help represent this flow of information also note that synthesized attributes carry information upward while inherited attributes provide for a downward information flow we can now associate a dependency network with any derivation tree fig shows a derivation tree and its dependency network a a a q cz jj y b bl fig al v e bl c b a q c q c x circularity by looking at the dependency network in fig we can tell that we had better evaluate c before we try evaluating a bl b or c now there was an arc b to b at level in fig this situation is in fig obvious ly neither of the attributes bl or b be evaluated because to evaluate bl we would need to evaluate b first and u al ° q vice versa this would cause al not to be table either dependency trees this property are called circular for obvious reasons an attribute grammar is or circular if it can generate a circular dependency network circular attribute grammars are clearly able and one would like to be able to test an at grammar for circularity in his second attempt knuth gives an algorithm which shows that the circularity problem is decidable his algorithm has time complexity and it appears that a number of other have that the problem is quite difficult what we will show in the next two sections is that the circularity test for attribute grammars is in fact of exponential complexity and thus not generally practical iii complexity of the circularity test lower bound in this section we will begin ing how to simulate a linear bounded automaton using attribute grammars and consequently reducing the membership problem for to the circularity test for attribute grammars this construction shows the circularity test to be quite hard since the best known algorithms for solving the membership problem are exponential the circularity test will then be proved to actually be of exponential complexity by extending the re technique to include the membership pro for writing pushdown simulation of linear bounded automaton a linear bounded automaton is a turing machine whose working tape is bounded by the length of the input tape that is the tape head is constrained to scan only a finite amount of tape by left and right for a full description see the membership problem for linear bounded automata is the following given the description of a and an input tape for that determine whether the will ac the input that is when started on that in put will it eventually halt in an accepting state we will assume for sake that the tape head is always scanning the leftmost square of the tape after the has accepted the input we will present a scheme for translating the description of an and an input tape to a line ar attribute grammar the attribute grammar will be circular if and only if the accepts the input tape a simple example will be used to illustrate the procedure for our purposes an is characterized by a set of states q one final state qf an alphabet e containing s symbols an input of length n xx xn and a number of move rules a move is shown by q x which expresses the fact that when the machine is in state q if the reads the symbol x on the currently scanned square the x will be replaced by y the state will be changed to q and the pointer will be moved one square in the direction d d can be r meaning right l meaning left or s meaning stationary indicating no movement the nonterminals of the associated attribute grammar are ordered pairs qx where q is a state and x is a tape symbol of the each nonterminal has two sets of attributes each con n subsets set contains inherited attributes and each subset contains s attributes where s is the number of symbols in the tape alpha of the set contains synthesized and each of the n subsets contains only a single attribute the inherited attributes are used to keep track of the current tape contents and the synthesized attributes are used as return paths in the circuit that we are trying to create we refer to the inherited attributes by where j that the attribute belongs to the jth of the n subsets of inherited and x the letter of the tape al with which the attribute is associated to refer to the synthesized attributes we simply re an integer between and n thus sj re to the jth synthesized attribute for exam ple assuming a binary tape alphabet consisting of symbols a and b and a tape length of the at of nonterminal qx are shown below m m ed n m m ul if the starting state is q the first square to be scanned is square an the input string is then the first production and semantic rules in the attribute are production s q a ia s ia s ib s ia ib b b b s a s the dependency graph induced by these rules j k in the rest of this discussion we will ignore the semantic rules and assume inherited attributes of the right hand side nonterminals and the synthesized attributes of the left hand side nonterminal are filled in as arbitrary constants each move of the gives rise to one pro in the grammar the is to keep track of the symbol in each tape square via the inherited attributes and carry the dependencies in the first production down to form a closed loop if and only if the associated suc reaches a final state we will have a circularity in the attribute grammar if in the process of getting to the point of we have not broken the circuits which implies that we have followed the of the properly the form of the resulting circuit is shown in figure from the figure notice that the reason for numbering the synthesized subsets from right to left is that now we want to set j of the inherited attributes n j zn with set j of the synthesized at fig general form of the desired circuit i i note two points here we only use n of the synthesized subsets the other n will be used in the next section in the inherited attributes the nth set here the rd is always associated with the tape square currently being scanned thus if the tape head moves to the left each set k of the left hand side variable is connected to the set kl of the right hand side variable so that the set n of the left hand variable which will now be scanned is associated with the set n of the right hand side variable the same tion holds for a move to the right set k of left hand nonterminal is connected to set k of right hand side nonterminal are in a position to write down the productions of the grammar a move of the gives rise to the following productions in our grammar ql a ql a both with q a q b semantic rules jl jl f l p j lo ll g il informally the inherited attributes in each set except the middle one are connected directly to the attributes of the corresponding set at the lower level in the middle set the old symbol attribute is connected to the new symbol attribute at the lower level to reflect the symbol change the reason we need two productions is that we do not know what symbol will be scanned after the move and we have to allow for all s here possibilities notice that now the middle set of q a is associated with the second square which i current ly under scan and the second set correctly shows a content of b or square notice that many connections are irrelevant configuration for example the arcs from to subset can be ignored because subset does not correspond with a tape square at the present time consider another move l ya q bl al j ij b j sj sj j now assuming q is a final state we generate a terminal t and close the loops qb t s u ib sj j w k ij figure shows the moves of the leading to the acceptance of the input the corresponding derivation in the grammar generating a terminal and the in the dependency network ej j ab the la moves s ql a q a q b t derivation of t in ag i circular dependency network of ag only the arcs to the circuit are shown we note that if the had not accepted the input tape that is it had not entered a final state the dependency network would not have been circular because the state transitions would not have with the tape contents and the cycle would have been broken therefore in order to find out whether the accepts the tape we could test the attribute grammar for circularity in other words we have reduced the membership problem for linear bounded automata to the circularity question for grammars in order for this reduction to be useful we must show that all the difficulty is not hidden in the translation process that is we must show that the translation procedure takes only a poly number of steps as a function of the size of the description the number of steps re to construct the attribute is pro to its size consequently it is to show that the size of the ag is a poly function of the size of the and its in put tape we are interested in determining the behavior of these description lengths as the tape length n becomes large we have shown that the description length of the and its input tape is bounded below by for some constant cl and the size of the description of the associated attribute grammar is bounded above by for some sufficiently large constant c we can then see that the length of the description of the attribute grammar is certainly no more than for example a constant times the square of the length of the description once the size of the various of the translation process are established it is not hard to see that the translation process itself only takes a polynomial number of steps in terms of the length of the description of the since the membership problem for is hard page we can already see that the circularity test must be quite complex in the next section we will the question of just how complex it is the writing pushdown a writing pushdown or equivalently an auxiliary pushdown automaton is an with an added feature it also has a stack it is thus a of a linear bounded automaton and a pushdown automaton for more information on see cook page has proven that the membership problem for is of exponential com cn therefore by reducing the membership problem to the circularity test we can find an exponential lower bound for the complexity of the circularity test the reduction technique is quite similar to the one in the previous sec tion with some added complications these result directly from the added of the to its stack the grammar now has to remember the symbol on top of the stack and be able to simulate the push and pop moves the stack symbol can be in the nonterminal with no at all push and pop however are more we will subsequently explain how they can be handled the grammar is now nonlinear when the makes a push move the derivation tree into two branches the left one simulating the behavior with the new symbol on top of the stack and the right one simulating its behavior after the new symbol has been off of the stack when a pop is made the current branch generates a terminal symbol and all the loops so that the right branch can continue in order to ensure that the right branch up where the left off we have to take some before splitting a guess is made as to the configuration of the after the cor pop this guess is carried to the left branch as the current guess and to the right branch as the actual configuration of the at the time of the pop the guess is verified and the closed if and only if the guess with the actual contents of the tape at the time of the pop instruction we let the guess for the contents of each po be carried in synthesized attributes which provide return paths for the circuit thus in contrast to the case where each of the n synthesized subsets contained only one return path that is a single synthesized attribute we must now provide s synthesized attributes in each of the n subsets so now the use of the inherited and synthesized attributes becomes more symmetric and we can refer to them respectively as and where j n and x is a tape sym see figure we again repeat that the in attributes contain the current tape con while the synthesized attributes contain the or desired contents after the pop the guess sets are used to guess a configuration of the the tape contents and the pointer position without the current contents of the other two sets at the split the synthesized attributes of the guess sets are carried to the left branch as the guess for this branch the inherited attributes of the guess sets are carried to the right branch as the set of the current contents because if the left branch does end in the configuration that has been then the right branch should go on with that configuration the old guess ie the original synthesized attributes are carried to the right branch as the guess for that branch see figure the attribute move split involved in simulating a push inherited synthesized inherited synthesized current guess guess current n come e m m l q n run ma an ma m r v b q each nonterminal is a indicating the mode to be discussed the current state the desired state the current tape symbol and the current stack symbol the desired state is initially set to qf the final state before each push move simulation the derivation tree en a guess mode in order to guess what the con of each square of the work tape will be when the symbol which is being pushed onto the stack finally gets back off of the stack the nonterminals in the guess mode have attributes each nonterminal in the guess mode has exactly twice as many attributes as the other nonterminals so that the current tape contents and the previously tape contents will not be during the process we two extra sets of attributes the guess sets as opposed to the old ones which we call the current sets see figure inherited current synthesized guess inherited guess synthesized current inherited current synthesized current inherited current synthesized current we will now show specifically what tions are needed for the push move which indicates that the state will be changed from q to q the current tape symbol x will be replaced the symbol z will be put on top of the current symbol z on the stack and finally the tape head will be moved one square to the right push non pop move is handled almost exactly as in the case and we will not elaborate on it to enter the guess mode the following productions are needed q xz u qq xz for all states o and symbol u the left hand side nonterminal says that the gram mar is in normal mode the current state is q the desired state the current tape symbol is x and the current stack symbol is z the right hand side nonterminal is similar except for its first entry the u which is a tape symbol as the first entry of the nonterminal indicates that the grammar is in guess mode and a guess of u is being made this is in the attributes by semantic rules which produce the following dependency graph now the current sets will remain while through a series of productions a guess will be made in the guess sets these productions are u qq xz for all u and v in the alphabet by means of these productions a guess is made in the subset of the inherited and synthesized sets and the previous all pushed over one square that the middle set is associated with the square under scan we require some more productions to position the guess correctly that is push it over an arbitrary number of without adding new for all u in the tape alphabet and z pop notice that the next state in the pop move must match the desired state q in the nonterminal changing the scanned tape symbol from x to y and the tape one square to the right will be reflected in the dependencies among the attributes of the nonterminal and the attributes of the pop nonterminal the grammar contains one production for eliminating the pop nonterminal and connecting the current tape attributes to the tape contents attributes pop t t is a terminal symbol in the grammar these semantic rules will cause the circuits to be closed at this point and if the guess at split time was correct the paths will go all the way up to the start of the right branch to end a derivation for the final state qf qf t for all x in the alphabet z is the initial stack after a series of these productions the guess sets the middle two sets will contain a configuration that we think the automaton will have after the pop it is now time to split into two branches the in the nonterminal indicates that the nonterminal is ready for the split normal q q y wz for all states q and tape alphabet symbol w notice that the x is changed to y as the push instruction required and that the first nonterminal on the right hand side of the production records the fact that the new stack symbol is z for a pop move mar does the following the gram in order for these semantic rules to close all the circuits we make the assumption that the will only accept an input with its read head to the left of the tape this assumption does not result in any loss of generality but allows us to write down the start production easily suppose for example that the input tape is xl x x then the starting production would be s normal ql qf ql is the associated attribute dependencies would be o q bl tt q q this will ensure that a cycle will result if the accepts the input and vice versa notice that the double connections of the synthesized attributes to the inherited attributes in production imply that we do not care what the tape contents are at the time of acceptance of the tape an example transformation from to ag is shown in figure a counting argument similar to the one used in the case shows that for any class of with a fixed alphabet if the length of the input tape is n the length of the grammar description is proportional to n the time required to construct the at grammar is a polynomial in the length of the input tape as it is easily seen from the con this in conjunction with re page gives us a lower bound of for the complexity of the circularity test for attribute grammars iv complexity of the circularity bound in order to find an upper bound for the complexity of a problem one merely has to find an algorithm to solve the problem we consider an algorithm here which appears to be less complex than that given by knuth the solution we propose here is as follows given an attribute grammar g write down a context free grammar g such that g will be nonempty if and only if g is then by testing g for emptiness we are in effect testing g for circularity we know that the complexity of the emptiness problem for con text free languages is there if the translation procedure does not cause more than an exponential explosion we can con that the complexity of the circularity cn is above by test construction of a context free grammar from an attribute grammar given an attribute grammar g we intend to build a context free grammar g such that g will be nonempty if and only if g is circular clearly we must not lose any information during the trans formation from ag to cfg we move the information contained in the attributes of g into the of g thus each nonterminal in g gives rise to a number of nonterminals in g which re certain dependencies the more attributes which are associated with each nonterminal the figure ql u u q z q z j u accept a the moves of causing it to accept the string ri it u normal ql q ii i v zz j z t rk more nonterminals there will be in g because there are more possible dependencies among the at for any nonterminal x in g we can write the corresponding nonterminal in g as where d indicates a number of dependencies among the at of x in the following we will sketch the procedure for constructing g from g in order to understand how g works observe that in a derivation tree of g with de attributes any particular circuit has a single top node some one or more bottom nodes and some up and down arcs that connect certain at of these nodes to form a circuit it is important to realize that there is only one top node for a given circuit the first thing that grammar g does is to find the node at the top of the circuit to this end every time the derivation tree splits we guess which branch will eventually lead to the de top node this guess can be indicated by associating a star with the nonterminal of the branch that is by writing the x as x we can now write the first series of productions of g they are identical to those of g except that the left side and one of the right side nonterminals are the nonterminals in these productions do not record any dependencies among their as an example of these productions p x b i z in g gives rise to x y z and in g x y z notice that an nonterminal can now do exactly as its counterpart does in g its behavior has no effect on the circuit because we have decided that the circuit is along another branch if we take s as the starting nonterminal of g where s is the starting nonterminal of g these productions will eventually cause the top of the circuit to be located in the derivation tree now we need productions to cause the star to go away when the top node has been located for each production ing we write in g a number of productions of the form p x ye zf where e and f reflect a number of among the attributes of y and z respective ly and the dependencies reflected in the dependency sets e and f together with the depend implied by the semantic rules of tion p form a circuit the dependencies implied by the semantic rules of p supply some up and down dependencies and it is assumed that the de sets e and f which do not exist at this production and which will be supplied by the bottom nodes will be created by the nodes further down the derivation tree now a search must be to that e and f will in fact be generated the following productions will do just that for each production p xyz in g we write a series of productions in g p ye zf such that if those dependencies among attributes of y and z which the dependency sets e and f will arise from dependencies lower in the derivation tree were actually to arise then those dependencies together with the dependencies inherent in the semantic rules of p would give rise to the dependencies in dependency set d with the productions obtained so far we can detect the top of the circuit and work our way down the tree looking for desired dependencies that will cause a circuit the next series of productions detect these desired dependencies when they are encountered for each production p xyz we write in g p x d yz in g if the dependency set d is implied by the semantic rules of production p now by also including in g all the productions of g we allow for the possibility of the derivation of terminal strings in g we claim that the above productions of g produce a terminal string if and only if a derivation tree in g produces the same terminal string and the attributes of this tree are defined this can be seen by observing that in a de tree of g the start symbol generates a number of branches one of which is the ones act exactly as they would in g and derive terminals only if they derive termi in g however the branch can only derive nonterminals and eventually a num of nonterminals with desired dependency sets which would cause a circuit these nonterminals will go away only if the desired dependency sets are found to exist that is if a circuit is found thus given a circular derivation tree in g we can find a derivation tree in g and vice versa in other words we have translated the pro of the circularity of g to the emptiness of g we know that the emptiness problem is poly therefore if we show that the size of g is an exponential function of the size of g and that the translation procedure is also exponential bounded we can deduce that the test is exponential remember that apply ing a polynomial function to an exponential pre serves the the important point in the counting argument are the following if there are k attributes associated with p ing we would require at least space to specify the semantic rules that is is a lower bound on the size np of the description of the production p and its semantic rules this production gives rise to a series of productions in g p ye zf let us investigate the total size of these productions to begin with note that a circuit needs to go through an attribute at most once the dependencies d e and f are therefore only required to contain pairs of attributes with the restriction that the left members of these pairs be unique the pair indicates that the left element depends on the right one therefore with k attributes there can be at most kk possible pairs of dependencies among k them ie d e and f can each be any one of k possible sets of pairs the description of each nonterminal is therefore of approximate length log kk as k we can write kk al the length of the description of one such production is bounded above by c for some constant cl which is to the number of nonterminals in production p the number of possible productions in the worst case is c time c c is the number of nonterminals in production p therefore an upper bound on the total length the descriptions of productions p in g come from a given production p in g can be written as for some constant c since the size np of the description p satisfies np of the see that this argument can be extended to prove that the size of the description of g is at most an exponential function of the size n of the description of g which in turn provides us with cn as the upper bound for the complexity of the circularity test theorem the circularity question for grammars is an exponential problem the up per and lower bounds on the time complexity of the problem are respectively cn and where c and c are constants and n is the length of the description of the attribute grammar and implications in this paper we have established that the circularity test for attribute grammars is of ex time complexity such problems are generally regarded as that is to say there can be no algorithm which is general enough to work in every instance within practical time and space limits this implies that if we want to be able to answer the circularity question for a particular attribute grammar which we would be interested in doing if we are trying to write a compiler for the language we should be to impose some restrictions on the way attributes are defined in the grammar such restrictions have been suggested previously general less restrictive set of restrictions is given in and will be discussed in a future paper acknowledgements we would like to thank k g for our interest in attribute grammars and h b for sharing many insights concerning computational complexity references d e knuth semantics of context free languages math syst th t e knuth correction to math syst w t declarative semantic definition report computer science department stanford university t a a declarative semantic definition of pl computer languages group computer science department a v aho and j d unman translations on a context free grammar information and control december p m lewis r e syntaxdirected jacm july p m lewis d j and r e attributed translations proc fifth annual acm symp on theory of comp j hopcroft and j d unman formal languages and their relation to automata m w f c on the complexity of the circularity test for attribute grammars computing center report no case university r m among combinatorial problems in complexity of computer r e and j w press new york g writing pushdown j comp syst sci s a cook characterization of pushdown machines in terms of computers jacm g v semantics evaluated from left to right publication no department de june m on attribute grammars and the semantic specification of programming languages phd thesis department of computing and information sciences case university computing center report 