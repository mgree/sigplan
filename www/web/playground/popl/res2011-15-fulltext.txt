precise reasoning for programs using containers department of computer science stanford university thomas department of computer science stanford university aiken department of computer science stanford university abstract containers are generalpurpose data structures that provide functionality for inserting reading removing and over elements since many applications written in modern programming languages such as c and java use containers as standard building blocks precise analysis of many programs requires a fairly sophisticated understanding of container contents in this paper we present a sound precise and fully automatic technique for static reasoning about contents of containers we show that the proposed technique adds useful precision for verifying real c applications and that it to applications with over lines of code categories and subject descriptors d software engineering general terms languages verification introduction containers are a family of generalpurpose abstract data structures that provide functionality for inserting removing and over elements examples of containers include maps lists vectors sets as well as their combinations we classify containers as either or in containers each element e has a position that is used for inserting e into or reading e from the container containers include vectors and lists which support inserting and reading elements at a specified position as well as queues and stacks which allow inserting and reading elements at the first or last position in contrast containers expose no notion of position and each element is added and using its value instances of containers include various kinds of maps sets and for instance in a map elements are inserted and up using a key similarly in a set elements are inserted and found by the value of their elements rather than a position in the container both kinds of containers are in modern programming and many languages such as c java and c provide a standard set of containers that programmers use as basic building blocks for the implementation of other more complex data structures and software for this reason successful verification of programs written in higherlevel programming requires a fairly sophisticated understanding of how individual elements are permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm modified as they flow in and out of containers in fact even basic safety properties often require reasoning about individual elements stored inside containers · to prove that the result of looking up a key k from a map m is nonnull we need to know that an element with key k is present in m and that the value associated with k is nonnull · in languages with explicit memory management such as c the safety of sequentially elements in a list or vector depends on the absence of aliasing pointers in the container as these examples illustrate proving even simple properties may require a richer abstraction than treating container contents as sets in the first example we need to know not only which values are present in the map but also which keys are associated with which values similarly the second example requires proving the uniqueness of elements stored at different positions of the container hence successful verification of these properties requires a detailed understanding of container contents we are interested in verifying properties of programs such as the examples above we focus on verification of the client program checking of the client from the separate problem of verifying the container implementation itself we believe this separation is for several reasons understanding the contents of a container does not require understanding the containers implementation for example while a map may be implemented as a hash table or a tree they both export the functionality of associating a key with a value from the clients perspective the difference between a hash map and a tree lies primarily in the performance tradeoff between various operations verifying container implementations requires different techniques and of automation then verifying their clients hence separating these two tasks allows us to choose the verification techniques for each purpose while we might need approaches for verifying container implementations we can still develop fully automatic and more scalable techniques for verifying their clients there are orders of magnitude more clients of a container than there are container implementations this fact makes it possible to annotate a of library interfaces in order to analyze many programs using these containers we propose a precise and fully automatic technique for static reasoning about container contents by separating the internal implementation of containers from their use our technique provides a uniform representation and analysis methodology for any position or container rather than modeling containers as sets of values our technique provides a understanding of containers enabling the abstraction to distinguish properties that hold for different elements our abstraction naturally models arbitrary of containers commonly used in vector int j j int m new int it for it it string k k k figure example key features of the technique real programs for example our technique can reason precisely about a map of lists expressing which lists are associated with which keys which nested lists are shared or distinct while also tracking the contents of the nested lists an informal overview to develop a unified representation for containers we model any container as a function that converts a key to an abstract index an integer which is then mapped to a value at that index in this abstraction a key corresponds to any term that is used for inserting an element into or reading an element from the container for example in a vector keys are integers identifying a position in the vector in a set keys are the elements that are inserted into the set for any container keys are converted to abstract indices using a mapping but this mapping differs between position and containers for containers such as a vector the mapping is the identity as the key is the position in the data structure for containers we leave the function converting keys to indices uninterpreted clients of containers cannot rely on elements being stored in any particular place just that they are stored in the container a key advantage of introducing an extra level of indirection from keys to indices is that this strategy allows us to treat containers uniformly while providing the ability to between distinct elements by using integer constraints on the indices specifically we model containers using indexed locations of the form i where the index variable i ranges over possible abstract indices of the container all elements in the container are represented by a single abstract location i but constraints on the index variable i allow to be made among the different elements of the container this approach has been previously used for successful reasoning about array contents and as we shall see our approach extends these benefits to both position and containers this combination of indexed locations and constraints on index variables allows for a much more detailed understanding of containers than representing their contents as a set for example if a container cs contents are modeled by the set of values this abstraction encodes that any element in c may have any of the values and effectively values associated with different elements on the other hand by representing c using an indexed abstract location i we can each of the values and by constraints and restricting which indices in figure the representation of container exam after the analysis of code from figure i may have which value the latter abstraction encodes that only those values whose keys are consistent with the index constraint i may have value vi and thereby the between positions and values for containers and for containers to illustrate important features of our technique consider the c code in figure here the container maps each to a vector of integers indicating the score received by each on every exam to keep the example simple suppose that there are only two and and received and and received and on two the code in figure builds a reverse mapping exam where the ith element in exam is a map from each to this score on the ith exam figure shows a graphical representation of the facts established about the contents of exam after analyzing the code from figure in this figure nodes in the graph represent abstract locations a directed edge from node a to b qualified by constraint indicates that b is one of the values stored in a and at which index of a the value b may be stored we important features of the abstraction based on figure abstract containers observe that the vector exam is qualified by an index variable i and the maps nested inside exam are also qualified by an index variable i both of these index variables allow us to select different elements in the container by the values of i and i memory allocations a key for precise reasoning about nested containers is different allocations in the figure memory locations arising from the allocation at line are described by i where i is also an index variable hence just as we use index variables to between elements in a container we also use them for distinguishing different memory allocations arising from the same expression mapping on the edge from i i to index variable i is equal to where pos is an invertible uninterpreted function representing the mapping from key to a unique but unspecified index on the other hand since exam is a container the mapping is the identity function hence the outgoing edge from exam i is qualified by i nesting of data structures on the edge from exam i to the nested maps modeled by i i i is equal to i this constraint indicates that there is a unique allocation for every index of the container exam because there is exactly one i for each i furthermore together with the constraints on edges outgoing from i i the abstraction encodes that the map stored at position of the vector exam key with value but the map stored at position of the vector associates with value iterators the indirection from keys to indices provides a natural way to model iterators by accessing every element in increasing order of their abstract indices since the mapping is always an invertible function the abstraction encodes that every element is visited exactly once this abstraction is also consistent with the expected semantics that iteration order over containers is in general unspecified since pos is uninterpreted while elements of containers are visited according to their position the rest of this paper is organized as follows section gives a small language in which we formalize our technique section describes the analysis and states the soundness theorem section describes some extensions that are useful for modeling containers in real applications and section discusses our implementation section presents experimental results section related work and finally section concludes to summarize this paper makes the following key contributions · we present a unified sound and precise technique for reasoning about contents of an important family of data structures known as containers · we describe a fully automatic static analysis for containers that provides a detailed understanding of their contents and that supports arbitrary of containers · we show that our technique is scalable enough to analyze c programs ranging between to lines of code that make heavy use of containers · we demonstrate that precise reasoning about contents of containers reduces false alarms by an order of magnitude compared to an analysis that treats containers as sets of values when verifying the absence of null dereferences memory leaks and deleted memory accesses in c programs language and concrete semantics we first introduce a simple language used to formalize our technique program p e expression e v c nil new e e let v e in e v foreach v v in v do e od if v nil then e else e fi a program consists of one or more expressions expressions include variables v nonnegative integer constants c the special constant nil container allocations new sequencing e e and let expressions a read operation reads the value of element with key v from container v and v writes value v with key v to container v a foreach construct iterates over container v binding the current key to v and the value to v finally an if expression evaluates expression e or e depending on whether variable v is nil or not the let new and foreach expressions are labeled with which are globally unique expression identifiers when irrelevant we omit types in this language are defined by the grammar type int nil pos adt val adt maybe base types in this language are int and nil containers with elements of type have type pos adt and containers with value type have type val adt to simplify the technical presentation we require keys of value v c int nil nil v adt nil new v adt v int maybe v adt v int v maybe v nil v adt v e e e e foreach v v in v do e od nil e e v maybe v e e if v nil then e else e fi e v e let v e in e figure type checking rules dependent containers to be integers section discusses how to extend our technique to keys with arbitrary types and custom equality operators we also introduce a type maybe for elements whose type can be either nil or a subtyping relation is defined as nil maybe maybe we write adt as shorthand for pos adt val adt type checking rules for this language are given in figure observe that this language allows arbitrary of containers because the element type of a container can be another container also while this language does not have explicit contains and remove operations that are commonly defined on containers elements can be removed by writing nil and the presence of key k can be checked by testing whether the result of reading k is nil operational semantics in the operational semantics of our language we view memory as a array where each row stores a container and each column identifies the index of a specific element in the container we model scalar values integers as rows where only the th column is used a concrete memory location is a pair l i where l is the base location ie the row and i is an offset ie the column figure gives the operational semantics the general structure of the rules are of the form e s c e l s here environment e maps program variables to base locations l store s maps concrete memory locations l i to an integer identifying another base location or a constant and c is a vector of integers denoting the current iteration number of each loop in scope the judgment e s c e l s states that under environment e store s and counter vector c expression e evaluates to value l producing a new store s in figure we use the notation sl to denote store s with binding l removed in the rules we also assume that type environment is available to between position and containers most of the rules in figure are straightforward we only important features of the language semantics there are two key differences between position and containers that our language semantics tries to capture first containers require filled positions of the container to be whereas containers do not second iteration over containers elements in increasing order of their position but iteration over containers elements in arbitrary order in general to capture the first difference observe that the language semantics requires containers to use a ev l sl l e s c v l s e s c c c s e s c nil nil s ln doms s i nil e s c new ln s e s e l s e ev ln ln doms s s ln l e s c e l s e s c let v e in e l s ln ev l sl key ev l sl l sl key e s c s ev l sl key ev l sl val ev l sl l s sl key val e s c v nil s adt ev l sl pos ev l sl elem ev l sl l sl pos nil if l nil pos sl pos nil if l nil s sl pos elem e s c v nil s adt ev l sl l k kn n where ki ki ki i sl ki i i nil if v pos adt permutation if v val adt e ev lk v lv lk lv doms e s c v in do e s e s c foreach v v in v do e od nil s lk lv ev lk ev lv ki i ith element of s ki lv i e s ic e le s e s i c v in do e s e s ic process v v in do e s i size i size e s ic process v v in do e s e s c e l s e s c e l s e s c e e l s ev l sl l e s c e lr s if l nil e s c e lr s if l nil e s c if v nil then e else e fi lr s figure operational semantics region of memory whereas containers may be sparse in particular it is legal to use any key when writing to a container but for containers the write operation is only defined if it does not create holes in the container ie all elements with indices in range size are and elements with indices at least size are nil to capture the second difference observe in the foreach rule that is an ordered list of key value pairs but we construct an arbitrary permutation of when over containers also observe that the key value pairs are hence any changes to the container during the iteration do not affect the key value pairs that are visited abstract semantics in this section we describe the abstract semantics that form the basis of our analysis we first describe our abstract domain section and then discuss our abstract model of containers section in section we present the analysis and in section we state the soundness theorem abstract domain and our abstraction between two kinds of abstract memory locations basic locations represent a single concrete element and indexed locations i represent containers as mentioned in section although a single indexed location i represents many concrete elements our abstraction can reason about individual elements stored in the container by using constraints on the index variable i the abstract values used in the analysis are abstract value abstract location allocation nil c i i abstract values are nil integer constants c basic locations where indicates the program point where the location is introduced and indexed abstract locations i allocations are of the form i where is a label for the syntactic allocation expression new more interestingly allocations are also qualified by a potentially empty vector of index variables to distinguish allocations arising from the same syntactic expression in different loop iterations hence just as index variables allow us to refer to distinct elements in a container index variables also distinguish allocations arising from the same program expression since loops may be nested the number of index variables in i is equal to the loop nesting depth of a new expression unlike the concrete store that maps each concrete location to exactly one concrete value the abstract store necessarily maps each abstract location to a set of possible abstract values an abstract value set is a set of abstract value constraint pairs abstract value set here constraints select particular elements from indexed locations for example if the abstract value set for a container i is i i nil i the abstraction encodes that the values of elements at indices and are and respectively but all the other elements are nil in the rest of this paper we assume that an abstract value set does not contain two pairs of the form and instead contains only once under constraints the constraints we require are more elaborate than we have indicated so far since most static analyses program behavior the reader may expect that the constraints used in the abstraction are in other words if is a constraint describing some subset of elements in the container during a concrete execution then if is an overapproximation now our analysis relies on constraints to model certain constructs well specifically updates to containers and path conditions but unfortunately if is a strict overapproximation then ¬ is a strict underapproximation of ¬ ie ¬ ¬ clearly for soundness we need a negation operation that preserves to solve this problem all the constraints used in our abstraction are constraints may must simultaneously representing over and of some set of concrete elements a constraint is wellformed if must may the key benefit of constraints is that they preserve under negation ¬ may must in other words if may and must are over and for some fact f then and are over and for respectively we briefly review some basic properties of constraints ¬ may must may must may must may may must must may must may must may may must must sat may must valid may must in this paper any constraint is assumed to be a constraint unless explicitly stated otherwise to make this clear any time we do not use a constraint we use the letter instead of furthermore if the may and must conditions of a constraint are the same we write a single constraint instead of a pair for example we abbreviate the constraint i k i k as i k the constraints may and must we use inside constraints in this paper belong to the combined theory of linear integer arithmetic and uninterpreted functions abstract model of containers as discussed in section our abstraction models any position or container as a mapping from a key to an abstract index to a value stored at this index of the container in this section we detail the and the mappings index selection from keys to indices the most important requirement for the mapping m for containers is that it the following axiom i i i i mi mi this axiom states that if two abstract indices are equal then the keys associated with these indices must also be equal this requirement is necessary for soundness otherwise two keys may be mapped to the same index causing a value associated with key k to be through inserts using a different key k hence m has the property that its inverse mapping is a function however the question remains whether m is itself a function in this regard there are two sensible design alternatives for some containers that allow multiple values for the same key such as we can allow the same key to map to multiple indices such that m itself is not a function we can require m to be a function and model containers that allow multiple values per key using nested containers without loss of generality we choose because our model can express arbitrary of containers since both m and m are functions the mapping is always a bijection ie an invertible function however the mapping for containers differs from that of containers in particular for containers m is an invertible uninterpreted function while for containers m is the interpreted identity function the intuition behind this choice is that if we insert an element e with key j into a container then e is guaranteed to be the jth element when over the container on the other hand if we insert element e with key j to a container we have no guarantees about where e will appear in the iteration order thus we model the mapping of containers as an invertible uninterpreted function formally we define two index selection operators and for mapping keys to index constraints for position and containers respectively definition index selection for container let key be the set of possible abstract values associated with some key and let i be an index variable then key i i j j j j key definition index selection for container let key be the set of possible abstract values associated with some key and let i be an index variable then key i i j j j key where pos is an invertible uninterpreted function given an abstract value set key representing a set of possible keys the index selectors and yield a constraint describing the possible indices associated with key in the definition of since the mapping m is the identity function the index variable i is set equal to each possible value j of the key ie i j on the other hand in the definition of the index variable i is equal to an invertible uninterpreted function pos of each key ie i since the abstract value set associated with the key may contain more than one element we take the disjunction of the constraints associated with each possible value of the key element selection from indices to values we now consider the problem of determining the value associated with a given index more specifically given an abstract value set associated with a container we want to determine which elements of are consistent with some index constraint we begin with a simple example suppose that the abstract value set for a container i is i i nil i and we want to determine the possible values of the element at index in the container to do this we can substitute for index variable i and remove all unsatisfiable elements from which yields as the only possible value for this element we formalize this concept using an element selection operation definition element selection let i denote the set of index variables mentioned in constraint and let qe define a quantifier elimination procedure then j j j j j j first observe that the element selection operation filters out elements in inconsistent with because of the requirement second observe that the resulting constraint j is obtained by existentially and then subsequently eliminating all index variables used in from the constraint j because j j existential quantifier elimination generalizes the simple substitution mechanism we sketched out informally in the example since the index constraint is not always a simple equality we may not be able to substitute concrete values for the index variables hence we use existential quantifier in the general case furthermore it is not required that this nil true c true e s c nil s e s c c s ev s e s c v s e s c e s e s c e s e s c e e s e s c e s ev s c e s e s c let v e in e s ev s nil j j j nil j e s c e s e s c e s s s s nil e s c if v nil then e else e s figure transformers not directly related to containers quantifier elimination procedure be exact since our technique uses constraints in particular since quantifier elimination in the theory of uninterpreted functions is not always exact we may use quantifierfree over and example consider the abstract value set i false i false nil i i associated with container i to determine the possible values of those elements whose indices in the container are in the range we compute i true false true false the resulting set encodes that the possible values of elements in the range are either or but definitely not nil the analysis we describe the analysis as deductive rules of the form e s c e s where e s and c are the abstract counterparts of the e s c environments used in the concrete semantics in particular the abstract environment e maps program variables to basic locations the abstract store s maps abstract memory locations to abstract value sets and finally the counter vector c a vector of integers is used for distinguishing different loop iterations we present the analysis in three steps first we discuss the basic transformers not directly related to containers figure then we describe the abstract semantics for reading from writing to and allocating containers figure and finally we give the abstract semantics of the foreach construct figure most of the transformers presented in figure are straightforward we only discuss rule in detail in this rule nil describes under what condition v is nil after independently analyzing the then and else branches we obtain the resulting abstract store s by s and s with and nil respectively and then taking their union in this rule we use the notation s as shorthand for the operation that with every constraint in s doms s j j j j s read from position dependent container ev ev s s s ij ij j ij j e s c s read from value dependent container ev ev s s s ij ij j ij j e s c s w j w j j j w p k k k k s i s i w w w p update c i ik k s i val key i s ik val key ik k k s s i ik k s key val with s write to value dependent container ev ev ev s s s s update with s e s c v nil true s write to position dependent container ev ev ev s s s s update with s e s c v nil true s container allocation i i i in where n c s i nil true i c e s c new i i c s i figure abstract semantics for container operations rule also uses a join operation on abstract stores defined as doms doms s s s s in this definition we require that every abstract value that is present in either s or s is also present in the other if it is not explicitly there we add it under constraint false abstract semantics for container operations we now consider the abstract semantics for reading from containers presented in figure in the first two rules of figure represents the abstract value set for the key v and each of the elements ij in abstract value set are containers that the read operation may be performed on we perform the mapping using the operator for containers and the operator for containers as described in section in these rules the constraints ij j and ij j describe the positions in container ij from which we read the value finally we perform the mapping using the operation the abstract value set describes all possible elements that may be obtained as a result of the read the now consider the rules in figure that describe the abstract semantics for writing to containers the rule computes the new abstract value set associated with container i after writing w at those indices of i described by constraint w since w is written to only those locations that satisfy the index constraint w we w with each element in w to obtain w now those elements in container i that do not satisfy the index constraint w are not modified by the write hence the existing values s i are preserved under condition thus p represents all values in i that are not affected by the write finally the set of new values stored in container i is obtained by taking the union of w new value for the updated indices and p ie values stored at all other indices the second rule update uses to compute the new abstract store after a write in this rule each element ij in c represents a container that may be written to the value set val describes the possible values that may be written and the constraint key ij j where is either or describes those indices of ij that are modified for each container ij in c the rule is invoked to compute the new value set j after the write and a new store s is obtained by binding each ij to its new value set j the write rules for position and containers use the update rule to compute the new abstract store after the write as expected the rule for containers uses the operator while the rule for uses the last rule in figure describes the abstract semantics for container allocations the abstract location arising from the allocation is labeled with the expression identifier to allocation sites and the vector of index variables i allocations arising from the same syntactic expression in different loop iterations since the counter vector c has as many entries as the loop nesting depth of the allocation expression the number of variables in i is equal to the number of entries in c observe that in this rule the constraint i c that each index variable in i is equal to the appropriate counter describing the iteration number of a loop finally recall that the concrete semantics the entries in a allocated container to nil hence the rule is invoked to compute the new value set associated with container i after its elements to nil example consider the simple program v val val in let x in let y in nil assume ev a the abstract store after line is given by s a b i true b i nil true here b does not have any index variables because the allocation expression is not in a loop the index variable i in b i ranges over recall that the operational semantics are undefined if containers are not used since checking this correct usage condition is an orthogonal problem to reasoning about container contents the abstract semantics reason only about programs for which the operational semantics do not get stuck key value pair at kth iteration for pos adt ev s c v s ij ij k j ij j c k v v v v v v nil key value pair at kth iteration for val adt ev s c v s ij ij k j ij j c v v v v nil k v kv k k kv k foreach elem vk kv key key key val kv val val key val kv e ev v s s key val e s c fix e k s nil true e s c foreach v v in v do e od s fix e cc e s s s e s c c fix e k s e s cc fix e k s figure abstract semantics for over containers indices of the container after the write at line we have s a b i true b i i pos nil i pos at line the abstract value set for x is s b i i s b i i pos true similarly at line the abstract value set for y is s b i i nil true abstract semantics for iteration the main idea behind the abstract semantics for over containers is that the jth iteration of the loop accesses the key and value pairs stored at the jth index of the container it is easy to see that this strategy is correct for containers because i the concrete semantics requires an element with key j to be accessed during the jth iteration and ii in our abstraction the mapping for containers is the identity function for containers recall that the operational semantics an arbitrary iteration order now although the abstraction models iteration by the element at the jth index during the jth iteration it does not impose any restrictions on which key may be visited during the jth iteration because the mapping is an uninterpreted function the constraint j is satisfiable for any value of j and any key k furthermore since pos is an invertible function the abstraction encodes that for each different value of j there is a different key k indicating that no key may be visited multiple times figure gives the abstract semantics of the foreach construct the first two rules compute the set of key value pairs that may be visited during an arbitrary kth iteration of the loop for containers respectively since the abstract semantics models iteration as the kth index during the kth iteration we the values stored in container ij under the index constraint ij k therefore in the first two rules the abstract value set v describes the values that may be stored at index k for containers the key during the kth iteration of the loop is bound to k as required by the operational semantics in the first rule we construct the set of possible key value pairs for the kth iteration as the set of all k v such that v is and in v observe that the key value pairs in respect the relationship between keys ie positions and values as illustrated by the following example example consider a container i such that s i i i nil i we compute the set of key value pairs during the kth iteration as k k k k observe that the abstraction respects the relationship between positions and values for example the pair is infeasible the second rule in figure computes the key value pairs during the kth iteration for containers in this rule the key during the kth iteration is bound to all integers k such that k as by constraint k as in the case the relationship between keys and values are preserved because the rule filters out infeasible key value pairs by checking the satisfiability of kv finally observe that the pos function is renamed to pos because elements may be visited in a different order in each loop the foreach rule first invokes the appropriate elem rule for computing the set of key value pairs during an arbitrary k th iteration the variable k is with the expression for this loop in order to avoid naming conflicts the set kv therefore describes the set of possible key value pairs during an arbitrary iteration the abstract value sets key and val are obtained by selecting the keys and the values from kv respectively the abstract environment e binds variables v v to fresh locations and and the abstract store s binds and to key and val since the operational semantics requires the key value pairs to be computed before executing the body of the foreach construct the foreach rule uses the fix rule to obtain the final store s in the fix e k rule c represents the current iteration number of the loop since the bindings for v and v are parametric on vari able k the rule replaces occurrences of k in s with concrete value c when evaluating the loop body e in this rule s is a sound store de the effect of the loop as s the store after any loop iteration here an abstract store s another abstract store s written s s according to definition definition domain extension ss an abstract store s ss is a domain of s with respect to s if the following condition holds let be any binding in s and let i i be any element of s if s i i s then ss i i ss otherwise ss i false ss definition abstract store overapproximation s s let s be the domain extension ss and let s be the domain observe that the set of all possible ks is finite for any given program in our language hence candidates for k are drawn from a finite set extension ss then s s if for all s and for all i such that i may must s and i may must s may may must must according to this definition a store s another abstract store s if when they are extended to the same domain any may constraint in s implies the corresponding may constraint in s and any must constraint in s is implied by the corresponding must constraint in s in other words the overapproximation encoded in s through the may constraints is more permissive than s and the underapproximation encoded by s through the must constraints is less permissive than s in the fix rule it is easy to see that a trivial invariant store s always exists since the analysis creates a finite number of abstract locations for any given program and an abstract store with constraint true false mapping each possible abstract location to any other abstract location has the property s s to find a more useful invariant store than the trivial it is necessary to infer numeric invariants relating index variables associated with different containers or allocation sites since the focus of this paper is not invariant generation we do not go into the details of how to find a good invariant store various techniques based on abstract interpretation and quantifier elimination can be used for finding invariants in particular our previous work on array analysis presents an algorithmic way of finding such invariants in this domain and we use the algorithm from in our implementation an example key features of the analysis in this section we consider a small but realistic example some important features of the analysis consider the following program fragment paper val val in pos cur paper in papers do pos pos in paper paper od paper paper in paper nil then else nil in this program fragment papers is a container whose elements are identifiers for all submitted papers to a conference the code above creates a new container paper that maintains a mapping from each paper identifier to a list of associated with this paper the code iterates over papers and for each paper allocates a new container and inserts the key value pair cur paper into the map for simplicity let us assume this particular conference was this year and had only with identifiers and which are placed in papers in this order let us also assume that is p and sp p i true after the allocation at line during some arbitrary kth iteration of the loop the abstract environment and stores are p a d paper c sp sa s p i p i true b i true i i i nil i sc k k k s b i nil true sd ei i i k s ei i nil i k consider the write at line which uses cur paper as the key and the allocated container as the value here the possible values of cur paper during the kth loop iteration are given by sc above which encodes that the value of cur paper is during the first iteration k during the second iteration k and during the third iteration k the abstract value set for the value is given by sd ei i i k here the allocated container is represented by ei i which has two index variables i and i where i distinguishes allocations from different loop iterations and i elements stored in the container the constraint i k in sd encodes that we are considering the allocation that during the kth iteration hence the set of all possible key value pairs that are written at line in any kth iteration are ei i i k k ei i i k k ei i i k k now if we eliminate the dependence on a particular iteration k we obtain the set of all possible key value pairs that may be written during any iteration of the loop ei i i w ei i i ei i i observe that while all the allocations at line are represented by a single abstract container ei i the index constraints that the allocations associated with each key are distinct from each other since the values of i are different for the keys and now to process the write at line we use the update rule from figure for each entry in w with c b i true the location associated with container paper the key value sets key val given by each entry in w key true val ei i i etc and using the index selector since paper is this yields ei i i i pos i i pos s b i i i pos nil i pos i pos i pos the new abstract value set s b i expresses that all containers stored in paper are unique because the value of i is for each key now let us consider lines in the program fragment to determine the result of the read at line we compute ei i nil i i pos i i pos i i pos i pos i pos i pos i pos which when simplified yields ei i i hence if paper f then sf ei i i for the if expression at line only the then branch is satisfiable since ei i is not nil finally after the write at line the values for the nested containers are given by s ei i i i nil i i hence this abstract store encodes that only the score at position of the list associated with key in paper has been changed to but the score lists associated with all other keys are unchanged soundness of the abstraction in order to state the soundness theorem we first need to define an abstraction function from concrete to abstract memory locations observe that if i denotes a vector of index variables used in some abstract location and is a concrete assignment to each of the index variables in i then the pair represents one concrete memory location therefore the abstraction function is a mapping from concrete locations to a pair consisting of an abstract memory location and a full assignment to all index variables used in abstraction function concrete loc l i to make this abstraction function precise it is necessary to augment the operational semantics with some additional machinery that was omitted from figure to avoid the language semantics first for each concrete location l i in store s we need to determine the program point that results in the binding of l i in s we write i to denote the program point associated with the introduction of l i second to be able to give a full assignment to the index variables in an abstract location we need to determine the counter vector c when a concrete location was introduced hence we assume an environment a maps each concrete location l i to the counter vector c present when l i was introduced in concrete store s since it is trivial to extend the operational semantics from figure to track i and al i we assume this additional information is available we can now define the abstraction function as follows definition abstraction function let l k be a concrete memory location and let k such that labels expression e and al k c then the abstraction of l k written l k is i i i c i k i true i i c i if e new pos adt if e new val adt otherwise we extend this abstraction function from all concrete values v to all abstract values in the following obvious way nil true v c true l k if v nil if v is integer constant c if v is a memory k we write to denote the result of substituting each of the variables in with their concrete assignment specified by in addition we assume the substitution gives an interpretation to all function symbols pos in by replacing pos with the particular permutation it stands for in a given execution since it is trivial to extend the operational semantics to track which permutation was used for which loop we assume this information is available definition value agreement let v be a concrete value with v and let be an abstract value set we say concrete value v with abstract value set written v if may must may must in this definition the first condition states the correctness of the overapproximation encoded by and the second condition states the correctness of the underapproximation if the abstract representation of v is then for the overapproximation to be correct must be in under some constraint may must and the may constraint may must evaluate to true under the index assignment recall that since the language from section has no inputs the only variables in constraints are index variables thus may always evaluates to a constant under the second condition of value agreement states the correctness of the underapproximation requiring at most the abstract representation of v to be in ie all other elements in should be infeasible under index assignment definition state agreement let v e s c be a concrete state consisting of a concrete value v concrete environment e concrete store s and counter vector c and let e s c be an abstract state with abstract value set and abstract environment and store e s and counter vector c we say concrete state v e s c with abstract state e s c written v e s c e s c if the following conditions hold v according to definition v dome v dome ev ev l k doms sl k l l k l s c c theorem soundness let p be any program if e s c e s c then e s c p l s e s c p s l e s c e s c the proof is given in the appendix extensions the language we have used for the formal development requires keys of containers to be integers but in real languages keys may have arbitrary types the techniques we have described so far are directly applicable when pointer values are used as keys because pointer equality is a form of integer equality however it is common to define custom equality predicates on some types and determining whether two keys are equal may be more involved than simple integer equality consider the following c code class point int x int y color c x int y color c bool point other return x y points point p point red point p point blue here the type point defines a custom equality operator that only checks the x and y for a point but its color in the above program after the last insertion operation there is only one element in the set even though two points with different are inserted if we treat p and p as variables in the constraint language our technique would conclude that the size of the set is under constraint p p and under p p to be more precise in the presence of custom equality predicates we infer axioms characterizing when two objects are equal specifically by analyzing the implementations of the custom equality predicates we infer necessary and sufficient conditions may must characterizing when two objects o and o may and must be equal observe that treating p and p as variables in the constraint language as above is equivalent to the trivial and always sound equality condition true false now in order to take into account what we know about the custom equality predicate we add the axioms o o o o may and o o must o o to the constraint solver for instance for the simple equality predicate for point we could the axiom p p p p px px py py allowing the technique to conclude that the size of the set after the second insertion is in the technical development we also assumed that the iteration order over containers is arbitrary while this is true in most cases some containers such as a based map may visit keys in a certain order during an iteration we can encode such restrictions in the iteration order by analyzing the custom less than operators and inferring appropriate axioms about the pos function in a similar way as above implementation we have implemented the ideas presented in this paper in our program verification framework for analyzing c and c programs a gcc and g based frontend called which translates c and c code to a lowlevel representation similar to address code uses the smt solver for solving and simplifying constraints generated during the analysis supports most features of c including classes arrays dynamic memory allocation pointer arithmetic references single and multiple inheritance and virtual method calls performs analysis and achieves by computing polymorphic summaries of functions and loops and them in calling contexts experimental evaluation to demonstrate the of the ideas presented in this paper we evaluate the proposed technique in two different ways in a first set of experiments we perform a case study and prove the functional correctness of a set of small but challenging programs manipulating containers in a second set of experiments we use this technique to prove memory safety properties of real c applications that use containers and we show that a precise understanding of data structure contents is in improving analysis results for both sets of experiments we annotated the containers provided by the c standard template library either directly as position or containers or by nesting them inside already annotated stl containers case study in our case study we analyze small but challenging example programs close to lines of code all benchmarks are available at the results of the case study are presented in figure we briefly discuss each of the programs from this table the first two programs copy the contents of a vector and a map into another container of the same type and assert their equality program builds the reverse map r of map m by inserting each k v pair in m as the pair v k of r program is modeled after the example in section and asserts the correctness of the entries in exam program inserts all the keys in a map m into a set s and asserts that s contains exactly the keys in m programs illustrate nested containers by properties about the composed data structures program inserts numbers size into a stack and a queue and asserts that the top of the stack is the last program time memory vector copy s mb map copy s mb reverse mapping s mb example from introduction s mb set containing map keys s mb map of lists s mb vector of sets s mb s mb relationship s mb singleton pattern correctness s mb prove map values nonnull s mb prove between vector elements s mb list containing pairs of a map s mb set containing map keys with nonnull values s mb relationship between keys and values in map s mb figure experimental results of the case study element in the queue program the singleton pattern through a get shared method that objects that are the same according to their custom equality predicate by using a set and asserts the correctness of get shared program asserts that the values in a map are nonnull and program asserts that there is no aliasing between elements in a vector program builds a list containing key value pairs in a map and asserts that the list contains exactly the key value pairs in the map program builds a set containing all map keys with nonnull values and asserts that the set contains exactly the keys with nonnull values program asserts various properties about the relationship between keys and values in a map is able to fully automatically verify all of these examples while errors in slightly modified versions of these programs as shown in figure the running times for most of these examples are under a second and maximum memory consumption is consistently below mb we believe these examples illustrate that can automatically verify interesting properties about the functional correctness of client programs using containers and their proving memory safety properties in a second set of experiments we investigate the added benefits of precise reasoning about container contents when checking for memory safety properties in real c applications using we analyzed three applications ranging from to lines of c code the first application is which c objects with a database the second application we analyzed is the library of the vector program which was used for the in this we chose this component of because it illustrates how more complex abstract data types are implemented using standard containers as building blocks the third application is a fairly large management program both and the library use the c standard template library stl while uses container libraries of the qt framework fortunately since the containers in qt are with the ones in the stl we were able to use the same set of container interface annotations for all three applications as typical of many programs written in an objectoriented style all of these applications make heavy use of containers such as vectors lists maps and their combinations to demonstrate the importance of precise reasoning about containers when checking for memory safety properties we analyzed these applications in two different configurations in the first configuration we use the technique described in this paper while in the second configuration we track which set of elements a number of lines our technique containers as sets running time cpu min min running time min min maximum memory gb gb null dereference errors actual errors false positives memory leak errors actual errors false positives access to deleted memory actual errors false positives total fp to error ratio library number of lines our technique containers as sets running time cpu min min running time min min maximum memory gb gb null dereference errors actual errors false positives memory leak errors actual errors false positives access to deleted memory actual errors false positives total fp to error ratio number of lines our technique containers as sets running time cpu min min running time min min maximum memory gb gb null dereference errors actual errors false positives memory leak errors actual errors false positives access to deleted memory actual errors false positives total fp to error ratio figure proving memory safety properties container may store but we do not reason about the relationship between positions and values for containers and we do not track the relationships for containers ie we smash containers into a set of values figure summarizes the results of our experiments for each of the three applications we check the following memory safety properties null pointer dereferences memory leaks ie lack of unreachable memory and accessing deleted memory all of our experiments were on an core with gb of memory in figure we provide the running times of the analyses both on a single core as well as on all since the analysis is many functions can be analyzed in parallel to yield much better running times ranging from to on in figure observe that the technique presented in this paper improves the precision of the analysis over the second tion which treats the containers contents as a set in many cases by an order of magnitude for example the total false positive to error ratio for is if the technique presented in this paper is used for the analysis while this ratio increases to with the second analysis configuration this means that there are roughly three actual error reports per false positive using our technique while there is less than one actual error per false positives using the second less precise configuration we believe that this reduction in false positives illustrates the of our technique for analyzing realworld c applications also observe in figure that there are no significant differences in running time and memory consumption between the two analysis configurations we believe that the statistics provided in figure illustrate that our technique adds useful precision without significant extra computational resources related work in this work we share the goal of separating the verification of data structure implementations from the verification of their use with the verification framework ­ main focus is to verify that the implementation of a data structure its specification on the can be used to check that custom data structure invariants are by the client such as the requirement that the data structure has no content before a certain method is called while addresses a more general class of abstract data structures than containers the abstraction of is a set abstraction of data structures which is less precise than the abstraction we consider for instance reasoning about a map does not track the relationship between keys and values in a map or between positions and elements in a vector in contrast we only consider the use of a special yet fundamental class of data structures and our focus is a fully automatic technique to improve analysis precision when analyzing real c programs that use containers another work that addresses the use of data structures is which focuses on verifying that the client of a software component the requirements of that component such as the requirement that a data structure d is not modified during an iteration over d another work with a similar focus is which uses predicate abstraction to verify that clients of the c standard template library stl the requirements for correct use of this library yet another work that is focused on usage of stl data structures is which is an unsound bug finding tool for discovering incorrect usage of stl primitives none of these efforts consider properties which require reasoning about the contents of containers which is our focus we believe that the problem of understanding container contents and the problem of verifying the correct usage of an adt interface are orthogonal and complementary the idea of using numeric constraints to specify elements of unbounded data structures goes back to which uses this idea for tracking pairs in lists in our previous work on analysis of array contents we use the combination of indexed locations and constraints to model arrays while this paper also uses some of the same underlying technical machinery as in the contributions of this work include a formalization of the differences and between different kinds of containers and a precise and uniform analysis framework that both what is the same and expresses what is different about containers in this paper we observe that a key requirement for precise reasoning about nested containers is to between containers allocated in different loop iterations the to distinguish allocations arising from the same expression also arises in other contexts such as static race detection in the technique described in also uses a vector of loop counters to distinguish between distinct allocations the work described in addresses the typestate verification problem for realworld java programs which make heavy use of containers this work also reports on the challenge of achieving sufficient precision as objects flow in and out of containers they techniques such as focus and developed by the shape analysis community based on valued logic in contrast our approach never performs explicit case splits on abstract containers and instead uses constraints to both specify different elements in the container as well as to perform updates on individual elements in this paper we observe that differences among various containers and different containers are for developing a methodology for reasoning about their contents although these differences may have significant performance implications this paper does not address the problem of selecting efficient containers which is considered in or their computational complexity addressed in conclusion in this paper we have presented a precise scalable and fully automatic technique for reasoning about contents of containers we have demonstrated that precise reasoning about containers is important for successful verification of memory safety properties in real c programs acknowledgments we would like to thank for his help with extending our frontend for the c language to c references i t aiken a updates beyond strong vs weak updates in esop gulwani s m cover algorithms in esop ­ cousot p n automatic discovery of linear among variables of a program in popl acm ­ m affine relationships among variables of a program ai ­ l a finding loop invariants for programs over arrays using a theorem prover in ­ i t aiken a static analysis intermediate language stanford university technical report i t aiken a from proofs a complete and practical technique for solving linear inequalities over integers in cav i t aiken a small formulas for large programs online constraint simplification in scalable static analysis in sas i t aiken a sound complete and scalable analysis in pldi ­ c standard template library qt framework lam p v rinard m a tool for verifying data structure consistency in compiler construction ­ lam p v rinard m generalized typestate checking for data structure consistency in ­ v lam p k rinard m modular analyses for data structure consistency ieee transactions on software engineering ­ g a field j d sagiv m deriving specialized program analyses for in pldi n a d verifying c with stl containers via predicate abstraction in conference on automated software engineering acm ­ d s lifting static checking from languages to libraries software practice and experience a interprocedural analysis for pointers beyond in pldi acm ny usa ­ m aiken a conditional must not aliasing for static race detection in popl s e n g e effective typestate verification in the presence of aliasing ­ reps tw sagiv s r static program analysis via valued logic in cav ­ o m e adaptive selection of collections in pldi acm ­ gulwani s kk t speed precise and efficient static of program computational complexity in popl ­ gulwani s b a lifting abstract interpreters to quantified logical domains in popl acm ­ appendix proof of soundness in this section we sketch the proof of soundness of the key rules from section the proof is a standard induction on the inference rules from figures and we only focus on the rules that involve containers a we first introduce some notation that is convenient to use in the proofs and state some assumptions definition let be an abstract value set and let be an assignment to at least the index variables in then j j j j definition let be the constraint may must then may and must throughout the proof we assume that every abstract value that can arise for a given program is present in every abstract value set for values that have not been explicitly added to we assume false a proof of key rules we first consider the read rule for containers let lc k denote the concrete location that the read is per formed on ie the result is obtained from k let lc k c and let k in the rule suppose ij j k k s ij lj lj by the assumption that the abstraction is correct before the read ie e s c e s c we have ij c j true ij c j false k k k k k true k false lj c lj true lj c lj false the resulting abstract value set is computed by the rule as s ij ij k k j now assume for contradiction that k then either i true or ii true assume i by for ij and k k we have c j true and k true thus s ij ij k j by correctness of the abstraction before the read we have may must s ij furthermore since true by and since c must assign ij to k and cj true ij k j true hence assumption i is not possible now assume ii first observe that if ij and k k then from the last identity in it follows that ii cannot hold now if ij then c j false and cs ij ij we have false now if k k we know from that k false hence ii is again not possible an almost identical argument also applies to containers the only difference is that c now assigns ij to and is computed as s ij ij k j now we consider a write v to container v let l k denote the concrete memory location that is modified and let v denote the concrete value that is written from the operational semantics we have s l i v if i k sl i otherwise let l i i k k true v v v sl i ei ei in the write rule from figure let ij j k k v v s ij lj lj by the assumption that the abstraction is correct before the write ie e s c e s c we know k k k true k k k false v v v v true v v v v false ij i j true ij i j false lj ei ei i lj true lj ei ei i lj false in the write rule for each ij the new entry in new abstract store s is computed as s ij s ij ij j s ij where is shorthand for with every constraint in as described in section assume that the write rule is not sound then using either i v s or ii sl i s i for i k we first consider i suppose v s then there are two possibilities a v true vs b v v v true vs now assume a and consider evaluating vs under v we know from that in v contains the pair v true observe that must assign ij to k hence by using we know that the constraint ij ij k k evaluates to true under assignment furthermore under assignment implies that j is true hence it follows that v true vs assumption a now assume b under assignment v we know from that for any v v such that v v v is false since additional constraints cannot weaken false it follows that v v v false vs assumption b we know consider ii ie sl i s i for some i such that i k this corresponds to the case where the abstract semantics for write the existing value of the wrong key again there are two possibilities a ei true ei s i b ei ei ei true ei s i now assume a from we know that under assignment ei ei true now by we need to show that the constraint cannot true observe that i assigns ij to i where i k and observe that k i i k false hence the sufficient condition for ij is false thus true which implies ei true ei s i a finally assume b under assignment ei we know from that for any lj lj s ij such that lj ei lj is false since additional constraints cannot weaken false assumption b is also infeasible the proof for containers is almost identical the only differences are that i now assigns ij to according to the definition of the abstraction function and s is computed as s ij s ij ij j s ij we now consider the foreach rule since the fix rule that s is a correct invariant without giving a constructive algorithm we only argue about the loop initialization ie key value pairs bound in the foreach rule of the abstract semantics correctly model the concrete execution we focus on containers let be the concrete key visited during the kth loop iteration such that k where k gives interpretation to function symbols pos in the abstract semantics the value set key during the kth iteration is given by key k k suppose key then either true or k k true but under interpretation k we have k k k pos k pos k k hence key 