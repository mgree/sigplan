programming with binders and indexed datatypes andrew university abstract we show how to combine a general purpose type system for an existing language with support for programming with binders and contexts by refining the type system of ml with a restricted form of dependent types where index objects are drawn from contextual lf this allows the user to specify formal systems within the logical framework lf and index ml types with contextual lf objects our language design keeps the index language generic only requiring decidability of equality of the index language providing a modular design to illustrate the and effectiveness of our language we give programs for closure conversion and normalization by evaluation our three key technical contribution are we give a bidirectional type system for our core language which is around refinement substitutions instead of constraint solving as a consequence type checking is decidable and easy to trust although constraint solving may be undecidable we give a bigstep environment based operational semantics with environments which itself to efficient implementation we prove our language to be type safe and have mechanized our theoretical development in the proof assistant coq using the fresh approach to binding categories and subject descriptors d programming languages language constructs and types and structures general terms design languages keywords logical frameworks higherorder abstract syntax dependent types recursive types introduction to reason about the runtime behavior of software we design and use formal systems given by axioms and inference rules such as logics to reason about access control abadi et al and pfenning and information flow and logics to reason about memory access et al a or simply the scope of names pottier over the last we have come closer to narrowing the gap between programming software systems and reasoning about them chen and xi et al the general is to design rich type systems which allow programmers to specify and enforce statically powerful invariants about their pro permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm grams yet existing approaches lack rich abstractions that allow users to describe formal systems and proofs on a highlevel factor out common and issues make it easy to use and at the same time have a small trusted kernel in this paper we extend a general purpose language to support programming with formal systems and ultimately proofs this is achieved by indexing types with contextual lf objects contextual lf extends the logical framework lf harper et al with the power of contextual objects m of type a m denotes an object which may refer to the bound variables listed in and has type a in the context see also et al b it also supports firstclass contexts and allows us to abstract over contexts this allows the user to specify formal systems within the logical framework lf and obtaining support for representing and binders renaming fresh name generation and substitutions contextual lf allows programmers to pack open lf objects together with the context in which they are meaningful thereby obtaining closed objects which can be passed and manipulated in particular contextual lf objects can be used to index types and track rich formal properties we demonstrate the advantages of combining contextual lf with datatypes by discussing implementations of closure conversion and normalization by evaluation these examples have been a good benchmark in comparing systems and demonstrate the benefits and of our approach our approach follows the of indexed types see xi and pfenning choosing as an index domain contextual lf which allows us to express properties about open objects the scope of variables and contexts which previous systems such as xi lack instead of generating and propagating constraints which is common in indexed type systems we will associate patterns with refinements substitution and work only with constraints in solved form this leads to a small trusted kernel compared to languages such as and or and which support programming with binders already the language we propose in this paper supports recursive types which the former languages lack this extension is key to important problems such as normalization by evaluation which are typically out of reach for these languages having the ability to define datatypes is convenient it is also more efficient than supporting datatypes via a which is in principle already possible in contrast to and harper which supports binding and computation we keep the separation of data and computations this has several advantages because our index language remains pure it is straightforward to establish adequacy of the formal system and its encoding using standard techniques see for example harper and this allows us to maintain all the good properties of contextual objects namely strong normalization and decidable equality moreover our computation language remains close to traditional mllike languages and is designed to be modular in the index domain as a consequence one can easily replace contextual lf with for example a higherorder logic with inductive types without the computations compared to other systems with a uniform language for computations and types such as the calculus of construction or martin type theory our computation language can easily be combined with imperative features allows nonterminating computation and requires fewer annotations to make type checking decidable the main technical contributions of this paper are · we present a core language with dependent types where we separate the types from computations one can think of this core language as the target of a surface language where we may omit implicit indices via type reconstruction our language is a conservative extension of a general purpose language where types are indexed by contextual lf objects and contexts and at the same time supports pattern matching on its index objects because it may be viewed as an extension of with recursive types we call our language however we emphasize that our design of the computation language is generic and we can replace the index language which in our case is contextual lf with any other language where equality between two index objects is decidable · we present a bidirectional type system for our core language we model dependently typed recursive types as fixpoints with explicit equality constraints on contextual objects this is similar to xi et al and et al where recursive types are with equalities between types to model gadts however instead of and solving constraints during type checking our approach relies on refinement substitutions in branches although constraint solving may be undecidable in our setting type checking based on refinements remains decidable type checking is hence easier to trust · we give a bigstep operational semantics because we allow matching on expressions and index objects we distinguish between the environment for values and index objects and show that types are preserved by extending our operational semantics to also track computations following cousot and cousot leroy and we prove progress · we have mechanized the typing rules the operational semantics and the type safety proof preservation and progress in the proof assistant coq we use the fresh approach to binding by and pottier to model variables in our language the proposed programming language with support for contextual objects and datatypes is a prime candidate for programming code transformations and certified programming more generally it provides a foundation for programming with domainspecific logics and demonstrates how to a general purpose programming language with direct support for programming with logics and proofs the remainder of the paper is organized as follows to illustrate the main idea of defining types indexed with contextual objects we discuss in detail three examples section evaluator closure conversion and normalization by evaluation we then introduce a language which supports contextual objects and datatypes in section we begin by introducing our index domain in section which in our case is contextual lf this will review and summarize previous work in this area we then present the computation language in section which includes indexed types recursive types variants and general pattern matching we will leave out polymorphism and imperative features which are orthogonal issues and which are straightforward to add the typing rules for and an bigstep semantics together with the type safety proof are presented in section we explain our of the type safety proof in section the rest of the paper is concerned with some related work current status and future research directions motivating examples in this section we discuss three examples which illustrate the utility of a language combining contextual types with indexed recursive types we use an informal surface syntax inspired by both and agda this surface syntax is intended to elaborate to the core language presented in section evaluator for the lambdacalculus we begin with a of a evaluator for the untyped lambdacalculus which is directly comparable to that of and harper this allows us to explain contextual objects in a simple setting we first represent the untyped lambda calculus in lf with higher order abstract syntax hoas lam tm tm tm app tm tm tm to implement an evaluator we must analyze and pattern match on and consequently we must be able to handle open objects hence the evaluator will be parameterized with a context which keeps track of variables of type tm and contextual objects of type tm to type contexts we define a context schema ctx as follows schema ctx tm to express that contains only variables of type tm we write ctx the of this example when compared to or is that we can write the closure of a term under an environment of bindings as a datatype with a single constructor cl as follows datatype cl ctx tm type tm we write tm for the type of terms whose free variables come only from the context we write tm for the type of variables of type tm in context ­ ie elements of we using it for lf types and also types since datatype is part of the computation language the arrow in tm does not indicate the lf function space but rather the usual computational function space hence this datatype represents the bodies of lambda abstractions in some context together with a binding for each of the free variables one note that we wrap arguments in to indicate that they are passed implicitly we can now proceed to evaluate a term in a context and in an environment which provides bindings for the variables in rec eval ctx tm fn e fn env case e of p env p lam x e x cl e x env app e e let cl e x env eval e env let v eval e env in in eval e x fn var case var of x v p env p when we pattern match on a contextual object e tm we might obtain a variable in which we write as p the item p is a parameter variable for a position in its association with the identity substitution for written turns it from a position into a tm in this case we look it up in the environment a lambda abstraction simply evaluates to a closure we think of the in lam x e x as binding all the free variables of lam x e x we explicitly apply s identity substitution to e in the pattern to indicate that the variables in are permitted to occur in e conversely writing the pattern as lam x e x attempts to the variables of out of e which is not the intention an application evaluates the function position to obtain a body e in the possibly different context with an associated env providing bindings for the variables in we now evaluate the body e in the environment env extended with the appropriate binding for x this implementation is quite close to that of and harper one difference is that contexts appear explicitly in our definition of which is more readable relating contexts closure conversion when implementing a transformation between languages as is common in compilers we often need the resulting terms to be in a different but related context in systems such as pfenning and and the solution is somewhat the programmer states results in a combined context and relies on sophisticated and subsumption mechanisms however by encoding this relation on contexts as an inductive predicate we can express this directly and do away with world subsumption we demonstrate this idea with an implementation of closure conversion and provide a good overview of closure conversion our implementation although we use hoas for our term representations the of closure conversion are not important here we wish primarily to demonstrate how datatypes complement contextual types the source language is the language of section the target language is augmented with constructs for explicit closures shown in part below proj nat close nil create an is an arbitrary length tuple of terms closure conversion will turn contexts into explicit objects such that the bodies of lambda abstractions will only refer to their and no other variables the reason is that we want to be able to them to the top level close constructs an explicit closure which binds all but the last argument proj e n projects out the nth component of the environment e we must now do as we and turn the open bodies of into closed terms which instead project from their environment to characterize the free variables in the open bodies we define the context we from and by performing substitutions instead of which is easy thanks to hoas schema rec n m case of m e s n e m proj e n e we write for the empty context and for a singleton context containing a single variable of type of course if we that contexts be passed explicitly as environments we had better be able to turn contexts into environments rec case of nil let env in env x so far this is more or less standard code the for this example is the recursive relation on contexts datatype ctx we freely omit types where they might reasonably be inferred states only that and are the same length we illustrate more sophisticated relations later the closure conversion function takes terms in a context into target language terms in a related context we only explain the cases for variables and the full implementation can be found in the appendix rec ctx tm fn cr fn m case m of variables are taken to corresponding variables when we learn that is nonempty we learn by cr that so too is the syntax passes the implicit argument explicitly x let cr in x x p let cr cr in let m cr p in x m to closure convert a lambda we closure convert the body in the extended context x using an extended context relation cr we close it and return an explicit closure for simplicity we and do not compute the set of variables in the body we instead close over the entire context lam x m x let m x cr x m x in let m ev m x in let env in close ev m ev env we omit here the case for applications which is straightforward a more sophisticated example of a context relation appears if we wish to express that a transformation is type preserving in typepreserving closure conversion see et al and and there is also a nontrivial relation between source language types and target language types assuming now that we use terms we might wish to use a relation such as the following datatype ctx t s t s logical relations normalization by evaluation implementing normalization proofs or normalization by evaluation in a system such has been difficult to do directly here we demonstrate an implementation of typed normalization by evaluation and in our language which supports both contextual types and indexed datatypes the essence of normalization by evaluation is to object level terms by the evaluation of the computation level there are therefore two levels of terms object language terms using the lf function space and computation level semantic terms using the computation level function space normalization proceeds by interpreting object level terms as semantic terms and the result the source language is tm a standard simplytyped family of terms with lam and app as constructors we have an open type of atomic base types which our implementation is essentially parametric over the target is simplytyped terms in normal long form t norm s norm arr t s arr t s norm t s embed atomic p norm atomic p to characterize the free variable context of the source language we define schema ctx some tm t the context of the target language is described by schema some t semantic terms must be defined as a datatype because we must use the function space type sub t t datatype sem ctx tp syn atomic p sem atomic p slam a b sub sem a sem b sem arr a b the type t t is read as the type of type preserving substitutions of variables in for variables in the need for this will become clear in our implementations of substitution and reification observe that we restrict the embedding of into sem to atomic types this enforces we must manually implement substitution of variables for variables in sem since we do not provide substitution for free for datatypes in fact it is substantially different from lf substitution explains this difference in depth the interesting case is slam it makes essential use of the quantification over substitutions in slam similar mechanisms appear in both and harper and and pottier rec subst s sub sem s sem s fn fn e case e of syn r r slam f slam fn fn s f s rec s sub s s where performs substitution on syntactic neutral terms we show the full code for this example in the appendix embedding into sem is only possible at atomic types so we must expand in the general case rec reflect a a sem a a r case a of atomic p syn r arr t s slam fn fn s let r r in let n t s in reflect s r n we can then semantic terms as object level terms by calling the computation level functions on fresh variables rec a sem a norm a a fn s case a of atomic p let syn r s in embed r arr t s let slam f s in let t e x f weaken reflect t t x in x e x where weaken is the weakening substitution of type ctx sub s we can now implement evaluation with the help of an environment of bindings the lam case evaluates in the extended environment in the application case the evaluation of e must produce an slam since syn is only applicable to atomic types rec eval s t tm t sem t tm s sem s fn r fn fn e case e of p p lam x e x slam fn fn s eval extend subst s x e x app e e let slam f eval e in f id eval e we have used extend to extend the domain of the environment in the lam case its type is shown below rec extend ctx s t tm t sem t sem s t tm s sem t normalization is then simply evaluation followed by reification rec a tm a norm a fn e a eval fn y impossible y e notably this implementation enforces and type preservation by dependent types expressing these invariants together with a clean approach to variable binding in is found in other work and harper and et al lack dependent types and pottier have this ability although their implementation is untyped and hence does not employ it further this illustrates that arbitrary of computation and lf function spaces is not crucial to as suggested by and harper their framework however obtains weakening for free for sem while we have to do a of work to implement it from a logic perspective this can be seen as a partial completeness and consistency proof for a natural deduction system by the method of logical relations we say partial because we the issues of totality checking to future work we that this can be to normalization proofs for the simplytyped lambda calculus without any difficulty the addition of indexed datatypes hence substantial benefit to programming and proof systems such as since it makes such systems capable of proofs by logical relations a review of contextual lf here we describe the index domain which in our case is contextual lf which builds on contextual types which were first introduced in et al b contextual lf contextual lf extends the logical framework lf harper et al with the power of contextual objects m of type a m denotes an object which may refer to the bound variables listed in and has type a in the context see also et al b can be obtained from the context by simply the type annotations and keeping only the declared variable names we characterize only objects in normal form since these are the only meaningful objects in lf furthermore we concentrate here on characterizing welltyped terms but defining kinds and rules for types is straightforward and omitted atomic types p q a m types a b p heads h x c p neutral terms r h r n u normal terms m n r xm substitutions · id m h contexts · xa normal objects may contain ordinary bound variables which are used to represent binders and are bound by abstraction or in a context they may also contain metavariables u and parameter variables p which we call contextual variables contextual variables are associated with a substitution the metavariable u stands for a contextual object r where describes the ordinary bound variables which may occur in r this allows us to rename the free variables occurring in r when necessary the parameter variable p stands for a contextual object r where r must be either an ordinary bound variable from or another parameter variable in the simultaneous substitutions we do not make its domain explicit rather we think of a substitution together with its domain and the ith element in corresponds to the ith declaration in we have two different ways of building a substitution either by using a normal term m or a variable x note that a variable x is only a normal term m if it is of base type however as we push a substitution through a abstraction xm we need to extend with x the resulting substitution x may not be welltyped since x may not be of base type and in fact we do not know its type hence we allow substitutions not only to be extended with normal terms m but also with variables x without loss of generality we require that metavariables have base type a bound variable context contains bound variable declarations in addition to context variables a context may only contain at most one context variable and it must occur at the left this will make it easier to ensure bound variable dependencies are satisfied in the dependently typed setting following we use a bidirectional type system where we check normal terms against a type and synthesize a type for neutral terms lf objects may depend on variables declared in the context and the which contains contextual variables such as metavariables u parameter variables p and context variables we introduce more formally in the next section all typing judgments have access to both contexts and a welltyped signature where we store constants together with their types and kinds m a normal term m checks against type a r a neutral term r type a substitution has domain and range the bidirectional typing rules are mostly straightforward and are presented in figure we will rename bound variables and maintain that contexts and substitutions declare no variable more than once note that substitutions are defined only on ordinary variables x and not contextual variables moreover we require the usual conditions on bound variables for example in the rule for abstraction the bound variable x must be new and cannot already occur in the context this can be always achieved via renaming similarly in we apply renaming as is common we rely on hereditary substitutions written as or b to guarantee that when we substitute a term n which has type a for the variable x in the type b we obtain a type b which is in normal form hereditary substitutions continue to substitute if a redex is created for example when replacing x by y in the object x z we would obtain y z which is not in normal form and hence not a valid term in our grammar hereditary substitutions continue to substitute z for y in c y to obtain c z as a final result for a more detailed description of hereditary substitution we refer the reader to for example et al b finally we remark on equality checking when checking a b we must take into account contraction because we have two neutral terms r a x a p a x a p a c a u p c a u p r m a r m normal terms m a r p p q xa m b r q xm substitutions · · h b b a h xa m a id m xa figure typing for contextual lf ways to build substitutions if x has type then we may have written x or yx y and we lift contextual lf objects to and to treat abstraction over uniformly are either contextual objects written as r or contexts these are the index objects which can be used to index types there are three different p denotes the type of a metavariable u and stands for a general contextual object r a denotes the type of a parameter variable p and it stands for a variable object ie either x or p where is a variable substitution a variable substitution is a special case for general substitutions however unlike p which can produce a general lf object p guarantees we are producing a variable g describes the schema ie type of a context the tag on the type of parameter variables is a simple syntactic device to distinguish between the type of metavariables and parameter variables it does not introduce a subtyping relationship between the type a and the type a the in which an lf object appears uniquely determines if x denotes a metavariable parameter variable or context variable we use the following convention if x denotes a metavariable we usually write u or v if it stands for a we write p and for context variables we use context schemas g g meta objects c r meta types u p a g meta substitutions · cx · xu context schemas consist of different schema elements which are built using intuitively this means a concrete declaration in a context must be an instance of one of the elements specified in the schema for example a context nat bool will check against the schema t t meta terms c u g g g x b b g xb xa g a b xb r p x a r p x a p a a b p b c u ·· cx xu figure typing for the uniform treatment of called c and called u allows us to give a compact definition of and we omit here the rules stating when and are wellformed and show only the typing rules for and in figure a consequence of the uniform treatment of is that the design of the computation language is modular and parameterized over and this has two main advantages first we can in principle easily extend and without the computation language in particular it is straightforward to add substitution variables which were present in or allow for richer context schemas second it will be key to a modular clean design of computations the single written as where stands for a m r is defined inductively on the structure of the given object see for example or the appendix we only discuss briefly here some of the fundamental ideas let us first consider the case where x stands for a metavariable u and c is a r we note that there are no capture issues when we push ru through a and the only interesting issue arises when we an object u in this case we apply ru to to obtain subsequently we apply to r to obtain the final result next we consider the case where x stands for a parameter variable p and c is a x or q the only interesting case is when we p similar to the case for metavariables we apply the to to obtain and subsequently apply to x or q there is however a small since is an arbitrary substitution applying it to x may yield a normal object m hence simply returning m may produce a term which is not meaningful in our grammar the solution to this problem is to define hence we index the with its domain finally the case where x stands for a context variable and c is a there are two interesting cases when we the identity substitution id we and create at the same time a concrete identity substitution which maps all variables from to themselves when we a context variable in a context then we simply replace it with the concrete context the full definition of is given in the appendix and has been previously described in et al b the simultaneous written as is a straightforward extension of the single substitution theorem property if and j then j a language with binding support and recursive types we present in this section a dependently typed programming language along the lines of miniml including recursive types variants and general pattern matching which is critical in practice and whose theory in this setting is nontrivial polymorphism on the other hand is largely orthogonal and therefore the type index objects are drawn from the domain of presented in the previous section but we emphasize that this language is parametric over the index domain requiring only decidable equality types and kinds our type language supports function types written as t t products written as t × t labelled sums written as lt dependent function types written as and dependent product types written as we only allow dependencies on not on arbitrary expressions the novel part in our type language is our definition of recursive types together with the equality constraint which may be associated with a given type the recursive type is written as while z denotes a type variable xt describes a typelevel function which expects kinds k types t unit z t t t × t l t c c t x t t c u context · z k x t we note that we can directly refer to and embed them in our types hence can be directly analyzed and manipulated by our computation language this is convenient in our setting however it also prevents a naive erasure of all the we also note that equalities cannot occur just by themselves in our grammar the reason is that equalities are treated during type checking and equality proofs which establish c c do not our expressions in fact equalities typically occur inside a recursive type and they are trivially true once we have chosen the correct instantiation for the existentially quantified variable we illustrate this idea to illustrate we give here three examples example the type of a vector of booleans which keeps track of their length can be defined as follows we assume an lf signature which declares together with two constants nat and s nat nat because all index objects to the recursive type v are closed we omit writing the empty context and simply write nat for nat and y for vec nil x unit cons y s y bool × vec y example the relation between contexts from section can be written as follows rel · · unit ctx ctx rel our treatment of recursive types with equalities is similar to xi et al and et al where recursive types are with equalities between types to model gadts recently fixed points with equalities between terms have appeared in and in et al for example in our setting we treat equality between contextual objects next we give the rules for types types xu z xu k t k x t xu k t k t t × t t u xu t u xu t c u c u t c c t u u unit z k t c u z k t c computations our language of computations includes recursion written as rec fe functions written as fn xe and dependent functions written as x e we also include pairs written as e e and dependent pairs written as pack c e finally we include labeled variants written as l e and a fold constructor for recursive types expressions i y i e i c e t expressions e i c fn ye x e rec fe unit checked fold e l e pack c e pattern branch e e case i of b pat x c unit fold pat l pat pack c pat pat pat b pat e contexts · yt our language is split into expressions for which we synthesize types and expressions which are checked against a type this the necessary type annotations and provides a syntax directed for a type checker intuitively the expressions which introduce a type are expressions which are checked and expressions which eliminate a type are in the synthesis category we have two different kinds of function applications one for applying functions to an expression and the other to apply a dependent function to a c pairs and dependent pairs are analyzed by pattern matching i t expression i type t yt i c c t y t i t i t t e t i e t i c u e t i c e t t e t expression e checks against type t ei ti where li ti l t f t e t li ei l t rec fe t yt e t xu e t fn ye t t x e e t e t i t t t e e t × t i t c u e c u pack c e c u e e t fold e s c e c c t i s for all i bi s t case i of b t b s t branch b with pattern of s checks against t i i i i pat is i i i e it i i pat i e s t figure typing for computations branches are modelled by pat e where describes the metavariables occurring in the pattern which are often left implicit in the surface language while corresponds to the explicit arguments the refinement substitution describes how the type of the is instantiated so the given branch is applicable example we show next the elaboration of a simple program to compute the tail of a vector and its elaboration rec tail vec s n vec n fn l case l of cons h t t which can be into rec fn l case l of m nat h bool m fold cons pack m h t mn t we insert the length argument to cons which was left implicit in the program and the refinement mn which guarantees that the type of the pattern is compatible with the type of the we also list explicitly the type of the index variable m as well as the type of the arguments h and t typing rules next we give the typing rules for computations in figure we present bidirectional typing rules for computations which will minimize the amount of typing annotations we distinguish between typing of expressions and branches in the typing judgment we will distinguish between the context for contextual variables from our index domain and the context which includes declarations of variables contextual variables will be introduced via abstraction the contextual variables in are also introduced in the branch of a variables in are introduced by recursion or functions and in addition in branches we use the following judgments e t i t b s t expression e checks against type t expression i type t branch b with pattern of type s checks against t the typing rules are given in figure we will rename bound variables and maintain that contexts declare no variable more than once moreover we require the usual conditions on bound variables for example in the rule for abstraction the contextual variable x must be new and cannot already occur in the context this can be always achieved via renaming similarly in the rule for recursion and function abstraction the variable x must be new and cannot already occur in the rules which synthesize and check are mostly standard and we only point out a few rules we have two rules for applications to synthesize the type s of a application i e we synthesize the type for i to be t s and check e against t for the dependent application i c we synthesize the type for i and check that c is a welltyped of type u note that we drop the computation context when we transition to type check a since cannot refer to computations the final type for i c is if we have synthesized a type t together with a trivial equality constraint we simply drop the constraint and return t to check a abstraction against we add xu to the and continue to check that the body of the abstraction has type t to check that a function fn ye has type t t we add the assumption yt to the computation context and continue to check the body e against t for checking a pair e e against the type t × t we check each part of the pair against their respective type for checking a dependent pair pack c e against we check that c is a welltyped of type u switching to the typing rules for the metalevel and the context in addition we check that e has type when we check a contextual c against a type u we simply convert to the type checking rules for and about the context our typing rules will ensure that are pure objects and do not contain any expressions when checking an expression against c c t we can simply drop the constraint c c since it is trivially true we check fold e against the type s c by unrolling the fixed point definition and checking e against the difference to simplytyped recursive types is that dependently typed recursive types are applied to index objects c to illustrate that our data carries enough information to ensure that the equality constraints are trivially true if the term is welltyped we show the typing derivation for cons in figure in the rule for case expressions we first infer the type s of the and then proceed to check that each branch bi has a pattern compatible with s and its body has a type compatible with t to check a branch i i i ei we check that the refinement substitution i provides instantiations from the outer to the current i moreover the pattern has type is ie it is compatible with the type of the and only refers to the local variables i and i we then proceed to check the body ei against it because the pattern may refine the types we must make sure to apply i to the appropriate parts and extend the computation context i with the bindings i introduced in the branch the typing rules for patterns are given in fig they duplicate some of the type checking rules for tuples dependent pairs recursive types and variants we ensure that the computation variables occurring in patterns occur uniquely and we split the computation context in the rule for tuples the on the other hand remains as a consequence contextual variables may occur more than once which is also often necessary to obtain welltyped expressions but we enforce linearity for computation variables occurring in patterns theorem decidability of type checking typechecking expressions is decidable proof the typing judgments are syntaxdirected and therefore clearly decidable bigstep operational semantics next we define the operational semantics for computations in fig we adopt an approach where we do not propagate values recall that we distinguish between metavariables in and program variables in to work with refinement substitutions in branches we hence define two environments denotes the instantiation for metavariables in provides instantiations for program variables in values v f unit fold v l v pack c v v v function values f fn ye x e extended values w v rec fe closures l e environments · wy values are either c unit pairs v v dependent pairs pack c v variants l v fold v or functions as closures since we have and dependent functions we have two corresponding closures closures are of computation inside an environment the environment is represented by the two suspended substitutions and for each of the two contexts and respectively we write e for a closure consisting of the expression e and the suspended and the program environment the intended meaning is that first is applied to e and then ordinary substitution to the result for we show the typing for environments and values in figure we give a bigstep semantics for computations in figure to evaluate a variable y in the environment and we simply look up its binding in the computation environment since contains extended values in particular y may be bound to a recursive function which in itself is not a valid result we continue to evaluate the extended value we from to a proper value when we a c in the environment and we apply to c to compute a closed unit simply evaluates to itself regardless of the environment evaluating a function fn ye in the environment and simply returns the closure fn ye when evaluating a recursive function rec fe in an environment and we evaluate the body e and extend the computation environment binding f to itself evaluating a tuple e e in the environment and is straightforward we evaluate e in the environment and and we proceed similarly to evaluate e the evaluation rules for fold and variants are straightforward unit unit nil nil unit cons y nat s y bool × vec y true bool fold nil vec true fold nil bool × vec nat true fold nil s s bool × vec pack true fold nil y s y bool × vec y cons pack true fold nil nil s unit cons y s y bool × vec y fold cons pack true fold nil vec s figure typing derivation for vector cons true nil fold cons pack true fold nil pat t pattern checks against type t x t c u t s pat t pat t x t c u unit unit fold pat t c pat c c t ti where li ti l t li l t c u pat pack c pat pat t pat t pat pat t × t figure typing rules for patterns e v expression e in environment evaluates to value v i fn ye e v e v i x e e cx v i e v i c v y v y rec fe y v e v e v c c unit unit y v y v e t v fold e fold v e v e rec fe f v l e l v fn ye fn ye x e x e rec fe v e v e v e v i i case i of b v pack c e pack c v e e v v case i of i i pat i ei b v i i i i v i i v pat case i of b v i i i i v i i v pat ei v case i of i i pat i ei b v case i of i i pat i ei b v figure bigstep semantics we have two rules for evaluating applications the first is for a application i e in an environment we first evaluate i in the given environment obtaining a closure fn ye then we evaluate e to a value v and finally proceed to evaluate e in the extended environment where the remains unchanged on the other hand when evaluating a dependent application i c in an environment we evaluate i to a closure x e we now extend the with the binding cx and evaluate e in the extended environment cx where the computation environment remains unchanged the most interesting cases are those for a branch may be if either the type of the and the type of the pattern are not compatible ie the current meta substitution and the refinement substitution in the given branch do not unify or if the types are compatible then the itself may still be incompatible with the pattern of the current branch evaluating a case expression we first evaluate the i in the current environment to some value v next we check that the current is with the of the and given branch this is written as is the result of unifying with i st i and is a substitution which maps contextual variables from i to i unifying the contextual substitutions ensures that the type of the and the type of the pattern are compatible next we check that the pattern is compatible with the v t value v has type t · f t v ti where li ti l t li v l t f t · cu c u unit unit t s v t fold v t c v t · c u v v t v t v c c t pack c v v v t × t l t closure l has type t · e t or e t environment has domain w t · · wy yt et figure value and closure typing value of the before matching the value of the against the the pattern we apply the contextual substitution to the pattern pat and also to the variables listed i which occur in the pattern the result will be a contextual substitution for the i and a substitution for actual pattern variables from i finally the body of the branch ei is evaluated recall that if the overall has type t in a and computation context then ei has type it in a i and computation context i i therefore we will now evaluate ei in the contextual environment and extend the computation environment with the new bindings in we now proceed to prove subject reduction which guarantees that types are preserved during evaluation theorem subject reduction let l t if l v then v t proof structural induction on l v to prove progress we follow cousot and cousot and leroy and and extend our bigstep operational semantics to allow for nonterminating computations in addition to the judgment e v we also allow for computation using the judgment e for example the evaluation rules for products are shown below e e v e e e e e in our operational semantics lemma canonical forms if v t s then v is of the form fn ye if v then v is of the form x e proof by inversion on value typing assuming that patterns cover all cases we finally can state and prove progress theorem if l t and for all values v v then l proof classical by coinduction and case analysis on the typing derivation to canonical forms corollary progress if l t then either l v or l we have mechanized the proofs of the subject reduction and progress theorems presented in section in the coq proof assistant the development is approximately lines of specification and under lines of proof we refer the interested reader to the material for this paper for the coq proofs we do not formalize contextual lf rather the proofs are abstract over the domain of c and u we need only assume that they behave well with and that pattern matching for c is decidable this demonstrates our point that the computation language forms a general core for dependently typed languages parametric over the domain c we use the fresh look approach to binding due to and pottier which is an abstract interface to de indices informally we found that the additional abstraction pushed us towards a more highlevel algebraic approach relying on simultaneous substitutions in place of low level de bruijn a natural question to ask is why we did not choose to formalize the language in a system with builtin support for binding and substitution such as one answer is that is currently the recursive types we propose here we would argue that the computation language is best represented as a recursive type since the syntax contains which are represented as computational functions tm tm which cannot be written in lf in fact we never perform substitutions on computation level expressions hence the lack of substitution for free is related work over the past two programming language researchers have been languagebased approaches to design safe and reliable software our work on and combines two domains programming with binders and programming with indexed types our work follows the of indexed types xi and pfenning where we separate the index domain of types from the this has several known advantages it is easy to allow state exceptions and polymorphism moreover we are not restricted to total functions as in full languages such as coq and or agda however since we can pattern match on index objects we cannot erase them most closely related to our work is the work by chen and xi xi and sarkar the system designed by xi and xi allows programmers to specify formal systems within the logical framework lf and embed lf objects as indices in types see and xi the programmer can then supply her own proofs the equality between two objects when automatic constraint solving in fails however the major challenge when manipulating and traversing lf objects is that we will open lf objects ie lf objects which may contain free variables unfortunately does not provide support for manipulating such open lf objects to support certified programming sarkar proposed which extended an mllike language with lf as an index domain to allow programming with open lf objects he proposes to the dynamic assumptions which arise when traversing a binder and manipulate their explicitly this requires an extension of lf with and unit to model contexts and their dependencies in contrast our work builds on contextual lf and explicitly supports contexts and parameter variables and types for them this allows us to express strong invariants by for example stating that we map variables from a context to variables in another context which seems difficult in approach since there is no guarantee by the underlying type system that we are only storing and manipulating variables in the context et al also suggests to index types with lf objects in a typesafe functional language to support programming with proofs in the presence of unrestricted recursion and imperative features while decidable type checking however their work restricts lf to the firstorder fragment and explicitly abstractions as a consequence encodings based on higherorder abstract syntax are not supported in recent years we have also made substantial advances in programming with binders we build on the idea of contextual types which is central to however so far and similar systems such as and are limited to only manipulating contextual lf objects we take it in this paper one step further of allowing contextual objects and contexts as indices to types recently and harper have proposed a system where one can mix computation functions and binding abstractions this builds on their earlier ideas in et al a prototype based on these ideas is implemented as a library within agda and has been used to for example implement normalization by evaluation structural properties such as weakening or substitution do however not hold in general but they can be implemented while and harper demonstrate that their library within agda supports programming with binders it is less clear whether their prototype will scale to support dependent types and it is also that we do not need to fully mix lf function space with the function space for computations to implement taking a view on programming with binders our work also seems similar to and pottier where the authors describe an agda library to support safe programming with names the fundamental idea is to index terms with a world which names when traversing a binding construct we build up a chain of worlds which is similar to our context however it is whether their work to support dependent types and hence encoding proofs and we hope that the presented work will enable us to further light on the relationship between nominal systems and encodings an interesting application of the presented work is its use as a tactic language for an interactive theorem prover and shao for example propose a language where we write computations about a higherorder logic with inductive definitions at this point only allows direct pattern matching on objects but does not allow in general types to be indexed with objects as a consequence recursive types in cannot be dependently typed our approach of adding inductive types to the computation language is directly applicable to their work and would add additional flexibility to their language our work takes from the work on inductive definitions in proof theory in particular the work by and and more recently et al et al which targets reasoning about higherorder abstract syntax representations our addition of recursive types in gives us effectively the same power as fixpoint definitions in their work to facilitate reasoning about hoas representations and his have extended the logic itself with the quantifier which allows generic quantification contexts must be modelled and about explicitly in contrast our work allows us to remain in firstorder logic by generalizing the term language to allow for contextual and contexts this allows us to our recursive types over contexts and provide explicit support for reasoning about contexts we believe the described work is an important step of understanding the differences and between the approaches based on proof theory on the one hand and the approaches in type theory on the other hand conclusion and future work we presented a typetheoretic foundation for programming with binders and indexed datatypes in particular we have shown how to add indexed recursive types to the language and proven the extension to be type safe we have also mechanized the type safety proof in coq there are however more general we have earlier of by separating from computations this has two important consequence first our computation language becomes modular we can in fact easily replace contextual objects by another decidable index domain second our modular approach the for adding contextual objects to other languages richer than the mllike computation language we used in this paper such as agda in this paper we have on programming with binders and indexed datatypes however frameworks such as are also proof development environments to use the presented language as a core language for a proof assistant we need to guarantee that the implemented functions are total ie all cases are covered and the functions themselves are terminating we believe coverage checking can be solved by extending prior work on coverage checking contextual objects and and pfenning termination checking requires us to identity a suitable notion of acceptable inductive datatypes eg based on strict as in coq and we plan to adapt types as for example in in the future references abadi michael w and gordon d plotkin a calculus for access control in distributed systems acm transaction on programming language systems ­ martin abadi heintze and g a core calculus of dependency in th acm sigplansigact symposium on principles of programming languages popl pages ­ acm press mixed types and strong normalization in shao editor th symposium on programming languages and systems volume of lecture notes in computer science pages ­ springer subtyping for types mathematical structures in computer science ­ special issue on subtyping by goguen and david and focused inductive theorem proving in and editors th international joint conference on automated reasoning lecture notes in artificial intelligence pages ­ springer and an inverse of the evaluation functional for typed lambdacalculus in logic in computer science pages ­ and interactive theorem proving and program development the calculus of inductive constructions springer chen and xi combining programming with theorem proving in danvy and benjamin c pierce editors th international conference on functional programming pages ­ cousot and cousot inductive definitions semantics and abstract interpretations in th acm sigplansigact symposium on principles of programming languages popl pages ­ acm and xi combining higherorder abstract syntax with firstorder abstract syntax in in editor workshop on mechanized reasoning about languages with variable binding pages ­ acm and case analysis of higherorder data in international workshop on logical frameworks and theory and practice volume of electronic notes in theoretical computer science pages ­ june andrew and combining generic judgments with recursive definitions in f pfenning editor rd symposium on logic in computer science ieee computer society press d and f pfenning noninterference in constructive logic in proceedings of the th ieee computer security foundations workshop ieee computer society press and a typepreserving closure conversion in haskell in proceedings of the acm sigplan workshop on haskell haskell pages ­ robert harper and daniel r metatheory in a logical framework journal of functional programming ­ robert harper and gordon plotkin a framework for defining logics journal of the acm ­ january leroy and coinductive bigstep operational semantics information and computation pages ­ daniel r dependently typed programming with domainspecific logics phd thesis carnegie mellon university daniel r and robert harper a universe of binding and computation in graham and andrew p editors th acm sigplan international conference on functional programming pages ­ acm press daniel r and robert harper focusing on binding and computation in f pfenning editor rd symposium on logic in computer science pages ­ ieee computer society press c and a reasoning with higherorder abstract syntax in a logical framework acm transactions on computational logic ­ greg morrisett and robert harper typed closure conversion in in acm symposium on principles of programming languages pages ­ acm press and a modal foundation for secure information flow in a sabelfeld editor workshop on foundations of computer security pages ­ j morrisett and birkedal hoare type theory polymorphism and separation journal of functional programming ­ a frank pfenning and contextual modal type theory acm transactions on computational logic ­ b towards a practical programming language based on dependent type theory phd thesis department of computer science and engineering university of technology september technical report d inductive definitions in the system coq rules and properties in and jan editors international conference on typed lambda calculi and volume of lecture notes in computer science pages ­ springer frank pfenning and system description a framework for deductive systems in h editor th international conference on automated deduction volume of lecture notes in artificial intelligence pages ­ springer a typetheoretic foundation for programming with higherorder abstract syntax and firstclass substitutions in th annual acm sigplansigact symposium on principles of programming languages popl pages ­ acm press programming proofs a novel approach based on contextual types submitted and a framework for programming and reasoning with deductive systems system description in and editors th international joint conference on automated reasoning lecture notes in artificial intelligence pages ­ springerverlag and system description a functional programming language for deductive systems in international workshop on logical frameworks and theory and practice volume of electronic notes in theoretical computer science pages ­ b and practical programming with higherorder encodings and dependent types in th european symposium on programming esop volume pages ­ springer pottier static name control for in nd ieee symposium on logic in computer science lics pages ­ ieee computer society july and pottier a fresh look at programming with names and binders in th acm sigplan international conference on functional programming icfp pages ­ sarkar a dependently typed programming language with applications to foundational certified code systems phd thesis carnegie mellon university and frank pfenning a coverage checking algorithm for lf in d and b editors proceedings of the th international conference on theorem proving in higher order logics pages ­ springer tim languages of the future sigplan notices ­ mark r andrew m pitts and j programming with binders made simple in th international conference on functional programming icfp pages ­ acm press and shao typed computation of logical terms inside a language with effects in paul hudak and weirich editors th acm sigplan international conference on functional programming icfp pages ­ acm martin m t simon peyton jones and system f with type equality coercions in acm sigplan international workshop on types in languages design and implementation pages ­ acm e a and i a languagebased approach to correct imperative programming in danvy and benjamin c pierce editors th international conference on functional programming icfp pages ­ acm xi applied type system in types volume of lecture notes in computer science pages ­ springer xi and frank pfenning dependent types in practical programming in th acm sigplansigact symposium on principles of programming languages popl pages ­ acm press xi chen and chen guarded recursive datatype constructors in th acm sigplansigact symposium on principles of programming languages popl pages ­ acm press indexed types theoretical computer science ­ 