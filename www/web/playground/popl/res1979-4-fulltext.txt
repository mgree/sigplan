principles of programs in i good richard m james institute project for computing science and computer applications the university of texas at austin austin texas abstract concurrency in is based unique formal approach to specifying and proving systems of processes the specification and proof methods so that proofs of individual processes are totally independent even when operating concurrently these methods can be applied both to terminating and nonterminating methods are well processes suited and the proof to automated verification aid the basic principles of these methods and their interaction with the design of are described keywords proving formal program verification concurrency specifications parallel message program programs buffers cr categories o introduction the primary objective of is to provide an effective developing operational practical software language systems for substantial size that are formally verified lines this goal has been by developing good from pascal in parallel with an integrated set of formal specification and verification methods both programs and their formal specifications are expressed directly in and methods for specifying implementing and verifying systems of concurrent processes have been a major part of this development has been used successfully in two major experimental applications involving significant amounts of concurrency describes a complete message switching network of concurrent processes involving a total of approximately lines of specifications and of code horn gives a line specification of a system of processes that will be used in conjunction with the systems verified in both involving these concurrency all parts of the were formally have strongly to high quality system design methods for specifying implementing and verifying systems of concurrent processes in have several important objectives that are necessary for verifying real systems a general method for specifying systems of concurrent processes has been developed such formal specifications are an absolute for formal verification systems of concurrent processes can be refined into well defined so that the proofs of the system and each of its are mutually independent this mechanism for operational abstraction is necessary for the proof of a large system into tractable nonterminating processes can be formally specified nonterminating processes and proved commonly occur in real systems effective algorithms for mechanically constructing all of the necessary verification conditions have been defined automatic verification condition generation is a practical for all except very small programs the first advances processes three toward are significant proving systems of concurrent the methods in characteristics used to these objectives have several process coordination is done strictly through message buffers formal specifications are stated terms of buffer transaction histories in buffer operation restrictions are used to simplify the specifications and proofs the cobegin statement that supports concurrent execution is highly and well structured the following sections describe the basic principles of proving systems of concurrent processes in major concepts are introduced one at a time we first describe the formal specification methods for concurrent processes and then define the independence that has been maintained between specifications and implementations of routines throughout to provide independent of routines we then describe proof methods for the various program statements involving message buffers and concurrency next we turn our attention to the special problem of specifying and proving nonterminating processes finally these methods are compared with other related work specifications has the of a programming language with embedded formal specification facilities these specification facilities are incorporated into the language so that they provide the necessary bases for program proofs and so that can be used strictly as a formal specification language if desired we shall not attempt to provide a complete description of the specification language but rather we shall concentrate primarily on specifications for routines procedures and functions because of their direct relation to concurrency external and internal specifications the specifications either external specifications are callers of the routine for a routine may be or internal external potentially visible to internal ones are not external specification of routines consist of two parts a required interface specification and an optional functional specification the interface specification defines the interface between the routine and its caller it consists of the routine header which defines the name of the routine and its formal parameters the only nonlocal data objects to which a routine may refer are formal parameters and globally defined therefore the formal parameter list gives a complete description of the interface between the routine and its calling environment functional are stated as entry and exit assertions that are interpreted as weak pre and postconditions for the routine essentially functional boolean expressions that global constants or formal interface specification specifications may refer parameters only in are to the for example the external specifications of a simple procedure that moves objects from one sequence to another might be written as procedure begin exit end rs r s type const type object object the interface specification of procedure is the header which precedes the sign and the functional specification is defined by the exit specification the precondition true is assumed if no explicit entry specification is given note in unit declarations procedures functions types constants may be given in any order internal specifications are specifications describing the internal operation of a routine the most common form is the assert specification typically used in inductive assertion proofs because these specifications may refer to local variables and therefore might reveal information about a particular implementation of a routine does not permit them to be visible outside the routine in which they appear this is consistent with the conventional use of inductive assertions message buffers message buffers are the process coordination mechanism used in the address space of each active process in a program is disjoint from the address space of every other active communication is process all via message buffers buffers may be declared locally or passed as parameters any number of procedures may share access to a buffer created in a common ancestor and passed downward in the calling structure via parameter a process can communicate with another concurrently active process only through a common buffer passed as an actual parameter when the processes were created buffers and closely are a those a typical buffer structure in defined in declaration is type object buffers are strictly queues upon which send and receive operations are mutually in time a buffer may be declared to have a maximal number of elements as was done with in the preceding example if a routine attempts to send to receive from a full empty buffer is blocked until some element is received sent to the buffer it from buffer histories since all process communication must be done via message buffers the complete history of process interactions can be analyzed by examining the histories of message traffic among processes every buffer b has two history sequences is a time local input history that records the sequence of all objects received from buffer b by a procedure activation a similarly is a time local output history that records all objects sent to buffer b by procedure activation a a history for a buffer of type as defined above is an object of type sequence of transaction type transaction record message object time integer whenever an object x is received from sent to a buffer b by procedure activation a a new transaction is recorded on the history the transaction that is recorded has x as its message field and t as its time field where t is the time at which a acquires mutually exclusive access to b note that successive time stamps on a given history must be strictly increasing because each individual procedure activation performs buffer operations strictly in sequence these time local histories are the basis for defining several other important histories and functions on buffers the local histories are defined implicitly by for all elements in the histories the histories record all messages in the same order as the histories but time stamps are not included if a buffer can be referred to by a procedure the buffer must be either a formal parameter variable or a local b is declared variable if buffer local to a procedure p then a new buffer is created for activation of p every procedure has an implicit formal parameter of type which names each distinct activation of the procedure because b is local to p only the activation of f and routines called by p can manipulate b therefore all transactions on b are recorded on the local histories with respect to procedure p therefore we define and global histories for b as records all receiving sending transactions on b by procedure p and any routines by p note that successive histories also will time stamps on the global be strictly increasing because only mutually exclusive access is provided for b the sequence of objects in a buffer b is denoted defined implicitly by currently by and is notation is sequence append is the sequence of objects sent to but not yet received from b the or of a buffer is defined in terms of its content iff size iff size uo n where n is the declared maximal requires n so that size of b not and for all buffers b the buffers used to communicate procedures running concurrently must be as parameters to those procedures functional external specifications for procedures normally describe the effect activation of that procedure on the histories of its buffer parameters example a procedure that moves n objects sequence to a buffer can be specified as among passed the these of an local for from a procedure begin entry exit end b s n integer n in and sizes u n ge n type sequence of object notation is the set of integers from o to is the implicit const parameter of type is subsequence the elements of all sequences are beginning with one the exit specification states that what is sent to b by procedure get is exactly the sequence sn it says nothing about what other concurrently operating procedures might be sending to b these other objects are not recorded on the local history of get they are however recorded on the global history nor does the exit specification say anything get about what may be received from b by should we want to show that nothing is received from sent to a buffer we may state this in the exit specification for example we could extend the exit specification of get to say exit and z notation is an empty sequence whose type is this approach received from to stating sent to that nothing was a buffer quickly becomes in both specification and proof it requires extra statements in the specifications and these extra statements to eliminate require extra steps in the proofs these extra steps allows the programmer restrictions declared or to declare on buffers a buffer as an input buffer upon operation may be which send operations are not allowed or as an buffer upon which receive operations are not allowed consider the following specification for a get and a companion put procedure procedure b output s n integer begin entry n in and size s ge n exit sl end n procedure var r b input n integer begin entry exit and end n in r n buffer b in get is output restricted no object may be received from it this implies that is empty upon exit similarly in put is empty by of the input restriction using operation restrictions eliminates a significant number of lines of these restrictions are designed to be checked statically a routine may not use an input output buffer the parameter in a send receive operation rules of require a formal parameter to be at least as restricted as its corresponding actual an unrestricted actual may correspond to a restricted formal but not vice versa this information can be used effectively to construct verification conditions in a than would otherwise be possible independence principle the independence had a major influence principle for routines has on the design of the proof of a routine may only depend upon its own specifications and implementation and upon the e specifications of the routines to which it refers this principle is the basis upon which the proof of a program can be decomposed into every routine can be proved independently this principle is of every other routine not new it has been generally to in previous developments of proof methods for sequential programs such as the pascal procedure call rule however it is important to recognize this principle as one of the keys to proving complex programs it is necessary to break a large program into pieces small enough and sufficiently simple to permit construction and of the individual proofs from a large program we can expect a large number of small pieces if the proofs of n pieces are completely each with all of the others we have nn possible for all but independence interactions the smallest principle this is values of n the that the implementation of one routine cannot interfere with the proof of any other routine because concurrent systems are usually more complex than sequential systems the use of the independence principle is even more important in concurrent systems methods for concurrent we know of no other proof systems that to this principle as the following sections will show this been to in developing the mechanisms for specifying implementing concurrent programs in and two major factors in this design are the local histories and the statement programs a procedure is implemented by a sequence of statements that refer to its formal parameters and local data objects the send and receive statements manipulate buffers directly buffers may also be manipulated as actual parameters in procedure calls the proof methods for these described in terms of the local histories the fundamental characteristic of buffer parameters is that each reference to a particular buffer has a potentially different value because the buffer may be manipulated by external processes since these external are not recorded on the local histories histories routine complete descriptions can be made independently of the local for each we will begin with the most fundamental concepts then introduce one new concept at a time these concepts are illustrated by an set of examples leading to a conventional system up send and receive statements send statements objects to a buffer receive statements objects from a buffer both statements also append the object to the appropriate local history the send statement send x to b is semantically statement equivalent to the assignment time t message x notation the expression denotes the sequence s extended the element e at the end s e by adding the corresponding notation is used to denote buffer transaction the similarly the receive statement receive m from b is semantically equivalent to m mi time t message m where m denotes some arbitrary same type as m informally element of value of the m is the first when a procedure attempts a send operation it first tests whether the buffer is full if it is full the procedure blocks until some other buffer process performs a receive from similarly a procedure the a receive operation on an empty buffer is blocked until some other process performs a send to that buffer below is a full definition get introduced in section of the procedure procedure begin entry exit b s n integer n in and sizes n ge n var k int o loop assert and k in n if k n then leave k ki send sk to b end end end notation in end statement the innermost statement all compound statements with the key word a causes control to leave loop containing the leave the proof loop is statement induction assertion rule for the send statement within the that of the equivalent assignment defining the new local history the theorem that results from the loop is and k in u ki the theorem says in essence that equal sequences each extended by the same element remain equal the procedure exit specification follows directly from the loop assertion note that the specifications and proof rely only upon the history of local buffer transactions sequential procedure call the procedure call allows operational abstraction a code segment is in a routine definition with its effects on its parameters described by its external specifications within a procedure the effect of any send or receive operation on a buffer parameter ie a nonlocal buffer is recorded on the local buffer histories for that procedure the semantics of the sequential procedure call in would be similar to the procedure call in pascal if we global variables there is an additional rule that describes how the local buffer histories of the called procedure relate to the local histories in the calling procedure suppose procedure p issues a procedure where b is an actual buffer call is equivalent to with call q parameter this qb q where and are fresh uniquely named temporary variables and q is a unique that is the actual parameter corresponds to the implicit formal parameter of procedure q the effect of the procedure call is that local histories of the called procedure are to the corresponding local histories of the calling procedure as an example of the use of this rule us write procedures a simple object mover using get and put of section let the procedure begin entry exit r s sizes r s le var b get put end the procedure contains nc send or receive statements it invokes procedure get which copies the sequence s to the buffer b and then invokes procedure put which copies the contents of buffer b into sequence r this action is described in external specifications of get and put the procedure call rule requires us to verify the procedure entry specifications and then allows us to assume the procedure exit specifications thus for procedure get we must verify that sizes in and size s ge sizes which follows directly from the entry condition for procedure the entry condition for procedure put follows from the entry of similarly we can rewrite the body of as the semantically equivalent form put because b is output restricted in get the history is null reducing the second input history assignment to similarly procedure because b is put we get input restricted in further since all local histories are initially null before a procedure has execution and are both null histories we now get the verification condition hi sizes le h h u h s h r h sizes cl rs hypothesis hi h histories local are the exit get and put is the entry condition of and h describe the buffer to h h and h specifications from procedures outline h and h describe histories but equality of histories implies equality histories since buffer b is we can use the global history the time the time of the local to axiom to show the h h and operator we conclude is null by equalities properties of the append that r s qed concurrent procedure calls the cobegin statement is a strict generalization of the sequential procedure call that may create several procedure which run concurrently the only statements that may appear within a cobegin are sequential procedure calls thus cobegin qi b qn b end is equivalent to ql b qn b where ql qn the function merges time histories according to their time stamps each merge is done on the same buffer b each time stamp on each history in the merge is unique because of mutual exclusion and therefore the merge function is deterministic as in the sequential procedure call the effect of a cobegin is to append a new or to the local history the new history is a time deterministic merge of histories produced by each of the called procedures the property function also has the h where type sequence of transaction and h is a time history thus if a cobegin calls only a single procedure say q we get and and the effect of the cobegin sequential call of q is identical to a does not allow aliasing in procedure calls no actual var parameter in a procedure call may name an object that contains or is part of another actual parameter in the same procedure call this rule applies to concurrent cobegin procedure calls as well in a the requirement is that no actual var parameter overlap any of the other actual parameters of of the procedure calls under the cobegin this together with the fact that operations on buffer var parameters are exclusive in time allows procedures with var parameters to execute concurrently without interference we can rewrite procedure using a concurrent procedure call procedure begin entry sizes le exit r u s var b r s cobegin end end changing concurrent assignment the sequential procedure procedure calls calls changes to the to the change only affects how the two are merged in the sequential case we know that all buffer transactions in get those in put and so the reduces to the append function the vc for is directly analogous to that for with the function substituted for the append operator the proof remains basically the same instead of using the reduction we use t nontermination both the traditional weak and strong interpretation of entry and exit specifications are for nonterminating processes because a weak exit is to hold a process terminates and a strong exit requires that the process w terminate specifications for nonterminating processes that have buffer parameters can be stated in with a block specification the block specification must hold whenever a process is fully blocked access to a buffer this point in effect defines a temporary halting point the block specification is interpreted in a weak sense it must hold h the process is blocked potential points in a procedure are sends receives sequential and concurrent procedure calls and await statements send and receive statements are defined as calls to send and receive procedures these procedures have specifications that their buffer parameter is full or empty respectively thus the potential points are basically procedure calls a procedure call is blocked is all of its procedure are blocked ultimately a procedure may block only because it invokes perhaps indirectly the send or receive procedures thus only procedure calls passing buffer parameters may potentially block the await statement is a buffer mechanism it is a nondeterministic case statement with send and receive operations as guards for the cases the await is blocked if all of the buffer operations are blocked if the await is not blocked it behaves as a nondeterministic case statement selecting between those cases whose guards are not blocked thus the await blocks as multiple sends and receives would and executes as a single send or receive the procedure specification must be proven at each potential point it must be provable from the information available from the internal program assertions in the normal inductive assertion technique together with any knowledge we may gain about the for example blocking at a receive statement implies that the buffer is empty due to the block specification of receive under a sequential procedure call we know the single procedure activation created has blocked and so may assume that procedures block specification at a concurrent procedure call however procedure is more at least one of the must be blocked but the rest may either be blocked or have already terminated to express this we define a predicate procedure which is true if the activation a is blocked thus if a procedure is blocked at the cobegin statement cobegin ql end then we deduce that if and then else fi and if then and else or fi or where ql qn are the corresponding to the procedure under the cobegin and and represent the and exit specifications respectively for procedure qi at the point the local histories are updated as they are after a procedure call intuitively the local histories are extended by whatever transactions were performed by the called procedures before thus the updated local histories will usually appear in the conclusion of a vc we can rewrite once again this time as system of two nonterminating concurrent processes a producer and a consumer procedure bin begin var block not and exit false explicitly assert nontermination var b cobegin end end procedure transfer var x var y begin block not full y empty x and exit false explicitly assert nontermination var m object loop assert u receive m from x send m to y end end verification of procedure requires proof of two verification conditions one corresponding to termination of the cobegin the other corresponding to at the cobegin the termination vc for this example is false false which is trivially true the vc for is hi if then not and u else false fi h if then not and else false fi h or h tl h cl not and where t and t are corresponding to the two of transfer hypotheses h and h are the instantiated block and exit specification of tl and t hypothesis h states that at least one of the two processes is blocked and not yet terminated hypotheses h and h describe how the histories in tl and t merge to form the histories of b in the conclusion is the block specification for with tl substituted for and t substituted for these substitutions are required because of the new values assigned to the buffer histories after the cobegin outline cases depending predicates which a procedure terminated ie because hypothesis the proof breaks into three on the h truth values of the the two cases in activation is assumed to have is not blocked are trivial hi or h reduces to false the remaining case assumes both of transfer are blocked thus we can immediately reduce hi and h to simple implications we can also eliminate the references to in h and h because merging with a null history is an identity function the vc is of the form p q r which can be rewritten as p and q r thus becomes a new hypothesis using this new hypothesis and the reduced h we can apply to deduce and by the not to deduce axioms of buffers thus we can use on hi and the vc now has the form hi h u h hb h h h not cl c conclusion be proven cl matches hl so only c remains using h and h we reduce c to to c hypotheses h and h imply u and from we can deduce that null and using the definition obtain transitivity of equality qed is of content c follows by related work the cobegin is a generalization sequential call statement of the it invokes several procedures concurrently and schedules these fairly nondeterministically only procedures can be invoked and by a cobegin and a cobegin of just one procedure is exactly call equivalent procedures to a sequential and also functions procedure in may not refer to nonlocal variables hence al variables that are used to communicate between procedures must appear explicitly as parameters buffers are the only variables that may be actual var parameters to several procedures operating concurrently the cobegin structure is the basis for systems into independently this decomposition is possible even in the presence of distributed processing the similarity of the cobegin to a procedure call is in direct contrast to concurrent pascal and modula in these languages processes are initialized and then run forever restricting the cobegin only to call procedures also is substantially different from which allows arbitrary statement lists as the of a cobegin the await statement is similar to the guarded command of dijkstra where the guards are buffer operation statements send receive and the commands are arbitrary statement lists the await until it can select nondeterministically some guard that is not blocked does the buffer operations and the statement list then exits the await process coordination in is done strictly by means of message buffers as opposed to dijkstra monitors hoare or conditional critical regions the buffers are strictly fifo queues upon which send and receive operations are in time similar synchronization mechanisms have been used in the rc operating system and but as far as we know message buffers have not been used previously as a basis for specification and proof the message types with buffers are axiomatic properties this is in direct contrast to the monitors of hoare and conditional critical regions as well as the of in which axiomatic properties of each shared object must be specified and proved transaction histories have most approaches to specifying been used in and proving properties of systems of concurrent processes and shared objects approaches however hoare these have used the of variables to record transaction histories in an m way in the histories and the ways in which buffer transactions are recorded are by the language and the semantics of the buffer operation statements are defined in terms of these histories an important of is the distinction and unique aspect between global and local histories global histories record all transactions on a given buffer the local histories record the effects of a given procedure activation on a given buffer this is the basis for the effects of a procedure so that it can be specified and proved independently of all other procedures the time buffer histories being used as a basis for formal specifications of realtime constraints specifications for procedures that manipulate buffers can be stated in terms of entry and exit assertions about the local buffer histories the technique for nonterminating processes assertions is similar to of manna the a block specification can be stated that is to hold u a procedure is blocked its mutually exclusive access to a buffer the block specifications also can be verified independently for each procedure operation restrictions may be declared on a buffer a buffer may be declared to be used strictly for input or for output these restrictions are in the spirit of jones and are enforced statically these restrictions reduce the size of specifications and their static enforcement significantly simplifies proofs the proofs are done by an extension of the inductive assertion method assertions may refer to transaction buffers histories and their verification respective conditions are constructed each procedure and proved independently all consideration of for the interactions of procedures running concurrently is isolated to the verification conditions for the cobegin it is never necessary to consider simultaneously concurrently processes running as in or to prove noninterference as in summary this principles paper has for specifying described the basic and proving systems of concurrent processes in including methods for both terminating and nonterminating processes these methods are based on message buffers for process coordination and a cobegin statement that is a generalization of a sequential procedure call proofs of concurrent processes are independent in that the implementation of one process cannot affect the proof of another the language has advanced aspects of concurrency several more that have not been described these include structures eg arrays of buffers and the ability to arrays of procedure within a cobegin the basic principles described here however can be extended to cover these more complicated systems such advanced facilities have proven successful in the applications listed in the introduction acknowledgements the mechanisms for specifying programming and verifying systems of concurrent processes in have been developed over a period we the significant contributions made during this period by allen l john h robert w michael k smith g and james c e at per per purpose of concurrent proceedings pascal conference in m rm specifications for realtime systems in texas conference on computing systems october dijkstra sequential languages ew dijkstra processes academic press in programming dijkstra dijkstra commands and derivation of programs cacm formal good di good cg lw df on the language version project the university of texas at austin may an of communicating march in hoare car hoare operating system structuring concept october an in horn r horn secure computer communications the university of texas austin a j correct in monitors k manual a and n springer pascal jones ak language constraints may and br on data access cacm manna z manna and r sometimes better than february always cacm ss techniques for parallel thesis cornell university august axiomatic programs proof phd ny axiomatic programs ss d proof technique acts informatica for parallel vol re implementation communications the university december of system of specification and a thesis texas at austin n modula modular a language for in software practice vol wa r c of the operating system in proceedings of the fifth on principles 