reasoning about programs by richard j karl n stanford research institute park california problems of attack prove their worth by back abstract this paper describes a theorem that knowledge about programming constructs such as numbers arrays lists and expressions the program can reason about these concepts and is used as part of a program verification system that uses the of program seman tics it is implemented in the qa language the qa system allows many bits of knowledge each expressed as a small program to be so that a program stands forward when it is relevant to the problem at hand the language al clear concise representation of this sort of knowledge the qa system also has special for dealing with commutative functions or relations and equivalence relations these features are used in this deductive system the program the user and his ad vice in the course of a proof have been found for find program a division algorithm and some sort programs as well as for many simpler algorithms additional have been proved about a pattern and a version of unification algorithm i introduction and background this paper describes a computer program that proves theorems about programs proving theorems about programs is of practical importance because it helps that they are correct instead of testing a program on test cases which may allow some bugs to remain we can try to prove that it behaves as we expect we hope future systems that reason about programs and understand how they work will help us to write and change pro grams many programs james t have done this sort developed a program of reasoning verifier that could prove theorems about programs his pro gram proved an interesting class of theorems and was very fast peter has recently written a system for interactive program writing that can also prove things about programs it is perhaps not as fast as system but it can prove more interesting theorems s r d have recently ap a resolution theorem prover to program cation and their results are also they can verify such programs as find their system does little actual resolution and a lot of simplification and reasoning about equality a program by and moore can prove difficult theorems about lisp pro grams thus there is no of interesting work related to our own the special characteristic of our own system is that it is concise read able and easy to change and apply to new subject areas our deductive system is one part of a program verifier the other part of the program verifier constructs theorems called verification conditions the deductive system proves them the verification condition generator et al is written in et al and the tive system is written in qa et al this paper focuses on the deductive system but gives examples of verification condition generation as well in writing our deductive system we were by several goals first the system should be able to find proofs it should have enough tive power to prove within a time and space the theorems being considered also these proofs should be at the level of an informal in a mathematical this means that the difficulty in following one line to the next in any proof should be small enough that the the research and in part t references reported was supported in part by the national by the advanced research projects under contract are listed at the end of the paper science foundation under grant gj proof is yet large enough not to be trivial furthermore the strategies the system uses in searching for a proof should be strategies that we find natural not only should the tactics that eventually lead to the proof be ones we might use in proving the statement by hand but also the false starts the system makes should be ones we might make ourselves we do not want the system to rely on search the trace of an so should make interesting reading in addition to the requirement that proofs be readable the rules the system uses in going from one line to the next should be easy to read and un we should be able to look at a rule and see what it does also it should be easy to change old rules and add new rules the user of a program verifier is likely to introduce new con we want to be able to tell the deductive system how these structures behave and to have the system reason effectively about new symbols gi v ing the system new information should be possible without knowing how the system works and certainly without the system furthermore the addition of new information should not the performance of the system the system is intended to with use as we apply the system to new problems we are forced to give the system new information and perhaps to generalize some old information these changes are incorporated into the system which may then be ter able to solve new problems since the system is easy to extend and we do not about the completeness or generality of any particular version of the system it is powerful enough to solve the class of prob on which it has been and it can be easily changed when necessary these considerations a part in the de sign of the programming system called qa as well as in the construction of our deductive system which is written in the qa language some of the techniques described below are embedded in the fa system itself others are expressed as parts of the deductive system ii a sample program that finds largest element of an array before we explain how the system is structured or implemented let us first look at a sample of some performed by our system this ex will give a better idea of the subject domain of the inference system and of the sort of reason ing we have to do it will also give a better ture of the process of generating a verification condition suppose we are given the annotated shown in figure to compute the largest an array and its location program element in on max aa io max all al max max i c i no i max e yes loc i max max max a max ai loc f ta figure finding the maximum of an array this program searches through the array keeping track of the largest element it has seen so far and the location of this element the intermediate as at c says that max is the largest element in the array between o and i and that loc is the in for max although our language does not permit the notation we have introduced some suitable which are discussed later to prove assertions about a complex program the system it into simple paths this program can be decomposed into four simple paths the path from b to c the path from c to d the path from c around the loop and back to c through point e the path from c around the loop and to c through point f notice that the author of this program has put assertions not only at the start and halt nodes of the program but also at the intermediate point c he has done this so that the paths can be verified in the same way that a simple pro gram is for instance the path that begins at c around the loop through e and returns to c can he regarded as a simple pro gram with the assertion at c as both its start as and its halt assertion lhe assertion at c has been chosen to be true when the loop is entered to remain true whenever control around the loop and returns to c and to be strong enough to allow the assertion at d to be proved when control leaves the loop and the program halts the choice of suitable internal assertions can be an task some tic methods have been proposed that will work in this and many other examples et al and manna if all the paths of the program are shown to be correctly described by the given as and if the program can be shown to termi this must be done separately then we can conclude that the program is indeed correct at least with respect to the programmers final tion although there of a program are easy to verify two of the paths are many typically for this paths in the of the paths program we examine suppose we want to demonstrate that if the assertion at point c is true when control passes through c then the assertion at c will still be true if control passes around the loop and returns again to c we will restrict our attention to the case in which the test max is true in this case control passes through e further more we will try to prove only that the second con of the assertion at c remains true our condition generator gives us the following statement to prove max a max i n a max this these statement hypotheses hypotheses is actually and a goal represented as to be five from the behavior problem is typical the goal is of the of its broken deductive approach into two system in this to many problems a and the second is immediately seen to be true the first is derived from and easily now let us look at the path from c to d we will assume the assertion at c is true and will prove the assertion at d we will look at the first conjunct of the assertion at d our verification condition generator gives us the following statement to prove max a a lo ni max a the reasoning required for this proof is a little more subtle and less typical than the previous tion when the system that n it immediately concludes that nl s since n and i are integers it further that n s since it already knows that i n it concludes that ni the goal it reduces to proving is that i n which it now knows this deduction is because it involves a lot of reasoning forward from assumptions and not much reasoning backward from goals however both of these proofs are typical of the behavior of the system at large because of their strong use of the properties of equality and the ordering relations the qa system enough of the com techniques of theorem proving and problem ing that our inference system needs no general knowledge but only some knowledge about numbers arrays and other structures the following sections show how the qa language allows that knowledge to be represented iii the qa language a pattern matching and the goal mechanism the functions one fact deductive system is or programs each and the use for that made up of these fact of many small programs knows the qa programming language is designed so that all programs can be when a problem to the system the functions that are to the problem stand forward these is a program has the form lambda part of the knowledge of what the program can be used for is expressed in the pattern when a func tion is applied to an argument the pattern is matched against that argument the vari ables in the pattern are bound to the appropriate subexpressions of the argument and the body of the program is evaluated with respect to those new bind for example the program lambda tuple x y tuple y x has pattern x y and body tuple y x the prefix means that the variable is to be given a new binding the prefix means that the variables old binding is to be used when is applied to tuple a b the pattern tuple x y is matched against tuple a b the variable x is bound to a and the variable y is bound to b the body tuple y x is evaluated with respect to these bindings giving tuple b a on the other hand if a function is applied to an argument and the pattern of that function does not match the argument a condition known as fail occurs at many points in the execution of a program the system makes an arbitrary choice be alternatives failure a up to the most recent choice and the choice of another alternative the of patterns is only one of the ways in which failure can occur in a pro gram we have yet to explain how a program stands for when it is relevant in the above example the function was called by name much as it is in a con programming language but it is also pos to make an argument available to any ble program in a specified class this is done by means of the goal mechanism when we say we assume that the goal class is a tuple of names of functions we are making that argument available to the entire class of functions the pattern of each of those functions is matched in turn against the argument if the match is successful the function is applied to that argument if the function re turns a value that value is returned as the value of the goal statement on the other hand if a failure occurs in evaluating the function back tracking occurs the next function in the goal class is tried and the process is repeated if none of the functions goal statement in the goal fails class succeed the entire for example in our deductive system one of the goal classes is called the rules used for proving equalities one of these rules is lambda eq w times x y goal eq times y x z this rule should try pat states that to prove to prove xz w xy z we the rule has the eq w times x y z if we execute goal eq a times ie we want to prove a bc d the system will try all the until it comes to it will find that the pattern of matches this argument binding w to a d then it will evaluate the body of this function ie it will try goal eq times c b d if it fails to prove eq times a c times b d it will try to apply the remaining to the original argument eq a times b d d the goal statement is an example of the pattern directed function invocation by in the net effect of this mechanism is that it en ables the user to write his programs in terms of what he wants done without to specify how he wants to do it furthermore at any point he can add new rules to or any other goal class thus increasing the power of the system with little effort b some sample rules the deductive system is a collection represented as small programs one rule in the preceding section two more rules here of rules was given are pre the first rule is lambda eq x y prog declare x x goal eq x y this rule says that to prove a and b are equal sim a and then prove that the simplified a is equal to b this rule a member of has the pattern eq x y the name of the will fail if its argument cannot be simplified in that case will also fail can ac simplify the right side of an equality as well as the left as explained in the next section the second rule is lambda f x y goal f x plus y z this rule says that to prove xy s z try to prove x yz it belongs to the goal class inequalities and is thus used not only for the predicate but also for lt gt and the variable f is bound to the appropriate predicate symbol c the goal mechanism is used for reasoning back from a goal however sometimes we want to son forward from an assertion for example suppose that whenever an assertion of the form x y is made we want to assert y g x as well we do this by a qa mechanism known as the a is to be a spirit that its a hiding place waiting until some specified event occurs at which time it appears performs some action and again we have put in the system each for a condition the we use above for assertions of the form x z y and makes the as y s x the user of the system can create his own however once they are created there is no way to get of them d representations to as great an extent as possible we have representations that model the semantics of the concepts we use so as to make our and easier for example our language has data structures especially intended to eliminate the need for certain in addition to tuples which are like the familiar lists of the list processing languages we have the finite sets of con mathematics and which are unordered tuples or equivalently sets with multiple occur of the same element are called sets by knuth who many of their properties furthermore we allow arbitrary expres sions to have property lists in the same way that atoms can have property lists in lisp et al these data structures ing of equivalence relations and arithmetic functions are useful ordering for instance in the if the tion of numbers and the multiplication of numbers are each represented by a function of two arguments then it becomes necessary to use numerous tions of the commutative and associative laws to prove anything about the number system however in qa all functions take only one argument but this argument can be a tuple set or bag as well as any other expression functions of multiple arguments can be represented by a function defined on tuples however a function that is commutative and tive such as plus is defined on the expres sion plus a b really means plus bag a b recall that are unordered the system cannot distinguish between bag a b and bag a b consequently the expressions plus a b and plus a b are equal in our system this makes the commutative law for addition redundant and in fact in the language most needs for the associative law are also avoided the logical function and has the property that for instance and a a b and a b the number of occurrences of an argument does not affect its value and takes a set as its argument a b and set a b are therefore and a a b and and a b are identical and a state ment of their equality is unnecessary some func tions that take sets as arguments are and or eq and greatest common value fact fact when a new fact is true is placed on if at some later is true we simply to our system the the property list of that time we want to know if that look on its property list however certain facts are given special in addition for example if we tell the sys tem that certain expressions are equal we form a set of those expressions on the property list of each expression we place a pointer to that set for instance if we tell the system assert eq a b c the system stores the following ab eq c eq set a b c ta if we then discover any of these expressions to be equal to still another expression the system adds the new expression to the previously formed set and puts the set on the property list of the new expres sion as well for instance if we say assert eq b d our structure is changed to the following a bc d in co and also perhaps the assertion i j i j but we will not know i j because it was with respect to a lower context set a b c d ta the transitivity symmetry and of equal ity are thus implicit in our representation if we ask the system whether a and d are equal by eq a d the system knows immediately by looking at the property list of a or d ordering relations are stored using the property list mechanism if we know that some expression a is less than b we place a pointer to b on the property list of a lt a b if we learn that b is less than c we put a pointer to c on the property list of b lt a b lt c if we then ask the system if will search along the pointers way to answer built into this representation a is in the less than c it the appropriate transitive law is the interact system eq knows about lt gt and how these relations s e contexts when we are trying to prove an implication of the form a b it is natural to want to prove b un der the hypothesis that a is true our assumption of the truth of a holds only as long as we are try ing to prove b after tbe proof of b is complete we want to that we have assumed a for this and other reasons the qa language contains a context mechanism all assertions are made with respect to a context either implicitly or explicitly for any context we can create an arbitrary number of lower contexts a query made with respect to a context will have access to all assertions made with respect to higher contexts but not to any assertions made with respect to any other contexts for instance suppose we are trying to prove i j i s j with respect to some context co we may have already made some as in context co we establish a lower context cl and assert i j with respect to cl then we try to prove i j with respect to cl when proving i s j j as well as all the tions we previously in co when the proof of b is complete we may have other statements to prove in co in doing these proofs we will know all the as f user interaction sometimes our rules ask us whether they should continue or fail this allows us to cut off lines of reasoning that we know in advance to be if we make a in the question we may cause the system to fail when it could have suc however we never cause the system to find a false or erroneous proof in addition to these mechanisms which are built into the language processor we have developed some notations that make it easier to discuss programming constructs these notations are interpreted by the deductive system iv notations in speaking about the program to find the element of an array we found it convenient to use the notation we have not in this notation into our language however we have found ways of getting around its absence a baga let a he a array and integers then a i j is the tuple aj if i j then a i j is the empty tuple i and j be tuple a i j and baga a i j are the bag and set to state that an array is sorted between o and n we use lw a o n to state that an array a is the same in contents o and n as the initial array ao although contents may have been we use eq baga a o n baga n b the strip operator let a set or bag or x xn means x then set l xl xn strip x y to state that max is greater any element in an array a between than or equal to i and j we use ln baga a i j max th s is perhaps not quite as clear as max max aj max but we prefer it to iu i u au j au max the strip operator from expressions is also used to remove baga strip bag b c d is cd we will eventually need two distinct operators one to act as a quantifier and one to remove but the single operator strip has both roles so far c access and change arrays cannot be treated as functions because their contents can be changed whereas functions do not change their definitions thus while fx is likely to mean the same thing for the same value of x at different times ax is not we overcome this difficulty by and functions access and change in our of the array concept q access a i means q change a i t means the array a after the assignment statement t has been executed we do not propose that access and change be used in writing programs or assertions we do find that they make reasoning about arrays simpler as they would the next sections show examples of some fairly difficult problems solved by the deductive system v the real number algorithm very little work has been done to prove things about programs that work on the real numbers of the floating point numbers although there is no reason to believe such proofs could not be done figure shows for instance a program to compute an approximate y of real numbers p and q where o p q this is an interesting and computationally algorithm it uses only addition and division by two and it computes a new significant bit of the with each iteration the algorithm can be understood in the follow ing way at the beginning of each iteration pq belongs to the interval y it is determined whether pq belongs to the left half or the right half of the interval y and d are so that in the new iteration the to which y belongs plays the role y becomes a better for pq of the interval and better y approximation m qd w i no ti y i y ta figure the division algorithm we will consider here only one path through this program ie the path around the loop that follows the right branch of the test p ab we will prove only one assertion p our verification condition generator us with the following hypotheses b qd p y p the goal is to prove from these hypotheses that p qd l these hypotheses and the manner precisely analogous condition for the previous maximum of an array goal were constructed in a to the generation of the example of computing the the proof goes as follows attempt at using the assertion tries to show that the conclusion it therefore tries to show that after an the system follows from ab qd this goal is broken into the following two a b qd goal follows to from whereas reduces vi a pattern as an experiment in the of new knowledge into the system we performed the partial verification of a simple pattern and a re version of the unification algorithm these algorithms were of special interest to us because they involve concepts we have actually used in the implementation of the qa pro gram itself they are thus in some sense realistic although neither of these programs appears in the qa code the subject domain is as follows we assume that expressions are lisp sions for example f x g a b is an expression atomic elements are designated as either constant or variable and they can be dis by the use of the predicates const and var here we use a b c f and g as constants and u v w y and z as variables is true is true q is false q y is false a substitution replaces some of the variables of an expression by terms substitutions are repre as lists of dotted pairs x a y f g is a substitution is the re of making substitutions in expression e if s is x a y g b and e is then is gb b the lisp functions car cdr list used to manipulate expressions tion is denoted by empty and has an operation compose of substitutions defined has the following property and atom can be the empty no effect on an ex called the by s e e the problem of pattern matching is defined as follows given two expressions called the pattern and the argument find a substitution for the vari ables of the pattern that makes it identical to the argument for example if pat is and arg is then arg is x d y c if there s no substitution that makes the pat identical to the argument we want the pattern to return the distinguished atom thus if pat is x y x and arg is a b c then arg since we cannot expect x to be matched against both a and c for simplicity no variables the match might be we assume that the argument con a program to perform arg prog ml m if then if arg then else if then return list cons pat arg if then ml if ml then m if m then return compose m ml the program does the appropriate thing in the case of atomic patterns or arguments and it applies itself recursively to the left and right of the expressions in the nonatomic case the program applies the substitution found in matching the left of the expressions into the right half of the pattern before it is matched so as to avoid having the same variable matched against different terms we have proved several facts about a version of this program but we focus our attention here on one of them if the program does not return then the match it finds actually does satisfy the desired condition ie that substituting the match into the pattern makes it identical to the argument we will further restrict ourselves to the case in which both of the arguments are nonatomic ie in which control passes through the final return of the program for this example the verification tion was constructed by hand although it could just as well have been one of many produced by the gen program in generating verification conditions for re programs we handle recursive calls to the way we handle loops in iterative pro grams whatever assertion we are trying to prove about the program is assumed to be true for the re call to the program for example for this program we have proved that arg arg pat arg this assertion plays the role of the halt assertion of an iterative program we can assume the tion to be true of the recursive calls these tions would have been made by the verification tion generator to abbreviate let ml and m then our inductive hypotheses are ml the program works for the car of the pattern and m the program the pattern works for the instantiated cdr of the verification condition split each of these implications will consider only the in of both these implications are recursive calls to the pattern finding both matches generator would into two cases we which the conclusions true ie that the succeed in we know hy our assumption that arg the argument contains no variables this is one of the input assertions for the program by the path we have taken we know that through the pattern is not a constant tbe program the pattern is not a variable m the argument is not an atom the goal is to prove ml pat arg the proof produced by the system proceeds the goal is split into two as follows and ml ml the first goal is simplified to to since by this sim since arg contains no variables neither thus the goal simplifies to does the proof of is even simpler ml simplifies to we know by our hypothesis in that and this completes the proof this proof required not only that we add new rules describing the concepts involved but also that we extend certain of our capabilities particularly our ability to simplify expressions using known equalities we nearly a before the system was able to do this proof however once the proof was completed the effort necessary to enable the sys tem to do the proof of the unification algorithm was minimal the latter proof though longer than this one did not require on the part much additional of the deductive system we do not show that proof here because it is similar to the pattern proof but we include the pro gram and the assertion we proved about it vii the unification the problem of unification is similar to that of pattern matching except that we allow both ments to contain variables we expect the to find a substitution that makes the two arguments identical when it is applied to both if such a sub exists for example if x is f u a and then y is ub va where u and v are variables and a b and f are con a simple program to unify x and y is unify x y prog ml m if xy then if then y then if vary then else list x then if else list then if then ml if then m if then ml y x the predicate v tests if u occurs in v this program is a recursive version of iterative pro gram again we have verified only the longest path of the program not the entire program furthermore we have proved not the strongest possible statement about this program but only that x y the find program the program find described by hoare is intended to an array a so that all the ele ments to the left of a certain index f are less than or equal to af and all those to the right of f are greater than or equal to af in other words the relation strip baga a fl s af z strip baga a fi nn should hold when the pro gram halts for instance if f is nn then af is the of the array the function is useful in computing and is fairly complex hoare remarks that a sorting program would achieve the same purpose but would usually require much more time the conditions for find are much weaker in that for example the elements to the left of f need not be sorted themselves as long none of them are greater than af as the general strategy of the program find is to move small elements to the left and large ele ments to the right these relative size categories are defined as being less than or not less than an arbitrary array element the algorithm the array from left to right looking for a large ele ment when it finds one it from right to left looking for a small element when it finds one it the large element and the small element it has already found and the scan from the left con where it left off until the next large element is found and so on when the scan from the left and the scan from the right meet in the middle they define a split in the array we can then show that all the elements to the left of the split are small and all those to the right are large the index f can be either to the left or to the right of the split but suppose it is to the left the elements to the right of the split can re main where they are they are the largest elements in the array and the element that will ultimately be in position f is to the left of the split we then the right portion of the array and repeat the process with the split as the upper bound of the array and with a refined definition of large and small we will eventually find a new split suppose this split is to the left of f we can then leave in place the elements of the array to the left of the split and work only with the elements to the right we the left bound of the array to occur at the split and we repeat the process thus the left and right bounds of the array move closer and closer together but they always have f between them finally they meet at f and the algorithm halts the flow shown in figure follows algorithm closely in this program i is the pointer for the lefttoright scan j is the pointer for the scan m and n are the lower and upper bounds of the middle portion of the array and r is the value used to between small and large array elements hoare provided an in formal manual proof of the correctness of his pro gram london and and have produced machine proofs the proof we obtained required a minimal number three of intermediate assertions however one of the conditions produced was quite difficult to prove this condition corresponds to the statement that the elements to the right of the right boundary the elements to its left after an exchange is performed and a new right boundary is established we present a sketch of that proof below a assertions for find the input assertion qs for find is q l s the second statement is indeed a us that the array of the initial array the intermediate assertion ql is strip baga a m s strip baga a strip baga a i n s strip baga a nl nn baga a i m baga ap m t yes no this assertion is the middle section the assertion strip baga strip baga reached of the q is a ml a i n whenever a new bound on array is established s strip baga a m nn s strip baga a nl nn r af im jn jn strip baga a ii s strip baga a jl nn baga a nn baga ap nn the assertion q is the same as the q with the additional conjunct assertion e b the proof all but one of the verification conditions for this program were proved fairly easily the one difficult condition corresponds to the path begin at q that follows the heavy line and finally ends at q the verification supplied us with the following condition generator hypotheses figure the find program the array ap is the initial it in the input assertion after we have modified a version so that of a we define we can refer to it the output assertion is strip baga a fi af g strip baga a fi nn baga a i m baga ap nn strip baga a i m strip baga a m nn baga a i n s strip baga a ni nn m i strip baga a ii r s strip baga a jl nn r baga ap nn baga a nn f jl the interesting consequence for this path is strip baga a jl s strip baga a j nn where a a i j the array that are results when elements in a ali and aj the proof proof produced sketched below roughly by the inference system the the j term in the goal to j giving the goal is simplified strip baga a j s strip baga a j nn the difficulty about in the proof arises from the whether j s i we are reasoning about an array segment and it is not clear whether that segment is affected by the exchange or not hand analysis of the hypotheses and reveals that ij the value of a term like baga exchange a i j j depends on which pos is actually the case the system simplifies the term into if j si then baga a j else bag strip baga a i aj strip jl intuitively if j i the bounds of the array then the array segment then both segment i and j are outside whereas if i j but aj similarly the term baga a i j j nn is simplified into if j i then baga a j nn else bag strip baga a j jl strip baga a jl m note that is then baga a j j is empty the else clause bag ai strip baga nn our goal can thus be reduced to showing that if j s i then strip baga a ji else strip bag strip baga a i strip jl if j s i then strip else strip baga a j nn bag strip baga a jl nn the system approaches the conditional expression by creating two contexts in one context j s i holds and in the other i j is true in the first context we must prove that strip j s strip j nn in the second context the statement to be proved strip bag aj strip i i baga a jl bag strip jl nn is note that in the working on bag aj strip into two first context j i by baga a j nn is expanded baga a jl nn thus to in breaks and strip strip ji baga a j strip baga a jl nn since i j follows from and follows from alone and work on the goal proceeds in the second con text in which i g j since j s we know baga a j is empty the inequality may thus be broken into four inequalities strip strip baga a ii s strip baga a jl nn aj and aj g strip baga a jl nn follows from hypotheses follows from goal goal follows from completes the proof and goal follows from and and this this proof is the longest tive system so far achieved by our ix summary of results ness complete of the proofs following have been found algorithms of the correct q finding the largest element of an array q finding the of two real numbers find program the algorithm greatest common for finding the q the thesis program from q integer and remainder q integer addition multiplication by repeated the factorial theorems algorithms have been proved about tbe following the pattern q unification q two array elements the theorem is that tbe bag of the contents of the array is unchanged c exchange sort we believe all of problem algorithm the system now has the power to do problem set except tbe linear which is not really a proof about an x future we are currently applying the verifier to more and more complex programs in a variety of subject do we are being forced to add new rules and to generalize old ones a purpose rule that for one problem may not work for the next the deductive system is implemented in the qa language although qa is suited for ex our rules it is an experimental system evaluated by an interpreter and is written in lisp furthermore it uses space r and e are in the process of integrating qa into to produce a system known as and programs will be lisp programs that can be evaluated by the lisp in or even compiled furthermore is much more conservative m its use of space we ex that this system will be considerably faster and more compact than the existing system our deductive system is already being translated into qa its users to write depth first search strategies since it implements the goal mechanism by means of backtracking the deductive system uses depthfirst search and for the most part this has been the proper thing to do there have been times however when we have the need for something more suppose for example we are trying to prove an expression of the form xy we can do this by trying to simplify x and then proving that the simplified x is equal to y or we can try to find some assertion a b and prove x a and y b in the current system we must ex one possibility before trying another whereas we would like to be able to switch back and be different approaches giving more attention to the one that currently seems to be making the best process finally we hope to apply this work to the construction of programs it seems that if we know how to reason about programs that reasoning should be able to help us in the process of forming or changing a program rather than taking a hand written and program to a for we hope to with a system that will play an active role in the creation of the algorithm acknowledgments the work on program verification was done in close with the work on qa was done in with and jan the first version of the simplifier us to write this paper and suggested its format rich has with design modification and debugging of qa read the manuscript and suggested many improvements this work has from our con with peter mark and many members of the artificial intelligence center and computer science group at with support and references r s and j s moore about lisp functions proc august proving theorems to appear p an interactive program thesis university of california california verifier berkeley phd b techniques research m w k n and r j research in interactive project phase ii stanford institute park california may b k n and r j design of an interactive system for verification of computer programs project phase iii stanford research institute park california july r w assigning mathematical mathematics vol meanings to programs society symp in applied pp proc c description and theoretical analysis using of a language for ing theorems and manipulating models in a robot phd thesis massachusetts institute of technology cambridge massachusetts hoare car algorithm no p find cacm vol an axiomatic basis for computer program ming cacm vol no p proof of a program vol no p find s r london and d automatic verification of programs i a logical basis and implementation title stanford stanford california to appear s program august m and z verification manna a proc heuristic approach to to appear j c a program verifier phd university pittsburgh thesis knuth d the art of computer programming vol fundamental algorithms addisonwesley reading massachusetts the art of computer programming algorithms addisonwesley reading massachusetts vol j mit press et al lisp programmers manual cambridge massachusetts j and j a compiler for arithmetic mathematical mathematics vol correctness of expressions proc society symp in applied pp a p proof vol of algorithms pp by general r and e preliminary manual technical note artificial center stanford research institute california to appear intelligence park j a a machine the resolution principle pp oriented logic based on jacm vol no j f j a and r j qa a procedural calculus for intuitive reason ing technical note artificial intelligence center stanford research institute park california manual cambridge w et al reference and incorporated massachusetts von j collected works vol pp b heuristic methods deriving inductive assertions joint conference on artificial research institute to appear august for mechanically proc international intelligence park california j processes h a class of computer journal vol iterative pp 