verifying higherorder functional programs with patternmatching algebraic data types ch oxford university computing laboratory j oxford university computing laboratory abstract typebased model checking algorithms for higherorder recursion schemes have recently as a promising approach to the verification of functional programs we introduce patternmatching recursion schemes pmrs as an accurate model of computation for functional programs that manipulate algebraic datatypes pmrs are a natural extension of higherorder recursion schemes that incorporate patternmatching in the defining rules this paper is concerned with the following undecidable verification problem given a correctness property a functional program p pmrs and a regular input set i does every term that is reachable from i under rewriting by p satisfy to solve the pmrs verification problem we present a sound which is based on modelchecking and counterexample abstraction refinement given a of the verification problem the method is guaranteed to terminate from an pmrs and an input set generated by a regular tree grammar our method constructs an weak pmrs which only the firstorder patternmatching behaviour remaining completely faithful to the higherorder control flow using a variation of typebased approach we show that the trivial automaton modelchecking problem for weak pmrs is decidable when a violation of the property is detected in the abstraction which does not correspond to a violation in the model the abstraction is automatically refined by unfolding the patternmatching rules in the program to give more and more accurate weak pmrs models categories and subject descriptors d software engineering verification f logics and meanings of programs specifying and verifying and reasoning about programs general terms languages verification introduction in the past have been made in the development of finitestate and pushdown model checking for software verification though highly effective when applied to firstorder imperative programs such as c these techniques are much less useful for higherorder functional programs in contrast the two standard permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm approaches to the verification of higherorder programs are typebased program analysis on the one hand and and dependent types on the other the former is sound but often the latter typically requires human recently a modelchecking approach based on higherorder recursion schemes hors has as a verification methodology that to combine accurate analysis and automation hors are a form of simplytyped lambdacalculus with recursion and uninterpreted function symbols that is presented as a grammar and used as a generator of possibly infinite trees showed that the trees generated by hors have a decidable modal theory and kobayashi introduced a novel approach to the verification of higherorder functional programs by reduction to their modelchecking problems this method has been applied successfully to the resource usage verification problem and through it to such problems as reachability and controlflow analysis for a simply typed functional language with finite datatypes and dynamic resource creation and resource access primitives the method relies on the existence of certain transformations which given a functional program and a resource usage specification reduce the corresponding verification problem to the question of whether the computation tree of the program generated by a hors satisfies a specification encoded by an automaton on infinite trees despite the high worstcase time complexity of the modal modelchecking problem for recursion schemes which is complete for schemes an implementation of this approach performs well on realistic inputs from a verification perspective a serious of the hors approach is its to naturally model functional programs with infinite data structures such as integers and algebraic datatypes this limits the potential impact of this as functions defined by cases on algebraic data types are in functional programming a model of functional programs our first contribution is the introduction of patternmatching recursion schemes which are hors extended with a notion of pattern matching a pmrs is a kind of restricted system we believe that pmrs have a very natural syntax into which large classes of functional programs can readily be translated a typical rule which is required to be well typed has the shape f x · · · xm py · · · yk t where the variables x · · · xm are possibly higherorder formal parameters of the nonterminal or defined operator f the expression py · · · yk which takes the place of the final parameter is a pattern constructed from terminal or constructor symbols and variables y · · · yk example the following pmrs defines a function merge that merges two lists of a and b by recursively them merge x nil x merge x cons a y cons a merge y x merge x cons b y cons b merge y x the patterns in the second argument position are used both to decompose compound data structures so as to select the required components and to determine control flow selected components are to the righthand side of the chosen rule by means of binding to the variables in the pattern remark our work is not the first to propose a patternmatching extension to hors a recent paper by kobayashi and introduces an extension of hors called higherorder tree transducers model functions that may employ pattern matching but in return must satisfy a type constraint an function takes tree arguments of input sort i which are trees that can only be and returns a tree of sort o which are trees that can only be constructed pattern matching is only allowed on trees of sort i consequently functions are not compositional in the natural way we believe our pmrs model to be both simpler and more natural a verification problem this paper is concerned with the follow ing verification problem given a correctness property a functional program p deterministic pmrs and a regular set i of input constructor terms does every term that is reachable from i under rewriting by p satisfy it is straightforward to see that the problem is undecidable example consider the pmrs p which when started from main takes as input a list of natural numbers and returns the same list with all occurrences of the number zero removed the defining rules of p are given by main m filter nz m if a b true a if a b false b nz z false nz s n true filter p nil nil filter p cons x xs if cons x filter p xs filter p xs p x the input set i is given by a regular tree grammar g equivalently order recursion scheme the defining rules of g are s n z n s n nil cons n as usual the start symbol of g is taken to be s the correctness property is any outcome of the program is a list containing no this is easily expressible as a trivial automaton a whose definition is omitted an algorithmic solution our second contribution is a sound but incomplete for solving the problem which is based on a counterexampleguided abstraction refinement loop the input to the algorithm consists of a pmrs p representing the program a regular tree grammar g equivalently an order recursion scheme representing the set i of possible inputs to input build pmrs build model check no feasible yes no check feasibility of violation violation yes no yes figure counterexampleguided loop the program and a trivial tree automaton a which is to say an automaton on infinite trees with a trivial acceptance condition representing a specification of good behaviour the algorithm proceeds according to the diagram in figure in step we compute a sound abstraction of the behaviour of p when started from terms in i from an pmrs p and an order recursion scheme g we build an weak patternmatching recursion scheme which the set of terms that are reachable from i under rewriting by p a is similar to a pmrs except that its pattern matching mechanism is only able to determine control flow it is unable to decompose data structure our method is a kind of flow analysis the first ­ and key ­ stage of the algorithm is a binding analysis which is inspired by jones and it performs a fixpoint construction of a finite set of bindings such that for every variable x formal parameter of rewrite rule every term that is ever bound to x during the computation is derivable from in the second stage we use the fixpoint set to build rules of the these rules model the bindings of all in all higherorder variables precisely they only approximate the binding behaviours of the patternmatching variables this is in contrast to jones and algorithm which builds a tree grammar that the binding set of every variable for an pmrs our algorithm produces an as an abstraction which is a approximation of the pmrs being than regular tree grammars which are equivalent to order to our knowledge our algorithm gives the most accurate reachability flow analysis of its kind the patternmatching mechanism of makes it possible to decide a model checking problem for it which is the content of step given a w a closed term t and a bu¨chi automaton with a trivial acceptance condition a we decide if every possibly infinite tree generated by w on input t is accepted by a the proof uses a variation of typebased approach if the fails to find any violation of the property then since the defines a superset of the terms reachable under p from i the loop in figure will terminate because p satisfies a on i however if the reports a counterexample then it may be that p also violates the property for some term in i but it may also be that the counterexample is an of an in the abstraction to determine which of these possibilities is the case in step we the nondeterminism introduced in the abstraction to see whether in this particular counterexample it behaves well or behaves in step the abstraction process is refined due to the fact that the abstractions only ever approximate the firstorder pattern matching variables remaining faithful to all the others there is a simple notion of automatic patterns are to a certain depth in the pmrs p forming a new pmrs p in the abstraction of p the rules that define the approximation will be more accurate and in particular the spurious counterexample will no longer be present since any rule in a abstraction is accurate whenever the pattern parameter contains no free variables this method of unfolding gives rise to a property given any of the pmrs verification problem the loop in figure will eventually terminate with the answer no returning to example performing step we obtain an overapproximation of the binding behaviour of the variables in the program this fixpoint set contains others the bindings x n and xs from this set we construct an whose contains the following filter p nil nil filter p cons x xs if cons x filter p xs filter p xs p x x n xs together with others all the p and g rules in example except those for filter unfortunately the is too to be useful there are trees representing lists that are obtained by rewriting from main s that are not accepted by the trivial automaton a however these are spurious counterexamples for an illustration consider the error trace in the main s main cons s z nil filter nz cons s z nil if cons x filter nz xs filter nz xs nz x if cons z filter nz nil filter nz xs nz s z cons z filter nz nil cons z nil the problem can be traced to the second clause of filter in the when replacing the variable x by the nonterminal x the connection between the two occurrences of x in the rhs is lost as the reduction of one occurrence of x is independent of that of the other the refinement algorithm produces a new pmrs p that replaces the two defining rules of filter by five new rules the two rules that cover the case when the list is a singleton are shown below filter p cons z nil if cons z filter p nil filter p nil p z filter p cons s v nil if cons s v filter p nil filter p nil p s v applying the approximation algorithm to pmrs p and input grammar g we obtain a that does accurately capture the set of reachable terms var x x n const t t app t t figure a simple type system for applicative terms outline the rest of the paper is as follows section introduces pmrs and other technical in section the abstraction algorithm which takes a program pmrs and an input set order recursion scheme and returns a is presented termination and soundness of the approximation are proved section presents a algorithm for deciding if every tree generated by a given is accepted by a trivial automaton the abstraction refinement algorithm is the topic of section finally section presents related work note a long version of the paper is available which contains the proofs and additional material we introduce pmrs a model for functional programs manipulating algebraic data types a restriction of pmrs with good algorithmic properties and the pmrs verification problem whose solution is the subject of the remainder of this work types terms and substitutions fix a finite set b o b of base types the simple types s are those expressions that can be constructed from the base types using the arrow b we adopt the usual convention that arrows associate to the right and omit accordingly the order of a type denoted ord is a measure of the of the arrow constructor on the left it is defined by and ord ord applicative terms fix a finite simplytyped alphabet f g a of firstorder terminal symbols or constructors a finite simplytyped alphabet f g h n of nonterminal symbols or defined operators and a set x y z v of variables · the constructor terms t are those expressions that can be built from terminals using application · the closed terms t n are those expressions that can be built from terminals and nonterminals using application · the patterns are those expressions p q of base type that can be built from variables of base type and terminals · the applicative terms t n v are those expressions that can be built from terminals nonterminals and variables using application we denote the free variables of a term t by applicative terms may be assigned simple types via a formal system of typing judgements s where is a finite set of type bindings defined by the rules in figure when an applicative term t can be assigned a simple type · · · m b we say that it has arity m and write art m by term we shall mean welltyped applicative term labelled trees given a alphabet an labelled tree t is a map from · · · m to where m is the largest arity of symbols in such that is and if tx f then i x i · · · we identify t with finite labelled trees and write t for the collection of possibly infinite labelled trees let be with ar given a closed term t we write t for the finite labelled tree defined by recursion as follows for m s · · · sm if f n f s · · · sm otherwise f eg f gg ab f g b labelled trees can be with a natural complete partial order in which for all trees t t and f s · · · sm f t · · · tm iff for all i si ti substitutions a substitution is just a partial function in v t n v by convention we do not distinguish between a substitution and its extension to the free algebra t n v and we will write the application of both using prefix a term t is said to match a term u precisely when there exists a substitution such that t u we shall say that a substitution is closed whenever every term in its image is closed patternmatching recursion scheme pmrs a patternmatching recursion scheme pmrs is a p n r main with and n as above r is a finite set of rewrite rules each of which is one of the following shapes m pure patternmatching f x · · · xm t f x · · · xm p t where p is a pattern which may be trivial main b o is a distinguished nonterminal symbol whose defining rules are always patternmatching rules in this paper we will assume that the variables appearing as formal parameters to defining rules in a pmrs will always be distinct a pure rule f x · · · xm t is welltyped when f · · · m o n and the judgement x xm m t o is provable a patternmatching rule f x · · · xm p t is welltyped when f · · · m b o n and there exist b bk such that the judgements y b yk bk p b and x xm m y b yk bk t o are provable we say that a pmrs is welltyped just when each of its rules is welltyped we will only consider welltyped pmrs in the following we define the order of a pmrs to be the maximum order of the type of any of the nonterminal symbols in n since a pure rule can be simulated by a patternmatching rule with a trivial pattern eg a terminal of a distinguished base type we shall sometimes find it convenient to treat all pmrs rules as patternmatching rules reduction we associate with each pmrs a notion of reduction as follows a redex is a term of the form f x · · · xm p whenever is a closed substitution and f x · · · xm p t is a rule in p the of the redex is t we define the reduction relation t n × t n by cs ct whenever s is a redex t is its and c is a context we say that a pmrs is deterministic just if given some redex f s · · · sn there is exactly one rule l r r such that f s · · · sn l for some given a pmrs p n r main let s t n be a closed term of base type we write lp s to mean the language of labelled trees obtained by rewriting of the term s more precisely define lp s as the collection of labelled trees t such that there are ti i with s t t t · · · a fair reduction outermost redex in ti sequence in is eventually i in case p is a deterministic pmrs lp s is a singleton set we write the unique labelled tree as sp example let zero nat succ nat nat nil cons nat and n rev the following deterministic order pmrs contains rewrite rules that implement list reversal with an parameter main zs nil zs xs nil xs xs cons y ys cons y xs ys when started from the term t cons z nil the only possible reduction sequence is main t nil t t nil t and hence m ain tp t as expected weak pattern matching recursion schemes a weak patternmatching recursion scheme is a w n r main with n and main as for pmrs the finite set r consists of rewrite rules of the shape m pure f x · · · xm t f x · · · xm p t in which a pure rule is well typed according to the same criteria as for pure pmrs rules a rule f x · · · xm p t is welltyped just when f · · · m b o n and there exist b bk such that the judgements y b yk bk p b and x xm m t o are provable note that none of the patternmatching variables yj occurs in t we will only consider with well typed rules have exactly the same notion of reduction as pmrs a redex is a term of the form f x · · · xm p whenever is a substitution and f x · · · xm p t is a rule in p the of the redex is t t xx · · · as the patternmatching variables do not occur in t the reduction relation is defined as for pmrs we define the order determinism and language of a analogously with pmrs a verification problem we are interested in solving the following verification problem given a program in the form of a pmrs p a regular set i of input terms and a correctness property does the output main t of the program main t satisfy for every input t i to propose a solution we require two further both of which concern the representation of the entities involved higherorder recursion schemes a higherorder recursion scheme hors is a g n r s with and n as before and r is a finite set of welltyped pure rewrite rules the component s is a distinguished nonterminal called the start symbol the reduction relation for hors is just that of noting that all redexes will necessarily be of the form f x · · · xm since there are no patternmatching arguments we can associate with a recursion scheme g its language lg of terms in t that can be derived from the start symbol s by rewriting away all occurrences of nonterminals more precisely we make the following definition lg t s t t t we define the order of a recursion scheme analogously with pmrs and note that as generators of finite trees order recursion schemes are equivalent to regular tree grammars trivial automata let be as before a bu¨chi tree automaton with a trivial acceptance condition or simply trivial automaton is a a q q where is as before q is a finite set of states q q is the initial state and the transition relation is a subset of such that if q f q · · · qn then n a labelled tree t is accepted by a if there is a tree r such that i ii for every x rx tx rx · · · rx m where m the tree r is called a of a over t we write la for the set of labelled trees accepted by a the pmrs verification problem given a deterministic pmrs p np rp main a nondeterministic order recursion scheme g ng rg s and a bu¨chi tree automaton with a trivial acceptance condition a q q we write p g a iff t lg · main tp la the pmrs verification problem is to decide the truth of p g a constructing an abstraction in this section we will present an algorithm which given an deterministic pmrs p and an order recursion scheme g constructs an whose language of labelled trees is an overapproximation of the set of labelled trees reachable from lg under rewriting by p at the of the algorithm is an analysis of the composite pmrs pg ng np rg rp main since every term s reachable from lg under rewriting by p ie main t p s for some t lg is certainly reachable from s under rewriting by pg ie main s p g main t pg s it suffices to look only at the behaviours of pg in order to construct a safe abstraction of those of p we detail the nature of this analysis and its properties separately before showing how it the construction of the some a simple term is a subterm of the rhs of a or is the starting term main s a compound term has the shape t · · · tm with m where the head symbol is either a variable or a terminal or a nonterminal and each ti is simple it follows from the definition that a simple term is compound but the converse is not true binding analysis in a pmrs the pattern matching rules use pattern matching both to determine control flow by selecting which of a number of defining rules is used to reduce a redex as well as to decompose compound data structure by binding components to variables in the pattern that then occur on the rhs of the rule however the weak pattern matching mechanism in a only the former capability although patterns are matched since there are no pattern matching variables on the rhs of defining rules data structures cannot be decomposed therefore to build an effective abstraction of a pmrs requires some knowledge of the substitutions that can occur in pairs during pmrs reduction to this end we define a binding analysis which determines a set of xm bindings p ct which occur in substitutions arising in from main s the analysis is based on the observation that every such redex is either main s or arises as an instance of a simple term it proceeds by an iterative process in which bindings by which instances of simple terms can be derived give rise to redexes which in turn give rise via contraction to more bindings until the desired set is reached in the limit before we give the details of the analysis let us make precise what it means for a set of bindings s to give rise to an instance of a term given such a set s we define the relation s s t which is a subset of t n v × t n inductively by the system rs r t s t s if x s s and cs s t then cx s t where c ranges over contexts we say that an instance of rule s is a just if the hole in c occurs in head position example let s x y b x n y f z z a then using the system rs it is possible to derive f x z s f f a b a and f x z s f n a note that the form of rule s does not constrain bindings to be used consistently within nonlinear terms let s x f y z y z y a z b then we have for example f x g x s f f a b g f b b in which the binding y a has been used in the derivation of the first argument of f whereas y z has been used in the derivation of the second argument to ensure that the analysis is computable we cannot to work with instances of simple terms directly we instead work with terms in which bindings have been applied only where strictly necessary in order to new redexes the construction of such terms is the purpose of the function head the head function given a set s of bindings we define the head function heads t n v t n v given by heads t · · · tm t · · · tm where is an auxiliary function defined by the following k x k whenever k n x x if x x then else t · · · tm x t · · · tm s x x thus heads u is the set of terms that are from u by iteratively replacing the head it is a variable by a term bound to it in s the second argument of any cyclic chain of bindings for example let s x y y x then heads x x y x x x y example let s and s be as in example then heads x c n c f z b c heads x c f y z c heads f x g x f x g x notice that since head performs according to bindings from s its behaviour is consistent with a strategy for constructing initial prefixes of derivations in the system rs each use of the recursive clause of corresponds to a of rule s a consequence of this relationship is made precise by the following lemma lemma if u s v · · · vm then there is a compound term u · · · heads u and for all i m ui s vi one final property to note about head is that whenever its argument is compound and all the variables in s are bound to simple terms the terms in sets in its image are all compound this is due to the fact that in this case the action of the head function is to construct new compound terms by old simple terms into head position this limited behaviour of the will contribute towards the termination of the analysis lemma we say that a set of bindings s is just if every term in the image of s is simple suppose s is if u is compound then every term in heads u is compound the goal of the analysis is to discover the possible redexes f x · · · xm p that occur during reduction sequences of pg starting from main s the head function heads u is able to determine in a way that is computable when an f redex is an instance according to s of a simple term u in this case according to lemma a term of the shape f t · · · tm s is an element of heads u however to know which defining rule of f is it is necessary to find out which patterns are matched by residuals of instances of s the approximate reduction to this end we introduce a new notion of reduction s t n v × t n v by a set of bindings s this reduction approximates the usual pmrs reduction by performing substitutions only where necessary and only when the relevant bindings are contained in s a s redex is a term of the form f x · · · xm p whenever there is a pg rule of the form f x · · · xm p t and is a substitution not necessarily closed the of the redex is t no substitution is per formed upon contraction we define the one step reduction s by the following rules let c range over contexts s t a pair cs s ct t heads x t · · · tm cx t · · · tm s ct as of is s standard we write and n s to mean a s to mean the reflexive chain of s transitive closure example consider the composite pmrs pg constructed from the pmrs and grammar given in example and let s contain the bindings p nz and x n then the following p x s nz x s nz n s nz s n s true is a s reduction observe how as demonstrated by the third step approximate reduction is accurate for order given a substitution and a pattern p we say that a s reduction s i s p is minimal just if it is not the case that there exist j i and substitution such that s j s p consider the two rules defining s reduction in the rhs of the conclusion of each rule is the term t in both cases assuming s is image sim ple t is a compound term since there are only finitely many such terms t and since there are only finitely many patterns drawn from the pmrs p the problem of finding such minimal reductions is computable lemma assume s is given a compound term s and a pattern p drawn from the defining rules of pg the problem of finding a substitution and a minimal reduction s s p is computable the fixpoint construction let s be a set of bindings we define fs as the least set x of bindings that contains s and is closed under rule c if i u is simple term of base type ii f t · · · tm s heads u iii f x · · · xm p t is a pg rule iv there is a minimal reduction s s p then xi ti i m x thus f n v n v is by construction a monotone on the complete lattice n v ordered by by the fixpoint theorem the least fixpoint of f which we shall denote exists and is as the of the chain f f f f ff · · · example consider again the composite pmrs pg composed from the pmrs p and tree grammar g given in example we shall apply the fixpoint construction to this structure initially the only choice of simple term is the starting term main s which otherwise trivially satisfies the premises of rule c and yields the single binding m s subsequently taking u filter nz m matches both the defining rules for filter after of m ms nil and m ms cons n respectively this choice adds the bindings p nz x n and xs examining the term p x in the rhs of the second defining rule for filter then gives n n finally taking u as the entire rhs of the second defining rule for filter and p x as in example gives bindings a cons x filter p xs and b filter p xs in this case no other choices of simple term yield any new bindings so the fixpoint is obtained as m s p nz x n xs n n a cons x filter p xs b filter p xs though the complete lattice n v is infinite the least fixpoint is finitely ie the closure of f is finite it is in fact a finite set observe that in example the form of every binding in the fixpoint is v t in which t is a simple term this is the key to showing the convergence of the analysis since every term f t · · · tm s heads u is compound whenever s is and u is compound so every binding xi ti is since whenever s is every s is compound so the bindings due to p are image simple since there are only finitely many simple terms termination follows theorem termination the least fixpoint of f is a finite set to see that this finite set of bindings is sufficient to describe all the all the substitutions that occur during redex contractions in reduction sequences of pg starting from main s one should first notice that the approximate reduction when instantiated with the fixpoint acts on simple terms in a way which is consistent with the way pmrs reduction acts on their instances in a trivial context lemma assume t is a and u is a simple term if s t and u s then u t and t t s t u t to lift this fact to the level of arbitrary reduction sequences starting from main s it is enough to observe that any redex in such a sequence apart from the first can be seen either to be itself a simple term or to arise as a subterm of some previous regardless of the context in which the redex occurs as a consequence of lemma the bindings necessary to derive the redex as an instance of the corresponding simple term will already be contained in the fixpoint hence if the reduction sequence reaches any the fixpoint will contain the bindings necessary to the substitution associated with the contraction lemma assume t is a if main s ct is a sequence then t t construction of the we are now ready to define the which is an abstraction of the composite pmrs pg n r main let be the fixpoint set of bindings and let nv vx x v and n ka a be two sets of fresh nonterminal symbols which we call and respectively we define the n nv n r main where r consists of the following three kinds of rules i weak patternmatching rules for each pure or patternmatching f x · · · xm p t r contains the following rule f x · · · xm p t ii instantiation rules for each binding x t in where x · · · xl r contains the following rule vx z · · · x · · · xl z · · · where each zi is a fresh variable of the appropriate types iii rules for each terminal symbol a b · · · bn o in r contains the following rule ka z · · · zn a z · · · zn where each zi is a fresh variable of type bi where we have written t to denote the term t in which every occurrence of a pattern matching variable y has been replaced by the corresponding and every occurrence of a terminal symbol a has been replaced by the corresponding ka example consider the following order pmrs whose defining rules are given by main m map m map nil nil map cons x xs cons x map xs x x and input grammar g consisting of two rules s nil cons s the function map behaves like the standard map function except that it the first two function arguments as it filters through the successive elements of the list argument the reachable constructor terms are finite lists that are prefixes of · · · after applying the fixpoint construction to this example the set of bindings consists of the following ms x x x x x xs s and hence the is as follows main m map m map nil nil map cons x xs cons x map xs x zero x one m s x zero xs s s nil cons zero s zero one nil nil cons v v cons v v since x and x are not variables the rules for v v vx and vx are in this case never used and so play no part in the approximation process they have been omitted it is easy to see that the constructor terms in main s are exactly the finite prefixes of · · · ie the approximation is exact in this case given any main s t the reduction can be simulated in the abstraction using the weak patternmatching rules and the instantiation rules whenever the contracts a which binds data y to a pattern matching variable y the simulation can contract the corresponding redex using a weak patternmatching rule and by lemma can then the bound data y from using the instantiation rules theorem soundness let the composite pmrs pg and the be as before then main s main s the third class of rules is not essential to the achieving soundness the purpose of the rules is to enforce a strict correspondence between the length of a reduction sequence and the maximum size of any constructor term created within it this the justification of the property of refinement in section model checking by type inference in this section we exhibit an algorithm to decide the model checking problem given a nondeterministic w n r m ain in which main b o a closed term t b and a trivial automaton a is lw main t la following work by kobayashi and kobayashi and we the model checking problem as a type inference problem in a particular finitary intersection type system induced by the automaton eliminating nondeterminism the first step we take is to simplify the problem at hand by eliminating the nondeterminism in w to this end we construct a new w in which multiple defining rules for a given nonterminal are using a family b b b of nondeterministic choice terminal symbols of type b b b we define w b n l r · l r r main in which by way of a shorthand we define t · · · tn r r · · · rm rm · · · where r rm r f t · · · tn r r and the type of f is of the form · · · n b we must modify the automaton a accordingly so we define a b q q q q q q b b q lemma for all terms t of lw main t la iff main tw la model checking as type inference we first introduce recursion schemes with weak which is a term rewriting system similar to in fact with the difference is that weak matching is explicitly provided by a case construct assume for each base type b an exhaustive and family of patterns pb p · · · pk a recursion scheme with weak is a g n r s where n and s are as usual and r is a set of pure rules of the form f x · · · xm t we write x · · · the set of applicative terms is defined as before except that it is augmented by a construct t · · · tk with typing rule t b ti o for i k t · · · tk o we say that g is deterministic just if there is one rule for each f n there are two kinds of redexes i f s · · · sm which contracts to · · · for each rule f x · · · xm t in r ii t · · · tk which contracts to ti provided t of base type b matches pattern pi pb p · · · pk we define evaluation contexts e as follows e f t · · · ti e ti · · · and write for the reduction relation e where · ranges over pairs and e over evaluation contexts assuming g is deterministic we define the labelled tree generated by g by rewriting from s as g t s t lemma deterministic and deterministic are as generators of labelled trees we present an intersection type system for the model checking problem the intersection types of the system are given by the grammar m q p i i where q q and p is one of the finitely many patterns associated with a definition by cases in the scheme g judgements of the type system are sequents of the form t in which is simply a set of type bindings where n v the defining rules of the system are as follows x x var q f q · · · qn a f q · · · qn q term · s p · · · pn p s p · · · pn p match t pi ti t · · · ti · · · tn s vn i i t i for each i n st case app x · · · x n t xt vn i i abs note that we have the following derived rule from match if a term s of the appropriate type matches the pattern p then s p we write a g if is provable for every f a is welltyped written a g just if there exists such that i a g ii s q iii for each f where f n meaning that is an intersection type compatible with type as assigned to f by the w is defined by if i q o and ii for p b for each each p pb i k i theorem let a be a trivial automaton and g be then a g if and only if g la the proof is omitted as it is very similar to the proof of the soundness and completeness theorems in corollary the model checking problem is decidable proof this follows from lemma lemma and theorem and the decidability of typability a g the latter follows from the fact that for each nonterminal there are only finitely many candidate intersection types compatible with a given type abstraction refinement when the model checking stage reports a counterexample in the form of an error trace the trace may be feasible that is it corresponds to a concrete reduction sequence in the original pmrs p or it may be spurious an of the abstraction process in the case the counterexample is spurious we will want to ignore it and perform the process again but in a new setting in which we are guaranteed never again to this trace to achieve this we the cycle from a modified pmrs p which has had some of its defining rules so as to reduce the amount of nondeterminism in the corresponding abstraction counterexamples and feasibility when the reports a violation of the property a counterexample error trace is returned this error trace is a reduction sequence in the abstract since is not completely faithful to the pmrs p it is necessary to determine whether such a counterexample trace corresponds to a reduction sequence in p which itself witnesses the violation or whether it is an of the abstraction of a counterexample it is useful to two important features of any given counterexample trace namely i the shape of the last term in the reduction sequence and ii the type of each constituent reduction any counterexample trace must end in a term t which witnesses the violation of the property since the property is a collection of possibly infinite labelled trees the term can be seen to be of the form q where q is a pattern which does not match any prefix of a tree t we say that the pattern q which witnesses the violation of the property is the error witness in any reduction sequence each reduction u v can be classified into one of two kinds based on the head symbol occurring in the redex in case we want to that the head symbol is a nonterminal belonging to p we say the contraction of this redex is an abstract and write u p v otherwise the head symbol is either a an or it belongs to g in this case we say that the head symbol in question is a and that the contraction of this redex is an abstract we write u v example consider the following abstract error trace which is derived from the abstraction of the pmrs p and grammar g given in example main s filter nz m filter nz cons n if cons x filter nz xs filter nz xs nz x if cons x filter nz xs filter nz xs nz s n if cons x filter nz xs filter nz xs true cons x filter nz xs cons x filter nz xs cons z filter nz xs which violates the property since it is the start of a list that contains a zero the for this trace is cons z v for some variable v the first reduction is an abstract as is the reduction written over lines and and that of lines and all the other reductions in the sequence are abstract the trace in the above example is spurious since there are no reduction sequences of the pmrs p starting from terms in lg from example which result in a list by a zero intuitively we can see that this trace is infeasible because the nondeterminism introduced by the abstraction has been resolved in an inconsistent way during the sequence the data bound by the pattern match for filter which is given as n ie some number has been resolved on the one hand line to a nonzero number and on the other hand line to zero in the following we define a process of labelling of the counterexample trace that will reveal information about the resolution of nondeterminism that has been introduced as a consequence of the abstraction the information that is exposed will allow us to see whether or not this abstract trace in has any corresponding trace in p starting form i that is whether the trace is feasible labelling the labelling procedure keeps track of how nondeterminism is resolved in an abstract reduction sequence by annotating each x with a set of possibly open terms which represent all the closed terms to which it reduces when the terms are given by the set l we write the annotated term xl and we identify an x with x given a term t which may include labelled subterms we define the resolution of t which is a set of terms defined as follows t fa l u v u t v t when t a when t f is not a when t f l is a when t t t where l denotes the set l when l is nonempty and z for some fresh variable z otherwise if any reduces to two incompatible terms or to a term which is inconsistent with the term that it represents in the matching then the procedure will detect a conflict and record it in the set failures s if s is labelled by l and there is a term t lg which is an instance of then do nothing else add main l to failures s u v the reduction u v cf x · · · xm ct x · · · xm label the head symbol f by t cf x · · · xm p p ct for each y let be the labelled v created by the contraction perform l lk on the of y in p if fails then add f l lk to failures for each occurrence of an n in u let nl be the set descendants in v label this occurrence of n with l lk perform ain s u where the procedure which is designed to resolve the data bound in a pattern match and the data created by the abstraction is given by sk the form of t t a if i a matches si then do nothing else fail t f if f is not a and i f matches si then do nothing else if f is a and w sk exists then label f by w else fail t t t if i either si is a variable or si si si then let sj z and sj z for fresh z z whenever sj is a variable and perform sk and perform sk else fail where denotes the most general common instance of the set of terms l regarding a single fresh variable as the of the empty set we call a counterexample trace that has been labelled by a labelled trace for the purposes of calculating terms are considered as first order entities constructed from atomic constants and a single application operator example consider again the abstract reduction sequence in example after performing the following labelled trace is produced the set bracket notation has been since all labels are singleton sets main s cons v v filter nz m cons v v filter nz cons n v if x z filter nz xs filter nz xs nz x s v if x z filter nz xs filter nz xs nz s n v if x z filter nz xs filter nz xs x z filter nz xs cons x z filter nz xs cons z filter nz xs after labelling we have failures filter z s v observe that there are no labels on n in line due to the fact that failed feasibility for a trace in to be feasible two properties are required first the nondeterminism introduced by the abstraction should be well and second there should be a term in the input that is able to trigger the trace ie when given as an argument to main the rest of the trace follows the first of these conditions is the subject of the step case in the second is the subject of the base case hence if after performing it is the case that failures then we say is feasible the justification is the following lemma lemma let be a feasible reduction sequence in with q then there exists a term t lg and a finite reduction sequence main t · · · in p with error witness q the witness to soundness which appears in the proof of theorem will always be feasible we say that any trace that is not feasible is spurious refinement when a reduction sequence in is shown to be spurious the problem can always be traced back to an occurrence of patternmatching notice that by definition the single parameter of the defining rule for main is always a pattern since the only loss of accuracy in the abstraction is in the way that data bound in pattern matches is handled during reduction our for is to increase precision in the pattern matching rules of our strategy is based on the observation that due to the particular way in which the abstract is constructed from the composite pmrs the terminal parts of each pattern are accurately preserved in the rhs of the defining rules of the abstraction based on the depth of pattern matches in the counterexample trace we unfold patterns in the defining rules of p in a way that preserves the the set of possible reduction sequences patternmatching depth to determine how much to unfold we define a measure depth t n v n which the extent to which a term can be matched as follows t · · · tm g t · · · tm i m n given a set of nonterminals n a depth profile for n is a map n n we assign a depth profile to a set of rules to quantify for each nonterminal f how accurately the defining rules for f model patternmatching given a set of rules r defining nonterminals from n let the depth profile of r denoted be the function g f x · · · xm p t r n depth profiles can be naturally ordered pointwise so that if d and d are depth profiles over the same domain n then d d iff df d f for all f n unfolding to capture the result of unfolding we first introduce two auxiliary definitions to aid readability in each of them we will annotate fresh variables with their implied types by a su the set of atomic patterns of type b ab is the set a ··· a b ··· b for each n n we define the exhaustive set of patterns of type b and depth n pq · · · where stands for the conjunction p xb i qi hence the depth family of patterns of type are given by n x and xs arbitrary variables nil cons z nil cons z cons x xs cons s n nil cons s n cons x xs to unfold the rules of a pmrs p according to a depth profile d one constructs a new pmrs p whose is so that for a given nonterminal f of type · · · m b o there is a number of defining rules which is equal to the number of patterns of type b and depth df for each of these rules the corresponding righthand side is constructed by using the existing p rules as a template let p n r main be a pmrs and let d be a depth profile with domain n such that d the of p is the pmrs n r main where r is the set such that for all substitutions f x · · · xm p t r iff i f x · · · xm p t r ii and p is of type b iii and q iv and q p example let p be as in example and let d be the depth profile given by the following rule df when f filter otherwise then the of p is the pmrs p whose rules are the same as p except that the two rules for filter have been replaced by the five rules in figure consider an abstraction of the pmrs p in example with g as given in example the only nondeterminism that is introduced in constructing the abstraction is in replacing the patternmatching variables in the righthand sides of the defining rules by due to the unfolding of the filter rules in p and hence in there is no longer a possibility to make the problematic reduction filter nz cons n if cons x filter nz xs filter nz xs nz x since the rules require more of the nondeterminism in the nonterminal symbols n and to be resolved earlier filter p nil nil filter p cons z nil if cons z filter p nil filter p nil p z filter p cons z cons v v if cons z filter p cons v v filter p cons v v p z filter p cons s v nil if cons s v filter p nil filter p nil p s v filter p cons s v cons v v if cons s v filter p cons v v filter p cons v v p s v figure depth unfolding of the defining rules for filter refinement given a pmrs p and an infeasible error trace in the abstraction of p we can obtain refined abstractions by unfolding the rules of p according to the of terms in the failures set then using the pmrs as the input to the next cycle of the loop lemma let p n r main be a pmrs and be the abstraction of p starting from terms in lg let be a counterexample trace of which is spurious with failures set s let d be the depth profile with domain n defined by g df f p s t p n and let p be the of p then is not a reduction sequence in the abstraction of p although it is clear that given any spurious trace in some abstraction it is possible to construct a refinement that eliminates it from any future abstraction the set of traces of and the set of traces of are incomparable since in general there are new introduced in the refinement and hence new into however there is a very close relationship between the depth of a pmrs and the feasibility of reduction sequences in its abstraction lemma fix n n then given any pmrs p and input grammar g there is a d such that if is the abstraction of the of p then all n reduction sequences in are feasible a consequence of this close relationship between depth and feasibility is that under the assumption that the always reports the shortest counterexample trace if the pmrs p when run from a term in i does violate the property then eventually the cycle will produce a feasible counterexample trace the fact theorem let p i a be a of the verification problem then the algorithm terminates with a feasible counterexample trace related work we compare and contrast our work with a number of topics in the literature related to flow analysis and verification of functional programs higherorder tree transducer as discussed in the introduction kobayashi introduced a typebased verification method for temporal properties of higherorder functional programs generated from finite base types in a paper kobayashi et al introduced a kind of tree transducer called that uses patternmatching taking trees as input and returning an output tree they studied the problem of whether the tree generated by a given meets the output specification assuming that the input trees meet the input specification where both input and output specifications are regular tree languages a sound but incomplete algorithm has been proposed for the verification problem by reduction to a model checking problem for recursion schemes with finite data domain which can then be solved by a variation of typebased algorithm though our algorithm in the present paper solves a similar kind of verification problem it is not straightforward to compare it with the work it would appear that pmrs is a more general and natural formalism than what is clear is that our approach to the overapproximation is very different we use binding analysis to obtain a which generates an overapproximation of the reachable whereas kobayashi et al use automaton states to approximate input trees collecting semantics and flow analysis in a paper jones and studied the data flow analysis of functional programs by safely the behaviour of a certain class of untyped firstorder term rewriting systems with pattern matching their algorithm takes a regular set i of input terms a program p and returns a regular tree grammar which is a safe description of the set of all reachable constructor terms of the computation of p with inputs form i precisely the algorithm computes a safe approximation of the collecting semantics of p relative to i which assigns to each rewrite rule a set of pairs g such that is a substitution in the course of such a computation of actual parameters to the formal parameters of the rule and g is a term reachable from the rhs of the rule with the substitution the collecting semantics is undecidable in general jones and was able to obtain for each rewrite rule a regular overapproximation of the set of bindings x x for each formal parameter x of the rule and the set of reachable terms g by the pair g there are two directions in which jones and algorithm may be refined consider the setting of simplytyped functional programs with patternmatching algebraic data types recent advances in the model checking of higherorder recursion schemes notably the decidability of mso theories of trees generated by higherorder recursion schemes indicate that the bindings of non patternmatching variables whether higherorder or not can be precisely though with extremely high asymptotic complexity jones and algorithm builds a regular approximation of the binding set of every variable a natural question is whether one can improve it by only the bindings of patternmatching variables while other variables including all higherorder variables precisely using the method in the work presented here offers a positive answer to the question another direction worth is to to preserve for each rewrite rule as much of the connection between substitutions and reachable terms g as one can get away with in an recent dissertation has presented just such an algorithm using a kind of linear indexed tree grammars which are equivalent to contextfree tree grammars the indices are the substitutions to compare our algorithm with jones and it is to apply their algorithm to our example their framework can be extended to simplytyped and higherorder programs it is an old idea in functional programming that an higherorder expression such as an applied function · · · f e · · · em where the type of f has arity greater than m may be viewed as a closure indeed closures are a standard implementation technique from this viewpoint a higherorder nonterminal is regarded not as a defined operator but as a constructor and closures are formed using a binary operator thus the second clause of m ap is written in their system as m ap cons x xs cons x m ap xs observe that in this setting m ap is a constructor ie terminal symbol and the expression m ap a pattern call the binding set of a variable the set of terms that may be bound to it at some point in the course of a computation the grammar produced by jones and algorithm is always regular equivalently an order recursion scheme this is achieved by the binding set of every variable including higherorder ones such as the grammar generates all finite lists of s and s which is less precise than our algorithm control flow analysis established in the s by jones shivers and others control flow analysis cfa of functional programs has an active research topic ever since see eg survey and the by nielson et al the aim of cfa is to approximate the flow of control within a program phrase in the course of a computation in a functional computation control flow is determined by a sequence of function calls possibly unknown at compile time thus cfa amounts to the values that may be substituted for bound variables during the computation since these values are denoted by pieces of syntax cfa reduces to an algorithm that assigns closures subterms of the examined term with substitutions for free variables to bound variables reachability analysis and cfa are clearly related for example the former can aid the latter because unreachable parts of the term can be safely from the range of closure assignment there are however important differences on one hand cfa algorithms are approximation algorithms designed to address a more general problem on the other because cfa considers terms in isolation of its possible program contexts the corresponding notion of reachability essentially amounts to reachability in the reduction graph functional reachability based on the fully abstract game semantics traversals are a particularly accurate model of the flow of control within a term they can therefore be viewed as a cfa method using traversals a new notion of reachability of higherorder functional computation in the setting of pcf is studied in called contextual reachability given a pcf term m of type a and a subterm n with occurrence is there a program context c such that cm is a closed term of ground type and the evaluation of cm causes control to flow to n conclusion recursion schemes with pattern matching pmrs are an accurate and natural model of computation for functional programs have patternmatching algebraic data types we have given an algorithm that given a pmrs p and a regular set i of input terms constructs a recursion scheme with weak patternmatching that i the set of terms reachable from under rewriting from p ii has a decidable model checking problem relative to trivial automata finally because of the precise analysis at we show that there is a simple notion of automatic which gives rise to a property for future work we plan to build an implementation of the verification algorithm for a real functional programming language we shall be especially interested in the scalability of our approach acknowledgements we would like to thank the anonymous reviewers for many useful comments references w and ch l theorems and their applications e m clarke o s y lu and h counterexampleguided abstraction refinement in cav proceedings of the th international conference on computer aided verification pages ­ london uk springerverlag a and n kobayashi resource usage analysis acm trans program lang syst ­ n d jones flow analysis of lambda expressions preliminary version in proceedings of the th colloquium on automata languages and programming pages ­ springerverlag isbn n d jones and n flow analysis of lazy higherorder functional programs theoretical computer science ­ n kobayashi types and higherorder recursion schemes for verification of higherorder programs in proceedings of popl pages ­ acm press n kobayashi modelchecking higherorder functions in pages ­ n kobayashi and ch l a type theory equivalent to the modal model checking recursion schemes in proceedings of lics ieee computer society n kobayashi n and h higherorder tree transducers and recursion schemes for program verification in popl pages ­ j reachable terms of functional programs university of oxford thesis r p computer aided verification of processes princeton university press j controlflow analysis of functional programs technical report rs department of computer science university of denmark dec url f nielson h r nielson and c principles of program analysis springerverlag new york ch l on modelchecking trees generated by higherorder recursion schemes in proceedings st annual ieee symposium on logic in computer science pages ­ computer society press long version pp at ch l and s j verifying higher order functional programs with patternmatching al data types long version available from ch l and n functional reachability in lics pages ­ o shivers controlflow analysis of higherorder languages phd thesis university 