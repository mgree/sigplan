making with decision predicates cook microsoft research university of london university of cambridge abstract we describe a new algorithm for proving temporal properties expressed in ltl of programs our approach takes advantage of the fact that ltl properties can often be proved more efficiently using techniques usually associated with the logic ctl than they can with native ltl algorithms the is that in certain instances nondeterminism in the systems transition relation can cause ctl methods to report counterexamples that are spurious with respect to the original ltl formula to address this problem we describe an algorithm that as it attempts to apply ctl proof methods finds and then removes problematic nondeterminism via an analysis on the potentially spurious counterexamples problematic nondeterminism is characterized using decision predicates and removed using a partial symbolic procedure which introduces new variables to predict the future outcome of these choices we examples taken from the database server web server and windows os kernel that our method can yield performance improvements in comparison to known tools allowing us to automatically prove properties of programs where we could not prove them before categories and subject descriptors d software engineering checking correctness proofs reliability d operating systems reliability verification f logics and meanings of programs specifying and verifying and reasoning about programs f logics and meanings of programs semantics of programming languages program analysis general terms verification theory reliability keywords linear temporal logic formal verification termination program analysis model checking introduction the common users and developers of tools that prove temporal properties of systems is that the linear specification logic ltl is more intuitive than ctl but that properties expressed in the universal fragment of ctl ctl without fairness constraints are often easier to prove than their ltl permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright © acm properties expressed in ctl without fairness can be proved in a purely syntaxdirected manner using statebased reasoning techniques whereas ltl requires deeper reasoning about whole sets of traces and the subtle relationships between families of them in this paper we aim to make an ltl prover for programs with performance closer to what one would expect from a ctl prover we use the observation that ctl without fairness can be a useful abstraction of ltl the problem with this strategy is that the pieces dont always fit together there are cases when due to some instances of nondeterminism in the transition system ctl alone is not powerful enough to prove an ltl property in these cases our ltl prover works around the problem using something we call decision predicates which are used to characterize and treat such instances of nondeterminism a decision predicate is represented as a pair of firstorder logic formulae a b where the formula a defines the decision predicates ie when the decision is made and b characterizes the binary choice made when this holds any transition from state s to state s in the system that meets the constraint is distinguished by the decision predicate a b from we use decision predicates as the basis of a partial symbolic procedure for each predicate we introduce a new variable to predict the future outcome of the decision after partially with respect to these variables we find that ctl proof methods succeed thus allowing us to prove ltl properties with ctl proof techniques in cases where this strategy would have previously failed to synthesize the decision predicates we employ a form of symbolic execution on spurious ctl counterexamples together with an application of lemma with our new approach we can automatically prove properties of programs in or seconds which were using existing tools examples include code fragments drawn from the database server the web server and the windows os kernel limitations in practice the applicability and performance of our technique is dependent on the heuristic used to choose new decision predicates when given an abstract representation of a specific point in a spurious counterexample the predicate synthesis mechanism implemented in our tool is applicable primarily to programs over arithmetic variables with commands that only contain linear arithmetic however no matter which predicate selection mechanism is used our strategy is sound thus unsound approximations to predicate synthesis could potentially be used in instances where the systems considered do not meet the constraints given above our technique is also based abadi and lamport make this point using the terminology of refinement mappings and trace equivalence instead of it in the context of temporal logics on an ctl prover for systems which itself cannot be complete a further limitation is that our procedure is not well suited for finitestate model checking the problem is that introducing variables greatly increases the number of elements required in usual finitestate encodings each variable must be capable of counting up to a number larger than the systems the problem is further when we introduce multiple variables as the nth variable must range over values as large as the of the system which has been augmented with the first n variables in contrast when using proof tools for systems the performance cost for adding additional variables is usually low finally our procedure depends on the full structure of counterexamples to ctl properties which are in the form of trees unfortunately with only a few exceptions tools do not return whole tree counterexamples related work our method more classical approaches in which fairness constraints are used to encode conditions and then language fair proved of the resulting system the difficulty with language emptiness for infinite state systems eg as implemented in previous work is that the mechanisms that allow us to ignore infinite executions not accepted by the fairness constraints are effectively the same as the expensive techniques used for proving termination thus in practice our previous tool relies too on termination proving machinery in contrast our new approach uses syntaxdirected techniques for ctl that depend much less on the performance of the underlying termination proving infrastructure however our strategy does rely on the assumption that on average the subtle that are tracked only in our approach do not occur frequently in cases where this assumption is not true the cost of inference of decision predicates may be higher than simply using traditional techniques we will see an example of this later in section it is well known that addresses the subtle semantic between and logics however for systems open questions still remain if we hope to develop a practical strategy a what to since complete does not lead to a automatic tool for systems and b how to in a way that the application of current formal verification tools we address these two questions in this paper others have considered this tradeoff between specifications and efficient verification procedures for example reduces ltl to ctl using additional fairness constraints this technique still relies on reasoning about fairness this is a sensible engineering choice for finitestate systems for the reasons discussed above but not for systems describes a method of translating an ltl formula into a semantically equivalent ctl formula however this leads to an exponential in the size of the ctl formula and requires a modification to the model checking algorithm identifies the subset of ctl called which is expressible in ltl for such formulae an ctl prover can be used by contrast our decision technique allows one to verify any ltl formula using proof techniques in such a way that performance is affected only in cases where tracking subtle between traces is actually required previous work has also examined different methods of representing systems in order to facilitate proving prove m l let c in while true do let m in match lm c with succeed return succeed fail let refine in if let in return fail else done figure algorithm based on predicate which implements ltl model checking ie m l l the procedures approximate refine and l are defined in later sections temporal properties or proving properties of abstractions eg pushdown systems when modelchecking is performed using techniques then the converse of our assumption is true traces are in fact more naturally explored than executions in this context our procedure uses several techniques found in the literature namely variables and lemma we are of course not the first to use these techniques in applications related to the one addressed here variables have been used for many years to resolve nondeterminism in proofs including some recent work our use of lemma is similar to its use in rank function synthesis and invariant generation algorithm our ltl proof procedure l is given in figure the algorithm is designed to iteratively find a sufficient set of decision predicates such that proof tools for ctl can be used to prove an ltl property l of the system m the algorithm is based on four procedures which are each defined in later sections of the paper · approximate section is a simple procedure which approximates an ltl formula with an analogous ctl formula in which universal operators are added in eg f becomes af and g becomes ag without loss of generality we assume that have been pushed to the atomic propositions of the formula · section takes a transition system and a set of decision predicates and returns a new partially system in which newly introduced variables are used to make about the valuations of the decision predicates in · refine section takes an ctl counterexample and in the case that represents multiple distinct paths through the system returns decision predicates which characterize the nondeterminism that distinguishes between the different paths in the case that represents only a single path through the system then refine returns · is an when m thus on the first iteration of the loop our procedure is to prove l via a simple approximation c together with the original system m when given a nonempty set of decision predicates builds m by the original transition relation of m with a relation that specifies the behavior of a variable for each decision predicate for any set of decision predicates if c holds then l also holds thus whenever we find a sufficient set of predicates to prove c we have proved l refine is used to determine if an found by l represents a real or something spurious at first there is a semantic gap between the two types of counterexamples are trees whereas are traces however if all of the paths through the counterexample represent the same path or its prefixes then any one of these paths is a counterexample to l in this case refine returns otherwise if represents more than one path in the program refine returns a nonempty set of new decision predicates example consider the ltl property which informally can be read for every trace of the system x will eventually become true and true the meaning of the analogous ctl property is slightly more operational on all paths from an initial state the system eventually reaches a state such that along all paths starting from this state x will be true and true for every transition system if holds then holds furthermore our experience leads us to believe that proving is often an efficient method of proving however consider the following program where represents nondeterministic choice x while skip x x while true skip in this case is valid but unfortunately is not is valid because for every individual program trace it is valid for example if a trace never leaves the loop at line then the property is valid because x before entering the loop for the traces that do leave the loop x will become true at the command on line and then remain true the ctl property is valid only if we can find a set of states that are eventually reached from the programs initial states such that holds in this case no such set of states exists and tools for ctl verification will return counterexamples to that have no relation to to the original property the of the problem is the nondeterministic choice between the transition from line to and the transition from line to when we are in the loop at line we cannot know if we will eventually leave the loop or not we when trying to decide if a state at location is the point at which x will be global true as it is only after considering a full program trace that we would know ie in this case we need to be looking at sets of traces not sets of states we now illustrate the procedure in figure on this example let l and m be the example program from above our procedure approximates l with c as we described above the program m does not respect the property c the counterexample to c in m is an infinite tree which can be represented as a finite graph of transitions between program locations n pc x n pc x skip n pc n pc in this graph pc indicates that the execution is at a state in which the program counter is at line our procedure uses refine to simultaneously symbolically simulate all possible paths through this graph and try to unify them into a single path through m in this case it would begin its execution by first pc and then pc after which it would discover that for all paths of the graph to represent the same path it must unify pc and pc which cannot be done thus in this case the ctl counterexample will be spurious to the ltl property and the decision predicate pc pc will be included in the refinement this decision predicate pc pc characterizes the choice when pc will pc or not notice also that in this particular case the predicates selected are over program locations but this is not true in general see example in section the procedure then uses to generate m which is effectively the cross product of m and a new transition relation which updates a new variable based on the valuations of the decision predicate pc pc s s s s s z s s we might try to express m in textual program code form as x while assume skip assume x x while true skip this new variable the outcomes of the decision predicate pc pc we initialize to be an integer for every given trace of the system the concrete number chosen at the command the number of instances of the transition before we see a transition the choice of a negative number eg represents the case where the execution will never see a transition ie nontermination whenever the program makes a transition it knows that because the made previously does not allow it the program also whenever we see a transition for we know that if we are going to see it at all we are one step closer to if and when a an additional decision predicate will also be returned by our procedure but it is not important for this example in later sections we use a special element instead of negative numbers to represent nontermination but for the purpose of this illustration negative numbers are easier transition finally occurs we know that the program then how many transitions will be visited the next time around until another transition which will never occur in this example because the old prediction is not needed again we can reuse the same variable for the new with the variable in place there is now a set of states where holds s s furthermore we can prove that this set of states is eventually reached so we can now use ctl where it previously failed on the second iteration of the procedure from figure no will be found in m and thus the ltl property l has been proved of m note that if we remove the second x command from the example then the property l is false in this case the variable will uniquely determine the number of iterations through the first loop and the counterexample returned will instead involve the second loop from this ctl counterexample we can construct a valid ltl counterexample in the later sections of this paper we define each of the used in figure ie approximate in section in section etc however before moving to these more detailed descriptions we must develop some terminology and definitions that will be shared later more details on any of our including a coq proof script can be found in our companion technical report states sets relations we assume a domain d of states and in the context of programs will often treat it as a mapping from variables v to values we will let s and t range over states and s represent a set of states we assume that no two states are r will often be used to represent relations when r is represented symbolically ie expressed as a formula it will be over the variables v and variables v for a state predicate p the meaning p s is defined as the set of concrete states that respect p the relational meaning of a formula p over and variables p r is defined in the usual way when it is clear from the context that we mean the real relation as opposed to the symbolic formula representation we will drop the r brackets the notations and mean the first and second projection respectively of a relation in cases where we are representing programs with controlflow graphs we will assume that states include a variable pc that represents the program counter and whose value is taken from a finite domain l n transition systems we define a machine m s r i where i s is the set of initial states and r s × s is the transition relation in this paper we will be constructing new systems by adding variables and them to their original versions thus it is convenient to build in a notion of internal and external state elements we assume that s × sin ie states consist of an external visible component and an internal component we refer to an individual state as s sin s and when a machine has no internal components we omit the brackets traces and paths we define a trace to be a sequence of states s sin s sin such that s sin i i si si r we denote r as the set of all such traces for convenience we do not allow finite traces ­ the transition relation must be such that every state s has at least one successor state this is ext l l l l l l l l l l l l l l l i i l l i i l l l gl l fl i i l l j j l l i ji l l l l wl figure semantics of ltl l s c c s c c s c c s c c s c s c c c s c c c s s ri s s si c c s c s s ri s s si c c s c s s r i si c c j sj c c i j si c c s c ac wc figure semantics of ctl c without a loss of generality as final states can be encoded as states that loop back to themselves in the transition relation with coinductive reasoning we can show that there exists an infinite trace from every state we use the notation ext to denote the projection of where internal components are removed s sin s sin ext s s is similarly defined we say that two systems are trace equivalent if their sets of traces are equivalent we define an abstract trace to be a sequence of state abstractions a path is a special case of an abstract trace in which only the are given a path or an abstract trace is spurious if there does not exist a concrete trace from which we can construct the path via a projection decision predicate vector formally we will treat as a vector of pairs each element in the decision predicate vector is a predicate pair denoted a b we will use the vector index i to refer to a particular pair within and ai bi denote the components of the ith pair we use the notation to indicate that s is in the set of states where ai holds ie s ai and similar for approximate proving ltl with ctl in this section we describe approximate which defines a sound overapproximation of ltl formulae with formulae in ctl linear temporal logic ltl we use the following ltl grammar l l l l l gl fl l wl we have not included u r x or ¬ without loss of generality we assume that appear only in atomic propositions ie instances of ¬ have been pushed to the leaves of the formula in the context of programs x is relatively useless and is easily subsumed by f u and r can be encoded as l ul fl l wl and l rl l wl l the ltl semantics l are given in figure the notation i indicates a suffix of a trace starting at the ith state in the sequence we use to denote the first element in the binds than the subscript ie i i an atomic proposition is from some abstract domain d and we assume that true false d and that d is closed under negation ie d d s ¬ s the operator gl specifies that l globally holds along all traces the operator fl specifies that along every trace eventually a suffix will be reached where l holds finally the l wl operator specifies that l holds forever or l holds until l holds the ltl entailment relation l is defined on traces the relation l l indicates that l holds for a given trace we now lift l to machines definition ltl machine entailment assume that m s r i we define m l l as r l l computation tree logic ctl we now review computation tree logic c c c c c ac wc the semantics of ctl c are given in figure unlike the ltl semantics semantics are statebased by this we mean that the temporal operators are statebased in structure the derivation of a given formula is and depends on the derivation of for subsequent states the operator specifies that c globally holds in all reachable future states the operator specifies that across all computation sequences from the current state that there is a reachable state in which c holds finally the ac wc operator specifies that c holds in every state where c does not hold yet definition ctl machine entailment as we did for l we lift c to machines assume m s r i we define m c c to be s i rs l l ltl with ctl we describe a simple syntactic conversion from a formula in ltl to its corresponding overapproximation in ctl definition approximate for all l approximate l l ag af w l w lemma ctl approximation for a machine m and ltl property l m c m l l proof by corresponding structural induction on the formulae and l we first c and l since traces is defined over i we are free to pick a state s i such that s c c we now pick a trace r and the appropriate case from the ctl semantics for example in the r i s r i where s s × n i i × n denoted s r s s s s r ai bi i i i i i i i n i i and n n figure the procedure which when given a vector of predicate pairs constructs the corresponding machine s c case the universal quantification tells us that for s s that c c by the inductive hypothesis for all r we have that l l and thus we have established the criteria for l fl for further details see our companion technical report decision predicate in this section we describe the procedure which uses decision predicates as it performs a symbolic form of partial partially machines figure contains the definition for which is designed to return a partially machine when given a vector of predicates and a machine m the new machine m includes additional variables denoted i these correspond to the predicate pairs ai bi in the vector in with i these variables are free to be a positive integer or zero or in the initial state we will see that the choice of initial values and the choice in from figure is the force behind for simplicity we used z instead of n in section we also now define the update relation differently than we did in section in the sense that in figure the variables appear only to the left of and variables appear only to the right while the two are equivalent the encoding in figure is conceptually more operational and easier to implement within a tools setting where in practice we are modifying the existing transition relation of m transitions in r are made in with r but constrained by the values of when states are reached that match a decision predicate ai bi in specifically when a state is reached where ai holds and the variable i then bi must hold in the next state and i is unchanged of figure this rule corresponds to behaviors where a state is visited infinitely often alternatively if i then bi must also hold in the next state except that i is when i reaches zero then must hold in the next state and i is free to take a new value from n starting the process all over finally when ai doesnt hold of a particular state i is unchanged the variables introduced here nondeterminism in the transition relation r for a larger nondeterministic state space the state space nondeterminism is either determined at ma initialization by the initial choice of values for given by i or else later in a trace by choosing new nondeterministic values for this lazy selection of nondeterministic values means that m consist of infinitely many variables for each predicate pair this formulation restricts us to treat programs with only countable nondeterminism one could of more powerful forms of nondeterminism but we intend to use this technique in the context of programs for which countable nondeterminism is sufficient theorem for all m m proof the theorem holds if each of the conditions p p p and p and pb described below are met these conditions are a variation of proposition from abadi and lamport conditions p p p and p directly match abadi and conditions we omit condition p as it involves liveness restrictions on the behavior of machines and we assume that our machines have no liveness restrictions we the restriction of abadi and p with pb detailed below as our variables do not respect the condition of finite nondeterminism the new condition pb is in fact a consequence of p in the second part of the proof abadi and lamport show that all the behaviors of m are contained within m note that regardless of p m because l true part defines a directed graph and then introduces claim which is not true in our setting however claim is only used in conjunction with claim and lemma in order to prove claim in our setting we have simply included claim as condition pb we now describe why each condition holds p p s s × sp i pi for some sp where p maps s × s onto s p if s p s by construction p of r r then from r s s r or s s this holds p if s s r and s p s then there exists p s such that s p s p r again this holds by construction of r case splitting on the value of p and over i pb for every s s r there exists p p such that s p s p r proof over each i consider all of the pos infinitely many transitions sj sj such that holds now for each transition may or may not hold this can be modeled by m ie a head m consisting of repeated instances of finitely many and a single and a tail consisting of infinitely many so we can choose i accordingly setting i m in each potentially zero or infinitely many instances of the head and setting i in the tail further details are available example nondeterministic choice consider the following machine s n n denoted x y i r in this transition relation there is nondeterminism in the first transition we can this with the predicates a x y and b x with these predicates we can construct the corresponding m s n n × n denoted x y i n r n n n the first two transitions have now been from the initial state depending on the initial choice of either x or ¬x will hold in the next state in this example since the nondeterministic transition only happens once the external behaviors when or in the initial state are all equivalent to in the initial state so for presentation purposes we have omitted them the additional behaviors will be used in the next example example termination consider the following system which we represent symbolically s n denoted x i n r x x x x x x x r in this transition relation when x initially there is nondeterminism in how many times the first transition is chosen before the second transition is chosen we can this with the predicates a x and b x constructing the corresponding m as follows s n × n i n × n r x x x x x x x x n x n x n r in m the first choice of how many times a transition from x x x r is taken is given by the choice of an initial value for any finite number of iterations corresponds to an arbitrarily chosen numeric value of the case where the transition is taken infinitely many times corresponds to the initial choice of for example running example for the example given in section the state space of the original program is s × denoted pc x for pc pc we have one variable denoted so s s × n and i × × n the transition relation some arcs is defined as follows r x pc x pc x pc x pc x pc x pc n r proving ltl with ctl and lemma shows that one can prove ltl properties with an ctl verifier and an transition relation we now extend this to show that one can prove perhaps even more ltl properties with ctl and a machine theorem ctl approximation with for a machine m ltl property l and predicates m c m l l proof lemma says that m c m l l the process of predicate constructs machine m from m such that m m since the two machines are trace equivalent and it is known that machines have the same lemma applies to the new machine and hence the theorem holds further details are available refine decision predicate refinement we now describe refine our procedure which counterexamples from a verification tool and predicates which characterize the nondeterministic branching within them if any nondeterminism exists ctl counterexamples counterexamples in ctl are trees the shape of the tree depends on the shape of the property which is violated while most tools typically do not annotate their counterexamples with they could be made to do so we formalize an ctl counterexample tree as follows definition ctl tree counterexample of of of × of × of × × of × × in the above definition there is a constructor for each structural element of an ctl formula a counterexample to an atomic proposition is a single state trace where the atomic proposition does not hold of the first element a counterexample to a conjunction is a counterexample to one of the conjuncts a counterexample to a disjunction is of two counterexamples one for each disjunct a counterexample is a path to a state in which a counterexample exists for the a counterexample is a path to an infinite loop where a counterexample exists for the a counterexample is a path to a state where a counterexample exists for both for example the counterexample to the property consists of a and loop for the af and from within the loop a for each ag equality between counterexamples is inductively defined lifting equality between traces we denote by ext the counterexample which consists of the external projection of paths in all components often counterexamples from model checking tools may contain less information than actual concrete traces eg slam returns abstract traces that include the valuations of pc together with the valuations of the predicates used during the failed proof attempt in the af rule the counterexample is represented as a with an path along which every subtree is a counterexample to the in not all counterexamples to termination can be represented this way there are some programs that do not terminate but whose counterexamples cannot be represented as a path for example while x y x x x while y y y r a b a ¬b such that r a b r and r a ¬b r if no such a b exist figure specification of which when given symbolic representations of two relations returns predicate pairs that distinguishes them an implementation of this procedure is described in section refine s n n let in while true do let n n n n n r n in let t r n n nn r n in let r in if then if n s s then return else n n s s n else return done figure the refine procedure down a counterexample flowgraph at each step simultaneously exploring all possible next steps if any pair of possible next steps are via a predicate from then that predicate is immediately returned match with s n id n nx n n n nx where nx n are fresh nx ni r ni i i i r r where each ni is fresh and nx n figure the procedure a counterexample and constructs a counterexample flow graph using to convert a path to a graph component in this case we assume an approximation of the real counterexample has been found and has been encoded using in some instances this could potentially lead to divergence in our tool counterexample controlflow graphs from a given counterexample we can construct a corresponding counterexample flowgraph which represents all paths in the counterexample we use a standard notation where nodes n n correspond to states in the counterexample and edges are triples n r n consisting of a starting node a transition relation r from the counterexample and a destination node even when we are working with programs these are different from program cfgs because they represent possible state transitions there may be multiple transitions for a single cfg transition eg when the program involves nondeterministic assignment and there maybe multiple nodes which have the same cfg node a counterexample flow graph can be constructed from a counterexample via the translation shown in figure predicate synthesis the procedure r is specified in figure it two transition relations r r and returns two pairs of decision predicates both a b and a ¬b we return both pairs because it is difficult to know a priori which will be more useful to the ltl proving procedure as the information tracked by a b differs slightly from that tracked by a ¬b moreover there are cases where tracking only a b will result in divergence whereas a ¬b does not the details of the implementation of will differ depending on the context ie finitestate systems expressed at the systems expressed over linear arithmetic etc we assume that for a given domain d a that d is capable of distinguishing two states and b that is capable of discovering sufficient elements in d to do so if these assumptions do not hold then in some instances our technique may be unable to sufficiently in our implementation described in section we use techniques to find predicates which are over linear inequalities symbolic tree execution the recursive procedure refine given in figure an ctl counterexample and returns a set of predicates which distinguish nondeterministic branching this involves first constructing a counterexample flowgraph and iteratively exploring the frontier refine simultaneously steps down each possible branch of the counterexample ensuring that all of the next states are equivalent using see the specification in figure to find distinguishing predicates when distinct states are found the corresponding predicates are returned so that they can be added to and the main algorithm can progress we now show that for a given counterexample if refine predicates then our algorithm produces a new machine for which ext is not a counterexample we also show that if no predicates are found by refine then a real counterexample to the original ltl property can be constructed from ext lemma counterexample elimination for a machine m property l if is a counterexample to m c then counterexample to m c such that ext ext where refine and refine proof let ai bi refine by definition of refine in figure this predicate pair must have come from a of the counterexample flow graph of the form n r n n r n moreover and now in the new machine the vector is augmented with a new element i so the set of states denoted r have either i or i according to r either r r is enabled or else r r is enabled but not both hence there is no valid counterexample such that ext ext further details are available remark on completeness there are a few to making a completeness claim first for a given ctl counterexample the routine must be able to discover predicates to characterize nondeterminism in however since we use approximation eg with linear arithmetic it will not always be able to discover sufficient predicates when they exist second even when we have a perfect routine some ctl counterexamples may be spurious as the underlying ctl also supports only overapproximation in linear arithmetic consequently when refine we cannot necessarily claim that we have a valid ltl counterexample furthermore as mentioned previously there are some nonterminating programs that do not have a path in these instances the ctl tool itself will either or return spurious counterexamples finally it is whether our refinement loop will discover a finite number of decision predicates with an infinite predicate vector all nondeterminism can be represented given a sufficient predicate domain but one would hope that for each there is a finite predicate vector example running example for the example in section an ctl prover may generate the following counterexample where a state is represented as pc x from this counterexample we use to construct the counterexample flowgraph given in section each arc represents a possible transition within the counterexample tree the procedure refine then all possible paths of the controlflow graph simultaneously starting from the first node as follows iteration n n s iteration n n s nn iteration n nn s after the first and second iterations does not discover a predicate to distinguish the two branches but after the third call to refine the predicate pairs pc pc and pc pc are discovered which distinguish paths that remain in the loop or exit the loop a new machine is then constructed with variables corresponding to these decisions and for this new machine an ctl verifier can prove that the property holds example consider the following program for which we would like to prove l fg y f x t x y t while x t if xt y while true skip the machine representing this program can be encoded as follows x x y y t t pc pc id x i d pc x x y y t t pc pc id x i d id id id figure counterexamples for each of the three iterations of proving example the notation id indicates the identity transition arising from the loop at line n n n n n n first iteration n n n n n n n second iteration n n n n n n n n n n third iteration figure the counterexample flow graphs that are constructed at each iteration of proving example s n n n denoted x y t l pc i n r pc pc x x y y t t pc pc x x y y t t pc pc x x y y t t pc pc x x y y t t pc pc x x y y t n pc pc x t x x y y t t pc pc x t x x y y t t pc pc x x y t t pc pc x x y y t t r using an ctl prover we may obtain the first counterexample in figure from this counterexample we use to construct the first counterexample flow graph in figure each arc represents a possible transition within the counterexample tree the procedure refine then all possible paths of the controlflow graph simultaneously starting from n as follows iteration n n s in this iteration refine finds that n nn and that r taking the only pair of relations from r generates the predicate pairs pc pc and pc pc corresponding variables are created and the ctl verifier is used on the newly constructed machine resulting in the next counterexample in figure we then get the second counterexample flow graph in figure and the refine it as follows iteration n n s iteration n nn s after the first iteration does not discover any predicates to distinguish the two branches but after the second iteration the predicate pairs pc pc and pc pc are discovered which distinguish paths that remain in the loop or exit the loop the ctl verifier is executed once again resulting in the third counterexample in figure the counterexample flowgraph is given in figure and refine it as follows iteration iteration iteration iteration n n n nn n nn n nn s s s s in the final iteration the predicate pairs pc t x and pc t x notice that the second predicate is over a program variable other than pc ­ in the next example we will see that pc is not always sufficient to distinguish paths running the ctl verifier one more time yields no counterexamples hence the original ltl property holds example in the examples above almost all predicates were over the program counter variable pc in many cases the program counter serves as a convenient way of distinguishing paths through the program however this is not always the case consider proving the property g x f x for the following program x x x x skip the notation represents nondeterministic choice between or the ltl property holds because in traces where this nondeterministic choice is always the property g x holds for any trace in which the nondeterministic choice is the property f x holds we shall represent the state as x where x n an ctl prover will generate the following counterexample to ag x af x i d for this counterexample refine would explore the corresponding and discover the decision predicate pairs x x and x x which distinguish the transition from importantly there is no predicate over the program counter variable alone which distinguishes these two transitions we can now synthesize a variable corresponding to this decision predicate and an ctl prover will discover a proof of the ctl property that the original ltl property holds implementation in this section we discuss some details of our implementation of the algorithm in figure our implementation of an ctl prover and the results of our tool when applied to example programs predicate synthesis in section we have assumed the existence of a predicate synthesis mechanism that met the constraints given in figure r a b a ¬b such that r a b r and r a ¬b r if no such a b exist depending on the configuration of the systems considered by the tool will need to be implemented in different ways here we describe a particular method of synthesizing predicates for counterexamples drawn from the style of programs typically accepted by modern model checking tools for programs as is true in many symbolic model checking tools for software we will assume that counterexamples are sequences of commands drawn from a path in the program we will assume that these commands are over a finite set of arithmetic variables and that the conditional checks and assignment statements only use linear arithmetic given this context an implementation can represent the relations passed to as conjunctions of inequalities using variables for example the command sequence x x y x which might represent a piece of a counterexample can be represented as a relation from valuations on x y pc to valuations on x y pc where x x y y pc pc x x x x y y y y x x x y x we can reduce the search for predicates in this setting to the search for functions satisfying a set of constraints in this instance we hope to find families of affine functions f and g such that the following conditions are true v r v r r r the set of common to both relations r and r are given s v r v r ie we are existentially out the by out the variables that are used to represent them we then find an overapproximation of s that is expressible as the conjunction of inequalities using f the second and third constraints force the function is expressed only over the distinguish between two transitions as done elsewhere we can apply lemma and an smt solver eg z or to find linear functions fi and gi that satisfy the above constraints thus to implement r we find families f and g satisfying the above constraints we then return the predicate pairs a b and a ¬b where a and b a witness to v r v r can be computed using a quantifier elimination procedure or alternatively an additional application of lemma in practice however a good guess is simply to take the valuation of pc from both r and r ie s pc where r pc and r pc proving ctl for systems we use ctl verification tool for programs described elsewhere our ctl prover works by reducing the task of ctl verification via a program transformation to an interprocedural program analysis problem thus we can use known safety analysis tools combined with techniques for refining termination arguments to obtain an ctl verification tool whose power is limited only by the power of these underlying tools the transformation uses recursion and nondeterminism in such a way that when these tools are applied to the transformed program they effectively perform the necessary reasoning eg backtracking checking tree counterexamples abstraction etc to prove behaviors of the original program formally our transformation t works as follows for a program p and an ctl property c m t p m c cannot return false p c c where m is assumed to be a finite set of wellfounded relations the new program t p m c is constructed by recursively the structure of c instances of is syntactically decomposed into proving termination to a set of states in which p holds can be decomposed into checking that p holds at each line of the program etc m can be thought of as the argument of progress when proving c once a suitable set m has been found proving that t p m c cannot return false can be accomplished with existing interprocedural analysis tools satisfying instances of m can be found using the same technique as is used in in our implementation we use slam as the underlying safety prover and as the method of finding new ranking functions f from spurious counterexamples experiments we have drawn out a set of ltl challenge problems from code bases examples were taken from code models of the io subsystem of the windows kernel the infrastructure of the database server and the web server we also include a few examples as well as the example from figure in further details on our benchmarks including sources are available in our companion technical report in many cases from the original sources have been abstracted away using the approach due to et al this abstraction introduces new arithmetic variables that track the sizes of recursive predicate found as a of a successful memory safety analysis using an abstract domain based on separation logic this abstraction also may introduce extra nondeterminism into the transition relation which in more complex cases may force our method to synthesize decision predicates program example from section example from fig of example linear linear accept liveness progress windows os fragment windows os fragment windows os fragment bug windows os fragment windows os fragment windows os fragment windows os fragment windows os fragment windows os fragment bug windows os fragment windows os fragment loc property gp fq gp fq p fq p fq gp gp gp gp fq gp gp fq fq gp fq gp fq fa fb gp fq fair termination tool time s m result to to to to to to to to decision predicates tool figure time s m result to table comparison of fair termination based ltl prover to decision predicate based algorithm from figure examples drawn from database server web server as well as the io subsystem of the windows os the property column indicates the shape of the temporal properties where p and q are atomic propositions specific to the program a indicates that the tool has proved the property whereas a indicates that a valid ltl counterexample has been found indicates the number of decision predicates needed and m the number of progress measures required to indicates that the experiment out after and in such cases we specify at least how many termination arguments were needed denoted the only previously known tool for automatically proving properties of programs is described in which is a procedure with an extension for fairness is used to convert ltl formulae to bu¨chi automata as we have done in our implementation of figure the implementation of uses slam as the underlying safety model checker and as the rank function synthesis tool table reports the results of our experiments the first column describes the code we added bugs into several of the examples the second column loc reports the number of lines of code for each example we studied the results for properties of shapes eg gp f q etc experiments were run using windows and an intel processor for both tools we report the total time the number of ranking functions required denoted m and the result for each of the benchmarks a indicates that the tool proved the property and is used to denote cases where bugs were found in the case that the tool the timeout threshold of to is used to represent the time the result is listed as and we simply report the current size of m at the time that the tool was together with a symbol for our approach we report the number of decision predicates required for these examples relatively few variables are usually required this our assumption that faster techniques usually work so long as we have a fast method for evaluating the potential of ctl counterexamples and an effective strategy of refinement when ctl methods fail we also observe that m is typically smaller when using the decision predicates based tool we implemented support for fairness in our decision predicate based approach tool in order to support figure of this is due to the fact that one of the fairness constraints actually comes from an environment assumption and thus must still be modeled our support for fairness uses essentially the same as given in combined with the transformation as mentioned in section a limitation to our approach is that there are cases when we see a minor performance for our strategy of only tracking on demand eg in windows os fragment we also see some minor overhead when computing real counterexamples eg in windows os fragment bug the most aspect of table is the overall result our decision predicate based ltl prover was able to all but example in usually a fraction of a whereas the fair termination based tool fails on nearly a of the benchmarks this is due to our strategy of first trying to use ctl proof strategies and only tracking subtle relationships between families of traces on demand using decision predicates without our approach we could not use an proof strategy with precision equal to native approaches in each of these to cases but one our decision predicate based tool proves all of the examples with reasonable resulting in a furthermore our tool reported no spurious counterexamples in the cases where a purely approach would have been incomplete for ltl resulting in a spurious counterexample our refinement procedure quickly found and then symbolically the problematic nondeterminism into the of the system conclusion we have described a new algorithm for proving ltl properties of systems our algorithm searches for instances of nondeterminism that the use of proof methods we characterize these instances of nondeterminism using decision predicates and then symbolically shift them into the using a procedure the advantage to this approach is that ctl proof methods can be used where they would have previously failed we find in practice that most instances of nondeterminism is to ctl proof methods thus in many cases we see performance improvements when using this strategy acknowledgments we thank berdine peter ohearn matthew parkinson and yang for their comments and discussions provided several of the examples from table we also thank the cambridge program for phd references the z theorem prover abadi m and lamport l the existence of refinement mappings theoretical computer science ­ p a b m j and m regular model checking for in cav ball t e cook b v j c b rajamani s and a static analysis of device drivers acm operating systems review a a and p handling liveness properties in regular model checking electronic notes in theoretical computer science ­ a manna z and h termination of polynomial programs in a r manna z and h b linear ranking with reachability in cav j clarke e k d and l symbolic model checking to the states and beyond information and computation clarke e emerson e and a automatic verification of finitestate concurrent systems using temporal logic specifications toplas clarke e o s lu y and h counterexampleguided abstraction refinement for symbolic model checking jacm clarke e o and d model checking springer clarke e s lu y and h counterexamples in model checking in lics clarke e m o and k another look at ltl model checking form methods syst des ­ cook b a podelski a rybalchenko a and m y proving that programs eventually do something good in popl cook b and e making with decision predicates tech rep university of cambridge computer laboratory jan cook b e and m reasoning for programs tech rep university of cambridge computer laboratory jan cook b podelski a and rybalchenko a termination proofs for systems code in pldi cousot p cousot r j l a d and x the analyzer in esop b and de l m a fast solver for in cav t ball and r b jones eds vol of lncs springer pp ­ j a and s modelchecking ltl with regular valuations for pushdown systems in y n pnueli a and l liveness with ranking international journal on software tools for technology transfer ­ j der journal ­ p and d fast ltl to bu¨chi automata translation in cav july k and t model checking java programs using java international journal on software tools for technology transfer ­ henzinger t a jhala r majumdar r necula g c g and w proofs for systems code in cav a appel a w and f z oracle semantics for concurrent separation logic in esop g j the model checker ieee trans software ­ m g and d probabilistic symbolic model checker lncs ­ s berdine j clarke e and cook b arithmetic strengthening for shape analysis lncs m the common fragment of ctl and ltl in s and m branching vs linear time perspective in pnueli a the temporal logic of programs in th annual symposium on foundations of computer science ieee pp ­ pnueli a and a psl model checking and runtime verification via in fm j t and e eds vol of lncs springer pp ­ podelski a and rybalchenko a a complete method for the synthesis of linear ranking functions lncs ­ podelski a and rybalchenko a transition invariants in lics pp ­ podelski a and rybalchenko a the logical choice for software model checking with abstraction refinement in qadeer s a and s back and variables for static verification of concurrent programs tech rep microsoft s on the complexity of automata in s h and manna z analysis in sas k model checking on product structures v and a liveness checking as safety checking for infinite state spaces in workshop on verification of systems a k m and g using language inference to verify properties in tacas m branching time vs linear time final in tacas m y and p an approach to automatic program verification preliminary report in lics 