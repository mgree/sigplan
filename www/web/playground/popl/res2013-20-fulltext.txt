library abstraction for cc concurrency mark university of cambridge university of york software institute abstract when constructing complex concurrent systems abstraction is programmers should be able to reason about concurrent libraries in terms of abstract specifications that hide the implementation details relaxed memory models present substantial challenges in this respect as libraries need not provide sequentially consistent abstractions to avoid unnecessary synchronisation they may allow clients to observe relaxed memory effects and library specifications must capture these in this paper we propose a criterion for sound library abstraction in the new c and c memory model the standard sequentially consistent notion of linearizability we prove that our criterion soundly captures all interactions both through call and return values and through the subtle synchronisation effects arising from the memory model to illustrate our approach we verify implementations against specifications for the lockfree stack and a queue ours is the first approach to compositional reasoning for concurrent cc programs categories and subject descriptors d software engineering verification f logics and meanings of programs specifying and verifying and reasoning about programs general terms languages theory verification keywords verification concurrency modularity c c introduction software developers often functionality in libraries and construct complex libraries from simpler ones the advantage of this is information hiding the need not understand each implementation but only its more abstract specification on a sequential system a internal actions cannot be observed by its client so its specification can simply be a relation from initial to final states of every library invocation this does not suffice on a concurrent system where the invocations can overlap and interact with each other hence a concurrent specification is often given as just another library but with a simpler eg atomic implementation the two libraries are called concrete and abstract respectively a specification means showing that the simpler implementation abstracts the more complex permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm one ie all its behaviours library abstraction has to take into account a variety of ways in which a client and library can interact including values passed at library calls and returns the contents of shared data structures and in this paper the memory model the memory model of a concurrent system what values can be returned when the system reads from shared memory in a traditional sequentially consistent sc system the memory model is straightforward there is a total order over reads and writes and each read returns the value of the most recent write to the location being accessed however modern processors and programming languages provide relaxed memory models where there is no total order of memory actions and the order of actions observed by a thread may not agree with program order or with that observed by other threads in this paper we propose a criterion for library abstraction on the relaxed memory model defined by the new c and c standards the c model we handle the core of the c memory model leaving more features such atomics and as future work see § the c model is designed to support common compiler optimisations and efficient compilation to architectures such as x power arm and which themselves do not guarantee sc it gives the programmer finegrained control of relaxed behaviour for individual reads and writes and is defined by a set of axiomatic constraints rather than operationally both of these properties produce subtle interactions between the client and the library that must be for in abstraction our criterion is an evolution of linearizability a abstraction criterion for systems like linearizability our approach satisfies the abstraction theorem if one library a specification abstracts another an implementation then the behaviours of any client using the implementation are contained in the behaviours of the client using the specification this result allows complex library code to be replaced by simpler specifications for verification or informal reasoning hence it can be viewed as giving a proof technique for contextual refinement that avoids considering all possible clients our criterion is compositional meaning that a library consisting of several smaller libraries can be abstracted by considering each separately when restricted to the sc fragment of c our criterion implies classical linearizability but not vice versa the proposed criterion for library abstraction gives the first sound technique for specifying c and c concurrent libraries to justify its we have applied it two typical concurrent algorithms a nonblocking stack and an queue to do this we have adapted the standard linearization point technique to the axiomatic structure of the c model these case studies represent the first step towards verified concurrent libraries for c and c technical challenges apart from the complexity of the c model defining a criterion for library abstraction requires us to deal with several challenges that have not been considered in prior work first the c memory model is defined whereas existing techniques for library abstraction such as linearizability have focused on operational models to deal with this we propose a novel notion of a history which records all interactions between a client and a library histories in our work consist of several partial orders on call and return actions this is in contrast to variants of linearizability where histories are linear sequences for this reason in the following we avoid the term linearizability we define an abstraction relation on histories as inclusion over partial orders and lift this relation to give our abstraction criterion for libraries one library abstracts another if any history of the former can be in abstracted form by the latter second c offers the programmer a range of for concurrently accessing memory each with different tradeoffs between consistency and performance these choices can affect other memory accesses across the particular choice of consistency level inside the library might force or reading certain values in the client and vice versa this is an intended feature it allows c libraries to define synchronisation constructs that offer different levels of consistency to clients we propose a method for constructing histories that captures such interactions uniformly the abstraction theorem that our histories indeed soundly represent all possible interactions finally some aspects of the c model conflict with abstraction most the model permits satisfaction cycles in satisfaction cycles the effect of actions executed down a conditional branch is what causes the branch to be taken in the first place this breaks the straightforward assumption that are confined to either client or library code a client can cause in a library which can in turn cause the original client for these reasons we actually define two distinct library abstraction criteria one for general c and one for a language without the feature leading to satisfaction cycles the former requires an a priori check that the client and the library do not access each others internal memory locations which compositionality the latter this restriction for a c model modified to admit incomplete program runs and thus provides evidence that satisfaction cycles are to blame for behaviour our results thus corner cases in c that abstraction and may future of the model as we argue in § many of the techniques we developed to address the above challenges should be applicable to other models similar to c structure in the first part of the paper we describe informally how algorithms can be expressed and specified in the c memory model § and our abstraction criteria § we then present the model formally § and § followed by the criteria § and a method for establishing their requirements § proofs are given in an extended version of the paper c concurrency and library specification in this section we explain the form of our specifications for c concurrent libraries together with a brief introduction to programming in the c concurrency model itself as a running example we use a version of the nonblocking stack algorithm implemented using the concurrency primitives in the subset of c that we consider figure a shows its specification and figure b its implementation which we have proved to correspond § and for readability we present examples in a instead of the actual cc syntax several important features are in are explained below specification implementation atomic seq s struct node int data node next atomic node t void init void init void v seq s s if while atom sec s s void v node x t x new node v do t t while int pop seq s if while s if s empty return empty return heads a int pop node t x do t if t null return empty x while return b figure the stack for simplicity we let pop leak memory the cases in the specification always succeed stack specification as noted in § specifications are just alternative library implementations that have the advantage of simplicity in exchange for or nondeterminism the specification in figure a represents the stack as a sequence abstract data type and provides the three expected methods init push and pop a correct stack implementation should provide the of atomicity of operations to concurrent threads we specify this by the bodies of push and pop in atomic sections denoted by atomic sections are not part of the standard c specification purposes we have extended the language with a prototype semantics for atomic section § both push and pop may nondeterministically diverge as common stack implementations allow some operations to in concurrency they are lockfree but not all these are the expected features of a specification on an sc memory model we now explain the features specific to c the sequence s holding the abstract state is declared atomic in c programs must not have data races on normal variables any location where races can occur must be explicitly identified as atomic and accessed using the special commands load store and cas the latter combines a load and a store into a single operation executed atomically a cas takes three arguments a memory address an expected value and a new value the command atomically reads the memory address and if it contains the expected value updates it with the new one due to our use of atomic sections the cases in the specification always succeed we use cases here instead of just stores because for subtle technical reasons the latter have a stronger semantics in c than our atomic sections see release sequences in the load and store commands are annotated with a memory order that determines the tradeoff between consistency and performance for the memory access cases are annotated with two memory orders as they perform both a load and a store the choice of memory orders inside a library method can indirectly affect its clients and thus a library specification must include them in the stack specification several memory operations have the memory orders denoted by the subscripts rel for stores and for loads to explain its effect consider the following client using the stack according to a typical idiom int a b x do x a pop while ba the first thread writes into x and calls the second thread the address of x from the stack and then reads its contents in general a relaxed memory model may allow the second thread to read instead of eg because the compiler x and the annotations guarantee that this is not the case when the load of s in pop reads the value written by the rel store to s in push the two commands we define this notion more precisely later but informally it means that the ordering between the rel store and load the values by reads from other locations such as the read a in the client to enable this idiom the specification only needs to from pushes to it need not from to pushes or from to to avoid unnecessary synchronisation the specification uses the relaxed memory order this order is weaker than meaning that the set of values a relaxed load can read from memory is less constrained additionally relaxed loads and stores do not with each other however relaxed operations are very since they compile to basic loads and stores without any additional hardware barrier instructions hence the specification allows implementations that are efficient yet support the intended use of the stack for message passing on the other hand as we show below it allows stack behaviours stack implementation figure b gives our implementation of the stack the stack is represented by a linked list of nodes accessed through a pointer t only the latter needs to be atomic as it is the only point of contention among threads the push function repeatedly reads from the top pointer t a newly created node x to point to the value read and tries to t to point to x using a cas pop is implemented similarly for simplicity we let pop leak memory like the specification the implementation avoids unnecessary hardware synchronisation by using the relaxed memory order however the load of t in pop is annotated since the command x accesses memory based on the value read and hence requires it to be up to date what does it mean for the implementation in figure b to meet the specification in figure a as well as returning the right values it must also implement the correct synchronisation to understand how this can be we must therefore explain how synchronisation works in cs semantics c model structure the c memory model is defined an execution of a program consists of a set of actions and several partial orders on it an action describes a memory operation including the information about the thread that performed it the address accessed and the values written andor read the semantics of a program is given by the set of executions consistent with the program code and satisfying the axioms of the memory model see figure for a of these here is a program with one of its executions whose outcome we explain below store sb sb rf rf sb note that in diagrams representing executions we omit thread identifiers from actions several of the most important relations in an execution are · sb a transitive and relation ordering actions by the same thread according to their program order · ib ordering initial writes to memory locations before all other actions in the execution above we have shown ib by a dotted line the two kinds of actions · rf relating reads r to the writes w from which they take their values w rf r · happensbefore hb showing the precedence of actions in the execution in the fragment of c that we consider it is transitive and happensbefore is the key relation and is the the c model has to the notion of a global time in an sc model a read must not read any write to the same location related to it in hb other than its immediate predecessor thus for writes w and w and a read r accessing the same location the following shapes are forbidden w hb w hb r rf r h hb w rf rd however in contrast to an sc model hb is partial in c and some reads can read from writes we might have w rf r but not w hb r memory orders by default memory reads and writes in c are nonatomic na the memory model guarantees that free programs with only nonatomic memory accesses have sc behaviour a data race occurs when two actions on the same memory location at least one of which is a write and at least one of which is a nonatomic access are in happensbefore and thus intuitively can take place at the same time hence programmers who write code that is free from both data races and atomic accesses need not understand the details of the relaxed memory model data races are considered resulting in undefined behaviour for the whole program the three main atomic memory orders from least to most restrictive are relaxed and sequentially consistent we have already seen the first two in the stack example above the third sequentially consistent sc does not allow relaxed behaviour if all actions in a program are either nonatomic or sc the program only behaviour however the sc memory order is more expensive the weakest memory order relaxed a number of as the c model places very few restrictions on which write a relaxed read might read from for example consider the sb this is a of the relation from the c model to programs without dynamic thread creation to which we restrict ourselves in this paper see § atomics and are left for future work see § we also omit some c that are orthogonal to abstraction see § example above the outcome shown there is allowed by c but cannot be produced by any interleaving of the threads actions c it if all memory accesses are annotated as sc the memory orders allow more relaxed behaviour than sc while still providing some guarantees consider the following execution of the client of the stack in figure a or b we have seen above message passing mp ib int a b x x do while sb call sb sb ba ret rf sb here is a combined action produced by a cas in this case the load in pop with the rel store part of the cas in push that it reads from this informal notion of synchronisation we mentioned above is in the memory model by including the corresponding rf edge into hb then since sb ib hb and hb is transitive both writes to x happen before the read hence by rd the read from x by the second thread is forced to read from the most recent write ie if all the memory order annotations in the stack were relaxed the second thread could read from x instead furthermore without synchronisation there would be a data race between the nonatomic write of x in the first thread and the nonatomic read of x in the second the memory orders only between pairs of reads and writes but do not impose a total order over memory accesses and therefore allow behaviour for example if we annotate writes in sb with rel and reads with then the outcome shown there will still be allowed each load can read from the without generating a cycle in hb or rd we can also get this outcome if we use push and pop operations on two instances of the stack from figure a or b instead of load and store thus both the implementation and the specification of the stack allow it to have behaviour to very roughly allows writes to be delayed but not while relaxed allows both relaxed actions produce even behaviour including what we call satisfaction cycles satisfaction cycle if a if b sb rf rf sb here each conditional satisfies its guard from a later write in the other thread this is possible because relaxed reads and writes do not create any happensbefore ordering and thus neither read is constrained by rd unlike relaxed does not allow satisfaction cycles if the loads and stores in the example were annotated then both rf edges would also be hb edges this would produce an hb cycle which is by the memory model satisfaction cycles are known to be a problematic aspect of the c model as we show in this paper they also create difficulties for library abstraction library abstraction informally histories our approach to abstraction is based on the notion of a history which records all interactions between the client and the library in a given execution clients and libraries can affect one another in several ways in c most straightforwardly the library can observe the parameters passed by the client at calls and the client can observe the return values therefore a history includes the set of all call and return actions in the execution however clients can also observe synchronisation and other effects inside a method these more subtle interactions are recorded by two kinds of partial order guarantees and synchronisation internal to the library can affect the client by forcing reads to read from particular writes for example in mp from § the client is forced to read from x because the push and pop methods internally in a way that generates an hb ordering between the call to push and the return from pop if the methods did not the client could read from either of the writes to x the client can thus observe the difference between two library implementations with different internal synchronisation even if all call and return values are identical to account for this the guarantee relation in a history of an execution records hb edges between library call and return actions even behaviour inside the library can sometimes be observed by the client for example the c model requires the existence of a total order mo over all atomic writes to a given location this order cannot go against hb but is not included into it as this would make the model much stronger and would efficient compilation onto very weak architectures such as power and arm now consider the following dn sb call forbidden library mo library ret sb in this execution a write internal to the invocation of in the second thread is after a write internal to the invocation of in the first thread this the client from reading from x to see this suppose the contrary holds then the load with the rel store of yielding an hb edge by transitivity with the client sb edges which are included in hb we get an hb edge from ret in the second thread to call in the first together with the sb edges this yields an hb edge going against the mo one which is by the memory model to account for such interactions the relations in a history of an execution record hb or other kinds of edges between return and call actions that the client cannot enforce due to the structure of the library eg the from ret to call above abstraction in the presence of relaxed atomics as we noted in § we actually propose two library abstraction criteria one for the full memory model described in § and one for programs without relaxed atomics we discuss the former first two library executions with the same history are observationally equivalent to clients even if the executions are produced by different library implementations by defining a sound abstraction relation over histories we can therefore establish abstraction between libraries to this end we need to compare the histories of libraries under every client context fortunately we need not examine every possible client it suffices to consider behaviour under a most general client whose threads repeatedly invoke library methods in any order and with any parameters executions under this client generate all possible histories of the library and thus represent all interactions with an important discussed below we write l i for the set of executions of the library l under the most general client starting from an initial state i initial states are defined formally in § but informally record actions such as the ones shown in sb the set l i gives the denotation of the library considered in isolation from its clients and in this sense defines a semantics of l this semantics allows us to define library abstraction we now quote its definition and formulate the corresponding abstraction theorem introducing some of the concepts used in them only informally this lets us their most important features that can be discussed independently of the we fill in the missing details in § after we have presented the c model more fully for the memory model with relaxed atomics a history contains one guarantee and one relation definition a history is a triple h a g d where a is a set of call and return actions and g d a × a library abstraction is defined on pairs of libraries l and sets of their initial states i it relies on a function extracting the history from a given execution of a library which we lift to sets of executions pointwise the notation l r and the notion of safety are explained below definition for histories a g d and a g d we let a g d a g d if a a g g and d d for safe l i and l i l i is abstracted by l i written l i l i if for any relation r containing only edges from return actions to call actions we have i i h history l r i i i h history l r i h h the overall shape of the definition is similar to that of linearizability on sc memory models any behaviour of the concrete library l relevant to the client has to be by the abstract library l however there are several things to note first we allow the execution of the abstract library to less than the concrete one but require it to provide the same guarantee intuitively we can the because this only allows more client behaviours second we do not consider raw executions of the most general client of l and l but those whose happensbefore relation can be extended with an arbitrary set r of edges between return and call actions without the axioms of the memory model l r i and l r i denote the sets of all such extensions the set r represents the happensbefore edges that can be enforced by the client such happensbefore edges are not generated by the most general client and in the presence of relaxed atomics have to be considered explicitly this is the to its generality referred to above we consider only edges as these are the ones that represent synchronisation inside the client similarly to how edges in the guarantee represent synchronisation inside the library cf mp the definition requires that if an extension of the concrete library is consistent with r then so must be the matching execution of the abstract one finally the abstraction relation is defined only between safe libraries that do not access locations internal to the client and do not have such as data races as we show in § the specification of the stack in figure a abstracts its implementation in figure b abstraction theorem we now formulate a theorem that states the correctness of our library abstraction criterion we consider programs cl with a single client c and a library l the case of multiple libraries is considered in § the abstraction theorem states that if we replace the implementation library l in a program cl with another specification library l abstracting l then the set of client behaviours can only increase hence when reasoning about cl we can soundly replace l with l to simplify reasoning in the theorem cl i gives the set of executions of cl from initial states in a set i combines the initial states of a client and a library and selects the parts of executions generated by client commands we call cl i if c and l do not access each others internal memory locations in executions of cl from initial states in i the notion of safety for cl is analogous to the one for libraries theorem abstraction assume that l i l i cl i i are safe cl i i is and l i l i then cl i i is safe and client cl i i client cl i i the requirement of noninterference is crucial because it ensures that clients can only observe library behaviour through return values and effects rather than by opening the box and observing internal states the of theorem is that it requires us to establish the noninterference between the client c and the concrete library l eg via a type system or a program logic proof as we show below we cannot weaken this condition to allow checking noninterference on the client c using the abstract library l as is standard in data refinement on sc memory models this makes the reasoning principle given by the theorem less compositional since establishing noninterference requires considering the composed behaviour of the client and the concrete what library abstraction is intended to avoid however this does not kill compositional reasoning completely as noninterference is often simple to check even globally we can also soundly check other aspects of safety such as freedom on cl furthermore as we show in § the notion of library abstraction given by definition is compositional for libraries as we now explain we can get the desired theorem allowing us to check noninterference on cl for the fragment of the language relaxed atomics abstraction without relaxed atomics restricting ourselves to programs without the relaxed memory order and the axiomatic memory model to allow incomplete program runs as described in § allows strengthening our result in three ways we no longer need to quantify over client happensbefore edges r like in definition instead we histories with an additional relation which is easier to deal with in practice than the quantification hence without relaxed atomics the to the generality of the most general client does not apply abstraction on histories can be defined by inclusion on guarantees rather than by equality we no longer need to show that the program cl is rather noninterference is a consequence of the safety of the abstracted program cl the first two differences make proofs of library abstraction slightly easier but are largely otherwise in particular quantification over client happensbefore edges in definition although does not make library abstraction proofs more complicated requiring the guarantees of the concrete and abstract executions to be equal in this definition just results in more specifications in certain cases in contrast the last difference is substantial the price of satisfaction cycles for each of the three above differences we have a counterexample showing that theorem will not hold if we change the corresponding condition to the one required in the case without relaxed atomics all of these counterexamples involve satisfaction cycles which can only be produced by relaxed atomics our results show that this language feature makes the reasoning principles for c programs less compositional due to space constraints here we present only the counterexample for point above the others are given in in § we identify the corresponding place in the proof of the abstraction theorem for the language without relaxed atomics where we rely on the absence of satisfaction cycles consider the following pair of libraries l and l l atomic int x int m return l atomic int x int m return here x is a location we have l l since both method implementations behave exactly the same assuming that the internal location x is not modified outside the library unsafe clients can distinguish between l and l for example the client print m can print when using l but not l however any nontrivial library behaves when clients its private data structures and thus it is reasonable for abstraction to take into account only wellbehaved clients that do not do this we therefore that l should be abstracted by l according to any sensible abstraction criterion the above client violates noninterference when using either l or l however we can define a more complicated client c such that cl is but cl is not am if a if b call m sb sb sb ret m rf rf sb sb the execution of cl given on the right violates noninterference due to a satisfaction cycle a fault in the client causes the library to by returning instead of and the effect of this is what causes the client fault in the first place since the abstract library l is completely to client interference its method will always return and thus the satisfaction cycle will not appear and the client will not access the variable x note that this counterexample is not specific to our notion of library abstraction any such notion for c considering l to be a specification for l cannot allow checking noninterference using l for reasons we have given a very simple counterexample this program would be easy to detect and eliminate eg using a simple type system one syntactic path in the client is guaranteed to result in the forbidden access to the internal state however the same kind of behaviour can occur with addresses the client out of bounds of an array the library state causing it to which in turn causes the original client for this kind of example proving noninterference becomes nontrivial it is to us whether satisfaction cycles are observable in practice they are by even the weakest c target architectures such as power and arm because these architectures respect dependencies created by controlflow it is also clear that the c language designers would like to for satisfaction cycles the c standard section states that although from § is permitted implementations should not allow such behaviour this apparent contradiction is because certain compiler optimisations such as common subexpression elimination and from loops can potentially create satisfaction cycles see for discussion since avoiding them would require compilers to perform additional analysis andor limit optimisations the standard does not satisfaction cycles our results provide an extra argument that allowing satisfaction cycles is c language and threadlocal semantics to define the c model we use a modified version of its proposed by et al in the of simplicity we consider a simple core language instead of the full cc and omit some of the features of the memory model we do not handle two categories of features those that are orthogonal to abstraction and more features that would our results in the first category we have dynamic memory allocation dynamic thread creation blocked cases and nonatomic of atomic locations we also do not present the treatment of locks here although we handle a bounded number of them in our formal development see in the second category we have memory and atomics discussed in § the semantics of a c program is given by a set of executions generated in two stages the first stage described in this section generates a set of action structures using a sequential threadlocal semantics which takes into account only the structure of every threads statements not the semantics of memory operations in particular the values of reads are chosen arbitrarily without regard for writes that have taken place the second stage described in § filters out the action structures that are inconsistent with the c memory model it does this by constructing additional relations and checking the resulting executions against the axioms of the model programming language we assume that the memory consists of locations from loc containing values in val we assume a function sort loc atom na showing whether memory accesses to a given location must be atomic atom or nonatomic na see § the program syntax is as follows c skip c m c c c else c c atom sec c l m cm m m cl let l in c cn a program consists of a library l implementing methods m method and its client c given by a parallel composition of threads c cn the commands include skip an arbitrary set of base commands c eg atomic and nonatomic loads and stores and cases method calls m method sequential composition branching on the value of a location x loc and loops our language also includes atomic sections ensuring that a base command executes atomically atomic sections are not part of cc but are used here to express library specifications we assume that every method called by the client is defined in the library and we nested method calls we assume that every method accepts a single parameter and returns a single value parameters and return values are passed by every thread via distinguished locations in memory denoted loc for t n such that na the rest of memory locations are partitioned into those owned by the client and the library loc t n the property of noninterference introduced in § then requires that a library or a client access only the memory locations belonging to them except the ones used for passing parameters and return values we provide pointers on how we can relax the requirement of static address space partitioning in § actions executions are composed of actions defined as follows µ na sc rel effect a a a b call ma ret ma u v w q r act e g t here e aid is a unique action identifier and µ are memory orders § of memory accesses every instance of an atomic section occurring in an execution has a unique identifier g atomic sections only have force when multiple actions have the same section identifier so actions outside any section are simply assigned a unique identifier each the domains of the rest of the variables are as follows t n x loc a b val we allow actions by a dummy thread to denote memory we only consider actions whose memory orders respect location sorts given by sort and we do not allow actions of sort na loading or storing a value a at a location x generates the obvious action a action e g t a b arises from a successful command it corresponds to reading the value a from the location x and atomically it with the value b and µ give the memory orders of the read and the write respectively and have to be different from na the value a in e g t call ma or e g t ret ma records the parameter or the return value passed between the library method and its client we refer to call and return actions as interface actions for an action u we write for its atomic section identifier and we denote the set of all countable sets of actions by we omit e g and annotations from actions when they are irrelevant we also write for an expression whose value is irrelevant we use t a to mean any of the following t a t x a t call a if x and na t ret a if x and na we use t a to mean t a or t x a we call the two classes of actions read actions and write actions respectively threadlocal semantics the threadlocal semantics generates a set of action a sb ib where a and sb ib a × a are the and relations introduced in § we assume that sb is transitive and and relates actions by the same thread ib relates actions with thread identifier to the others we do not require sb to be a total order in cc the order of executing certain program constructs is unspecified for a base command c we assume a set c t × pa × a of all pairs of action sets and sb relations that c produces when executed by a thread t the ib relations are missing as they are relevant only for a whole program note that base commands may include conditionals and loops and thus can give rise to an arbitrary number of actions we give a separate explicit semantics to conditionals and loops only because they are used in the most general client in § definitions of c t for sample base commands c are given in figure note that in the threadlocal semantics a read from memory such as in the figure yields an arbitrary value a cas command generates an action if successful and a load otherwise we define an initial state of a program cl by a function i fin val × giving the initial values of memory locations together with the memory orders of initial writes to them we define the set of action structures cl i of a program cl in figure note that this set of action structures corresponds to complete runs of cl the clause for atom sec c assigns the same atomic section identifier to all actions generated by c the clause for a call to a method m brackets structures generated by its implementation cm with call and return actions we have omitted the clause for loops for simplicity we assume that the variable in the condition of a branch is always nonatomic assumptions we make several straightforward assumptions about the structures in c t for c · structures in c t are finite and contain only load store and actions by t with unique action identifiers · for any a sb c t sb is transitive and · structures in c t are to the choice of action and atomic section identifiers applying any bijection to such identifiers from a structure in c t produces another structure in c t · atomic sections in every a sb c t are in sb u v q u sb q sb v so as not to presentation we only consider programs cl that use and correctly we assume that in any action structure of a program only library actions by t read and write to and only client actions by t read and write to we also require that and be before an access in any structure a sb ib of cl u t call a w t w sb u u t ret a w t w sb u additional assumptions without relaxed atomics for our result without relaxed atomics § we currently require the following additional assumptions · the structure set c t accounts for c any values from the memory locations it reads see for · any structure of a base command c inside an atomic section accesses at most one atomic location this is sufficient for our purposes since a library specification usually accesses a single such location containing the abstract state of the library · we modify the standard c model by requiring that a programs semantics include structures corresponding to execution prefixes in the standard c model all executions are complete although possibly infinite we define ci p t for a thread ci by ci p t ap a sb ci t ap a u a v ap u sb v u ap this is necessary due to the interaction between our prototype atomic section semantics and the c model it the notion of atomicity atomic sections at the end of a prefix may be partially executed and therefore more weakly ordered than their completed counterparts eliminating it will require a deeper understanding of the relationship between atomicity and the notion of incomplete program runs see § for its use in the proof c axiomatic memory model the axiomatic portion of the c model takes a set of action structures of the program generated by the threadlocal semantics in § and filters out those which are inconsistent with the memory model to formulate it we action structures with extra relations executions the semantics of a program consists of a set of executions x a sb ib rf sc mo sw hb where a and the rest are relations on a · sb ib rf and hb introduced in § rf is such that its reverse is a partial function from read to write actions on the same location and with the same value · sequentially consistent order sc ordering sc reads from and writes to the same location the projection of sc to each atomic location is a transitive total order while writes to distinct locations are · modification order mo ordering writes but not reads to the same atomic ie of the sort atom location the projection of mo to each atomic location is a transitive total order · sw defining synchronisation we write rx for the component r of the execution x we can now define the denotation cl of a program and the notion of safety and noninterference introduced informally in § an execution x is valid if it satisfies the validity axioms shown in figure it is safe if it satisfies the safety axioms in figure and it is if it satisfies the axiom from figure we explain the axioms shown in the rest of this section intuitively validity axioms correspond to properties that are enforced by the runtime while safety axioms correspond to properties that the programmer must ensure to avoid to simplify the following figures and do not show axioms dealing with cases and locks to keep the presentation tractable we have also omitted some corner cases from and in figure the missing axioms and cases are given in and our results are established for the memory model including these the correctness of the stack in figure actually relies on a corner case in for a program cl and an initial state i we let cl i be the set of valid executions x whether safe or not such a cl i we write cl i to stand for its obvious lifting to sets i of initial states a program cl is safe when run from i if every one of its valid executions is and similarly for noninterference and sets of initial states an unsafe program has undefined behaviour the validity axioms define sw and hb directly in terms of the other relations and the hb relation is constructed from the sb ib and sw and as follows from has to be the operator in the definition of hb is needed to handle atomic sections for now the reader should ignore it the sw relation is derived from sc and rf the rf sc and mo relations are only constrained by the axioms not defined directly we explain the validity axioms by first considering a language fragment with nonatomic memory accesses only and then expanding it to include the other memory orders nonatomic memory accesses the values read by nonatomic reads are constrained by and requires every read to have an associated rf edge when the location read was previously ie when there is a write to it that before the read executions with reads from locations are valid but as we explain below unsafe requires that a read only reads from the write to the same location immediately preceding it in hb cf rd in the absence of other synchronisation this means that a thread can read only from its own previous writes or initial values since by sb ib hb threads can establish the necessary syn in the original c model sc is a total order on sc operations over all locations the formulation here is is equivalent to the original one but more convenient for defining library abstraction using atomic operations which we explain now or locks which we here see sc atomics the strong semantics of sc actions is enforced by all sc reads and writes over a single location into a total order sc which cannot form a cycle with hb according to an sc read can only read from the write thus if all memory accesses are annotated as sc in sb from § the result shown there is forbidden indeed by and the store of to y has to follow the load of from y in sc and similarly for x this yields a cycle in sb sc note that the model requires the existence of sc but does not include all of it into hb as a consequence one cannot use the ordering of say two sc reads in sc to constrain the values that can be read according to by an rf edge between an sc write and an sc read generates an sw edge which is then included into hb by atomics have the same effect as we now explain atomics by an read with the rel write it reads from for example if in we annotated all writes with rel and all reads with then the rf edges would be included into hb and the execution would be by for atomics weaker than sc there is no total order on all operations over a given location analogous to sc this is why sb is allowed instead they satisfy a weaker property of coherence all writes but not reads to a single atomic location are into a total modification order mo which has to be consistent with hb sc writes to the location are also included into mo and in such cases the latter has to be consistent with sc since reads are not included into mo we do not have an analogue of and thus a read has more freedom to choose which write it reads from the only constraints on atomic accesses weaker than sc are given by coherence and for example says that a read r that after a write w cannot read from a write w earlier in mo relaxed atomics like atomics relaxed atomics respect coherence given by the mo order and the axioms and however rf edges involving them do not generate synchronisation edges sw the only additional constraint on relaxed reads is given by which reads from the future ie from writes later in hb cf rd this and the fact that coherence axioms enforce no constraints on actions over distinct locations allows if all the loads and stores in were to the same location it would be forbidden by safety axioms the safety axioms in figure define the conditions under which a program is pairs of actions over the same location with at least one write it requires that such pairs on distinct threads one of which is a nonatomic access are related by hb and on the same thread by sb recall that in cc the order of executing certain program constructs is unspecified and thus sb is partial reads from locations the axiom is not part of the c memory model but the property of noninterference required for our results to hold § it is technically convenient for us to consider it together with the other safety axioms requires that the library and the client only read from and write to the locations they own except and used for communication § the axiom an action as performed by the library or the client depending on its position in sb with respect to calls and returns atomic sections atomic sections are a idiom for defining library specifications in an sc memory model we can t u v u v a e e g g e e g g u e g t a v e g t a y a b t u v u v e e g g a e e g g a a u e g t a b v e g t u e g t a v e g t figure definitions of c t for sample base commands here x y loc and a b val are constants skip t c c t a · a sb sb u v u a v a a sb c t a sb c t c else c t u · a sb u v v a a a sb c t u t a a u · a sb u v v a a sb c t u t atom sec c t e g t e t a e g t e g t e t e t sb a sb c t g m t a · u · v sb u v u q q v q a a sb cm t u t call m v t ret m let m cm m m in c cn i a · · n t at n t a × · n t at t n at ct t t n u finitely many v v u a · e g a ix a e aid g figure threadlocal semantics a · b is the union of the sets of actions a and b with disjoint sets of action and atomic section identifiers hb sb ib sw where r r u v u v u r v w r w sw r t t µ x t t sc rel µ sc w t r t w rf r r x w w hb r w r w w rf r hb sc is acyclic w r x w rf r w r na w hb r w w hb w hb r hb w r g w rf w r w rf r r w w sc r w w sc w sc r w hb w i w mo w mo w i w sc w w mo w r hb w w w rf g mo r w hb u v u mo v u mo q mo v u v u sc v u sc q sc v r w w wo mo w rf r rf r hb figure selected validity axioms of the c memory model axioms simplified for the purposes of presentation are marked by u v x t t u v a u v u t x v t x u t v t t t u hb v v hb u atom t t u sb v v sb u r r a r read w w rf r u x t u a t u t x x t n v v call v sb u q ret v sb q sb u x figure selected safety axioms of the c memory model r t x r x w w hb r w w w rf r a b r t a a u call b u sb r v ret u sb v sb r a b r x t r a r t x w w rf r r t x r x w w hb r w w w rf r a b r t a u ret b u sb r v call u sb v sb r a b r x t r a r t x w w rf r r a r t r ret u u hb r u t ret figure axioms for library § and client § executions define their semantics by simply requiring that no other events are interleaved with actions inside an atomic section unfortunately the relaxed memory model of c does not admit such a simple definition the straightforward solution of a total order on all instances of atomic sections would rule out relaxed specifications that we would like to give such as the specification from § hence we have extended c with a prototype notion of atomic sections suitable for its setting inspired by the semantics of transactions in this notion represents only the first step towards a natural specification language for relaxed c which is an interesting problem in itself the axioms defining the semantics of atomic sections are and in figure and in figure deferred to for brevity they capture the expected properties of atomicity thus in we factor sb ib sw over atomic sections using eg if an action u happensbefore another action v then u also happensbefore any other action from the same atomic section as v and require that actions from the same atomic section be in mo and sc relaxed actions which do not generate hb edges and are trivially satisfied when every action has a unique atomic section identifier additionally in this case simplifies to hb sb ib sw which is how it is defined in standard c thus if every action executes in a separate atomic section our augmented model coincides with standard c library abstraction in detail we first define formally the concepts used in the definition of library abstraction definition and the abstraction theorem theorem from § for the memory model with relaxed atomics we then show how the abstraction theorem can be for a fragment of the language them § and give the proof for both theorems § library abstraction in the presence of relaxed atomics history definition we formally define the history function which selects a history in the sense of definition from a library execution for an execution x we let and lift history to sets of executions pointwise here is the projection of ax to interface call and return actions the selector computes the guarantee part of the history we let be the projection of to pairs of actions of the form call ret and pairs of calls and returns in any order by the same thread we record only edges of the above form since it can be shown that any happensbefore edge between interface actions in a library execution under its most general client can be obtained as a transitive closure of such edges intuitively edges are the ones that represent the synchronisation between library method invocations as illustrated by mp in § the selector computes the part of the history we let be the projection of to pairs of actions of the form ret call this component is needed since the axiom figure that sc cannot form a cycle with hb but does not include sc into hb thus when a library relates a call action u to a return action v with hb and sc the client cannot relate v to u with the same relations as this would we add only edges into as these are the edges that represent synchronisation inside the client similarly to how edges represent synchronisation inside the library in one might think that the component of the history should have included edges recording potential violations of other similar axioms eg as suggested by dn however in the case of the model with relaxed atomics we are forced to quantify over client happensbefore edges r in definition as it happens this makes it unnecessary to consider axioms other than see the proof of the theorem in these axioms however have to be taken into account in the case without relaxed atomics § semantics we define the most general client as follows take n and let m ml be the methods implemented by a library l we let let l in where is m else m else ml here we use the obvious of loops and conditionals to branch expressions that yield a nondeterministic value to allow parameters of methods to be chosen arbitrarily we replace the axioms from figure and from figure by and from figure which that reads from lack associated rf edges while nonetheless yielding identical values within a single method call as part of the proof of the theorem § we show that this client is indeed most general in a certain formal sense with the concerning the need to extend its executions with client happensbefore edges mentioned in § we note that some libraries require their clients to pass only certain combinations of parameters or issue only certain sequences of method calls such contracts could be in our framework by restricting the most general client appropriately we do not handle them here so as not to the presentation for an initial library state i fin val × a library execution of l from i is an execution from i for some n a library execution is valid if it satisfies the validity axioms with instead of it is safe if it satisfies the safety axioms with instead of we let l i be the set of all valid library executions of l from i and lift l to sets of initial states pointwise we say that a library l is safe when run from i if so is every execution in l i for a set i of initial states l i is safe if l is safe when run from any i i the notion of a library is defined similarly extended executions in definition we use library executions whose happensbefore relation is extended with extra edges recording constraints enforced by the client consider an execution x and a relation r over interface actions from ax the extension of x with r is an execution that has the same components as x except the happensbefore relation is replaced by r an extension of a library execution with r is admissible when it satisfies the corresponding validity axioms but with replaced by hb sb ib sw r for an initial library state i we let l r i be the set of admissible executions of l from i extended with r this completes the definition of components used in definition execution projections finally we define the client function used in theorem consider a valid execution x of cl an action u a is a library action if it is a call or return action an action of the form for x or if vv call v u ret v q u an action u a is a client action if it is a call or return action it is an action of the form for x or the negation of the above property holds we define the execution by restricting the action set to library actions and all the relations in x accordingly we use a similar projection to client actions and lift client and to sets of executions pointwise properties of library abstraction for the fragment of the language with an sc allowing only nonatomic memory accesses and sc implies classical linearizability this follows from theorem and the fact that classical linearizability is equivalent to observational abstraction on the sc memory model however the converse is not true since our notion of library abstraction theorem for clients in the full c it distinguishes between sc libraries that classical linearizability would consider equivalent see using theorem we can obtain the expected property that like the classical notion of linearizability our notion of library abstraction is compositional with a that noninterference among libraries has to be checked globally formally consider libraries l lk with disjoint sets of declared methods and assume the splitting of the library address space into regions belonging to each library consider sets of initial states i ik such that j k i ij we the notion of library safety so that for lj is checked with respect to locations in let l i lk ik be corresponding library specifications we define l respectively l as the library implementing all methods of l lk respectively l lk and having the set of initial states i ik respectively i ik we assume that any combination of implementations or specifications of different libraries is the following theorem is shown by abstracting lj to lj one by one using theorem theorem if lj ij lj ij for j k then l l library abstraction without relaxed atomics we call an action with at least one annotation relaxed in this section we restrict ourselves to programs whose action structures do not have any relaxed actions and we augment the c threadlocal semantics as described in the assumptions of § among other things these changes allow us to remove the quantification over client happensbefore edges r from definition at the of including an additional relation into the history definition an extended history is a a g d d where a is a set of interface actions and g d d a × a for an execution x a sb ib rf sc mo sw hb we let which we lift to sets of executions pointwise the selectors and are defined as in § the relation is defined similarly to but whereas the latter records client hb and sc edges that can violate the former includes the client hb edges that can violate the axioms and figure we do not have to consider other similar axioms such as and since in any valid execution x without relaxed actions we have due to this the hb client edges and and can be covered by the same relations for the case of and includes the dashed edges of all possible instantiations of the following diagrams w l hb u v mo hb w w mo w u hb rf v r hb where u ret and v call this records client hb edges that violate or cf dn in § the diagrams are thus constructed systematically by the hb edge for the case of includes edges corresponding to a corner case in this axiom omitted from figure the full version of the axiom and the corresponding diagram are given in definition we let a g d d a g d d if a a g g d d and d d for safe l i and l i l i is abstracted by l i written l i l i if i i h l i i i h l i h h unlike in definition here an abstracted history can guarantee fewer happensbefore edges to the client without relaxed atomics removing edges from happensbefore can only permit more client behaviours or make the client unsafe we note that checking the inclusion between the components of the history given by required by definition is simpler in practice than over client happensbefore edges r in definition for executions x and y we write x y when all their components except hb are equal and theorem abstraction without relaxed atomics assume that l i l i and cl i i are safe and l i l i then cl i i is safe and x client cl i i y client cl i i x y unlike theorem this one allows the programmer to check noninterference on with respect to a library to conclude that cl is since the abstract library can have a smaller guarantee than the concrete one the happensbefore of the execution cl may also be smaller than that of the execution cl like the notion of library abstraction from § the one proposed here implies classical linearizability for the sc fragment of the language but not vice versa and is compositional however here the latter property does not require us to check noninterference globally a composition of several libraries is proof semantics we start by defining the semantics of a client c c cn which is a counterpart of the semantics defined in § let m be the set of methods that can be called by c consider the program let m skip m m in c cn where every method is implemented by a stub that returns immediately after having been called moreover we allow methods to return arbitrary values by replacing the axioms from figure and from figure by and from figure we call executions of the above program client executions of c a client execution is valid if it satisfies the validity axioms with instead of it is safe if it satisfies the safety axioms with instead of for an initial client state i fin val × let c i be the set of all valid client executions of c from i for a set i of initial states we define c i as expected the notion of an extended client execution is similar to the one of an extended library execution from § for an extended execution x we let be the execution obtained from x by from and according to history selectors consider a client execution x we define × which are analogous to and from § but select the information about the client part of the execution that is relevant to the library we let be the projection of to pairs of actions of the form ret call and pairs of calls and returns in any order by the same thread we select edges of this form as they are the ones that record synchronisation enforced by the client we let be the projection of to pairs of actions of the form call ret proof outline for theorem consider an execution x of cl from the initial state i i where i i and i i we start by x into a client execution and a library execution and showing that c i l i the second inclusion that the most general client of the library defined in § is indeed most general as it can the behaviour of l under any client c this comes with the that an execution of the most general client of l has to be extended with to obtain as the library local semantics does not generate happensbefore edges enforced by client synchronisation and similarly for in the first inclusion the above decomposition step relies on x being non using the fact that l i l i we prove that there exist i i and y l i such that here we use the quantification of client happensbefore edges r in definition to handle the extension of the library execution with we then compose the executions x and y into the desired execution of cl this step uses the fact that the component of is smaller than that of proof outline for theorem unlike in theorem here we need to consider the case when an execution x of cl has ac tions noninterference in this case we identify an action u and construct a valid execution that is a prefix of x ending just before u and is thus this is only possible because without relaxed atomics we do not have tion cycles and because the theorem is stated over an augmented threadlocal semantics § with prefix executions added to the se we convert the resulting execution into one of cl as in the proof of theorem and the action the action u to it this yields an execution of cl noninterference and the assumption about its safety in the case when x is the proof is similar to that of theorem some additional work is needed to deal with the fact that definition does not have a quantification over client happens before edges and allows the abstract guarantee to be smaller than the concrete one establishing library abstraction in this section we discuss the proof process for establishing abstraction between libraries in the sense of definitions and to reason about programs on the c memory model we use of the action structures generated by them which give a simple mathematical interface to the program semantics to prove library safety required by definitions and we consider all the execution shapes of the most general client and check these against the c safety axioms we now explain how we prove the correspondence between the executions of concrete and abstract libraries using definition for illustration effect points consider an execution x l r i we construct an execution x l r i whose history witnesses the existential in definition using an adapted version of the linearization point method for proving linearizability the method constructs the abstract execution by calling a method specification at a fixed linearization point in every method invocation of the concrete execution intuitively it is at this point that the concrete method takes effect in our adaptation we construct x by substituting calls to library method implementations in x for the corresponding calls to specifications and choosing appropriate values for reads and different orders between actions these values and orders are chosen based on the orders over actions we call effect points for each concrete method invocation in x thus the various partial orders over the effect points in the concrete execution the order of precedence for the effects of method invocations in the abstract execution in contrast with the original linearization point method the latter order does not have to be linear we now explain this technique in more detail on an example example stack we have proved the correctness of the stack in figure b with respect to its specification in figure a according to definition full details are given in as effect points in x we pick the actions modifying the stacks top pointer t which correspond to successful cases this is the same choice as the that of linearization points when proving the linearizability of stack on an sc memory model the order over these actions defines a total order over successful push and pop invocations when substituting invocations of method implementations for invocations of specifications we use to decide and for the abstract location s namely suppose we have two method invocations u and v in x such that the of u is the immediate predecessor to the of v in when substituting corresponding invocations of specification methods u and v we set up and so that the load from s in v reads from the in u and orders the on s in u right before on it in v and in the abstract execution immediately the values of reads which the construction of x example queue we have similarly verified a nonblocking queue according to definition see the queue is intended for communication between a single producer thread and a single consumer thread and provides three methods init enq and the implementation stores values in a finite cyclic array while the specification stores them using the abstract data type of a sequence to ensure that the consumer calling values it must with the producer calling enq using atomics related work behaviour has become in real concurrent systems as a result some algorithm designers have to algorithms with annotations such as however the corresponding of correctness properties and their proofs are generally informal while there has been some work on formally verifying programs on weak memory models none has proposed a compositional reasoning method like we do ours is the first approach that the notion of a correct library specification and provides a method for establishing it on c or any similarly relaxed model our work is an evolution of linearizability a correctness criterion that has been widely adopted in the concurrent algorithms community in the sc fragment of c our definition of library abstraction implies classical linearizability history abstraction in classical linearizability is defined by linearization of the partial order over methods invocations and the guarantee portion in our histories can be seen as lifting this to the c setting classical linearizability has no equivalent to our relation the conflicts between relations that are captured by do not occur in an sc setting where all events are totally ordered recent work has the intuition that linearizability corresponds to observational abstraction and has extended it to handle liveness programs and the x memory model the latter work is the to this paper in particular we the approach in the proof of the abstraction theorem § from it however while its objective is the same as for concurrent technical challenges and the machinery developed to address them are very different the x memory model can be defined by a smallstep operational semantics which has an underlying total order on abstract machine memory events linearizability for x is therefore a relatively extension to classical linearizability which simply represents some of these events in linear histories in contrast c relaxed behaviour through partial ordering controlled by an axiomatic semantics there are no abstract machine events to which our novel definition of a history as a set of partial orders and history abstraction as inclusion over them furthermore x is a substantially stronger model than c with sb from § being the only significant relaxation our approach is the first technique for specifying effects of inside libraries on weaker memory models conclusion and future work we have proposed the first sound criterion for library abstraction suitable for the c memory model and demonstrated its on two small but typical relaxed libraries our criterion is certainly complex but much of this complexity arises from the realworld of the c memory model in turn the complexity of the model arises from a of target platforms of c and of the worlds most programming languages despite this complexity the criterion allows developers to establish that c libraries satisfy simple specifications that precisely describe the level of consistency guaranteed this is an essential for supporting modular development of complex software on relaxed memory models in addition our approach is the first compositional reasoning technique for an defined relaxed memory model and general principles for abstraction on such models we have good reason to believe that our techniques can be reused for other memory models as the conditions for library abstraction fall out naturally from obligations arising when trying to prove the abstraction theorem according to the approach in § in particular the histories in our approach are constructed uniformly with relations obtained straightforwardly from axioms by hb edges § in particular our preliminary show that these techniques can be used to define a notion of library abstraction for an axiomatic formulation of the x memory model our specifications describe precisely the level of synchronisation provided by the library although in some cases this makes them more this is motivated by the fact that libraries on c can offer relaxed interfaces to clients without either giving up all synchronisation guarantees or enforcing sequential consistency if information about the internal synchronisation used to ensure library correctness were not described in these interfaces clients would have to duplicate it thereby decreasing performance on the other hand requiring library interfaces to be sc would rule out libraries that use weaker memory orders to achieve efficiency while preserving basic correctness properties again decreasing performance our prototype atomic section semantics represents a first attempt at a syntactic specification idiom for relaxed algorithms with limitations as described in § we leave a more treatment of relaxed atomic sections to future work our two of library abstraction definitions and and the abstraction theorem theorems and identify the feature of the current cc memory model that does not allow fully compositional reasoning about libraries as we argued in § this is not specific to our definition of library abstraction but would be inherent to any sensible one we hope that these insights will future of the cc memory model our development memory and atomics which are the more advanced features of the c memory model a memory is a synchronisation construct that affects many memory actions rather than just one is a memory order which more efficiently to power and arm processors we conjecture that our methods can be used to handle these features as both of them generate more possible interactions this will require adding additional relations to histories to concentrate on the core challenges of library abstraction in c we assumed that the data structures of the client and its libraries are completely disjoint § we hope to lift this restriction by combining our results with a recent of classical linearizability allowing transfers of memory ownership similarly a previous of linearizability to handle liveness properties could be used to specifications of the kind shown in figure a to guarantee properties such as acknowledgements we would like to thank boehm richard paul robin peter sewell s yang and john for helpful comments we from grants and references m m and a library abstraction for cc concurrency extended version university of york technical report m s s sarkar p sewell and t c concurrency in popl boehm can get along with programming language memory models in boehm and s v foundations of the c concurrency memory model in pldi s a m and h yang concurrent library correctness on the tso memory model in esop s d m and m sagiv eventually consistent transactions in esop i p ohearn n and h yang abstraction for concurrent objects in esop i p ohearn n and h yang the client on data refinement in the presence of pointers a and h yang atomicity abstraction in icalp a and h yang linearizability with ownership transfer in concur m p and j m linearizability a correctness condition for concurrent objects toplas programming languages ­ c programming languages ­ c m m t and e abstractions for relaxed memory models in pldi l lamport how to make a multiprocessor computer that correctly executes programs ieee trans comp j the java memory model phd thesis department of computer science university of action structures for locks lock t e g t lock e g t block e aid g unlock t e g t unlock e aid g let m cm m m in c cn i a · · n t at n t a × · n t at t n at ct t t n u finitely many v v u v t u v u block a · e g a ix a e aid g additional validity axioms w u w rf u u w mo u w mo w mo u w w r u v x w rf r r atom mo v u w mo u w mo w mo u u w rf r w w locks u v u lock v lock u sc v q q unlock u sc q sc v w r w sw r w sc r w unlock r lock t t µ x w t t sc rel µ sc w t r t w rs t w rf r where w rs t w def w w mo w w w mo w mo w w t w w r x w rf r r w w sc r w w sc w sc r w sc w w w sc r w w sc w sc r hb w additional safety axiom v t v a v t unlock u u t lock u sb v q u sc q sc v v t u t lock v t block u sb v q u sc q sc v figure action structures for locks and additional c memory model axioms m m michael scalable lockfree dynamic memory allocation in pldi m m michael m t and v a idempotent work in s s sarkar and p sewell a better x memory model in t a relyguarantee proof system for in s sarkar p sewell j l and d understanding power in pldi r k systems programming with parallelism technical report rj ibm research center i and j berdine a proposal for local reasoning in a additional definitions for the c model in we omitted the treatment of locks and cases from the description of the memory model and simplified some of the axioms even though the proofs of our theorems do not make such simplifications here we provide the missing definitions we handle programs with bounded numbers of locks lock acquired and released using commands lock and unlock respectively we thus extend the set of actions as follows lock unlock block where lock an action e g t block represents a attempt to acquire a lock we split the set of locks into client and library ones lock clock and consider only programs where the client and the library use locks from clock and respectively in figure we give the actions structures for lock operations omitted from figure and the c axioms omitted from figures and note that the action structures of a whole program do not include those where a thread executes actions after blocking to the axioms to the model with locks we require that the sc relation totally orders actions of the form lock block or unlock for each lock in addition to sc actions the axioms and locks define the behaviour of cas commands and locks is an additional axiom for atomic sections in the spirit of and are full versions of the axioms presented in a simplified form in figure the former adds synchronisation via release sequences defined by the rs relation and the latter allows sc reads from writes is an additional safety axiom a double unlock or a double lock in the same thread as a fault all the theorems stated in the paper valid for this extension of the model to account for the full version of the axiom we add additional edges to for x a sb ib rf sc mo sw hb includes the dashed edges of all possible instantiations of the following diagram w sc r r zo rf w u hb w w sc v w sc w sc r w hb where u is a return and v is a call its counterpart contains the dashed edges assuming u is a call and v is a return 