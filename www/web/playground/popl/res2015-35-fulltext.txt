towards the essence of hygiene michael d university of university of illinois at abstract hygiene is an essential aspect of schemes macro system that prevents variable capture however previous work on hygiene has focused on algorithmic implementation rather than precise mathematical definition of what hygiene this is in contrast with lexical scope and substitution which also deal with preventing variable capture but have widely applicable and mathematical definitions this paper presents such a precise mathematical definition of hygiene it various kinds of hygiene violation and presents examples of how they occur from these examples we develop a practical algorithm for macro expansion we then present mathematical criteria for whether a macro expansion algorithm is this characterization corresponds closely to existing hygiene algorithms and light on aspects of hygiene that are usually in informal definitions categories and subject descriptors d programming languages formal definitions and general terms algorithms languages keywords hygiene macros nominal logic introduction hygiene is an essential aspect of the scheme macro system that prevents variable capture for example suppose we have a or macro that expands as follows let x t or begin write f x let x t let tmp begin write f if tmp tmp x this expansion introduces a let binding for begin write f in order to avoid its side effect however this let binding can cause suppose the original expression used tmp instead of x in a naive macro system the result would be the following expansion permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm let tmp t or begin write f tmp let tmp t let tmp begin write f if tmp tmp tmp in the result of this expansion tmp is captured and no longer bound to what it was at the call to or changing the binding name from x to tmp has changed the result from f to t hygiene prevents these problems in a macro expansion system macros are automatically as wellbehaved with regard to variable names as the core forms of the language and users can rely on the expected alpha equivalences essentially hygiene is the equivalent of lexical scoping at the macro level hygiene has a long history in the literature et al and wand and and et al and wand however these works leave hygiene defined informally and focus on the algorithmic aspects or apply to only a restricted set of macros that follow certain typing disciplines and do not handle the general case furthermore while they all to implement similar concepts of hygiene they use divergent implementation approaches that are difficult to formally compare without a precise formal definition of hygiene this paper proposes such a definition of hygiene this definition is formally precise and hygiene to concepts from nominal logic and pitts in particular it shows that hygiene is a combination of alpha equivalence and nominal logics notion of this definition is applicable to a wide variety of macro systems and deriving a practical algorithm that satisfies it leads to connections with existing hygiene algorithms such as the expansion algorithm used in scheme et al finally we use this definition to important aspects of hygiene that are omitted from traditional informal descriptions of hygiene the organization of this paper is as follows in section we give an overview of the basic ideas behind our characterization of hygiene in section we review the of macro expansion in scheme in section we examine various sorts of hygiene violations and how they occur we show why traditional notions of alpha equivalence and other naive methods for ensuring hygiene are not sufficient we show that identifiers in a general system must be rather than and we present a simple algorithmic method for ensuring hygiene in section we develop a formal mathematical characterization of hygiene in terms of nominal logic in the process we demonstrate a new sort of hygiene violation that while implicitly handled by traditional hygiene algorithms is not widely discussed in section we show how this characterization corresponds to the algorithm finally in section we discuss related work and in section we conclude overview of the main ideas while we give a more complete treatment of the mathematical concepts of hygiene in section the main ideas are as follows we show that a syntactic representation that treats identifiers as simple atomic values with no auxiliary information does not contain enough information to express the structures needed to implement a macro system as powerful as schemes we can however express those structures by splitting identifiers into a pair of atoms identifiers are thus instead of and we write them as r b where r is the reference part of the identifier and is by a reference atom while b is the binder part and is by a binder atom next we formally define hygiene in terms of two criteria the first the reference hygiene criterion requires that each macro expansion step respect alpha equivalence with respect to reference atoms in the fully expanded outer parts of the syntax that have known binding structures unfortunately we cannot use alpha equivalence in the partially expanded inner parts of the syntax as their binding structures are unknown to handle this the second criterion the binder hygiene criterion is expressed in terms of an condition with respect to binder atoms that must hold on all macro transformation functions in essence the reference hygiene criterion requires that the expansion process respect alpha equivalence in the parts of the syntax with known binding structures in parts of the syntax where the binding structure is unknown this will not work so the binder hygiene criterion requires that macro transformers respect any possible binding structure that that part of the syntax may have together these two criteria formally define hygiene and we specify these using nominal logic in section these criteria are consistent with traditional informal definitions of hygiene and and the reference hygiene criterion ensures that references introduced by a macro are not captured by bindings other than those introduced by the macro the binder hygiene criterion ensures that binders introduced by a macro are always generated and thus cannot capture reference other than those introduced by the macro finally though and hygiene are usually described as the two main aspects of hygiene the used to define the binder hygiene criterion requires a third aspect namely macro transformers must not observe the values of binders in their inputs other than to compare them with other binders in their inputs this third form of hygiene is actually enforced by traditional hygiene algorithms even though informal descriptions of those algorithms do not discuss it of scheme macros before considering hygiene we briefly review the of scheme macros and how they operate as shown in figure macro expansion occurs between the reader which a string into an and the interpreter or compiler which evaluates or the fully expanded term at the start of this process an is taken from the reader and injected into the domain of syntax objects for our purposes a syntax object is an with identifiers instead of symbols in a naive these identifiers are plain symbols but in a they carry extra scoping and binding information in some syntax objects additionally contain other information such as source locations or data structures that the algorithmic performance of macro expansion we omit these as they are not relevant to the essential theory of hygiene in the remainder of this paper we deal only with syntax objects and do not use string read syntax syntax compile executable figure schemes compilation pipeline next comes the core expansion process we model this as a sequence of smallstep rewrites using each step corresponds to one particular macro invocation or expansion of a core form the expansion process always proceeds with the outermost expression that can be expanded we thus divide the program into two parts we call the inner part that is waiting to be further expanded as its binding structure is unknown and we call the outer part that is already fully expanded as its binding structure is known there is no more expansion to be done in and we know the form of each component of thus we can represent it using the representations used internally by the compiler conversely the structure of the waiting to expand is not yet manifest in order to distinguish from we adopt the notation of the former thus for example we may say that the lambda x x expands after a number of steps to the lambda x x note that may be modified by macro expansion though cannot thus while we might expect the expression f x y to be a function call it may instead be a macro call if f is bound to a macro definition likewise even though lambda x y is usually a lambda expression it may be a macro or function call due to a local definition of lambda this is resolved only once this is fully expanded into we define both and in figure where we use vector notation for repeated elements for simplicity of presentation we over which are versus and we include forms as core forms instead of encoding them in terms of lambda using these forms the or macro can be written as in figure the full expansion sequence for let x t or f x is then as shown in figure to define a macro we use and these are similar to let and letrec except that the lefthand sides of their bindings are the names of macros and the righthand sides are macro transformers for example we use the following to define the or macro where f is the macro transformer for or or f macros are generally invoked using a syntax within the body of this the or macro can thus be invoked using or f x a macro transformer is a function that defines how a macro expands it takes as argument the syntax object representing the macro invocation and returns the syntax object to which the macro call should expand for example the macro invocation or f x causes or f x to be passed as input to the transformer for or the transformer then returns a syntax object such as let tmp f if tmp tmp or x syntax objects are similar to but they have separate methods for construction and unlike which use functions like cons pair car and cdr to create and examine objects syntax objects use the pattern matching form and the form syntax the first argument of is the and is matched against the patterns in each clause the second argument schemes and allow macros to be called in other places as these are orthogonal to hygiene we omit them from this paper for the sake of simplicity identifiers constants pattern literals i x y z · · · c f t · · · lit i i c ast c i lambda i ast ast ast if ast ast ast let ast letrec ast ast ast syntax ast lit ··· constants variables functions function app conditionals local variables local macros syntax syntax code patterns pat i pat pat ··· nil constant pattern variables pairs figure syntactic forms is a list of identifiers that are to be treated as literal constants in the patterns of the in this paper pattern literals are not used and we use only a subset of the pattern language however the techniques we describe trivially generalize to pattern literals and the full pattern language the subset that we use allows a pattern to be either a that matches anything the nil constant a pattern variable or a pair of patterns as with nested pairs can be represented using list notation the syntax form is a form for syntax objects as a notational shorthand syntax e can be written as e for any e just as quote e can be written as e in addition any pattern variables that are bound by are automatically substituted for the corresponding identifiers in an syntax any identifiers that are not bound by a pattern are simply constants for example the following evaluates to the syntax object a z a x y y x z finally for simplicity of presentation we do not discuss library forms module forms define or in addition we only briefly discuss in section how to handle the quote form and the hygiene operators and or lambda f x x x xs let tmp x if tmp tmp or xs figure definition of the or macro let x t or f x let x t or f x let x t or f x let x t let tmp f if tmp tmp or x let x t let tmp f if tmp tmp or x let x t let tmp f if tmp tmp or x let x t let tmp f if tmp tmp or x let x t let tmp f if tmp tmp or x let x t let tmp f if tmp tmp or x let x t let tmp f if tmp tmp x let x t let tmp f if tmp tmp x figure example naive expansion of the or macro hygiene before considering how to define hygiene in section we examine the different sorts of hygiene how they are violated and how to handle them to do this we start with a naive algorithm that uses identifiers and work our way up to a fully algorithm the resulting algorithmic techniques are relatively simple but they provide useful about how a expansion system to behave later in section we use these to develop precise properties that characterize hygiene types of hygiene violations hygiene is about avoiding variable capture and there are two primary ways that can happen the first is by a macro introducing binders and the second is by a macro introducing references for example as seen in the following quote according to and a macro system is one in which it is impossible to write a highlevel macro that inserts a binding that can capture references other than those inserted by the macro it is impossible to write a highlevel macro that inserts a reference that can be captured by bindings other than those inserted by the macro interestingly once we characterize hygiene we will discover that there is a third kind of hygiene violation specifically we must ensure that identifiers that act as binders in the input of a macro transformer are not observed by the macro transformer other than to compare them to other binders from the same input though this third kind is not often discussed it is implicitly by traditional hygiene algorithms and we explore this in section hygiene as an example of hygiene consider the following code let tmp t or f tmp this should evaluate to t since the first argument to or is f and the second argument tmp is bound to t however a naive eventually expands this to the following let tmp t let tmp f if tmp tmp tmp the or macro introduces an inner binding of tmp to f that the binding of tmp to t and results in this code evaluating to f instead of the expected t hygiene hygiene violations due to introduced binders are certainly the most easily recognized sort of violation however violations due to introduced references can also occur consider for example the following variation of the code we had before let if t or f if all we have done is rename tmp to if so this code should still evaluate to t however a naive eventually expands this to the following let if t let tmp f if tmp tmp if note that if is bound to t so if tmp tmp if is not the core form for if as it was before but rather a function application of the variable if to the variable references tmp tmp and if this is thus to call t as a function aside from being a runtime error it is to be what the programmer intended this time the binding of tmp to f introduced by the or macro is not the cause of the problem rather it is the fact that the macro introduces a reference to if that it expects to be bound to the core form for if since the macro is called in a context in which if is not bound to the core form we get an incorrect result this problem occurs any time a macro introduces a reference that it expects to be bound in a particular way though this particular violation occurred due to the of a core form this may happen even in a system with multiple for example a macro that introduces references to forms such as read or eval has the same problem if it is called in a context where those identifiers are enforcing hygiene with binder renaming as a first attempt at moving from a naive macro to a macro let us consider the introduced reference problem more carefully as before we start with the following code let if t or f if as shown before in a naive this code eventually expands to the following let if t let tmp f if tmp tmp if to avoid this problem we can rename bound variables to generated identifiers as soon as they are exposed thus for example after expanding the outer let and before expanding the or macro we can generate a fresh identifier such as if and replace all occurrences of if with if this results in the following code let if t or f if when this fully expands we get the following which has avoided capturing the if used by the or macro let if t let tmp f if tmp tmp if note that we do not rename bindings until they are fully expanded into and thus have a known binding structure that cannot be modified by other macro calls binder renaming is since binder renaming is sufficient to ensure hygiene a natural question is whether it is sufficient to ensure hygiene unfortunately it is not to see this consider the following example where we have placed the definition of the or macro inside the binding of tmp let tmp t or let tmp or f tmp for the sake of brevity we most of the or macro except for the tmp binding introduced by it after the outer let form expands and before the body of the let expands we generate a fresh identifier for it to bind and we rename all tmp references this results in the following let tmp t or let tmp or f tmp note that when tmp is renamed to tmp the tmp identifier introduced by the or macro is also renamed if we continue expansion we get the following let tmp t or let tmp or f tmp if we then expand the call to the or macro we get the following let tmp t or let tmp let tmp f if tmp tmp or tmp at this point we can see that even though we have been careful to rename any bindings discovered during the expansion process hygiene has been violated the or macro has introduced a binding for tmp that the outer binding to tmp and captures the reference to tmp in or tmp the renaming of tmp when the inner let is expanded will not help us as it will rename all occurrences of tmp and not just those introduced by the or macro while we will come back to the use of binder renaming for ensuring hygiene this example demonstrates that it does not ensure hygiene to find a complete solution for hygiene we must something more enforcing hygiene with for the moment we set aside binder renaming and hygiene to consider hygiene violations due to introduced binders this happens for example in section where the binding for tmp that is introduced by the or macro the locally defined tmp the problem is that the introduced tmp happens to coincide with the tmp being used locally we can avoid this by using a generated identifier instead of tmp indeed this is a widely used technique in systems with macro for example if we have a operator that generates fresh identifiers we could define the or macro as follows or lambda f x x x xs tmp g let g x if g g or xs here we use to introduce g as a pattern variable that gets replaced with the result of this ensures that the binder we introduce is unique and thus never conflicts with one from the input to the macro if we consider the example from section with this definition of or the expansion proceeds the code immediately before expanding the or macro is as follows let tmp t or f tmp when or expands creates a fresh identifier say tmp that is globally unique the identifier tmp does not conflict with tmp and thus we avoid the hygiene violation due to an introduced binder the fully expanded expression is then the following let tmp t let tmp f if tmp tmp tmp unfortunately while using allows us to avoid hygiene violations caused by introduced binders it provides no help with introduced references consider again the following example from section let if t or f if if we use but not binder renaming we get the following when we fully expand the or macro let if t let tmp f if tmp tmp if the binder introduced by the macro uses the generated identifier tmp but that is not the identifier causing the problem it is the binding of if that is the problem that binding is outside the reach of the or macro and thus there is nothing the macro can do to avoid the captured variable this example demonstrates that on its own using generated identifiers for introduced binders is not a complete solution to hygiene either binder renaming with is also neither the solution in section nor the solution in section is sufficient on its own to ensure hygiene but they handle complementary aspects on the one hand the solution in section handles hygiene on the other hand the solution in section handles hygiene thus we might consider combining the two first we rename identifiers bound by core forms that are discovered during macro expansion then we require that any binders introduced by macro transformers be generated surprisingly this does not work either to see why consider the question of whether x should be generated by the m macro in the following code let x m lambda y x x y m x suppose is defined as follows lambda u v let u v whatever is passed to as u becomes bound thus the x introduced by m needs to be generated because it is introducing a new binder if we do not generate x then the expansion sequence would be the following which results in the capture of the x originally passed to m by the binding of x introduced by m m x x x x let x x x on the other hand generating the x introduced by m avoids this problem and results in the following expansion sequence where no capture occurs m x x x x let x x x while generating x avoids capture in this case consider if were defined as the following lambda u v u with this definition ignores its second argument and is not a binding form if we generate x like before then we get the following expansion sequence m x x x x x this results in an error since x is now a variable reference and there is no x in scope if on the other hand we do not generate x then we get the following expansion sequence which behaves correctly m x x x x x we might still hold out hope that a sufficiently careful programmer with sufficient information about the binding structure of could write macros like m that generate identifiers exactly in those places where they should however that hope is dashed once we consider a definition of like the following lambda u v let u u v here expands to both the increment and let binding from our previous definitions of if m does not generate x then the expansion sequence is as follows m x x x x let x x x x this is wrong as the binding of x in the resulting let captures the x from the original call to m on the other hand if m does generate x then the expansion sequence is as follows m x x x x let x x x x this is also wrong as there is a reference to the variable x in the righthand side of the let binding with this definition of we are stuck the m macro must generate the x that it introduces because of the let binding but the m macro also must not generate the x that it introduces because of the reference in the righthand side of the let binding enforcing hygiene with identifiers the problem in section is because some uses of x should use the generated version while others should not as long as identifiers are atomic symbols we cannot have both in order to resolve this we split identifiers into a reference part and a binder part so they are instead of we thus write identifiers as r b where r is the reference part and b is the binder part the reference part is by a reference atom and is used if the identifier eventually ends up in a reference position while the binder part is by a binder atom and is used to determine what identifiers are captured when the identifier ends up in a binding position these two sorts of atoms are from mutually disjoint domains and a binder atom is never used in a position that expects a reference atom or vice versa as a simplifying notation we write x for xr xb when the nature of an identifier is not significant with these identifiers m can expand with both generated and generated atoms in the reference and binder parts of the identifier respectively so for example we could have the following expansion sequence m xr xb xr xb xr xb xr xb let xr xb xr xb xr xb xr xb the binder part of the introduced identifier xr xb is generated but the reference part is not in the righthand side of the let binding we use the reference part of the identifier xr which was not generated on the other hand in the lefthand side of the let binding we use the binder part of the identifier xb thus the let does not capture the identifier in the body of the let that has xb as a binder part to account for this change we define expansion to operate with identifiers using the smallstep relation in figure this relation is closed under congruence for but not thus expansion always operates at an outermost also though it may appear that the third clause ie macro application the other clauses it does not binding forms always use fresh reference atoms so r in the third clause never with constants such as in the other clauses under this definition variable references merely expand to their reference parts for example we have the following expansion xr xb xr in effect the reference part of an identifier represents what the identifier would refer to if there were no more binding forms discovered during expansion binding forms are a bit more complicated when expanding a binding form we use the binder part of the identifier to determine what identifiers it captures once that is determined those identifiers must be modified to refer to the newly expanded binding form since variable references expand to a reference atom the binding forms in also use reference atoms for their binding positions since the target of a variable reference is determined by the reference part of an identifier we replace the reference parts of the captured identifiers with generated reference atoms that we then also use in the for the binding form this replacement is implemented using the subst function defined in figure its first clause replaces the reference part of identifiers that have a particular binder part and the other clauses are merely a standard traversal over considering lambda again we have the following expansion sequence lambda xr xb xb xr lambda wr wr xb xr lambda wr wr xr as with binder renaming we use wr a generated reference atom for the binding form the in xb is changed to wr since the binder part of that identifier xb matches the binder part of the identifier xr xb that is in the binding position for the lambda form in other words that identifier should be captured by the lambda on the other hand the identifier xr is left alone as its binder part does not match xb identifiers are sufficient returning to the final version of the macro from section we can now see how all of this together first we start with the following expression m xr xb when m expands it generates the binder portion of any identifiers that it introduces and we thus get the following xr xb xr xb xr xb when expands the xr xb identifier is placed in both the lefthand and righthand sides of the let binding which results in the following let xr xb xr xb xr xb xr xb at this point we expand the let form this generates a fresh reference atom xr and we use subst to replace the reference part of any identifiers in the body that have the same binder part as the bound identifier this binder part is xb and was generated by the m macro so the only identifier captured is the first argument to and we get the following let xr xr xb xr xb xr xb we then expand the righthand side of the let binding since the identifier in it is a variable reference it expands to its reference part to produce the following let xr xr xr xb xr xb c r b r b args b r b body b test true f b body b r b rhs body b r b rhs body b body b b pat rhs f un args c r f r b args where f is the currently transformer bound to r and all identifiers introduced by f have generated binder parts lambda r if test true f let r rhs letrec rhs r rhs rhs syntax rhs where b is the binder parts of the identifiers in the corresponding pat and pat is pat with each identifier r b replaced by a corresponding element of r f un args if none of the above cases apply be fresh reference under congruence atoms and subst for b r e be the application subst b r r b r b if b b subst b r r b r b if b b subst b r c c if c is a constant subst b r subst b r subst b r subst b r figure definition of subst all the remaining identifiers are references so the last bit of expansion results in the following let xr xr xr xr note that identifiers for x that are introduced by m can all capture each other because they have the same generated binder parts but those introduced identifiers cannot capture anything else as their binder parts are distinct from the binder parts of any other identifiers summary at this point we have an algorithm that completely handles hygiene we summarize the major points as follows first identifiers are and contain both a reference part and a binder part the reference part represents what the identifier refers to if it ends up in a reference position the binder part represents which identifiers can capture each other second when expanding a binding form we use the binder part of an identifier to determine what identifiers are captured by it a generated reference atom is created for the binding form and the reference parts of the captured identifiers are then replaced with this reference atom so that those identifiers now refer to that binding form finally we require that the binder parts of any identifiers introduced by a macro call be generated this ensures that the only identifiers they can capture are ones that were introduced in that macro call if we go back to the examples of hygiene violation in the or macro with this algorithm we get the expansion sequence in figure which shows the enforcement of both hygiene with the if binding and hygiene with the tmp binding the mathematics of hygiene the algorithm in section provides useful about hygiene but does not define what hygiene actually is we now turn to this question and consider the mathematical properties that characterize hygiene we do this in terms of permutations support and from nominal logic and pitts so we review these before to the main question of characterizing hygiene in the process we expose hygiene as a third way hygiene can be violated that is not often discussed but is implicitly by traditional hygiene algorithms nominal logic permutations in nominal logic permutations are invertible total mappings over atoms we write for the permutation that maps the atoms let t let or f let pr t let or f pr let pr t let or f pr let pr t let qr or f pr let pr t let qr or f pr let pr t let qr let sb f sb sb or pr let pr t let qr let tr f tr sb tr sb or pr let pr t let qr let tr f tr sb tr sb or pr let pr t let qr let tr f if tr sb tr sb or pr let pr t let qr let tr f if tr tr sb or pr let pr t let qr let tr f if tr tr or pr let pr t let qr let tr f if tr tr pr let pr t let qr let tr f if tr tr pr figure example expansion of the or macro and to each other while leaving all other atoms unchanged and for the permutation that maps corresponding elements of and to each other while leaving all other atoms unchanged we write the application of a permutation to an atom as · finally since every permutation is invertible we write for the inverse of we lift these permutations from applying over individual atoms to applying over both and by a straightforward homomorphism as shown in figure note that we apply the permutation even to bound variables if we do not the permutation could result in captures for example consider the permutation applied to the term lambda if we do not the variable binding then we cannot the body without causing variable capture finally nominal logic permutations to apply to functions if we let compose permutations with functions then the application of a permutation to a function f is defined by the equation · f f to see the intuition behind this consider identifiers and constants · r b · r · b · · · · · lambda i body lambda · f un args · f un · if test true f if · test · true · f · let body let · letrec body letrec · body · body · syntax syntax · · ast · ast · patterns · · · pat pat · pat · pat figure lifted permutation application if we have the representation of f applying to f should apply to all the atoms in the implementation of f thus if f always returns some constant c then · f should return · c we achieve this effect by applying to the output of f however we have to be careful about inputs to f that end up in the output for example if f is the identity function then f contains no atoms and applying to f should not change it applying to the output of f would rename elements of the input that end up in the output we this by applying to the input any inputs that end up in the output will have the out by the and thus be unchanged support from this notion of permutation nominal logic defines the concept of the support of an object intuitively the support of an object is the set of atoms that occur free in it it is usually defined over a domain that alpha equivalent terms but for the sake of clarity we make uses of alpha equivalence explicit if is lambda i body lambda i body let body let i rhs body letrec body letrec i rhs body body i rhs body body i rhs body s l s l pat rhs if i body i i i body if rhs rhs and i body i i i body if i rhs i i i rhs and body i i i body if rhs rhs and i body i i i body if i rhs i i i rhs and body i i i body if s s and l l and i pat i i i pat and rhs i i i rhs where i and i are the identifiers in the corresponding pat and pat respectively figure alpha equivalence for we write t i i i t as an abbreviation for i i · t i i · t and use for for all but finitely many closed under symmetry transitivity and congruence the alpha equivalence relation the support of a term t is the smallest finite set t such that the following holds t · t t as an example of this consider the term lambda the atom with any atom other than results in an term thus is not in the support of that term on the other hand any atom that we swap with results in a term thus is in the support of that term finally nominal logic defines as holding for a function iff its support is empty thus f is iff any of the following equivalent equations hold where alpha equivalence over functions is interpreted ie they take alpha equivalent terms to alpha equivalent terms f · f f f f f f alpha equivalence as already mentioned hygiene is essentially lexical scoping at the macro level thus it would be natural to characterize hygiene by requiring terms to expand to terms however since macro transformers can be any turing computable function we cannot in general know the binding structure of and thus cannot define a nontrivial relation over them for example we may have a macro that uses a complicated function of its input to determine whether or not to expand to a let as another example even a simple let may not actually be a binding form if it is nested in some other macro call as the outer macro may the so the let becomes some other form fortunately while we cannot know the binding structure of we know the binding structure of the parts of the code already expanded into for example after one step of expansion the example in section becomes the following let t or f now that the let form has expanded into it cannot expand further and its binding structure is fixed we do not know the binding structure of its body though because the body is that may be further expanded nevertheless we can use a notion of alpha equivalence that accounts for the binding structure manifest in but assumes no nontrivial equivalences in this notion of alpha equivalence is a conservative approximation of whatever the actual binding structure may be and is sufficient to formally define when hygiene violations occur due to introduced references in figure we formally define this alpha equivalence it is entirely standard and behaves as usual for alpha equivalence except that it has no equivalences for other than for example the above expression is alpha equivalent to the following let xr t or f xr if these two expressions do not expand to expressions then hygiene is violated we formally define this as follows criterion reference hygiene a macro expansion step is with regard to references iff for any partially expanded expressions e e and e where e e and e e there exists an e such that e e and e e a macro system is with regard to references iff all its expansion steps are with regard to references since this criterion is independent of the details of the expansion algorithm we are free to choose from any of the wellknown methods for manipulating terms while alpha equivalence in section we this property by always generating bound reference atoms but we can also use the binding forms provided by nominal logic expansion b b body fresh b body permutation · fresh b body fresh · body alpha equivalence fresh b body fresh b body if b body b b b body fresh body body fresh b body fresh b b body if b body figure definitions of expansion permutation and alpha equivalence for fresh note that just like binder renaming the reference hygiene criterion ensures reference hygiene but not binder hygiene this is due to the fact that we do not know the binding structure of and thus have no nontrivial equivalences for it that problem is the subject of the remainder of this section fresh identifiers as a first step toward handling binder hygiene recall that the algorithm in section requires that macros generate the binder atoms in any identifiers they introduce in order to model this we introduce a scoping construct for binder atoms we write this as fresh b body where the binder atoms in b are introduced into the scope of body are not allowed in b and order is irrelevant so we treat b as a set in figure we define expansion permutation and alpha equivalence for this form in addition to the usual alpha equivalences we may omit atoms bound by fresh that are not in the support of its body and if fresh does not bind any atoms we can replace it with just its body we include these equivalences because the purpose of fresh is to bring the elements of b into the scope of its body if they are not used then we do not need fresh to bring them into scope just as with other binding constructs operations such as substitution must rename the binders in fresh to avoid capture now instead of using we make macros return a fresh wrapped around a syntax object for example the or macro expands as follows or f fresh let f if this is identical to when we used except that now comes from a locally declared scope instead of being a global a macro transformer should use fresh for any introduced binder atoms but in order to formally require this we need to define what counts as an introduced binder atom for example if a transformer returns xr yb when passed xr xb as input clearly yb was introduced by the macro and should be included in the atoms by fresh however what if a macro returns xr xb when passed xr xb as input the macro transformer might be the identity function in that case xb is not introduced by the macro as it comes from the input on the other hand the macro transformer could be the constant function that always returns xr xb in that case xb is introduced by the macro we just happen to have chosen an input that coincides with the output in order to handle this note that the binder atoms introduced by a transformer are in its support thus we can force macro transformers to use fresh for introduced binder atoms by requiring that their supports contain no binder atoms in other words we require that macro transformers be with respect to binder atoms this allows us to distinguish between transformers that return xr xb when passed xr xb because they are an identity function and those that do so because they are a constant function in the former case applying the permutation xb yb to the function before applying it to xr xb results in the following xb yb · f xr xb xb yb f yb xb xr xb xb yb · f yb xb · xr xb xb yb · f xr yb xb yb · xr yb xr xb on the other hand doing the same on a constant function results in the following xb yb · f xr xb xb yb f yb xb xr xb xb yb · f yb xb · xr xb xb yb · f xr yb xb yb · xr xb xr yb in the former case the transformer function is with respect to binder atoms and applying the permutation does not change the output in the latter case however the transformer is not and the permutation changes the output if a transformer needs to introduce a binder atom as is the case with tmp in the or macro then in order to remain it must use fresh for example instead of returning the constant xr xb we can have f return fresh xb xr xb in that case modulo alpha equivalence applying the permutation to f does not change it this is seen in the following xb yb · f xr xb xb yb f yb xb xr xb xb yb · f yb xb · xr xb xb yb · f xr yb xb yb · fresh xb xr xb fresh yb xr yb fresh xb xr xb this then gives rise to the following criterion defining hygiene with respect to binders criterion binder hygiene a macro transformer is with respect to binders iff it is with respect to binder atoms a macro system is with respect to binders if all its transformers are with respect to binders hygiene while the binder hygiene criterion provides a formal description of hygiene with respect to binders it still places the burden of ensuring hygiene on the macro author while a mechanical proof checker or a type system like in and wand or could verify that a particular transformer is we can also have the macro system automatically enforce binder hygiene a simple way to do this is to use fresh to capture any binder atoms in the support of a transformer thus we have the following definition where f is the support of f with respect to binder atoms definition automated hygiene given a transformer f let the version of that transformer be the following f fresh f f effectively this assumes f is to be and uses fresh to clean up any binder atoms that the macro author left in the support of f in order to apply the result of to an argument we lift fresh to be a function where application of fresh is as follows definition fresh application if s x then fresh s f x fresh s f x when s and the support of x are not disjoint we use to rename s to not conflict with x before applying this definition this definition trivially ensures the of as shown in the following theorem theorem of automated hygiene for any f with a finite support with respect to binder atoms f is with respect to binder atoms proof trivial the operator produces a fresh that captures the binder atoms in the support of f and thus the support of f is empty if the macro system applies to all macro transformers then all macros are automatically for example consider again the macro that returns the constant xr xb the support of this with respect to binder atoms is the singleton containing xb if we apply to this we get fresh xb f applying this to xr xb then results in the following fresh xb f xr xb fresh xb xb xb · f xr xb fresh xb xb xb · f xr xb fresh xb xb xb · xr xb fresh xb xr xb of course computing the support of a function is undecidable in general to get a practical implementation we can instead use the following definition definition automated hygiene alternative given a transformer f and a syntax object x where is some minimal permutation mapping each element of x to an atom not in the support of f or x let the application of the version of that transformer be as follows f x fresh · f x x · f x since we can easily compute the support of a syntax object this definition is practical to implement but behaves the same as definition as shown in the following theorem theorem of automated hygiene definitions definition and definition are equivalent definitions of up to alpha equivalence proof let s f x s f x and s x f also let be defined as in definition finally let v · f x note that · s · s s and s are all disjoint and v · f x · s · s s s we then have the following equalities fresh f f x fresh s s f x fresh · s s · f x fresh · s s · f x fresh · s · s · f x fresh v · s · s · f x fresh v s s · f x fresh · f x x · f x note that different choices of in definition may result in different results but as a corollary of theorem those results are all alpha equivalent to each other hygiene readers may notice that the binder hygiene criterion affects not just binder atoms introduced by transformers but also binder atoms observed by macro transformers for example consider the following macro transformer where extracts the binder atoms from two identifiers and tests if they are equal obs lambda if xr xb in a naive expansion system if the input to this transformer is xr xb then the output is however if we apply the permutation xb yb to the transformer then the result is the following xb yb · obs xr xb xb yb obs yb xb xr xb xb yb · obs yb xb · xr xb xb yb · obs xr yb xb yb · this function does not introduce any atoms nevertheless it does observe a binder atom in the input thus it changes its output and it is not this is not just an of how we have defined hygiene but is a distinction present in many hygiene algorithms indeed if obs were to take the identifier constant that it is comparing against the input and introduce it into its output then hygiene requires that it not bind over any identifiers from the input thus those identifiers should not be equal when they are observed by to achieve this we must keep the atoms in the input distinct from any atoms internal to the transformer and thus enforce hygiene this is not as well known as and reference hygiene but is just as important summary at this point we now have a mathematical definition of hygiene and can summarize the main points as follows first we assume identifiers are as in section second in order to enforce reference hygiene we require that the reference hygiene criterion holds in other words we require that expansion steps respect alpha equivalences over already exposed binding forms in the portion of the code third introduced binder atoms are noted by their presence in the support of a transformer fourth we require that the binder hygiene criterion hold in order to force transformers to be with respect to binder atoms and thus enforce binder hygiene when macros introduce a binder atom they must thus use fresh so they remain finally we can automatically make transformers be by using the operator as defined in definition or definition hygiene and the definition of hygiene in section has a close correspondence to the algorithm described by et al while a detailed explanation of is beyond the scope of this paper we a few of the in the algorithm are used to annotate syntax objects with binding information there are two different algorithms described by et al for applying these in one may be suspended in the middle of applying to a syntax object and are applied to descendant syntax objects in the other are applied and always syntax objects until they reach individual identifiers these two models are semantically equivalent the former is asymptotically more efficient but the latter is simpler and more directly corresponds to our definition of hygiene in the eager version of the algorithm are a sequence of marks and substitutions surrounding a base symbol for an identifier marks are atomic and substitutions map a set of marks and a particular symbol to a label which is also atomic new marks are added to the wrap of an identifier during the macro expansion process a fresh mark along with its inverse called an is created each time a macro is called the is placed on the identifiers in the input of the macro transformer while the mark is placed on the output of the macro transformer when a mark is placed on an identifier that has the corresponding they each other out identifiers with different marks are considered to be not the behavior of marks in this regard the behavior of the permutation in definition the difference is that a mark is essentially an abstract permutation that we treat without knowing how it maps atoms when a binding form expands a new label is chosen for the binding and a substitution is created that maps the marks and symbol of the identifier in the binding position to the new label this substitution is added to the of any identifiers in the body when an identifier expands in a reference position the substitutions are to determine to what label it is bound this models the behavior of how binding forms are expanded in section the generated reference atom corresponds to the new label the subst operator corresponds to the creation of a substitution finally note that the operators and in are equivalent to comparing the reference and binder parts respectively of the identifiers described in section in all these the algorithm corresponds to an almost direct implementation of the mathematical principles in section the major difference is that treats per as opaque symbolic objects ie marks and the operations on identifiers are stored in forms ie the marks and substitutions in a wrap this allows operators such as quote and that hygiene and either strip from identifiers or the wrap of an identifier to a new symbol the mathematics in section can also support these operations if we generalize it to treat permutations as opaque objects and keep subst related work et al defined a macro expansion algorithm by marking identifiers with time stamps indicating the macro expansion step in which they were introduced however their definition of hygiene only hygiene and not hygiene and then proposed using syntactic closures to handle hygiene they define hygiene to include both and hygiene with syntactic closures macros take syntactic environments as arguments and return expressions that have been closed over particular environments these environments are then used when interpreting identifiers in those expressions takes a different approach and passes functions for explicitly renaming and comparing identifiers to each macro transformer in both these systems macro authors must be careful to correctly use the tools provided for ensuring hygiene as they may otherwise end up with macros and combined the pattern matching language of and wand with the ideas from and to create a system that lets users write highlevel macros that are automatically finally the algorithm et al extended this by allowing macro transformers to be arbitrary functions and providing mechanisms for the rules of hygiene the system specified by the scheme standard et al is based on this along with extensions for macros these systems all focus on the algorithmic implementation of hygiene and define hygiene only informally or by way of a particular algorithm however the reference hygiene criterion and the binder hygiene criterion are applicable and we can consider how they apply to these systems et al satisfies the binder hygiene criterion but not the reference hygiene criterion which reflects the fact that they are concerned only with binder hygiene and and provide the tools for macro authors to satisfy both the reference hygiene criterion and the binder hygiene criterion but do not enforce them nevertheless whether a macro author has used the tools correctly can be determined by whether these criteria are by the transformer and and et al automatically satisfy the reference hygiene criterion and the binder hygiene criterion except when hygiene operators are used a number of systems et al and felleisen and wand use shape types or some other typing discipline to enforce hygiene these systems generally annotate macros with types that specify their binding structures and enforce the reference hygiene criterion and the binder hygiene criterion as a consequence of several of them directly connect their notions of hygiene to nominal logic in a typed setting however these type systems reject many otherwise wellformed macros and do not consider hygiene in a general setting without a type system or when not all binding structures are known in advance the definition of hygiene that we propose is not only useful for determining whether a particular macro system is but also provides a useful perspective on extensions to hygiene that have been proposed for example van gives examples of macros that use local functions to manipulate the syntax since the usual hygiene algorithms do not distinguish between identifiers introduced by different functions within the same macro expansion step these functions may capture identifiers introduced by each other this is easily solved by the operator to macro authors so they can annotate these functions as to introduce distinct identifiers similar techniques can be used with the local transformations in and felleisen and another example is macros et al the classic case of this is a loop macro that binds break to a continuation that breaks out of the loop this binding is introduced by the macro but should be visible to the loop body written by the macro user we conjecture that this can be handled by allowing macros to specify that they have a nonempty support for example loop would specify that break is in its support conclusion hygiene is an essential aspect of the scheme macro system there have been multiple implementations of it over the years but no general formal definition of what it is existing definitions are either informal to a particular expansion algorithm or consider only a restricted subset of macros that follow a certain typing discipline in this paper we examine several examples of hygiene and how it is violated in naive from these examples we then develop a simple expansion algorithm that preserves hygiene based on the developed with that algorithm we then construct a precise formal definition of hygiene this definition hygiene to nominal logic and shows that hygiene is a combination of alpha equivalence and it is algorithm independent and can be used to test whether a proposed algorithm is this definition closely corresponds to several existing algorithms and in particular the algorithm closely how one would naturally write an algorithm to satisfy this definition acknowledgments thanks go to mitchell wand william r j johnson michael and the anonymous reviewers for their comments suggestions and help in improving this paper this material is based upon work supported in part by nsf grant any conclusions or expressed in this material are those of the authors and do not necessarily reflect the views of the nsf this article reports on work supported by the advanced research projects under agreement no fa the views expressed are those of the authors and do not reflect the policy or position of the department of or the us references and matthew keeping it clean with syntax parameters in proceedings of the workshop on scheme and functional programming october alan and syntactic closures in proceedings of the acm conference on lisp and functional programming lfp pages ­ new york ny usa acm isbn x doi william macros through explicit renaming acm sigplan lisp pointers october doi william and macros that work in proceedings of the th acm sigplansigact symposium on principles of programming languages popl pages ­ new york ny usa acm isbn doi macros journal of functional programming special issue september doi s and matthias felleisen macros in proceedings of the fourth workshop on scheme and functional programming pages ­ november and matthias felleisen macros in and editors generative programming and component engineering volume of lecture notes in computer science pages ­ springer berlin isbn doi and matthias felleisen macros in proceedings of the th acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm isbn doi r syntactic abstraction the in and greg editors code leading programmers explain how they think theory in practice chapter july isbn r robert and syntactic abstraction in scheme lisp and symbolic computation ­ december print online doi bf j and andrew m pitts a new approach to abstract syntax with variable binding formal aspects of computing ­ ­ july print x online doi s e and macros as computations typesafe generative binding macros in in proceedings of the acm sigplan international conference on functional programming icfp pages ­ new york ny usa acm isbn doi david a theory of typed macros phd thesis university boston ma usa may david and mitchell wand a theory of macros in editor programming languages and systems volume of lecture notes in computer science pages ­ springer berlin isbn doi daniel p friedman matthias felleisen and bruce macro expansion in proceedings of the acm conference on lisp and functional programming lfp pages ­ new york ny usa acm isbn doi e and mitchell wand deriving syntactic transformations from their specifications in proceedings of the th acm symposium on principles of programming languages popl pages ­ new york ny usa acm isbn doi michael r matthew and van eds revised report on the algorithmic language scheme september url michael r matthew van findler and revised report on the algorithmic language scheme journal of functional programming august doi s van macros september url 