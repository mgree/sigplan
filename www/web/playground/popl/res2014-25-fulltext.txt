on coinductive equivalences for higherorder probabilistic functional programs sangiorgi di inria de de abstract we study bisimulation and context equivalence in a probabilistic calculus the contributions of this paper are we show a technique for proving congruence of probabilistic applicative bisimilarity while the technique follows method some of the are quite different relying on nontrivial properties for sets of real numbers secondly we show that while bisimilarity is in general strictly than context equivalence between the two relations is on pure terms the resulting equality is that induced by trees generally accepted as the extensional equivalence on pure terms under a lazy finally we derive a coinductive of context equivalence on the whole probabilistic language via an extension in which terms to distributions may appear in redex position another motivation for the extension is that its operational semantics allows us to experiment with a different congruence technique namely that of logical bisimilarity categories and subject descriptors f logics and meaning of programs specifying and verifying and reasoning about of programs f logics and meaning of programs semantics of programming semantics general terms theory keywords bisimulation probabilistic lambda calculus coinduction technique introduction probabilistic models are more and more not only are they a tool when dealing with uncertainty and incomplete information but they sometimes are a rather than an option like in computational cryptography where eg secure public key encryption schemes need to be probabilistic a nice way to deal computationally with probabilistic models is to allow probabilistic choice as a primitive when designing algorithms this way switching from usual deterministic computation to a new paradigm called probabilistic computation examples of application areas in which permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm probabilistic computation has proved to be useful include natural language processing computer and machine learning this new form of computation of course needs to be available to programmers to be accessible and indeed various probabilistic programming languages have been introduced in the last years spanning from abstract ones to more concrete ones being inspired by various programming like imperative functional or even object oriented a quite common scheme consists in any deterministic language with one or more primitives for probabilistic choice like binary probabilistic choice or primitives for distributions one class of languages that well with probabilistic computation are functional languages indeed algorithms as functions allows a smooth integration of distributions into the itself reflected at the level of types through monads as a matter of fact many existing probabilistic programming languages are designed around the calculus or one of its like scheme the focus of this paper are operational techniques for understanding and reasoning about program equality in higherorder probabilistic languages checking computer programs for equivalence is a crucial but challenging problem equivalence between two programs generally means that the programs should behave in the same manner under any context specifically two terms are context equivalent if they have the same convergence behavior ie they do or do not terminate in any possible context finding effective methods for context equivalence proofs is particularly challenging in higherorder languages bisimulation has as a very powerful operational method for proving equivalence of programs in various kinds of languages due to the associated coinductive proof method to be useful the behavioral relation resulting from bisimulation bisimilarity should be a congruence and should also be sound with respect to context equivalence bisimulation has been onto higherorder languages by abramsky this version of bisimulation called applicative bisimulation has received considerable attention in short two functions m and n are applicative bisimilar when their applications m p and n p are applicative bisimilar for any argument p often checking a given notion of bisimulation to be a congruence in higherorder languages is nontrivial in the case of applicative bisimilarity congruence proofs usually rely on method other forms of bisimulation have been proposed such as bisimulation and logical bisimulation with the goal of the burden of the proof of congruence and of language extensions in this work we consider the pure calculus extended with a probabilistic choice operator context equivalence of two terms means that they have the same probability of convergence in all contexts the objective of the paper is to understand context equivalence and bisimulation in this probabilistic higherorder language called the paper contains three main technical contributions the first is a proof of congruence for probabilistic applicative bisimilarity along the lines of method this technique consists in defining for every relation on terms r its lifting rh the construction essentially by definition ensures that the relation obtained by lifting bisimilarity is a congruence the latter is then proved to be itself a bisimulation therefore with applicative bisimilarity probabilistic applicative bisimulation is obtained by setting up a labelled markov chain on top of terms then to it the coinductive scheme introduced by and in a firstorder setting in the proof of congruence the construction closely reflects analogous constructions for nondeterministic extensions of the calculus the are in the technical details for proving that the resulting relation is a bisimulation in particular our proof of the socalled key lemma an essential in method relies on nontrivial properties for sets of real numbers these properties themselves proved by modeling the problem as a flow network and then apply the theorem the congruence of applicative bisimilarity yields soundness with respect to context equivalence as an easy corollary completeness however fails applicative bisimilarity is proved to be a subtle aspect is also the late vs early formulation of bisimilarity with a choice operator the two versions are semantically different our construction relies on the late style in our second main technical contribution we show that the presence of higherorder functions and probabilistic choice in contexts gives context equivalence and applicative bisimilarity maximal power on pure terms we do so by proving that on pure terms both context equivalence and applicative bisimilarity coincide with the tree equality which terms with the same tree briefly and is generally accepted as the extensional equivalence on pure terms under a lazy the result is in contrast with what happens under a nondeterministic interpretation of choice or in the absence of choice where context equivalence is than equality our third main contribution is a coinductive of probabilistic context equivalence on the whole language as opposed to the subset of pure terms we obtain this result by setting a bisimulation game on an extension of in which weighted formal sums terms to distributions may appear in redex position of distributions as sets of terms the construction us of the reduction of nondeterministic to deterministic automata the technical details are however quite different because we are in a higherorder language and therefore once more we are with the congruence problem for bisimulation and because formal sums may contain an infinite number of terms for the proof of congruence of bisimulation in this extended language we have the technique of logical bisimulation in this method and in the related method of bisimulation the clauses of applicative bisimulation are modified so to allow the standard congruence argument for bisimulations in firstorder languages where the bisimulation method itself is exploited to establish that the closure of the bisimilarity under contexts is again a bisimulation logical have two key elements first bisimilar functions may be tested with bisimilar rather than identical arguments more precisely the arguments should be in the context closure of the bisimulation the use of contexts is necessary for soundness secondly the transition system should be smallstep deterministic or at least confluent and the bisimulation game should also be on internal moves in our probabilistic setting the ordinary logical bisimulation game has to be modified substantially formal sums represent possible of running terms hence they should appear in redex position only allowing them anywhere would considerably the obligation of redex position for certain terms is in contrast with the basic schema of logical bisimulation in which related terms can be used as arguments to bisimilar functions and can therefore end up in arbitrary positions we solve this problem by moving to coupled logical bisimulations where a bisimulation is formed by a pair of relations one on terms the other on terms extended with formal sums the bisimulation game is on both relations but only the first relation is used to input arguments for functions another point is the meaning of internal transitions for formal sums in logical bisimilarity the transition system should be smallstep and formal sums should into values in a finite number of steps even if the number of terms composing the formal sum is infinite we satisfy these requirements by defining the transition system for extended terms on top of that for terms the proof of congruence of coupled logical bisimilarity also exploits an upto distribution bisimulation proof technique in the paper we adopt callbyname evaluation the results on applicative bisimilarity can be onto callbyvalue in contrast the other results is more problematic and we leave it for future work see section for more details an extended version of this paper is available further related work research on higherorder probabilistic functional languages have so far mainly focused on either new programming constructs or denotational semantics or applications the underlying operational theory which in the ordinary calculus is known to be very rich has so far largely in this section we give some pointers to the relevant literature on probabilistic calculi without any hope of being exhaustive various probabilistic calculi have been proposed starting from the work by followed by more advanced studies by jones and plotkin both these works are mainly focused on denotational semantics more recently there has been a on this line of work with the introduction of adequate and sometimes also denotational models for probabilistic variations of pcf there is also another thread of research in which various languages derived from the calculus are given types in monadic style allowing this way to model concrete problems like bayesian inference and probability models arising in these works however do not study operationally based theories of program equivalence nondeterministic extensions of the calculus have been in typed calculi as well as in untyped calculi the in all these works is mainly apart from all authors closely follow the testing theory in its modalities may or must separately or together approach inherits both testing and bisimulation elements our definition of applicative bisimulation follows and scheme for systems many other forms of probabilistic bisimulation have been introduced in the literature but their greater complexity is usually due to the presence of both nondeterministic and probabilistic behaviors or to continuous probability distributions see such as contextual of equality include in a calculus with in which deadlock is observable and in a calculus with choice parallel composition and both callbyname and callbyvalue applications see for a survey on observational of calculus trees a pure untyped probabilistic lambda calculus let x x y be a set of variables the set of term expressions or terms is defined as follows m n l x xm mn m n where x x the only nonstandard operator in is probabilistic choice m n is a term which is meant to behave as either m or n each with probability a more general construct m p n where p is any computable real number from is derivable given the of the calculus see eg the set of free variables of a term m is indicated as and is defined as usual given a finite set of variables x x x denotes the set of terms whose free variables are among the ones in x a term m is closed if or equivalently if m the substitution of n for the free occurrences of x in m is denoted m nx we sometimes use the identity term i def xx the k def and the purely divergent term def terms are now given a callbyname semantics following a term is a value if it is a closed abstraction we call v the set of all values values are ranged over by metavariables like v w x closed terms evaluates not to a single value but to a partial value distribution that is a function d v r such that v v dv distributions do not necessarily sum to so to model the possibility of probabilistic divergence given a value distribution d its support sd is the subset of v whose elements are values to which d attributes positive probability value distributions ordered pointwise form both a lower semilattice and an cpo limits of chains always exist given a value distribution d its sum d is v v d v the callbyname semantics of a closed term m is a value distribution m defined in one of the ways explained in we recall this now though only briefly for lack of space the first step consists in defining a formal system deriving finite lower approximations to the semantics of m bigstep approximation semantics as an example derives judgments in the form m d where m is a term and d is a value distribution of finite support see figure smallstep approximation semantics can be defined similarly and derives judgments in the form m d bigstep and smallstep can simulate each other ie if m d then m e where e d and vice versa in the second step m called the semantics of m is set as the least upper bound of distributions obtained in either of the two ways m def sup d sup d m d m d notice that the above is welldefined because for every m the set of all distributions d such that m d is directed and thus its least upper bound is a value distribution because of completeness example consider the term m def i k we have m d where di and dv is elsewhere as well as m where is the empty distribution the distribution m assigns to i and to k the semantics of terms satisfies some useful equations such as lemma m n m n we are interested in context equivalence in this probabilistic setting typically in a scenario as the nondeterministic one terms are considered context equivalent if they both converge or diverge here we need to take into account quantitative information f n f n f n f x f x x f x k f n k n f id k f n f g g n m n f g f n m n f g figure three higherorder functions definition context preorder and equivalence the expression m p stands for m p ie the term m with probability p the context preorder m n if cm p implies cn q with p q for every closing context c the equivalence induced by is probabilistic context equivalence denoted as remark types open terms the results in this paper are stated for an untyped language them to a simplytyped language is straightforward we use integers booleans and recursion in examples moreover while the results are often stated for closed terms only they can be generalized to open terms in the expected manner in the paper context equivalences and are defined on open terms are defined on closed terms and it is then intended that they are extended to open terms by requiring the usual closure under substitutions example we give some basic examples of higherorder prob programs which we will using the coinductive techniques we introduce later in this paper consider the functions and from figure they are written in a language extended with probabilistic choice but can also be seen as terms in a typed probabilistic calculus with integers and recursion to term takes a function f and a natural number n in input then it proceeds by a fair captured here by the binary infix operator and depend ing on the outcome of the either calls f on n or recursively calls itself on f and n when with eg the identity and the natural number the program evaluates to the geometric distribution assigning probability n to any positive natural number n a similar effect can be obtained by which only takes f in input then modifying it along the evaluation the function is more complicated at least to understand its behavior one should first look at the auxiliary function if m and n are two natural numbers and f and g are two functions m n f g callbyname reduces to the following expression f n f n f nm g nm the term works by forwarding its three arguments to the fourth argument is a recursive call to where however k is replaced by any number greater or equal to it chosen according to a geometric distribution the functions above can all be expressed in using fixedpoint combinators as we will see soon and k are context equivalent whenever k is a natural number probabilistic bisimulation in this section we recall the definition and a few basic notions of bisimulation for labelled markov chains following and in section we will then adapt this form of bisimilarity to the probabilistic calculus by combining it with applicative bisimilarity definition a labelled markov chain is a triple s l p such that · s is a countable set of states · l is set of labels m bt v v bv m d p nx xp sd m n xp sd d xp · ba m d n e m n · d · e bs figure bigstep callbyname approximation semantics for · p is a transition probability matrix ie a function p s × l × s r such that the following normalization condition holds ls s ps s where as usual ps x stands for tx ps t whenever x s if r is an equivalence relation on s sr denotes the of s modulo r ie the set of all equivalence classes of s modulo r given any binary relation r its reflexive and transitive closure is denoted as r definition given a labelled markov chain s l p a probabilistic bisimulation is an equivalence relation r on s such that s t r implies that for every l and for every e sr ps e pt e note that a probabilistic bisimulation has to be by definition an equivalence relation this means that in principle we are not allowed to define probabilistic bisimilarity simply as the union of all probabilistic bisimulations as a matter of fact given r t two equivalence relations r t is not necessarily an equivalence relation the following is a standard way to overcome the problem lemma if is a collection of probabilistic bisimulations then also their reflexive and transitive closure ii ri is a probabilistic bisimulation lemma allows us to define the largest probabilistic bisimulation called probabilistic bisimilarity it is def r r is a probabilistic bisimulation indeed by lemma is a probabilistic bisimulation too we now claim that the inclusion is obvious the other way around follows by being a probabilistic bisimulation and hence included in in the notion of a probabilistic simulation play the role of equivalence relations given a labelled markov chain s l p a probabilistic simulation is a preorder relation r on s such that s t r implies that for every l and for every x s ps x pt rx where as usual rx stands for the of x namely the set y s x x x r y lemma holds for probabilistic simulations and as a consequence we are allowed to define similarity simply as def r r is a probabilistic simulation any symmetric probabilistic simulation is a probabilistic bisimulation contrary to the nondeterministic case however simulation equivalence coincides with bisimulation proposition coincides with op for technical reasons that will become apparent soon it is convenient to consider markov chains in which the state space is partitioned into disjoint sets in such a way that comparing states coming from different components is not possible remember that the disjoint union ii xi of a family of sets is defined as a i i i a xi if the set of states s of a labelled markov chain is a disjoint union ii xi one wants that bisimulation relations only compare elements coming from the same xi ie a j implies i j in this case we say that the underlying labelled markov chain is probabilistic applicative bisimulation and technique in this section notions of similarity and bisimilarity for are introduced in the spirit of work on applicative bisimulation this consists in s operational semantics as a labelled markov chain then giving the and notion of bisimulation for it states will be terms while labels will be of two kinds one can either evaluate a term obtaining a distribution of values or apply a term to a value the resulting bisimulation probabilistic applicative bisimulation will be shown to be a congruence thus included in probabilistic context equivalence this will be done by a nontrivial generalization of technique which is a wellknown methodology to get congruence results in presence of higherorder functions but which has not been applied to probabilistic calculi so far formalizing probabilistic applicative bisimulation requires some care as usual two values xm and xn are defined to be bisimilar if for every l m lx and n lx are themselves bisimilar but how if we rather want to compare two arbitrary closed terms m and n the simplest solution consists in following and and that every equivalence class of v modulo bisimulation is attributed the same measure by both m and n values are thus treated in two different ways they are both terms and values and this is the reason why each of them corresponds to two states in the underlying markov chain definition can be seen as a labelled markov chain v p that we denote with labels are either closed terms which model parameter passing or that models evaluation observe that the states of the labelled markov chain we have just defined are elements of the disjoint union v two distinct states correspond to the same value v and to avoid we call the second one ie the one coming from v a distinguished value when we want to on the fact that a value xm is distinguished we indicate it with xm we define the transition probability matrix p as follows · for every term m and for every distinguished value xn pm xn def m xn · for every term m and for every distinguished value xn m n mx def · in all other cases p returns terms seen as states only interact with the environment by performing while distinguished values only take other closed terms as parameters simulation and bisimulation relations can be defined for as for any labelled markov chain even if strictly speaking these are binary relations on v we often see them just as their restrictions to formally a probabilistic applicative bisimulation a is simply a probabilistic bisimulation on this way one can define probabilistic applicative bisimilarity which is denoted similarly for probabilistic applicative simulation and probabilistic applicative similarity denoted remark early vs late technically the distinction between terms and values in definition means that our bisimulation is in late style in bisimulations for concurrent languages late indicates the explicit manipulation of functions in the clause for input actions functions are chosen first and only later the input value received is taken into account is used in to early style where the order of quantifiers is so that the choice of functions may depend on the specific input value received in our setting an early style would mean having transitions such as xm n m nx and then setting up a probabilistic bisimulation on top of the resulting transition system we leave for future work a study of the comparison between the two in this paper we to the late style because easier to deal with especially under technique previous works on applicative bisimulation for nondeterministic functions also focus on the late approach remark defining applicative bisimulation in terms of labelled markov chains has the advantage of the definition in a familiar framework most importantly this will be useful when dealing with method to out the explicit operational details of the definition a probabilistic applicative bisimulation can be seen as an equivalence relation r × such that whenever m r n m e v n e v for any equivalence class e of r that is the probability of reaching a value in e is the same for the two terms if m and n are values say xp and xq then p lx r for all l the special treatment of values in clause the use of labelled markov chains in definition terms with the same semantics are lemma the binary relation r m n × st m n v v v × v is a conversely knowing that two terms m and n are bisimilar means knowing quite a lot about their convergence probability lemma adequacy of bisimulation if m n then m n moreover if m n then m n example the semantics of the terms m def xx x xx n def differ as for every value v we have m v if v is xx x or xx otherwise n v if v is otherwise nonetheless we can prove m n indeed xx x xx because for every l the three terms l l l and il all have the same semantics ie l now consider any equivalence class e of distinguished values modulo if e includes the three distinguished values above then pm e m v n v pn e v e v e otherwise pm e pn e probabilistic applicative bisimulation is a congruence in this section we prove that probabilistic applicative bisimulation is indeed a congruence and that its sibling is a the structure of the proof follows so we will not give all the details the main idea consists in defining a way to turn an arbitrary relation r on possibly open terms to another one rh in such a way that if r satisfies a few simple conditions then rh is a including r the key step then is to prove that rh is indeed a bisimulation in view of proposition considering similarity suffices here it is here convenient to work with of relations called relations ie sets of triples in the form x m n where m n x thus if a relation has the pair m n with m n x then the corresponding relation will include x m n recall that applicative bisimilarity is extended to open terms by considering all closing substitutions given any relation r we write x m r n if x m n r a relation r is said to be compatible iff the four conditions below hold com x x x x x r x com x x xm n x x x x m r n x xm r xn com x n l p x x m r n x l r p x ml r np com x n l p x x m r n x l r p x m l r n p the notions of an equivalence relation and of a preorder can be straightforwardly generalized to relations and any compatible relation that is an equivalence relation respectively a preorder is said to be a congruence respectively a if bisimilarity is a congruence then cm is bisimilar to cn whenever m n and c is a context in other words terms can be replaced by equivalent ones in any context this is a crucial any notion of equivalence is expected to pass it is wellknown that proving bisimulation to be a congruence may be nontrivial when the underlying language contains higherorder functions this is also the case here proving com com and com just by the operational semantics of the involved terms is indeed possible but the method fails for com when the involved contexts contain applications we thus need to introduce nontrivial technical tools actually the lifting of any relation r is the relation rh defined by the rules in figure the reader familiar with method should have a sense of vu here indeed this is the same definition one finds in the of nondeterministic calculi the language of terms after all is the same this the first part of the proof indeed one already knows that if r is a preorder then rh is compatible closed under and includes r since all these properties are already known see eg and only depend on the shape of terms and not on their operational semantics for the readers convenience all these proofs can be found in something is missing however before we can conclude that h is a namely transitivity we also follow here and consider the transitive closure h which is a preorder by construction this is just the first half of the we also need to prove that h is a simulation as we already know it is a preorder the following lemma gives us the missing bit lemma key lemma if m h n then for every x x it holds that m xx n x h x the proof of this lemma is and is discussed in the next section from the lemma using a standard argument we derive the needed results and ultimately the most important result of this section theorem on terms is a and is a congruence x m rh p x x r m how x x rh m x x m rh l x xl r n x xm rh n x x how x n rh q x m n rh l x pq r l how x m rh p x n rh q x p q r l how x m n rh l figure lifting for proof of the key lemma proving the key lemma turns out to be much more difficult than for deterministic or nondeterministic cases in particular the case when m is an application relies on another technical lemma we are now going to give which itself can be proved by tools from linear programming the combinatorial problem we will face while proving the key lemma can actually be and understood suppose we have n sets x x x whose elements are labelled with real numbers as an example we could be in a situation like the one in figure a where for the sake of simplicity only the labels are indicated we fix three real numbers p def p def p def it is routine to check that for every i it holds that pi xi ii ii where x is the sum of the labels of the elements of x let us observe that it is of course possible to turn the three sets x x x into three disjoint sets y y and y where each yi contains copies of the elements of xi whose labels however are obtained by splitting the ones of the original elements examples of those sets are in figure b if you the three sets you obtain the diagram we started from quite however the examples from figure have an additional property namely that for every i it holds that pi yi we now show that finding sets satisfying the properties above is always possible even when n is arbitrary suppose p pn r and suppose that for each i n a real number ri r is defined such that for every such i it holds that ii pi ji rj then ri in is said to be a probability assignment for n is it always possible to probability assignments the answer is positive lemma probability assignments let p def ri in be a probability assignment then for every nonempty i n and for every k i there is r such that the following conditions all hold for every i it holds that ki for every k n it holds that pk ki · ri proof any probability assignment p can be seen as a flow network where nodes are the nonempty subsets of n plus a distinguished source s and target t edges then go from s to each singleton i with pi from every nonempty i to i i n whenever i i with and from every such i to t with ri the thesis then is easily proved equivalent to showing that such a net supports a flow of value pi and indeed the fact that this is the value of the maximum flow from s to t can be proved via the theorem remark throughout the following proof we will implicitly use a routine result stating that m n implies m xx n x x for every x x the property needed by the latter is precisely the reason why we have formulated as a labelled markov chain xx consists of distinguished values only and is nothing but x x proof of lemma this is equivalent to proving that if m h n then for every x x the following implication holds if m d then n x h x this is an induction on the structure of the proof of m d some interesting cases follow · if m is a value xl and then the proof of m h n necessarily ends as follows x l h p xp xl h n n let x be any subset of x now if l x then and the inequality trivially holds if on the contrary l x then p h x consider p the set of terms that are in relation with p via we have that for every q p both x l h p and x p q hold and as a consequence x l h q does this is a consequence of a property of see in other words p h x but then n x h x n x p xp xp · if m is an application lp then m d is obtained as follows l f qp lp q f xq · moreover the proof of m h n must end as follows l hr p h s rs lp h n n now since l f and l h r by induction hypothesis we get that for every y x it holds that f xy rx h y let us now take a look at the distribution d f xq · q since f is a finite distribution the sum above is actually the sum of finitely many let the support sf of f be xq it is now time to put the above into a form that is amenable to treatment by lemma let us consider the n sets h q h qn to each term u in them we can associate the probability we are then in the scope of lemma since by induction hypothesis we know that for every y x f xy rx h y we can then conclude that for every u h q qn h qi in x a x x y y b figure sets y there are n real numbers such that in u h qi in f u h qi i n so we can conclude that d · in u h qi · in u h qi now whenever qi h u and p h s it follows that h u sx we can then apply the inductive to the n derivations of obtaining that for every x x · u h x in u h qi · u h x in u h · u h x u h in · u h x u h in · u h x u h · u h x u x h x n x h x n x h x which is the thesis this concludes the proof relating applicative bisimulation and context equivalence the congruence of applicative bisimilarity yields the inclusion in context equivalence theorem for all m n m n implies m n the converse inclusion fails a counterexample is described in the following example for m def xl p and n def xl xp where l is y and p is yz we have m n hence m n but m n we prove that the above two terms are context equivalent by means of this is a relation that can be shown to coincide with context equivalence by a context lemma itself proved by the technique more details are in see also section example we consider again the programs from example terms and only differ because the former performs all probabilistic choices on natural numbers obtained by applying a function to its argument while in the latter choices are done at the functional level and the argument to those functions is provided only at a later stage as a consequence the two terms are not applicative bisimilar and the reason is to that for the inequality of the terms in example in contrast the bisimilarity between and k where k is any natural number intuitively holds because both and k evaluate to a single term when with a function while they start in a probabilistic way only after the second argument is provided at that point the two functions in very different ways but their semantics in the sense of section is the same cf lemma as a bisimulation one can use the equivalence generated by the relation k m n m n k l using b and c for the body of and respectively the power of probabilistic contexts we show here that applicative bisimilarity and context equivalence if the tested terms are pure deterministic terms in other words if the probabilistic choices are into the terms only through the inputs supplied to the tested functions applicative bisimilarity and context equivalence yield exactly the same power to show this we prove that on pure terms both relations coincide with the tree equality which terms with the same tree briefly are the lazy variant of trees briefly bt the most popular tree structure in the calculus only correctly express the computational content of terms in a strong while they fail to do so in the lazy one for instance the term x and as both have identical but in a lazy we would always distinguish between them hence they have different the tree of m lt m is constructed as follows lt m def x xn if m is an of order n lt m def if m is an of order finally if m has principal head normal form x mm then lt m is a tree with root x and with lt m lt mm as subtrees being defined can of course be infinite we write m ll n iff lt m lt n example let be an of order such as def and consider the terms m def n def these terms have been used to prove results in a canonical model for the lazy calculus by abramsky and for this they show that in the model the convergence test is definable this operator when it receives an argument would return the identity function if the supplied argument is and would diverge otherwise the convergence test can distinguish between the two terms as m reduces to an abstraction whereas n diverges however no pure term can make the same distinction the two terms also have different ll trees lt m xx lt n xx d yx x d d y d although in as in the convergence test operator is not definable m and n can be separated using probabilities by running them in a context c that would as argument then cm whereas cn example canonical model is itself than equality for instance the terms m def and n def have different but are equal in model and hence equal for context equivalence in they are separated by context equivalence in for instance using the context c def since cm whereas cn we already know that on full applicative bisimilarity implies context equivalence hence to prove that on pure terms the two equivalences to equality ll it suffices to prove that for those pure terms implies ll and that ll implies the first implication is obtained by a variation on the technique a powerful methodology for separation results in the calculus often employed in proofs about local structure theorems of models for this we exploit an inductive of equality via the for n written is essentially obtained by observing a tree only upto level n the key lemma shows that any difference on the trees of two terms within level n can be observed by a suitable context of the probabilistic calculus we write m as an abbreviation for the term m we denote by qn n the term x · · · xn this is usually called the of degree n play a key role in the technique a variant of them the play a role in lemma below a term m is a of degree n if either m qn or there exists r n such that m x xr xr · · · · · · xn a function f from the positive integers to terms is a function if for all n f n is a of degree n lemma suppose m n for some n and let x xr be the free variables in m n then there are integers mx and k and functions fx such that for all m k there are closed terms rm such that the following holds if m fx m mx x m and n fx m mx x m then r s the proof goes by induction on the least n such that m n the fact the technique actually works implies that the power of probabilistic contexts is at least as strong as the one of corollary for m n m n implies m ll n to show that equality is included in probabilistic applicative bisimilarity we proceed as follows first we define a refinement of the latter essentially one in which we observe all probabilistic choices as a consequence the underlying bisimulation game may ignore probabilities the obtained notion of equivalence is strictly than probabilistic applicative bisimilarity the advantage of the refinement is that both the inclusion of equality in the refinement and the inclusion of the latter in probabilistic applicative bisimilarity turn out to be relatively easy to prove a direct proof of the inclusion of equality in probabilistic applicative bisimilarity would have been harder as it would have required extending the notion of a tree to then reasoning on substitution closures of such trees the definition below relies on two notions of reduction m p n means that m callbyname reduces to n in one step with probability p as a matter of fact p can be either or then is obtained by composing zero or more times and the corresponding real numbers definition a relation r × is a strict applicative bisimulation whenever m r n implies if m p then n q and p r q if m p then n q and p r q if m xp then n xq and p lx r for all l the converse of and strict applicative bisimilarity is the union of all strict applicative bisimulations if two terms have the same then passing them the same argument m produces exactly the same choice structure intuitively whenever the first term finds a copy of m in head position also the second will find m lemma if m ll n then m r n for some strict applicative bisimulation r terms which are strict applicative bisimilar cannot be distinguished by applicative bisimilarity proper since the requirements induced by the latter are less strict than the ones the former imposes lemma strict applicative bisimilarity is included in applicative bisimilarity since we now know that for pure deterministic terms ll is included in by lemma and lemma that is included in by theorem and that the latter is included in ll corollary we can conclude corollary the relations ll and coincide in coupled logical bisimulation in this section we derive a coinductive of probabilistic context equivalence on the whole language as opposed to the subset of terms as in section for this we need to xm m n ss m n xm sl mi di i mi pi i di pi sp z · m e f sa em fm figure reduction rules for fs manipulate formal weighted sums thus we work with an extension of in which such weighted sums may appear in redex position an advantage of having formal sums is that the transition system on the extended language can be smallstep and deterministic any closed term that is not a value will have exactly one possible internal transition this will make it possible to the logical bisimulation method in which the congruence of bisimilarity is proved using a standard induction argument over all contexts the refinement of the method handling probabilities called coupled logical bisimulation uses pairs of relations as we need to distinguish between ordinary terms and terms possibly containing formal sums we to follow logical bisimulations rather then bisimulations because the former admit a simpler definition in the latter each pair of terms is with an environment that is an extra set of pairs of terms moreover it is what environments should be when one also considers formal sums we leave this for future work formal sums are a tool for representing the behaviour of running terms thus on terms with formal sums only the results for closed terms interest us however the characterization of contextual equivalence in as coupled logical bisimulation also holds on open terms notation and terminology we write fs for the extension of in which formal sums may appear in redex position terms of fs are defined as follows m n being terms e f em ii mi pi m n xm in a formal sum ii mi pi i is a countable possibly empty set of indices such that ii pi we use for binary formal sums formal sums are ranged over by metavariables like h k when each mi is a value ie an abstraction then ii mi pi is a formally value such values are ranged over by z y x if h ii mi pi and k jj mj pj where i and j are disjoint then h k mr pr similarly if for every j j is ii then j pj stands for ij · pj for h i mi pi we write h for the real number i pi if z i pi then z · n stands for i pi the set of closed terms is fs any partial value distribution d in the sense of section can be seen as the formal sum v v v dv similarly any formal sum h ii mi pi can be mapped to the distribution ii pi · mi that we indicate with h reduction between fs terms written e f is defined by the rules in figure these rules are given on top of the operational semantics for as defined in section which is invoked in the premise of rule if there is a i with mi not a value the reduction relation is deterministic and strongly normalizing we use for its reflexive and transitive closure lemma shows the agreement between the new reduction relation and the original one lemma for all m there is a value z such that m z and m z proof one first show that for all e there is n such that e n z then one reasons with a double induction an induction on n and a transition induction exploiting the determinism of context equivalence and bisimulation in fs certain terms ie formal sums may only appear in redex position ordinary terms ie terms in by contrast may appear in arbitrary position when extending context equivalence to fs we therefore have to distinguish these two cases moreover as our main objective is the of context equivalence in we set a somewhat constrained context equivalence in fs in which contexts may not contain formal sums thus the fs contexts are the same as the contexts we call these simple fs contexts whereas we call general fs context an unconstrained context ie a fs term in which the hole · may appear in any places where a term from was expected including within a formal sum later we will see that allowing general contexts does not affect the resulting context equivalence terms possibly containing formal sums are tested in evaluation contexts ie contexts of the form we write e p if e z and z p recall that z is unique for a given e definition context equivalence in fs two terms m and n are context equivalent in fs written m fs n if for all closing simple fs contexts c we have cm p iff cn p two e and f are written e fs f if for all closing fs evaluation contexts c we have ce p iff cf p in of lemma context equivalence in coincides with context equivalence in fs we now introduce a bisimulation that yields a coinductive of context equivalence and also of equivalence a coupled relation is a pair v e where v × e fs × fs and v e intuitively we place in v the pairs of terms that should be preserved by all contexts and in e those that should be preserved by evaluation contexts for a coupled relation r v e we write r for v and r for e the union of coupled relations is defined eg if r and s are coupled relations then the coupled relation r s has r s def r s and r s def r s if v is a relation on then vc is the context closure of v in ie the set of all closed terms of the form cm cn where c is a context and m v n definition a coupled relation r is a coupled logical bisimulation if whenever e r f we have if e d then f g where d r g if e is a formally value then f y with e y and for all m rc n we have e · m r y · n the converse of and coupled logical bisimilarity is the union of all coupled logical bisimulations hence is the union of the first component of all coupled logical bisimulations and similarly for in a coupled bisimulation r r the bisimulation game is only on the pairs in r however the first relation r is relevant as inputs for tested functions are built using r clause of definition actually also the pairs in r are tested because in any coupled relations it must be r r the values produced by the bisimulation game for coupled bisimulation on r are formal sums not plain terms and this is why we do not require them to be in r formal sums should only appear in redex position but terms in r can be used as arguments to bisimilar functions and can therefore end up in arbitrary positions we will see below another aspect of the of r the proof technique of logical bisimulation only allows us to prove of the bisimilarity in arbitrary contexts for the pairs of terms in r for pairs in r but not in r the proof technique only allows us to derive preservation in evaluation contexts in the proof of congruence of coupled logical bisimilarity we will push as many terms as possible into the first relation ie the first relation will be as large as possible however in proofs of bisimilarity for concrete terms the first relation may be very small possibly a singleton or even empty then the bisimulation clauses become similar to those of applicative bisimulation as inputs of tested function are almost identical up in coupled logical bisimulation the use of two relations gives us more flexibility than in ordinary logical bisimulation depending on the needs we can the size of the first relation it is possible that some of the above aspects of coupled logical bisimilarity be specific to callbyname and that the callbyvalue version would require nontrivial modifications remark in a coupled logical bisimulation the first relation is used to construct the inputs for the tested functions the formally values produced in the bisimulation game for the second relation therefore such first relation may be thought of as a global environment global because it is the same for each pair of terms on which the bisimulation game is as a consequence coupled logical bisimulation remains quite different from bisimulation where the environment for constructing inputs is local to each pair of tested terms coupled logical bisimulation follows ordinary logical bisimulation in which there is only one global environment in ordinary logical bisimulation however the global environment coincides with the set of tested terms the similarity with logical bisimulation is also by of the associated functional in contrast the functional associated to bisimulation is monotone see remark as an example of use of coupled logical bisimulation we the counterexample to the completeness of applicative bisimilarity with respect to contextual equivalence example we consider the terms of example and show that they are in hence also in contextual equivalence of by corollary and fs recall that the terms are m def xl p and n def xl xp for l def z and p def yz we set r to contain only m n this is the pair that us and r to contain the pairs m n m xl xp l p l p and a set of pairs with identical components namely l p l p u u u u where is the empty formal sum thus r r is a coupled logical the main challenge towards the goal of relating coupled logical bisimilarity and context equivalence is the of bisimulation we establish the latter exploiting some upto techniques for bisimulation we only give the definitions of the techniques the statements about their soundness the first upto technique allows us to drop the bisimulation game on actions definition bigstep bisimulation a coupled relation r is a bigstep coupled logical bisimulation if whenever e r f the following holds if e z then f y with z y and for all m rc n we have z · m r y · n in the reduction computation is performed at the level of formal sums and this is reflected in coupled bisimulation by the application of values to formal sums only the following upto technique allows computation and application of input values also with ordinary terms in the definition we extract a formal sum from a term e in fs using the function inductively as follows def i pi whenever de i mi pi dm def m def h definition a coupled relation r is a bisimulation upto for sums if whenever e r f then either one of the bisimulation clauses of definition applies or e f and one of the following clauses applies e d with dd m n and f g with dg l p m r l and n r p e xm and f xn and for all p rc q we have m px r n qx e xm p m and f xn qn and m r n according to definition in the bisimulation game for a coupled relation given a pair e f r we can either choose to follow the bisimulation game in the original definition or if e and f do not contain formal sums we can try one of the new clauses above the advantage of the first new clause is that it allows us to make a split on the derivatives of the original terms the advantage of the other two new clauses is that they allow us to directly handle the given terms without using the operational rules of figure and therefore without introducing formal sums to understand the first clause suppose e def m n l and f def p q we have e m n l def g with dg m l n l and f p q def h with h and it is sufficient now to ensure m l r p and n l r q using the above proof technique we can prove the necessary property for bisimulation the use of upto techniques and the way bisimulation is defined in particular the presence of a clause for steps and the possibility of using the pairs in the bisimulation itself to construct inputs for functions make it possible to use a standard argument by induction over contexts lemma if r is a bisimulation then the context closure s with s def rc s def r rc em f n st e r f and mi rc ni is a bisimulation upto formal sums using lemma we can prove the inclusion in context equivalence corollary if m n then m fs n moreover if e f then e fs f the converse of corollary is proved exploiting a few simple properties of fs eg its transitivity the inclusion fs theorem we have fs and fs it also holds that coupled logical bisimilarity is preserved by the formal sum construct ie mi ni for each i i implies ii mi pi ii ni pi as a consequence context equivalence defined on general fs contexts is the same as that set on simple contexts definition remark the functional induced by coupled logical bisimulation is not monotone for instance if v w then a pair of terms may satisfy the bisimulation clauses on v e for some e but not on w e because the input for functions may be taken from the larger relation w recall that coupled relations are pairs of relations hence operations on coupled relations such as union and inclusion are defined however corollary and theorem tell us that there is indeed a largest bisimulation namely the pair fs fs with logical as well as bisimulations upto tech are particularly important to the burden of proving concrete equalities a powerful upto technique in higherorder languages is upto contexts we present a form of upto contexts combined with the bigstep version of logical bisimilarity below for a relation r on we write for the closure of the relation under general closing fs contexts definition a coupled relation r is a bigstep coupled logical bisimulation upto contexts if whenever e r f the following holds if e z then f y with z y and for all m rc n we have z · m rc fs y · n for the soundness proof we first derive the soundness of a smallstep upto context technique whose proof in turn is similar to that of lemma the technique of definition already allows some context manipulation we need this technique for the proof of the technique example we have seen that the terms and of example are not applicative bisimilar we can show that they are context equivalent by proving that they are coupled bisimilar we sketch a proof of this in which we employ the upto technique from definition we use the coupled relation r in which r def and r def r am bn m rc n where am def nm n m n and bn def xn x xn x this is a bigstep coupled logical bisimulation upto contexts the interesting part is the matching argument for the terms am bn upon receiving an argument m they yield the values i m m pi and i n m pi for some and these are in beyond callbyname reduction so far we have studied the problem of giving sound and complete coinductive methods for program equivalence in a probabilistic calculus with callbyname reduction one may whether what we have obtained can be adapted to other notions of reduction and in particular to callbyvalue reduction eg the callbyvalue operational semantics of from since our construction of a labelled markov chain for is independent on the underlying operational semantics defining a callbyvalue probabilistic applicative bisimulation is the proofs of congruence of the bisimilarity and its soundness can also be to callbyvalue when we restrict our attention to pure terms as we do in section we are strongly relying on callbyname evaluation only reflect term equivalence in a callbyname lazy we leave the task of generalizing the results to eager evaluation to future work but we conjecture that in that setting probabilistic choice alone does not give contexts the same power as probabilistic bisimulation similarly we have not investigated the callbyvalue version of coupled logical bisimilarity as our current proofs rely on the of formal sums only in redex position a constraint that would probably have to be lifted for callbyvalue a comparison with nondeterminism syntactically is identical to an language introduced by and the semantics we present here however is quantitative and this has of course a great impact on context equivalence while in a nondeterministic setting what one is the possibility of or of or both terms with different convergence probabilities are considered different in an essential way here actually nondeterministic context equivalence and probabilistic context equivalence are incomparable as an example of terms that are context equivalent in the must sense but not we can take i i and i conversely i is equivalent to any term m that reduces to i m which can be defined using fixedpoint combinators while i and m are not equivalent in the must sense since the latter can diverge the divergence is irrelevant because it has probability zero may context equivalence in contrast is than probabilistic context equivalence despite the differences the two semantics have analogously to what happens in nondeterministic calculi applicative bisimulation and context equivalence do not coincide in the probabilistic setting at least if callbyname is considered the counterexamples to full abstraction are much more complicated in callbyvalue calculi and cannot be easily adapted to the probabilistic setting conclusions this is the first paper in which bisimulation techniques for program equivalence are shown to be applicable to probabilistic calculi on the one hand idea of interaction as application is shown to be amenable to a probabilistic treatment giving rise to a congruence relation that is sound for context equivalence completeness however fails the way probabilistic applicative bisimulation is defined allows one to distinguish terms that are context equivalent but which behave differently as for when choices and interactions are performed on the other a notion of coupled logical bisimulation is introduced and proved to precisely context equivalence for along the way applicative bisimilarity is proved to coincide with context equivalence on pure terms yielding the tree equality the crucial difference between the two main bisimulations studied in the paper is not the style applicative logical but rather the fact that while applicative bisimulation on relating only individual terms coupled logical bisimulation is more flexible and allows us to relate formal sums which we may think as distributions this also explains why we need distinct reduction rules for the two bisimulations see examples and while not complete applicative bisimulation as it stands is simpler to use than coupled logical bisimulation moreover it is a natural form of bisimulation and it should be interesting trying to the techniques for handling it onto variants or extensions of the language topics for future work some have already been at in earlier sections among the most interesting ones one can mention the of applicative bisimulation onto the language fs we conjecture that the resulting relation would coincide with coupled logical bisimilarity and context equivalence but going through technique seems more difficult than for given the nature of formal sums and their to redex positions also interesting would be a more effective notion of equivalence even if the two introduced notions of bisimulation avoid universal over all possible contexts they refer to an essentially operational semantics in which the meaning of a term is obtained as the least upper bound of all its finite approximations would it be possible to define bisimulation in terms of approximations without getting too fine bisimulations in the style of logical bisimulation or bisimulation are known to require upto techniques in order to avoid tedious equality proofs on concrete terms in the paper we have introduced some upto techniques for coupled logical bisimilarity but additional techniques would be useful upto techniques could also be developed for applicative bisimilarity more in the we would like to develop sound operational techniques for socalled computational a key notion in modern cryptography computational is defined similarly to context equivalence the context is however required to work within appropriate resource bounds while the two terms can have different observable behaviors although with probability we see this work as a very first step in this direction complexity bounds are not yet there but probabilistic behaviour an essential is correctly taken into account acknowledgments the authors would like to thank the anonymous for the many interesting comments this work is partially supported by the project is and the project references s abramsky the lazy calculus in d turner editor research topics in functional programming pages ­ s abramsky and ch l full abstraction in the lazy lambda calculus inf comput ­ e and g distributive semantics for nondeterministic typed theor comput sci ­ h p barendregt the lambda calculus ­ its syntax and semantics volume of studies in logic and the foundations of mathematics northholland m r de and m a uniform framework for modeling nondeterministic probabilistic stochastic or mixed processes and their behavioral equivalences inf comput ­ g for strict parallel functions inf comput ­ g and c the power of the calculus with inf comput ­ d v and p object tracking ieee trans on pattern analysis and machine intelligence ­ u and m probabilistic operational semantics for the lambda calculus theor inf and ­ u d sangiorgi and m on coinductive equivalences for probabilistic higherorder functional programs long version available at v and r probabilistic game semantics acm trans comput log ­ r de and m hennessy testing equivalences for processes theor comput sci ­ u and a non deterministic extensions of untyped lambdacalculus inf comput ­ m and e from theorem to observational equivalences an informal account notes theor comput sci ­ m j and p by parallel the algorithm inf comput ­ t m and c the computational meaning of probabilistic coherence spaces in lics pages ­ s and s probabilistic encryption j comput syst sci ­ n d the principles and practice of probabilistic programming in popl pages ­ a d gordon bisimilarity as a theory of functional programming notes theor comput sci ­ a d gordon m j g t a v s k rajamani and c v a pattern for bayesian reasoning in popl pages ­ m hennessy exploring probabilistic bisimulations part i formal comput ­ d j proving congruence of bisimulation in functional programming languages inf comput ­ r and p a model for a higherorder process calculus in icalp pages ­ c jones and g d plotkin a probabilistic powerdomain of evaluations in lics pages ­ v p b and e from applicative to bisimulation notes theor comput sci ­ k g and a bisimulation through probabilistic testing inf comput ­ s b relational reasoning about functions and nondeterminism phd thesis university of s a and method for calculi with in concur pages ­ c d and h foundations of statistical natural language processing volume mit press ch l nondeterminism in a functional setting in lics pages ­ p labelled markov processes college press s park f pfenning and s a probabilistic language based on sampling functions acm trans program lang syst j probabilistic reasoning in systems networks of inference morgan a a probabilistic rational programming language in pages ­ morgan a m pitts theories of program equivalence in semantics and logics of computation pages ­ cambridge university press a m pitts method for higherorder languages in d sangiorgi and j editors advanced topics in bisimulation and coinduction pages ­ cambridge university press n ramsey and a stochastic lambda calculus and monads of probability distributions in popl pages ­ n probabilistic in volume of lncs pages ­ d sands from rules to proof principles an operational metatheory for functional languages in popl pages ­ d sangiorgi and d walker the picalculus ­ a theory of mobile processes cambridge university press d sangiorgi n kobayashi and e logical bisimulations and functional languages in volume of lncs pages ­ d sangiorgi n kobayashi and e bisimulations for higherorder languages acm trans program lang syst k callbyvalue and nondeterminism in volume of lncs pages ­ s mapping a survey exploring artificial intelligence in the new pages ­ 