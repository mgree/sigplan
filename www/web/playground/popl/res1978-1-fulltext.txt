conference record of the fifth annual acm symposium on principles of programming the smalltalk programming system design and implementation daniel h h xerox palo alto research center palo alto california abstract this paper describes a programming system based on the of communicating objects experience with system shows that this model provides flexibility modularity and a compiled representation for the language presented along with an interpreter suitable for the objectoriented model provides naturally efficient addressing a corresponding virtual memory described which offers of space is is the purpose of the smalltalk project is to support children of all in the world of information the challenge is to identify and of sufficient simplicity and power a single person to have access to and control over information which ranges from numbers and text through and in our experience the notion of class and instance is an for information structure to describe processing we have found the concept of to be simple and general rather than provide this organization as a feature in an existing system we have taken these two as the point of for the programming language the result is a interactive system which provides its own text editing debugging file handling and display on a personal computer the smalltalk language is object oriented rather than function oriented and this often people with previous experience in computer science for example to some means to present as a message to the object the fundamental difference is that the object is in control not if some is the integer then the result will be the integer however if some object were the string the result might be meta in this way meaning with the objects of the system and code remains an abstract form merely the flow of communication as we shall see this separation is a key factor in the ability of a system to handle complexity the principle of modularity no part of a complex system should l on the internal details of any other part the design of the smalltalk language supports this principle through uniform reference to objects sending messages to obtain results and through organization of object descriptions and computational methods into classes factoring of information structure and behavior is provided by the implementation of all references in the language are to objects which may be atomic or may consist of several named fields which refer in turn to other objects though the only atomic datum is the bit it is often appropriate for such simple objects as names and numbers to be considered atomic for example in a piece of code which reads the of a point in two dimensions should there be instructions such as load the second word relative to point p such an instruction would not perform properly if it encountered a point represented in communication is the for processing in the smalltalk language objects are created and manipulated by sending messages the same model describes activities ranging from ordinary arithmetic to communicating processes in separate machines the response to a message is implemented by a method which reads or writes some data field or sends further messages to achieve the desired response the communication supports the principle of modularity since any attempt to examine or alter the state of an object is sent as a message to that and the sender need never know about internal representation for example points represented in r and would have a method which to the message y by returning the examples in this paper use a syntax which gives higher precedence to messages of fewer therefore first receives the message remember is a property of not a function and then r receives the message q with one argument every object in small talk is created as an instance of some class the class holds the detailed representation of its instances the messages to which they can and methods for computing the appropriate responses the only information remaining to be stored in an instance is the set of values for its named fields the class is the natural unit of modularity as it describes all the external messages understood by its instances as well as all the internal details about methods for computing responses to messages and representation of data in the instances in the smalltalk language a class can be declared to be a subclass of another class and thus inherit ail the of that superclass the subclass can then add of its own can those it and can still invoke the ones from within its code this capability leads to a highly system the reactive principle the feature of is that all objects are active ready to perform in full at any time nothing of this should be lost at the interface to the human user of the system in other words all components of the system must be able to present themselves the user in an effective way and must moreover present a set of simple tools for their meaningful the analogy to a library of useful functions is a set of well developed from which most of the system classes are derived the most general of these class object provides default behavior for any object or examining and its contents on a display screen in addition to a and display screen the smalltalk system provides a for pointing at the screen the smalltalk system includes a class window which establishes a uniform model for interaction with these devices from window users can define new subclasses with behavior specific to their content the inheritance from class window avoids a lot of replicated code and a uniform model for reactive control over new objects added by the user rm w mm class new tick w lc ii figure a typical display figure shows a typical display screen from a smalltalk system each of the areas is an instance of class window which provides a basic protocol for user interaction if the is within the window the content is thus showing it in front of the other windows once active the window becomes the of all user actions such as the typing on the or entering sensitive areas around the window if the is outside the window control is given up so that another window may be the class window also provides a basic protocol for handling such actions as moving itself changing its size its contents and terminating its on the screen the reader may find evaluating the user interface presented in the figures this misses the point which is the of communicating objects in describing the situation many other approaches to display handling are used with smalltalk and they are the subject of this paper figure text each of the windows shown in the figure belongs to some subclass of window the subclass handles tie specific content in figure for example the user has a window for editing the text of a class specific to this content is the ability to select text with the the text up and down by entering the bar at the windows left and send specific editing messages by entering the at its right the class has thus provided a simulation of itself as structured text which is needed for this text in turn a text editor to display the text and allow it to be manipulated finally the window provides a spatial channel for the flow of information in both directions between the user and the subject of investigation as shown in figure the user has just drawn the through the text of the message show and the editor has by the text and noting the selection internally in figure the currently active window supports it provides a large from which to choose shape and to be applied when the is another window interfaces to one of the character allowing the user to design new at will yet another the time of each of the windows its own semantics to the uniform syntax of motion and action available to the in this way the underlying of communicating objects can be seen to operate all the way up to the level which corresponds to a conventional operating system i i disk b ut window ll i u m if m m j dl c w me ir m y event responses v l roll em law or cl w d a figure a picture example of a smalltalk class rectangle as we have seen above most programming in smalltalk is done using a structured editor rather than go into the details of this process we show here an from class rectangle show how it supports the window example above and describe in detail the operation of one of its messages a smalltalk class is defined by giving it a name and naming the fields of its instances following this is an list of the messages to which the class each message consists of a pattern followed by smalltalk code within brackets class new title rectangle fields origin corner access to fields origin t means return corner origin origin corner no code just store into the instance testing true if pt is inside and empty me combination r max r origin corner r corner image clear color primitive outline width self clean display operation black self clean white pt corner origin pt have two f origin is the lower left corner and corner is the upper right corner because both origin and corner are points rectangle builds on a data domain which is already graphical y interesting class new title fields x y point cartesian to fields y hy testing pt return true if i x and am y of pt combination make up a new rectangle origin self corner c point pt pt arithmetic point new new x x x y x y y y the scheduling of windows shown in figures is implemented in windows response to the message visible in figure the element in the code is the expression frame c which checks whether the location a point is within the frame a rectangle of the current window the code for rectangle contains builds in the procedural domain nn meaning of for points i t test origin is below and to the left of the point pt and the second test determines that pt is below and to the left of corner the reader will want to know here that arithmetic messages etc get sent before keyword messages the identifiers ending in therefore after the two have been made the conjunction of the two results the case that the rectangle contains the point pt smalltalk treats all objects which are not false as true this is rather in class object by messages of the form and x tx are inherited by all other classes the implication arrow is a primitive operation which into a branch conditional on the object false the other messages to rectangle are presented so that interested readers can the message outline w which causes an outline of width w to appear around the rectangle on the screen this message is used by class window to clear and outline its frame these readers want to know that if several keyword messages at a level they combine to provide a message with ple arguments for example class number provides a message el arg new x self w am for creating points simply this code sends the message xy to the new point with the two arguments self and arg the benefits of the message discipline adding a new class of data to a programming system is soon followed by the need to print objects of that class in many extensible languages this can be a difficult task at a time when things should be easy one is with having to edit the system print routine which a is difficult to understand because it is full of details about the rest of the system b was written by else and may even be in another language and c will the system to bits if you make one false move of this often leads to writing a separate print routine with a different name which then must be in our objectoriented system on the other hand is always by sending the message s where s is a character stream to the object in question therefore the only place where code is needed is right in the new class description if the new code should fail there is no problem the existing system js and can continue to provide support the code for moving a rectangle could be more efficient if corner were relative to origin so that it did not need to be changing names from this could be accomplished by fields origin corner to fields origin extent and updating the code from corner e origin pt to origin pt in a conventional organization all the code in the system will have to be because it used to count on finding the corner in the second field in fact most systems would require rewriting because access to the corner which used to be a simple load or store becomes a computation corner corner extent the class organization and message discipline ensure that if the original message protocol is supported then all code outside the class will continue to work without even moreover the only changes required will all be within the class whose representation is being changed modularity is not just an issue of if n parts depend on the of each other then aspect of the system will be proportional to such will interfere with the systems ability to handle complexity the may manifest itself at any level difficulty of design language with features long time required to make a change or difficulty of debugging messages enforce an organization which another benefit of leaving message interpretation up to the target objects is type independence of code in the rectangle example the code will work fine if the are integer or floatingpoint or even some numerical type this allows for much sharing of code and the ability to have one object as another the power of subclasses the utility of code is exploited by subclass organization in for example superclass number implements the messages the the in terms of the basic comparisons and consequently after defining only the basic comparisons any new subclass of number can to the full numerical protocol other messages in the superclass number such as which creates a point and which creates an interval similarly allow of points and limits of ranges to be floatingpoint fraction or any other kind of number the factoring provided by leads to it can also increase efficiency through use of system code for instance we provide support for reading and writing the next item in a stream now by making class a subclass of stream inherits this very efficient code for its most common operations the superclass stream sends itself the message when it reaches the end of its character buffer and this gives the subclass a to read a new record off the disk by overriding the meaning of besides allowing subclasses to messages in their smalltalk provides for access to the messages in figure the selected text defines the message show to show show self which windows definition the token super indicates that the following message should be up beginning with the class above in this case it allows to invoke windows show code to put a frame around the window before the document to display its text further multiple paper properties inheritance of smalltalk including of are beyond the scope of this implementation the challenge of implementing the smalltalk language is to provide acceptable performance without the simplicity of the underlying beyond the goals of modularity and factoring four pragmatic issues affect the performance of the smalltalk system storage management compact object code message handling and a virtual memory storage management requiring the programmer to the allocation and deallocation of objects is out of the question in a true high language it is a sure source of errors and it the code with irrelevant pragmatic instead the smalltalk kernel maintains reference counts for all objects and them to be reused when the count goes to zero we chose reference counting over garbage collection because the computational overhead is more uniform in realtime and the behavior with little free storage is better the flow of data in a programming system is usually small integers either representing characters or results of simple arithmetic and indexing the system small integers without reference counting they are special object references this one wildcard in some lisp systems reduces the overhead to a reasonable level the of cyclic structures cannot be handled by reference counting but we have not found this to be a problem the class architecture makes it especially convenient to objects which are going to in cyclic structures for each cyclic link field an appropriate message can be defined which propagates through the structure the cycle it is true that this discipline corresponds to explicit storage management but it is well and hence presents little problem compact object code to our is the ability to run smalltalk on personal computers in this of the system is crucial and worth some raw speed to achieve moreover our experience with virtual memory systems is that overall performance actually improves with to reduced of the to this end the smalltalk system translates source code into compact corresponding to the elements of the language class title part names superclass message inst size free list string i corner origin i and static structures dynamic i i context structures sender method pc stack ptr self no args etc if any t pt origin corner pt i e y argument rectangle w origin corner point x y point x y receiver figure smalltalk structures the top of figure illustrates the static structure in smalltalk corresponding to rectangle contains one of the fields of the class points to an object called a this is a hash table whose keys are the message names and whose value include the corresponding compiled method and also the source code the translates the source code into in order using what the class knows about instance fields and other variable locations including some information discussed below the code body for computing contain code or in our system bit words the choice of encoding is made by translating every common item into a single and then providing escapes for cases where this is impossible the codes fall into the following basic categories load relative to receiver self load relative to temp frame load relative to load indirect load relative to context load constant send literal message send special message short jumps long jumps control ops escapes the loads pick up an object reference and push it onto an evaluation stack and the message codes either cause a primitive operation or invoke another context depending on the actual message and the receiver on top of the stack the jumps come in two and conditional the latter taking place only if the top of stack is false but the stack in any event the long jumps are followed by an extension the control ops include returning to caller pop stack and store which is followed by a describing the destination field the escapes work like the long jumps extending the loads and sends by a full of offset an area is set aside in the method for object references which do not fit into a and these serve when necessary as an escape to refer to constants external references or message tokens our example which does not use any literals would be encoded as origin corner pt l and it load load receiver load send special message send special message do control the encoded methods typically of the original source code virtual memory therefore the source from one the space in implementations with no it would be important to the code message handling execution of the code is relatively simple and the lower half of figure illustrates the dynamic environment when a rectangle receives the message contain an instance of class context is allocated to serve much the function of a conventional call frame its sender field points to the context of its caller to which the final value of its computation will be passed with the return t operator the self field points to the object who is receiving this in our example it is a rectangle the in this example is simply the class rectangle but in the case of messages which are inherited from it indicates the class from which the message was inherited this is needed to provide the super access described earlier method points to the object code for the method being executed and pc is a offset into it the current progress of execution points to a vector of temporary storage for the computation its access is partitioned into three areas arguments passed from its caller other temporaries required for the computation none in our example and the stack area used in evaluating the is the offset indicating the current top of stack the smalltalk system gets a great deal of out of the fact that contexts are objects of full capability just like all the other parts of the system for debugging the context is in a position to reveal the location of the pc the contents of the stack the values of temporary variables and the current state of the receiver for analysis purposes the operation of the interpreter is simulated smalltalk by a loop which sends the message step to the current context repeat current current step an outline of this simulation appears in an appendix to this paper most of the task of interpretation is implicit in the descriptions above the one complex operation of further is how a new context gets set up to send a message to a new receiver our example of figure will serve us again corner has been put on the stack and pt above it is the top item in the stack the next pointed to by pc indicates that the message is to be sent the very first thing that happens since this is a common arithmetic operation is that pt is checked to see if it is an integer allowing a fast primitive operation but it is not the more general process then begins of hashing the token into the of pts class point a match is indeed found and the resulting code object can be in the new context along with pt off the stack in the self field class point in the field and the previous context in the sender field the parameters in the beginning of the method are computed at compile time and serve to initialize the new environment they tell how much space is needed for the and how many arguments are expected one here after the arguments have been moved from the previous stack to the beginning of the the initial values of and pc and the new context is ready to run it will eventually terminate by a then the value true or false on the top of the stack will get pushed back onto the stack and the computation of rectangle contains will resume where it t off efficient message handling it should be obvious that to carry the message sending down into integer arithmetic will result in a slow system on any non message oriented computer the must but not get in other words the user of the system should not any non to achieve acceptable performance it is important that the interpreter not send messages to contexts it performs all the same steps but in the way possible the smalltalk system achieves its speed by the assignment of special code to the most frequently executed operations for instance the message is assigned a special code and the interpreter to that code by immediately checking whether both receiver and argument are of class integer if so it does the addition in line and proceeds immediately without even looking up the symbol plus let alone creating a new context if the check fails then passes to the normal message sending code thus the of virtual memory one of the most satisfying aspects of a system built of objects is the naturally efficient use of address space since a reference can only point to an object as a whole the small talk system can indicate distinct objects using bit object references with a mean object size of words the system can address over a words and this size is a nice match to the size of common personal computer disk in implementing this virtual memory we decided to swap single objects thus achieving maximum of storage at the possible of slower of without a few this scheme could never work first a h code associates the class of an object with its object reference thus avoiding a overhead on every object the address space is given to classes for their instances in of with the same bits it is therefore possible to index a table with the high order bits of any object reference and discover the class of that object second variable length classes have many such one for each of the common small lengths in this way the overhead of a length word is avoided on the small sizes for larger sizes the cover ie and so on and an extra word specifies the exact length third these of address space are mapped into locations on the disk since all the objects are instances of the same class they have the same size hence the page and offset on the disk can be computed from the low order bits of the object reference in this way objects can be located on the disk to be into core for the sizes a little space on the disk is for the ability to compute the disk offset location fourth the provides a solution to the problem of making free space without the disk here is the problem there are objects in core roughly words each and we need words of if we have to write out objects assuming we can even decide which ones how do we keep from doing disk to do it our solution is to core by thus writing many objects together on a page and sweeping over the disk in order of pages moreover a single bit on each object meaning been since my was last provides a nice criterion for selecting objects to be conclusion we have known for some time that the uniform model of communicating objects leads to a naturally integrated programming system a very aspect to our work is the that this approach can also result in an efficient implementation the smalltalk system has supported large applications for simulation information text editing composition and without significant barriers to complexity and this is our strongest of the worth of the language beyond this i must add that programming in smalltalk is fun on the one hand the act of expressions into statements and then into methods is not very different from conventional programming on the other hand the experience is totally different for the objects which and traverse the code are active entities and writing expressions like rather than boxes around many people have to the smalltalk system alan has been the basic principles for about a now and the rest has through the and energy of the whole learning research group smalltalk was implemented by the author with the of and several other people at have significantly most notably and peter references a a extensible ms thesis univ of may univ a the reactive engine phd thesis univ of sept univ learning research group dynamic xerox palo alto april g oj b k begin pa d a control structures for programming languages phd thesis univ liskov b and s programming with abstract types sigplan notices april liskov b an to clu memo mit i and c semantics of acm sigplansigact conf palo alto jan r actor machine architecture ms thesis mit dept june l p a lisp machine with very compact programs stanford august l p and d an efficient incremental automatic garbage collector cacm september appendix a smalltalk simulation of the interpreter class new title fields sender context method pc receiver contexts carry the dynamic state of smalltalk processes they are the interpreter at the same time they are instances of class in this way the generality of can be applied progress of execution accessed in a to examining efficient ways by normal smalltalk and tracing the the code below differs simplified categories from the actual code in smalltalk in that it corresponds to the slightly of the text and has not been carefully checked for errors beyond the in the text the interested reader will want to know is the subscript message as in except for assignment w treated as an message pat as in t i self pop the symbol indicates conditional execution if the preceding value is true then the is executed form serves and control exits to build dispatch the outer tables as following body brackets in the of code this if next below the default value returned from any message is self the receiver of the message other values may be returned with the w symbol the messages inst f n and nth field of an instance clearly stops here and these primitive n val violate the principle messages appear which are used below of modularity this else in the to read reflects system and write the that the access to fields sender sender method method pw receiver receiver pc all fields simulation of the interpreter step i byte byte self byte push receiver dispatch on next code load from instance self self self self push push push push push method literals load load method literals value self load ci o true false nil from and args from literals indirectly from from this context constants send method literal send messages short jump forward self pop pc short branch if false jump forward and pop and back self skip extension pc long self pop pop stack store self top into self store store self pop into self store and sender push self top return value byte on pop to sender true store val into field byte field i val same val encoding as store into instance store into and args user invalid store cant store into literals method literals value indirectly through literals self val store into this context send message class meth callee t i send a message class self top class until class lookup message look up the method class class superclass class follow the superclass message message chain if meth primitive if as primitive then do it self meth if it fails proceed with send callee context new create new context and fill its fields sender self method meth pc meth te vector new meth meth class receiver self pop for i to meth do pass arguments t i self pop return new context so it becomes current step pc and return pc next code messages push val push value onto top top return value on top of stack pop i t pop value off stack lt of stack val and return it 