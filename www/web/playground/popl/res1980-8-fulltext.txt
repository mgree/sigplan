interprocedural data flow analysis in the presence of pointers procedure variables and label variables extended abstract william e ibm thomas j watson research center heights new york abstract interprocedural data flow analysis is complicated by the use of procedure and label variables in programs and by the presence of aliasing among variables in this paper we present an algorithm for computing possible values for procedure and label variables thus providing a call graph and a control flow graph the algorithm also computes the possible aliasing relationships in the program being analyzed we assume that control flow information is not available to the algorithm hence this type of analysis may be analysis given this assumption we demonstrate the correctness of the algorithm in the sense that the information it produces is conservative and show that it is as precise as possible in certain cases we also show that the problem of determining possible values for procedure variables is pspace hard this fact indicates that any algorithm which is precise in all cases must also run very for some programs authors current address mit laboratory for computer science technology square cambridge ma this work was performed to the sm degree thesis requirements under the via program a program of the mit department of engineering and computer science the work was supported in part by a from the and john foundation © requires a fee and or specific permission acm introduction program optimization in the presence of procedure calls is important because of the current on modularity and abstraction in program design since these design heavy use of procedures and procedure calls it is essential that analysis techniques used to compile these programs perform well when calls are used this is important for several reasons among these are the facts that procedures are often fairly general so that better code can be produced for them given the contextual information implied by their use in the program that procedure calls imply some overhead which it might be desirable to avoid and that lack of knowledge about a called procedure makes it difficult to determine information about the procedure which contains the call standard data flow analysis techniques have many problems when applied to programs containing procedure calls the reason for this is that a procedure call is essentially a statement whose effects cannot be determined upon examining only the statement itself rather the body of the procedure must be examined as well failure to examine the body of the procedure may result either in no optimization being performed or in optimization being performed in small sections of the program which contain no procedure calls with very pessimistic assumptions being made about the use of parameters and global variables if the latter is the case then many valuable optimizations may be lost for example the presence of a procedure call within a loop might prevent code which is invariant inside the loop from being moved outside it these have led to the development of a number of methods for interprocedural data flow analysis which produce summaries of the effects of each procedure e g an of which variables are used modified etc these summaries are used when analyzing invoking the problems mentioned above procedures avoiding the methods proposed by and have a number of advantages over that proposed by allen including greater speed fewer passes required over the code and the handling of recursion method though slower than the others mentioned here can produce more precise information unfortunately these methods are not sufficiently general to be used for many languages specifically all of these methods require a call graph however if procedure variables are included in the language the call graph cannot be obtained through a simple scan of the text of the program being compiled further complications occur when aliasing among variables in the program is possible this can result from mechanisms such as pointers and parameter passing these two mechanisms are the ones considered in this paper as an example of the problems which aliasing can cause a call on a procedure variable using could have the effect depending on the value of the procedure variable at the time of the call of assigning a procedure value to one of the parameters of the call this fact must be taken into account in constructing the call graph for if procedure a contains a call on procedure variable x the call graph must contain arcs from the node for procedure a to the nodes for each procedure which x can have as its value another language feature which the situation is the use of label variables such a feature prevents the construction of a control flow graph until the possible values of all label variables in the program have been determined since a control flow graph is required for standard data flow analysis it is necessary for some part of the analysis phase of the compiler to compute this range information for label variables before standard data flow analysis is performed related work very little work has been done on the problem of handling performing procedure variables and pointers in interprocedural data flow analysis is the only one who addresses the problems associated with these language features however there are a number of limiting aspects to work first the algorithm requires iteration in the presence of recursion this can lead to large time requirements second the algorithm is presented at a low level making it difficult both to understand and to verify finally the algorithm as presented is specific to certain features of pl this combined with the low level of presentation makes it difficult to adapt the algorithm for use in compiling other languages ryder presents an algorithm which determines the call graph for a program with procedure parameters the algorithm is designed to be used with fortran and is meant to be portable across a wide range of machines the constraint leads to limitations on the use of storage these limitations the design of the algorithm the to use the algorithm for fortran leads to the assumption that there is no aliasing and no recursion these factors all limit the general applicability of the algorithm the methods proposed by allen and rosen solve the problems associated with procedure variables and pointers to varying usually by placing restrictions on the use of these features in the programs to be compiled in the extreme case these features are not allowed at all proposed solution we propose to deal with the problems introduced procedure variables and label variables by first computing range information ie lists of possible values for procedure variables thus providing a call graph and then using one of the known methods such as for generating summaries it is necessary to compute aliasing patterns as well as range information for pointers while computing range information for procedure variables simply because procedure variables can acquire values as a result of aliasing with other variables all of this information will be computed without taking control flow information into account it will subsequently be used to compute range information for label variables and to generate summaries for procedures prior to generating a control flow graph the context in which this work has been done is that of the experimental compiling system project of the computer sciences department at watson research center an overview of this project is given in briefly the goal of the project is to build a general purpose optimizing compiler which given the appropriate source language definition and target machine description can compile programs for that source language into code for that target machine clearly it will not be possible to compile all languages for all machines however it is that it will be possible to compile a large class of languages for a large class of machines for this reason the analysis and optimization phases should be formulated in a manner which is as independent as possible of language and machine the compiler attempts to treat primitives of the intermediate language and previously analyzed procedures as uniformly as possible at least as far as analyzing a program which uses them this is accomplished by associating with each primitive and each analyzed procedure a summary of its effects information contained in such a summary includes lists of variables which are used modified and preserved as well as an of the copies which may be performed when the primitive or procedure is invoked for example the summary for a primitive which moves data from its second argument to its first argument would specify that the primitive uses and preserves its second argument modifies its first argument and performs a copy of its second argument into its first argument the information about copies is used in propagating procedure label and pointer values thk means that in order to analyze a program we need either the code or a summary for every procedure which it calls this might seem to force a compilation order for separately compiled programs and to achieve reasonable optimization of the programs it does however it is desirable to be able to compile programs separately and to allow this to be done in any order this creates two problems in analyzing a procedure first the effects of the caller such as aliasing of parameters may be unknown second there may be calls on procedures for which no summary exists in either case the worst case must be assumed in the second case is treated by creating a summary for the unknown procedure and ensuring that this summary specifies all of the possible effects of the procedure the first case is somewhat more complicated in effect the program is treated as if there were a call on the procedure which causes all possible parameter aliasing including with external variables if any of the parameters are procedure variables the problems are this is because a call on the parameter could be a call to a procedure which was passed as an actual parameter and the effects of this procedure are unknown we omit the details of the handling of such situations we assume that we are given a collection of procedures each of which consists of a set of instructions each instruction consists of an which indicates a call on either a primitive a previously analyzed procedure a procedure in the collection or a variable and a list of operands each of which is either a variable or a constant expressions are not allowed as operands rather we assume that the computation of expressions has been expanded into sequences of instructions operands are assumed to be passed by reference for each which is a primitive or a previously analyzed procedure we assume that there exists a summary for that this summary must specify all of the possible copies among parameters and in which a call on the could result we make no assumptions about the possible flow of control between instructions in a single procedure given such a collection of procedures the problem is to compute sets of possible values for procedure variables sets of possible values for label variables sets of variables which may be through pointer variables and sets of possible aliases for all variables in the next section we show that this problem is inherently very difficult in sections we present our solution in stages its correctness and evaluating its precision and time requirements following this we discuss briefly some characteristics of the alias relationships as computed by our method and then summarize our results complexity in this section we show that the problem of determining possible values for procedure variables is pspace hard we assume some with the term pspace hard a definition of this term and a discussion of its can be found in in fact we prove the following makes a stronger statement theorem which determining possible values for procedure parameters for programs in which there is no aliasing among variables no nesting of procedure declarations and no significant flow of control and in which every procedure is formally reachable is a pspace hard problem this theorem is significant for a number of reasons first it indicates that it is extremely that there is any efficient method for computing possible values for procedure variables second and perhaps more important it shows that even when assignment statements aliasing and nesting of procedure declarations are not allowed it is still that an efficient method exists furthermore this is still true when there is no significant control flow in the program being examined other than that implied by the call graph these results lead one to search for solutions to the problem which are approximate and reasonably efficient such as the one presented in this paper these solutions may not produce exact information but they must produce safe information ie information which is conservative in that the possible values determined should be a superset of the exact possible values we make the restriction that all procedures be formally reachable since this is an assumption which is often made in compilers proof we make use of a theorem proved by in which he shows that deciding the property of formal reachability in programs without nested procedure declarations is a pspace hard problem formal reachability is defined in terms of a formal execution tree which is a tree of calls where the nodes of the tree are pairs consisting of procedures and their environments this is not the same as reachability defined in terms of a call graph as it is usually used in compilers shows this by constructing a program p for a given turing machine m polynomial s and input w such that a procedure halt in p is formally reachable if and only if m when started in its initial state with w written on its tape and its head scanning the leftmost symbol of w halts without its head ever moving outside the sn to the right of and including the tape square scanned at the start where n is the length of w p satisfies all of the requirements given in the statement of the theorem except for the restriction that all procedures be formally reachable and can be constructed in polynomial time from a description of the turing machine m the input w and the polynomial s in addition p has the property that there is a procedure qf such that qf is formally reachable in p if and only if m when executed with input w enters its final state without its head ever leaving the boundaries stated above qf contains a single call to the procedure halt deciding whether halt is formally reachable is therefore as difficult as deciding whether m halts in the required manner furthermore halt is formally reachable if and only if qf is formally reachable since the first parameter of qf has no possible values if qf is not formally reachable and has exactly one possible value if qf is formally reachable it follows that determining whether a given procedure parameter has a nonempty set of possible values is a pspace hard problem this problem can be easily solved given the set of possible values for the procedure parameter so determining sets of possible values for procedure parameters must also be pspace hard we have not yet proved the theorem since p does not satisfy the restriction given in the statement of the theorem that all procedures in p must be formally reachable however it is possible to transform p into a program p in which all procedures are formally reachable and about which we can ask the same kind of question which we about p furthermore the construction of p from p can be done in time linear in the length of p details of this construction can be found in the basic idea in constructing p t is to introduce calls to every procedure in p but to do so in such a way that it is still possible to talk about the formal execution of p simulating the execution of the turing machine m on input w since it will then be the case that qf is always called at least once the question which we will ask about p is whether the first parameter to qf has more than one possible value this will be true if and only if qf is called more than once which will be true if and only if m when executed on input w halts in the manner therefore this question is pspace hard and since this question can be easily given sets of possible values for procedure parameters the theorem f the method as stated earlier we will present the method in stages we begin with the simplest case a single procedure with no aliasing and allow more complexity in the program being analyzed until we have included reference parameters pointers and calls on procedure variables no aliasing we will first consider propagating values within a single procedure given that there is a summary for every instruction in the procedure create a relation named pval and initialize it to all pairs ab such that b is copied into a b may be an constant or a variable a must be a variable a pair xa in pval means that x has possible value a pval ranges over the variables in the program for which we wish to determine values and over the values which we are interested in propagating we determine which copies are possible by examining the instructions in the procedure for each instruction consider each copy in the summary for the of the instruction if one of the elements of the copy is a formal parameter of the substitute the corresponding operand of the instruction the resulting copy gives a pair which should be placed in pval to propagate values replace pval by its transitive closure pval for variable x and constant a the resulting relation gives an answer to the question of whether a is a possible value of x we claim that propagating values in this manner for this limited case is both correct and as precise as possible to show that it is correct suppose that a variable x has value a at some point during the execution of the program for x to have value a the execution of the program must include a sequence of assignments xi xi with x being a and x being x if this is the case then each of these assignments must appear as a copy in the summary of some instruction in the program therefore each appears as a pair in the initial pval relation from this it follows that the transitive closure of pval must include the pair x a computed is correct therefore the information to show that it is as precise as possible suppose that there is a pair xa in the transitive closure of pval there must exist a sequence of pairs xi in the initial pval relation with xo being a and xn being x each of these pairs corresponds to a copy specified by the summary for some instruction in the procedure since we are making no assumptions about the possible flow of control between instructions in the program any sequence of instructions must be considered possible in particular the sequence of instructions which corresponds to the given sequence of copies must be considered possible this means that ignoring control flow information x may have a as value therefore the information computed is precise the complexity of this algorithm is bounded by the complexity of computing the transitive closure of an n x n matrix with n being the total number of variables and values involved in the propagation under the assumptions made up to this point this is asymptotically the best possible algorithm for computing this information we can show this by that computing this information is of the same complexity as computing the transitive closure of a matrix we consider a single procedure and assume that we have no control flow information if pn is the time to propagate values for a program containing n variables and constants and tn is the time to compute the transitive closure of an n x n matrix we must show that there exists a constant c such that tn suppose that we have an n xn binary matrix m and we wish to compute its transitive closure we first create variables xi and constants ai for s i s n for each xi we create an instruction whose summary indicates a copy to xi from ai for each in the matrix say at position ij we create an instruction whose summary indicates a copy to xi from xj these instructions constitute the procedure for which we wish to propagate values we claim that xi has possible value aj if and only if there is a in position ij in the transitive closure of m this implies that tn s pn since pn is bounded by the time to compute transitive closure and this is n we can assume that pn s pn from this we conclude that tn pn now consider the situation in which the program to be analyzed consists of multiple procedures and in which instructions may be calls on primitives previously analyzed procedures or procedures in the given collection operands to primitives and previously analyzed procedures are passed by reference while operands to procedures in the collection are passed by value propagating values in this situation is almost identical to propagating values in the case of a single procedure the only difference is that we must account for the transmission of values from actual parameters to formal parameters this can be done in the relation pval for each call on a procedure p in the collection where p is declared with formal parameters xi and the call has corresponding operands yi add the pairs to pval for each other instruction initialize pval as before then form the transitive closure pval we claim that as in the case of a single procedure this computes correct and completely precise information and does so asymptotically as quickly as possible the proof is quite similar to the previous proof we omit the details call by we now wish to allow parameters to procedures in the collection to be passed by reference this means that when a value y is copied into a variable x there is an implied copy of y into each alias of x there are now two different effects to consider the first is the modification of a variable by assignment to it the second is the association of a formal parameter with an actual parameter by a call to the procedure which the formal to keep track of this information we create two relations called and affect a pair xa in means that x is assigned value a a pair xa in affect means that x may be aliased to a and to every other variable which may be aliased to a however it can be the case that there is some variable which may be aliased to x but not to a the characterization of parameter aliasing with affect was first suggested by is initialized specified in the summaries to all copies which are of instructions in the program affect is initialized to all parameter pairs which result from calls to procedures in the collection assume for the moment that constants are never used as actual parameters for calls to procedures in the collection we will relax this restriction in the final version of the algorithm and will explain the reason for it at that time shows that the alias relation which indicates the possible aliasing relationships among variables may be computed by the expression affect o affect t we claim that the following computation pval specifying correct possible values results in pval affect v affect t where r denotes the reflexive transitive closure of the relation r rt denotes the of r and r denotes the transitive closure of r we first note a theorem by which states that a modification of a variable can affect any actual parameters including the variable itself which correspond to the variable as well as any formal parameters which correspond to any of those observe that if the variable is not a formal parameter then the set of corresponding will include only the variable itself furthermore a modification of a variable can affect only these variables he then goes on to show that affect gives for each formal parameter all of the possible corresponding now suppose that variable x can have possible value a at some point in the execution of the program there must be a sequence of calls and assignments which in the assignment of a to x for each call in the sequence which matches formal y with actual z the pair yz is in affect and therefore in pval for each assignment of z to y in the sequence the pair yz is in and therefore in pval furthermore if w is aliased to y there exists a u such that w affect u and y affect u as shown by the pair uz is therefore in pval since we know that u affect t o z the pair wu is also in pval since each pair in affect is in pval since pval is closed the pair wz must be in pval therefore each pair corresponding to the values transmitted by each action in the execution sequence of the program is in pval this implies each pair corresponding to the values transmitted by the sequence as a whole must be in pval in particular the pair xa is in pval therefore the information computed is correct since the complexity of boolean matrix multiplication is the same as that of transitive closure the complexity of this algorithm is like the previous versions of the algorithm bounded by the time to compute the transitive closure of an n x n matrix furthermore since this algorithm computes the same information for a single procedure as the previous algorithm it can be argued that this algorithm is asymptotically the possible algorithm for computing the information which it produces this algorithm does not compute completely precise information the from the use of affect to characterize parameter aliasing and is discussed by in as a simple example of the consider the skeleton program in figure in this example a should be assigned q by the first call on p and b should be assigned r by the second call on p however the method determines procedure procedure procedure procedure q r variable st ab figure that both a and b have possible values q and r this results from the fact that based on the assignment of t to s we propagate all values of t to s and then to all actual parameters for s the basic reason for this is that separate calls on a procedure are not treated separately pointer variables we now introduce pointer variables into the programs being analyzed we do so in two steps first considering a single procedure and then allowing multiple procedures with parameters passed by reference as mentioned earlier it is necessary to augment the summary information kept for primitives and previously analyzed procedures to give some information about indirect accesses through variables to simplify the summaries no information will be kept about the number of levels of indirection involved in accessing storage through a pointer eg in accessing an element of a list instead a distinction is made only between a direct access of a variable and an access of storage via some positive number of indirection on a variable the summaries must now distinguish types of copies letting p and q denote p and q denote storage accessible variables these four types are as follows between variables through four and the l pq p q p q p q two other types of copies are also allowed these involve the assignment of the address of a variable to another variable or to storage accessible through another variable these are as follows p p we will the relations affect and previously these relations dealt with the variables and values which were interesting in terms of propagating values to handle pointers and the transmission of values via assignments to storage accessible through pointers we introduce dummy variables for each pointer variable for a pointer variable p this dummy variable is meant to represent the storage accessible through p and will be denoted by p to propagate aliasing information correctly based on the assignment of the address of a variable to another variable we introduce dummy literals for each variable whose address is copied for a variable q whose address is copied cases and above this literal will be denoted by aq and represents the address of q l pq add the pair pq to add the pair pq to affect p q add the pair pq to add the pair pq to affect p q add the pair pq to add the pair pq to affect p q add the pair pq to add the pair pq to affect p add the pair to add the pair pq to affect add the pair pq to affect p add the pair to add the pair pq to affect add the pair pq to affect figure figure describes the initialization of affect and for each type of copy if one element of a copy say x is not a variable then all pairs involving x should be ignored to give some intuition about the reasons for the relations in this manner consider the simple assignment p q if p and q are pointer variables this has two effects first it results in p and any alias of p the value contained in q it also causes any storage accessible through q to be accessible through p from which it follows that every alias of q is an alias of p there are many between the effects which occur due to parameter aliasing and those due to the use of pointers if there are several assignments to a pointer p say from q and r then p is aliased to both q and r but q and r are not necessarily aliased on the other hand if p is assigned to several pointers say q and r then q and r are both aliased to p and since q and r may be assigned the same value q and r are aliased to each other these two situations are very similar to two situations which can occur with reference parameters the first being when two different actual parameters are passed to the same formal parameter and the second being when a single actual is passed to two formals in fact parameter pointer aliasing something aliasing behaves much like which makes more sense when we consider the fact that a call binds the formal parameters to the locations corresponding actual parameters by the for the of the call in effect for formal x and actual y there is an assignment of the form u taking to be a variable so that the storage accessible through it is simply x we see that the initialization for such a copy is exactly that used in the relations for a call using ie add the pair xy to affect however the algorithm which we used to propagate values for reference parameters is not sufficiently general to handle pointers although the effects are very similar in the two cases there is one crucial difference we mentioned that the binding of a formal parameter to an actual parameter is in effect an assignment of the address of the actual to the address of the formal considering these two addresses to be variables this almost models the situation which occurs with pointers the difference with pointers is that the variables which contain addresses can be aliased as well and so assignments to a pointer variable must be propagated to all of the aliases of the variable this includes assignments of the address of a variable cases and furthermore for any variable which is assigned the address of another variable it is necessary to ensure that the appropriate aliasing is computed between the second variable and the storage accessible through the first variable the method which we choose to solve this problem is to iterate for each modification to a variable which we discover we will add the aliasing relationships implied by that modification and then iterate to see if this produces any more modifications this produces the algorithm in figure the function ind returns the object which denotes storage accessible via one level of indirection on x if x is of the form ay y is returned if x is of the form y and y is a pointer variable y is returned if y is not a pointer variable then the pair should be ignored finally if x is of the form y y itself is returned for each modification x y this explicitly propagates the implied aliasing information to all z such that x affect z the propagation to other aliases of x eg to those z such that z affect x is already done by of the fact that whenever we have z affect x we also have initialize affect and as indicated above repeat m affect t o for each xy in m add to affect add to affect until there is no change in affect pval affect v affect t o figure z affect x then z affect y adding xy to affect the closure of affect will as desired and give the key to the correctness of this algorithm lies in the definition of affect remember that a pair xy in affect means that every alias of y is also an alias of x now suppose that variable x has value a at some point in the execution of the program there must be a sequence of assignments which results in the assignment of a to x assume that for the ith assignment in the sequence all of the possible aliasing which can result from previous assignments is in affect we will show that the same is true for the aliasing which results from the ith assignment the proof of the correctness of the computation of pval is then identical to the proof used for reference parameters we first note that for each possible assignment which appears in the program affect is initialized such that if an assignment is the first in the sequence the aliasing computed from affect is correct after considering that assignment the ith assignment in the sequence however could assign a value not just to the explicit target of the assignment but also to any aliases of that target assuming that affect contains at least the aliasing information resulting from the previous i assignments and that the target of the ith assignment is w the computation of m finds all possible modifications of those y such that w affect y the aliasing implied by these modifications is then entered into affect we must show that forming the closure of affect computes all aliasing which could result from the ith assignment since w may alias any z for which there exists a y such that w affect y and z affect y we must show that the pairs entered in affect by the loop over the pairs in m cause the aliasing for each such z to be correct we have shown that this is true for each y such that w affect y since as may be easily verified z affect y is true if z affect y is true the aliasing which was entered for y is to z when the closure of affect is this means that the aliasing is correct after considering the ith assignment from which we can deduce that the aliasing is correct after considering the sequence of assignments computation of pval is correct determined as a possible value for x therefore the and so a is we claim that this algorithm is precise as well as correct given the assumption that no information about control flow is available observe that a pair xy in affect means that every alias of y as computed by the expression affect o affect t is also an alias of x now observe that this is actually the case for every pair which is placed into affect because of a modification from this it follows that the aliasing is precise which implies that computation of pval produces precise information the the reason why the aliasing information computed is precise for pointers but not for reference parameters is that the call structure of the program contains information about the relative of the alias relationships for parameters unless control flow information is considered no such information is available for aliasing due to pointers within a single procedure allowing multiple procedures in the collection with parameters passed by reference requires a change only in the initialization of affect no change in the propagation algorithm itself is required for each call with operands yi to a procedure with formal parameters xi the pairs and xi yi should be added to affect the initialization for all other statements is as above we omit the details of the proof of correctness for this version of the algorithm the algorithm has the same as it did for programs with reference parameters and without pointers before discussing the time requirements of this algorithm we make an observation about the algorithm itself this is that it is not necessary to the transitive closure of affect each time through the loop nor is it necessary to consider the effects on m of a pair in affect whose effects have already been considered in other words we can propagate the effects of modifications incrementally this leads to the equivalent version of the algorithm given in figure in this algorithm we keep track of all recently discovered aliasing relationships and determine any modifications implied by these relationships we then compute the aliasing relationships implied by these initialize affect and as indicated above affect affect affect do while m o qj for each xy in m add to add to remove those pairs from affect that are already in add each pair in closure of affect to affect and the let be all those pairs which were added to affect by the previous statement end affect v affect t o figure modifications and continue aliasing is discovered this process until no new let n be the size of the domain of the relations let e be the total number of pairs in affect when the algorithm the initial closure of affect can be done in time tn the computation of the contribution of a single pair in to m can be done in time n every pair in affect appears in at this point in the program at most once therefore the total time spent in the computation of m for all iterations of the outermost loop is at most ne the loop over the elements of m can be done as m is computed and so the total time spent in this loop is at most ne the time spent deleting those pairs in which are already in affect is proportional to the number of such pairs there are at most ne such pairs for all iterations of the outermost loop since the total number of pairs placed in m for all iterations of the outermost loop is at most ne finally the forming of the closure of affect can be done in time at most n for each pair which is added to affect whether it is in or is added in forming the closure after adding a pair in there are at most e such pairs so the total time spent forming the closure of affect for new pairs is at most ne the computation of pval can be done in time the total time for the algorithm as a whole is therefore ne calls on procedure variables the final step is to consider propagating values through calls on procedure variables the basic problem with a call on a procedure variable is that at the time the call is encountered in scanning the program the possible values for the variable and hence the actual procedures which might be called by the statement are unknown therefore it is not possible to immediately associate the actual parameters of the call with the formal parameters of the procedure being called to avoid the program several times we need a mechanism to keep track of the actual parameters of calls on procedures variables when a value is determined for a procedure variable we can then associate the actual parameters of the calls on the variable with the formal parameters of the value the mechanism which we choose to this is to create for each procedure variable dummy formal parameters for a given procedure variable x which is called with m actual parameters we create m dummy formal parameters for we also create dummy variables for each dummy formal parameter representing the storage accessible through the dummy formal the number of dummy formal parameters which need to be created can be determined by an initial scan of the program which keeps track of the number of actual parameters passed to each procedure variable if the source language requires complete type specifications of procedure variables ie that the types of the parameters be specified as well then the number of dummy formal parameters which are needed for each procedure variable can be determined from the declaration of the variable also entries only need to be created for those parameter positions which have pointer types having created dummy formal parameters for each procedure variable the initialization required for a call on a procedure variable is exactly that for a call g procedure in the collection if the call has actual parameters yi and is to procedure variable x with dummy formal parameters the pairs and should be added to affect if we consider a procedure variable x to be a procedure with formal parameters which contains a single statement that statement being a call on the current value of x with actual parameters it should be clear that each time a value a is determined for x we should associate the formal parameters of a with the dummy formal parameters of x as pairs one way in which this can be done as suggested by is to create relations one for each parameter position a pair xy in means that x has ith formal parameter y for each procedure a in the collection with formal parameters yi the pair is placed in for each parameter position i for each procedure variable x with dummy formal parameters the pair is placed in for each parameter position i now suppose that a is determined as a possible value for x if yi is the ith formal parameter of a and a is a possible value for x and x has ith formal parameter then the pairs and should be added to affect the expression t o o computes the pair this leads to the algorithm in figure this algorithm like the one developed for pointers initialize affect and as indicated above repeat m u affect t o for each xy in m add to affect add to affect pval affect v affect t for each parameter position i p o o for each xy in p add xy to affect add to affect until there is no change in affect pval affect v affect t o figure can be transformed into an equivalent algorithm which propagates information incrementally a similar time bound can also be derived for it its correctness should be fairly clear given the correctness of the algorithm for programs without calls on procedure variables and we omit the proof we mentioned earlier that actual parameters to calls on procedures in the collection or on procedure variables should be restricted to be variables and not constants the reason for this was to avoid the discussion of aliasing since constants are passed by value under call the solution to this is to initialize pval with all pairs xa such that there is a call to a procedure or procedure variable with formal parameter x and corresponding actual parameter a no entry is made in affect for such pairs the computation of pval affect v affect is then changed to assign pval v affect v affect to pval in this way constant actual parameters are propagated but no values may be attributed to them due to modification of the corresponding formals the alias relation the alias relation as mentioned computed by the expression earlier can be affect o this relation gives an answer to the question is it possible at some point in the program for variable a to be aliased with variable b the obvious ways to store this relation eg as a boolean matrix or as a list for each variable of the variables to which it might be aliased take space which is roughly proportional to the square of the number of variables in many situations however it is the case that there are sets of variables which are equivalent under this relation we define equivalence of two variables to mean that they may be aliased to each other and that the sets of variables to which they may be aliased are identical each such class could potentially be stored in space linearly proportional to the number of variables in it rather than to the square of that number the amount of storage required for the alias relation is then c rather than v where c is the number of classes which may be of unit size and v is the number of variables this is especially useful in because of the large number of temporaries which are generated for constructs such as array indexing and which fall into fairly large classes of equivalent variables we prove the following theorem necessary and sufficient condition for be equivalent as defined above which gives a two variables to theorem given the relation affect consider it as a graph and find its maximal strongly connected components replace each such component with a new node identified with the component this leaves a directed acyclic graph dag define a sink in the dag to be a node which has no edges coming out of it a node x in the original graph is a sink if the node identified with the strongly connected component containing x is a sink in the dag we say that node a reaches node b if there is a path possibly of length zero in the graph from a to b two nodes in the original graph are equivalent if and only if they reach the same set of proofi we will consider affect and alias as graphs derived in the obvious way from the relations previously discussed and will give the proof in terms of nodes and edges of these graphs affect is a directed graph while alias may be considered as an graph since the alias relation is symmetric this is easily seen from the definition of alias when we of an edge in alias we mean an edge also when we of a node x reaching a node y we mean that there is a path from x to y in affect unless stated otherwise a path is defined as a possibly empty sequence of edges we note that there is an edge between node x and node y in alias if and only if there exists a node z such that x reaches z and y reaches z this follows immediately from the definition of alias in terms of affect two nodes x and y are equivalent if and only if the following three conditions hold there is an edge between x and y in alias for each edge between x and some node z in alias there is an edge between y and z for each edge between y and some node z in alias there is an edge between x and z in other words two nodes are equivalent if and only if they alias each other and the sets of nodes which they alias are identical lemma x alias y is true if and only if there exists a sink z such that x reaches z and y reaches z proof of lemma from the definition of alias it is clear that x alias y is true if and only if there exists a node w such that x reaches w and y reaches w therefore if there exists a sink z such that x reaches z and y reaches z it follows that x alias y is true we now show that such a z exists if x alias y is true let w be such that x reaches w and y reaches w consider the dag derived from affect in the statement of the theorem let u be the node in the dag which is identified with the strongly connected component containing w u must reach some sink v in the dag let z be a node in the strongly connected component identified with v since u reaches v in the dag it follows that w reaches z this means that x reaches z and y reaches z v is a sink that z is a sink and so z is the desired node we now prove the theorem first showing that if x and y reach the same set of they are equivalent and then showing that if they reach sets of they are not equivalent suppose that x and y reach the same set of since this set is necessarily nonempty they are aliased to each other suppose that x alias w is true let z be a sink such that x reaches z and w reaches z as in the lemma since x reaches z it follows by hypothesis that y also reaches z by the lemma it follows that y alias w must be true similarly if y alias w is true it follows that x alias w is true therefore x and y are equivalent now suppose that x and y are equivalent furthermore suppose that there exists a sink z which one of them say x reaches and which the other one say y does not reach by the lemma it follows that x alias z is true since a sink reaches itself furthermore there is no w such that y reaches w and z reaches w since z reaches only itself being a sink and y does not reach z therefore y alias z is not true this gives a contradiction since we have found a node z such that x alias z is true and y alias z is not true that x and y are not equivalent this completes the proof of the theorem this theorem leads naturally to a reasonably efficient method for computing the sets of equivalent variables these sets can then be used for storing the alias relation strongly connected components can be computed in time o where n is the number of nodes in affect and e is the number of edges deciding which nodes are can be done by first forming the reflexive transitive closure of affect and then checking each strongly connected component to see if there is an edge from any node in the component to a node in another component if there is no such edge then the component and each node in it is a sink a technique described by wegman and can then be used to partition the nodes into classes based on the sets of which they reach this technique involves hashing the which a given node reaches the results of the hash together to get a new representation of the set having found the new representation of the set of reached by each node the nodes can be partitioned very quickly based on the equality of these representations by using a hash table for those nodes whose sets of have the same such representation the actual sets should be compared this is because the representation is guaranteed to be unique only within a specified probability summary in this paper we have presented an approach to interprocedural data flow analysis for programs which use pointers label variables and procedure variables we have stated as the major to such analysis the problems of determining the call graph the control flow graph and the alias relationships in the program and have presented an algorithm for determining these program characteristics subject to the basic assumption that information about control flow is not available we have shown that the algorithm is precise for programs containing simple assignments and multiple procedures with parameters passed by value assuming that information about the number of levels of indirection involved in accessing storage through a pointer is not available we have shown that the algorithm is precise for programs containing pointer variables as long as the program consists of a single procedure the algorithm is in fact precise for programs containing multiple procedures and pointer variables as long as pointers are not passed as parameters when pointers may be passed as parameters or parameters are passed by reference the information produced by the algorithm is no longer as precise as possible similarly when the program may contain calls to procedure variables the information produced lacks some precision we have also shown that the problem of determining possible values for procedure variables is pspace hard this fact makes it that a method exists which is both precise and reasonably efficient in certain cases we have shown that the algorithm is asymptotically as efficient as possible we have also discussed some characteristics of the aliasing information which is produced and have shown how these characteristics can be used to store the information more efficiently it is still an open question whether it is possible to produce better information without any loss of efficiency it is also open as to whether iteration is required in cases involving aliasing and calls on procedure variables it may be that the information produced can be computed in time bounded by the time to compute the transitive closure of an n x n matrix it is also possible that certain restrictions on the use of procedure variables and reference parameters may make it possible to compute the desired information both precisely and efficiently acknowledgements the author would like to thank for this work he and thanks for the many helpful suggestions which they made as these algorithms were being developed also provided many suggestions on the work ferrante allen john and the others mentioned above also thanks for their comments on previous of this manuscript which greatly improved the presentation mark wegman provided some key insights in analyzing the time requirements of the algorithm finally ibm itself should be for providing the to do this work through the mit via program references aho a v hopcroft j e and unman jd design and analysis of computer algorithms addisonwesley aho av and unman jd principles compiler design addisonwesley of allen fe interprocedural data flow analysis proceedings ifip north holland amsterdam allen fe and j a program data flow analysis procedure march allen f e et al the experimental compiling systems project ibm research report rc tj watson research center heights ny september jp a method for determining the side effects of procedure calls phd thesis stanford university report no stanford linear center august j interprocedural data flow analysis based on transitive closure univ of california at berkeley computer science dept tech rep september jl private communication graham sl and wegman m a fast and usually linear algorithm for global flow analysis ja cm january rosen bk data flow analysis for procedural languages april ryder bg constructing the call graph of a program ieee ions on soft engineering se may tc sideeffects in a optimizing compiler proceedings ifip conference north holland amsterdam optimization recursion analysis for compiler cacm september wegman m n and jl new classes and applications of hash functions proceedings annual symposium on foundations of computer science october w e interprocedural data flow analysis in the presence of pointers procedure variables and label variables s m thesis massachusetts institute of technology to be published ka a theoretical study of some aspects of parameter passing in algol and in similar programming languages phd thesis university august 