practical affine types a university boston massachusetts usa abstract alms is a generalpurpose programming language that supports practical affine types to offer the expressiveness of linear logic while keeping the type system light and convenient alms uses expressive kinds that minimize notation while polymorphism between affine and types a key feature of alms is the ability to introduce abstract affine types via signature in alms an interface can impose resource usage restrictions than the principal usage restrictions of its implementation this form of sealing allows the type system to naturally and directly express a variety of resource management protocols from type systems we present two pieces of evidence to demonstrate the validity of our design goals first we introduce a prototype implementation of alms and discuss our experience programming in the language second we establish the soundness of the core language we also use the core model to prove a principal theorem categories and subject descriptors d programming languages language constructs and features general terms languages keywords affine types linear logic type systems polymorphism modules a practical affine type system alms is a practical generalpurpose programming language with affine types affine types enforce the discipline that some values are not used more than once which in alms makes it easy to define new abstractions generalpurpose means that alms offers a full complement of modern language features suitable for writing a wide range of programs practical means that alms is neither nor a minimal is possible to alms and try it out type systems divide into two foundational calculi closely to linear logic and implementations of type systems designed to solve special problems we argue that a general practical type system based on linear logic can naturally and directly express many of the special cases such as memory management aliasing control session types and typestate to this end the language must satisfy several permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm module type rw lock sig type array array of identified by type exclusive access type shared shared access type a grants level access to array e val new int array val array val array shared val release array unit val set array int val get array int × end figure an interface for locks § convenience values are the common case so working with them is as smooth as in a conventional language expressiveness a wide variety of type systems appear naturally as idioms it is easy to use and understand it provides the of a modern highlevel programming language such as algebraic datatypes pattern matching exceptions concurrency and modules soundness it has a clear theoretical foundation we show that alms meets these criteria alms a dependent kind system to determine whether a particular type is affine or and to support polymorphism over affine and types this approach may sound complicated but in practice it is no or harder to understand than the type systems of other functional programming languages affine types a weakening of linear types duplication of some values unlike with linear types all values may be this flexibility is appropriate to a highlevel language and it better with other features such as exceptions our contributions this paper introduces the programming language alms its implementation and its basic theory · we describe the design of alms whose novel features include precise kinds for affine type constructors and demonstrate how it expresses a variety of idioms § · our implementation is a usable prototype in which we have written several lines of code § · alms on a theoretical basis we provide a formal model § and establish essential theoretical properties § our implementation and full proofs are available at learn alms in pages alms is a typed callbyvalue impure functional language with algebraic data types pattern matching reference cells threads exceptions and modules with opaque signature alms reads like ocaml leroy et al but is explicitly typed in most cases local type inference explicit type instantiation unnecessary we introduce alms through a series of examples consider a simple alms function that updates one element of an array by adding an integer let a int int amount int a a amount this function has a race condition between the read and the write so we may want to use a lock to enforce mutual exclusion let a int int amount int lock lock a a amount lock affine data locks can ensure mutual exclusion but using them correctly is a rather alternative to ensure mutual exclusion is to aliasing of the array if we have the only reference to an array then no other process can operate on it concurrently in alms we do this by an interface that includes a new abstract array type module type af array sig type array a val new int array val set array int a a array val get array int a × array end module af array struct end the notation a specifies that type has kind a as in affine which means that any attempt to duplicate a reference to such an array is a type error two points about the types of and are worth noting · each must return an array because the caller cannot reuse the reference to the array supplied as an argument · type a has kind a which means that it may be used at most once this is necessary because a function partially applied to an affine value would reuse that value we now rewrite to use the af array interface let a int int int let balance a a in a balance if we attempt to use an more than once without it a type error results let a int int int let balance a in a balance alms reports that the affine variable a is duplicated implementing is just a matter of the primitive array type and operations and sealing the module with an opaque signature it is to call this an affine function but standard terminology says that an affine function uses its argument at most once whereas here we have the type of a function itself usable at most once whether an alms function is affine is determined by the kind of the type of its formal parameter e module af array struct type array let new let set a array ix int v a ix v a let get a array ix int a ix a end the original array type has kind u as in because it places no limits on duplication we can use it to represent an abstract type of kind a however because u is a of a and kind subsumption rule allows assigning an abstract type a greater kind than that of its concrete representation this is somewhat to standard treatment of equality types milner et al and treatment of type constructor variance leroy et al in sml is subsumed by type in that signature matching can abstract an equality type to a type but not vice versa we need not change new at all and get and set are modified slightly to return the array as required by the interface affine capabilities the affine array interface is quite restrictive because it requires an array through the program it cannot support operations that do not actually require exclusive access to the array however alms supports creating a variety of abstractions to our needs one way to increase our flexibility is to separate the reference to the array from the capability to read and write the array only the latter needs to be affine for example we may prefer an interface that supports dirty reads which do not require exclusive access but are not guaranteed to observe a consistent state module type cap array sig type array type cap a val new int array × cap val set array int cap cap val get array int cap × cap val array int end in this signature array is now and cap is affine type arrays second parameter is a stamp used to tie it to its capability which must have type cap where matches in particular the type of new indicates that it returns an existential containing an array and a capability with matching stamps the existential guarantees that the stamp on an array can only match the stamp on the capability created by the same call to new operations set and get allow access to an array only when presented with the matching capability this ensures that set and get have exclusive access with respect to other sets and gets they no longer return the array but they do need to return the capability on the other hand does not require a capability and should not return one for example the cap array interface allows us to an array while simultaneously computing an approximate sum let a cap let th a cap in let th a in th th to implement cap array we need suitable representations for its two abstract types we represent cap arrays arrays by the primitive array type and capabilities by type unit which is adequate because these capabilities have no runtime module a array module cap array struct type array type cap unit let new size int init size init let set a ix int v a ix v let get a ix int a ix let end type unit has kind u but as in the previous example we can abstract it to a to match the kind of the tation of the operations is in terms of the underlying array operations with some to ignore capability arguments in set and get and to construct tuples containing to represent the capability in the result in new and get capabilities are values capabilities such as often represent the state of a resource but in alms they are also ordinary values they may be stored in immutable or mutable data structures into exceptions and or sent over communication channels like any other value for example suppose we would like a list of array capabilities lists are defined thus in the standard library type list nil cons of × list the type variables we have seen until now could only be instantiated with types but the on type variable indicates that may be instantiated to any type whether affine or whether a list should be treated as affine or depends on whether the contents of the list is affine or alms represents this fact by giving the list type constructor a dependent kind where kind denotes the kind of list list has kind that is the kind of a list is the same as the kind of its element type type int list has kind u whereas list has kind a in general the kind of a type is the least upper bound of the kinds of the types that occur directly in its representation for example type r × type s int × type t t of t of t type u u u of u type v × unit type w × unit unit u because both and are part of the representation of r it must be affine if either of its parameters is affine on the other hand the parameter is not part of the representation of s so that has kind the kinds of t and u are the least solutions to these inequalities t t t u u u u the kind of each type must be at least as restrictive as the kinds of all of its alternatives for v the kind of does not appear because the domain and codomain of a function type are not part of the functions representation instead function types have their kind in a as in the definition of type w we saw this in the example if you think this unit is unnecessary we agree § where the were all a when the kind is u we often omit it we discuss the kinds of function types and their subtyping in more depth in § more possibilities the rules of alms are flexible enough to express a wide variety of designs for example the ability to store capabilities in data structures allows us to create a more dynamic interface than the static capabilities of module type cap lock array sig include cap array val new int array val acquire array cap val release array cap unit end this signature changes the type of new to return an array with unique tag but no capability to operate on the array one needs to request a capability using acquire subsequent attempts to acquire a capability for the same array block until the capability is released we implement cap lock array in terms of without any knowledge about the representation of its capabilities the implementation relies on synchronized variables based ids et al an may hold a value of type or it may be empty while an may contain an affine value the itself is always this is safe because calling take on a nonempty removes the value and returns it while take on an empty blocks until another thread puts a value in it to implement cap lock array we now represent an array as a pair of the underlying and an to store its capability module cap lock array struct module a type array × cap let new size int init let a cap size init in a cap let acquire array let release array cap cap cap let set a array a let get a array a end the new operation creates a new pair and stores the capability in an operations acquire and release use the component of the representation while the old operations such as set must be lifted to project out the underlying there are many more possibilities figures and show two interfaces for locks which at any one time allow either exclusive readwrite access or shared readonly access signature rw lock figure on the first page describes dynamic locks the signature declares types and shared and an affine binary type constructor · · capabilities now have type where the capability to a particular array and records whether the lock is exclusive or shared operation set requires an exclusive lock but get allows to be shared or signature fractional figure describes static locks based on fractional capabilities as in the previous example the capability type cap has a second parameter which in this case represents a fraction of the whole e e module type fractional sig type array type type type type cap a val new int array × cap val split cap cap × cap val join cap × cap cap val set array int cap cap val get array int cap × cap end figure another interface for locks capability the fraction is represented using type constructors and · · a capability of type cap grants exclusive access to the array with tag while a fraction less than such as or indicates shared access there are operations split which splits a capability whose fraction is into two capabilities of fraction and join which combines two capabilities back into one capability again set requires exclusive access but get does not syntax given as defined above we can rewrite to take advantage of it open let a int array int int let cap acquire a in let balance cap get a cap in let cap set a balance cap in release a cap while this gets the job done the explicit of the capability can be and hard to read to address this alms provides preliminary support for an alternative syntax inspired by a proposal by et al let a int array int int let cap acquire a in set a get a cap cap release a cap the pattern cap bound by let marks cap as an imperative variable which means that within its scope functions applied to cap are expected to return a pair of their real result and the new version of cap alms transforms this code into the version above currently this transformation happens before type checking which means that it cannot soundness but also cannot exploit type information implementation and experience our prototype implemented in k lines of haskell is available at besides a usable interpreter it includes all the example code from this paper and other alms examples a variety of concepts · a interface to berkeley ensures that the protocol to set up a is followed correctly this library also shows how exceptions may be used for error recovery in the presence of affine capabilities · an server is built on top of the library · two session types et al libraries demonstrate different approaches to alternation one uses anonymous sums and the other uses algebraic datatypes for named branches · our version of and uses session types to connect stream transducers · the alms standard library implements higherorder coercions for checked which can for example turn a function of type unit u unit u thread into a function of type unit a unit u thread by adding a dynamic check these examples are not the last word on what can be done in a language like alms haskells type classes wadler and a general mechanism to solve specific problems have since found uses similarly a practical general form of types as by alms likely has many applications waiting to be we have now written several lines of code in alms and this experience has led to improvements in both its design and our at using what it has to offer for example an earlier version of alms had only u and affine a arrows but behavioral contract library motivated the introduction of arrows whose kinds involve type variables eg in particular we found ourselves writing the same function multiple times with different qualifiers in the argument types and the addition of usage qualifier expressions eliminates this redundancy the calculus we model alms with a calculus based on system f the higherorder polymorphic calculus with subtyping pierce our calculus makes several important changes to f · our type systems structural rules are limited in particular contraction which variables in a typing context to make them accessible to multiple subterms applies only to variables whose type is of the kind variables of affine or polymorphic kind cannot be · our kind system is with dependent kinds · our kind system is also with variance on type operators which allows abstract type constructors to specify how their results vary in relation to their parameters · type operators are limited to firstorder is type operators may not take type operators as parameters · type variables are bounded only by a kind not by a type · the subtyping relation is induced by the subtyping rule for functions an function may be supplied where a function is expected the calculus also includes more types and terms than a minimal presentation of f because we are interested in practical issues we think it is important that our model include products sums mutable references and nontermination we do not model modules directly in but its type abstraction makes a suitable target for the firstorder fragment of et als modules translation in linear logic terms our calculus like alms multiplicative products and additive sums directly additive products are easily encoded by a a a e e a k case k of x x e x x e where and are the kinds of and q usage qualifiers v kinds × types e x x e e e v e terms e e case e of x x e e e case e of x e y e fix e new e swap e e delete e ptr v x e v v v ptr v v values · x typing contexts q a u v ± v · v v · ± ± ± constants variance composition figure syntax of syntax we begin with the syntax of in figure terms e include the usual terms from system f variables abstractions applications type abstractions and type applications several forms for data construction and elimination nil pairs pair elimination sum and sum elimination recursion fix e and several operations on reference cells allocation linear swap and deallocation location names ptr appear at run time but are not present in source terms values v are standard types include type variables typelevel abstraction and application universal quantification function types and type constructor constants for unit sums products and references as in alms the function arrow carries a usage qualifier which specifies whether the function is or the two constant usage qualifiers q u for and a for affine are the bottom and top of the lattice in figure now consider the k combinator x y x partially applied to a value k v whether it is safe to duplicate this term depends on whether it is safe to duplicate v and this is reflected in the instantiation of to express this relationship we introduce usage qualifier expressions which form a bounded distributive lattice over type variables with u and a as bottom and top we can thus give k type u qualifier expressions are the base kinds of that is the kinds that classify proper types that may in turn classify values to classify type operators kinds also include dependent product kinds written v this is the kind of a type operator that when applied to a type with kind gives a type with kind for example the kind of the alms list type constructor in § is which means that list has the same kind as the in kind means that list is a covariant or monotone type constructor if is a subtype of then list is a subtype of list v form a lattice figure a type operator may also be contravariant where the result with the argument where argument may vary freely without the result or invariant ± where the argument may not vary at all without producing a whereas alms uses conventional notation for typelevel application uses prefix application s e s e smallstep reduction s x e v s s v s v s fix v s v fix v s new v s v ptr s v swap ptr v s v ptr v s v delete ptr s s e s e s ee s ee e e e v e e e e v e evaluation case e of x x e e e contexts case e of x e y e fix e new e swap e e swap v e delete e s v s s stores figure operational semantics selected rules result we define a composition operation · on where v · v is the variance of the composition of type operators having v and v the kinds of the type constructors for sums and references may aid understanding the sum type constructor has kind this means that the kind of a sum type is at least as restrictive as the kinds of its it is covariant in both arguments which means that is a subtype of if is a subtype of and is a subtype of the reference type constructor on the other hand has kind ± a this means that reference cells are always affine and that their types do not support subtyping in either direction typing contexts or associate type variables with their kinds variables with their types and locations with the types of their contents by convention we use for typing contexts that include neither affine variables nor locations and we use for typing contexts that may include locations and affine or variables we use dom to refer to the type variables variables and locations mapped by a context we define the free type variables in a variety of syntactic forms ftv ftv etc in the standard way we use to denote the set of location names present in term e there are no binders for locations operational semantics the operational semantics of is mostly a standard callbyvalue reduction semantics we give a selection of rules in figure the reduction relation relates configurations s e a store and a term a store maps locations to values v stores are taken to be unordered and do not repeat location names the rules for reference operations are worth noting in store s new v chooses a fresh location adding v to the store at location and reducing to the reference ptr the operation swap ptr v requires that the store have location holding some value v it v for v in the store returning a pair of a reference to and value v finally delete ptr also requires that the store contain which it then removes from the store this means that a location can result in a dangling pointer which would cause subsequent attempts to access that location to get stuck our type system prevents this v v e s s e kind is well formed fig kind is subsumed by fig type when increases fig type has kind fig type is to type fig context is bounded by qualifier fig extending with gives fig term e has type fig store s has type fig configuration s e has type fig figure type system judgments kind wellformedness ftv dom if ftv then v v v v v v figure i kinds static semantics our type system involves a large number of judgments which we summarize in figure in several cases we omit premises concerning wellformedness of contexts which the presentation and do not add anything of interest the omitted premises appear in the extended version of this paper kind judgments judgments on kinds appear in figure the first judgment determines whether a kind is well formed in typing context a base kind ie a usage qualifier expression is well formed provided that specifies a kind for all of its free variables a dependent product kind v is well formed if maps all of its free variables provided it satisfies a second condition whenever the bound type variable is free in that is when the kind is variance v must be or ± this rules out kinds such as that classify no useful type operator but whose presence breaks the relations monotonicity property see lemma the second judgment is as we will see if a type has kind then it may be used where or any greater kind is expected for dependent product kinds the order is merely the product order on the variance and the result kind but for base kinds the relation relies on an interpretation of qualifier expressions we interpret qualifier expressions via a valuation v which is a map from type variables to qualifier constants we extend vs domain to qualifier expressions q v v v v v v v v we need to interpret qualifier expressions under a typing context definition consistent valuations a valuation v is consistent with a typing context if for all v v thus a valuation is consistent with a context if it corresponds to a potential instantiation of the type variables given that context definition qualifier subsumption we say that is subsumed by in written if for all valuations v consistent with v v in other words in all possible instantiations of the type variables in qualifier being a implies that is a and variance the first two judgments in figure for computing and giving kinds to types are defined by mutual induction it should be clear on inspection that the definitions are wellfounded judgment v means that type variable appears in type at variance v or in other words that type operator has variance v rules and say that type variables appear with respect to themselves and with respect to types in which they are not free rule says that a type variable appears in a type operator at the same variance that it appears in the body the remaining three rules are more involved · by rule the variance of a type variable in a type application comes from both the operator and the operand the variance of in is at least the variance of in and at least the variance of in the composed with the variance of operator this makes sense if is a contravariant type operator then appears in but in · by rule the variance of in is at least its variance in however if appears in then it is invariant in this reflects the fact that types are related only if their bounds match exactly so changing a type variable that appears in produces an type this means that is based on the kernel variant of f pierce · by rule the variance of in a function type is at least its variance in the codomain and at least the opposite composition with of its variance in the domain this reflects function argument the variance of is at least if it appears in the qualifier expression the second judgment assigns kinds to well formed types rule merely looks up the kind of a type variable in the context rules and are the usual rules for dependent abstraction and application with two small changes in rule first it associates with itself in the context as which ensures that occurrences of in can be reflected in second it to the variance judgment to determine the variance of the type operator rule assigns a universal type the same kind as its body but with a replacing this is necessary because the resulting kind is outside the scope of qualifier a is a safe bound for any instantiation of and no terms have types that lose precision by this choice the kind of an arrow type in rule is just the qualifier expression attached to the arrow the remaining rules give kinds for type constructor constants type equivalence and subtyping the last judgment in figure is subtyping the subtyping relation is parametrized by a variance v which gives the direction of the subtyping is the usual direction a subtype of in terms of subsumption this means that values of type may be used where values of type are expected the other are useful in defining the relation in the presence of type operators gives the inverse of the subtyping relation ± relates only equivalent types and relates all types we can see how this works this in rule to determine whether is a v variance of type variables with respect to types v v v v v · v ftv v v if ftv then ± else v v v v v v v if ftv then else v v v of types v v v v a × u ± a subtyping v v v v v v v v v v v v v v v v v v v figure ii types subtype of we take v to be yielding v v v v this means that for the subtyping relation to hold · the operators must be related in the same direction so that is a subtype of · the operands must be related in the direction given by the of the operators for example if both operators are covariant then the operands must vary in the same direction so that is a subtype of if both operators are contravariant then the operands must vary in the opposite direction if the operators are invariant then the operands cannot vary at all but if they are then is a subtype of for any and rule says that subtyping includes type equivalence which is merely equivalence on types rule allows any pair of types to be related by variant subtyping and rule says that the opposite variance sign gives the inverse relation rules and specify that type operators and types are related if their bodies are rule is more than the usual arrow subtyping rule beyond the usual for arguments and for results it requires that qualifiers and relate in the same a a direction this rule is the source of nontrivial subtyping in without which subtyping would relate only equivalent types the rule has two important implications first an function can always be used where a function is expected this corresponds to linear logics usual rule which says that the of course modality may always be removed ill has a rule e a e a is syntaxdirected in this rule but for practical programming we consider that as too thus our subtyping relation supports as needed for example the function for creating a new thread in alms has type unit a u thread which means that will not call its argument more than once however this should not stop us from passing an function to and indeed we can subtyping allows us to use a value of type unit u where a value of type unit a is expected alternatively by domain we can use where a value of type unit u u thread is expected in this case subsumption allows us to not to reuse its argument the other important implication of subtyping will become once we see how qualifier expressions are assigned to function types subsumption makes it reasonable to always assign functions the most permissive safe usage qualifier because bound of typing context · u x a typing context extension · u x x x x figure iii typing contexts subsumption then allows us to use them in a less permissive con text subtyping applies only to function types because in both the calculus and alms language only function types carry qualifiers for instance alms has no separate types for integers and for affine integers integers are always if a programmer wants an affine version of int she can create it in alms using the module system context judgments figure defines two judgments on contexts judgment which will be important in typing functions computes an upper bound on the qualifiers of all the types in context if a context contains any locations it is bounded by a otherwise its bound is the least upper bound of the qualifiers of all the types of variables in the context the second judgment shows how environments are extended by variable bindings the typing judgment for terms will use two typing contexts holds environment information that may be safely duplicated such as type variables and variables of type whereas holds information such as location types and affine variables that duplication given contexts and judgment extends them by the variables and types in to get and any variables may be placed in but only variables whose types are known to be may be placed in since may be duplicated term judgment the typing judgment for terms appears in fig the judgment e uses two typing contexts in the style of the environment and the affine environment when typing multiplicative terms such as ap we to both subterms but partition between the two e e e e unlike not all types in are necessarily affine since types whose usage qualifier involves type variables are not known to be we place those in to ensure that we do not duplicate values that might turn out to be affine once types are instantiated the other multiplicative rules are for product introduction for product elimination and for reference updates note that does not require that the type of the reference in its first parameter match the type of the value in its other words swap performs a strong update to type the term case e of x x e rule first splits the affine environment into for typing subterm e and for subterm e it invokes the context extension relation figure to extend and with bindings for x and x in order to type e the context extension relation requires that variables not known to be be added to the rule for sum elimination is both multiplicative and additive the affine context is split between the term being and the branches of the case expression however the portion of the context given to the branches is shared between them because only one or the other will be evaluated rule also uses the context extension relation to bind the pattern variables for the branches rules and introduce and eliminate reference types in the usual way likewise the sum introduction rules and type abstraction rule are standard rules and are standard for an affine calculus but not a linear one as they implicitly support weakening by allowing to contain unused bindings rule is also standard modulo the reasonable constraint that its parameter function be since the reduction rule for fix makes a copy of the parameter the type application rule supports because it requires only that the kind of the actual type parameter be a of that of the formal parameter this is the rule that supports the sort of type abstraction that we used in our examples of § to construct affine capabilities for example the rule lets us instantiate affine type variable with unit type a x e a u u a a x e within its scope is considered a priori affine regardless of how it may eventually be instantiated this term types only if x appears in affine fashion in e this us finally to the rule for typing abstractions to type a term x e rule uses the context extension relation to add x to its contexts and types the body e in the extended contexts it also must determine the qualifier that the arrow because abstractions close over their free variables a function also the values of its free variables therefore the qualifier of a function type should be at least as restrictive as the qualifiers of the abstractions free variables to do this rule to the context bounding judgment figure to find the least upper bound of the usage qualifiers of variables in the affine environment and it requires that the function types qualifier be equally restrictive this refines linear logics usual rule which says that the modality may be added to propositions that in turn depend only on ed resources in ill we have e a e a where is a context in which all assumptions are of the form x b as with in our system it only makes sense to apply to function types our treatment of indicates why we need the explicit weakening rule which allows unused portions of the affine environment in order to give a function type the best qualifier possible we need to remove from any unused variables or locations that might otherwise raise the bound on and the algorithmic version of the type system as implemented in e typing of terms e e e e x x ptr x e x e e e e e v v e e e e e e × e × x x case e of x x e e k e k k e e x e x case e of x e x e e e u fix e e new e e e swap e e × e delete e figure iv terms s · s e store typing s · v s v configuration typing conf s · s e e figure v stores and configurations alms does just that in § we show that our implicit mechanism selects the best usage qualifier for function types store and configuration judgments in order to prove our type soundness theorem we need to lift our typing judgments to stores and runtime configurations the type of a store is a typing context containing the names of the stores locations and the types of their contents the store typing judgment s gives store s type in the context of which is necessary because values in the store may refer to other values in the store rule shows that the resources represented by context ie are split between the values in s our preservation lemma concerns typing judgments on configurations s e which means that e has type in the context of store s to type the configuration by rule conf we type the store splitting its type into which contains locations referenced from the store and which contains locations referenced from e a a theoretical results we now state our two main qualifiers and type sketch their proofs full versions of our proofs may be found in an extended version of this paper available at principal qualifiers alms and go to a lot of to find the best usage qualifier expressions for function types to make programming with affine types as convenient as possible we want to polymorphism between and versions of functions while writing the alms standard library we found that usage qualifier constants a and u even with subtyping were to give a principal type to some terms for example consider function default an for option types function argument types let default def opt match opt with some x x none def without usage qualifier expressions default has at least two incomparable types default u option a default u option u in the first case because might be affine the partial application of default must be a function but in the second case we know that is so partially applying default and the result is safe formally these types are incomparable because the type variable in the former has a different kind than in the latter and alms uses the kernel variant of rule however even were we to replace rule with a rule analogous to fs full variant v v v the types would not be related by the subtyping order more importantly neither type is in an informal sense the type of default allows to be instantiated to an affine or type but the result of partially applying it is a function even if is known to be default int option a int default int option a int if we choose default the result of partial application is but to instantiate to an affine type is a type error default int option u int default type error alms avoids both problems and instead that the best usage qualifier for the arrow is the kind of the type variable a default u option default int option u int default int option a int because this is an important property we prove a theorem that every function has a principal usage qualifier theorem principal qualifiers if x e then it has a least qualifier expression that is · x e and · for all such that x e proof sketch we obtain the principal qualifier as follows let be the restriction of to exactly the free variables and locations of x e let be the unique bound of given by by strengthening x e and by rule we can get the same type in a derivation of x e always involves rule using some portion of followed by some number of and subsumption will never let be less than however weakening might allow us to type x e with a different portion of than we know that any superset of has bound no less than and while a of may have a smaller bound we chose so that only and its are suitable to type the term and then weaken to thus for a function in any given context there is a least usage qualifier and our implementation can find the least qualifier by considering only the portion of that to the free identifiers of the term as suggested by the algorithmic rule x e a if x fve x otherwise x e type soundness the key in our type soundness proof is establishing a substitution lemma which in turn relies on showing that the kind of the type of any value accurately reflects the resources contained in that value which itself comes as a corollary to the proposition that the kinds of subtypes are themselves lemma monotonicity of if where and then this lemma is the reason for the premise in rule that for a kind v variance v must be at least if ftv otherwise we could construct a counterexample to lemma · a u · a a and · u u · but a u is not the case the kind wellformedness judgment rules out kinds like proof for lemma we define an extension of the rela tion which is to the kinds observe that on qualifier expressions this new relation co with we generalize the induction hypothesis if where and then and complete the proof by induction on the structure of the subtyping derivation corollary finds locations suppose that v and where dom contains only locations if any locations appear in v then a proof sketch by induction on the typing derivation we use the previous lemma in the case for the subsumption rule v case v by the induction hypothesis a a and by lemma corollary lets us prove our substitution lemma then progress preservation and type soundness are standard theorem type soundness if e then either e diverges or there exists some store s and value v such that e s v and s v related work in prior work we showed how an affine language may safely with a conventional language and in particular the languages may freely share values including functions attempts by the conventional language to the affine languages invariants are by dynamic checks in the form of behavioral software contracts that paper focused specifically on interaction using a predecessor of alms system f et al describe a calculus of lightweight linear types their primary motivation is similar to ours to remove overhead and provide a simple foundation for practical linear programming system f and the prior iteration of alms independently introduced several new ideas · both use kinds to distinguish linear in alms affine types from types where fs kinds and correspond to our a and u and their relation corresponds to our u a · f uses and to abstract types into linear types alms the language uses modules and the calculus uses type abstraction to define abstract affine types including type constructors with parameters et al mention the possibility of extending f with abstraction over higher kinds but do not show the details · they sketch out a convenient notation for writing linear computations this inspired our different implicit syntax which is implemented in alms as mentioned at the end of § there are also differences · f has linear types which weakening whereas alms has affine types which support it this is a tradeoff linear types make it possible to enforce liveness properties which may be useful for instance to ensure that manual memory management does not leak on the other hand we that safely combining linearity with exceptions requires a system to track when raising an exception would implicitly discard linear values alms can support explicit deallocation so long as failure to do so is up by a garbage collector · function type is a subtype of its function type f does not provide subtyping though they do show how expansion can explicitly perform the coercion that our subtyping does implicitly experience with our implementation that subtyping is valuable though we admit it comes at the cost of complexity · f requires annotating abstractions xe to specify the kind of the resulting arrow type which may only be or alms refines this with qualifier expressions and selects the least kind automatically · et al give a semantics and prove that they can encode regular protocols we do neither but conjecture that our system similar properties except that weakening makes it possible to out of a protocol at any point · their sketch of rules for algebraic datatypes is similar to how ours work though ours are strictly stronger for example an option type in f would have two versions our dependent kinds in alms let us define one type constructor whose kind subsumes both option clean at first uniqueness types appear to be dual to affine types uniqueness types are indicate that a particular reference is affine and linear types are since they restrict what may be done to some reference in the future but do not necessarily know where its been similarly subtyping relation which allows that a value is unique appears dual to which allows that an value is affine however the duality breaks down in the higherorder case when a partially applied function captures some unique free variable type system must aliasing of the function in order to maintain uniqueness when the function is fully applied and in terminology function types with the unique attribute are essentially unique but we might call them affine there is a strong similarity between our judgment and uniqueness propagation rules that relate the uniqueness of data structures to that of their constituent parts while clean supports subtyping it does not have a relation analogous to alms or fs in particular clean requires that the uniqueness attributes declared for an abstract type in a modules interface exactly match the uniqueness attributes in the modules implementation use types and qualifiers wadler discusses several variants of linear type systems he proposes something to subtyping ie a a and points out that in such a system terms such as x have several types we made a similar observation in § in order to recover principal types he introduces use types which the exponential modality with a use variable i i the use variable ranges over and where a a and a a this provides principal types but at the cost of adding inequality constraints to type schemes a inequality of the form i j is essentially an implication i j where is truth and is de et al show in the setting of uniqueness types how such inequalities may be represented instead using boolean logic for example if we have a type i j i j we can discard the inequality constraint and represent it instead as i ik because i i k in general any collection of inequalities or constraints may be eliminated by replacing some of the use variables with propositional formulae over use variables this insight is the source of usage qualifier expressions if we follow use types to their logical conclusion we reach ahmed et al each type is composed of a that describes its representation and a qualifier that gives its usage alms does not follow this approach because we that qualified types are too for a type system their systems qualifier lattice includes two more than ours r for relevant types that allow duplication but not and l for linear types this results in a rich and elegant system but we do not believe r and l would be useful in a language like alms however there is an interesting correspondence between our rules and their type rules for example our product type constructor × has kind which means that the kind of a product type is the least upper bound of the kinds of its components the product typing rule in enforces a similar constraint that the qualifier of a product type must upper bound the qualifiers of its components and v v v v and is a safe lowlevel language with support for typestate it tracks keys which associate static capabilities with the identity of runtime objects in the same manner that alms uses type variables to tie values to capabilities this allows static enforcement of a variety of protocols as an example and give a tracked version of the berkeley api in previous work on alms we show how alms expresses the same interface treatment of capabilities may be more convenient to use than because while alms requires explicit of capability values key sets are tracked automatically within function bodies on the other hand because capabilities in alms appear as ordinary values we may combine them using the native intuitionistic logic of type system instead must provide a simple predicate calculus for expressing pre and postconditions for more complicated logic allows embedding capabilities in values but since the values are extracting a capability from a value requires a dynamic check type system eliminates the need for such checks for affine values stored in algebraic datatypes though it also allows dynamic management of affine values by storing them in reference cells notably alms can also express and adoption and focus experimental operating system is written in a highlevel systems programming language that extends spec et al has builtin support for channel contracts which are a form of session type providing static checking of communication protocols between device drivers and other services unlike more linear systems the design the need to allow for failure every protocol implicitly includes branches to close the channel at any point processes do not share memory but can allocate tracked objects on a common exchange heap only one process has access to an exchange heap object at a given time but a process may give up access and transmit the object over a channel to another process which then claims ownership of it library includes two different implementations of session types supporting different interfaces and the exchange heap concept is easily expressible as well future work and conclusion we already programming in alms but we are not done yet unit subsumption in § we found that adding capabilities to an existing interface often involves the old version of a function to ignore a new argument of type unit or construct a tuple containing unit for its result this is unnecessary while the client outside the abstraction barrier needs to see types that involve the affine capabilities the implementation has no use for them to eliminate much of this we can extend our subtyping relation to take advantage of the fact that unit is well a unit singleton v × singleton v × singleton v this is implementable via a type erasure technique such as intensional polymorphism crary et al not representing compiletime capabilities at run time has performance benefits as well type inference local type inference eliminates most explicit type applications but to annotate all function arguments is to fix this we are exploring possibilities for type inference while we that our limited subtyping should not full inference and milner alms has several idioms that rely on existential types we are exploring whether an extension for firstclass polymorphism such as hml would be suitable for alms alms is not finished but our prototype is at this point usable for it is based on a calculus whose type system we have proved sound while some parts of the type system are complex we have seen in practice that alms types are tractable and alms programs do not look very different from the functional programs to which we are it currently implements algebraic datatypes exceptions pattern matching concurrency and opaque signature the language is rich enough to express typestate a variety of static and dynamic locking protocols checked of functions to functions session types and more acknowledgments we wish to thank j daniel matthias felleisen and the anonymous for their helpful comments discussion and this research was supported in part by grant fa references a ahmed m and g morrisett a stepindexed model of state in icfp pages ­ acm a dual intuitionistic linear logic technical report u of edinburgh p s r s and extending a parallel nonstrict functional language with state in proc volume of lncs springer g m on intuitionistic linear logic phd thesis u of cambridge j checking interference with fractional permissions in sas volume of lncs springer k crary s weirich and g morrisett intensional polymorphism in semantics ­ l and r milner principal for functional programs in popl pages ­ acm r and m enforcing highlevel protocols in lowlevel software in pldi acm m and r adoption and focus practical linear types for imperative programming in pldi acm m m aiken c o g j r and s language support for fast and reliable communication in os in pages ­ acm s j v t and a session types for communication technical report tr u of glasgow jy girard linear logic theoretical computer science ­ d flexible types robust type inference for firstclass polymorphism in popl pages ­ acm x leroy d j d and j the objective caml system inria edition k j and s lightweight linear types in system f in pages ­ acm r milner m tofte r harper and d macqueen the definition of standard ml mit revised edition b c pierce types and programming languages mit r and m van clean language report version dept of software technology u of a c v and d dreyer modules in pages ­ acm m higher order subtyping phd thesis i e and g w cacm ­ j a and r stateful contracts for affine types in esop volume of lncs pages ­ springer e de r and d m uniqueness typing simplified in pages ­ springer p wadler is there a use for linear logic in pages ­ acm p wadler and s how to make adhoc polymorphism less ad hoc in popl pages ­ acm 