conference record of the fifth annual acm symposium on principles of programming complexity of expressions allowing concurrency w f case university w e university of w c university of o summary we study some consequences of the formal lan guage approach to modelling software system for the case of asynchronous concurrent sub systems we use the formal language opera tion to give an algebraic definition of seman tics for a simple structured concurrent program ming language and prove that the use of this opera tion is necessary having established this we investigate other types of behavioral ex which use the operation and show that the analysis problem for these expressions is either undecidable or the results provide some limitations for example on expression method of system behavior analysis our lower bound proofs involve the use of syn symbols which seem to be a formal analogue of introduction the and control structures express concurrent program behavior they implicitly contain the idea of interleaving or streams of operations from component processes this interleaving is also implicit in the path expression and and event expressions and of course the various petri net schemes this paper is concerned with algebraic expressions which explicitly use the operation p to express con we give an example of this use by pro a semantics for simple structured parallel programs we then study the recognition problem for languages defined by such expressions our conclusion is in brief that is complex this paper has two main sections the first part after preliminary definitions illustrates the use of in giving semantics for con current programs many authors of course have given such semantics among them are and and for example our approach differs from these authors by using algebraic expressions with explicit con we separate control from data in the manner of program so that a program ex defines a certain set of abstract tion sequences these sequences of operations are then interpreted over a state space the io behavior of such a program is given by choosing an interpretation and off pairs of states associated with the and ends of all le execution sequences thus obtaining a binary relation on the state space in contrast pratt views a program as being defined by such a relation we show that for expressing concurrency the execution sequence approach is necessary because the io behavior of the of two programs cannot be defined from the io behavior of the components using the department department of computer of computer g information science case university science university of department of computer g communication sciences university of ann standard relational operators our result uses a theorem of on rela tional which is itself a form of theorem page the second part of this paper deals with the complexity of the recognition problem for lan guages defined by expressions with concurrency defines event expressions which de note behavior of programs written in a software description language similarly and use expressions as definitions of desired program behavior scheme is intended for offline analysis of global system behavior while the path expressions are to be compiled into code which checks activity during execution in both cases however it is natural to ask whether or not a string of symbols is in the set denoted by the expression we prove that event expressions in their full generality can denote any recursively enumerable set and thus are not amenable to algorithmic analysis we then show that extensions of path expressions to the contextfree case standard path expressions denote regular sets will have to be defined with some care because there exist deterministic con languages whose is npcomplete our results use the technique of syn symbols introduced by in event expressions these symbols are a formal language analogue of we use them to force concurrent systems to simulate turing ma behavior the technique is of one used by to show an exponential space lower bound on the vector addition reachability problem and for the np result an extension of the methods used by to exhibit npcomplete languages there appear to be many different ways to use these symbols in such proofs let l and l be subsets of z then c l where the or can be null an early ref to this operation is and it is easy to show that regular sets are closed under and that the of a regular set and a cfl is a cfl the are not closed under theorem shows how bad things can get we also consider the unary operation on languages is the kleene closure of lt ng ln ln the regular sets are not closed under structured parallel programs we give an application of to program ming language semantics we consider a language for which expressions with form a concise way of defining meanings figure o is an example writer if then if result null begin then t write buffer end end writer read g process if then begin code to compute result end end read process fig o this code represents execution of with processing using a shared buffer with a semaphore to enforce mutual exclusion of reading and writing we are not concerned with efficiency or even correctness here however only with giving a meaning to the statements the atomic operations in this program are the assignments reads and writes the atomic tests are the conditions mentioned in the statements we assign to each atomic operation a unique symbol from an alphabet z and each test a symbol from an alphabet b these alphabets need not be finite the control structures sequencing repeat etc are then regarded as operators on sets of strings of symbols and so give rise to program expressions a program ex thus denotes a certain language set of strings of operation and test symbols by inter each symbol and hence string as a real operator or test we then get the meaning of the program this is of course the method of program for a class of programs involving con formally the class of program expressions over z and b is given by a recursive definition i each element of z is a program expression ii if t and r are program expressions and b s b then the following are program expressions tl if b then n if b then t else while b do t t tl r to illustrate let us give the tree structure of our example program regarded as a program expres sion fig this tree the role of control structures as operators on the results of subtrees the first stage in computing the meaning of a program expression is to define its associated language the second is to interpret this lan guage over a data space thus of an expression t is defined the language following the recursive definition i of w n ii if lt lm are defined d b s b then lwt b tl else n lt r lt a lit res a i s em o ii i s em sem i code fig comments is a single symbol denoting the negation of the predicate b the use in the definition of reflects the to do the null operation when b is false we do not employ infinite sequences of operations thus is not the same as or true for the second stage we define the inputoutput relations denoted by a program expression given a set d of states for each operation we are o relation ro d x d and for each b c b a subset sb of d then for each x s z ub we define a relation ix io for u s z ib sb e b ix o otherwise where o is relational composition and is restriction of a relation to a set finally im u lt so that ir is a binary relation on d the io relation of n pratt among this rela tion as the definition of a program he can then build up compound programs using relational opera for example relational composition for se and transitive closure for in definite iteration intuitively however there is no fixed combination of standard relational opera union composition projection etc which corresponds to our task in the next section is to prove this of let d be a set and rl rm given relations on d the arity of these can be arbitrary a relation r is definable from r rm if it can be written as a relational expression over ri rm using the following operations union complement projection expansion permutation where the last three operators are defined let rc dn then d d il dn di di as follows d dn ­ dn ul d un where u is a permutation of n theorem there exist two programs nl and r and an interpretation i such that is not definable from inl it and the identity rela tion proof let z the pro grams lt ab and n cd the interpretation i is defined over d we set ia ib ic id clearly and it is easy to check that cd is the constant function k our problem is to show that k is not de from fl and id the identity relation on from logic let rm be given relations on d and let rl rm be the set of of d leaving these relations invariant ie fd d is in r iff for each ri dn shows that a relation r is definable from ri rm if and only if each f in ir rj leaves r invariant in fact we need only the easy direction of his result there are only two of and both leave and id but the function f o and does not leave k invariant and so k is not definable this proves our theorem lower bound results we turn to the analysis of expressions ing theorem shows that the class of event expressions denotes the full of re sets event expressions introduced in and there called message transfer expressions were in as a behavioral characterization of the sys tem description language that language was able to define types of behavior theorem however shows that event expressions are more general theorem asserts the existence of contextfree languages l and l such that l a l is npcomplete thus unless there is no polynomial time algorithm for possible strings from general this means that one should be careful when extending path expression definitions to cases where component processes exhibit recursive or behaviors event expressions event expressions denote formal languages in the manner of regular expressions except that an extra denotational process some strings from the language the idea is to use special matching of as synchronization symbols to control concurrent combinations execution sequences not having a specified pattern of synchronization symbols are from the language h easy fact about is given by lemma let ui e z and wi c s if the string to to u u un then each wi let a and s be two finite disjoint alpha proof observe that the grammar cannot re terminal and synchronization alphabets move symbols in z thus sequences must be respectively we assume s a where a is a finite set and la c a the set of in of symbols of event in a then the class expressions is given by independently applied to each wi theorem for any re subset l of x we can find event expression e such that an proof we show that an ee can be constructed in such a z way that the activity simulates the a if el e then tion of a automaton we the automaton with output instructions and let the terminal symbols of e el e e el a e e are all members of language definition from an ee is a process the first is similar to that for regular expressions the second is the intersection pro mentioned above we define an language lo lo e lo el e u a e a the ee correspond to the output symbols of the cm the only trace of the computation is then the successive out put symbols of the machine theorem states that for any re set l there is a cm m such that the out put language of m is just l this gives us the result the main difficulty with the proof is ensuring that every sequence which occurs represents a computation of the machine this is one of the reasons for lemma output symbols do not so the can can be to the wi by itself however lemma will not suffice because each wi will be composed of a string over s essentially where each yj is an of the form yl y p configuration of the cm followed by the inverse of the next configuration of these ys is to represent for the second phase define g with productions the tation of the cm between output steps in order to con within each string yl we intro then le w c z i y c let z ab a al is le where e is the w g then the lan expression aa bb a t in this example the operation intro and g symbols in equal numbers the lan auxiliary symbols and insert ing them into the expression in such a way that if each a then the whole string yl will col to a and correctly represent a computation in doing so the two counters of our machine contain a string of als and a string of respectively thus a tion has the form guage nn is a subset of al a into aa b and in effect all similarly strings the except language those of the form is generated by the expression bn where qi is a state of the machine we make up an expres sion for each qi so that if the symbols are re as terminal for the moment the associated language would be by aa a notice that the b and y symbols control the match where m and n are the new contents of the a and b ing of bs while the a and symbols control the of the machine and q is the correct j new state this expression can easily be constructed using the idea in the example preceding lemma we then union together expressions for each qi and star the result thus obtaining our expression for the whole language we now give the construction process in some detail first we describe give the associated and finally machines then show language equality machines the cm is a finite set m of instructions having one of the following forms qi if to qj else go to qk qi write go to q j qi go to qj qi halt one instruction say qo is designated as the start instruction the machine may start with p r for any natural numbers p and r a configuration of a cm is just a triple where k and l are natural numbers and qi is a state output is ignored here in the usual way we define a computation sequence of m to be a sequence of configurations each correctly follow ing from its predecessor according to machine in starting with for some p and r and ending with some where q is a halt instruction the output string wz is the string of symbols obtained by left to right all symbols produced during the sequence and then a computation sequence of m for technical reasons we will modify ms finite control as follows the state set is partitioned into two disjoint subsets and and transitions always go from odd to even or from even to odd states my cm can be modified this way without changing the language generated construction we let of an ee from a cm z be the output alphabet of m then z is also the terminal alphabet of em we now give the auxiliary alphabet s the positive part a of s has several components g odd q j q c p the state set of m then we have a and s au where consists of all of symbols in a we write the inverse of as corresponding to each state of m we give an ee our understanding is that any letter auxiliary symbols in the ee are taken from or depending on whether the state is in or we will thus drop subscripts on case qi j e i o if by qj aa a a to understand this expression regard all symbols except the letters as terminal symbols the introduces and in equal numbers and and in equal numbers these symbols to the left and their in thus a correspondence between as and ts and between bs and ts after symbols we are left with strings of the form min which represent successive now similarly we have state of the cm case qi ca ca go to qj configurations an expression of the cm for each e i ai ad a a case qi go to qj ei ai u ad a case qi if c a go to qj else a qk ei a u a a ea similar expressions are constructed tions involving for the define start halt where h is the halt state for the program m define em start o ue ih halt we would like to show lem lm the part lem of this result is showing that lm in the expression em there are many ways to strings possibilities for and therefore many we must show that every correct computation control the order to terminals corresponds to a of the machine the brackets of as do the re on m and the fact that no can cross terminal symbols the function of the brackets is given pre by the next lemma lemma given a string w uz z z of the form where o and t are in z zi s au all bracket free if w to then each zi to i the proof is by induction on p and is omitted assertion lem lm we will show only that lem explained above consider a string as in which to terminals from the form of em this string will have an internal structure xx x p where x and x are strings introduced by expres p sions eo and e representing p two consecutive statements and x x p come from ex representing statements x has the form each xi has the form and x has the form p k where ut e e and e a ik c a a we can write the string x rx xo x kt in the form by lemma this string must to ut and so by lemma each zi must but zi x il which thus must for each i and so tions can be simulated for more than one step as an example suppose that xi is generated by an expression representing instruction qi ca ca go to q and x is generated by an expression representing qk ca cal go to q then ignoring the symbols x t by ad x tb s the string z b qj aa t o must hence q qk sn j and t m also there must be exactly s symbols in zi t symbols s symbols and t symbols and symbols in zi must have been inserted in the ex for qi and any and f symbols in zi by the expression for q since qi and qj have differ j the a and f introduced for qi must thus the a and symbols in the left part of xi and the and symbols introduced for qj must they and symbols in the right half of x tl n s and the computation is advanced two steps by induction the strings xl x thus represent p a correct computation of the machine between two output steps and again inductively the whole string represents a correct computation of the machine the example just above represents a cal inductive step of the proof theorem follows because the trace left upon making all is just the sequence of output symbols produced by the machine we remark that without the opera tion theorem does not hold only regular sets can be generated the thus introduces all the counting ability into our expressions the complexity our final of pure theorem shows that even when re to the class of contextfree languages is a complex operation we find l and l such that l a l is npcomplete this means that a general efficient algorithm which message sequences from parallel sources with contextfree behavior will probably not exist unless p np it is possible however to design such an algo rithm in case the message sources give finite state behavior thus an interleaved sequence of messages coming from sources whose behavior a regular path expression will be efficiently because regular sets are closed under the intended use of path expressions does not even raise this issue each process simply checks whether the subsequence of the age stream consisting only of the letters mentioned in its path expression in fact is language denoted by the expression our result implies only that in extending analysis to sys with behavior some care should be taken with semantics of the expressions a language l z is in np iff there is a non deterministic tm accepting l within pn time where p is a polynomial l is npcomplete iff l e np and for each l e np l l ie there is a computable function z such that for all x x c l s l theorem there exist deterministic contextfree languages l and l such that l a l is npcomplete proof we show that for all l c np exist l and l depending on l such that a l by choosing l to be a known npcomplete language we get a specific l al which is npcomplete note trivially l a l e np our proof is another turing machine simulation argument let l e np and let m be a turing machine accepting l within pn time we may assume that m has a single tape and that the input head of m has a head motion consisting of for example successive across the entire tape a configuration of m is a string in where q s the state set and z is the tape alphabet of m we will take z for convenience in the usual way if x and x are configurations of m we write x x to indicate that x follows from x by means of program define the following languages k i xx where z r is the reversal of z and is a new symbol l where gl is a string homomorphism that each o by and each by leaving symbols unchanged replaces any other k i z e l gk where g is a string homomorphism replacing o by o and by ll and l are deterministic we claim that l a l is the required language to show that this is the case we introduce some temporary notation let q qo be the state set of m for a string xi e de fine to be the image of xi given by co c o let w be a string in kl and let r r v rr be a string in k we say that v is the complement of w just in case r zl cx r cx notice that if w s k has a complement in k then w represents a complete computational history of m starting from the configuration xl because x xi x xi etc our idea is to together with gv to produce a very string and to use this form as the definition of the reducing function which shows that ll a l the brackets and are used to show that if x c l then the only way to x will be to have xe a gv where w and v are and w represents an accepting computation of x it is useful to regard all configurations as having the same length so if x e x x n let ix be x followed by pn n all tions last for pn steps and an accepting con consists of tape entirely zero and head at the end of the tape in state q f let ht be the position of the head at step t of the tion by our assumption h can be calculated very easily set x pn ix yt pn gl qf where yt qt t even qt qo qo t odd thus is an encoding of the initial followed by a large number of strings of the form ol all of which have the same length and then the final string which is the complement of the final configuration observe that if is a of strings from l and l then each portion of between any must consist of a contribution from l with a complementary contribution from because left brackets occur in l right brackets occur in l before after each o or the position of the and in guarantee that the first l configuration matches the second l and so we thus have the fact that x s a gv and v is the complement of w but by our remarks above and the fact that w starts with an initial configuration and ends with a final one this means that w represents an accepting computation on x hence x e lx c l a l proving theorem conclusion the results above represent a small into possible methods for expressing concurrent be by appropriately restricting synchronization patterns it seems that many types of synchronized concurrent behavior are definable various forms of languages can be des by introducing symbols representing the opera tions of adding and from a given place and that in any string the number of add symbols up to any point the number of symbols we have not dealt with the class of expressions formed by adding and to ordinary regular increase expressions denotational adding power just does not although the generalized membership problem given e and x is x e le becomes nphard this can be proved by a reduction from the exact cover problem finally we have no results on the possible complexity of the languages formed from regular languages by closing under the operation references f data structures tion and realization phd thesis of r a and n the specifications of process synchronization by path expressions lecture notes in computer science vol springerverlag e f a relational model for large shared data cacm pp s mathematical theory of contextfree languages hill n york s and e h mappings of languages by m pp s contextfree language siam j pp j j and b process structuring computing l pp r j reduction a method of proving properties of parallel cacm i i pp r j the reachability problem requires exponential space tech report department of science yale to appear in theoretical computer science s consistent complete tive system for the verification of parallel programs proceedings of th annual acm symp on theory of ming pp may j petri nets computing pp pratt v r consideration on proceedings of the th on foundations of pp w e and systems phd thesis stanford university of w e system modelling and analysis tech report department of computer and communication sciences university of july j r mathematical logic addisonwesley reading mass 