backpack haskell with interfaces scott dreyer simon peyton jones microsoft research simon abstract module systems like that of haskell permit only a weak form of modularity in which module implementations depend directly on other implementations and must be processed in dependency order module systems like that of ml on the other hand permit a stronger form of modularity in which explicit interfaces express assumptions about dependencies and each module can be and about independently in this paper we present backpack a new language for building packages on top of a weak module system like haskells the design of backpack is inspired by the module calculus of and dreyer but differs significantly in detail like backpack supports explicit interfaces and recursive linking unlike backpack supports a more flexible applicative semantics of instantiation moreover its design is motivated less by foundational concerns and more by the practical concern of integration into haskell which has led us to both the syntax and semantics of raw expressive power the semantics of backpack packages is defined by elaboration to sets of haskell modules and binary interface files thus showing how backpack maintains with haskell while extending it with separate typechecking although backpack is toward integration into haskell its design and semantics are largely with respect to the details of the underlying core language categories and subject descriptors d programming languages formal definitions and theory d programming languages language constructs and abstract data types modules f logics and meanings of programs studies of program structure keywords type systems mixin modules haskell modules applicative instantiation recursive modules separate modular development packages module systems introduction suppose an author a wants to write test and a software component or package p that needs to call a generator but a wants each c to be able to supply his or her own generator in a typed language the author a must define the interface to the generator permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm typecheck p with respect to the interface and p the client c then links p with a particular generator that matches the interface we refer to this style of development as separate modular development as distinct from the style of incremental modular development in which a package can only be when the implementations of its dependencies are available one of the most approaches to is that taken by the ml module system and its many variants ml provides functors which enable a module m to be parameterized over the implementations of its dependencies the dependencies can then be instantiated by functor application in multiple different ways even within a single program an alternative approach is to use mixin modules instead of relying on mixin modules support by combining within their both defined and undefined components the latter specified via interfaces unlike functors mixin modules support recursive linking and since linking is implicitly mixins also avoid the propagation of coherence or sharing constraints so common with functor programming moreover recent work by and dreyer on the type system has demonstrated that mixin modules have the to the functionality of ml modules however despite their advantages mixin modules have yet to be adopted by any functional language in the case of the ml languages this is ml already has a powerful module system and the extra benefit by mixins is not worth the replacement cost what about haskell haskells existing module system was designed as a weak management system without a proper notion of interface section and hence supports only not tools like the package management system pick up the enabling users to dependencies in order to work around the lack of interfaces but the haskell community that this is a solution and is ways to support properly in short haskell is a prime example of a language that is for extension with interfaces and mixins the is that the foundational accounts of mixin modules that have appeared in the literature employ a variety of complex and type systems and it is not at all clear how to convert any of them into a practical design that could be incorporated into a language like haskell with this in mind we make the following contributions · we present backpack a new language for building packages on top of an existing weak module system like haskells section like backpack supports interfaces recursive linking abstract data types and we are not counting scala it supports mixin composition but in a way that is to its objectoriented mechanisms package names p module path names p package r d package definitions d package p t where b bindings b p m p s p p include p t r t p renaming r p p module expressions m signature expressions s figure backpack syntax · unlike backpack supports a more flexible applicative rather than generative semantics of instantiation thereby extending mixin modules into new section it would be easy to support generativity as well · unlike other strong module systems backpack expressive power to simplicity and from the core language and its type system the main technical device that supports this is the central notion of module identity section which we can treat largely independently from the type system of the core language the type system for backpack is much simpler than that of · we give a formal description sections ­ of how to elaborate a backpack package into a set of ordinary haskell modules and module types the latter corresponding to existing notion of binary interface file if the package is complete ie fully implemented it can be compiled and executed but regardless the haskell modules output by elaboration can be separately from their missing dependencies · we prove soundness of elaboration which guarantees that a complete package will elaborate to a welltyped set of haskell modules section even stating soundness required us to define a formal semantics for separate typechecking of recursive haskell modules which did not exist previously finally we conclude the paper in sections and with a detailed discussion of related and future work for space reasons we leave a number of formal details to our technical appendix available at a backpack figure gives the syntax of backpack a package definition d gives a package name p to a a sequence of bindings b the simplest form of binding is a concrete module binding of the form p m which binds the module name p to the implementation m for example package ab where a x true b import a y not x the code in square brackets represents module implementations whose syntax is just that of a haskell module details in the technical appendix appendix § indeed in a practical implementation of backpack the term m might be realized as the name of a file containing the modules code however note that the module lacks a header module m where because the modules name is given by the backpack description package ab binds two modules named a and b the first module bound to a nothing and defines a core value x and the second module bound to b the first module and makes use of that x in its definition of y the type of this package we still provide syntax for optional export lists of core language entities only the module name expresses that it contains a module a which defines x bool and a module b which defines y bool we will more precisely discuss types at the package and module levels in section the module bindings in a package are explicitly each module can refer only to the modules bound earlier in the sequence in fact the bindings should be interpreted as iteratively building up a local module context that tracks the name and type of each module encountered for example if the order of the two bindings were then this package would to be welltyped as the module reference a would no longer make sense module bindings do not rather if the same module name is bound twice the two bindings are linked see section top level and dependencies a package consists of an ordered list of package definitions each package in a only those packages whose definitions occur earlier in the sequence to make use of those earlier packages ie to depend on them a package includes them using the include binding form thus package where c x false include ab import qualified a d import qualified c z ax cx one should think of an include construct as up a package and all of its contents into the current in this case the modules a and b are inserted into the package as if they were bound between c and d consequently the module bound to d can import both a and c the type of says that it provides four modules c which provides x bool d which provides z bool and the two modules a and b from package ab even though they were defined there and merely included here the modules exposed by a package can be controlled with syntax that that of the module level this feature is discussed as a special case of in section in this paper we will treat the example package definitions as the bindings in a single package at this point that top level includes the definition for ab followed by abstraction via interfaces up to this point the package system appears only to support since each module can only be checked after those that it depends on for example could only be developed and checked after the package ab had already been developed and checked otherwise we would not be able to make sense of the import declaration import qualified a and the subsequent usage of ax as a bool to support as well backpack packages may additionally contain abstract module bindings or holes to specify a hole a provides a set of declarations called a signature s and binds a module name p to it by writing p s one should think of holes as obligations to eventually provide implementing modules a package is not complete until all such obligations are met concrete modules on the other hand are simply those bound to actual implementations as in all previous examples this combination of abstract and concrete components reflects the basis of our package system as our first example we simulate how the package might have been developed by specifying holes for the other components a and b package where a x bool b y bool c as before d as before by out the other components the of can typecheck her code in c and d entirely separately from the who provides a and b in contrast in the existing package system developers cannot typecheck their package code without first choosing particular version instances of their dependencies effectively they test the of their code with respect to individual configurations of dependencies which may or may not be the ones their users have manually writing the holes for components as above involves too much duplication instead a can define a package full of holes that the interface of an entire component a client includes that package of holes and thus them into her own package without writing all those signatures by hand the following two packages achieve the same net result and have the same type as but without signatures in the client package package where a x bool b y bool package where include c as before d as before holes are included in exactly the same manner as concrete modules and they retain their status as holes after inclusion under the interpretation of holes as obligations inclusion propagates the obligations into the including package in these two examples we have named the packages and which might suggest multiple versions of a single package eg in however while they may that informal intuition in the present work we focus on modularity of packages leaving a semantic account of for future work linking and signature matching so far all package examples have contained bindings with distinct names what has appeared to be sequencing of bindings is actually a special case of a more general linking mechanism linking two mixin modules with strictly distinct names merely them whenever two bindings share the same name however the modules to which they are bound must themselves link together this gives rise to three cases and first when linking two holes together we merge their two interfaces into one this effectively joins together all the core language declarations from their respective signatures the resulting hole provides exactly the entities that both original holes provided package where data list a import package where data bool include import import the package above declares its own hole for and also includes the hole for from before the binding for is checked the previous bindings of must have linked together this module can see both list and bool since they are both in the interface of the linked hole whereas the module could only see the list datatype in the order of the first two bindings of has no effect here this example another aspect of programming with packages each package has the option of writing precise interfaces for the other packages ie modules it depends on specifically only needs the list datatype from the standard module rather than the entire modules other entities this results in a stronger type for since the assumptions it makes about the module are more precise and focused not all interface merges are valid for example if had also declared a list datatype but of a different kind from that in eg data list a b then the merge would be invalid and the package would be illtyped second when linking two module implementations together it intuitively makes no sense to link together two different implementations since they define different code and different types rather than all as for instance does we instead that linking only succeed if the two implementations are the same in which case the is a to test this we require equivalence of their module identities about which see sections and consider the following classic dependency package top where top package left where include top left package right where include top right package bottom where include left include right bottom the bottom package of the links together the packages left and right each of which provides a module named top that it from the top package the linking resulting from the in bottom is welltyped because left and right provide the same module top from package top third when linking a module with a hole the modules type must be a subtype of the holes and we say that the module matches or implements that hole this form of linking most closely the traditional concept of linking or of functor application it also corresponds to how structures match signatures in ml roughly a module implements a hole if it defines all the entities declared in that hole and with the exact same specifications the package above has a hole for the module as this package is not yet complete it can be but not yet compiled and executed supporting separate compilation would require sweeping changes to existing infrastructure we therefore link with a particular implementation of its hole so that it may now be compiled and used package where include data list a data bool null xs the implementation of provides the two entities declared in the hole included from and an additional third entity the value null this implementation matches the interface of the hole so the is welltyped for simplicity our definition of when a module matches a hole is based on width rather than depth subtyping in other words a module may provide more entities than specified by the hole it is but the types of any values it provides must be the same as the types declared for those values in the holes signature in particular the match will be invalid if the implemented types are more general than the declared types for example a polymorphic package where data list a nil cons a list a package where include import array data arr i e something list arr i e package structures where include set import data s graph import import array data g tree import import graph data t package where include import qualified as p array data arr i e something package where include import array data arr i e something cons nil package graph where include include structures graph array package graph where include include structures graph array package where include graph ga include graph gb import qualified ga client import qualified gb export main main figure running example data structures library and client identity function of type forall a a a will not match a hole that declares it as having type int int instantiation and reuse developers can reuse a packages concrete modules in different ways by including the package multiple times and linking it with distinct implementations for its holes we call each such an instantiation of the package furthermore in backpack packages can be instantiated multiple times and those distinct instantiations can even in the same linked result in contrast both and ghc currently prevent users from ever having two instantiations of a single package in the same program figure provides an example of multiple instantiations in the package but this example a features of backpack we must first and renaming in our examples so far we have omitted entirely but actually according to figure all package definitions and should contain a spec to infer a spec where one is omitted one can simply list all module paths provided by the corresponding package the syntax used in our examples can thus be translated into our formal language with a straightforward typedirected rewriting moreover the syntax for package inclusion given in figure requires that all additionally contain a renaming when we omit renaming it means that one should use the empty renaming the two packages and provide two distinct implementations of the array module described by the hole specification in the earlier package the next two packages the graph implementation from structures and implement its array hole with the respective array implementations since structures also defines set and tree these modules would be included along with and array and would thus the of and instead these packages the structures package upon inclusion so that only the desired modules and array are added to and this closely the import lists of haskell modules which may select specific entities to be imported similarly implementation details of a package definition can be hidden rather than provided to the definition to expose only certain module names this closely the export lists of haskell modules by their definitions to expose only and graph both packages and hide the internal array modules used to implement their graph modules at this point and provide distinct instantiations of the graph module from structures distinct in the sense that they do not have the same module identity the identity of a crucial notion in semantics see section essentially encodes a dependency graph of the modules source code since the graph modules in and import two different module sources for the array from and the other from do not share the same dependency graph and hence have distinct identities thus if the final package were to include both and backpack would that was trying to merge two distinct implementations with the same name to avoid this error the of and employ renaming clauses that rename graph to ga and gb respectively so that the two graph implementations do not one may whether it is necessary to track dependency information in module identities why not just generate fresh module identities to represent each instantiation of a package to see the motivation for tracking more precise dependency information consider the example in figure both the and packages separately instantiate the graph module from structures with the same array implementation from both instantiations refer to the same identity for array backpack thus treats the two resulting graph modules and their g types as one and the same which means the code in is welltyped in other words the identity of graph inside is equivalent to that of graph inside and thus the g types mentioned in both packages are compatible as this example indicates our treatment of identity instantiation sharing behavior we call this an applicative semantics of identity instantiation as opposed to a potential generative semantics in which the two when instantiated with the same produce distinct identities as is well known in the ml modules literature enables significantly more flexibility regarding when module instantiation must occur in the hierarchy of dependencies in the previous example the authors of and were free to instantiate graph inside their own packages under a generative semantics on the other hand in order to get the same graph instantiation in both packages it would need to be instantiated in an earlier package like from figure and then included in both and hence the code as written in figure would under a generative semantics produce two distinct graph identities and g types as et al have noted applicative semantics is generally safe only when used in conjunction with purely functional modules it is thus suited to haskell which computational effects package left where include structures include left import graph x g package right where include include structures right import graph f g g package where include include bot import left import right f x figure example of aliases one wants to link two holes whose names differ the binding form p p in figure allows the programmer to add such aliases which may be viewed as sharing constraints for example package share where include foo a x include foo b y xy here a from foo depends on hole x and b from foo on hole y and we want to require the two holes to be ultimately instantiated by the same module the binding x y expresses this constraint recursive modules by using holes as forward declarations of implementations packages can define recursive modules ie modules that import themselves the haskell language report allows recursive modules but it leaves them almost entirely unspecified letting haskell implementations decide how to handle them our approach to handling recursive modules follows that of the example below defines two modules a and b which import each other by the parts of b that a depends on the first implementation makes it knows the names and types of entities it from naturally the second implementation makes sense after that this definition is analogous to how these modules would be defined in ghc package where b sb a import b b import a normal mixin linking the recursive ensuring that the import b actually to the b implementation in the end ghc allows recursive modules only within a single package backpack on the other hand allows more flexible recursion although packages themselves are not defined recursively they may be recursively linked consider the following package where a sa b sb package where include a import b package where include b import a package where include include in ghc instead of explicit bindings to a signature and two modules there would be the two module source files and an additional file for b that looks exactly like sb moreover the import b within the a module would include a source that tells the compiler to import the file instead of the full module at the level of packages these definitions do not involve any recursive inclusion which is good because that would be illegal rather they form a dependency like the earlier packages top left right and bottom there is no recursion within the definitions of and either the recursion instead occurs implicitly as a result of the mixin linking of modules a and b in the package separately recursive units may be defined in in roughly the same way finally we note that semantics presented in the next section explicitly addresses one of the key blocks in supporting recursive linking in the presence of abstract data types namely the socalled double problem in the context of the above example the problem is that in the specification sa of the hole a may specify an abstract type t which sb then depends on in the types of its entities subsequently in when the implementation of a b it will want to know that the type t that it defines is the same as the one mentioned in sb or else it will from double two distinct names for the same underlying type avoiding double is known to be challenging but crucial for enabling common patterns of recursive module programming semantics avoids double completely the semantics of backpack the main toplevel judgment defining the semantics of backpack is d given a package definition d along with a package environment describing the types and of other packages on which d depends this judgment d a package type and also d into a parameterized directory expression which is essentially a set of welltyped haskell module files the above judgment is implemented by a algorithm the first pass called a package shape for d which effectively explains the structure of the package ie the modules contained in d the names of all the entities defined in those modules and how they all depend on one another the second pass called typing the structural information in with additional information about the structure of d in particular it in the types of entities forming a package type and checking that d is wellformed at our goal in the present section is to explain in detail this typechecking algorithm as well as the elaboration of backpack into haskell central to both passes of backpack typechecking is a notion of module identity using the package and its dependencies from figure as a running example we will the role and structure of module identities and then in subsequent explain the implementation of typing and elaboration full details are given in appendix § module identities figure shows the shapes and types of and its dependencies we proceed by figure in a lefttoright fashion the first column of figure contains the first key component of package types a mapping from modules logical names p ie their names at the level of backpack to their physical identities ie the names of the haskell modules to which they elaborate the reason for distinguishing between logical names and physical identities is simple due to aliasing section there may be the reason for splitting typechecking into two passes has to do with the double problem as discussed in section see section for further discussion as well as a detailed explanation of how our solution to double compares with identity variables identity constructors identities identity substitutions k figure module identities multiple logical names for the same physical module for further technical for the distinction see the discussion in section in order to the particular logical mappings in figure let us first explore what physical identities are which means how module names work in haskell module names in haskell modules in haskell have fixed names which we call physical because they are globally unique in a program and module definitions may then depend on one another by these physical names modules serve two related roles as points of origin for entities and as syntactic concerning a module may define new entities such as values or abstract data types concerning a module may export a set of entities some of which it has defined itself and others of which it has imported from other modules for example a module foo may define a data type named t a subsequent module bar may then import and it as to ensure that type identity is tracked properly the haskell type system models each entity semantically as a pair t of its name t and its provenance ie the module that originally defined it in this example foo thus and will be viewed as equal by haskell since they are both just different names for the same semantic entity to ensure compatibility with haskell our semantics for backpack inherits haskells use of physical names to identify abstract types however haskells flat physical module is not expressive enough to support holes applicative module instantiation and recursive linking to account for these features we the language of physical names with a bit more interesting structure figure this language we call module identities variable and applicative identities physical module identities are either variables which are used to represent holes applications of identity constructors k which are used to model dependency of modules on one another as needed to implement applicative instantiation or recursive module identities defined via we start by the first two each explicit module expression m that occurs in a package definition corresponds statically to a globally unique identity constructor k that encodes it for example if a single module source m appears on the righthand side of three distinct module bindings in a package p then the three distinct identity constructors of those modules are roughly pm pm and pm in the absence of recursive modules each module identity is then a finite tree a variable or a constructor k applied to zero or more subterms the identity of a module is the constructor k that encodes its source m applied to the n identities to which m s n import statements resolved in order for instance in the very first example from section ab the identities of a and b are ka and kb ka respectively where ka encodes the first module expression and kb the second in a package with holes each hole gets a fresh variable within the package definition as its to make use of these physical names in our elaboration we embed them into the space of haskells physical names see section we write simply pm the integer part of the identity constructor when only one instance of m exists in the definition of package p identity in the identities of the four modules are in order a b kc and kd a kc consider now the module identities in the graph instantiations in as shown in figure in the definition of structures assume that the variables for and array are p and a respectively and that is the module source that graph is bound to then the identity of graph is g p a similarly the identities of the two array implementations in figure are aa p and ab p the package is more interesting because it links the packages and structures together with the implementation of array from instantiating the hole array from structures this linking is reflected in the identity of the graph module in whereas in structures it was g p a in it is ga p aa similarly the identity of graph in is gb p ab thus linking consists of substituting the variable identity of a hole by the concrete identity of the module that hole makes use of both of these graph modules under the aliases ga and gb respectively consequently in the client module and will be correctly viewed as distinct types since they in modules with distinct identities as illustrates module identities effectively encode dependency graphs the primary motivation for encoding this information in identities is our for an applicative semantics of instantiation as needed for instance in the example of figure in that example both the packages and link with structures the client package subsequently to use both the left module from and the right module from and depends on the fact that both modules operate over the same type this fact will be checked when the packages and are both included in the same of and the semantics of mixin linking will that their graph modules have the same identity thanks to the dependency tracking in our module identities we know that the graph module has identity ga in both packages recursive module identities in the presence of recursive modules module identities are no longer simple finite trees consider again the example from the end of section although this example does not concern our current focus the careful treatment of recursive module identities explanation suppose that a and b are the identities of a and b and that ma and mb are those modules defining module expressions respectively because ma b and mb a the two identities should satisfy the recursive equations a b b a these identity equations have no solution in the domain of finite trees but they do in the domain of regular infinite trees which we denote finitely as a a b b the semantics of backpack relies on the ability to perform both unification and equivalence testing on identities in the presence of recursive identities however simple unification and syntactic equivalence of identities no longer suffices since eg the identity b represents the exact same module as a in a syntactically distinct way fortunately we can use wellknown unification algorithm for regular trees instead structures logical mapping p p array a p array a set s graph g tree t p array aa p array ab p graph ga p graph gb p ga ga gb gb client c physical shapes p p a p a s s s s g g gg t t t t p aa p ab p aa ga g p ab gb g gb g p aa ab ga g gb g gb g c main c main physical types p p a p a s data s s s g data g gg t data t t t p aa p ab p aa ga data g p ab gb data g gb g p aa ab ga data g gb data g c main c main aa ab p p p s p g p a p cons pl cons cons ga gb p aa p ab t p g c ga gb p cons p pl data nil cons a a cons a a aa as arr something as something as something a as something a aa data arr i e as something i e as something aa aa aa aa something data arr i e something i e ab ab ab something ab ab something ab data arr i e something ab arr i e ab ab something figure example package types and shapes for the package and its dependencies constructing the mapping from logical names to physical identities is but one part of a larger task we call which the most and interesting part of type system the goal of is to compute the shape ie the structure of the package formally a package shape l has two parts the first is a physical shape context m which for each module in the package maps its physical identity to a polarity m and a module shape the polarity m specifies whether the module is implemented or a hole the module shape s defined entities the entities that the module itself we write a · on the metavariables of certain shape objects eg not to denote a metalevel operation but to these objects similarity to their corresponding type objects eg well as export which list the names and of the entities that exports note that these are not the same thing a module may import and entities that in ie whose are some other modules and it may also choose not to export all of the entities that it defines internally in our running example in figure the physical shape contexts computed for each package are shown in the second column the second part of the package shape is a logical shape context l p which for each module in the package maps its logical name p to its physical identity this is the mapping shown in the first column of figure which we have already discussed in detail in section in addition l also maps p to a shape which is required to be a subset of the principal shape of as recorded in the physical shape context this may seem if l maps p to and maps to say then why does l record another as well the reason is it is core level value names type names constructor names kind environments semantic types defined entity export module level types physical type logical type package level package types package environments objects defined entities module shapes physical shape logical shape package shapes x t k typ t typ data t k typ data t x typ m m l p l · p x t t k m l p l figure semantic objects for and typing convenient in some of the inference rules to be able to look up the shape of a module by merely the logical shape context l and it is possible for different logical module names to reflect different restricted of the same underlying module see the technical appendix for an example of this appendix § in our running example however the reader may ignore this and assume that all the s associated with in l and are equal which is why we omit them from the first column of figure figure defines the semantic objects for and typing and figure gives some of the key rules implementing rules the main judgment b takes as input the body of a package definition which is just a sequence of bindings b rule the shape of b by in lefttoright order to synthesize the shape of each individual binding b via the judgment b and then merge it with the shapes of the previous bindings via the judgment let us begin with the judgment that shapes an individual binding the rule should be the rule is simple as well choosing fresh identity variables to represent the holes in package p and applying the renaming r to p s shape note that it uses some simple auxiliary definitions rename for applying a renaming to the l part of a shape and shape for a package type to a shape by removing typing information moreover by the type of p we rename its variables to match the chosen the rule generates the appropriate globally unique identity to represent m and then calls out to a judgment for haskell modules c m appendix § which generates the shape of m assuming that is the modules identity as an example of this observe the shape generated for the client module c in in figure the shape provenance c to the main entity since it is defined in client while provenance ga to the g type since it was imported from ga and is only being by client the rule for hole declarations is a bit than the other rules perhaps surprisingly the generated shape declares not only a fresh identity variable for the hole itself but also a set of fresh identity variables one for each entity b p p p p c m p m p fresh c s p s p fresh p include p r shape b b b b b figure rules ignoring in the hole signature s the intermediate merely encodes these fresh identities as input to the signature judgment the reason for this is simply to flexibility there is no reason to demand a priori that the module that in the hole ie the module whose identity will end up getting substituted for must itself be responsible for defining all the entities specified in the hole need only be responsible for those entities which may very well have been defined in other modules the shape a in figure illustrates the output of on the array hole in package this shape specifies that aa is a module defining an entity called arr that as is a module defining an entity called something and that a is a module and as something together in its export spec of course when the hole is eventually filled eg in the package whose is discussed below it may indeed be the case that the same module identity is substituted for a aa and as ie that both defines and exports arr and something but does not require this returning now to the merging judgment that is invoked in the last premise of this merging judgment appendix § is where the real of particular this is where mixin linking is performed by unification of module identities if a module with logical name p is mapped by and to physical identities and respectively the merging judgment will unify and together moreover if and are specified by and as having different module shapes and respectively those shapes will be merged as well with the resulting shape containing all of the components specified in either and for any entities appearing in both and their will be unified to see a concrete instance of this consider the merging that occurs during the of the package in our running example in figure the package includes two packages defined earlier and structures as per rule each inclusion will generate fresh identity variables for the packages holes say p pl a aa as for structures and p pl for since both packages export the merging ment will unify p and p the physical identities associated with in the shapes of the two packages consequently the shape of p namely cons will be unified with the shape of p namely cons resulting in the unification of pl and pl as well similarly since both packages export array the merging ment will link the implementation of array in with the hole for array in structures by unifying a aa and as with aa as a result the occurrences of a aa and as in g and its shape get substituted with aa which explains why the shape of maps graph to ga merging will check that the implementation of array in actually provides all the entities required by the hole specification in structures ie that aa subsumes a which indeed it does typing in our running example thus far we have not yet performed any typechecking of code such as the code inside client module there is a good reason for this before we dont know whether types such as and imported by client are equal because we dont know what the identities of ga and gb are but after we have all the identity information we need to perform typechecking proper thus as seen in the toplevel package rule in figure the output of the passed as input to the typing judgment b typing in turn produces a package type which the package shape with ie typing information the final type returned for the package then just over the variable identities of the holes in so that they may be instantiated in different ways by subsequent package definitions the package types generated for the packages in our running example appear in the third column of figure formally the only difference between these package types and the package shapes in the second column of figure lies in the difference between their constituent module types and module shapes whereas the defined entities component of only names the entities defined by a module the defined entity component of additionally specifies their for example observe the module type to module aa in aa this type the shape in aa with additional information about the kind of arr and the type of something let us now explain the typing rules in figure for the moment we will ignore the parts of the rules concerning elaboration into haskell we will return to them in section the rules and implement typing of a sequence of bindings b the procedure is structurally very similar to the one used in the of b we process in lefttoright order each constituent binding b producing a type that we merge into the types of the previous bindings the key difference is that the partial merge operator does not perform any unification on module merely performs a mixin merge which checks that all specifications kinds or types assigned to any particular entity are equal for instance when typing the mixin merge will check that the type of something in the array implementation from is equal to the type of something in the array hole from structures and thus that the implementation satisfies the requirements of the hole the remaining rules concern the typing of individual bindings b the typing rules and are structurally very similar to the corresponding rules given in figure the key difference is that whereas and generate appropriate identities for their and instead look up the identities in the package shape as an example of this observe what happens when we type the array module in using rule the package shape we in the pass tells us that the physical module identity associated with the logical module name array is aa so we can go and assume aa is the identity of array when typing its b p p p p p c m p m p p c s defined p s p fresh p apply defined include p r apply b b defined b b b d b b fv package p where b figure typing and elaboration rules ignoring tion note that and call out to typing judgments for haskell modules and signatures c like the analogous judgments these are defined formally in the appendix appendix § like and the rule also to determine the identities of the in the package p being included the only difference is that an included package contains a whole of rather than only one so looking up their identities is a bit more involved it is performed by to a matching judgment similar to the one needed for signature matching in ml module systems this judgment looks up the instantiations of all the included holes by matching the type of the included package p after applying the renaming r against this produces a substitution with domain which then gets applied to to produce the type of the include binding for example when typing the package we know after that the identity of the array module is aa when we include structures the matching judgment will this information from and produce a substitution mapping structures a parameter to the actual array implementation aa backpack to haskell we our claim to haskell with through an elaboration of backpack our external language el into a model of ghc haskell our internal language il the el as we have module names module sources file expressions file types typed file expressions directory expressions f f identity translation figure il syntax and mention f instead of demonstrated so far extends across the package module and core levels while the il defines only module and core levels effectively the outer package level gets compiled away into modules in the il figure gives the syntax of the il for its semantics including the typing judgment see the technical appendix appendix § elaboration translates a backpack package into a parameterized directory expression which is a mapping from a set of module names f to typed file expressions parameterized over the identities of the packages holes we assume an embedding from module identities into il module names which respects the equivalence on module identities that the backpack type system relies on however for readability we will leave the embedding implicit in the remainder of this section as for the typed file expressions they can either be defined file expressions which provide both an implementation of a module along with its type or undefined file expressions which describe a hole with type thus all components of a are explicitlytyped this has the benefit that the modules in a can be in any order since all static information about them is specified in their explicit file types as a continuation of our running example figure the elaboration of the package except with the file types off for brevity first note that each module identity in the physical type m of hand corner of the table in figure corresponds to one of the haskell modules in the elaboration of the package and for each its type in m is modulo the embedding precisely the file type of that we have omitted from figure the concrete module identities in m map to defined file expressions while the identity variables p and pl representing holes map to undefined file expressions the elaboration of packages marked with text is almost entirely straightforward following the typing rules more interesting is the elaboration of haskell modules which is to in the second premise of rule and formalized in the appendix appendix § one might expect module elaboration to be the identity translation but in fact it is a bit more subtle than that consider the c entry in the directory corresponding to the client module as a concrete example the module header unlike the original el implementation of client which was anonymous its il version has a module header specifying c as its fixed physical name and main and as its exported entities more generally the exported entities should reflect those listed in the modules type the import statements our elaboration rewrites of logical names like ga into of physical module identities like ga since the physical identities are the actual names of haskell modules in the directory expression we must therefore take care to preserve the logical module names that the definitions in the modules body expect to be able to refer to for example the reference is seen to have provenance during backpack typechecking of client so in the il version of client we want to mean the same thing we achieve this by means of haskells import aliases which support renaming of imported module names eg the first import statement in c the p pl p pl aa ab ga gb c module aa where import qualified p as p data arr i e something arr i e module ab where import p as cons data arr i e something cons nil module ga g where import p as cons import aa as array arr something data g module gb g where import p as cons import ab as array arr something data g module c main where import qualified ga as ga g import qualified gb as gb g main figure elaboration of for readability the translation from identities to module names and the file type annotation on each module file have been omitted see figure for the latter physical name ga but gives it the logical name ga in the body thus ensuring that the reference still has the same meaning as it did during backpack typechecking the body thanks to the import aliasing we just described the entity definitions in the body of c can remain syntactically identical to those in the original client module of and exports all imported and exported entities are given as explicitly as the haskell module syntax allows even when the original el modules to make them explicit eg the original code for graph lists neither its nor its exports but its elaboration as ga and gb does the primary reason for this is that it enables us to prove a weakening property on il modules which is critical for the proof of soundness of elaboration if modules are not explicit about which entities they are and their module types will not be stable under weakening formalization of haskell modules and soundness we have proven the following key soundness theorem about the elaboration if a package definition d has type l and into a parameterized directory expression then every module in is welltyped in the il and the identities and types in directly match those of for example soundness means that the identities and el module types appearing in the type of in figure correspond precisely to the names and types of the il modules in figure as part of this effort our il a new formal model of the haskell module system this model follows the haskell language report as closely as possible in its definition of wellformed the processing of module dependencies through import statements and export lists unlike previous work on formalizing the haskell module system our model supports separately recursive modules furthermore we have developed some basic metatheory for the il eg substitution and weakening in order to prove soundness of elaboration a non trivial given that substitution can result in the merging of bindings full details of the il are given in the technical appendix appendix § we do not provide any kind of dynamic semantics in backpack and thus we cannot prove or even state any conventional type safety theorem instead the soundness of elaboration simply reduces the question of whether backpack is typesafe to the question of whether haskell is typesafe related work and technical discussion detailed comparison with ml modules provide a very expressive and convenient language for programming with abstract data types however due to the double problem section functors are incompatible with recursive linking there have therefore been several attempts to synthesize aspects of ml modules and mixin modules in a single system including and typed unit calculus and type system for recursive the most advanced system in this space is and which aims to be a highly expressive foundational calculus of mixin modules for an mllike core language design and semantics are inspired by those of but our design decisions driven by our goal of haskell with have led to considerable simplifications supports firstclass and higherorder units ie mixins whereas exist at the top level we believe units to be sufficient for practical programming and restricting them to top level the semantics of applicative identities also supports hierarchical mixin modules with deep linking but backpack restricts packages to be flat of modules deep linking lets express many different ml constructs eg nary signatures using just one form of linking since our focus is on rather than expressiveness we features like firstclass units and deep linking for simplicity of syntax and semantics optimizing instead for common usage patterns in particular our include construct is more straightforward to program with than binary construct and better with the feel of the haskell module language eg its import statements backpack also provides some features that lacks such as renaming and an applicative semantics of instantiation concerning the double problem solves it through the use of a algorithm for typechecking linked modules the first pass computes all information about type components in the modules and the second pass performs full typechecking in these two passes are defined using a single set of inference rules with the first pass defined by ignoring certain premises backpack the same idea in order to compute the physical module identities involved in a package before typechecking it however backpack distinguishes the two and completely separate judgments and rules although this leads to a of rules the rules themselves are we feel much easier to understand in particular the account of linking given by the sequencing rules and is considerably simpler than linking rule moreover backpack stages the pass over a whole package entirely before the typing pass leading to a conceptual split between the two phases of package typechecking than in where the two passes are interleaved a key reason we can get by with a simpler semantics of linking is that we are less than in a certain sense unlike we do not aim to completely the functionality of ml modules does and this means that its semantics must deal with nested uses of sealing ie the ability to define types that are transparent inside a module but opaque outside a defining feature of ml modules which the problem in contrast backpack does not attempt to support thus does not the the simple reason that haskell our target of elaboration cannot support it finally is defined by elaboration into an internal language which was designed specifically to capture all the necessary features of is an extension with linear kinds of an earlier il similarly specialized for recursive ml module systems called metatheory status as a foundational calculus rather than a practical language design in contrast to backpack whose il is a formalization of an existing implementation the ghc module system a major benefit of our approach is that the semantics via elaboration of a backpack package may be understood by haskell programmers essentially in terms of a of import and export lists in their haskell modules the elaboration in figure is a case in point logical module names vs physical module identities module identities which establish canonical physical names for modules as distinct from logical names serve two important roles in semantics they simplify and the elaboration into haskell modules and its soundness proof and they are the principal component of our solution for how to support applicative mixin linking concerning the first point the distinction between logical and physical names is a central technical element conceptually elaboration into our il in particular a key invariant of elaboration is that the physical part of a packages el type gives a precise description of the il modules that it to the logical part of its type is only relevant for management during typechecking concerning the second point the idea of distinguishing between logical and physical names is not new a number of prior for the definition of standard ml on a similar distinction the key advantage of this approach as opposed to more direct syntactic type systems for modules eg is that physical identities greatly simplify the treatment of type equality in the presence of aliasing no matter their logical names two types are equal iff they have the same physical identity this eliminates the need for mechanisms for handling type sharing like sums or singleton kinds see et al for further discussion moreover for recursive and mixin module extensions of ml the distinction has enabled clean solutions to the double problem as discussed above there is some recent work by im et al on solving double using only logical it does not account for separate typechecking of mutually recursive modules in general what distinguishes backpack from these prior systems is its support for both separate typechecking of recursive modules and an applicative semantics of instantiation as appropriate for a pure language like haskell to handle the combination we needed to the language of module identities with both and constructor applications and employ standard unification and algorithms that work for these recursive identities to see why consider the example from section in which the modules a and b in package have the recursive identities a and b defined on the subsequent page if one were to define another package in the same way the identities of a and b would be exactly the same in contrast were we to code up this example in each distinct package defined like would produce modules with fresh distinct identities as one would expect given generative semantics of instantiation nevertheless we observe that recursive identities do not the semantics much a to the scalability of the approach separate compilation for ml setting aside the lack of support for recursive linking ml functors are not by themselves really a practical mechanism for due to the of sharing constraints that are known to arise when programming in a fully style ie in which modules are parameterized explicitly via the functor mechanism over all their dependencies consequently a number of systems have been proposed for building a better framework on top of the existing ml module system before discussing these systems in more detail let us observe two important ways in which they all differ from backpack first unlike backpack the separate compilation systems for ml build improved support on top of the ml module system which offers instantiation reuse and at least some form of via functors in contrast backpack is built on top of haskell which lacks those features and thus the expressiveness it offers over the underlying language is in some sense more significant second we realize this not through functors but through mixins as a result backpack supports recursive linking and avoids the need for any separate notion of sharing constraints to address the lack of separate compilation in ml cardelli introduced a foundational calculus of however as a foundational calculus this framework lacks support for userdefined abstract data types as well as recursion at the module or core features that the complexity of module systems building on foundation et al designed a typed language of program fragments that lists of toplevel sml definitions eg modules into what they call units linking happens automatically by name when unit definitions are considered in the same in particular when multiple units in a have interface on some common name those dependencies unify automatically without extra annotations units therefore eliminate the need for sharing constraints on mixin modules they do not permit recursive linking in a different open modular programming the language of sewell et al and the alice ml language of et al support not only separate compilation but dynamic linking and in the case of of components all of which are beyond the scope of backpack while modules with new primitive operations as a mechanism for compilation units and linking alice ml defines components by reduction to a simpler construct of packages modules as firstclass core values linking in consists of nonrecursive chains of module definitions and whereas alice ml a more flexible and dynamic component manager approach based on java rather than neither nor alice ml supports recursive modules as part of the ocaml module system the compilation tool performs separate compilation on files that contain module components the tool treats the file system rather like a mixin each component ie a file can be defined as an implementation ie a ml file or a hole ie a file and components can be recursively linked like but unlike backpack though these mixins cannot be instantiated and reused a file cannot be linked with multiple implementations of its dependencies in essence implements something similar to the target il of elaboration for ocaml obviously and extended with full separate compilation rather than just separate typechecking it does not however provide a language for building and linking components as backpack does mixin modules for oo languages our focus has been on in the setting of a typed functional language in the objectoriented community mixins have already seen significant both scala and j for instance incorporate composition into the very of their designs however as we have explained we are particularly interested in the question of how to existing languages with and to our knowledge there is relatively little work on that the systems of et al define a new level of mixin modules to existing java classes a component contains defined classes and deferred classes the latter of which are specified as abstract class names with various constraints the bind construct which performs mixin linking components producing a unique copy of all the classes inside the merged result and thus fresh abstract types in contrast backpack supports an applicative semantics of instantiation the languages are implemented with a translation into polymorphic bytecode essentially an extension of jvm bytecode with and constraints for the deferred classes ie holes in the component for that reason their il although they present no formal definition of their elaboration into this language instead they define a reduction semantics on components that them into fully instantiated java class definitions in backpack following much work on ml module systems packages do not have a direct reduction their meaning is given by a formal translation into a typed il in our case based on haskell as is the in objectoriented languages the systems emphasize dynamic binding virtual methods overriding etc and do not consider the issue of the double problem in contrast backpack supports only static binding does not permit overriding and great effort to avoid double future work type classes backpack modules only allow data types and values type classes and type class instances are absent we have left them out of the system in order to focus attention on the essential features of backpack that we hope will be applicable not just to haskell that being said we believe that type classes into backpack should be feasible in the extension we type classes and instances would both be new kinds of core entities although the latter would differ from existing entities in that they do not have simple syntactic names and import resolution treats them differently see below as with all entities the export listed in a module type would denote which instances a module provides to its clients the interaction between instances and signatures an interesting challenge linking an implementation for a hole or even linking two holes together through aliasing might result in the existence of two distinct instances for the same type class and type that are visible within a single module for example in the bindings p class eq a where a data t b data t import p import qualified a c import qualified b instance eq at where instance eq bt where of c requires that at and bt be distinct types but if we then add an alias binding a b these two types are unified into a single one and now c defines two different instances for a single class and type making it illtyped to prevent this form of error we would need to the definition of merging for sets of export to prevent two distinct instances for the same class and type from merging together successfully this would be enough to guarantee that the substitution that links a and b together would not be well defined on the package type for the previous four bindings thus the addition of the alias binding a b we would also need to extend the il in order to maintain a crucial invariant of the elaboration translation namely that the il translation of a module only the entities that were visible to that module during typechecking section this invariant would not be preserved in the presence of type classes because haskell does not support named instances so there is no way to explicitly the instances that one module from another for example suppose a module y a hole x and then the hole is subsequently filled with an implementation defining an instance that was not in the signature for x in that case we do not want the elaboration of y to see that new instance since it might break ys but there is no way a priori to prevent it to restore this invariant in the presence of type classes we would need to in the ability to explicitly name instances on import statements this capability which would require a minor extension to ghc would then allow us when y in the above example to explicitly restrict the import of x to only include those instances that were visible in xs signature type and we could straightforwardly extend backpack with both type and haskells mechanism for defining abstract data types both would be separate entities along with datatypes and values with defined entity because they are core entities they would be imported exported and recorded in module types just like datatypes and values however for compatibility with ghc neither would be abstractly in signatures ie by the righthand sides unlike regular data types in the case of type we would need to treat them as equal to their defining types to this we would simply expand type as part of backpack elaboration ensuring that they never appeared in our semantic objects the modules approach of et al works similarly since the themselves would never appear in any semantic types typ they would not type equality in contrast would not be automatically with their defining types in semantic types typ they would look and behave essentially like regular data types while the support for in haskells existing package management system does not interfaces and mixins neither do interfaces and mixins an important direction for future work is to investigate how best to integrate into backpack acknowledgments we are for discussions with beta and for early design discussions with and and for detailed technical feedback from references and polymorphic bytecode compositional compilation for languages in popl and flexible typesafe linking of components for languages in and a calculus of module systems and modularity meets inheritance in luca cardelli program fragments linking and in popl karl crary robert harper and what is a recursive module in pldi s mark p jones and thomas a formal specification of the haskell module system in haskell dreyer a type system for recursive modules in icfp dreyer recursive type generativity typesafe linking with recursive and shared libraries acm toplas ­ and mixin modules in icfp a static semantics for haskell matthew and matthias felleisen units modules for hot languages in pldi and pottier numbering firstorder canonical forms for secondorder recursive types in icfp robert harper and a typetheoretic interpretation of standard ml in proof language and interaction in of robin milner mit press and leroy mixin modules in a callbyvalue setting acm toplas ­ paul hudak john hughes simon peyton jones and philip wadler a history of haskell being lazy with class in iii huet des phd thesis paris september im and park a syntactic type system for recursive modules in oopsla leroy applicative functors and fully transparent higherorder modules in popl leroy the objective caml system documentation and users manual robin milner tofte robert harper and david macqueen the definition of standard ml revised mit press qi and andrew myers j nested intersection for scalable software composition in oopsla martin odersky and matthias scalable component abstractions in oopsla scott and matthew from structures and functors to modules and units in icfp the missing link ­ dynamic components for ml in icfp and dreyer mixin up the ml module system acm toplas v and dreyer modules in extended version available from the authors at v types for modules phd thesis university of edinburgh peter sewell james j and vafeiadis highlevel programming language design for distributed computation ­ david vii karl crary and robert harper a separate compilation extension to standard ml in ml 