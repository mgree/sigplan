abstractions from tests institute of technology usa yang university of oxford uk sagiv university university abstract we present a framework for dynamic analysis to find good abstractions for static analysis a static analysis in our framework is our main insight is to directly and efficiently compute from a concrete trace a necessary condition on the parameter configurations to prove a given query and thereby the space of parameter configurations that the static analysis must consider we provide constructive algorithms for two instance analyses in our framework a flow and contextsensitive analysis and a flow and pointsto analysis we show the of these analyses and our approach on six java programs two the analysis of queries on average and proving the pointsto analysis of queries on average and proving categories and subject descriptors d software engineering verification f logics and meanings of programs semantics of programming analysis general terms languages verification keywords static analysis testing analysis pointsto analysis problem introduction static analyses based on the abstract interpretation technique are guaranteed to be sound if such an analysis reports that a given query holds for a given program it must indeed hold in practice however the analysis may not be enough to apply to the program or it may not be precise enough to prove the query this problem is inherent with the undecidability of static analysis one of the most interesting questions in static analysis concerns how to a given static analysis to prove a given query the idea is to make the analysis yet precise by it to prove a specific query counterexampleguided abstraction permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm refinement cegar aims to solve this problem the idea is to refine the abstraction until either a concrete counterexample is found or the query is proven despite many advances the cegar approach includes many limitations which its it is costly and may fail due to limitations of the theorem prover the to appropriately refine the abstraction the size of the counterexample and the cost of the static analysis to compute the intermediate abstractions this paper takes a different approach it uses dynamic analysis to compute good abstractions for static analysis the static analysis is and the space of parameter configurations is typically large eg exponential in program size or even infinite given a query a set of parameter configurations and a concrete trace our dynamic analysis computes a necessary condition on the parameter configurations for proving the query our limited experience shows that this condition can be used to choose from among the remaining parameter configurations one that yields an abstraction that is enough to cut the cost of the static analysis yet precise enough to prove the query one advantage of our approach is that the necessary condition is inferred efficiently and directly from the concrete trace without the need to run the static analysis on the whole program which may be infeasible additionally our method can be seen as an procedure for static analysis when an abstraction fails to satisfy our condition it can neither prove nor the query independently of the existence of the counterexample this means that some abstractions are even before they are computed which is in contrast to the cegar approach we do not provide a general algorithm to compute the necessary condition from a given trace instead we provide a formal definition of the problem and algorithms that compute the condition directly from the trace for two instance analyses a flow and contextsensitive analysis and a flow and pointsto analysis we have evaluated our approach on six realworld java programs two in total the largest being k for analysis our approach of queries on average and proving for pointsto analysis it of queries on average and proving the fact that the of queries are more significantly that our approach is precise in practice it is also scalable despite being topdown interprocedural and fully flow and contextsensitive our analysis takes only seconds on average over invocations with a maximum of seconds to the key contributions of this paper are as follows we present a novel approach for using concrete traces in order to obtain good abstractions in certain cases for static analysis we present a formulation of a necessary condition for an abstraction to be precise enough for a given concrete trace we provide constructive algorithms to compute the necessary condition from a concrete trace for two static analyses analysis and pointsto analysis we provide empirical evidence that our approach can be efficiently implemented and that the resulting static analysis is both precise and scalable example in this section we provide the reader a of our approach using analysis the analysis problem we introduce the analysis problem using the example java program in figure object allocation sites have unique labels h h and so on and we all types variables u v and w are and g is a global ie static field the program is multithreaded in each iteration of the loop the main thread executes the statement which calls the start method of class which starts a new thread corresponding to the object pointed to by u thus after the call the main thread proceeds to the next loop iteration while the started child thread runs code not shown in the figure the graph at the top of figures ignoring the dotted boxes shows the concrete data structure created just before program position pc in any iteration i of the loop for convenience each object is labeled with the site at which it was created h h etc the clear nodes denote threadlocal objects and the nodes denote objects an object is threadlocal if it is reachable from at most one thread and otherwise an object becomes reachable from multiple threads if it is assigned to a global or if the start method of class is invoked on it in the former case the object becomes reachable from all threads in the program while in the latter case the object becomes reachable from at least the parent thread and the started child thread moreover any object reachable in the heap from a object is also finally once an object it remains for the rest of the execution in our example the statement g new h which writes to global g causes the created object to depicted by the object labeled h likewise the call causes the object pointed to by u to depicted by the object labeled h from an earlier iteration moreover the object pointed to by w is reachable from this object in the heap via field f hence that object also depicted by the object labeled h from an earlier iteration we formulate the analysis problem in the form of program queries the query we focus on in our example is w which is true if whenever any thread reaches program position pc the object pointed to by local variable w in that threads environment is threadlocal it is easy to see that this query is true in our example the only thread that reaches pc is the main thread and whenever it does w points to the object most recently created at site h which is threadlocal note that this object only after the following statement is executed many clients in verification testing optimisation and program understanding for multithreaded programs can benefit from such queries for instance proving our example query enables a static race to prove that field id is analysis a key challenge in proving analysis queries lies in choosing a heap abstraction that threadlocal objects from objects one class of heap abstractions involves partitioning all objects based on some static program property a natural way is to use a separate partition for all objects created at the same allocation site but even this simple heap abstraction can be too costly when applied to a large program with procedures our goal is to derive heap abstractions that in most cases are still precise enough to prove the given query the first step in our approach is to the static analysis in a manner that admits a large possibly infinite family of abstractions and cast the problem as a search for a good parameter configuration to use for proving a given query examples of such analyses a safety model checker can be viewed as by a set of program predicates that the predicate abstraction it computes shape analysis is parametric in which predicates to use as abstraction predicates and pointsto analyses etc are by a vector of integers that the degree of context and the analysis must use for each call site and each allocation site our analysis uses heap abstractions with two partitions denoted l and e that definitely threadlocal objects and possibly objects respectively the analysis is by the partition to be used for objects created at each allocation site a parameter configuration thus maps each allocation site in the program to either l or e each object created at a particular site starts in the partition by for that site and may subsequently from l to e but not vice versa the analysis succeeds in proving a query x if variable x does not point to an object by the e partition in any abstract state at program position pc our goal in the analysis setting is to efficiently find a parameter configuration that is yet precise enough to prove a given query in practice most configurations yield abstractions that are not enough to apply to the given program or not precise enough to prove the given query moreover proving different queries can require different configurations we next illustrate the difficulty in efficiently finding good configurations we begin by noting that and testing configurations is infeasible due to the large space from which they can be chosen consider the trivial in figure a which maps each site to l the analysis using computes at position pc the abstract state shown at the bottom of the figure with the corresponding concrete state shown above it this analysis fails to prove our query because variable w points to partition e in the abstract state at position pc despite all objects starting in partition l this is because statement g new h the l partition since maps h to l recall that objects can from partition l to partition e this leads us to in figure b which is similar to but maps h to e the analysis using proves our query but it is not the configuration our analysis reasons about reads from objects that are by the l partition and so it tracks outgoing fields from such objects being fully flow and contextsensitive the analysis is exponential in the number of such fields hence it is to map as few sites as possible in to l and thereby limit the number of such fields in particular it is not necessary to map h to l which causes field f to be tracked this leads us to in figure c which is the configuration that proves our query note that further it fails to prove the query mapping h to e clearly fails because query variable w is allocated at site h but mapping h to e also fails because variable u is allocated at site h and statement w will the l partition u v w are local variables g is a global variable start a new thread for i i i u new h v new h g new h vf g w new h w pc i query w h l h l h l h l a fails to prove query h l h l h e h l h l h e h e h l b proves query but not c proves query and figure example java program and abstract states computed by our analysis at pc using different parameter configurations parameter configurations from tests we have seen that choosing a good parameter configuration for a given query requires a balance between precision and scalability the key insight in our work is to directly and efficiently infer from a concrete program trace a necessary condition on the parameter configurations for proving the query our work does not provide a general algorithm for computing the necessary condition but it serves as a principle for designing good abstractions we provide constructive algorithms using the principle for two instance analyses a analysis and a pointsto analysis we also prove that these algorithms indeed compute a necessary condition any parameter configuration not satisfying the condition will fail to prove the query in the case of our analysis the necessary condition is computed using an algorithm we call backward pointer reachability given a query x and a concrete program state at location pc where and are the environments providing the values of local and global variables respectively and is the heap this algorithm that any parameter configuration that can prove this query must map the allocation site of each object from which the object x is reachable in to l for our example query this algorithm outputs h l h l this is because whenever program position pc is reached variable w points to an object allocated at site h and the only other object from which that object is reachable in the heap is the one pointed to by variable u which is allocated at site h note that the configuration output by the algorithm does not constrain the values of h and h moreover many allocation sites in the program may not even be visited in the trace since it is to objects using the e partition instead of the l partition recall that the analysis tracks outgoing fields of only objects in the l partition we simply map all unconstrained sites to e thus our approach yields configuration shown in figure c which is the configuration that proves the query our backward pointer reachability algorithm is not the only algorithm that satisfies our necessary condition principle in the extreme one could an algorithm that also infers a condition that is sufficient for the given trace such an algorithm for instance would map h to e recall from figure a that any configuration that maps h to l fails to prove the query however there is a tradeoff between the amount of computation that the dynamic analysis does and the quality of the configuration it infers and the motivation underlying our backward pointer reachability algorithm is to a good balance problem in this section we explain the formal setting of our result in particular we define the problem whose solution plays a crucial role in our approach definition a transition system is a triple s t i where t s × s and i s a query q on a transition system s t i is a function from s to true false intuitively s defines the state space of the transition system t all the possible state changes and i the set of initial states a query q specifies a particular safety property of the transition system we assume that a transition system s t i and a query q are given as input to a static analysis the goal is to prove that the query is true in all reachable states s t i qs true we solve this problem by using a dynamic analysis together with a static analysis a dynamic analysis here is simply a run of the given transition system from some initial state in our combination this dynamic analysis is run first and it either the query or a condition on the parameters of the static analysis which should hold in order for the analysis to prove the query at all in the latter case this condition is converted to a particular parameter setting and the static analysis is run with this setting to attempt to prove the query the transition system used by the dynamic analysis is often instrumented to track extra information about program execution in its states one example is to record in each object the timestamp of its creation then just looking at a single state provides the order of creation of objects in the state note that finding such an order in a standard semantics requires looking at a concrete trace the instrumentation transforms such trace properties to state properties which can be better exploited by our dynamic analyses in the following we describe our static analysis and how we combine dynamic and static analyses in detail we fix a transition system sc tc ic and a query qc and call this transition system the concrete program static analysis we the reader of a standard definition of a sound static analysis and a wellknown consequence of the soundness condition definition a static analysis is a tuple d t i of a complete lattice d a monotone function t d d an element i d representing the set of initial states and a monotone function d we call the function map and it gives the meaning of elements in d as sets of states in the concrete program a static analysis is sound iff ic i d d t d lemma if a static analysis d t i is sound every of d i t d the set of reachable states in the concrete program d d i t d d d we consider static analyses with multiple parameters we the domain of parameter settings as follows definition a domain of parameter configurations is a set of functions from a set param of parameters to a set pval of parameter values the domain does not necessarily contain all such functions and it is ranged over using symbol intuitively parameters p in param decide parts of the analysis to be controlled such as the abstract semantics of a particular memory allocation in the given program a parameter configuration maps such ps to elements in pval which determine an abstraction strategy to employ for the p part of the analysis we allow the possibility that multiple parameter configurations essentially express the same abstraction strategy and we make this duplication explicit assuming an equivalence relation on definition a static analysis is a family of static analyses d t i indexed by parameter configurations in some we require that equivalent components of the analysis satisfy the condition d d d d d d a static analysis is sound if all of its component analyses are sound problem description assume that we are given a sound static analysis d t i we now formulate the problem for this static analysis a solution extracts useful information for a static analysis from results of a dynamic analysis and it forms the main component of our combination of dynamic and static analyses we say that a finite subset sd of sc the query qc when true for every s sd in our setting such a set sd of states is obtained from multiple runs performed during dynamic analysis and it carries information potentially useful for the following static analysis one example of such information is by our predicate sd on parameter configurations sd d d sd d s d false intuitively the predicate holds for when the component analysis cannot separate sd from states the query qc as a result sd implies that the component cannot the predicate is related to so called of abstract elements the formula sd holds iff there is an abstract element d in d sd and containing only those concrete states where qc evaluates to true the latter property of d is the definition of qc having the at d prove that the query holds for all the states in sd using this predicate we describe our problem problem in short nc problem find an algorithm that takes a finite set sd the query qc and returns a set n param × pval satisfying the conditions below for all ¬ p v n p v sd the lefttoright implication implies that if is not equivalent to any parameter configuration that all the parameter bindings p v in n we can skip the option of setting parameters to because the resulting analysis cannot prove the query hence to have any hope for proving the query with the static analysis we should ensure that some parameter configuration equivalent to our setting respects all the bindings p v in n the phrase necessary condition this property of n the other direction is a completeness requirement and it the algorithm to discover all the binding pairs that can be used to detect the satisfaction of sd we make two further remarks on the nc problem first if every parameter configuration satisfies sd so that no parameter settings can make the static analysis prove the query the problem requires that the algorithm should return an unsatisfiable set n up to the equivalence for every no equivalent to follows all the bindings in n this usually happens when n contains two different bindings p v and p v for the same parameter p second even if some parameter configuration equivalent to respects all the bindings in n the analysis with can fail to prove the query according to the equivalence such satisfies sd but this just means that the component analysis has an abstract element in d that can sd without including bad states ie those the given query in practice however we found that sd is a good of the success of the analysis with especially when states sd are instrumented and carry additional information about concrete traces a solution to the nc problem enables an interesting combination of a dynamic analysis and a static analysis in this combination a dynamic analysis is first run and it gives a set of states s sn that are reachable from some initial states in ic if the given query qc does not hold for some si we have found a counterexample and the combined analysis terminates with this counterexample si otherwise the solution to the nc problem is run for s sn and then it computes a set n the combined analysis then checks the of n as follows p param v v pval p v n p v n v v if the check goes through the analysis stops and returns impossible to prove otherwise it one element v from pval which normally makes the static analysis run fast and constructs a parameter configuration n as follows n p if p v n for some v then v else v the element v is chosen carefully so that n belongs to finally the analysis with the parameter setting n is run on the given program in what follows we explain how to solve the nc problem for instance analyses generic solution we have developed solutions to the nc problem for two instance analyses this section is a of the description of these solutions where we explain their in particular we an assumption made by both solutions on static analyses and queries and describe a for developing an algorithm for the nc problem called generic solution from which the solutions can be derived this can also be used for other instance analyses as in the previous section we assume a fixed concrete program sc tc ic and a fixed query qc on sc our generic solution requires that a static analysis d t i should have coupled components which means that the following three conditions hold the component static analyses use the same abstract domain that is d d for all we let d be this common abstract domain note that we do not impose a similar requirement on and component analyses can therefore use different maps this means that although the components share the same set d of abstract representations they can still have different abstract domains because they might interpret these representations differently for all and all d d s d true s d true note that both sides of the equivalence are the same except the subscripts and the common part s d true means that query qc holds for all states abstracted by d hence if the static analysis with a certain parameter configuration returns such d it can prove that query qc holds for all the reachable states of the given concrete program for this reason we call d satisfying formula a good abstract element because of the equivalence above the identification of such good abstract elements does not depend on the choice of a parameter configuration and we use some and define the set of good elements dg as follows dg d s d true there are a finite lattice and monotone functions fs and gs × pval for each s sc such that the equivalence below holds for all finite subsets sd sc d dg sd d s sd a a p v p v the left side of the equivalence means that the static analysis with can use a good abstract element d dg to abstract a given set of states sd hence it can at least separate sd from bad states where query qc gets evaluated to false according to the equivalence this property on can be checked using f and g that is we iterate over all parameter configurations equivalent to and do the following for every state s sd we compute some of fs over map this to a subset n of param × pval using gs and check whether respects all the bindings in n if the check succeeds we stop the iteration and return yes if the iteration without any successful check we return no assume that we are given a sound analysis that has coupled components our generic algorithm for solving the nc problem is given in figure given a finite set sd query qc the algorithm iterates over every element s sd and computes the least fixpoint fs which is mapped to a subset ns of param × pval by gs the resulting subsets ns from iterations are combined and become the result n ns input a finite subset sd sc such that s sd true output the finite subset n param × pval computed by n s sd a fs figure generic algorithm for solving the nc problem note that the least fixpoint of fs exists and can be computed by the standard method which generates fs until the fixpoint is reached because is a finite lattice hence complete and fs is monotone theorem our generic algorithm solves the nc problem proof let n be the result of our algorithm when it is given a set sd of states as the input we need to prove that for every parameter configuration sd holds if and only if we cannot find equivalent to such that p v for all p v n we will this proof obligation by showing sd p v n p v we first transform the left side of the equivalence by unrolling the definition of and using the first condition of having coupled components which says that d d for all sd d sd d s d false d d sd d s d true in the first equivalence we the definition of and replace d by d in the result of unrolling the second equivalence is the standard one from classical logic next we use the second condition of having coupled components which allows us to define the set dg of good abstract elements independently of a parameter configuration d d sd d s d true d d sd d d dg d dg sd d d dg sd d the first equivalence uses the definition of dg and the second equivalence and the lefttoright implication of the third follow from standard reasoning in classical logic the remaining implication in the last equivalence relies on the following condition on d d d d d d as well as the fact that if d d then both d and d belong to dg or neither does so finally we use the last condition of having coupled components to reach the property on the result n of our generic algorithm by the third condition of having coupled components the property in is equivalent to s a p v p v since is an equivalence relation the property above means the same as the following condition s a p v p v in what follows we transform the second conjunct of the condition until we reach our target property for n s sd a a p v p v s sd p v fs p v p v fs s sd p v p v n p v the last two equivalences are standard steps from logic the direction of the first equivalence holds because fs fs now it remains to show the lefttoright direction of the same equivalence to do so we pick s sd and assume that for some a a p v p v since fs is monotone on a complete lattice fs is the least element in satisfying a hence fs a furthermore since gs is monotone fs is a subset of this subset relationship and the second conjunct of the property for a imply that p v fs p v we get the right side of the second equivalence from and instance analyses following our general for solving the nc problem we have developed algorithms for solving the problem for two instance analyses in this section we describe these algorithms we start with a model of concrete program states this storage model is used by both instance analyses as it is or in a slightly form our storage model defines a set of concrete states of a given program it assumes the nonempty set pc of program positions in the given program also the model assumes five nonempty disjoint sets a finite set lvar for local variables another finite set for global variables yet another finite set for fields and two countable sets loc for objects and for allocation sites the formal definition of our model is given by these equations × loc val nil local lvar val global val heap × fin val pc pc × local × global × heap there are no dangling pointers in and intuitively h o means an object o instrumented with its allocation site h such instrumented objects and nil form the set of values the storage model defines states as tuples of four components the first is the current program position pc and the other two denoted and hold the values of local variables and global variables respectively the last component is the heap with finitely many allocated objects note that we treat local and global variables separately this separation helps formulate one of our instance analyses below we consider two analyses over the storage model although there are infinitely many values for denoting allocation sites only a finite subset of them are used in a given program because the program includes only finitely many instructions for memory allocations the formal statement of the absence of dangling pointers is range range range l f l f dom nil analysis it attempts to prove that at a given program position pc a particular local variable x never stores an object that is reachable from any global variable note the use of our separation of local variables from global variables pointsto analysis this analysis tries to show that program variables x and y always point to different heap objects at all program positions the objectives of both analyses have the same format and demand the proof that a certain query should hold for all reachable program states we denote these queries by xq and analysis our first instance analysis is a fully flow and contextsensitive analysis it answers the query xq which whether at program position local variable xq never points to an object that is reachable from global variables the analysis objects in a program state using two abstract locations l and e such that l abstracts nil and a set of objects that are not reachable from global variables and e abstracts the set of all remaining objects in the state thus e includes all objects reachable from any global variable and possibly more the abstract domain tracks outgoing fields from objects by l and it is defined as follows val l e local lvar pval heap pval d pc local × heap an abstract heap is a map from fields to sets of abstract locations this map concerns only the objects by l and the values stored in the fields of these objects note that we do not track values stored in global variables or objects by e this is our choice based on the following observation if an object is reachable from a global variable it usually remains so and as a result tracking what are stored in such objects does not normally help improve precision of the analysis the analysis is an instance of our static analysis that has coupled components its parameters are defined as follows param param pval pval l e parameters are allocation sites and parameter configurations map them to one of the abstract locations l and e setting an allocation site h to v pval entails that objects allocated at h are initially by v this initial membership of a newly created object can change but only in a limited manner an object can move from l to e but not vice versa in this way a parameter configuration how objects are abstracted using l and e and it affects the precision and scalability of the analysis because the analysis generally tracks information about l more precisely but at a higher cost finally the analysis does not have symmetry among component analyses so that the equivalence relation on parameter configurations is simply the equality the intuition described so far on the analysis is by our map which we will now explain for a set l of objects let val val be the following function which abstracts concrete values in val if v l nil then l else e the subscript l here provides the meaning of the abstract location l which our abstraction function abs exploits in a standard way to abstract concrete values using this value abstraction we define maps d as follows pc d l x lvar x l f l dom f f l f × dom l f l l l g g l h a l h l this definition requires that the abstract location l should have an appropriate interpretation as a set l of objects with respect to the abstract stack and heap at pc by the word appropriate we mean that l should satisfy the five conjuncts given above the first two of these conjuncts express that and values that are stored in local variables and in fields of objects in l the next two are concerned with l containing only objects that are unreachable from global variables they say that l is closed under backward pointer reachability and it does not contain any object stored in any global variable hence when these conjuncts hold no object in l can be reached from global variables finally the last conjunct says that all objects in l are allocated at sites mapped by to l equivalently it says that l never contains objects from sites mapped by to e this is the place where the depends on the parameter configuration and the conjunct describes a unique property of the component analysis which holds because objects from sites mapped to e are abstracted using e and this membership in e never changes during the analysis we order pval using the subset relation and local and heap by the pointwise extension of this subset order then from these order relations of local and heap we construct the order on our abstract domain d again using a standard pointwise extension for the product and function spaces lemma the abstract domain d is a complete lattice furthermore is monotone for every nc algorithm assume that we are given a query xq for some program position and a local variable xq our nc algorithm for this query takes a finite set sd such that every state s sd satisfies the query then the algorithm computes a subset n of param × pval which describes a necessary condition for proving the query as formulated by the equivalence in section our algorithm works as follows given an input sd it iterates over every state s pc sd with pc and backward pointer reachability starting from the object xq concretely the backward reachability first looks up the object stored in variable xq in the state s then it computes all the objects that reach object xq via fields in the state and finally it takes the allocation sites as of the resulting objects and builds the set of parameter binding ns h l h as once all the iterations are completed the algorithm the and returns their union n ns as a result formally the nc algorithm is an instantiation of the generic solution in figure with the following data specific to the analysis the first datum is the dg d of good abstract elements whose do not contain bad states xq this property of abstract elements should hold regardless of what parameter configuration is chosen to do the such a dg exists for the analysis and it has the definition dg d x x xq l the second datum is a finite lattice for each state s pc in the case of the analysis pl f l f dom nil the remaining data are monotone functions fs and gs × pval for all s xq pc l l f l f dom l f l h l o h o l h e o g h o l h o g the first function fs comes from the query and a condition on l in the which says that l should be closed under backward pointer reachability the function computes backward closure of the set l and extends the result with the object xq stored in xq the second function collects all the allocation sites appearing in l and turns them to conditions that those sites should be mapped to l when l contains an object h o stored in some global variable so the object xq is adds both h l and h e so that no parameter configurations can satisfy all the bindings in the computation of the fixpoint of fs and its conversion via gs are the formal implementation of the backward reachability calculation to in our informal explanation of the algorithm above lemma the data dg fs gs satisfy the conditions in section hence our analysis has coupled components also the induced nc algorithm solves the nc problem for the analysis construction of a parameter configuration the result n of our nc algorithm needs to be converted to a specific parameter configuration so that our analysis can be instantiated with that configuration we use a simple conversion described at the end of section if n contains two different bindings for a single allocation site we return impossible to prove otherwise we construct a parameter configuration h if h v n then v else e note that in the construction we chose e as a default value usually setting an allocation site to l makes the analysis more precise but slower as well hence our choice of e corresponds to using the most abstract and also component of the analysis which can still separate good states sd obtained by the dynamic analysis from bad states the query xq pointsto analysis our second instance analysis is a flow and pointsto analysis it answers the query which whether program variables xq and point to different objects at all program positions our version of the pointsto analysis uses parameter configurations to an existing flow and pointsto analysis the purpose of looking for such optimisation is not to improve the existing analysis it is wellknown that the existing analysis rather our purpose is to test whether our approach of combining dynamic and static analyses can produce a abstraction that is still good enough for proving a given query our analysis finds a minimal abstraction for proving a given query in the following sense consider a partial order l e defined by l e and extend this order to parameter configurations pointwise a successful run of our analysis computes a minimal parameter configuration according to this extended order if one accepts that this order correctly compares the degree of abstractions of parameter configurations she or he can see that the computed parameter configuration is also a minimal abstraction our pointsto analysis abstracts objects using three abstract locations p p and p these abstract locations form a partition of all objects and they are used to describe aliasing relationships among program variables and fields that arise during program execution based on this intuition on abstract locations we define the abstract domain of our pointsto analysis loc p p p stack var d stack × heap var lvar heap loc × an abstract state conservatively describes all objects stored in program variables and fields note that a program position is not a part of an abstract state this implies that our abstract state specifies a flowinsensitive property of a given program as expected for any flowinsensitive static analyses our pointsto analysis is by maps from allocation sites to abstract locations param pval loc param pval l loc h h l k for some bijection k on pval a parameter configuration at each allocation site which abstract location to use to objects created at the site since there are only three abstract locations all sites are partitioned into three groups each of which is using one abstract location unlike the analysis once an object is by an abstract location say p this summary relationship never changes during the analysis so the object never becomes by p or p later for each parameter configuration we care only about how partition allocation sites into three groups not about the names of these groups whether groups are named p p p or p p p does not matter for the behavior of the analysis this independence on names is made explicit by our equivalence relation on parameter configurations above the way that parameter configurations control the analysis here can be seen in our map which we present next for sets of objects l l with l l let val be the following function that abstracts concrete values v if v nil then else if v l then p else if v l then p else p note the role of subscripts l and l they give the meaning of p and p and guide the function to abstract concrete objects according to this meaning these subscripts are usually constructed by taking the inverse image from a parameter configuration l l h a h p h a h p another thing to notice is that the concrete value nil gets abstracted to the empty set hence every abstract value v represents a nonempty set of concrete values which contains nil using both the value abstraction and the subscript generation explained so far we define the map as follows pc x lvar x g g l f l × dom f p f l f l × dom f p f l f l l × dom f p f we omit the subscripts l l from l to avoid the first two conjuncts ensure the sound abstraction of objects stored in local and global variables the remaining ones guarantee that the concrete heap according to the partitioning scheme by the parameter configuration we order elements in d in a standard way by extending the subset order for pointwise over the function space first and the product space next lemma the abstract domain d is a complete lattice furthermore for all their maps are monotone and satisfy the following condition d d d d d d nc algorithm given a set sd of states from the dynamic analysis our nc algorithm for the pointsto analysis first computes the following sets hx and hy hx h pc sd o xq h o hy h pc sd o h o the first set hx consists of allocation sites of objects that appear in some states of sd similarly the second hy is made from allocation sites of objects appearing in some s sd next our algorithm converts hx hy to a set n of parameter bindings n h p h hx h p h hy which is returned as a result of the algorithm our algorithm is a solution to the nc problem for the pointsto analysis this is because it is an instance of the generic solution in section with the following data the independent set dg of good elements exists and it is dg xq for each state s we let xs pl f l f dom nil and define xs × xs hence consists of pairs l l where li is a set of allocated locations in s or nil the remaining data are the following functions fs and gs for every s pc l l xq l l h p o h o l h p o h o l the function fs simply adds the value of xq to the first set and that of to the second hence the fixpoint of fs is just xq which will be computed by one fixpoint iteration from this fixpoint the function gs gets the bindings of allocation sites to p or p lemma the data dg fs gs satisfy the conditions in section hence our pointsto analysis has coupled components also the induced nc algorithm solves the nc problem for the pointsto analysis construction of a parameter configuration from the result n of the nc algorithm we construct a parameter configuration to be used by our static pointsto analysis our construction follows the method described at the end of section with only a minor as before if the same allocation site is bound to p and p at the same time by n our combined dynamic and static analysis stops and returns impossible to prove otherwise it chooses mutually distinct h h h that do not appear in a given program nor n and defines n n h p h p h p choosing such his is possible since is an infinite set and the given program uses only finitely many allocation sites in then our analysis uses p as a default parameter value and constructs a configuration n h if h v n then v else p using p as a default value is our decision choice based on the observation whatever parameter configuration is used the resulting component pointsto analysis is very hence it is to go for the option that precision which is precisely to use p as a default value we point out that n belongs to since n includes the bindings h p h p and h p experimental evaluation in this section we evaluate the effectiveness of the two instance analyses of our framework the analysis and the pointsto analysis we implemented these analyses and applied them to the six multithreaded java programs described in table including four from the benchmark suite all experiments were done using ibm j vm on a linux machine with two intel processors and gb ram though the experiments were run in a single thread and the jvm was limited to use up to gb ram we next evaluate the precision of these analyses section their scalability section and the quality of the computed abstractions section precision in this section we evaluate the precision of our and pointsto analyses figure shows the precision of our analysis each query to this analysis is a pair pc x where pc is the program position of a statement that accesses an instance field or an array element of an object denoted by local variable x pc y xf pc y xi pc xf y pc xi y such queries may arise from any analysis of multithreaded programs that to reason only about instructions that possibly access memory such as a static race detection tool or a software transactional memory runtime the top of each column shows how many queries were considered for each benchmark that is queries where program position pc was reached at least once in a concrete trace of the benchmark on a single supplied input it shows both the absolute number of considered queries and what fraction they constitute of the queries reachable in a static cfa call graph the latter provides a measure of the coverage achieved by each trace ­ the considered queries are classified into three categories those by our dynamic analysis of the trace those proven by our static analysis using the parameter configuration inferred by the dynamic analysis local and those neither nor proven unknown on average of the queries in each benchmark are either or proven the effectiveness of our approach using only a single trace also note that our approach does not the use of multiple traces which would only further improve both coverage and precision figure shows the precision of our pointsto analysis each query to this analysis is a tuple pc x pc y where pc x and pc y are identical to the queries described above for our analysis with the additional constraint that they both among all benchmarks in and we singlethreaded benchmarks etc and multithreaded benchmarks with little concurrency etc because one of our instance analyses is analysis we also because it is too similar to which we include both are built we tried the remaining four benchmarks in our experiments queries coverage local unknown figure precision results for our analysis e e e e e e e queries coverage aliased not aliased unknown figure precision results for our pointsto analysis access array elements or they both access the same instance field and at least one of them is a write such queries may be by for instance a static race detection client to determine whether the statements at pc and pc can be involved in a race the top of each column shows how many queries were considered for each benchmark that is queries where both program positions pc and pc were reached at least once in the single trace the traces cover ­ of all statically reachable queries the average coverage is lower for queries of this analysis compared to that of our analysis vs this is because the pointsto analysis requires both pc and pc to be reached for a query to be considered whereas the analysis requires a single program position pc to be reached the considered queries are classified into three categories those by our dynamic analysis of the trace aliased namely those where x and y pointed to objects created at the same allocation site at least once those proven by our static analysis using the parameter configuration inferred by the dynamic analysis not aliased and those neither nor proven unknown note that category includes not only queries that are false concretely but also queries that might be true concretely but are impossible to prove using an object allocation site abstraction almost all queries on average are either or proven this result suggests that in practice a flow and pointsto analysis based on object allocation site abstraction for java does not require representing objects allocated at each site using a separate abstract location merely three abstract locations to the query suffice description web from tool version text indexing and search tool system tool relational database engine classes app total methods app total kb app total alloc sites table benchmark characteristics the classes column is the number of classes containing reachable methods the methods column is the number of reachable methods computed by a static cfa analysis the column is the number of of reachable methods the total columns report numbers for all reachable code whereas the app columns report numbers for only application code library code the alloc sites column is the number of object allocation sites in reachable methods time s s s s s s dynamic analysis time events s m s m s m m m s m s m static analysis time serial s s m m m m table running time of our analysis scalability in this section we evaluate the scalability of our analysis table provides the running time of the analysis the time column reports the time to the benchmark for analysis reflection computing a call graph etc the dynamic analysis column reports the running time of our dynamic analysis which includes the time to the benchmark and run it on a single supplied input it also reports the length of the trace that was analyzed the trace includes a separate event for each execution of each object allocation instruction each instance field or array element access and each instruction ie a write to a static field or a call to the start method of class we tried multiple different inputs for each benchmark but found only improvements in coverage and precision this suggests that the of most queries and the abstractions for proving them are not sensitive to program inputs which in turn plays into our for each reachable query the dynamic analysis either the query or provides a parameter configuration that is used by the subsequent static analysis the static analysis column reports the serial running time of all invocations of the static analysis one per set of queries for which the same parameter configuration is inferred by the dynamic analysis note that these invocations do not share anything and could be run in an parallel manner on a machine or a cluster hence we next study the running time of each invocation figure provides the distribution function of the running times of individual invocations of the static analysis for each of our four large benchmarks all from the suite the blue curve shows the of an version of the static analysis while the red curve × shows the of the naive version we explain the difference between the two versions the have a separate point for each different running time the of the point denotes that time while we conjecture that the input happens because analysis and pointer analysis concern heap structure and pointer which is less sensitive to the specific data values in different program inputs eg different keywords to be by different sql queries to be by etc the of the point denotes the number of invocations that took at most that time the version of the analysis takes almost constant time across different invocations for each benchmark that our approach is effective at the abstraction to each query section provides more statistics about the computed abstractions specifically it takes an average of seconds per invocation and a maximum of seconds over all invocations for all benchmarks the naive version on the other hand takes an average of seconds per invocation and runs out of memory for the invocations for and for that are denoted by the points taking timeout we used for those invocations the and naive versions of our static analysis differ only in how they compute method summaries which we explain next let pc denote the incoming abstract state for a method recall that provides the incoming abstract value of each formal argument of the method and is the incoming abstract heap if the incoming abstract value of none of the formal arguments contains abstract location l ie x l x then the analysis of that method will never read the incoming abstract heap the version of our analysis exploits this observation and analyzes the method in context ie using an empty incoming abstract heap whereas the naive version still analyzes it in context in practice we observed that our topdown interprocedural analysis repeatedly methods with the same incoming abstract environment satisfying the above condition but with different incoming abstract heaps thus the naive version results in significantly reuse of summary edges than the version evident from the in figure these have a separate point for each different number of summary edges that was computed for any method in the benchmark in any invocation of the analysis the of the point provides that number while the of the point provides the fraction of methods for which at most that many summary edges were computed in any invocation note that while in both versions only under a of summary edges is computed for the of methods there are in the naive version for which more summary edges are computed than in the version for all four benchmarks these cause the invocations described above to run out of memory it is worth that sophisticated optimizations have been proposed to efficiently compute and represent method summaries over abstract heaps eg while those optimizations are hard to understand and implement ours is relatively simple yet highly effective in practice notice that the only reason why our optimization is enabled is due to the unique capability of our dynamic analysis to map only a few necessary allocation sites to l and the of allocation sites to e in the parameter configurations with which the static analysis is invoked see section without this capability many methods would be analyzed with incoming abstract environments containing l in the abstract optimized naive optimized naive optimized naive optimized naive figure of the running time of invocations of the and naive versions of our static analysis values of formal arguments which in turn would prevent the version of our analysis from ignoring the incoming abstract heap and summary reuse abstraction quality this section evaluates the quality of the abstractions computed by our analysis the key question we want to answer is how hard is the analysis problem to justify using query and dynamic analysis we with various purely static approaches and found that they were not precise or scalable enough below we describe two such approaches the goal of this was to determine how much flow andor context sensitivity for precision we implemented a flow and analysis based on object allocation site abstraction and found that it proved only of the queries for our benchmarks with an average of in contrast the combined approach presented in this paper which is flow and contextsensitive proves of the queries with an average of this shows that flow andor context sensitivity is likely important for precision optimized naive optimized naive optimized naive optimized naive figure of summary sizes of methods in invocations of the and naive versions of our static analysis the goal of this was to determine whether a trivial parameter configuration is precise and scalable enough we used the static analysis presented in this paper but invoked it with a parameter configuration that simply sets each allocation site in the program to l instead of using our dynamic analysis to obtain parameter configurations to individual queries we found the resulting analysis to be highly ran out of memory on all our six benchmarks but highly precise on much smaller benchmarks not shown that it was able to successfully analyze this shows that even though the above trivial parameter configuration is not the most precise in principle it is likely very precise in practice and the ability of our dynamic analysis to avoid mapping sites to l is critical in practice for scalability we would like to answer the question if a few allocation sites must be mapped to l for scalability how small is that number to justify an approach as sophisticated as backward pointer reachability and how different are the allocation sites for different queries to justify query we next answer these questions figure shows the of the number of allocation sites that were mapped to l for each query by the dynamic analysis recall proven queries all queries proven queries all queries proven queries all queries proven queries all queries figure of the number of allocation sites mapped to l in each parameter configuration for all queries considered by our static analysis and for just those that were proven that these are the sites the dynamic analysis has determined must be mapped to l mapping any of them to e is guaranteed to make the static analysis fail to prove the query the red curve × shows the for all queries that were considered by the static analysis whereas the blue curve shows the for only queries that it up proving for each point shown the denotes the number of sites that were mapped to l for some query and the denotes the fraction of queries that needed at most those many sites the relative shapes of the two are expected as the number of sites needed to be mapped to l by a query grows the that our dynamic analysis will miss some needed site due to lack of coverage and thereby cause our static analysis to fail to prove the query increases the show that while just sites are needed to prove around of the queries for each benchmark at least a of sites are needed to prove another and of sites are needed to prove the remaining on average sites are needed for all queries that the static analysis attempts to prove with the being sites for figure of the number of queries in each invocation of our static analysis figure shows the of the number of queries in each invocation of our static analysis for which the same parameter configuration is inferred by the dynamic analysis for each point shown the denotes the size of at least one such query set and the denotes the fraction of query sets of at most that size on average an invocation of the static analysis considers queries with some considering over queries each this shows that the abstraction needed for proving each query is neither too unique nor too generic related work our approach is related to techniques for abstraction and to techniques for combining dynamic and static analyses we next survey each of these kinds of techniques abstraction in the problem a program and a query assertion are given and the goal is to find either a counterexample program trace showing a violation of the query or an abstraction which is yet precise enough for the analysis to efficiently prove the query on the pro gram there are two natural solutions to this problem abstraction refinement which starts with a abstraction and refines it and abstraction which starts with a precise abstraction and it the cegar approach eg in the first category and refines the abstraction by false counterexample traces besides the cegar approach there are other approaches to refine abstractions that are based on a dependence analysis that relates queries to sources of such as flow context or object in the abstraction in more recent work et al present algorithms to find a minimal abstraction that are based on both abstraction refinement and a fundamental difference between our approach and all the above techniques is that we the concrete trace in order to avoid performing the static analysis at all this can be in cases where the static analysis is exploring too many paths and considering too many configurations interestingly our method could be combined with abstraction refinement eg by computing an initial abstraction which respects the necessary condition and then applying refinement if necessary combining static and dynamic analyses recent work combines static and dynamic analyses in interesting ways the project exploits a dynamic analysis to improve the performance of the step of a static analysis a form of testing is used to reduce the number of theorem prover calls and case splits due to pointer aliasing which a static analysis considers during refinement gupta et al uses a dynamic analysis to simplify nonlinear constraints generated during inference of program invariants et al uses a static analysis to construct a concrete trace that is then used by an automated theorem prover to check if it covers all executions it proves safety properties if the check passes on the concrete trace and produces a counterexample that can be used to generate new traces if the check fails one of the interesting questions for a program analysis is how to infer the right invariants to prove a query one potential idea which is similar to ours is to start from a given concrete trace and then it uses interpolants to perform this approach is interesting but it requires computing interpolants which is not yet feasible for many programming language features also like cegar this approach fails to from multiple paths in contrast we simplify the problem by assuming that the abstract domains already provide and use the concrete trace to abstractions techniques combining random test generation and concrete execution with symbolic execution and model generation have been explored they use symbolic methods to direct tests towards paths to find errors faster but they do not use abstraction and in general cannot find proofs in the presence of loops to our knowledge our technique is unique in that it uses a dynamic analysis for computing necessary conditions on abstractions and also for directly providing a static analysis with an abstraction that is to a given query and which in most cases succeeds in proving the query conclusion efficiently finding good abstractions is a problem in static analysis static analyses offer the flexibility to the abstraction to a given query but also pose a hard search for a suitable parameter configuration we have presented a novel solution to this problem using a dynamic analysis to compute a necessary condition on the parameter configurations for proving a given query we have given constructive algorithms for two instance analyses analysis and pointsto analysis we have proven that these algorithms indeed compute necessary conditions and shown that in practice these algorithms are efficient and the resulting static analyses are both precise and scalable acknowledgments we thank for technical discussions on analysis and the problem and peter ohearn and the anonymous for helpful comments on the paper yang support from references t ball and s rajamani the slam project debugging system software via static analysis in popl pages ­ n e a v s k rajamani and r j proofs from tests in pages ­ d t a henzinger r majumdar and a rybalchenko path invariants in pldi pages ­ s m r c a m k s r a d d s z m a m jump h lee j e b a d t d von and b the benchmarks java development and analysis in oopsla pages ­ e m clarke o s y lu and h counterexampleguided abstraction refinement for symbolic model checking jacm p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction of approximation of fixed points in popl pages ­ c and y check n crash combining static checking and testing in pages ­ p n and k dart directed automated random testing in pldi pages ­ p a s rajamani and s compositional program analysis the power of alternation in popl pages ­ b s t a henzinger y a v and s k rajamani a new algorithm for property checking in pages ­ a gupta r majumdar and a rybalchenko from tests to proofs in tacas pages ­ s and c lin pointer analysis in sas pages ­ t henzinger r jhala r majumdar and k abstractions from proofs in popl pages ­ p and m scaling abstraction refinement via pruning in pldi pages ­ p o and m learning minimal abstractions in popl pages ­ k heuristics for program analysis in popl pages ­ a v s k rajamani s and a v the project software property checking via static analysis and testing in tacas pages ­ j and a precise concrete type inference for objectoriented languages in oopsla pages ­ j p and j specification and verification of concurrent systems in in proceedings of the th international symposium on programming pages ­ n j t reps m sagiv and r a semantics for procedure local heaps and its abstractions in popl pages ­ k d and g a unit testing engine for c in pages ­ g t ball and m sagiv testing abstraction theorem proving better together in pages ­ 