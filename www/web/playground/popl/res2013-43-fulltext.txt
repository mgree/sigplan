the of sharing in data structures national university of university college london abstract programs manipulating mutable data structures with sharing present a challenge for modular verification deep aliasing inside data structures reasoning in isolation over parts of these objects because changes to one part of the structure say the left child of a dag node can affect other parts the right child or some of its descendants that may point into it the result is that finding intuitive and compositional proofs of correctness is usually a we propose a compositional proof system that enables local reasoning in the presence of sharing while the ai frame problem captures the reasoning required to verify programs without sharing we that natural reasoning about programs with sharing instead requires an answer to a different and more challenging ai problem the ramification problem reasoning about the indirect consequences of actions accordingly we present a proof rule that attacks the ramification problem and show how to reason with it our framework is valid in any separation logic and permits sound compositional and local reasoning in the context of both specified and unspecified sharing we verify the correctness of a number of examples including programs that manipulate dags graphs and data structures in nontrivial ways categories and subject descriptors f specifying and verifying and reasoning about programs logics of programs d verification correctness proofs formal methods general terms languages theory verification keywords aliasing modularity separation logic introduction data structures with sharing such as acyclic and unrestricted graphs as well as various kinds of data structures are in computing an example of an data structure can be found in the linux io scheduler in which the set of events forms both a linked list and a binary sorted tree depending on which links one follows programs manipulating data structures with sharing are often short but the reason that they are correct can be subtle and previous work has not come up with general intuitive and compositional principles for reasoning about such programs the key difficulty is that deep aliasing reasoning in isolation over parts of these objects changes permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm to one part of the structure say the left child of a dag can affect other parts the right child or its descendants that may point into it we propose a compositional proof system for programs manipulating shared data structures our framework directly addresses the sharing present in the data structures and achieves compositionality via applications of the following rule tp u c p q rq c at first there seems to be no connection between the known spec tp u c and the desired spec c the connection is given by the ramification indicated by the p q rq premise which asserts semantically although this paper also provides ways to reason syntactically about it that the global assertion r becomes r after a local transformation from p to q the term ramification comes from artificial intelligence fin and refers to the problem of understanding the indirect global consequences of local actions eg a might reduce the ambient light by blocking the window ramification is with the simpler frame problem which on maintaining knowledge after actions eg the does not change the number of of program verification has had significant success handling the frame problem especially with the frame rule of separation logic frame tp u c tp f u c tq f u here the separating conjunction ensures that p and f cover disjoint pieces of heap allowing the frame rule to guarantee that f is unchanged under the action of c the frame rule us compositionality in the presence of the heap we can reason about the effect a program has on the portions of heap it accesses and reuse that spec in any heap this has given rise to concise compositional proofs of programs even in the presence of some forms of sharing where one knows what is shared by unfortunately we usually cannot use the frame rule directly when verifying programs that manipulate data structures with unrestricted sharing because such structures cannot easily be into the form p f for example the left and right descendants of a dag node are not usually disjoint the reason to focus on ramification rather than frame is that the former allows us to reuse for c in far more settings than the latter permits of course with great power comes great having isolated the parts of the proof that require careful of indirect effects on the global structure we are left with ramification obligations to prove as it turns out are expressible as separation logic p q rq def r p pq ´´ rq these feature the magic wand connective of separation logic for all states satisfying q and disjoint from the current state the combination of both states satisfies r which is hard to reason about in general given the universal quantification over states however of ´´ in are restricted to a particular idiom that together with denotes an update to the state by this intuition we are able to reduce these spatial to more abstract reasoning about the nature of the update on the structures mathematical representation eg graphs as sets of nodes and edges and transformations on said graphs the verification process thus into two parts first showing that a concrete program correctly implements some transformation on an abstract mathematical structure and second showing that those mathematical transformations produce the desired specification this division gives us the freedom to describe data structures with sharing in the most natural way we will present examples that use the separating conjunction of separation logic to reason about disjointness eg between the parent of a dag node and its children the overlapping conjunction y to reason about unspecified sharing eg between the left and right children of a dag node and the classical conjunction to reason about complete sharing eg an data structure in contrast to previous work we achieve compositional reasoning and the sharing approaches based on separation logic invariants that the state into the disjoint pieces required by the frame rule often the predicate definitions on the program at hand eg the dag definition used could depend on the order of traversal in the algorithm in other words previous attempts to reason about shared data structures with separation logic have on their head to avoid the sharing other approaches from these problems at least as much and often gave up compositionality our key contributions are as follows · we present the rule which enables local reasoning while for global effects precisely when they are required ramification can reason about programs that manipulate data structures with unrestricted sharing while enabling the small specifications compositionality and expressiveness that have led to separation logics success · although the rule leads to more natural hoare proofs the entailment checks can be nontrivial we have developed a ramification library of lemmas that help simplify the ramification conditions we also show how to prove concerned with certain general graph and dag updates in a way that enables a separation of concern between heap and mathematical reasoning about graphs · we have applied the rule to a variety of algorithms that manipulate data structures with nontrivial sharing although some of the examples are not long all involve reasoning due to the heavy use of sharing we think that a strength of our approach is that the hoare invariants at each program point are natural and seem to follow our programmers intuition much more closely than traditional proofs · we give a semantic account of ramification and show that and frame are each derivable from the other meaning that our framework is applicable in any separation logic moreover we identify the precise constraints on the underlying model that enable the overlapping conjunction y and show that most separation logics in the literature can therefore follow our and use it to reason about unspecified sharing the rest of the paper is organized as follows we first recall some important concepts from separation logic § we then and present the rule § and show how to reason about it § based on this we provide proof for three examples that different aspects of ramification marking a dag § removing from an data structure § and garbage collector § finally we show how ramification is applicable in any separation logic § compare to related works and conclude separation logic and trees recall the framework of separation logic io while considering the following mark procedure written in c that recursively marks binary trees dags or graphs struct node int m struct node lr void node x if x xm return struct node l xl r xr xm separation logic allows straightforward inductive definitions of predicates to describe data structures in the heap the following definition the actual contents and location of each node but does make sure that the structure is acyclic thanks to the between the root and the subtrees and that no sharing occurs between subtrees thanks to the between the children def px dd l r x ÞÑ d l r the definition of tree uses the standard classical separation logic operators a h satisfies the pointsto predicate x ÞÑ y when h contains only the location x whose value is y and the separating conjunction p q asserts that p and q hold on disjoint we use x ÞÑ d l r as a shorthand for px q ÑÞ d px q ÞÑ l px q ÞÑ r simplifying the memory model so that eg each datum one unit of space it is wellknown how to use separation logic to prove the mark procedure memory safe for trees moreover the separation logic proof the programmers the of the verification is to handle the recursive calls via the frame rule eg at line taking the spec of mark as a premise tt ÑÞ l r frame tt ÞÑ l r this is a canonical example of how inductive predicates the separating conjunction and the frame rule fit together to produce concise proofs unrolling the tree predicate yields formulas so the proof system via its frame rule is able to perform on the symbolic state and work on each independently for sharing we now turn to the case of data structures with sharing and introduce our rule we begin by defining inductive predicates for dags and graphs before presenting the proof sketch that we to for the mark procedure when applied to dags dag and graph predicates our first task is to define a dag predicate since the separating conjunction prevents sharing our first attempt updates tree to regular conjunction between the children instead def px dl r x ÞÑ l r unfortunately in classical separation logic actually describes a linked list because the conjunction forces the two to exactly the same space in memory h p q if h p and h q however reynolds points out that dag is correct in intuitionistic separation logic in which x ÞÑ y holds on any heap that contains at least x rather than only x § translated into our classical setting this is equivalent to defining dags as follows def px dl r x ÞÑ l r if our first attempt was in some sense too small then our second is too big holds on any heap that contains at least a dag rooted at x as usual in intuitionistic separation logic it is impossible to fully verify certain algorithms eg showing that dag completely the structure using dag what we want is a way to get the overlapping features of the intuitionistic conjunction without actually intuitionistic we turn to another connective studied in the published literature which we the overlapping conjunction and write y and which precisely characterizes the desired sharing h ù p y q def h h ph h h ph h p q ph h qq the is the combination operator on the underlying separation algebra often some kind of disjoint union contrast the definition of y with the standard definition of h ù p q def h ph h ph p q ph qq here are some properties of y for reference and to aid intuition lemma p y emp p p q p y q p q p y q p y q p true p y q dr pr ´´ p q pr ´´ qq r p y q q y p p y pq y rq pp y qq y r ñ ñ pp q y qq equations and are immediate from the definition of y we use quantification over predicates in commutativity is direct from and the commutativity of in contrast associativity is and requires cross split see § finally lem enables y to be used in covariant recursive predicates just like and whenever we write recursive definitions using y including dag and graph below we are implicitly using the key point to y is that we can use it in exactly the same places that feature the kinds of sharing that the intuitionistic captures but it does not the resulting structure that is it allows us to define a classical dag with a data field as def px dd l r x ÑÞ d l r y the separating conjunction between the root x and its children prevents cycles in the data structure the definition for graphs simply replaces this remaining with another y def px dd l r x ÑÞ d l r y y we will dag and graph with mathematical dags and graphs to enable proofs of functional correctness writing q and q respectively and need not be tight and so can include vertices that are unreachable from x mathematical trees lack sharing and are hence directly definable as terms mathematical dags and graphs are more complicated and so we defer the associated formal definitions until § one key notation is pd l rq which indicates that the mathematical node x is associated with data d and successors l and r unspecified sharing observe that y models unspecified sharing ie the dag predicate does not say which parts of a dag are shared in contrast specified sharing requires the precise identification of the shared part eg on a dag identifying which nodes are shared between the left and right children often this is very difficult pf q def pp qq ñ f pp q f void mark struct node x struct node lr if x xm return l xl r xr tx ÞÑ l r q y qq p l xm tx ÞÑ l r q y qq p l mark l pq x ÞÑ l r mp y mp p l rq mark r pq x ÑÞ l r q y qq p l rq lq rq mp figure proof sketch for marking a binary dag the steps that induce are indicated with i where the associated ramification entailment is equation number i on the other hand sometimes specified sharing is exactly what the ordered although the overlapping conjunction is extremely useful our framework is not based around it and one of our key contributions is that can handle both specified and unspecified sharing for an example of specified sharing see § which uses instead of y moreover see § for how we can use the explicit overlapping conjunction of and cb of manipulating dags fig presents the annotated proof sketch of the functional correctness of mark when applied to dags using the small spec mp the function mp xq whose formal definition is deferred until § indicates the mathematical dag derived from via marking starting from node x notice that this specification immediately implies that if the initial dag is then the final dag is completely marked as is the case for many recursive programs on data structures part of the state tracking the recursive exploration of the graph in the call stack which which states have been only partially processed our spec accounts for this complexity while remaining local ie it only describes the portion of memory accessed by mark enabling compositional reasoning moreover we straightforward invariants at each program point although the invariants are natural the proof in separation logic is far from obvious things are straightforward enough until we reach the first recursive call at line for tree we applied the frame rule in equation which very well while we can easily frame away the x ÞÑ l r from the precondition line the two dag predicates into q on the one hand and a disjoint frame on the other would describing the shape of the right child once everything that is shared with the left child has been removed which is exactly what we wish to avoid the second recursive call in line presents exactly the same problem we wish to frame but cannot these two recursive calls require a new proof pattern that we call ramification the rule while the proof outline of fig provides all the invariants needed to prove mark on dags frame cannot be applied directly to reason about the effect of applying the mark spec on the left child because the left and right child are not disjoint to solve this issue we introduce the ramification rule which allows the reasoning to we often write eg when what we really mean is x v where x v means that the variable x evaluates to the value v in the current state because mathematical graphs take values rather than variables we these kinds of details for the presentation progress through commands that have indirect global effects tp u c r p pq ´´ rq fv pq ´´ rq x c h the complicated in reasoning at each recursive call site so that the assertions at each program point remain natural such as in fig eg the assertions are free from ´´ no free variables of q ´´ r may be modified by c as usual magic wand separating implication is the of h p ´´ q def h ñ h p ñ h h q here asserts the compatibility of h and h h h h informally can be read as the result of applying c in a state r is r if replacing p inside r with q yields r magic wand binds more than any other operator is sufficiently abstract that it can be hard to as an initial of its power observe that the frame rule modulo some restrictions on free variables as discussed below is a direct consequence because p f p pq ´´ qf q next let us apply ramification to verify the following spec in which x ÞÑ ´ is the standard notation for dx x ÑÞ x tx ÑÞ ´ y y ÞÑ x a tx ÑÞ a y y ÑÞ two the first precisely matches the standard small axiom for store update in separation logic tx ÑÞ x a tx ÞÑ au the second is the following ramification entailment whose proof is direct from the associated definitions x ÑÞ ´ y y ÞÑ ´ x ÑÞ ´ px ÑÞ a ´´ x ÑÞ a y y ÑÞ free variables notice that has a side condition to the usual free variable usually this is no big deal but it causes when we want to use ramification to verify commands of the form x f p q since x is modified and we may want to refer to it in the postcondition one sufficient solution which removes all free variable side conditions is to use variables as resource but this introduces other complications another solution is to use the following variant of the rule tp u x f p q r p pq ´´ rx ÑÞ x f p q x r fv pr r p q fv pq ´´ pf q h is a consequence of and the usual rules for assignment and sequence if we are allowed to make the local program transformation from x f p q to xf p q x x in which x is always chosen fresh from now on we will sweep free variable issues under the using when needed lookup because pointsto facts may be inside shared parts of the state we find it convenient to use the global rule for lookup instead of the standard local one of separation logic lookup py ÞÑ x rx ÑÞ u x y tp u x r fv pp in fact is able to derive lookup from the standard local separation logic axiom reasoning about to set the stage for the verification of our examples we now present techniques for general reasoning about and link abstract mathematical reasoning about graphs to spatial that is and ´´ are related by p q r p q ´´ r ramification library our ramification library is a collection of lemmas that help reduce complicated and related some of the more generalpurpose lemmas which can handle simplifications such as removing frames that occur within are in fig other lemmas in our library are specific to certain data structures such as graphs we will meet some of these in § some of the lemmas in fig require that various predicates be precise which means that whenever p is satisfied on a h h def h h h that must be unique q def h h h h h ñ h h ñ h p ñ h p ñ h h all the predicates we consider here are indeed precise so this is never a concern in this paper lemmas and use ´´ the existential magic wand h p ´´ q def h p h h q this operator can be because one does not know which copy of p has been out of q but is sometimes lem allows one to frame away f within an overlapping conjunction in order to focus on an easier entailment perhaps surprisingly both p and q need to be precise for it to hold lem and are of lem for classical conjunctions although lem is more immediate the premise r p pq ´´ rq may sometimes be difficult to establish in particular one would need to show that p can always be found in a state satisfying r which is not necessarily the case it is true in the original ramification because the state satisfies pp f q r lem this by requiring the condition that if p may be found in r then any way of adding q instead of p yields r we use this lemma to prove the pop program in § lem allows one to ignore parts of the state that remain invariant during an update for instance a procedure may require some piece of state in its precondition that is not modified and thus unchanged to its postcondition for the lemma to apply that piece has to be described precisely enough by f that r is invariant under it for any other satisfying f third premise precision of p is required to force the same of r to satisfy both f true and q ´´ r second and last premises and r p f true makes sure that r always contains p f finally lem and allow one to split a ramification over either disjoint or overlapping pieces of states into over each of these states this is crucial to make the proof of some ramification modular for instance when reasoning about the effects of an update on both a global graph and a set of overlapping pointers as in our proof of algorithm see § or when proving the dag copying program of this ramification library is by no means exhaustive nor do we use all of it in the examples presented here rather we think that these lemmas demonstrate that ramification can be about using the intuition that they represent updates to the state the lemmas we will present in § for on graphs and dags further that claim exact graph and dag predicates in this section we define mathematical graphs and dags we will provide ways to reason about which involve them in the next section before we do so however let us consider whether our job would be any easier if we were only about shape instead of functional correctness eg if we tried to verify mark with the spec as in fig the proof is straightforward until the first recursive call on line after away the root pointer x ÑÞ l r we apply which the following entailment in which p frame within y ramification qq p y r p pq ´´ q y rq pp f q y r p pq ´´ pq f q y rq frame within ramification q r p pq ´´ rq pp f q r p pq ´´ pq f q rq frame within ramification p ´´ r q ´´ r pp f q r p pq ´´ pq f q rq exact frame within ramification q r p f true f ´´ r f ´´ r r p f pq f ´´ rq r p pq ´´ rq disjoint ramification r p pp ´´ rq s q pq ´´ sq r s p q pp q ´´ r sq ramification p q i p y qi p pp ´´ p y qi q p y q y q p pp ´´ p y q y qq figure some generalpurpose lemmas from our ramification library and q are the pre and postconditions from the recursive call y ´´ unfortunately this entailment turns out to be invalid recall that our ramification p pq ´´ rq idiom represents a state update in which p is substituted for q in r to yield r here this means substituting one for another which on its surface seems reasonable the problem is that the away state pq ´´ rq can have dangling pointers into the local state p if p is too as it is transformed into q then those pointers break in the state r here y lr lr l s r l l r in this example the update on dag l has node s and allocated a fresh node l instead although l is still a dag r is not so we will not be able to prove y this is not an artificial problem from our approach in fact the failure of the ramification entailment indicates that is too weak of an inductive specification changes to the pointer structure of the left could make the recursive call to the right crash and we must reflect that in the specification for mark there are several solutions to this problem but for this paper choose the most powerful proving functional correctness in § we will discuss some other possibilities that can yield more lightweight shape proofs at the cost of some additional formalism mathematical graphs we define the mathematical representation of a directed binary graph as a pv d l eq where v is a finite set of vertices d is some set of data l v Ñ d is a labeling function associating each vertex v with some data d and e v Ñ pv pv associates each vertex with up to two successors to ease the matching between a mathematical graph and its heap representation we usually take v loc and d val given a mathematical graph pv d l eq we often write x p for x p v z tu s for s v z tu and for we define the update of at node v written rv ÑÞ pd l where l r p v and d p d as rv ÞÑ pd l d l eq def pv y d rv ÞÑ rv ÞÑ pl q a node y is the successor of a node x p written x y or simply x y when is clear from context if either py or pz for some z a node y is reachable from x written x ° y or x ° y if px is in the reflexive transitive closure the reachability set of x p written xq is defined as xq def ty x ° we also lift reachability to sets of vertices s tv v sq def y ¨ ¨ ¨ y given a graph pv d l eq and a set of vertices s v it is often useful to restrict to those vertices reachable from respectively not reachable from the vertices in s written Ó s and respectively Ò s accordingly we define where f s is the function obtained from f by restricting the domain to the set s Ó s def pv sq d l v e v q Ò s def pv v d l v e v q the pv d l eq Ò s is not necessarily a graph since the edge function e may point outside of the new set of edges v however Ó s is always a graph the subgraph of reachable from s we sometimes write Ó x and Ò x for Ó and Ò by convention if s v then pv d l eq Ó s is the empty graph spatial graphs we tie a mathematical graph to a spatial graph by adding as a parameter to graph q def px dd l r pd l rq x ÞÑ d l r y q y q note that q only the spatial representation of the portion of that is reachable from x may contain other nodes this is expressed by the following lemma that a graph into its individual nodes we use the iterative star notation defined as emp if the set that is being iterated over is empty and as follows otherwise given a predicate p on x def p ¨ ¨ ¨ p lemma for every graph pv eq and node x p q ÞÑ generally speaking reasoning at this level is in program proofs and ramification allows us to remain at the level of graph instead however this lemma is useful both as a check and to prove the general lemmas about graphs given in the next section we likewise dag with a mathematical graph q def px dd l r pd l rq x ÑÞ d l r q y qq moreover the predicate q is satisfiable if and only if Ó x is indeed a dag as enforced by the in the spatial predicate lemma for every graph and variable x q q p Ó x is finally we define the following shorthand for describing multiple subgraphs of the same graph from a root set s tv q def q y ¨ ¨ ¨ y q q def q y ¨ ¨ ¨ y q if s h then both predicates denote emp reasoning about graph and dag one advantage of proving functional correctness is that we can connect our mathematical reasoning with our spatial reasoning here we state lemmas that do just that first the spatial graph and thus dag predicates are precise lemma for all s and qq our next lemma lets us collections of subgraphs provided that we preserve the set of reachable nodes lemma if sq sq then q q our third lemma helps us extend a graph with fresh nodes lemma graph growth x ÞÑ d x x rx ÞÑ pd x x ÞÑ d x r q rx ÞÑ pd x x ÞÑ d l r ru q rx ÞÑ pd l x ÑÞ d l r ru q rx ÑÞ pd l first a graph cell x whose successors are both itself corresponds to a singleton graph rx ÞÑ pd x second if a node x has a loop to itself on the left and a pointer to an existing graph on the right then we can add x to the graph not shown is the case when the loop is on the right third if x links to two possibly equal graph nodes then we can again add x to the graph the first two cases need to be stated separately because x r means that q is k finally is the analogue of for dags we do not need for and because dags must be acyclic the frame rule combined with the between a parent and its descendants and equation is enough to the root of a dag however an unrestricted graph has y between the parent and its successors so we need to use to update the root the following lemma helps the associated lemma single graph node update pd l rq rx ÑÞ pd l l ru y s q x ÞÑ d l r px ÑÞ d l r ´´ l ru y s qq pd l rq rx ÑÞ pd l q x ÞÑ d l r px ÞÑ d l r ´´ qq lem handles the cases in which we are adding a fresh node so in we need only consider the case in which tx l r l ru the case of interest is a full update to node x where we are updating not only the data d to d but also the pointers l and r to l and r respectively the precondition is a set of subgraphs of including x l and r as well as arbitrary others s after the update the state contains subgraphs at x which now contains l and r and s as well as the old l and r previously contained in the old x which may now be from y s in practice we often care about far simpler updates is a direct consequence of and handles the case in which we only wish to update the data field next we observe that an update that preserves the set of reachable nodes cannot remove any overlapping pointsto fact the same remark is true of dags as well replacing graphs with dags everywhere in the lemma below rx ÞÑ pd x def d rx ÑÞ ds rx ÞÑ px observe that r can be equal to in which case q is just emp lemma pointsto preservation sq sq q y x ÑÞ ´ q q ´´ q y x ÑÞ our final lemma applies when we wish to update an entire subgraph typically with a function call rather than a single node lemma subgraph update s q sq Ò s Ò s q y q q q ´´ q y qq s q sq Ò s Ò s q y q q q ´´ q y qq first lets us an update to a subgraph or set of subgraphs as long as all previously reachable nodes are still reachable to prevent eg the dangling pointer problem outlined in § and the mathematical update is local second gives us the same property for dags if our newly substituted does not contain a cycle then our whole dag will not become cyclic proving mark on dags we are ready at last to off the proof of mark from fig mathematical marking one of our goals is to translate reasoning into spatial reasoning define the mathematical marking mp rq of a graph pv d l eq starting from the vertex r p v as marking all nodes reachable via nodes from r formally define a new relation as follows x y iff dz p y p z as before we omit the subscript when it is clear from context and write ° of from for the reflexive r is then pv d transitive closure where for the all x marking pv mp rq if r ° x otherwise we also need to describe the effect of marking a single node in accomplished with mp xq that sets the marked bit of node x in to the following lemma about mathematical markings now becomes crucial to prove the functional correctness of mark lemma for all graphs and nodes x y p xq xq moreover if pd l rq then xq lq rq lq xq rq lq rq xq rq xq lq mp xq that is we can swap the order of two mathematical markings and regardless of which order we mark the root and children either child first by equation at the end we are fully marked spatial marking our first remaining tasks are the on lines and in both cases we frame away the root node and then apply yielding the following q y q q mp ´´ mp y mp mp y mp mp lq ´´ lq y lq observe that the first ramification directly implies the second by instantiating with mp lq in the first entailment and using the commutativity of y to swap the roles of l and r to prove we apply lem to reduce the spatial ramification entailment to a pair of mathematical the first mathematical lq lq lq ie that every vertex reachable from l in the old dag is still reachable from l in the new dag mp lq is immediate because the mathematical marking function m changes neither the vertices nor the edges of the dag the second mathematical mp lq Ò l Ò l ie that the part of that is not reachable from l is identical to the part of mp lq that is not reachable l is almost as simple by the definition of m we know that the only difference between and mp lq is that the new labeling function has marked vertices reachable via paths in from l all other labels are maintained since the second mathematical only about changes to the portion of the mathematical graph that is not reachable from l and those labels are unchanged we are done finally to establish the postcondition in line from line apply lem to derive lq rq which by lem is equivalent to our postcondition observations our proof of mark ie fig and § is short and our invariants at each program point are straightforward we were able to reuse our initial ramification to prove our second essentially all of the spatial difficulties were handled by our ramification library moreover by lem our proof is easy to modify to accommodate trivial changes in the program like moving the update in line to after one or both of the recursive calls in lines and the order of the recursive calls etc our ability to accommodate these kinds of changes is an of the power of using ramification to separate mathematical and spatial reasoning from each other in contrast previous work on verifying these kinds of algorithms used complex and invariants so that they could always apply the frame rule for example consider et al which is the of most previous work in applying separation logic to reason about data structures with sharing et al define mathematical dags as terms whose nodes are either labeled proper nodes written x node l r or references to a label elsewhere in the dag written ptr x to express sharing their spatial predicate grants ownership of a node at the point that corresponds to where it is declared in the mathematical definition roughly speaking x px node l rq def x ÞÑ v l r l l r r but not when it is referenced again similarly x xq def emp each node can only be declared once although it may be referenced many times and the order in which they are declared must match the order in which the program traverses the dag as the authors note § p this predicate is specifically designed to support a left to right scan as are the formulae on which it is based it seems difficult to avoid this unfortunately the consequences of this style of definition to many other parts of the associated verification including the statement of the specification of mark and its exact implementation changes in one part of the system eg the order of traversal required changes to other parts of the system ie the definition of the specification of mark and the invariants at each program point the style of the state into many disjoint pieces to reason about data structures with sharing a heavy price to enable the frame rule resulting in subtle § p definitions and in contrast our definition of mathematical graphs is traditional our dag predicate is natural and our specification for mark is straight forward none of these depend on internal implementation of the algorithm such as traversal orders moreover our program invariants are easy to understand easy to update to accommodate minor changes in the algorithm and easy to verify using ramification and our ramification library are both more natural and more robust than those in previous work marking possibly cyclic graphs the mark function can also mark unrestricted graphs because lemmas and both apply to graphs as well as dags the only substantial change to the the proof in fig is for line here dags only require the frame rule due to the between a parent and its children but unrestricted graphs require an additional ramification due to the additional y x ÑÞ l r y ru q x ÑÞ l r px ÞÑ l r ´´ x ÑÞ l r y ru mp this ramification follows directly from lem termination our work here is primarily concerned with partial correctness but suppose we were interested in total correctness as well the dag argument is simpler each recursive call is on a strictly smaller thanks to the between a parent and its children notice that this argument is valid regardless of whether we mark the root first at line or after one or both recursive calls in contrast the termination argument on unrestricted graphs is more complicated because the y between root and successors means that the may not be any smaller at the recursive calls instead each recursive call must be on a graph with fewer nodes if we before coloring the root then we may not terminate other graph algorithms to prove that ramification can apply equally well to programs that unlike mark the link structure of the graph we also verified and the full details are in a and b respectively here we give only the key insights copying dags the goal of the function is to make a deep copy of its argument it uses a data field in each original node to record the location of its corresponding copy or if the node has not yet been copied just as with mark a straightforward recursive implementation is compact and works as follows if the root is already copied then return immediately otherwise recursively copy the left and right children allocate a new node to be the roots copy and set its fields as appropriate to make the verification together we need to add a new feature to our separation logic regions lg briefly regions indicate disjoint in the heap and a spatial predicate p can be tagged with a region identifier to become p indicating that p is entirely contained in region predicates in different regions are always disjoint even when connected by sharing operators such as y regions are useful when we are with the following problem in which is some sharing operator such as or y pp sq pp rq that is we have some disjoint formulas p and q which overlap with two additional disjoint formulas r and s and we wish to resources around until the p and q are overlapping with each other and are disjoint from the overlapping q and s the direction is immediate unfortunately verifying requires the direction after making both recursive calls and reaching the following invariant in which l and r are the left and right children of the root and ll and rr are their respective copies q qq y q qq now we need to apply the rule of consequence to the original children from their overlapping copies q y qq q y qq struct node struct node next lr void pop void if s return struct node c s ÞÑ n l r c su s ÑÞ s l r ÞÑ s l r z z t ÞÑ s ´ ´ q c ÑÞ ´ ´ ´ c ÑÞ ´ ´ free c figure removal from a tree the problem is that the implication is just not true without carrying around some additional information via regions specifically that the original dag is in region while the copy is being created in region in general regions help because they ensure that p does not have any overlap with s despite the intermediate sharing operator pp sq pp rq others have run across the same problem in contexts including and shape analysis for lists and trees and have turned to regions for similar reasons interestingly our verification also uses regions in an novel way to split one large ramification entailment equation into two smaller via lem from our ramification library this second use of regions is not to verify but it does simplify things other than the use of regions the verification proceeds straightforwardly graphs a graph is usually done in two steps first all sharing between nodes of the graph so that each node has at most one predecessor thus computing a spanning tree of the graph and then the tree b contains the novel verification for the first step verifying the second is standard the real proof effort is on the mathematical side the spatial aspects of the verification are no more complicated than mark and and do not require regions because our definition for graph uses y we are able to establish emp at the end indicating that we have completely the structure data structures reasoning about trees our examples so far have focused on graph ramification is also applicable in other interesting contexts including data structures here we focus on one kind of structure trees which lists and trees each node has three links to other nodes of the data structure a next pointer of a list and the left and right fields of a binary tree this is a popular type of data structure the linked list may record the set of elements some order of particular interest eg to most recent while the tree provides efficient lookup our case study is a procedure that removes the first element of the linked list from the data structure inspired by what can be found in the linux io scheduler the code and annotations are shown in fig it assumes two global variables s and t that point respectively to the head of the linked list and the root of the tree the precondition states that the two shapes span exactly the same memory cells enforced by the conjunction removing from the list line merely advances the head pointer but we cannot stop there because it leaves the structure in an inconsistent state the items in the list and the tree must be identical removing from the tree is likely to be operationally complex potentially involving operations to or otherwise parts of the tree thus we abstract this operation and assume that it is performed by a function its spec has to express two particular facts to ensure that it is wellbehaved wrt the list structure it must not with the list fields and the resulting new tree should cover the same nodes as before except for c we enforce the first constraint by not giving any access on the list fields to the procedure ie by restricting its precondition to the skeleton of the tree and the second constraint by recording the set of nodes in the tree shape we therefore define the following predicate that the list fields of each node q def px emp dl r l r x ÞÑ l r lq rq z l z r the tree predicate can be split into a skeleton and a bag of pointsto predicates using the pointers predicate def x ÑÞ ´ ¨ ¨ ¨ xn ÑÞ ´ d q the list predicate is defined in the standard way for acyclic lists with two data fields def pl dl x y l ÞÑ l x y we moreover assume that each address is aligned as a multiple of to prevent in which a node in the tree might overlap two nodes in the list in a state satisfying a general observation about how data structures are manipulated is that changes to fields of only one structure do not affect the other eg list induction easily proves that x ÑÞ n l r ´´ x ÑÞ n l r ´´ this reads as if a state may be completed by a node to form a linked list then it by any other node at the same location and with the same next field also yields a list the same property for skeleton trees follows by induction on the size of the tree q ´´ q ´´ verification the spec of follows the discussion above qc ÑÞ ´ the proof sketched in fig is mostly straightforward if s is nil then the list is empty hence so is the tree and the postcondition is trivially satisfied otherwise we unfold the list predicate which enables the lookup at line after that we split the tree according to and apply the following ramification pc ÞÑ s l r z c ÑÞ ´ ´ z z q ´´ pc pc ÑÞ s ´ ´ ÑÞ ´ ´ q z this ramification follows a general pattern and we can reduce it to a much simpler one by that the righthand side conjunct is automatically handled by lem from our ramification library which can remove frames that occur within this yields the following simpler proof obligation z ´´ c ÞÑ x y z c ÞÑ ´ ´ q ´´ c ÞÑ x ´ ´ this entailment is similar to the rest of the proof is immediate garbage collector it is time for the test verifying the functional correctness of garbage collector the general setting is as follows there are two disjoint equally large regions of memory the and the starting respectively at the address pointed to by from and to programs manipulate objects in the when the program to allocate but the has run out of room we garbage collect by copying the entire graph of reachable objects into the before from and to and normal execution if the former had any unreachable objects then the new has some free space in the of previous work we make a number of simplifications we assume that there is a single root from which all active objects are reachable ie any object not reachable from that root can be safely we also restrict our study to objects that contain only pointers including the null pointer rather than arbitrary integers our proof can be modified to verify the algorithm eg we can allow data by the usual systems of requiring that data be odd and pointers be even algorithm the graph from one space to the other using only a constant amount of extra memory which is in short supply during garbage collection contrast this with our example of that required linear additional space in both the data fields and the function stack the cost is that we the original graph which we can live with because it will be garbage the trick is that the first field in each object in the to point to its copy in the the collector can determine whether an object has already been copied and moreover discover the address by checking if its first field points into the following we implement the algorithm as two functions collect and shown in fig in addition to the to and from pointers fixed for the of the collection they maintain two additional pointers into the first the scan pointer the scanned objects whose pointers point into the from the objects whose pointers point into the second the free pointer distinguishes the first unused address in the initially line scan free to meaning that no objects have been copied and the entire is free the process is by copying the object pointed to by the root r line which allocates two cells of memory at the beginning of the by increasing free and them with the values in the original object now after that the program loops lines ­ until no objects remain calling on both object fields lines and before scan to indicate that the object has been scanned each call to the pointers into the newly encountered nodes as necessary fig presents an intermediate state in the execution with one node copied and scanned and one node for scanning formal specification to represent states of the execution we use the following definitions mathematical graphs are pairs pv eq ie we remove d and l and the spatial predicate is accordingly q def px dl r pl rq x ÑÞ l r y q y q we define shorthand to express whether a node is in the from or and whether it has been copied recall that to from and size are constant throughout the execution def x from x from size def x to x to size copied p xq def x we write for v p and similarly for the memory also contains a pool of free addresses starting at some x and the whole which we use to collect nodes that the algorithm ie objects that are no longer reachable from the and are therefore fresh garbage def to size ´ def from size ´ the main property of a garbage collector is that the final graph is isomorphic to the original one in the middle of a void r ÞÑ r q y scan free to while scan free r ÑÞ to q y to « r scan r ÞÑ to q y scan ÑÞ q q y q y q y scan scan free to ´ « r qq y q y r scan free scan ´ to « to r ÑÞ to q y scan scan scan scan r ÑÞ to q to « r void void p pp ÞÑ q y qq q p f q free f if p pp ÞÑ q y q ÞÑ a b y q y qq q p f q free f void obj p void obj pp ÑÞ obj y obj ÞÑ b y q y qq q p f q free f if to to size pp ÑÞ obj y obj ÑÞ b y q y qq q p f q free f p pp ÞÑ y obj ÑÞ b y q y qq p p p f q free f q rp ÞÑ f to else pp ÑÞ obj y obj ÑÞ b y q y qq q p f q free f void new free free free new obj new obj pp ÞÑ obj y obj ÞÑ b y q y qq b p p f q free f new f y new qq ÞÑ b y free f p f q new f ÞÑ bs y new qq ÞÑ b y p f q free f new f ÞÑ ÑÞ bs y new qq ÞÑ b y ÞÑ bs pp ÑÞ q y q y qq ch p Ò tp to « to free f figure proof sketch of garbage collector to scan free figure state of the memory during garbage collection previous field values are indicated by or dotted pointer arrows s f q def q tv copied p pf ´ f ´ u Ó to v p a b pa ñ s pv s s pv s ñ b « figure graphs parameter s is the first address and f is the beginning of the free space there are as many nodes in the as there are copied nodes which ensures that we never our free space at line every cell in the is reachable for each object either it is in the and either scanned with fields pointing to the or with fields pointing to the or it is in the with fields either entirely pointing to the or with first field pointing to its copy in the in which case the second fields of the object and its copy point to isomorphic subgraphs collection the loop invariant is more complex for it is that the graph rooted at to is isomorphic to the original one upto a function the of a graph pv eq already copied nodes by following their first field which points to their copies formally is the graph pv eq where v tv p v copied p and if pv then pv v q with vi vi if copied p otherwise we write x « x to denote graph isomorphism between Ó x and Ó x both and imply so at the end of garbage collection when the entire graph has been moved into the we will have standard isomorphism between the old graph and the new the main constraints satisfied by the graph are enforced in the mathematical world by the predicate shown in fig additionally the following invariant is implicit throughout the proof to scan free to scan free q here even forces all objects and global pointers to be aligned on even boundaries notice that a graph entirely in the is automatically a graph ñ to similarly if to p and s f then s f q ñ these observations are enough to go from the precondition to the loop invariant and from the loop invariant to the postcondition verification of we omit the simpler spec of that applies the first time it is called in collect line and focus instead on the calls made from the main loop lines and one field of a object from its original target in the to its targets copy in the if the target is then no action is required and the post is direct from the pre otherwise we can unfold the graph line to expose the target object in the we then examine its first field if is in the then the target object has a copy located there and we the pointer to it the ramification immediately follows from lem slightly modified to handle updates and updates the graph to rp ÑÞ where a single field update rx ÑÞ ys corresponds to rx ÑÞ y if x is even and to rx ´ ÞÑ ys if x is odd the actual proof effort at that point is to establish p and to « to the former holds because the only update is that p changed from in to scanned in p p and from pointing to the to the for the latter notice that so p to point to gives the same canonical graph hence to « to if the object has not been copied yet we two units of space at the position of the free pointer by it line and fill them with the objects fields since the pool of free space is kept separated from the current graph of objects frame is able to deal with the heap up to the assignment at line now we rewrite the state to integrate the new object into the main graph lem then both the current field p and the first field of the target object obj to point to the copy new yielding two successive that update the global graph accordingly which we can with lem once again and our library allow us to progress past updates to the shared state the actual complexity in establishing mathematical facts about graphs in the postcondition their proof is similar to the case in which was in the to begin with we have to prove that new is reachable from to as required by which holds because p is reachable from to and points to it the isomorphism holds because new and obj have identical contents verification of collect the main function first copies the root node in the graph using an alternative simpler spec for to establish the loop invariant line in which we leave out the case r of an empty graph it then enters a loop that updates both fields of the first object in which may queue up new objects until all objects have been scanned the looping condition allow us to go from the invariant at line to the assertion at line in particular to ° scan by so lem applies the ramification at line makes interesting use of our ramification library lem tells us that each individual pointer in as well as the other field of scan is preserved combining this with lem yields that the whole of is preserved the graphs are updated thanks to lem we finally combine both our conclusions with another application of lem to deduce line we fold back the subgraph rooted at scan into the main one rooted at to which leaves the following spatial deduction which holds because together q and contain the whole allocated heap q y q y q y the second call to is analogous to the first and after we advance scan we reach the loop invariant related work garbage collector has been a benchmark of sorts for verification especially in separation logic may previous by the spatial graph into its individual nodes and those into several disjoint groups corresponding to the intersections of various heap regions from and scanned and in the above proof the global variable free is modified by but appears in our assertions we this issue by treating free as a resource we remove our knowledge about free when is called and only get to assume what is in postcondition in the state eg line r p pq ´´ rq tp u c x fv pq ´´ rq h tp pq ´´ c tq pq ´´ frame c figure proof of q pq ´´ rq r consequence etc our approach uses a single generic inductive graph predicate and the of reasoning about those regions is handled at the level of mathematical graphs this division of yields in our a much more and concise proof which relatively intuitive and natural invariants strongest and extensions here we discuss the general applicability of the rule as well as an alternative form of the rule we also discuss a number of extensions to apply to more examples including the overlapping conjunction y regions and higherorder settings of ramification in § we showed that the frame rule was a consequence of the rule somewhat surprisingly the converse is also true theorem tp u c r p pq ´´ rq fv pq ´´ rq x c h proof by the short derivation given in fig because theorem only requires frame and consequence is valid in any separation logic this is very because it means that we do not need to modify the numerous of separation logic in previous work to incorporate ramification it has been there all along just waiting for its importance to be recognized weakest preconditions and strongest postconditions in fact our rule appears in the separation logic as a weakest precondition rule as follows lemma weakest pre given a postcondition r and a specification tp u c then p pq ´´ rq is the weakest precondition ie given any specification c then r p pq ´´ rq our examples demonstrate that we can successfully with weakest precondition can we also succeed with strongest postcondition ie with the following forward rule tp u c r p true pp ´´ rq q r c the pp ´´ rq q r pattern is of a pattern used in vp to characterize stability by setting r to r in the focus is on concurrency and a threads may take an unknown number of actions in our setting we know that a given specification will execute exactly once which we by allowing the to be the more general r rather than r when p is precise gives the strongest postcondition lemma strongest post given precondition r and tp u c if p is precise then pp ´´ rq q is the strongest postcondition as it happens whenever p is precise and are each derivable from the other however precision is actually only needed when starting from and so we consider to be fundamental moreover although we were able to prove some of the examples using we found its ´´ idiom to be harder to reason about than the ´´ idiom in extensions supporting ramification we can in any separation logic but verifying certain programs can require various extensions such as regions in here we detail other extensions starting with a more careful look at y the overlapping conjunction y although the overlapping conjunction y appears in the literature under such names as fusion conjunction and its properties are not for abstract separation logics a separation algebra is a partial commutative monoid with ps q that provides an abstract model for separation logic although the overlapping conjunction y can be defined in any separation algebra it is not necessarily easy to use in fact several critical properties require stronger separation algebra axioms we propose using a variant described by et al that has multiple units disjointness ie x x y ñ x y and a kind of distributivity property called cross split a b z c d z ñ ad bc bd ac ad a bc bd b ac bc c ad bd d ab c d ac bc ad bd that is if an element eg a can be split in two different ways then there are four subobjects which partition the original and respect the original cross split is not discussed much in the literature but we discovered that it is for reasoning about the overlapping conjunction y which is not even associative without it in fact all of our proofs that use y assume cross split by no means algebras used in practice satisfy cross split including the canonical model of as partial maps from addresses to values are found by set intersection on the domain users of our theory must therefore verify that the separation algebras they care about satisfy cross split explicit overlapping conjunction and proposed a generalization of p y q that tagged the shared core with an explicit description c cb defined as follows h p xy def h h ph h h sq ph h p q ph cq ph h qq this explicit overlapping conjunction is more expressive than y p xy p y q moreover and developed the following proof rule tp u c pc ´´ rq c r q c true tp xy c unfortunately is not useful to verify any of our examples because we focus on unspecified is we do not know exactly what the overlap is eg the precise nodes shared between the children of a dag node and hence cannot pick c or c other than true in general unspecified sharing is more difficult to verify than specified sharing which is apparent when one tries to apply ´´ rq true r in other words start from r remove an unrestricted replace it with a second unrestricted heap and now prove r conversely cannot verify our example § because instead of c and c being too weak they represent the entire structure ie p c r and q c r applying then makes no progress because the simpler hoare tp u c is actually identical to the goal all of that said and demonstrate how to use to verify programs that operate in the special case of specified partial when nontrivial c and c are known and not the entire p q r or r is derivable from so we can reuse all of their fractional shares actions and tight regions in § we pointed out that attempts to verify mark using the predicate were unsound in this paper we focused on functional correctness instead but we also various other methods for that the graph is not including fractional shares actions in the style of and a variant of regions that could prevent memory deallocation each method had some benefits but also required some additional formalism the tradeoffs were higherorder settings in recent years there have been several of separation logic to reason about higherorder state such as the resource invariants of concurrent separation logic with firstclass locks although we did not do any for higherorder settings which are often very complicated in ways to their we did check a few of the from this paper in coq within the framework of separation algebras and believe that the by itself no fundamental difficulties related work there is a large body of work orthogonal to ours the design and proof of algorithms for data structures with sharing its counterpart in program verification a range of domains and we begin this section with other separation logic based analyses our reasoning about graphs a lot to the overlapping conjunction y which has roots in relevant logic many people have it in the context of separation logic who defined inductive graphs and dags as we did but did not provide a means to reason about them and were able to reason about a specified version of y using a more domainspecific framework than ours as discussed in § more recently et al and et al have used some form of ramification to verify respectively implementations of trees and programs that follow the pattern both of which involved unspecified sharing their are restricted to adhoc ramification operators for each example and the logic itself is domainspecific and done modulo a predicate on the global heap it would be interesting to try and their proofs in our setting lee et al an automatic analysis for trees that the results of separate analyses for lists and for trees moreover several works have dealt with definite sharing in separation logic eg linked lists trees with parent pointers skip or cyclic lists etc in these cases one always knows what is shared and by on the other hand handling sharing such as in this paper was achieved only by to that specified or avoided the sharing proof of the graph marking algorithm § later mechanized in mn does not define a spatial graph predicate but rather describes the graph by its spanning tree attempts to lift this kind of reasoning to other algorithms on dags and graphs has led to predicates that explicitly deal with sharing and data structures into pieces often in ways to the behavior of the program at hand several other frameworks have dealt with sharing in programs in shape analysis can prove data structure consistency when one can expose a into which objects ultimately point and has been used to prove partial correctness of a garbage collector and the algorithm and have used to automatically verify garbage collectors hp however these works do not provide compositional reasoning for sharing it would be interesting to see if we can import ramification into other frameworks such as whose reasoning about the heap is based on dynamic frames a of separation logic conclusion we have presented a new paradigm ramification valid in any separation logic for the compositional verification of programs that manipulate data structures with both specified and unspecified sharing we gave a ramification library that helps simplify ramification in general and reduces local spatial updates to abstract mathematical reasoning we have demonstrated the applicability of our framework by providing concise local specifications for a range of examples and data structures including garbage collector these initial lead us to believe that ramification provides a robust basis for elegant compositional reasoning about sharing in data structures acknowledgments we thank peter ohearn for his continuous help and we also from discussions with berdine richard david walker yang and especially with matthew parkinson who first suggested that our initial semantic account of ramification was expressible as a separation logic entailment finally we thank the anonymous reviewers for their suggestions and this research was supported by a lee and grant resource reasoning references r c calcagno and p ohearn local reasoning separation and aliasing in space r c calcagno and h yang variables as resource in separation logic r proving pointer programs in hoare logic in cb r and j o local reasoning for abstraction and sharing in c j a nonrecursive list algorithm c acm c calcagno p w ohearn and h yang local action and abstract separation logic in lics r a and a w appel a fresh look at separation algebras and share in fin j exploiting constraints in design synthesis phd thesis stanford university h correctness proofs a case study of algorithm in p s and g d smith towards a program logic for javascript in popl a a w appel and f oracle semantics for concurrent separation logic in esop a r and a w appel a logical mix of approximation and separation in hp c and e automated verification of practical garbage collectors in popl io s s and p w ohearn bi as an assertion language for mutable data structures in popl n l birkedal and j verifying programs using frame properties in k r m leino an automatic program verifier for functional correctness in lg j m and d k polymorphic effect systems in popl o lee h yang and r program analysis for data structures in cav may n r and a formal verification of the heap manager of an operating system using separation logic in mn f and t proving pointer programs in higherorder logic inf comput h f l birkedal and p formalized verification of trees separation and sharing in r s sagiv g and j field partially disjunctive heap abstraction in sas j c reynolds intuitionistic reasoning about shared mutable data structure in in computer science of computing j c reynolds separation logic a logic for shared mutable data structures in lics j c reynolds a short course on separation logic m the problem a solution to the problem of models artificial intelligence n l birkedal and j c reynolds local reasoning about a copying garbage collector acm toplas a semantics for relevant logics j log v vafeiadis modular finegrained concurrency verification phd thesis university of cambridge vp v vafeiadis and m j parkinson a of relyguarantee and separation logic in concur t v p lam a podelski and m c rinard field constraint analysis in h yang local reasoning for stateful programs phd thesis university of illinois a copying dags the program in fig makes a deep copy of a dag using a data field in each original node to record the location of its copy when it exists or otherwise initially all the copy fields of must be set to and at the end all the nodes reachable from x will have been copied into a new dag whose root is returned by in the intermediate recursive calls parts of the dag rooted at the argument will have already been copied to cut down on the amount of formalism we must present to verify a specification for we will regions in the following adhoc way we assume two regions and bound at the top level in the meta context the initial dag must come in region and malloc always allocates in region the new copy will be in and the original will remain in this specification is not as general as one would want since eg it prevents us from verifying the copying of a copy a far better specification would take the regions as parameters but all of the extra would be in the orthogonal region management system rather than in the such a system would have features such as generalpurpose region creation destruction and merging as well as a good handle on region variable scoping describing completed and dag copies we represent an entirely copied dag pv d l eq rooted at x and its copy rooted at y by the predicate y q or double dag y q def px y q y y q the nodes in the first dag are described by the graph because we store the addresses of the copy in the data fields is also enough to struct node struct node struct node struct node x struct node rr y if x return if xc return xc l xl r xr y node x c y x ÑÞ y l r q y qq y ÞÑ ´ ´ ´ p l rq ll l pq x ÞÑ y l r ll q y qq y ÑÞ ´ ´ ´ p l rq l rr r pq x ÞÑ l r ll q y rr qq y ÑÞ ´ ´ ´ p l rq l r y c y l ll y r rr x ÞÑ y l r y ÑÞ ll rr ll q y rr qq p l rq l r return y y q x u figure proof sketch of dag copy describe the copy via pv d l eq where v tv dv p v v v u dv p v pv l rq pl rq if l lq r rq the predicate describes the postcondition for our next task is to define the precondition because some parts of the dag may have already been copied the dag predicate q describes a single dag in region and a set of dags in region corresponding to any previously copied q def q px q pr px q processed roots finds the roots of the copied h if x pr px q def q y pr pr q if p l rq otherwise observe that when x is copied ie py l rq and y then q y q we will use this equivalence to move between the precondition and the postcondition when we discover that the dag is already copied when we wish to reason entirely about the copies we write q ie copy dags for px q note that if x is not yet copied ie p l rq then using the second case in the definition of pr we deduce that q q y q and thus q x ÞÑ l r qq finally to reflect the fact that already copied parts of the dag will not be changed by we define the relation x between two dags pv d l eq and pv d l eq true when Ò x Ò x and Ó x is more copied than Ó x v p xq ñ ñ q we will write when dx x verification of now we annotate the program in fig with the key assertions to prove the following specification y y q x u if the dag is empty then the postcondition is trivially satisfied line if the node has already been copied line then equation yields the postcondition the real of the algorithm is in the from the two recursive call sites and the entailment of the postcondition from line the two are as follows q y q q ll q l ´´ ll q y q l q q y q q rr q r ´´ ll q y rr q r q as with mark the second ramification follows from the first by the roles of r and l and observing that when y q q y q y q regions let us split the first ramification using the lem from our ramification library yielding two simpler in which l and by the definition of l ll ´ the first half of in region q y q q q ´´ q y qq is direct from lem the second half of in region is q q c q ´´ c q y qq where c this ramification is more involved because the copied roots of starting from r may differ from the previous ones in instantiating lem with s pr p lq s pr p rq and s yields this entailment which is only there because it features the rooted at pr p rq whereas we want those rooted at pr p rq q y q q c q ´´ c q y p rq c qq to complete this proof we remark that the copied roots of r in and in satisfy the following relations hence lem applies pr p rq pr p pr p rq pr p rq y p q p l q to reach the postcondition from line the on each side of the overlapping conjunction need to be from the original using regions and equation in the following derivations where p l rq l and r x ÑÞ y l r y ÞÑ ll rr q y q q rx ÞÑ py l y q x the last deduction step uses this mathematical fact p l py l rq l r ñ x b a graph let us show how to verify the depthfirst search spanning tree procedure for binary graphs as presented in fig the desired toplevel specification for spanning is that starting from an graph we remove some edges indicated by the predicate and get a tree that covers the same set of nodes q q xq the predicate pv d l eq pv d l eq is true when pv d lq pv d lq and e has fewer edges than e v p v pl rq ñ pl p tl ur p tr u void node x q p ´ struct node lr l xl r xr tx ÞÑ l r y q y q p l x m x ÑÞ l r y q y q p l rq mp xq if l l m x ÞÑ l r y q y q p l rq mp xq p ´ spanning l e ls e x l x ÑÞ l r y q y pl q q q p l rq mp xq p ´ y mp lq lq lq ¨ ¨ ¨ if r r m spanning r ¨ ¨ ¨ q y px q q mp xq xq xq figure spanning tree of a binary graph during the execution the graph will be partially marked and the effect of spanning on such graphs is thus assuming that the root x of the graph has not been marked yet it transforms the part of that is reachable from x it was not apparent in the toplevel specification xq xq into a tree covering the same nodes with some subgraphs as seen in fig these extra subgraphs are precisely those that start at a marked node reachable from x via nodes in the original graph using the pr predicate from a the proof of spanning has four main branches corresponding to whether each of the left and right subgraphs has to be examined or not notice that spanning assumes a nonempty graph as a precondition in fig we only show the proof sketch corresponding to the case where the left subgraph was nonempty and marking the root x is done as in mark for graphs to handle the recursive call of line we have to prove the following ramification q y q q q y pl q q ´´ q y pl q q y qq rewriting q as q p Ó l is a using an analogue of lem for trees turns this ramification into an application of lem the same trick can be used to obtain the first disjunct of line corresponding to the case where was applied while the second disjunct is an application of lem because the nodes covered by the subtrees at l and r are marked and form the same set as the nodes reachable via paths in the graphs before each recursive call we can both trees and the roots in the first disjunct of line to form the spatial part px ÞÑ l r q qq y pl q q y pr q q the post follows from the pure facts the other are similar 