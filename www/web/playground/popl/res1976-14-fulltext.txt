primitive recursive program transformation r s ij s moore and r e abstract we describe how to transform certain flowchart programs into equivalent explicit primitive recursive the correctness conditions for the are more amenable to proof the verification for the corresponding flowchart programs in particular the transformed correctness conditions can often be verified automatically by the theorem prover developed by and moore i key words lisp program induction theorem proving verification structural introduction experiments with the theorem prover developed by r and j moore i have shown that structural induction in combination with symbolic evaluation and some generalization heuristics can be used to prove properties of a wide variety of lisp functions completely automatically the key property of these functions making them amenable to induction is their explicit primitive recursive specification roughly speaking the explicit primitive recursive form produces the effect that when the formula to be proved in the induction conclusion is symbolically evaluated it assumes the form of the induction hypothesis in order to use the theorem prover on flowchart programs it is necessary to translate the into functional form the approach is that described in which produces partial recursive specifications one is then forced either to extend the theorem prover to with a limited class of partial recursive specifications tag moore does in or to further transform these specifications where possible into explicit primitive recursion in this paper we are concerned with the second approach i rs is employed by stanford institute park california this work was supported in part by contract n j s moore is employed by xerox palo alto research center palo alto california r e is by stanford research this work was supported in part by contract no of course not all programs compute primitive recursive functions for example programs that compute function or that interpret fortran programs compute partial recursive but not primitive recursive functions furthermore it is undecidable whether a function for which a partial recursive definition is given is primitive thus the method described here is not applicable to arbitrary flowchart programs but only to those certain schemes known to describe primitive recursive functions an example our approach is best outlined with an example although we have restricted our presentation to the domain of lists and numbers the general ideas are more applicable figure i shows a program computing the int that converts a binary number represented as a list of ls and os into an integer the program the input list from left to right at each position scanned it the value of an a and adds the of the scanned bit after all bits have been scanned the value of the is returned consider the theorem stating that a binary number ie a onto the right end has the effect of that numbers value il intl where is understood to be a universally quantified variable ranging over all lists of ls and s the first step in proving tile theorem is to convert the flowchart program into functional form has shown that one can do this in a mechanical way for arbitrary flowchart programs by introducing a new recursive function for each tag point h the above example one obtains o i x x j i i no ii i i x c a l f x where l int if x nil then a else int xa the theorem to be proved can now be stated one might now be to try to prove using structural induction on l the basis case l nil goes through easily because both sides of symbolically evaluate to the induction step however does not go through for that step one assumes the induction hypothesis and tries to prove int l where is a variable ranging over the set i symbolically evaluating both sides of gives at this point if all had well we would have been able to invoke the induction hypothesis and been done but although is similar to it is not quite the same specifically the second argument place of intl is filled with in the one case and with b in the other the source of the difficulty is that the form of the definition of i n t l is not primitive recursive in the primitive recursive form requires all parameters but the control parameter ie the one in the first argument position of intl to be in the internal recursive calls in the definition of intl however the second argument is changed from a to transformation to primitive recursion the solution we propose here is to transform the recursive definition of intl into one that is primitive recursive the transformation works on all functions that are instances of the scheme if px then else where p g n and h are primitive recursive the primitive recursive transform of f is f where and are primitive recursive functions whose definitions are below if px then x else if then y else if px then nil else and rev is the primitive recursive function which a list if then nil else the justification for the theorem is as follows let xi d e n o t e and let k be the smallest nonnegative integer such that then gx k however f i n a l x x xk and s e q x x x x x k l thus r e v s e q x x xk xk x x so that f i n a l y r e v s e q x x o y o therefore gx hx y · which is just by informally constructs a list of the successive values x will take on during the computation of f this list in reverse order is then given to which computes the final value of the y this value and that of which is the final value of x is then given to g to compute the final output of f in the special case where px is nx is and can be expressed as a function h of and y the transform is simpler where we use h for h in the definition of the informal justification of this is that if the final y can be computed only in terms of the of the successive values of x then we need not compute the sequence of x values but merely the sequence of values but if p and n are as above this sequence is just x it is easy to see that i n t l is an instance of the scheme described by f and in fact is an example of the simpler case since we can let px y nx y thus we get where f i n a l a is if then a else car x f x a given this definition of intl the example theorem becomes l i st while this theorem is somewhat more complicated syntactically than all of tile functions in it are primitive recursive and it can be proved immediately by the theorem prover described in i discussion the idea that flowchart programs can sometimes be replaced by explicit primitive functions was first mentioned in the work of r peter to quote from pp it may be seen in a similar way that in general a recursion of the form aa n ia and even a definition of the form aa n ia i ar i ry i i ar ny na i i a r i of a function with arbitrarily many argument places does not lead out from the class of primitive recursive functions result for the two argument case is easily seen since it is just the justified above this theorem can actually be proved completely automatically by the modified theorem prover described in proof of the theorem is somewhat complicated because she carries it out in number theory where a enumeration method must be used to express the notion of the list of xs used in the computation of f as noted in the introduction it is possible to avoid the translation of the partial recursive specifications into primitive recursive ones and still prove many theorems moore describes how roughly stated approach requires of the original theorem prover first the induction principle must be o that to prove for all x and y where y is used as an in some function f in co one first proves for all y and then inductively assumes for any expression e and proves moore explains why this is a valid induction principle also cf pp the choice of the expression e is left to the theorem proving process and moore explains how it can be determined from the definition of f the second required in is the extension of the generalization heuristic so that argument positions which initially contain constants can be replaced by expressions containing free variables allowing the use of the induction method above this generalization introduces a new function called the function into the positions it turns out that function is just our the method of translation into primitive recursive form proposed in this paper does not require either the form of induction or the subtle generalization we have found that proofs of many theorems involving f are complicated by the introduction of terms such as due to the expansion of the call in f however use of the lemma this is a good example of why future number theory should be using pure lisp as the metalanguage z z which can be proved by the theorem prover allows these terms to be further simplified ill fact the use of this equality usually yields the same lemma produced by generalization and induction in references rs and moore j proving theorems about lisp functions j acm i january pp r l studies in logic northholland amsterdam j recursive functions of symbolic functions and their computation by machine c acm april moore j introducing iteration into the pure lisp theorem prover ieee transactions on software engineering no september pp peter r functions academic press new york pp 