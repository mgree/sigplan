kjava a complete semantics of java university university of illinois at complete popl consist well easy to abstract this paper presents kjava a complete executable formal semantics of java kjava was extensively tested with a test suite developed the project following the test driven development methodology in order to maintain clarity while handling the great size of java the semantics was split into two separate definitions ­ a static semantics and a dynamic semantics the output of the static semantics is a java program which is passed as input to the dynamic semantics for execution the program is a valid java program which uses a subset of the features of java the semantics is applied to multithreaded programs both the test suite and the static semantics are generic and ready to be used in other projects categories and subject descriptors d programming languages formal definitions and keywords java mechanized semantics k framework introduction java is the second most popular programming language http after c and followed by php both c and php have recently been given formal semantics like the authors of the c and php semantics and many others we believe that programming languages must have formal semantics moreover the semantics should be public and easily accessible so are more easily and fixed and formal analysis tools should be based on such semantics to eliminate the semantic and thus errors in such tools without a formal semantics it is impossible to state or prove anything about the language with including that a program meets its specification that a type system is sound or that a compiler or interpreter is correct while all analysis tools or implementations for the language incorporate some variant of the language semantics or a projection of it these are hard to access and thus to to the best of our knowledge the most attempts to give java a formal semantics are which uses abstract state machines and which uses term rewriting however as discussed in section these semantics are far from being complete or even well tested each comes with a few sample permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm java programs only the defined features and each can execute only about half of the others programs we present kjava a semantics for java which systematically defines every single feature listed in the definition of java which is the java language specification nd edition a page chapter document moreover our semantics is tested in fact we spent about half the time to this project to write tests which are small java programs special cases of features or combinations of them specifically we followed a test driven development methodology to first develop the tests for the feature to be defined and interactions of it with previous features and then defined the actual semantics of that feature this way we produced a set of tests which serves as a test suite not only for our semantics but also for testing various other java tools considering that no such test suite exists for java our tests can also be regarded as a contribution made by this paper as a semantic framework and development tool for our java semantics we chose k there are several aspects of k that made it suitable for such a large project k provides a convenient notation for modular semantics of languages as well as execution and formal analysis tools for the defined languages such as a parser and interpreter for reachability symbolic execution engine deductive program verifier and recently a translator of semantics to coq in particular recent advances in matching and reachability logic have been incorporated in k making it unnecessary to define multiple semantics for the same language eg an operational semantics for execution and an axiomatic semantics for program verification the c and php semantics mentioned above have both been defined in k and demonstrated their using the generic k tools the prover for example automatically turns the c semantics into a deductive verifier of c programs to emphasize that our java semantics is useful beyond just providing a reference model for the language we show how the builtin of k can be used to multithreaded java programs while this illustrates only one possible application of the semantics other applications can be similarly derived from the tools provided by k besides such immediate applications we believe that our executable semantics of java is also a convenient platform for with java extensions for example proposes to extend java with and records with mixins and with immutable objects the proposal to extend java with generic types made it to the language in java the widely lambda expression feature with at least three proposals was finally incorporated in java such extensions are easy to add to our semantics and thanks to k one would immediately benefit not only from a reference model for them but also from all the formal analysis tools automatically by k this paper makes the following two specific contributions · kjava the first complete semantics of java including more generally kjava is the first complete semantics for an imperative statically typed objectoriented concurrent language section illustrates some challenges of java section describes our definitional methodology and shows selected rules and section shows an application to modelchecking multithreaded programs · test suite covering all java constructs section also used to compare java semantics in section related work here we discuss two other major formal executable semantics of java and compare them with kjava we also recall other large language semantics that the design of kjava other executable semantics of java is the first attempt to define a complete semantics of java and the most complete prior to kjava showing that is it feasible to define formal semantics to programming languages it was defined using abstract state and covers almost all major features of java except packages is also executable with the kind help of its authors we were able make it work comes with tests that touch all their implemented features which we used as one of our external test for kjava contains not only the semantics of java but also defines the compiler and the bytecode format and gives a manual proof for the correctness of their compiler while kjava uses a different formalism it follows the methodology to separate the static and the dynamic semantics except for that and kjava are quite different uses many auxiliary constructs in their programs produced by the static semantics while kjava uses a subset of plain java is monolithic while in kjava the static and the dynamic semantics are two separate definitions that can be used independently for example other projects can use our static semantics to reduce the set of java programs they need to handle is another executable semantics of java defined using term rewriting in our testing that is overall less complete than although passed a few tests that failed to pass however unlike thanks to the was successfully used to perform exploration and modelchecking of java programs for example was able to detect the deadlock in the philosophers problem and prove the fixed program correct comparison since both and are executable we evaluated their completeness by running our test suite section with each the results of our are presented in figure the list of java features is divided into large groups separated by the first groups contain features introduced with java literals expressions statements arrays classes and instance members interfaces static members and static initialization packages and identifier resolution group includes features introduced with java and the last group includes the single new feature of java assert besides packages does not define all literal forms an important set of operators the switch statement array and complex cases of method overloading and method access modes the remaining features of java are defined except for some corner cases despite being more recent than covers a smaller subset of java yet it in a few areas supports a set of operators but still not all of them and it has better support for local variable yet many other features are not supported switch and continue ad feature aj kj basic integer boolean string literals other literals overflow distinction between integer types prefix i i also operators other integer operators string other types reference operators basic statements switch break continue array exceptions array length array polymorphism array array default values basic classes inheritance polymorphism method overloading ­ distinct number of arguments method overloading without argument conversion method overloading with argument conversion method access modes instance field constructor calls via this and super keyword super interfaces interface fields static methods and fields accessing static fields static initialization static initialization trigger packages hiding instance initialization blocks static inner classes instance inner classes local anonymous classes assert statement support level full partial none aj represents is and kj is our work figure completeness comparison of various semantics of java array features many features and interfaces also makes no distinction between various integer types and integer overflow is not defined from java and it only supports the simplest feature instance methodology the level of differs widely both among groups and among individual rows in figure we compressed large portions of java into one row when all semantics defined them eg basic yet when we identified interesting features not supported by some of the semantics we extracted them into individual rows we were careful to interpret the test results in particular we designed each test to touch as few java features as possible other than the tested one to minimize the number of reasons for failure section in the cases when we were unable to identify why a particular test failed we gave the semantics the benefit of the except for kjava other executable semantics several semantics have been defined recently due to space constraints we only mention those which had a direct ence on kjava the first semantics developed in k was that of c it covered all the c features was tested using the gcc test suite and was used to explore c a large fragment of php also defined in k was tested for using the php standard test suite and applied to prove simple properties using modelchecking two different semantics of large fragments of python were defined using k and resp plt redex both were tested against available test the techniques were also successfully reused to define c from the fact that java and c are similar jscert is an almost complete semantics for javascript in coq using a methodology that a close to the standard and tested against the javascript standard test suite background and challenges here we give background on java and k and discuss some of the major challenges when giving semantics to java the java language specification java is a statically strongly typed objectoriented multithreaded language it is completely defined ie unlike other languages it has no undefined or features except for threads java is completely deterministic the definition of java is the has pages and the part that defines the language has pages java is distributed as part of the java development together with a several class library the class library however is not part of the nevertheless we defined semantics to all classes that are central to the language and mentioned in the such as object string thread and a exception types challenges the kjava project challenges the first challenge is the size of java at the imperative level the language has operators § and statements § java values may be subject to a large number of conversions § there are complex rules for an identifier § more precisely an identifier in java could mean one of the following package class field local variable or method method name could be decided based on the immediate syntactic context alone however between the remaining categories is nontrivial and involves many special cases one of the most complex features of java is method overloading that we illustrate in the next subsection classes have complex initialization rules that include static initialization § and instance initialization § the matter is further complicated by the ability to call on the first line of a constructor either a constructor of the same class through this or a constructor of the base class through super interfaces interact with a wide number of features as they may have methods static fields specific rules for initialization and method java has a number of modularity features such as packages and four categories of nested classes static inner inner local and anonymous since nested classes may access names from their enclosing classes they bring a large number of special cases for name packages are important to define access modes and access modes have challenging interactions with the other java features as will be illustrated in section the separation of the whole semantics into static and dynamic definition is a consequence of java being statically typed dynamically typed languages like php or javascript need just a dynamic semantics clearly defines what computations should happen before the execution compiletime and what should happen during the execution runtime in section we present an example that illustrates the difficulties produced by static typing while it might seem natural to have the two semantics for java we did not follow this approach from the beginning how static typing the design decisions of kjava is discussed in section another challenge was the careful testing and implementation of all corner cases for each new feature the difficulty arises when the new feature with already defined features for example packages were among the last features added we had to make sure packages were properly resolved in all contexts in variable declarations clauses cast expressions etc when we later added inner classes we had to make sure inner classes work equally well in all the contexts above for each context we had to test that inner classes might be referred both by simple names and by fully qualified names that might contain package names our testing methodology is presented in section despite these challenges we made no and completely defined every single feature of java content to kjava java was designed to be compiled into a bytecode format that is executed on a java virtual machine jvm consequently some details of deal specifically with the bytecode representation and are irrelevant here such parts are § details of jvm execution and § bytecode binary compatibility also defines all the compiletime errors that might be produced by incorrect programs we do not cover them as the focus of kjava is to model the behavior of valid java programs only also we do not cover dynamic class loading § instead in kjava all classes are loaded at the beginning of the execution the possibility to load classes at runtime from other formats than bytecode but sends the reader to the jvm specification for details no other details are given for this reason it is fair to consider a jvm rather than a java feature and to regard the default class the one loading classes from class files from the purely as a performance optimization with no implication to the semantics limitations we do not define the java memory model jmm that the allowed multithreaded execution behaviors § instead we define a sequentially consistent memory model with a global store and no caches consistent with the only if all fields are defining jmm would be a significant effort on its own relatively orthogonal to the present work also jmm was replaced by jmm so is no longer actual it has been demonstrated that k allows for modular replacement of the memory model § we plan to do the same for java in future work a of java static typing and access modes every java expression has a statically assigned type static types have various functions during execution · subexpression types influence the type of the parent expression for example is not the same as long · integers type gives their precise representation within the allowed range when the range for a certain type is overflow occurs is different from byte · when an object has a member field or static method that an inherited member one can pick the right member by manipulating the type of the qualifier given b of type b then bv and could refer to different fields · method overloading allows methods with the same name and number of arguments but with different argument types then f and may invoke different methods for most expressions the static type might be computed at the same time as the actual value of the expression one might think that static types could be computed during execution at the same time as the value of an expression is computed we actually did this in an version of the semantics and it great for a while however we had to this approach when the time to define the conditional operator an expression class a private string a return int string a return long string test return class b string test return new int long figure method overloading with access modes package a public class a void f void g package a public class b extends a protected void f void g package b import a public class c extends b protected void f protected void g a c new c cf cf cg bg figure package access mode and method overriding a b c evaluates to b when a is true and to c otherwise when b and c have different static types the conditional expression will have the join type of the two thus the static type of the operator depends on the type of the two arguments yet only one of these arguments is evaluated at runtime it would be incorrect to compute the value of both b and c just for the sake of having their static type due to possible side effects therefore the computation of static types had to be separated from the actual execution one of the most complex features of java is method overloading first the arguments of a method call may have types that are different from the parameter types when the method is overloaded the version with the most specific types that are compatible with the argument types is invoked moreover the choice of available versions of the method is by access modes in figure both versions of f are compatible with the call yet the set of accessible versions is different for the two call sites the call from has access to both versions and it chooses the more specific one however the call from cannot access the private f it calls the one with default access mode the situation is even more complex when overloading is combined with inheritance and subtype polymorphism one might be to think that access modes are only required for static semantics and could be discarded before execution § puts some restrictions on the types of arguments of that makes join in most cases to be the type of arguments and in java this is not the case in figure the two methods f and g are very similar yet the class of the actually invoked methods is different since af is declared with package access mode and class c is in a different package the method cf does not directly af however it does af indirectly through the declaration bf the method af is accessible to b since both a and b are in the same package as bf is declared with protected access mode the method is accessible to any subclass of b including to c thus a link is established that allows cf to af the very similar method g is declared with the default package access mode in b that prevents the connection between bg and cg hence in order to determine the right method to be invoked it is not sufficient to pick the last one visible to the dynamic runtime type of the qualifier a correct semantics has to the entire chain of classes between the static type of the qualifier and the dynamic type the examples above illustrate how static typing allows for a rich set of features but it also significant complexity moreover it is not enough to consider each language feature in isolation it is required to define and test each combination that might lead to nontrivial interactions section addresses testing some rules related to method invocation are presented in section k k is a framework for engineering language semantics given a syntax and a semantics of a language k generates a parser an interpreter as well as formal analysis tools such as model checkers and deductive theorem provers at no additional cost it also supports various such as and coq that is it can translate language semantics defined in k into or coq definitions the interpreter allows the to test their semantics significantly increasing their effectiveness furthermore the formal analysis tools facilitate formal reasoning for the given language semantics which helps both in terms of applicability of the semantics and in terms of engineering the semantics itself for example the exploration capability helps the language designer to cover all the nondeterministic behaviors of certain language constructs or combinations of them here we describe k only very briefly more details are given on an basis in the rest of the paper in k a language syntax is given using conventional annotated with semantic attributes a language semantics is given as a set of reduction rules over configurations a configuration is an algebraic structure of the program state organized as nested labeled cells holding semantic information including the program itself figure shows a subset of the java configuration the order of cells is irrelevant in a configuration leaf cells contain pieces of the program state like a computation stack or continuation eg k environments eg env stacks eg stack etc as this is all best understood through an example let us consider a typical rule for reading a variable x ··· k ··· x l ··· env ··· l v ··· store v we see here three cells k env and store the k cell represents a list or stack of computations waiting to be performed the leftmost ie top element of the stack is the next item to be computed the env cell is simply a map of variables to their locations and the cell store is a map from locations to values the rule above says that if the next thing to be evaluated which here we call a redex is the variable lookup expression x then one should match x in the environment to find its location l in memory and match l in the store to find its value v with this information one should transform the redex into that value v the line represents a reduction a cell with no line means that it is read k k list stack m ap env int location º i nt tid m ap holds bool thread threads m ap methods k list k class classes t m ap store list in list out set m ap figure subset of the java configuration but does not change during the reduction the are structural frames that is they match portions of cells that are irrelevant this notation is actually quite useful the above rule would be written out as a traditional rewrite rule like this x k x l env l v store l k x l env l v store items in the k cell are separated with which can now be seen the and take the place of the ··· above the most important thing to notice is that nearly the entire rule is duplicated on the righthand side rhs duplication in a definition requires that changes be made in in multiple places if this duplication is not kept in sync it leads to subtle semantic errors in a complex language like java the configuration is much more complex and would require including additional cells like thread and threads figure k automatically infers these cells keeping the rules local and modular in fact one of the most aspects of k is its modularity it is very the case that one needs to touch existing rules in order to add a new feature to the language there are two k features specifically modularity first the configuration can be structured as nested cells second the language designer needs only to mention the cells that are needed in each rule and only the needed portions of those cells for example the above rule only refers to the k env and store cells while the entire configuration contains many other cells as shown in figure this modularity not only to compact and thus human readable semantics but also to the overall effectiveness of the semantics development process for example even if a new cell is added to the configuration later on in order to support a new feature the above rule does not change program parser program ast collect class names process compilation units static semantics process class declarations process class members elaboration folding ast valid java program unfolding execution dynamic semantics figure the structure of kjava kjava the semantics of java in k kjava is divided into two separate definitions static semantics and dynamic semantics figure for parsing we use a java grammar defined in which we turned into a parser compatible with k by using the the static semantics takes as input the ast representation of a java program and produces a program as the output it performs computations that could be done statically and are referred in as compiletime operations such computations include converting each simple class name into a fully qualified class name or computing the static type of each expression the ast is passed to the dynamic semantics for execution statistics we define the semantics for all syntactic tions of java here are some statistics for our semantics static dynamic common total size kb n cells ­ n rule n aux the rows represent source lines of code comment lines of code total files size number of cells number of rules number of auxiliary functions the columns represent the static semantics the dynamic semantics except class library modules common for both static and dynamic semantics class library including and the total size next we present an overview of the static semantics and continue with selected rules from the dynamic semantics static semantics the static semantics consists of several phases depicted in figure each phase deeper into the syntactic structure of java and either performs a set of transformations over the program or computes some new configuration cells collect class names phase in this phase the initial program is traversed and all class names are collected into a map the names map serves two purposes at later phases to resolve simple class names into fully qualified class names and to determine the set of classes available inside a package each class is traversed recursively so that the inner classes are also yet the traversing does not proceed inside code blocks thus classes defined at the block level local and anonymous are not discovered at this stage process compilation units phase in this phase the traversal starts again from the initial program ast and performs two tasks the first is to move class content from the initial ast to the class cells inside the configuration from where it will be easier to access during subsequent phases from this point on the program is no longer a monolithic ast but a collection of class cells the of the initial class content is very at this stage just the class declaration including clauses is and not the class members the class content is recursively like in the the previous phase to process all the inner classes the second task of this phase is to process and produce the map of class names accessible for each toplevel class process class declarations phase in this phase the simple class names inside clauses of each class are converted into fully qualified class names this allows us to compute the map of accessible class names for inner classes has complex rules for the names accessible inside inner classes that do not allow computing those names at an earlier stage process class members phase at this stage the body of each class is processed and each member is stored in an appropriate cell for methods the parameter and return types are now resolved elaboration phase this phase involves the code blocks and is the most complex of all phases the transformations here involve class names inside blocks expression types and method overloading also at this stage classes local and anonymous are first detected upon their detection classes must be passed through all the previous phases to be normalized to the same format as the other classes transformations figure most of the transformations performed by static kjava left column contains sample input fragments together with the minimal relevant context the right column represents the transformed fragment these transformations illustrate the means by which it was possible to represent the program as valid java without any extra annotations the simple class names are transformed into fully qualified class names row this allows us to eliminate clauses in programs each expression is additionally wrapped into a cast expression that encodes its static type row during execution this cast is treated like a regular cast the example in the figure also illustrates binary numeric the result type of the addition between an int and a long is a long in addition for method calls each argument is wrapped into one more cast namely to the expected parameter type row this allows us to effectively encode method overloading row illustrates the preprocessing of fields accessed by simple names each such field access is converted into a qualified access if the field is it will be qualified by this first case in row and this should be additionally cast to the current class type according to rule if the field is static it will be qualified with the class that defined the field second case the same transformation is performed for methods called without a qualifier this last transformation allows us to among the four roles of a name namely package class field or local variable syntax id id id type type id syntactic context package package or class class expression expression resulting role package package class field local var an identifier inside a syntactic context where only a package is allowed will be considered a package if either a package or a class is allowed then the identifier will also be considered a package initial code object l void a f class a int v static int s v s class a a class a static int a class a int a a a super class o void m final int ab class l int f return ab new lf final int a new a int f return a f code long int long f long int class a a super class a static int a class a int a void init aa a super init class o void m final int ab env new new m class int ab class l env env int f return l o final int a class extends a new figure transformations performed by the static semantics here we consider classes that are used as qualifiers to refer to an inner class also as packages a field or a local variable will always be part of a cast expression thus will always be inside an expression context if the respective identifier is qualified then it is a field otherwise it is a local variable with row if a constructor does not call another constructor on the first line then it should call the base class constructor super except if the current class is object for we omit the already discussed transformations eg into cast expressions in the remaining examples of static fields as well as static blocks are collected into one big static block row which is invoked during execution when the class is for the first time accessed by the program for instance the same procedure cannot be followed row instead all the instance initialization code is collected into the method init that is called by the constructors right after the base constructor super was called the most complex transformation is that of local classes it is encoded into a separate module with rules one of the largest of kjava local classes are converted into instance inner classes within the same enclosing class the difficulty of this transformation arises from the ability of local classes to access final local variables visible at the point when the class was declared the most common case is presented in row for each such local class l an additional inner class is defined that stores the enclosing local environment of l contains a field for each variable in the environment accesses to the local environment of l are encoded as accesses to fields of finally anonymous classes are first converted into local classes which are in turn converted into inner classes the last row motivation for elaboration phase initially kjava was developed without an elaboration phase for example expression types were computed along their value each time they were executed similarly other computations that are now done in the elaboration phase were performed on the during execution this approach up to a point and produced a monolithic semantics which was more compact than the present one however when we reached the point to define the semantics of the conditional expression and of the local classes it eventually clear that we had to compute the static types as described in section it is impossible to compute the type of a conditional expression by evaluating its operands dynamically also local classes had to be discovered and prior to execution in order to cover all the corner cases for this we needed a phase capable to into code blocks folding phase the last and simplest phase of preprocessing folding combines the information stored in class cells back into one big ast as an interface to the dynamic semantics since all the transformations performed by the static semantics maintain the validity of the program the resulting ast represents a valid java program as well this phase is technically unnecessary for the dynamic semantics alone because unfolding phase in dynamic kjava figure is the exact of folding the ast back into the same cells that were used to produce it folding and unfolding phases were required to complete the division between the static and the dynamic parts of kjava the ast the output of the static semantics is the ast this ast has a valuable property it corresponds to a valid java program equivalent to the initial one more precisely for every java program p there is a program p such that the ast of p is equal to the ast of p we do not prove this property we only state it supported by the observation that every transformation performed by the static semantics preserves program equivalence maintaining this equivalence imposed some challenges first we were forced to use only transformations that preserve program validity all the transformations presented in figure are also performed by the java compiler with the difference that produces bytecode in contrast not all transformations performed by were accessible to static kjava for example inner classes into toplevel classes we could not do the same because we would lose method access modes and access modes have to be preserved section also we could not use any auxiliary constructs in the ast despite the challenges we believe producing a ast with stated properties was since it enables our static semantics to be usable in conjunction with tools outside the k exceptions we choose to illustrate the first rules from kjava through the dynamic semantics of throw and figure these rules are relatively and require just the cell k by default rules without a cell context as are all the rules in figure automatically apply to the current computation task the first task in k which holds the current computation all the rules in a language definition in k match the first task of k either explicitly or like here implicitly the first rule rewrites a into the body of try s followed by catch clauses wrapped into the auxiliary construct the binary associative construct followed by is builtin to k and stands for computation task the constructors role is to separate individual tasks in the current computation now rules for other statements will apply over the content of s until it is either entirely consumed or a throw statement becomes the first task in the first case if s was consumed it means the execution of try block completed normally then the term reaches the top of computation and is discarded by the second rule in the second rule is an anonymous variable which can match anything here it can match one or more catch clauses the term is rewritten into · the unit or empty computation in words this rule says that if reaches the top of computation then discard it now the entire is consumed and the execution continues with the next statement in case s an exception a throw statement will eventually reach the top of the computation figure continues with the syntax definition of throw as it has a semantic role before throw could be evaluated the expression inside throw has to be evaluated to a value k has a compact notation to achieve this the strict annotation meaning bring the nonterminals of the annotated syntax to the top of computation and them back when they are evaluated to a final value specifically for the statement throw this annotation is compiled into one and one rule as shown in the inner box figure the rule the expression to the top of computation for evaluation the notation hole is a marking the context from which the expression was the rule should only apply if the expression is not a final result yet here a typed value this restriction is encoded in the side condition the rule the produced typed value back to its original context the typed value is v t an auxiliary notation of kjava the left side of is the value while the right side is the static type k also has more general forms of strict allowing to control which arguments should be and the evaluation order now the actual rules for throw are ready to apply rule matches when the type of the exception carried by throw is compatible with the type accepted by the first catch clause so the exception is the compatibility of the exception type and the catch clauses type is verified by the expres sion in the side condition in this case both the throw statement and the construct are rewritten into a sequence of three statements a declaration of the catch parameter x of type as a local variable x an initialization of x with the exception value typed with the type expected by x x v and the body of catch all three statements are wrapped inside a block to the variable x to its expected scope rule matches when the two types are not compatible in this case the first catch clause is the next one if any to the top of the list rule matches when throw cannot interact with the next statement the side condition statements interacting with throw are the nonempty and finally thus if the next computation item after throw is anything except the two including the empty produced eventually by the fourth rule that statement will be the statement throw will remain the top of computation until it reaches a matching catch or remains the only rule inside the k cell the notation means that variable ki should match only one item in the computation sequence separated by if we just ki then the entire remaining computation would be matched if throw remains the only task in the computation another rule will match that will ensure exception propagation outside the current method loop statements with are defined similarly one may why not a try with multiple catch clauses into multiple try with one catch each we actually did so initially but it turned out to be incorrect indeed the code try throw new a a throw new b b cannot be into try try throw new a a throw new b b because in the second case the exception b would get by b and this is incorrect according to this counter example is now included in our test suite method invocation the central rule of method invocation is the first rule in figure this is actually the last rule to be applied after a long chain of computations that involves computing the qualifier the arguments loading the required information from various cells of configuration and deciding the actual method to be invoked based on the access mode as was mentioned in section when the actual invocation of the method is ready to be performed the top of computation cell contains a term of the form this term is a java qualified method invocation expression augmented with kjava auxiliary syntax here is the object or class upon which the method is invoked the term is a reference to a method with signature sig declared in the class the variable denotes the remaining in cell k this rule performs the following operations · the rest of computation and the current content of are saved to a new entry or frame on top of the cell stack this data will be used to restore the current computation context by the rules for return · the new method context is initialized with an empty local variable environment env rule try try s s rule · syntax stmt throw exp strict compiled into rule throw e requires e rule v · throw v rule throw v catch x x x v requires subtype rule throw v catch x · requires subtype rule throw ki · requires ki figure rules for and throw the class of the invoked method the current object location computed by auxiliary function as the location of the qualifier if qualifier is an object no location if qualifier is a class for static methods · current computation is rewritten into a sequence of four terms static initialization of the new class initialization of the parameters the method body a return statement with no arguments this will be reached only if the execution of the method body terminates without reaching another return or throw statement the auxiliary function static initialization of the class in case this class was not initialized yet repeated calls of this function have no effect rule º sig args args body return k · ··· stack · env location sig body class rule t x tv t x x tv rule · · · figure final rules for method invocation the function is defined by rules and in figure it takes as arguments two list of parameter declarations and the list of argument values the first rule processes the first parameter declaration in the list the parameter with name x of type t is rewritten into a local variable declaration t x followed by an assignment expression that x with the argument value the third term in the rhs of the rewrite is with the processed parameter and argument removed here we use as k brackets to terms when all parameters are processed both arguments of become empty lists in this case the third rule from the figure applies the term the complete semantics of method invocation as well as the semantics of new are discussed in the companion report and synchronization kjava has basic support for threads first is the class thread with methods start join and interrupt we also support thread synchronization through the synchronized statement § and the synchronized for methods § for more advanced usage we support methods from class object wait below we discuss the key rules for methods wait and both methods have to be called from a synchronized block that holds the monitor lock of the target object when wait is called the thread the lock on target object and blocks until another thread calls on the same object when is called the waiting thread does not up immediately but only after the thread the synchronized block when up the thread the lock on the target object when there are multiple threads waiting on the same monitor object will nondeterministically up one of them finally if either wait or is called in a state where the current thread does not hold the appropriate monitor an exception is the rules are presented in figure see figure for the configuration cells the first rule corresponds to the invocation of wait here the term represents a rule µ µ sig wait class object · ··· k ··· thread tid tid ··· ··· holds ··· ··· · · ··· ··· tid requires int rule ± sig class ··· k ··· ··· holds requires int rule ··· · k ··· ··· · rule ··· · k tid tid · false wt requires tid in keys wt bool in figure rules for and typed object qualifier of the method call the only part that is of interest to us from this term is object identifier in the store that is also used as synchronization key the next term class object represents a method reference to the method with signature name wait and irrelevant arguments declared in the class object the expression above the line lhs of the rewrite is a method call expression for the given object reference the given method reference and no arguments this rule replaces the method call expression in cell k with auxiliary function used later to exit from the waiting state the id of the current thread tid has to be in the set in the cell holds attached to each thread stores the number of times the current thread acquired the lock on each object here we use it to make sure that the current thread acquired the lock at least once see the side condition another cell matched here is this one in contrast with holds is a global cell unique for the whole configuration it stores the set of objects that are currently used as synchronization of blocks synchronized when an object enters the waiting state it has to release its ownership to the monitor this is done by deleting ol from the set the second rule is the starting rule for the side condition ensures that the current thread holds the monitor on the target object the actual logic of is to the construct requires two rules for two case when there is at least one thread waiting on the target object and the case when there is none rule is the rule for the first case if there is a thread waiting on the current object then the object identifier will be present among the map values of by deleting the whole entry associated to that value we enable the waiting thread to proceed if there is no thread waiting for this object then term is simply consumed at this stage after a call to the rule for could match inside another thread rule the rule checks in its side conditions that the current thread identifier tid is not among the waiting threads it also checks that the target object represented by is not this is required because the thread from waiting state has to the monitor on the target object finally the rule has to make sure that the thread was not while it was waiting otherwise another rule will match and will throw the appropriate exception we only presented the key rules above corresponding to the most common execution scenario the corner cases such as illegal calls that should result in various exceptions are not included but are nevertheless fully supported and tested applications here we show how kjava together with builtin k tools can be used to explore multithreaded program behaviors the first application is state space exploration and the second is ltl modelchecking state space exploration the next simplest way to use kjava besides execution is state space exploration when a program is run with the k and option search the tool outputs all of the possible executions for the program any possible nondeterministic behavior this capability was successfully used in the semantics of c to expose the nondeterminism of expression evaluation while singlethreaded java is deterministic threads bring nondeterminism by running a multithreaded java program in search mode we can produce all its interleaving behaviors additionally the option pattern allows us to filter the search results according to a pattern this feature may be effectively used for example to detect deadlocks in kjava the cell thread is when the corresponding thread its execution consequently we can detect successful execution paths by using the pattern · threads the pattern will match when there are no threads remaining conversely the pattern thread would match the final states where at least one thread did not finish its execution eg a deadlock we successfully used this approach to detect the deadlock in the philosophers problem ltl modelchecking while state space search might be used to test some programs k offers a more powerful capability for exploring nondeterministic behavior specifically k provides linear temporal logic ltl modelchecking capabilities through its in this section we show how kjava can be used to verify ltl properties of multithreaded applications consider the program in figure a modified version of the program contains a blocking queue ­ a classical example with one producer and one consumer thread the inner class contains two methods put and get the methods are synchronized designed to be called from a multithreaded environment when put is called on a full queue the calling thread has to wait until some other thread an element similarly the consumer thread calling get has to wait when the queue is empty the producer the main thread calls put four times while the consumer anonymous thread inside main calls get the same four times aside from capabilities this small program illustrates many other features of java expressions with side effects public class static class int int array new int head tail synchronized void element if tail head wait element system out print synchronized int get if tail head wait int element system out print return element public static void args exception final queue new new thread public void run i i i try queue get e start i i i figure a blocking queue exception handling arrays static and instance methods inner and anonymous classes running state space exploration for the example above correctly produces all expected interleavings of the output text represents a call to put ­ a call to get the implementation of contains a subtle problem the wait call is within an if inside both get and put thus is executed at most once this is actually a correct behavior if we have just one producer and one consumer but leads to problems when the number of threads is at least three above the only way a thread waiting on line labelled could be is from a call to from method put line labeled since at the end of the method put we have at least one element in the queue method get can safely extract an element in a scenario with one producer and two the thread waiting on could be by a call to from ei we do not consider spurious here or if the thread executing get was by another get that other get could have actually extracted the last element from the queue thus the queue empty of the queue state the thread will execute the body of get and will extract a element from the queue to eliminate this possibility we need to replace the if statements with while above both at and a programmer might make such a subtle when first designing the queue for a usage and then extending the context to more threads it is difficult to expose this bug through traditional testing we executed the incorrect program a times with the jvm it never the path next we would like to expose the problem above with ltl in this implementation of queue tail is each time an element is added to the queue and head is each time an element is extracted they are never since it is not possible to extract more elements than are added a basic invariant of the queue is head tail this is the exact invariant that is violated by the example above in the scenario the ltl model checking capability of the k framework allows us to find the bug by model checking the following ltl formula this the property was correctly proven true for the example in figure but was proven false for the version of the same program when we the queue implementation the model checker proved the formula correct the version of the program in figure took seconds to model check produced transition states and roughly two rewrites similar formal program analysis capabilities were demonstrated within the semantics of c and php testing testing kjava took almost half of the overall development time here we describe our testing efforts which in what could be the first available test suite for java the for a test suite all recent executable language semantics projects used an external test suite for validation naturally we tried to do the same the test suite for java both the language and the class library is java compatibility from oracle is not available instead oracle offers free access for to implement the whole ie both the language and the class library after a application oracle rejected our request we also explored test part of is a test suite for the class library but not for the language another test suite is containing tests for classes and for the compiler but not for the runtime tests the compiler test its capability to distinguish between correct and incorrect java programs and to output the appropriate error message unfortunately all these tests were for our purpose there were actually two external test that we were able to use one was the set of examples from that we presented in section another one was the list of examples from the java precisely we used out of tests from and out of examples from java precisely the programs that we did not use either illustrated compiler errors or were not complete java programs or used classes that we do not support these two sets of examples while useful were far from enough their purpose was to illustrate java not to exercise every single corner case of the language with no of an available test suite we had no choice but to develop our own test development methodology when writing our tests we followed the test driven development the main principle of is to write tests before implementing the actual feature under test it was to use for kjava for two reasons first kjava has a complete and final consequently our tests are not expected to change as a result of changes in the specification second tests for kjava are java programs they do not depend on any part of the system under test kjava to be written for every test we compared the output produced by kjava with the output produced by when developing a new feature we followed the following steps first we tried to cover all corner cases of the feature under test in isolation for example the first nonterminal of the for statement might be a list of variable in such case we will include in our tests statements with zero one or more second we would define the new feature in the simplest way possible to pass all the tests sometimes after the implementation we would identify some corner cases that were not captured by the tests we would add additional tests for such cases thus our methodology was a combination of and testing in addition to the steps above we tests for each combination of language features whenever we thought that the two features may possibly interact we followed the development of java starting from lowlevel features such as literals expressions statements towards the higher level features the order of development is approximately reflected by the order in which tests were written which can be found in kjava public we at testing every detail specified in eg to test the precise order of execution of subexpressions inside an expression we used subexpressions with sideeffects and verified the correct order of evaluation by observing the correct order in which the side effects occurred some features on other features to be properly tested for example in order to test the precise static type of various expressions we used method overloading for example if an expression e has to return type a but a erroneous semantics could also produce b we tested the correct choice by calling fe where f was an overloaded method that could accept an argument of type a or b in all such cases we were careful to the exhaustive testing of the developed feature and to write the tests later once all are available eventually we produced a test suite consisting of tests to test we used state space exploration we designed a test suite of programs explicitly at covering all the behaviours of all the supported multithreaded language constructs for each program we first produce all the possible solutions using k then we compare the number of solutions with the expected manually determined one later changes testing and when we first tried to execute and over our test suite the of the tests failed it was because some very basic feature used in most of the tests was not supported for example did not support addition between a string and a boolean did not support escape characters and we were not able to use n in our tests for this reason to overcome this problem we our tests and eliminated the most common causes of failure when they were not the actual feature under test this way we were able to produce the results reported in section conclusion and discussion we have discussed kjava which to our knowledge is the first complete formal semantics of java the semantics has been split into a static and a dynamic semantics and the static semantics was so that its output is also a valid java program this way it can be used as a frontend in other java semantics or analysis tools as a side contribution we have also developed a test suite for java to our knowledge the first public test suite of its kind more than small java programs that attempt to exercise all the corner cases of all the language constructs as well as nontrivial interactions of them the reader may argue that there is no such thing as a complete semantics of a large language like java because it is always possible to miss a feature or worse an interaction of features while this is true in principle we mention that completeness of the semantics was our major objective from the of this project and that we have very carefully considered all possible interactions of features that were explicitly discussed in the or that we could think of since there is no other attempt to completely formalize java that we are aware of in order to formally compare with kjava due to all the above we believe that it is fair to claim that kjava is the first complete formal semantics of java kjava can serve as a platform to experiment with java extensions not only can one define such extensions but one also gets a reference implementation for we plan to extend kjava with semantics for the the versions of java starting with java most of java features can be compiled into jvm bytecode by using option target foreach loop and these features can be similarly defined in the static kjava support in the dynamic kjava would be required for and annotations the feature of java is lambda expressions could be into anonymous classes implementing a functional interface uses a different strategy yet the designers of java suggest as an option we also plan to define dynamic class loading it has already been defined in so we see no in it for kjava this would allow support for a much set of classes from consequently for more real life programs finally using ks support for reachability logic it should be possible to verify java applications deductive verification requires more user that model checking and would be a separate work on its own acknowledgments supported by nsf grants and references kjava url access to the url using java features in earlier url translation of lambda expressions url project url url project url a simple scenario using wait and in java url l f i and f a programming language with and records sci comput program ­ may m a d p s d a and g smith a trusted javascript specification in popl pages ­ acm d programming language semantics in k framework with in pages ­ ieee d kjava runtime semantics for method invocation and object instantiation technical report university of illinois url e n g v and r f a highlevel modular definition of the semantics of c theor comput sci ­ may g m odersky d and p wadler making the future safe for the past adding to the java programming language in oopsla pages ­ acm m r r de and e java front url m f s p n j and c manual version url http a c r b m moore t f and g reachability logic in lncs springer s j and a the ltl model checker and its implementation in pages ­ springerverlag c a formal semantics of c with applications phd thesis university of illinois july c and g an executable formal semantics of c with applications in popl pages ­ acm a f chen j and g formal analysis of java programs in in cav volume of lncs pages ­ d and s an executable formal semantics of php in ecoop pages ­ m s and m felleisen a programmers reduction semantics for classes and mixins in formal syntax and semantics of java pages ­ springerverlag c language version url j b g steele and g java language specification second edition addisonwesley nd edition d a formal semantics of python thesis university of illinois at july c e j and a immutable objects for a language in esop volume of lncs pages ­ springer berlin j p r h p and j the syntax definition formalism manual sigplan not ­ k and a understanding the url j g a m s d j li a and s python the full in oopsla pages ­ acm g and a checking reachability using matching logic in oopsla pages ­ acm g a c and b m moore reachability logic in lics pages ­ ieee june g and t f an overview of the k semantic framework ­ p java precisely mit press r f e and j java and the java virtual machine definition verification validation springerverlag 