reduction a new method of proving properties of systems of processes richard j computer science department yale university new abstract when proving that a system of processes has a given property it is often convenient to assume that a routine is ie that the routine cannot be interleaved with the rest of the here sufficient conditions are obtained to show that the assumption that a routine is un can be relaxed and still preserve basic properties such as halting and thus correctness proofs of a system of processes can often be greatly simplified this technique called reduction is viewed as the replacement of an routine by an one introduction suppose that parallel processes in p it p is a system of independent and h is some routine con is often easy to prove that p has some property z as long as the routine r is a routine is provided it is never interleaved with the rest of p ie provided it can be treated as one action for r might be the three instructions or actions rx increment r assuming that r is or ble reduces r to the single instruction x x in contrast prove that to l it is not usually easy to p has property z when r is the basic question when does assertion define pr obtained from p ble action e considered in this paper is imply assertion to be the system of processes by reducing r to one r is considered to be pr is called the reduction r the type of results we obtain are of p by if pr has property p has property z then in proving these results restrictions must be placed on r these restrictions however are satisfied by a wide range of these re are then used as suppose that one to prove that p has property z p is reduced to p and p is reduced to p and so on finally yielding q now q is shown to have property z thus several applications of show that p also has property e the reason this method is is that q is usually much simpler than p q is simpler than p first because q has less actions than p it follows that a proof that q has property z must consider less cases than a proof that p property x second q is simpler than p be cause assertions about q are often simpler than assertions about p for example we will later investigate variables an example where in q the sum of two ab ­ is always a constant while in p ab a complex function of p of the state this difference in the assertions that can be made about ab is important the fact that ab is constant allows an easy proof that q does not halt the previous proof procedures for systems of processes essentially of tion method adapted to parallel systems and the basic to this method is that because of the many possible computations in a parallel system the assertion method to in the consideration of many cases the interleaving of systems of processes is a major for the assertion method this should with the main advantage of the reduction method the computations of pr are a proper subset of the computations of p of course the reduction method can indeed be used in conjunction with the assertion method reduction is developed in the context of a variant of the model of systems of processes of the author was supported in part by research grant number one of the key advantages of this mo is that it is not toward any particular type of systems of processes this is important since the reduction pr cannot always be de in terms of one of the classic models for example if p is a pv system of processes then pr need not be a pv system of processes however in our model pr is always a valid system of processes this paper is composed of sections in section the basic model of system of processes is presented in section the concept of tion is presented and then shown to preserve both halting and in section several ex are presented which demonstrate the power of the reduction method basic model a system of processes is of disjoint each consists of a finite connected whose nodes are statements of a finite of these directed the form collection graph start statement start test statement j true j b generalized assignment statement b x t false where b is a predicate and x is a list of as these predicates and assignments are assumed to be fully interpreted and to operate on program variables we will not need to state what predicates and assignments are allowed the results presented here are from the class of predicates and assignments allowed each statement is also called an action and each flowchart is called a process the form and are given the usual seman tics actions of the form are given the fol semantics if b is te then the assignments in z are executed otherwise nothing is executed another to way of the semantics of a assignment is to consider it equivalent ­ true b false d i i t b denotes the concatenation of b and where the actions inside the dotted lines are con note no claim is made that generalized assignments should be implemented in this way just that they should behave in this way a computation of a system of process is a finite sequence of actions such that each action in turn is able to execute thus if is a computation and f is the action lb then the predicate b must be true after the com cl is executed for example the of the system of processes s initially are the sequences and all note prefixes of these se is not a computation after s s ence w cannot execute next the class of pv systems of processes is defined the importance of this is first the fact that the reduction method applies to pv systems of processes demonstrates that it has practical value this follows since pv or a variant of it is used in most current operating systems thus the reduction method can be used to prove the correctness of parts of opera systems second the literature contains many complex examples of pv systems of processes the fact that the reduction method can be used to simplify their proofs demonstrates the power of the reduction method definition p is a pv system of processes provided there is a distinguished subset of the program variables called n with integer values such that they can be only used in generalized assignments of the form or i the former is called called a a ps the latter is are intuitively used by pv systems of processes as a method of communication the name itself from the use of se or flags to send signals between they are manipulated in exactly two ways either one could increment a semaphore by eg or one could test whether a semaphore was possible and if this was true then the semaphore by eg are often thought of as resources a is then an attempt to unit of the resource sk while a is a release of unit of this resource reductions the concept of reduction is then shown that reductions and is now defined it preserve both routines and reductions suppose that of processes when do are actions in a form a routine here means open routine first it is reasonable to that they all lie in the same routines that span processes are very and are not allowed here of course this is not enough one would not consider fragment f and to be a routine in the fl o i true y yl i i the missing requirement is that the routine must be entered via and then via f n this is still not the case one would not der fl and f to be a routine in the fragment in a routine there must be no way to jump into the middle of the routine will n certainly once this is form a routine in summary in order for f f in to form a routine they must satisfy two constraints they must all lie in the same process they must be entered via fl and via f n with no into the middle in order to avoid notational not ­ all the routines studied here are to be straight line that ia they are assumed not to branch the of the following results to include branching ia straightforward definition the generalized assignment form a routine provided f actions is the predecessor of i or s i n the fact that ia a predecessor of and f is a predecessor of and so on implies that lie in the same flowchart flowchart are disjoint connected directed graphs since is the unique predecessor i of f il there can be no into the middle of the routine definition a system suppose that is a routine in of processes where lin f is i i where predicate is the z is a list of assignments then the composite action action g defined by and of b is i a where b is the predicate b is true and b is true on the state that results after is executed and n b n is true on the state that results after e s suppose that g is the composite action the routine l fn is the action g computes the effect of l fn when it is to be or example the composite action of the routine of that for t in a directed graph f is the predecessor of g provided there is an arc from f to g s s tl is the action s t t note in the composite action t is tested nonnegative since always increments t before tests t to be positive also that g leaves t fixed increments t to be by note t and definition suppose that is a routine in p then the reduction n of p by is the system of processes formed when the path is removed and replaced by g where g is the composite action of fl fn thus j j becomes fn i g i j the reduction ie n processes that is formed when the is considered to be ble the fundamental between question is p and the system of routine or what is the if does not halt then does p halt a of processes if there is some com a such that is not a computation for all actions f a system of processes that does not halt is often called deadlock free in analyzing parallel systems such as operating systems it is often important to prove that they never halt ie that they are deadlock free this follows since operating system processes are often never ending tasks eg disk handler and hence must be proved to never halt reductions that preserve halting and the most optimistic all reductions preserve conjecture to make is that halting more exactly if f does not halt n p does not halt then unfortunately of processes this is false consider the system ex whose processes are l al a al g b b true a al b e bl where that ex halts and initially lf are it is easy is a computation not computations to see the actions form a routine the processes of are i i it is easy to that does not halt therefore does not halt and rx does halt this contradicts assertion l the failure of assertion can be explained as fol in the routine in ex it is pos to enter the routine and not be able to ever exit it this observation tion on routines leads to one rl if is ever entered then it must be possible to eventually exit the routine this restriction appears to be strong however as demonstrated later it is satisfied by a wide class of routines restriction is not sufficient to ensure the truth of assertion l for example consider the system of processes ex whose actions are true yx yo y y s start true xo where yo that ex halts is not executes that satisfies initially is a computation he actions restriction tions of if z are it is easy to a computation and y o lf rm a the start yl start v does not halt hence restriction s not sufficient to imply assertion l this ple fails to satisfy assertion because the effect of actions f and f when separated by action is not the same as the effect of and fz together when routine ff cannot be y is always can be this observation leads to set to when routine y can be set to o or a further restriction r the effect of the actions of a routine when and when must be the same the restriction may appear ture precisely and perhaps satisfy this is not the the key definition to be difficult to cap just as difficult to case the following is definition a system provided suppose that f and g are actions in of processes then f is a right mover if is a computation and f and h lie in different processes then is also a computation moreover the values of all the program variables in and are the same also g ia a left mover provided if is a computation and g and h lie in different processes then a is a computation moreover the values of all the program variables in and are the same essentially a right mover ia an action that performs a while a left mover is an action that performs a release of a resource in order to see this consider first the case of a left mo vi r if s v f is a computation and f performs then is also a computation and h lie in different processes a af is a computation since a release can always execute here we use the fact that f and h lie in different processes is a computation since h executed after a and f did not any resource ie any demand of h can still be is a computation since and are with the same effect and we know that b is a computation second consider the then is a computation is also h lie in different case of a right mover and g performs a a computation provided processes if g and ah is a computation argue as before is a computation if h is a release this follows immediately thus assume that h is a then the result follows by a symmetry argument is a computation argue as before the above proofs pv of processes can be stated exactly see section for definition provided the routine it is of the form is a b el true q fn true en where for some and f kl fn restriction k l are left are right f is k not so res rl corresponds to the fact that each f i is of the form i ei restriction the first last nk r corresponds to the fact that are right are left and the theorem in a system suppose that of processes is p then if does not halt then p does not halt a n proof first are needed in for they of we will state two simple lemmas that our proof their proofs are omit follow easily from the def init ions lemma suppose that is a computation with from i then a where the process of fi is in a no action lemma that halts suppose in p that with is a computation i n then where no action from the process of fi is in in order to continue the proof suppose that a is a computation in p such that a halts we will show how to construct a computation b such that the program variables after a and are executed and always occurs consecutive blocks of actions in b ie as if ill fj and j n then t bi is the ith element of the sequence b if f jl fi fj and j then bi f j if no fi is in o then a is already in the desired form ie let that some f is in i of lemmas and a therefore ct by repeated applications where no action from the process of aj j n by the definition and left and right for some f is in i of k any kd fl fn is a computation and it with a on all the program variables this argument can be repeated to form the desired computation now b bm where no f is in any j on all program variables r let g be the composite l fn and a action and b agree of the routine is a computation in moreover a and b and agree on all halts in the program variables then the if of the theorem has been proved hence the would be true conversely assume that not halt in further theorem does that h is a computation in f n then ah is a computation in p if h g then fn is a computation in p these assertions follow since a and agree on all program vari ables in case however we have reached a contradiction d a corollary of theorem is that reductions of also preserve a system of processes is determinate provided if a and i halt then they agree on all program variables the proof of theorem actually established that for each a that halts in p there is a b that halts in such that n a and b agree on all the program variables then thus if f l n sa is determinate n p is determinate implies that in order to prove this last assume that p is not determinate there are u and al that halt in p values on some program variable noted above there are b and that as with v as halt in f with n a and agree on v and al and f agree on v thus b and is not determinate on v hence n that right that the next theorems are a major aid in proving an action is a left or right mover whether or not a given action is a left or mover often is the main difficulty in proving a routine is a definition a system of processes is commutative provided if and are both computations then they agree on all the program variables commutative is a fundamental restriction that is often placed on parallel systems in parallel theory and the concept of commutative plays an important role in their study of theorem suppose then that is a pv system of pro every ps action is a right mover every vs action is a left mover all other actions are both right and left provided p is tive proof a sketch also see of this proof was made earlier theorem section u theorem shows that commutative pv systems of processes contain a great of left and right for example in a commutative pv system of processes the routine s a routine thus whenever f f are anything but a ps ex while ex does not since they are almost identical this shows that arguments cannot be allowed here in a sense theorem is on the edge of being incorrect the third example presents an example where the reduction method gl ws an assertion to be simplified the first example is based on the system of processes ex whose actions are fj true a al b bl i rm where a b initially it is easy to see and f f are f theorem shows that and are right thus by theorem we can prove that ex never halts if we can show that the following system of processes never halts true x y is a in a commutative pv system of applications the reduction method is now demonstrated by a number of examples the first two examples the importance of precision in studying the reduction concept in these two examples two sys of processes ex and ex are analyzed start al a al g bo a al where theorem if the a b initially clearly b is therefore fg is a by again by theorem ex never halts following system of processes never halts zl where initially it is trivial to prove that this system of processes never hence ex does not halt the second example is based on the system of processes ex defined in section if we re ex as we did ex we obtain i a b b i where a b initially the key difference is that b is not equal to as it was in the previous example this is of course not since ex does halt could not be applied is that are both not this the reason theorem and g example shows how sensitive the reduction method ia the final example ie based on the of processes ex whose actions are where ao and b n initially is essentially the bounded buffer example of the value of ab intuitively represents the number of elements in the buffer one would like to argue that ab is equal to n but it clearly is not indeed ab can equal n or n or now let us apply the reduction method theorem shows that f f and f are both then theorem shows that ex does not halt provided that the following system of does not halt ig i ta al ib bl where al and b n it ia now trivial by argument that ab n always the above system of can only halt when asl and b s o but this implies that ab n s o which is impossible a conclusions the basic properties deadlock free not and are preserved by reductions since reduction reduce the interleaving of a system reduction often reduces the effort to prove that a system is correct many re follow easily from theorem this leads to the interesting possibility that they can be generated indeed a program that could keep track of actions form composite actions determine whether or not an action was a left and or right mover would be a great aid in proving correctness of parallel systems references the rw assigning mathematical aspects mathematics meanings to programs of computer science society kn the application of program proving techniques to the verification of synchronization processes hc correctness in operating systems phd thesis university ea proving assertions about parallel programs research report cs department of applied analysis and computer science university of rj limitation of synchronization primitives yale computer science report no g ew dijkstra sequential pro programming languages by f bh liskov the design of the operating system rm re parallel program rj on synchronization primitive systems yale computer science report no an synchronization of processes cacm 