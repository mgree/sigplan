netkat semantic foundations for networks college foster cornell university university of massachusetts carnegie mellon university kozen cornell university princeton university david walker princeton university abstract recent years have seen growing interest in highlevel languages for programming networks but the design of these languages has been largely ad hoc driven more by the needs of applications and the capabilities of network hardware than by foundational principles the lack of a semantic foundation has left language designers with little in determining how to incorporate new features and programmers without a means to reason precisely about their code this paper presents netkat a new network programming language that is based on a mathematical foundation and comes equipped with a sound and complete equational theory we describe the design of netkat including primitives for modifying and packets union and sequential composition operators and a kleene star operator that iterates programs we show that netkat is an instance of a canonical and mathematical structure called a kleene algebra with tests kat and prove that its equational theory is sound and complete with respect to its denotational semantics finally we present practical applications of the equational theory including syntactic techniques for checking reachability proving noninterference properties that ensure isolation between programs and establishing the correctness of compilation algorithms categories and subject descriptors d programming languages language application languages keywords network programming languages domainspecific languages kleene algebra with tests netkat introduction traditional network devices have been called the last of computing unlike modern computers which are this work performed at cornell university permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm implemented with hardware and using standard interfaces networks have been built the same way since the s out of devices such as switches load and each implemented with custom hardware and using interfaces this design makes it difficult to extend networks with new functionality and effectively impossible to reason precisely about their behavior however a has taken place with the recent rise of sdn in sdn a generalpurpose controller machine a collection of switches the controller to network events such as new connections from hosts topology changes and shifts in traffic load by the switches accordingly because the controller has a global view of the network it is easy to use sdn to implement a wide variety of standard applications such as routing traffic monitoring and access control as well as more sophisticated applications such as load detection and a major of sdn is that it defines open standards that any can implement for example the api clearly specifies the capabilities and behavior of switch hardware and defines a lowlevel language for manipulating their configurations however programs written directly for sdn platforms such as are to assembly easy for hardware to implement but difficult for to write network programming languages in recent years several different research groups have proposed domainspecific languages for sdn ­ ­ the goal of these network programming languages is to raise the level of abstraction of network programs above such as thereby making it easier to build sophisticated and reliable sdn applications for example the languages developed in the project support a programming model i a generalpurpose program to network events by generating a static forwarding policy and ii the static policy is compiled and passed to a runtime system that the switches using messages this model policies can be expressed by having the generalpurpose program generate a sequence of static policies are written in a simple domainspecific language with a clear semantics so programs can be analyzed and even verified using automated tools still it has never been clear what features a static policy language should support the initial version of used simple lists of rules as policies where the actions in constructs for forwarding and modifying packets subsequent versions of the language added and later removed the ability to embed arbitrary functions in policies as well as constructs for composing policies in parallel and sequence as its designers added removed and modified the meaning of primitives as by the needs of applications without principles or metatheory to guide its development its evolution has clear direction and the ad hoc semantics has not made clear which primitives are essential and which ones can be derived and when new constructs have been added to the language it has not been clear how they should interact with existing constructs and what behavioral laws they should an even more issue is that these static policy languages only specify the forwarding behavior of the switches in the network however when a network program is actually executed functionality is determined both by the behavior of the switches and by the structure of the network topology to answer almost any interesting question about the network such as can x connect to y is traffic from a to b through z or is there a loop involving s the programmer must step outside the of the model and the abstractions it provides to summarize we believe that a foundational model for network programming languages is essential such a model should i identify the essential constructs for programming networks ii provide for new features and iii unify reasoning about switches topology and behavior semantic foundations this paper presents the first network programming language that meets these criteria to begin we focus on the global behavior of the network unlike previous network programming languages which have focused on the local behavior of individual switches abstractly a network can be seen as an automaton that moves packets from node to node along the links in its topology hence from a perspective it is natural to use regular expressions the language of finite automata regular expressions are a standard way to specify the behavior of a network a path is encoded as a concatenation of processing steps · · a set of paths is encoded as a union of paths p q · · · and iterated processing is encoded using kleene star moreover by modeling the network in this way we get a theory for reasoning about formal properties kleene algebra ka a sound and complete equational theory of regular expressions with kleene algebra as the choice for representing global network structure we can turn our attention to specifying local functionality a switch implements predicates to match packets and actions that transform and forward matching packets existing languages build various abstractions the predicates and actions supplied by the hardware but predicates and actions are essential as a consequence a foundational model for sdn must incorporate both kleene algebra for reasoning about network structure and boolean algebra for reasoning about the predicates that define switch behavior fortunately these classic mathematical structures have already been unified in previous work on kleene algebra with tests kat by now kat has a metatheory including an extensive model theory and results on expressiveness deductive completeness and complexity the axioms of kat are sound and complete over a variety of popular semantic models including language relational and trace models and kat has been applied successfully in a number of application areas including compiler device driver and communication protocol verification moreover equivalence in kat has a pspace decision procedure this paper applies this theory to a new domain networks host switch a switch b figure example network host netkat netkat is a new framework for specifying programming and reasoning about networks based on kleene algebra with tests as a programming language netkat has a simple denotational semantics inspired by netcore but modified and extended in key ways to make it sound for kat which netcore is not in this respect the semantic foundation provided by kat has true the axioms of kat the interactions between primitive program actions predicates and other operators moreover any future proposed primitive that violates a kat axiom can be rejected for the equations that allow us to reason effectively about the network netkat thus provides a foundational structure and consistent reasoning principles that other network programming languages lack for specification and reasoning netkat also provides a finite set of equations that capture equivalences between netkat programs the equational theory includes the axioms of kat as well as domainspecific axioms that capture transformations on packets this set of axioms enables reasoning about local switch processing functionality needed in compilation and optimization as well as global network behavior needed to check reachability and traffic isolation properties we prove that the equational theory is sound and complete with respect to the denotational semantics while the soundness proof is straightforward our proof of completeness is novel we construct an alternate language model for netkat and the completeness of ka to evaluate the practical utility of our theory and the expressive power of netkat we demonstrate how it can be used to reason about a collection of applications first we show that netkat can answer a variety of interesting reachability queries useful to network operators next we state and prove a noninterference property for networks that provides a strong form of isolation between netkat programs finally we prove that netkat can be correctly compiled to a lowlevel form analogous to switch flow tables in summary the contributions of this paper are as follows · we develop a new semantic foundation for network programming languages based on kleene algebra with tests kat · we formalize the netkat language in terms of a denotational semantics and an axiomatic semantics based on kat we prove the equational axioms sound and complete with respect to the denotational semantics · we apply the equational theory in several domains including reasoning about reachability traffic isolation and compiler correctness the next section presents a simple example to netkat and introduces the key elements of its design the subsequent sections define the language formally develop its main theoretical properties and present applications overview this section introduces the syntax and semantics of netkat using a simple example consider the network shown in figure it consists of switches a and b each with ports labeled and and two hosts the switches and hosts are connected together in series suppose we want to the network to implement the following policies · forwarding transfer packets between hosts but · access control block ssh packets the forwarding component is both switches to forward packets for host out port and likewise for host but there are several ways to implement the access control component we will develop two implementations and prove them equivalent using equational theory forwarding to up let us define a simple netkat policy that implements the forwarding component to a first approximation a netkat policy can be thought of as a function from packets to sets of packets in the next section we will generalize this type to functions from lists of packets to sets of lists of packets where the lists encode histories to support reasoning about properties we represent a packet as a record with fields for standard such as source address src destination address dst and protocol type typ as well as two fields switch sw and port pt that identify the current location of the packet in the network atomic netkat policies filter and modify packets a filter f n takes any input packet pk and yields the singleton set pk if field f of pk equals n and otherwise a modification f n takes any input packet pk and yields the singleton set pk where pk is the packet obtained from pk by setting f to n to allow programmers to express more sophisticated policies netkat also has policy combinators that build policies out of smaller ones the union combinator p q generates the union of the sets produced by applying each of p and q to the input packet while the sequential composition combinator first applies p to the input packet then applies q to each packet in the resulting set and finally takes the union of all of the resulting sets with these operators we can implement the forwarding policy as follows p dst h · pt dst h · pt at the top level this policy is the union of two the first updates the pt field of all packets for h to and all other packets while the second updates the pt field of all packets for h to the union of the two generates the union of their other words the policy packets across switches a and b in both directions access control next we extend the policy with access control the simplest way to do this is to compose a filter that blocks ssh traffic with the forwarding policy in sequence ssh · p this policy the input packet if its typ field is ssh and otherwise it using p of course a quick inspection of the network topology shows that it is not necessary to test all packets at all locations in the network to block ssh between host and host must traverse both switches so it is sufficient to filter only at switch a pa sw a · ssh · p sw b · p or at switch b pb sw a · p sw b · ssh · p both of these policies are more complicated than the original policy but more efficient because they avoid having to store and enforce the access control policy at both switches naturally we would prefer one of the optimized policies in addition we would like to be able to answer the following questions · are packets · are ssh packets · are pa and pb equivalent network ask these sorts of questions whenever they write a network policy however note that we cannot answer them by the policies answers depend on the network topology we will see how to incorporate topology information into a netkat program next topology a network topology is a directed graph with hosts and switches as nodes and links as edges we can model the topology as the union of smaller policies that encode the behavior of each link to model an internal link we use the sequential composition of a filter that packets located at one end of the link and a modification that updates the sw and pt fields to the location at the other end of the link thereby capturing the effect of sending a packet across the link to model a link at the of the network we simply use a filter that packets located at the port we assume that links are and encode bidirectional links using pairs of links for example the following policy models the internal links between switches a and b and the links at the to hosts and t sw a · pt · sw b · pt sw b · pt · sw a · pt sw a · pt sw b · pt note that although we represent the links as policies unlike switch policies these link policies cannot actually be controlled must be consistent with the structure of the underlying physical topology switches meet topology a packet traverses the network in interleaved steps of processing by the switches and topology in our example if host sends a packet to host it is first processed by switch a then the link between a and b and finally by switch b this can be encoded by the netkat term more generally a packet may require an arbitrary number of particular if the topology has a cycle using the kleene star operator which iterates a policy zero or more times we can encode the overall behavior of the network · t note however that this policy processes packets that enter and exit the network at arbitrary locations including at internal locations such as on the link between switches a and b it is often useful to restrict attention to packets that enter and exit the network at specified external locations e e sw a · pt sw b · pt using this predicate we can restrict the policy to packets sent or received by one of the hosts e · · t · e more generally the input and output predicates may be distinct in · p · t · out this encoding is inspired by the model used in header space analysis we call a network modeled in this way a logical since it encodes processing behavior and internal processing steps section discusses a more refined model that encodes processing formal reasoning we now turn to formal reasoning and investigate whether the logical correctly implements the specified forwarding and access control policies it turns out that these syntax fields f f · · · fk packets pk f v · · · fk vk histories h pk pk h predicates a b f n ab ¬a identity drop test disjunction conjunction negation policies p q a f n pq p dup filter modification union sequential composition kleene star duplication semantics p h ph h h h f n pk h ¬a h pk h if pk f n otherwise h a h f n pk h pk f pq h p h q h h p q h p h s in fi h where f h h and f i h p fi h dup pk h pk pk h kleene algebra axioms p q r p q r pq qp pp ppp p · q · r p · q · r p · q r p · q p · r p q · r p · r q · r p · p p q p · r r p · q r p · p p p q · r q p · r q additional boolean algebra axioms a b · c a b · a c a a ¬a a · ¬a packet algebra axioms f n · f n f n · f n if f f f n · f n f n · f n if f f dup · f n f n · dup f nf n f nf n f n f n f n · f n if n n pf i i figure netkat syntax semantics and equational axioms questions and many others can be reduced to policy equivalence we write p q when p and q return the same set of packets on all inputs and p q when p returns a subset of the packets returned by q on all inputs note that p q can be treated as an abbreviation for p q q to establish that correctly filters all ssh packets going from port on switch a to port on switch b we check the following equivalence where is the policy that all packets typ ssh · sw a · pt · · t · a sw b · pt to establish that the optimized policies pa and pb correctly filter ssh packets going from port on switch a to port on switch b we check the following equivalences typ ssh · sw a · pt · pa · t · a sw b · pt and typ ssh · sw a · pt · pb · t · a sw b · pt finally to establish that correctly packets from h to h we check the following inclusion ssh · sw a · pt · sw b · pt · t and similarly for packets h to h of course to actually check these equivalences formally we need a proof system netkat is designed to not only be an expressive programming language but also one that satisfies the axioms of a kleene algebra with tests kat moreover by extending kat with additional axioms that capture the domainspecific features of networks the equational theory is it can answer all the questions in this section and many more the following sections present the syntax semantics and equational theory of netkat formally section prove that the equational theory is sound and complete with respect to the semantics section and illustrate its effectiveness on a broad range of questions including additional reachability properties section program isolation section and compiler correctness section netkat this section defines the syntax and semantics of netkat formally a packet pk is a record with fields f fk mapping to integers n we assume a finite set of packet including source and destination addresses tag ip source and destination addresses tcp and source and destination ports along with special fields for the switch sw port pt and for simplicity we assume that every packet contains the same fields we write pk f for the value in field f of pk and pk f n for the packet obtained from pk by updating field f to n to facilitate reasoning about the paths a packet takes through the network we maintain a packet history that records the state of each packet as it from switch to switch formally a packet history h is a nonempty sequence of packets we write pk to denote a history with one element pk h to denote the history constructed by pk on to h and pk pk n for the history with elements pk to pk n by convention the first element of a history is the current packet other elements represent packets we write h for the set of all histories and ph for the powerset of h syntax syntactically netkat expressions are divided into two categories predicates a b and policies p q predicates include constants true and false tests f n and negation ¬a disjunction ab and conjunction operators policies include predicates modifications f n union p q and sequential composition p · q iteration p and a special policy that records the current packet in the history dup the complete syntax of netkat is given in figure by convention binds than · which binds than hence a · b c · d is the same as a · b c · d semantics semantically every netkat predicate and policy denotes a function that takes a history h and produces a possibly empty set of histories h hn producing the empty set models the packet and its history producing a singleton set models modifying or forwarding the packet to a single location and producing a set with multiple histories models modifying the packet in several ways or forwarding the packet to multiple locations note that policies only ever or modify the first current packet in the history this means that an implementation need not actually record are only needed for reasoning figure defines the denotational semantics of netkat note that there is no separate definition for predicate is a policy and the semantics of · and are the same whether they are composing policies or predicates the syntactic distinction between policies and predicates arises solely to ensure that negation is only applied to a predicate and not for example to a policy such as p formally a predicate denotes a function that returns either the singleton h or the empty set when applied to a history h hence predicates behave like filters a modification f n denotes a function that returns a singleton history in which the field f of the current packet has been updated to n the union operator p q denotes a function that produces the union of the sets generated by p and q and sequential composition denotes the composition of the functions p and q where the composition of functions of type h ph is defined as f g x g y y f x policy iteration p is interpreted as a union of semantic functions fi of h where each fi is the composition of function denoted by p i times finally dup denotes a function that the current packet and adds it to the history since modification updates the packet at the head of the history dup the current state of the packet and makes it observable readers familiar with and netcore may notice some differences between the syntax used in previous network programming languages this paper focuses on theoretical foundations so we use the traditional algebraic syntax for kat which a b f n ab ¬a p q a f n pq p dup ab true false fn a or b a and b not a pq filter a f n pq pq p dup figure netkat algebraic and surface syntax the · and operators for predicates and programs and has constants and figure shows the relationship between this algebraic syntax and the surface syntax we use in programs equational theory as its name suggests netkat is a kleene algebra with tests formally a kleene algebra ka is an algebraic structure k · where k is an idempotent semiring under · and p · q respectively is the least solution of the affine linear inequality p · r q r respectively r · p q r where p q is an abbreviation for p q q the axioms of ka are listed in figure a kleene algebra with tests kat is a algebraic structure k b · ¬ where ¬ is a unary operator defined only on b such that · k · is a kleene algebra · b · ¬ is a boolean algebra and · b · is a of k · the axioms of boolean algebra consist of the axioms of idempotent already listed as ka axioms and the additional axioms listed in figure in previous work on kat the elements of b and k have usually been called tests and actions respectively in this paper we will refer to them as predicates and policies it is easy to see that netkat has the required syntactic structure to be a kat however the kat axioms are not complete for the underlying netkat packet model to establish completeness we also need the packet algebra axioms listed in figure the first three axioms specify commutativity conditions for example the axiom states that assignments src x and dst y can be applied in either order as src and dst are different src x · dst y dst y · src x similarly axiom states that the assignment src x and predicate sw a can be applied in either order the axiom states that every predicate with dup interestingly only this single axiom is needed to characterize dup in the equational theory the next few axioms characterize modifications the axiom states that modifying a field f to n and then on packets with f equal to n is equivalent to the modification alone similarly the axiom states that on packets with field f equal to n and then modifying that field to n is equivalent to just the filter states that only the last assignment in a sequence of assignments to the same f has any effect the final two axioms characterize filters the axiom states that a field cannot be equal to two different values at the same time while the axiom if a · p p · a then a · p a · p · a p · q · p p · q · p p · q · p p q if for all atomic x in q x · p p · x then q · p p · q lemma in identity in identity in corollary of lemma in figure kat theorems states that the sum of filters on every possible value is equivalent to the identity this implies packet values are drawn from a finite domain such as integers example access control to illustrate the netkat equational theory we prove a simple equivalence in figure using the policies from section recall that the policy pa filters ssh packets on switch a while pb filters ssh packets on switch b we prove that these programs are equivalent on ssh traffic going from left to right across the network topology shown in figure this can be seen as a simple form of code the filter from switch a to switch b we use the logical encoding with the following input and output predicates in sw a · pt out sw b · pt as a up we first prove two simpler lemmas that will be useful for the main code motion proof the proofs of these lemmas are straightforward using the netkat axioms and some standard kat theorems given in figure we the terms on each line that will be changed on the next step of the proof to the notation we uses of axioms related to associativity and use the following abbreviations aa sw a a pt ab sw b a pt ma sw a m pt mb sw b m pt ssh typ ssh lemma states that the sequential composition of the input predicate the predicate ab and an arbitrary policy q is equivalent to the policy that all packets intuitively this holds because the input predicate matches packets on switch a and ab matches packets on switch b lemma states that the sequential composition of an arbitrary policy q the predicate aa the topology t from section and the output predicate is equivalent to the policy that all packets intuitively this holds because the topology does not forward packets located on any port of switch a to port of switch b the proof is essentially a case analysis on the links in the topology using these lemmas we then prove lemma which states that pa and pb both drop ssh traffic going from host to host formal statements of these lemmas and proofs using the netkat equational axioms can be found in figure soundness completeness and decidability this section proves the soundness and completeness of the netkat axioms with respect to the denotational semantics defined in section more formally these results state that every equivalence provable using the netkat axioms also holds in the denotational model theorem and that every equivalence which holds in the denotational model is provable using the axioms theorem we also prove the decidability of netkat equivalence and show that the problem is to obtain these results we prove theorems that are stronger and more from a theoretical point of view for soundness we prove that the model used in the denotational semantics is isomorphic to a model based on binary relations and to the soundness of kat over binary relation models for completeness we develop a language model for netkat that plays the same role as regular sets of strings and guarded strings do for ka and kat respectively we then relate the and language models which allows us to the completeness of ka to prove the completeness of the netkat axioms soundness to prove soundness we begin by the standard semantics introduced in section in terms of binary relations in the standard semantics policies and predicates are modeled as functions p h ph this semantics is isomorphic to a relational semantics · in which each policy and predicate is interpreted as a binary relation p h × h h h p h p h intuitively p is the set of inputoutput pairs of the policy p formally the maps p h ph are morphisms of type h h in kl p the category of the powerset monad it is well known that the category kl p is isomorphic to the category rel of sets and binary relations as by x py x y x × y px × y in the relational model · product is interpreted as ordinary relational composition and the remaining kat operations translate under the isomorphism to the usual kat operations on binary relations since the relational model with these distinguished operations satisfies the axioms of kat see eg so do netkat models with the semantics of section let denote in netkat the following theorem states the soundness of the netkat axioms theorem soundness the kat axioms and packet algebra axioms listed in figure are sound with respect to the semantics of section that is if p q then p q proof sketch we have already argued that the semantics is isomorphic to a relational kat and therefore satisfies the kat axioms listed in figure it remains to show that the additional packet algebra axioms on the righthand side of figure are also satisfied these can all be verified by elementary arguments in relational algebra see eg some are special cases of equations ­ whose soundness is proved in theorem see the long version of this paper for the full proof completeness the proof of completeness proceeds in four steps we first define reduced netkat a subset of netkat where policies are regular expressions over complete tests a normal form for sequences of tests complete assignments a normal form for sequences of modifications and dup we show that every netkat policy is provably equivalent to a reduced netkat policy and that reduced terms have a simplified set of axioms to assignments and tests inspired by past proofs of completeness for ka and kat we then develop a language model for reduced netkat this language model gives semantics to policies via sets of guarded lemma in · ab · q proof in · ab · q definition in aa · a · ab · q aa · ab · a · q · a · q lemma q · aa · t · out proof q · aa · t · out definition t q · aa · aa · a · mb · m ab · a · ma · m aa · a ab · a · out q · aa · aa · a · mb · m · out q · aa · ab · a · ma · m · out q · aa · aa · a · out q · aa · ab · a · out definition out q · aa · aa · a · mb · m · ab · a q · aa · ab · a · ma · m · ab · a q · aa · aa · a · ab · a q · aa · ab · a · ab · a q · aa · aa · a · mb · m · a · ab · a q · aa · ab · a · ma · aa · m · ab · a q · aa · aa · a · ab · a q · aa · ab · a · ab · a q · aa · aa · a · mb · m · ab · a · a q · aa · ab · a · ma · m · aa · ab · a q · aa · aa · ab · a · a q · aa · ab · a · ab · a q · aa · aa · a · mb · m · ab · q · aa · ab · a · ma · m · · a q · aa · aa · ab · q · · a · ab · a lemma in · ssh · pa · t · out in · ssh · pb · t · out proof in · ssh · pa · t · out definition pa in · ssh · aa · · p ab · p · t · ssh · out in · ssh · aa · · p · t · ssh ab · p · t · ssh · out in · ssh · aa · · ssh · p · t ab · p · t · ssh · out in · ssh · aa · · p · t ab · p · t · ssh · out in · ssh · ab · p · t · ssh · out in · ssh · ab · p · t · ssh · ab · p · t · ssh · out definition out in · ssh · ab · a in · ssh · ab · p · t · ssh · ab · p · t · ssh · ab · a in · ab · ssh · a in · ab · ssh · p · t · ssh · ab · p · t · ssh · ab · a lemma lemma lemma in · ab · ssh · a in · ssh · aa · p · t · ssh · p · ssh · aa · t · out definition out in · ssh · out in · ssh · aa · p · t · ssh · aa · p · t · ssh · out in · ssh · aa · p · t · ssh · aa · p · t · ssh · out in · ssh · aa · p · t · ssh · out in · ssh · aa · p · t · ssh ab · · p · t · out in · ssh · aa · p · t · ssh ab · · ssh · p · t · out in · ssh · aa · p · t · ssh ab · · p · t · ssh · out in · ssh · aa · p ab · · p · t · ssh · out definition pb in · ssh · pb · t · out figure code motion proofs strings we prove the language model and the standard model of netkat given by the denotational semantics are isomorphic we then define a normal form for netkat policies and show that every policy is provably equivalent to its normal form finally we relate netkat normal forms to regular sets of guarded strings and obtain the completeness of netkat from the completeness of ka the rest of this section the key steps of this proof the long version of this paper gives further details step reduced netkat let f fk be a list of all fields of a packet in some fixed order for each tuple n nk of values let and denote the expressions f n · · · fk nk f n · · · fk nk reduced netkat syntax complete assignments f n · · · fk nk complete tests reduced terms f n · · · fk nk p q pq p dup complete test complete assignment union sequence kleene star duplication simplified axioms for a and p · · dup dup · · · p · regular interpretation rp a dup r rp q rp rq r rp · q xy x rp y rq dup rp n figure reduced netkat language model gp i a · · dup · g · a gp q gp g · gp · q gp · · dup · a gp n guarded concatenation undefined if if a b p q p a q b i figure netkat language model respectively we call these expressions complete tests and complete assignments respectively we often call complete tests atoms because they are atoms minimal nonzero elements of the boolean algebra generated by the tests note that complete tests and complete assignments are in correspondence according to the values hence if is an atom we denote the corresponding complete assignment by and if is a complete assignment we denote the corresponding atom by we let a denote the set of atoms and the set of complete assignments now that we have defined atoms and complete assignments we investigate their properties figure gives a collection of simple axioms for reduced policies that are easily provable using the full netkat axioms one useful consequence of these axioms is p a · any policy is provably equivalent to a policy in which all atomic assignments f n appear in the context of a complete assignment the proof of this fact is straightforward f n n pa · · f n p a · where is with the assignment to f replaced by f n similarly every test is equivalent to a sum of complete tests b p b since all modifications can be replaced by complete assignments and all tests by atoms any netkat policy p can be viewed as a regular expression over the alphabet a dup the bottom of figure shows this by defining a mapping r from reduced netkat to regular sets over this alphabet we assume for the remainder of this section that all netkat policies are in reduced form step language model both ka and kat have language models in which expressions are interpreted as regular sets of minimal nonzero terms often called terms for ka the language model is the regular sets of strings and for kat it is the regular sets of guarded strings netkat also has a language model it consists of regular subsets of a restricted class of guarded strings i a · · dup · each string in this set has the form · · dup · · dup · · · dup · n for some n these strings represent the minimal nonzero elements of the standard model of netkat figure defines the language model as a mapping g from reduced netkat expressions to regular subsets of i the case for sequential composition makes use of the concatenation operator over strings from i which we lift to concatenation of sets of guarded strings from i both definitions appear at the bottom of figure note that is a partial function on strings but a total function on sets of strings using the simplified axioms of figure it is easy to show that is associative on strings and sets over union and has identity · a also note that if exists then i and otherwise having defined the language model we now show that it is isomorphic to the standard packet model presented in section we first show that the standard semantics of every netkat expression is equal to the union of its minimal nonzero terms the proof is straightforward by induction on p lemma for all policies p we have p s x next we prove that every x in i is completely determined by x lemma if x y i then x y if and only if x y finally using lemmas and we conclude that the language model is isomorphic to the denotational model presented earlier lemma for all policies p and q we have p q if and only if gp we notation slightly here by applying the union operator s to functions h ph this is interpreted pointwise s p s s p s step normal forms next we define a normal form for netkat policies and prove that every policy is provably equivalent to one in normal form definition a netkat policy p is in normal form if rp i a policy is if it is provably equivalent to a policy in normal form lemma every policy p is proof the inductive proof requires a slightly inductive hypothesis let us say that a policy is in strong normal form if it is in normal form and is a sum of zero or more guarded policies where a policy is guarded if it is of the form either · · x · or · we show by induction on p that every policy is equivalent to a policy in strong normal form the cases for atomic policies are straightforward hn p a · dup p a · · dup · b p b · the case for union is trivial and the case for sequential composition follows by a simple argument « p si · p tj p p si · tj p p si tj i j ij ij the most interesting case is for kleene star consider an expression p where p is in strong normal form we first prove the uniform case when all guarded terms in p have the same initial atom that is p · t where t is a union of terms each with a leading and and rt · dup · let u be t with all terms whose is not deleted and with the deleted from all remaining terms by the simplified axioms of figure we have t · · t u · t therefore t · · t · u · t · using lemma t · · t t t · · t · · t t u · t · · t t u · u · t u · t and hence p p · p · t · · t · t · · t · u · t · t · u · u · t which after normalizing the is in strong normal form for the case p where the initial tests in p are not uniform the argument is by induction on the number of terms in the union if p then by the inductive hypothesis q has an equivalent strong normal form q using figure we obtain p · x q q · · x · q q · · x · q then proceed as in the previous case step completeness we need just one more lemma before the completeness result which says that the regular interpretation and language model coincide for netkat policies in normal form lemma if rp i then rp gp proof suppose rp i it is straightforward to show that gp is equal to the union of the elements of rp by induction on p gp gx then since gx x for x i we have gp x rp the proof of completeness for netkat now follows from the completeness of ka theorem completeness every semantically equivalent pair of netkat expressions is provably equivalent using the netkat axioms that is if p q then p q proof let p and q be the normal forms of p and q by lemma we can prove that each is equivalent to its normal form p p and q q by soundness we have p p and q q hence p q by lemma we have gp moreover by lemma we have gp rp and rq thus rp rq since rp and rq are regular sets we have p q by the completeness of ka finally as p p and q q and p q we conclude that p q decidability the final theorem presented in this section shows that deciding the equational theory of netkat is no more nor less difficult than for ka or kat theorem the equational theory of netkat is proof sketch to show reduce ka to netkat as follows let be a finite alphabet for a regular expression e over let re be the regular set of strings over as defined in § transform e to a netkat expression e by replacing each occurrence in e of a symbol p with p · dup and with an arbitrary but fixed atom it follows from lemmas and that re re if and only if re re if and only if ge ge if and only if e e to show that the problem is in pspace given two netkat expressions e and e we know that e e if and only if there is a packet pk and packet history h such that h e pk e pk or h e pk e pk let us say the former without loss of generality we guess pk nondeterministically and follow a through e that produces some h e pk at the same time we trace all possible through e that could generate a prefix of h ensuring that none of these produce h e it takes only polynomial space to represent the current values of the fields of the head packet and the possible positions in e for the current prefix of h the algorithm is nondeterministic but can be made deterministic using theorem reachability properties network often ask questions such as can all hosts talk to each other or are hosts kept separate from hosts or does all untrusted traffic traverse the detection system and so on automated tools for these and other questions about reachability properties have been the focus of several recent research projects most existing tools work by encoding the topology and policy as a logical structure and then translating the reachability property into a formula whose satisfiability can be checked using a sat solver or other tool this section presents a different approach we show how to encode two important classes of reachability properties as netkat equations we then prove the equations are sound and complete with respect to intuitive semantic definitions of reachability using the language model developed in section reachability the simplest reachability properties answer questions such as can host a send packets to host b if a can send packets to b then the denotational model of the network must include a packet history that starts from host a and ends at host b pk b · · · pk a more generally we can ask if packets satisfying some predicate a can be transformed so that they satisfy some predicate b these predicates may denote single hosts groups of hosts or even arbitrary classes of traffic such as web traffic to reason about reachability we use a small generalization of the logical model introduced in section in the logical model we model the behavior of the network using the following netkat expression in · p · t · out where p and t define the behavior of switches and links as netkat policies because the policy does not contain dup it does not record the individual that packets take as they go through the network to do this we must augment the logical to record the state of the packet at each intermediate in · dup · p · t · dup · out using this encoding we can define reachability as follows definition reachability we say b is reachable from a if and only if there exists a trace pk · · · pk n dup · p · t · dup such that a pk n pk n and b pk pk to decide whether b is reachable from a we check the following netkat equivalence a · dup · p · t · dup · b intuitively the prefix predicate a filters the policy to only include histories that begin with packets satisfying a similarly the predicate b filters the policy to only include histories that end with packets satisfying b we do need to prove that this equation holds if and only if b is reachable from a the key to the proof is to translate both the denotational definition of reachability and the reachability equation to the language model where they are easy to relate theorem reachability correctness for predicates a and b policy p and topology t a · dup · p · t · dup · b if and only if b is reachable from a proof we translate the netkat equation into the language model a · dup · p · t · dup · b n · · · · n · dup · · · dup · ga · dup · p · t · dup · b we also translate each term in the semantic definition of reachability into the language model pk · · · pk n pk · · · pk n dup · p · t · dup a pk n pk n and b pk pk · · · m m · m · dup · · · dup · · p · t · dup m · m ga and · gb to prove soundness we let n and m n to show that if · n · dup · · · dup · ga · dup · p · t · dup · b then m · m · dup · · · dup · · p · t · dup host switch a switch b host host host figure a simple network controlled by two which holds by definition of the proof of completeness follows by a similar argument a w from a to b is a location that all packets traverse en from a to b for example a network operator might want to ensure that all traffic from untrusted hosts to trusted hosts traverses a definition we say w is a from a to b if and only if for all histories pk · · · pk n dup · p · t · dup where a pk n pk n and b pk pk there exists a pk x pk · · · pk n such that · w pk x pk x · b pk i for all i x and · a pk j for all x j n to decide whether w is a from a to b we check the following netkat inequality a · dup · p · t · dup · b a · dup · ¬b · p · t · dup · w · ¬a · p · t · dup · b the lefthand side is exactly reachability from a to b the righthand side is also a expression but it has a predicate to check that packets traverse w furthermore it tests that packets do not visit b before w or return to a after reaching w theorem correctness for predicates a b and w a · dup · p · t · dup · b a · dup · ¬b · p · t · dup · w · ¬a · p · t · dup · b if and only if all packets from a to b are through w proof similar to the proof of reachability correctness above see the long version of this paper for the full proofs using these encodings and theorems as building blocks we can develop techniques for checking other reachability properties as well for example we can check for test whether a policy is correctly implemented and string together multiple into composite tests traffic isolation policy combinators help programmers construct complex network policies out of simple parts the most basic combinator is union which combines two policies by taking the union of the results generated by the however naive use of union can lead to results because each may receive and modify packets intended for the other example consider the network in figure suppose the task of routing traffic between hosts and has been assigned to one programmer while the task of routing traffic between hosts and has been assigned to another programmer the first programmer might produce the following policy for switch b pb sw b · pt · pt pt · pt and the second programmer might produce a similar switch policy for b this second policy differs from the first only by sending traffic from port out port rather than port pb sw b · pt · pt pt · pt similar policies pa and pa define the behavior at switch a now if we assume t captures the topology of the network properly then pa pb · t correctly sends traffic from host to host however when the second policy is added in pa pb pa pb · t packets sent from host will be copied to host as well as host in this instance union actually produces too many behaviors in the best case sending additional packets to host from host leads to unnecessary in the worst case it may violate the security policy for host either alternative demonstrates the need for better ways of composing forwarding policies slices a network slice is a lightweight abstraction that modular construction of policies intuitively a slice defines a piece of the network that can be independently of the rest of the network the boundaries of a slice are defined by in and out predicates while the behavior in the slice is determined by the internal policy p each slice also has a unique identifier w to it from other slices packets that match in are injected into the slice once in a slice packets in the slice and p until they match the predicate out at which point they are we write slices as follows in w p out where in and out are the and predicates and p defines the internal policy to define slices in netkat we begin by a header field for example tag to record the packets current slice in order for our elaboration to have the desired properties however the tag field must not be used elsewhere in the policy or in the or predicates we call a predicate if it with any modification of the tag field and a policy if it with any test of the tag field given predicates in out and policy p and a tag w representing packets not in any slice we can compile a slice into netkat as follows in w p out w let pre tag w · in · tag w tag w in let post out · tag w in pre · p · post compilation the slice policy with pre and policies pre and post the pre policy tests whether a packet i is outside the slice tagged with w and matches the predicate in which case it is injected by tagging it with w or ii has the unique identifier w may be defined by the compiler and need not appear in the surface syntax in practice the field is often used to different classes of network traffic already been injected already tagged with w once injected packets are processed by p if p a packet that matches the predicate out then post the tag w otherwise the packet remains in the slice and is left isolation a key property of slices is that once a packet enters a slice it is processed solely by the policy of that one slice until it is even across multiple in the topology the following theorem captures this idea more precisely theorem slice composition for all slice and predicates in and out identifiers w policies s q policies p and t if · s in w p out w · w w · out · t · dup · q · q · t · dup · in · q traffic then s q · t · dup s · t · dup q · t · dup in a this theorem says that executing the union of s and q is the same as sending packets through two separate copies of the network one containing the slice and the other containing q the proof of the theorem is by equational reasoning and makes use of the theorem from figure an interesting corollary of the result above is that when the slice boundary of s and the domain of q do not overlap for traffic for the of s the union of s and q is equivalent to s alone corollary for all slice and predicates in and out identifiers w policies s q and t such that · s in w p out w · w w · out · t · dup · q · q · t · dup · in · in · q then in · tag w · s q · t · dup in · tag w · s · t · dup corollary to traditional languagebased information flow properties if s defines public data and q defines private high security data the corollary implies that the observable behavior of the network remains unchanged regardless of whether the data q is present absent or replaced by some alternate high security data q example slices provide a solution to the scenario described in the example at the beginning of the section we can assign each programmer a unique slice with boundaries that correspond to the locations of the end hosts under control of that slice for instance the first programmers in and out predicates include the network access points for hosts and while the second programmers in and out predicates include the network access points for hosts and in sw a · pt sw b · pt out sw a · pt sw b · pt s in w pa pb out in sw a · pt sw b · pt out sw a · pt sw b · pt s in w pa pb out pattern port port action drop output output drop if then else if pt then pt else if pt then pt else figure a flow table and an equivalent netkat policy action sequence a f n · a action sum as a as predicate b f n · b local as if b then as else p sw sw · p figure normal form the original difficulty with this example was caused by packet duplication when for example a packet was sent from host to host corollary proves that we can use slices to solve the problem host is connected to slice and restricting the input to that of slice implies that the behavior of the entire program is precisely that of slice alone compilation in order to execute a netkat program on an switch we must compile it to a flow table the lowlevel programming abstraction that supports a flow table is a list of rules where each rule consists of a pattern to match packet and actions to apply to matching packets when a packet at a switch the actions associated with the priority matching rule are applied to it for example the flow table on the lefthand side of figure blocks ssh packets but all other traffic between ports and the flow table is an equivalent netkat policy to make the connection between these two equivalent representations obvious we introduce a conditional construct as shorthand if b then as else def b · as ¬b · logically a flow table pattern is a conjunction of positive literals and each action is a combination of modifications we can interpret rules as of conditional expressions in this section we describe the design of a compiler based on this idea the input to the compiler is netkat without dup or sw n terms these constructs are necessary to model network topology but the output produced by the compiler is meant to execute on switches therefore it is reasonable to these features the output of the compiler is a subset of netkat called normal form an policy is a sum of conditional where each is guarded by a test for a switch sw sw · · · · sw sw n · n each term can be interpreted as a complete flow table for a given switch figure presents the full grammar for mapping to flow tables is mostly straightforward and many of the lowlevel details have been addressed in previous work the rest of this section the major steps required to compile netkat to each step eliminates or restricts an element of netkat syntax in other words each step translates from one intermediate representation to another until we arrive at we write netkat op to denote netkat expressions that do not use the op operator for example if p netkat then p does not contain dup and does not modify the sw field this is the source language for the compiler as described above step star elimination the first step is to eliminate kleene star from the input policy this step is critical as switches do not support iterated processing of many switches only support a single phase of processing by a table formally we prove that any program without dup or less importantly assignment to sw is equivalent to a kleene program again without the dup primitive or assignments to sw lemma star elimination if p netkat then there exists p netkat where p p proof we show that p can be obtained from the normal form used in the completeness theorem more specifically let p be the policy obtained from p by the normalization construction of lemma by construction dup can only appear in the normal form of an expression already containing dup so p cannot contain dup rp i and p does not contain dup so rp at · p therefore p does not contain kleene star let us now prove that any assignment of the form sw in p is in the same term by the corresponding test sw because p does not contain any assignment of the form sw sw i it with any test of the form sw sw i therefore p also with any test of the form sw sw i it follows that p can be written as a sum of for some atom and complete assignment p suppose for a contradiction that term contains a test sw sw i and p contains an assignment sw sw j with sw i sw j then · sw sw i · p · sw sw j · p · sw sw j · p · sw sw i but those two terms are also equal which is a contradiction therefore any assignment of the form sw in p is pre in the same term by the corresponding test sw and can be removed using axiom to produce the desired p tests and assignments to other fields than sw could appear in between but we can use the commutativity axioms and to move the assignment sw to just after the test sw step switch specialization next we show that every policy can be specialized for the switches in the network this transformation allows us to remove nested tests of the sw field and put the policy into a form where it can easily be compiled into a flow table for each switch lemma switch specialization if p netkat then for all switches sw i there exists p netkat such that sw sw i · p sw sw i · p proof let g be the unique homomorphism of netkat defined on primitive programs by sw if sw sw i otherwise gf v f v dup for every primitive program element x of netkat we have both sw sw i · x gx · sw sw i gx · sw sw i sw sw i · gx if dst a then pt else if src b then pt else if dst a · src b then pt pt else if dst a then pt else if src b then pt else figure compiling policy union if typ ssh then w else · if dst a then pt else if dst b then pt else if dst a · typ ssh then w · pt else if dst a then pt else if dst b · typ ssh then w · pt else if dst b then pt else figure compiling policy sequence hence applying lemma twice shows sw sw i · p gp · sw sw i gp · sw sw i sw sw i · gp by the definition of g any occurrence of sw v in p is replaced by either or in gp moreover since p netkat it follows that gp does not contain any occurrence of sw v and since p gp netkat we also have sw sw i · p sw sw i · p step converting to the third step is to compile policies in netkat to this is a recursive procedure that first to to calculate the union of two policies we take the of the predicates and actions this procedure is based on earlier work but we present a purely syntactic proof of correctness figure shows an example of compiling policy union which illustrates why the construction is necessary calculating the sequence of two policies is more involved since we have to commute the modifications in the first policy with the tests in the second policy to produce a single ifthenelse as illustrated in figure as the netkat axiom shows modifications and tests commute only if they affect distinct fields the compiler has several transformations to ensure that various kinds of overlapping tests and modifications do commute lemma compilation if p netkat then there exists a policy p such that p p and p the proof goes by induction on the structure of p step combining results lemmas and suffice to prove any policy p in netkat may be converted to normal form theorem if netkat then there exists such that optimizations naive compilation of network programs can produce flow tables that are large hence existing systems implement optimizations to generate smaller tables for example the following lemma describes a common optimization called elimination which removes unnecessary rules from the table lemma elimination if b b then if b then as else if b then as else if b then as else we plan to study further optimizations in future work related work kleene algebra is named for its kleene much of the basic algebraic theory of ka was developed by john kleene algebra with tests was introduced by kozen ka and kat have been successfully applied in many practical verification tasks including verification of compiler optimizations pointer analysis concurrency control and device drivers this is the first time ka has been used as a network programming language or applied to verification of networks the proof of the main result in this of the equational based on a novel model of kat while many other systems have been proposed for analyzing networks we believe ours is the first to provide a complete highlevel algebra for reasoning about network programs as they are written systems such as header space analysis and formally encode information about network topology and forwarding policies into sat formulae representations header space analysis or higherorder logic formally these systems then define custom algorithms over these models to check specific properties such as reachability or packet loss such systems can check for violations of important network invariants but do not provide sound and complete systems for reasoning directly about programs moreover although these systems have expressive languages for encoding properties they do not connect these encodings back to denotational or operational models of the network in contrast in section we show how to encode a reachability property as a netkat equation and then prove that the reachability equation is equivalent to a semantic definition of reachability as a programming language netkat is most similar to netcore and which both from earlier work on netcore defined the fragment of netkat with filters modification and union and extended netcore with sequential composition although has neither a formal semantics nor a compiler neither language defined an equational theory for reasoning about programs nor did they include kleene these previous languages netkat programs can describe potentially infinite behaviors is a logic programming language with an explicit notion of location and a distributed execution model in contrast to netkat and netcore are designed for programming not distributed sdn because is based around datalog with general recursion and pragmatic extensions that its semantics equivalence of programs is undecidable kleene star is able to model network behavior but has decidable equivalence conclusion this paper presents netkat a new language for sdn programming and reasoning that is based on a semantic algebra with tests denotational semantics describes network programs as functions from packet histories to sets of packets histories and its equational theory is sound and complete with respect to this model the language enables programmers to create expressive compositional network programs and reason effectively about their semantics we demonstrate the power of our framework on a range of practical applications including reachability traffic isolation access control and compiler correctness acknowledgments the authors wish to thank the members of the cornell and the popl reviewers for helpful comments as well as and for work on a preliminary version of slices this work is supported in part by the nsf under grants and the under n a research and a research references and configuration analysis and verification of in and kozen kleene algebra with tests and program technical report tr computer science department cornell university july using kleene algebra to reason about concurrency control technical report nj john regular algebra and finite machines and hall london andrew d chen and an api for application control of in foster michael j christopher and david walker a network programming language in icfp september mark and foster network in pldi june and foster isolation a slice abstraction for networks in james the last of computing december available at and header space analysis static checking for networks in ahmed matthew and p verifying invariants in real time in kozen a completeness theorem for kleene algebras and the algebra of regular events ic ­ may kozen kleene algebra with tests and commutativity conditions in tacas pages ­ germany march kozen kleene algebra with tests transactions on programming languages and systems ­ may kozen kleene algebras with tests and the static analysis of programs technical report tr computer science department cornell university november kozen and certification of compiler optimizations using kleene algebra with tests in cl july kozen and smith kleene algebra with tests completeness and decidability in csl september m ion and declarative routing extensible routing with declarative queries in ahmed matthew p and debugging the data with in james martin and scott extending sdn to networks in scott and turner enabling in networks computing communications review ­ b calculating with pointer structures in algorithmic languages and calculi proc ifip working conference february christopher foster and david walker a compiler and runtime system for network programming languages in popl january christopher foster and david walker composing networks in april tim nelson daniel j and a balance of power expressive controller programming in mark foster and david walker abstractions for network update in sabelfeld and andrew c myers languagebased informationflow security ieee journal on selected areas in communications ­ relational mathematics cambridge university press o decidability and expressiveness aspects of logic queries in pages ­ the project see and paul hudak functional reactive programming of networks in wang y richard yang and paul hudak maple simplifying sdn programming using algorithmic policies in wang and formally in sun g and a survey of virtual lan usage in networks ieee communications ­ 