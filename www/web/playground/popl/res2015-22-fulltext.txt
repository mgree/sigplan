polymorphic functions with settheoretic types part local type inference and type reconstruction xu univ paris paris paris france france power grid co popl consist complete well easy to abstract this article is the second part of a two series about the definition of higherorder polymorphic functions in a type system with recursive types and settheoretic type connectives unions intersections and in the first part presented in a companion paper we defined and studied the syntax semantics and evaluation of the explicitlytyped version of a calculus in which type instantiation is driven by explicit instantiation annotations in this second part we present a local type inference system that allows the programmer to omit explicit instantiation annotations for function applications and a type reconstruction system that allows the programmer to omit explicit type annotations for function definitions categories and subject descriptors d programming languages language constructs and keywords types xml intersection types type constraints introduction many xml processing languages such as are functional languages however none of them provides parametric polymorphism even though this feature has been repeatedly in different standardization groups a major block to such an extension ie the definition of a subtyping relation for regular tree types with type variables was lifted by and xu in part of this work presented in the previous edition of popl we described how to take full advantage of and system by defining a calculus with higherorder polymorphic functions and recursive types with union intersection and negation connectives the approach is general and goes well beyond the application to xml processing languages as a matter of fact the motivating example we gave in part does not involve xml but looks like a rather classic display of functional programming map map f l case l of x xs f x map f xs even int bool int int even x case x of int x mod x the first function is the classic map function defined in haskell we use letters to denote type variables the second would permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm be an haskell function were it not for two its type declaration contains type connectives type intersection and type difference and the pattern in the case expression is a type meaning that it matches all values returned by the matched expression that have that type so what does the even function do it checks whether its argument is an integer if it is so it returns whether the integer is even or not otherwise it returns its argument as it received it although the definition of even may seem it follows a very common pattern used to manipulate functional datastructures two examples are functional implementation of trees for which our system provides a far better typing and the transformation of xml documents whose elements are modified or left unchanged according to their see actual code in section later on and in appendix a included in the electronic appendix available online furthermore it is a perfect minimal example to illustrate all the aspects of our system in part we showed that the system presented there is expressive enough to define the two functions above and to verify that they have the types declared in their signatures that map has the declared type will come as no in practice we actually want the system to infer this type even in the absence of a signature given by the programmer see section that even was given an intersection type means that it must have all the types that form the intersection so it must be a function that when applied to an integer it returns a boolean and that when applied to an argument of a type that does not contain any integer it returns a result of the same type in other terms even is a polymorphic dynamically bounded overloaded function however the system in part is not able to infer without the help of the programmer the type of the partial application of map to even which must be equivalent to map even int bool int int int since map even returns a function that when applied to a list of integers it returns a list of booleans when applied to a list that does not contain any integer then it returns a list of the same type actually the same list and when it is applied to a list that may contain some integers eg a list of reals then it returns a list of the same type without the integers but with some booleans instead in the case of reals a list with booleans and reals that are not integers typing map even is difficult because it demands to infer several different instantiations of the type of map and then take their intersection this is why the calculus in includes explicit type substitutions the programmer must explicitly provide the typesubstitutions used to instantiate the types of the terms that form an application a requirement that makes the system of not usable in practice yet in this paper we remove this limitation by defining a sound and complete inference system that the typesubstitutions that a programmer should insert in a program for map even we need to infer just two instantiations namely int int and int int bool the type in is redundant since the first type of the intersection is an instance eg for int of the third we included it just for the sake of the presentation of to make it well typed in other words we define local type inference for namely we solve the problem of checking whether there exist some typesubstitutions that make the types of a function and of its arguments compatible and if so of inferring the type of the application as we did for in particular we show that local type inference for reduces to the problem of used to perform type reconstruction and infer types more precise than those inferred by the type systems of the ml family the paper is by an electronic appendix available at http which contains all detailed proofs and complete definitions the system is fully implemented and at the moment of writing in it will be distributed in the next public release of the language in the the current version can be tested by compiling the branch of the we to check the for current issues next section the various problems to be in this research and describes the system of the reader with the work in can skip directly to section overview the aim of this research is the definition an xml processing functional language with polymorphic functions that is in the specific a polymorphic version of the language is a programming language that the manipulation of data in xml format from academic research it is used in production available on different platforms and included in all major linux distributions the essence of is a calculus with pairs explicitlytyped recursive functions and a typecase expression its types can be recursively defined and include basic arrow and product type constructors and the intersection union and negation type connectives in this work we omit for brevity recursive functions and product types constructors and expressions our results can be easily extended to them as sketched in section and detailed in the and add type variables so in the rest of this work we study a calculus whose types and expressions are described by the next two following definitions definition types types are the regular trees generated by the following productions t b t t t t t t and such that every infinite branch contains infinitely many occurrences of constructor we use t to denote the set of all types in the definition b ranges over basic types eg int bool ranges over type variables and and respectively denote the empty that types no value and top that types all values types coinduction accounts for recursive types and the condition on infinite branches out types such as t t t which does not carry any information about the set denoted by the type or t which cannot represent any set it also ensures that the binary relation t defined by t t ti t t ti t is this gives an induction principle on t that we will there are different definitions for local type inference here we use it with the meaning of finding the type of an expression in which not all type annotations are specified this is the used in scala where like in c and java type parameters for method calls can be omitted in our specific problem we will omit and thus infer the annotations that specify how the types of a function and of its argument can be made compatible as explained in section it is more general than pierce and local type inference for arguments types use without any further explicit reference to the relation we use to denote the set of type variables occurring in a type t a type t is said to be ground or closed if and only if is empty the subtyping relation for these types is the one defined by and xu for this work it suffices to consider that ground types are interpreted as sets of values ie either constants or abstractions that have that type and that subtyping is set containment a ground type s is a subtype of a ground type t if and only if t contains all the values of type s in particular st contains all abstractions that when applied to a value of type s if the computation terminates then they return a result of type t eg is the set of all functions and is the set of functions that diverge on every argument type connectives ie union intersection negation are interpreted as the corresponding settheoretic operators eg s t is the union of the values of the two types for what concerns types ie types with variables occurring in them all the reader needs to know for this work is that the subtyping relation of and xu is preserved by substitution of the type variables namely if s t then s t for every the converse does not hold in general while it holds for semantic typesubstitutions in convex models see two types are equivalent if they are subtype one of each other type equivalence is denoted by finally notice that in this system s t if and only if definition expressions expressions are the terms inductively generated by the following grammar e c x ee ii xe et e e and such that in every expression et e e the type t is closed in the definition c ranges over constants eg true false which are values of basic types we use bc to denote the basic type of the constant c x ranges over expression variables et e e denotes the typecase expression that evaluates either e or e according to whether the value returned by e if any is of type t or not ii xe is a value of type ii si ti and denotes the function of parameter x and body e an expression has an intersection type if and only if it has all the types that compose the intersection therefore intuitively ii xe is a welltyped value if for all ii the hypothesis that x is of type si implies that the body e has type ti that is to say it is well typed if ii xe has type si ti for all i i as we said at the beginning of the section the functional core of has exactly the same types and expressions as the above except for two single differences i its types do not contain type variables and ii it includes product types and recursive functions which we omitted here for brevity the reasons why in and in its polymorphic extension we study here there is a typecase expressions and why expressions are explicitly annotated by their intersection types are explained in details in the companion paper that presents the first part of this work and to which the reader can refer the of this research with respect to thus is to allow type variables to occur in the types that annotate abstractions it becomes thus possible to define the polymorphic identity function as xx while the classic term is written as the intended meaning of using a type variable such as is that a welltyped abstraction not only has the type specified in its label and by subsumption all its but also all types obtained by instantiating the type variables occurring in its label so xx has not only type but by subsumption also for instance the types the type of all functions which is a supertype of and the type of all non integer values and by instantiation the actually for every type t all types of the form t are equivalent and each of them denotes the set of all functions types etc the addition of type variables and instantiation makes the calculus a intersection type system see section in for instance by combining intersections instantiation and subtyping it is possible to deduce that xx has type the key problem to be solved then is to define an explicitlytyped calculus with intersection types and a typecase expression this is technically quite challenging because of three main reasons i type instantiation must be explicit ii it may require the use of sets of typesubstitutions and iii it cannot always be immediately propagated to the body of a function a detailed description of these reasons can be found in but in a i instantiation must be explicit because of the presence of a typecase we check the type of a function by checking its type annotation thus any of variables of an annotation must be explicitly propagated that is to apply xx to we must first apply the int to it yielding and only then we can apply the function to ii sets of typesubstitutions are needed because of intersection types a function that expects arguments of type can be safely applied to xx but the latter must be previously instantiated by a set of two typesubstitutions int bool yielding the application of a set of substitution to a type t returns the intersection of all types obtained by applying each substitutions in the set to t iii typesubstitutions cannot be immediately applied to the body of a function since this may yield illtyped terms for instance consider the following definition of the identity function and apply it to the same set of substitutions as before namely int bool this yields the following term which is not well typed to type it one should prove that under the hypothesis x int the term has type int and that under the hypothesis x bool this same term has type bool but both checks fail because in both cases is illtyped it neither has type when x bool nor has it type when x int to with these three problems we proposed in part that the instantiation of the body of a function changes according to the type of the argument of the function for instance when we apply the identity function to an integer we must instantiate its body by the int while the bool must be used when the function argument is a boolean value to obtain this behavior in part we introduced and studied a lazy instantiation of function bodies which delays the propagation of a set of substitutions to the function body until the precise type of the function argument is known this is obtained by abstractions by sets of typesubstitutions for example in order to pass our identity function to a function that expects arguments of type we first instantiate it as follows x the annotation that subscripts the outer indicates that the func tion must be and therefore that we are using the instance whose type is the one in the interface ie to which we apply the set of typesubstitutions in the annotation the will be actually propagated to the body of the function at the moment of the reduction only if and when the function is applied is thus lazy however the new annotation is statically used by the type system to check type soundness formally this is obtained in part by adding explicit sets of typesubstitutions ranged over by to the grammar of definition sets of typesubstitutions can be applied directly to expressions to produce a particular of the type variables occurring in them or as in they can be used to annotate s to implement the lazy of the function body this yields a calculus whose syntax is e c x ee ii j jj xe et e e ej jj where types are those in definition and with the restriction that the type tested in typecase expressions is closed we call this calculus and its expressions the explicitlytyped calculus and expressions respectively in order to it from the one of definition which does not have explicit typesubstitutions and therefore is called the calculus a abstraction ii j jj xe we call the interface of the function and the set of type the of the function we write ii xe for short when the is a singleton con just the empty substitution we use v to range over values that is either constants or abstractions let e be an expression we use fve and respectively to denote the sets of free expres sion variables and bound expression variables of the expression e we use to denote the set of type variables occurring in e as we assume bound expression variables to be pair distinct and distinct from any free expression variable occur ring in the expressions under consideration polymorphic variables can be bound by interfaces but also by for example in the occurring in the interface of the inner abstraction is bound by the and the whole expression variable is such a type variable is called monomorphic we assume that poly type variables are pairwise distinct and distinct from any monomorphic type variable in the expressions under consideration in particular when substituting a value v for a variable x in an ex e we suppose the polymorphic type variables of e to be distinct from the monomorphic and polymorphic type variables of v thus avoiding capture both static and dynamic semantics for the explicitlytyped ex in are defined in in terms of a operation which takes an expression e and a set of typesubstitutions and pushes down to all outermost abstractions occurring in e and collects and with the sets of type substitutions it meets precisely is defined for abstractions and applications of typesubstitutions as ii k kk jj def j jj k kk j jj def ej jj iii where denotes the pairwise composition of all substitutions of the two sets it the set of typesubstitutions when e is either a variable or a constant and it is applied on the remaining expressions see for definitions the dynamic semantics is given by the following notions of reduction where v denotes a value applied by a strategy ej jj ej jj ii j jj vt e e ej jp vx ee where in we have p def jj ii v the first rule performs that is it propagates the sets of typesubstitutions down into the of the outermost abstractions the second rule states the semantics of applications this is standard callbyvalue reduction with the a c bc a x x a e t j a ej jj tj a e t a e s t a ee t · s s jj si j ii jj ii j j a e a t et e a e e s s tt a e a t et e a e e s s a e t a e s a e s t a et e e s s tt figure typing algorithm that the substitution of the argument for the parameter is performed on the body of the function notice that rela depends on the type of the argument and keeps only those typesubstitutions that make the type of the argument v match at least one of the input types defined in the interface of the function ie the set p which contains all substitutions j such that the argument v has type for some i in i the type system statically ensures that p will never be empty for instance take the function instantiate it as in by both int and bool and substitution finally the third rule checks whether the value returned by the expression in the typecase matches the specified type and selects the branch accordingly the static semantics is given by the rules in figure which form an algorithmic system as by the a subscript in a and by the names of the rules in every case at most one rule applies either because of the syntax of the term or because of mutually exclusive side conditions we the reader to for more details there the reader will also find a and far more readable system defined in terms of subsumption here we just comment the rules interesting for this second part that is and first of all no the presence of in judgments this is the set of type variables that is the variables that occur in the type of some outer abstraction and as such cannot be instantiated this set must contain all the type variables occurring in rule by the has the type declared its that is to do that it first adds all the variables occurring in this type to the set in the function body these vari ables are monomorphic then it checks that for every possible input type ie for every possible combination of ti and j the function body e with the single j under consideration ie ej has a subtype of the corresponding output type rule infers for the type obtained by applying the set of typesubstitutions to the type of e provided that the typesubstitutions do not instantiate monomorphic variables ie for all jj noted as j rule for applications checks that the type t of the function is a functional type ie t then it checks that the type of the argument is a subtype of the domain of t denoted by finally it infers for the application the type t · s def t su that is the smallest result type that can be obtained by t to an arrow type with domain s even if t in general t does not have the form of an arrow type it could also be a union or an intersection or a negation of for every type t such that t and type s such that s the type t · s exists and can be effectively computed progress it subsumes existing intersection type systems and type inference is decidable furthermore the calculus can be compiled into an intermediate language which executes only by need and thus can be efficiently evaluated again see part before we again that in this calculus typesubstitutions and thus instantiation are explicit has type but xx does not contrary to ml the semantic subtyping relation does not account for instantiation overview and contributions of this article part recall that we want the programmer to use the expressions of grammar and not those of grammar which would require the programmer to write explicit typesubstitutions therefore in section we define a local type inference system that given an expression produced by the grammar checks whether and where some sets of typesubstitutions can be inserted in this expression so as to make it a welltyped explicitlytyped expression of grammar thus our local type inference consists of a reconstruction system as it has to the sets of typesubstitutions that make an expression of grammar a welltyped expression of grammar in order to avoid ambiguity we the word reconstruction for the problem of type annotations in particular function interfaces and of inference of typesubstitutions for the problem of local type inference in particular we show that this problem can be reduced to the problem of deciding whether for two types s and t there exist two sets of typesubstitutions iii and j jj such that tj jj we prove that when the of i and j are given the problem above is decidable and reduces to the problem of finding all substitutions such that s t for two given types s and t we this latter problem the problem we show how to produce a sound and complete set of solutions for the latter problem this is done by generating sets of that are then normalized merged and solved the solution of the problem immediately yields a procedure that tries all the for i j for the local type inference system to readability we will systematically use the metavariable a to denote expressions of the calculus ie those of grammar and the metavariable e for expressions of the explicitlytyped calculus ie those of grammar finally in section we show that the theory and algorithms developed in section can be reused to do mllike type reconstruction that is to infer the interface of expressions in a pure calculus with typecase in summary the results of this paper make it possible to program in the calculus by compiling it into welltyped explicitlytyped expressions defined in let us show the details on the motivating example of the introduction first note that in the calculus even can be defined as xint x mod x where st is syntactic sugar for while with the products and recursive function definitions given in the appendix map is f nil nil f mf where the type nil tested in the type case denotes the singleton type that contains just the constant nil and denotes the type that is the least solution of x x nil if we these two expressions to the typechecker the rules in figure suffice since no local type inference is needed to type these two functions it that both are well typed and have the types declared in their interfaces to apply the expression defining map to the expression defining even we need to instantiate map that is to perform local type inference the inference system of section infers the following set of type substitutions int int int and inserts it between the two terms so that the type substitutions apply to the type variables of map yielding a typing equivalent to the one in the expression with the inserted set of typesubstitutions is compiled into the intermediate language defined in section of part and executed as efficiently as if it were a monomorphic expression finally in section we show that we could allow the programmer to omit the type declaration for map ie map since it is possible to reuse the algorithms developed in section to for map a type slightly more precise than the one above contributions the overall contribution of this work parts and is the definition of a calculus with polymorphic higherorder functions in a type system with recursive types and union intersection and negation type connectives and local type inference the technical contributions of this part are ­ the definition of an algorithm that for any pair of polymorphic regular tree types t and t produces a sound and complete set of solutions to the problem of deciding whether there exists a such that t t this is obtained by using the settheoretic interpretation of types to reduce the problem to a unification problem on regular tree types ­ the definition of a inference system sound and complete wrt the system of the explicitlytyped calculus of ­ the definition of a sound and complete algorithm for local type inference for the calculus the algorithm yields a procedure for the of a calculus with intersection and recursive types and with explicitlytyped abstractions ­ the definition of a type reconstruction algorithm that uses the machinery developed for local type inference and improves reconstruction defined for ml languages we also provide two different implementations a prototype implementation of the calculus presented here and the polymorphic extension of the compiler of a language inference of typesubstitutions since we want the programmer to program in the calculus then it is the task of the inference system to check whether it is possible to insert some typesubstitutions in appropriate places of the expression written by the programmer so that the resulting expression is a welltyped explicitlytyped expression of the grammar in to define the inference system we proceed in two steps first we define a syntaxdirected deduction system for the calculus by modifying the one in figure whenever the old system checks a subtyping relation the new system tries to guess some explicit type substitutions to insert in that position second we show how to compute the operations used by the deduction system defined in the first step each of these steps is developed in one of the following type substitution assignment in this section we define an inference system for the calculus of definition the system will be sound and complete with respect to explicitlytyped one modulo a single exception we will not try to insert typesubstitutions in that is we will consider only expressions in the explicitlytyped calculus in which all are absent ie they are a singleton set that contains only the empty there is no technical problem to infer also typesubstitutions in not doing so is just a design choice suggested by common sense so as to match the programmers intuition if we write an expression such as x we want to infer that it is illtyped as say haskell does but if we allowed to infer then the expression could be the system to answer that the definition of map does not this signature rather than it the signature by substituting for alternatively we must omit the signature and let the system infer it see section on reconstruction we have to define a system that where sets of typesubstitutions must be inserted so that an expression is transformed into an explicitlytyped expression that is well typed in the system of figure the general role of typesubstitutions is to make the type of some expression satisfy some subtyping constraints examples of this are the type of the body of a function which must match the result type declared in the interface or the type of the argument of a function which must be a subtype of the domain of the function actually all the cases in which subtyping constraints must be satisfied are in figure they coincide with the subtyping relation checks that occur in the rules figure is our thread through the definition of the inference system the rule must be removed and the typing algorithm in figure checks whether for some types s and t the relation s t holds then the inference system must check whether there exists a set of typesubstitutions iii for the polymorphic variables ie those not in that makes t hold the reader may why we apply the only on the smaller type and not on both types the reason can be understood by looking at the rules in figure and that whenever a subtyping relation is specified the righthand side type cannot be instantiated either because it is a ground type rules or because it is a type in an interface and inferring a for it would correspond to inferring a in a rule the only exception to this is the rule for application but for it we will introduce a specific operator later in this section in order to ease the presentation it is to introduce a family of that combine subtyping and instantiation definition let s and t be two types a set of type variables and iii a set iii s of t define and ii i ii s t def iii such that iii s t intuitively it suffices to replace by and by in the algorithmic rules of figure where is the set of monomorphic variables used in the premises to obtain the corresponding rules of inference this yields the system formed by the rules in figure we the symbol by i x ti ia si i ii xa ti si si si ii i a t i a s i a s t i at a a s s t t ii i a i t at i a a a s s t t i a i t i a at a a s s i a t i i aa u a s ut · s figure inference system for typesubstitutions to that it is the inference system for typesubstitutions plus the rules for constants and variables omitted they are the same as in figure of particular interest is the rule which has become simpler than in figure since it works under the hypothesis that abstractions have empty and which uses the set to compare the types of the body with the result types specified in the interface si si notice that we do not require the sets of typesubstitutions that make si si satisfied to be the same for all ii this is not a problem since the case of different sets of typesubstitutions corresponds to using their union as sets of typesubstitutions ie to them pointwise see definition b and corollary b references starting with letters refer to it still remains the most rule the one for application it is difficult because not only it must find two distinct sets of typesubstitutions one for the function type the other for the argument type but also because the set of typesubstitutions for the function type must enforce two distinct constraints the type resulting from applying the set of to the type of the function must be a subtype of and its domain must be compatible with ie a supertype of the type inferred for the argument in order to solve all these constraints we them into a single definition which is the algorithmic counterpart of the set of types used in section to define the operation t · s occurring in the rule precisely we define as the set of types for which there exist two sets of typesubstitutions for variables not in that make s compatible with the domain of t t · s def u j jj t iii s jj u tj jj · in practice this set takes all the pairs of sets of typesubstitutions that make t a function type and s an argument type compatible with t and collects all the possible result types this set is closed by intersection see lemma b which is an important property since it ensures that if we find two distinct solutions to type an application then we can also use their intersection unfortunately this property is not enough to ensure that this set has a minimum type for that we also need to prove that the intersection of all the types in the set can be expressed as a finite intersection which would imply the existence of a principal type which is still an open problem for the application of a function of type t to an argument of type s the inference system every type in t · s this yields the inference rule of figure these inference rules are sound and complete with respect to the typing algorithm modulo the restriction that all the in the abstractions are empty both of these properties are stated in terms of the erase function that maps expressions of the explicitlytyped calculus into expressions of the one by in the former all occurrences of sets of typesubstitutions theorem soundness of inference let a be an expression if i a t then there exists an explicitlytyped expression e such that a and a e t the proof of the soundness property is constructive it builds along the derivation for the expressions a an explicitlytyped expression e that satisfies the statement of the theorem this expression is the one that is then compiled in the intermediate language we defined in part and evaluated notice that the generality of the solutions found by the inference system the smaller the type found the more general the solution is as a matter of fact adding to the system in figure a subsumption rule that uses the relation that is subsumption i a t tt i a t is sound this means that the set of solutions is upward closed with respect to and that from smaller solutions it is possible by such a subsumption rule to deduce the larger ones in that respect the completeness theorem that follows states that the inference system can always deduce for the erasure of an expression a solution that is at least as good as the one for that expression by the type system for the explicitlytyped calculus theorem completeness of inference let e be an explicitlytyped expression in which all are empty if a e t then there exists a type t such that i t and t t the inference system is syntax directed and describes an algorithm that is parametric in the decision procedures for and · the problem of deciding these two relations is next type we define the problem as follows definition problem let c be a that is a finite set of pairs of types these pairs are called constraints and a finite set of type variables a is a solution for the problem of c and noted c if and for all s t c s t holds thus a corresponds to the logical conjunction of the constraints that compose it and the problem searches for a that satisfies this conjunction the definition of the problem is the of our inference system since every problem we have to solve to imple ment the rules of figure is reduced to different instances of this problem with the exception of it is not difficult to show that the implementation of the rules of the inference system i corresponds to finding and solving a particular problem first notice that for the remaining rules the problem we have to solve is to prove or the relation s t for given s and t by definition this n typesubstitutions such each i in two that maps each variable of s not in into a fresh type variable and a type i t the i i domains thus of i the are m if if if if t t t t m then return else pp pp pp and k bn then m t is the smallest variable wrt return else return else m t norm for k in p n then tp m t else t else if t nn ii ti then m p p else let t be the pp disjunctive normal form of t in pp p return m figure constraint normalization by construction pairwise disjoint they are formed of distinct fresh exists a solution to the problem for un t and the way to proceed to find n is explained in section the rule a special treatment since it needs to solve a more difficult problem a solution for the problem that is sound it finds only correct solutions and complete any other solution can be derived from those returned by the algorithm to this end we proceed in three steps i given a problem we show how to effectively produce a finite set of solutions that is sound it contains only correct solutions and complete every other solution of the problem is less the usual sense of unification ie it is larger wrt than some solution in the set ii we show that if we fix the of i and j then it is possible to reduce the rule problem to a problem iii from this we deduce a sound and complete algorithm to the general rule problem and thus the whole inference system we solve each problem in one of the next but be we recall an important property of semantic subtyping sys which states that every type is equivalent to and can be effectively transformed into a type in disjunctive normal form that is a union of uniform intersections of literals a literal is ei an arrow or a basic type or a type variable or a negation an intersection is uniform if it is composed of literals with the same constructor that is either it is an intersection of arrows type variables and their or it is an intersection of basic types type variables and their in summary a disjunctive normal a whose form is either bp q or pp nn qp rn q pp nn qp rn when either p or n is non empty we call the variables qs and rs the toplevel variables of the normal form solution of the problem in order to solve the problem for given and c we first fix some total order any will do on the type variables occurring in c and not in from now on when speaking of type variables we will mean type variables not in order that will be used to ensure that all inferred types satisfy the condition of definition next we produce sets of as a single corresponds to logical conjunction so a set of corresponds to disjunction of the corresponding conjunctions in a particular form by in four steps first we the so that at least one of the two types of every constraint is a type variable second we merge constraints that are on the same variables third we solve all these by producing solvable sets of equations equivalent to the original problem and then solving these equations fourth we combine these three steps into an algorithm that produces a sound and complete set of solutions of the problem to this end we define two operations on sets of definition let s s pt × t be two sets of we define s s def c c c s c s s s def s s by convention the empty set of is it denotes failure in finding a solution while the set containing the empty set is always satisfied we also define an auxiliary function single that out a given toplevel variable of a normal form more precisely given t pp tp which is a nn for that k is t p n we define t as the constraint equivalent to t in which k is that is pp tp nn qp q k when k n and k pp nn tn qp k rn r when k p to readability we will often write s t for the constraint s t as we did above example we will show the various phases of the process by solving the problem for the following c bool int and assume that constraint normalization we define a function norm that takes a type t and generates a set of normalized ie formed by constraints whose form is either s or s whose set of solutions is sound and complete wrt the constraint t this function is parametric in a set m of visited types needed to handle coinduction and the algorithm to compute it is given in figure if the input type t is not in normal form then the algorithm is applied to the disjunctive normal form t of t end of line since a union is empty if and only if every that it is empty then the algorithm generates a new for the problem that all the of a normal form to beginning of line if a contains a toplevel variable then the smallest wrt toplevel variable is out line if there is no toplevel variable and there are only basic types then the algorithm checks equivalence of t and the two following constraints is easily derived from the de laws and the property t t t the constraint by calling the subtyping algorithm and accordingly it returns either the unsatisfiable set of or the one that is always satisfied line finally if there are only intersections of arrows and their then the problem is decomposed into a set of by using the decomposition rule of the subtyping algorithm for semantic subtyping see for details after having added t to the set m of visited types the of types ensures that the algorithm always terminates see lemma c notice that in line the algorithm always out the smallest variable therefore by construction if norm generates a constraint t or t then every variable smaller than or equal to may occur in t only under an arrow equivalently every toplevel variable of t is strictly larger than remark there is the special case of t or t in which t is itself a variable in that case we give priority to the smallest variable and consider the larger variable be a bound for the lower one but not this point will be important for merge a in which all constraints satisfy this property is said to be well ordered cf definition c example the function norm works on single constraints actually on a type t representing the constraint t so let us apply it on the first constraint of the example we want to the constraint bool and thus we apply norm to the type bool ¬ now this constraint has two distinct solutions either i is the empty set in which case the larger type becomes that is the type of all functions see which contains every arrow type in particular bool or ii the types satisfy the usual rule for arrows that is and bool since there are two distinct solutions then norm generates a set of two precisely ¬ returns bool both are normalized and are computed by line in figure the first is computed by the rightmost recursive call of norm notice that p since it ranges over the strict subsets of p which in this case is a it requires sn ie to be empty while the second is obtained by the union of the first two recursive calls which require sn sp and tp tn constraint merging take a normalized each constraint of this set one particular variable however the same variable can be isolated by several distinct constraints in the set we next want to transform this into an equivalent one ie a with exactly the same set of solutions in which every variable is isolated in at most two constraints one where the variable is on the lefthand side and the other where it is on the righthand side in other words we want to obtain a normalized in which each variable has at most one upper bound and at most one lower bound in practice this set represents a set of constraints of the form i i where the is are pairwise distinct this is done by the function m where c is a normalized and m a set containing the types already visited by the function m rewrite c by applying as long as possible the following rules according to the order on the variables smallest first ­ if t and t are in c then replace them by t t ­ if s and s are in c then replace them by ss if there exist two constraints s and t in c st m then else cc s m the function merge performs two steps in the first step it using so as to give priority to smaller variables cf remark the variables isolated by the normalized c and for each such variable it merges all the constraints by taking the union of all its lower bounds and the intersection of all its upper bounds for instance if c contains the following five constraints for s s t t t then the first step replaces them by ss and which corresponds to having the constraint ss such a constraint is satisfiable only if the constraint that the lower bound of is smaller than its upper bound is satisfiable this is checked in the second step which looks for pairs of constraints of the form s and t thanks to the first step we know that for each variable there is at most one such pair and then adds the constraint s t to c this constraint is equivalent to but neither it or s t is normalized thus before adding it to c we it by calling recall that norm returns a set of each corresponding to a distinct solution so we add the constraints that are in c to all the that are the result of via the operator this is why merge returns a set of rather than a single one the so obtained are normalized but they may be not merged yet so we recursively apply merge to all of them via the operator and we record in m of course this step is done only if the constraint s t was not already embedded in c before that is only if is not already in m note that merge preserves the property that in every constraint t or t every variable smaller than or equal to may occur in t only under an arrow example if we apply norm also to the second constraint of our example we obtain a second set of int to obtain a sound and complete set of solutions for our initial c we have to consider all the possible combinations see step of the constraint solving algorithm later on of the two sets obtained by normalizing c that is a set of four int bool bool int the application of merge to the first set leaves it unchanged merge on the second one returns an empty set of since at the second step it tries to solve int the same happens for the third since it first adds and at the recursive call tries to solve bool the fourth one is more interesting in step it replaces bool and int by and at the second step adds obtained from and it also checks which is always satisfied so after merge we have notice that we did not merge and into since then is not considered an upper bound of see remark and thanks to that the resulting is well ordered constraint solving norm and merge yield a set in which every is of the form c i i where i are pairwise distinct variables and si and ti are respectively or whenever the corresponding constraint is absent if there is a constraint on two variables then again priority is given to the smaller variable for instance if then will be considered to represent thanks to this assumption the system so obtained is well ordered that is for every constraint st in it the toplevel variables of s and t are strictly larger than notice that in doing that we do not lose any information the bounds for larger variables are still recorded in those of smaller ones and any bound for larger variables obtained by transitivity on the smaller variables is already in the system by step of merge the last step is to solve this that is to transform it into a solvable set of equations that then we solve by a unify algorithm that exploits the particular form of the equations obtained from a let c be a of the above form we define as follows s t s t c fresh the function takes every constraint s t in c and replaces it by s t with fresh it is clear that the c has a solution for every possible assignment of included between s and t if and only if the new has a solution for every possible unconstrained assignment of at the end the i i has become a set of equations of the form i ui i i where the is are pairwise distinct by construction this set of equations has the property that every variable that is smaller than or equal to wrt i may occur in ui only under an arrow as for we say that the set of equations is well ordered this last property ensures the of the equation defining the smallest type variable by and lemma c there exists a solution of this set namely a substitution from the type variables n into possibly recursive regular types t tn whose variables are contained in the fresh is variables introduced by solve all universally quantified ie no upper or lower bound and the type variables in this solution is given by the following unify procedure in which we use to denote regular types and where e is a set of equations if e then return else ­ select in e the equation t for the smallest wrt ­ let e be the set of equations obtained by replacing in e t every occurrence of by x fresh ­ let in return thanks to the of e unify generates a set of solutions in which all types satisfy the condition on infinite branches of definition it solves the contractive recursive equation of the smallest variable defined by e if does not occur in t then the can be omitted replaces this solution in the remaining equations solves this set of equations and applies the solution so found to the solution of so as to solve the other variables occurring in its definition the complete algorithm the algorithm to solve the problem for c and variables not in then proceeds in three steps step let n if n then fail m then fail else es let denote the set of all substitutions obtained by the previous algorithm they form a sound and complete set of solutions for the problem theorem soundness and completeness c c st where means that the two substitutions map the same variable into equivalent types of types ensures the termination of the algorithm and hence the decidability of the problem the proof of these properties combines proofs of soundness completeness and termination of each step see appendix c example end after step and our initial problem bool int has become let us apply step the first is trivial and it is easy to see that it yields the solution the second is we apply solve to the constraints for obtaining we find the solution for no need to substitute since it does not occur in the constraints for which is we replace in the solution of obtaining the solution for this second is then which with forms a sound and complete set of solutions for our initial problem finally solve introduces several fresh polymorphic variables which can be up after that the substitutions have been applied to obtain the types by inference system all variables that occur only in covariant resp contravariant position in a type can be replaced by resp this is what we implicitly did in our example to solve and eliminate from the constraint of solution for application with fixed it remains to solve the problem for the rule we recall that given two types s and t a solution for this problem is a pair of sets of typesubstitutions iii for variables not in that make both of these two ti sj dom ti ii jj ii hold two complications are to be dealt with i we must find sets of type substitutions rather than a single substitution as in the tal problem and ii we have to get of the dom function if i and j have fixed then both difficulties can be easily and the whole problem be reduced to a prob lem to see how consider the two in since the two sets of substitutions are independent then without loss of generality we can split each substitution k for in two substitutions a renaming substitution k that maps each variable in the domain of k into a ke transformed the problem in into the problem of finding for two given types t and t all substitutions such that t and t hold finally we can prove see lemmas c and c that a solves if and only if it solves t and t t with fresh we transformed the application problem with fixed into the problem for t t t whose set of solutions is a sound and complete set of solutions for the rule problem when i and j have fixed solution of the application problem the algorithm to solve the general problem for the rule all the possible combinations of the of i precisely we have t ii ti and t ij ti where for h into fresh obtained from th by renaming the variables not in and j by say a order more precisely we start with both i and j at cardinality and step a generate the t t as explained in subsection the constraint t is implied by this one since contains every arrow type and apply the algorithm described in subsection yielding either a solution a substitution for variables not in or a failure step b if all the failed at step of the algorithm of subsection then fail the expression is not if they all failed but at least one did not fail in step then increase the of i and j to their successor in the order and start from step a again otherwise all substitutions found by the algorithm are solutions of the application problem notice that the algorithm returns a failure only if all the fail at step of the algorithm for the problem the reason is that up to step all the constraints at issue are on distinct occurrences of type variables if they fail there is no possible expansion that can make the satisfiable in step instead constraints of different occurrences of some variable are merged thus even if the constraints fail it may be the case that they will be satisfied by expanding different occurrences of some variable into different variables therefore an expansion is tried solving the problem for s t is similar there is just one set whose cardinality has to be increased at each step instead of two this a sound and complete procedure for the application problem and thus for the inference system theorem c we defined some heuristics omitted for space reasons see section c to stop the algorithm when a solution seems whether these or some halting conditions preserve completeness that is whether typesubstitutions inference is decidable is an open problem we believe the system to be decidable however we fail to prove it when the type of the argument of an application is a union its expansion the union over the intersections thus generating new combinations of types it comes as no that the definitions of our heuristics are based on the and of the unions occurring in the argument type let us apply the algorithm to map even we start with the constraint set t where t is the type of even we just renamed the variables of the type of map after step a the algorithm generates a set of see section of for more details on this example one is unsatisfiable since it contains the constraint t an intersection of arrows is never empty since it always contains the type of the functions four of these are less general than some other their solutions are included in the solutions of the other and the remaining four are obtained by adding the constraint respectively to int bool int int int yielding the following four solutions for or or or of these solutions only the last two are minimal since both are valid we could stop here and take their intersection yielding the type expected in the introduction if instead we strictly follow the algorithm then we have to perform a further iteration expand the type of the function yielding t for which the minimal solution is as expected a final remark on completeness the theorem states that for every solution of the inference problem our algorithm finds a solution that is more general however this solution is not necessary the first one found by the algorithm even if we find a solution with a further expansion may yield a more general solution we have just seen that in the case of map even the good solution is the second one although this solution could already have been by the first minimal solutions we found a simple example that shows that carrying on after a first solution may yield a better solution is the application of a function of type × × to an argument of type for this applications our algorithm extended with product types returns after one iteration the type × since it with while one further iteration would deduce the more precise type of course this raises the problem of the existence of principal types notice that the type t in the statement of theorem is not unique may an infinite sequence of general solutions exist this is a problem we did not in this work but if the answer to the previous question were negative then it would be easy to prove the existence of a principal type since at each iteration there are only finitely many solutions then the principal type would be the intersection of the minimal solutions of the last iteration finally notice that we did not give any reduction semantics for the calculus the reason is that its semantics is defined in terms of the semantics of the explicitlytyped calculus the at runtime is an essential feature independently from the fact that we started from an explicitlytyped expression or not and we cannot avoid it if we denote by the set of expressions e that satisfy the statement of theorem then the bigstep semantics for an expression a is given in terms of if an expression in reduces to v so does a as we see the result of computing an expression is a value of the explicitlytyped calculus so abstractions may contain nonempty and this is since it may be the result of a partial application this can be made transparent for the programmer by returning just the type and the value fun as in toplevel also notice that the semantics is not determined since different expressions in may yield different results however this may happen only in one particular case namely when an occurrence of a polymorphic function flows into a typecase and its type is tested for instance the application true results into true or false according to whether the polymorphic identity at the argument is instantiated by int or by int bool once more this is in a calculus that can dynamically test the types of polymorphic functions that admit several sound instantiations this does not happen in practice since the inference algorithm always choose one particular instantiation the existence of principal types would make this choice canonical and remove any residual so in practice the semantics is deterministic but implementation dependent in summary programming in the calculus corresponds to programming in the explicitlytyped one with the difference that we to the system the task to write typesubstitutions for us and with the that by doing that we make the dynamic test of the type of a polymorphic function to be implementation dependent of course the dynamic test of the type of polymorphic functions or of functions make this problem and yields much a simpler implementation examples and experiments we developed two implementations see the last page of the appendix for instructions a complete but prototype with products and arrow type constructors and an extension of the full language which is highly optimized types are stored in binary decision trees to avoid the cost of normalization patternmatching has optimal implementation static analyses are used to minimize the impact of polymorphism and so on in this section we show examples of the latter that is of syntax extended with type variables in this extension map has type since in sequence types are denoted by brackets whose content is described by a regular expression on types functions are explicitly typed and thus must specify both their input and output types let x int string x or the whole interface when they are typed by an intersection type let even int bool int int x int x mod x x the type returned for the partial application map even is then unions and intersections are denoted by and respectively while the one for map is while the righthand side arrow of this intersection is the type an ml programmer would expect our inference algorithm also the special case stating that the function maps the empty list into itself interestingly the solver does not need to know the body of map to deduce it this is because encodes lists by recursive union types stands for x where nil denotes the empty list and our system tries to infer a result for every type in the union instantiation works as expected as the following of interactive toplevel shows is the prompt of the toplevel while its output is displayed in let g int int int int bool bool bool bool x x val g bool bool bool bool int int int int fun let id a a x x val id a a fun g id bool bool int int fun id id g bool bool bool bool int int int int fun our system includes singleton types types that contain a single value and thus the type returned for instance for let x y x in is ie the type of functions that accept any argument and return and likewise id has type more surprising may be the case for a function such as max whose definition uses the polymorphic comparison operator greater than let max x y if x y then x else y val max fun an ml programmer would probably expect the partial application max to be typed as or at least we were that instead for this application the system returns the type and so the point is that our system includes union types and therefore an application such as max is well typed it suffices to instantiate the variable in the type of max by the union type to give the final instantiation for the type system must know the type of both arguments of max therefore in the case of the partial application it with stating that it knows that contains at least the value and for the second argument to instantiate the missing part represented by and the type returned for max is in this example we specified the type for max since this is what an ml programmer would following the ocaml convention in the concrete syntax type variables start by a quote to readability here we print them by letters and so write rather than a b have written however in a system with polymorphic union types a more meaningful type for max is if we specify such a type for max then the type for the partial application max is more intuitively the fact that and cannot from any practical point of view be distinguished seems a nice feature of our system nevertheless notice that the same type deduction as for max would have if in the definition of we had used instead of in that case would have been typed by the less precise union type too thus in order to achieve precise typing it is important to use distinct type variables for distinct parameters finally we said in the introduction that the typing of even follows a pattern that is common in programming functional data structures this can be seen by examining implementation of trees these are balanced binary search trees whose nodes are colored either in black or in red and such that every red node has two possibly empty black children a red node with a red child is a wrong tree must keep the tree balanced and the key definition is a function balance which transforms every tree ie a tree with a wrong child into a tree and leaves all other trees unchanged gives a very compact and elegant definition of balance consisting of a pattern matching with two cases for a union and for a capture variable but current type systems are not expressive enough to verify that his code without any modification satisfies color invariants our types instead can do it as follows type type elem type red elem type elem wrong wrong type wrong red elem let balance z red y red x a b c d z red x a red y b c d x a red z red y b c d x a red y b red z c d red y x a b z c d x x the only irrelevant difference of this definition with definition of balance is that we used syntax for trees that is xml elements tagged by their color with an attribute elem for their content and that sequences of two subtrees the type of balance which has the same form as the type of even precisely describes the behavior of the function and this type information is enough to prove that the insertion function has type that is that when it inserts an element into a wellformed it returns another wellformed tree see appendix a for the complete code and how to run it on the development version of the results and algorithms of this paper to was not easy the internal representation of types and its algorithms is challenging to give an idea of such a challenge consider that a simple type variable is internally represented as a union of binary decision diagrams each the top type of a type constructor and so are type and error message generation for what is specific to this work the main challenge is not only to extend the typing rules of figure to missing data structures and expressions xml trees general pattern matching products but above all to modify the rules so that they return expressions with sets of explicit types substitutions also the various internal languages used by the compiler must be modified the compiler performs several passes that translate each intermediate language into a lower level one and each transformation phase must be with specific static analyses to optimize the evaluation of polymorphic expres sions finally the propagation of type substitutions must be implemented for all constructed values ie pairs and xml documents the main modifications are summarized in appendix e for what concerns the results of some preliminary experiments are reported in appendix f in summary we generated a test suite of applications of higherorder polymorphic functions by taking all the functions exported by the list module of ocaml and cross applying one to each other whenever a given function can be applied ie the application in ocaml to two other functions then we applied it to their intersection and their union whenever two functions can be applied to the same function then we applied their union and their intersection to it and so on so up to a maximum of toplevel connectives we also tested all applications resulting illtyped in ocaml so as to check cases in which local may fail the results are significant and the test suite was defined to the possible exponential up which is essentially due to the presence of arrows and intersections that may trigger multiple the combinations of the functions of the list module cover a wide range of use cases and involve recursive types specifically polymorphic lists and the limit of connectives on arrows more than what we ever met in practice to type check the applications on an average took with an average time for application of ms and ms of time this means that apart from few cases which took a of seconds our implementation performs local type inference within acceptable delays we also verified that our implementation handles the application of functions to arguments cf ocaml standard library whose functions have at most arguments furthermore the room for improvement is still important our implementation uses the datastructures of types and memoization however normalization and constraint generation are implemented as described in this paper in particular as in line in figure normalization performs a full expansion by modifying the algorithms so that like in the subtyping algorithm normalization and constraint generation are performed we hope to improve performance by an order of magnitude type reconstruction the theory of type we developed in section can be reused to perform type reconstruction that is to assign a type to functions whose interface is not specified the idea is to type the body of a function under the hypothesis that the function has the generic type and deduce the corresponding constraints formally we consider expressions produced by the following grammar m c x mm xm mt m m together with the judgment r m t s that states that under the typing environment m has type t under the constraints in s provided that s is satisfiable the subscript r indicates that this is a type reconstruction system these judgments are derived by the rules in figure these are quite standard apart from the fact that they derive multiple rather than just one this is due to the type reconstruction rule for which four possible alternatives m diverges it can match only the first the second or both cases in this system the type of a welltyped expression is a type and a set of typesubstitutions ie the set of all substitutions that are solutions of the satisfiable in s and thus it is an intersection type obtained by applying this set of typesubstitutions to the type the soundness of this system is a consequence of the results on the inference of the previous sections as a matter of facts this system is precisely the same system as the one in the previous sections with the only difference that all interfaces are of the form and to that we infer typesubstitutions r c bc r x x r m t s r m t s r mm s s t t x r m t s r xm s t s r m ts s t s s t t t s s t t s s s t t r m ts r m ts r mt m m s where i and in each rule are fresh type variables figure type reconstruction rules in we also used a different and more standard presentation to constraint generation of course completeness does not hold far from that for instance it is impossible in general to deduce for a function without type annotations the type the type of all functions since this would correspond to decide the halting problem though our algorithm returns for µf xf x the same type as in ml that is likewise completeness would imply decidability of reconstruction and thus imply decidability for intersection type systems which are undecidable similarly our reconstruction system cannot type the functions we pointed out in the first part of this work see section in however if a function can be typed in mllike type systems then our type reconstruction rules can deduce a type at least as good as the ml one indeed if we restrict our attention to the first four rules the system produces a singleton set of constraints that is the same as in ml system cf and when are not circular ie their solution does not require recursive types then our constraint solving algorithm coincides with unification all fresh variables introduced by solve are simplified as we described at the end of section and solve directly produces a set of equations that are in and terminology in solved form furthermore since the types considered here are much richer than in ml since they include unions intersections and then our reconstruction may infer slightly better types type connectives alone bring in particular two advantages for type reconstruction i the system sets of typesubstitutions and thus intersection types and ii pattern matching which can be seen as a typecase with singleton types is typed more precisely thanks in particular to intersections and for instance and contrary to ml our type reconstruction can type for which it returns the recursive type t this type is a subtype of thus it is more precise than the classic nonrecursive typing of in intersection type systems t though it is not as precise as its subtype which can also type as a final example if we apply our type reconstruction algorithm extended with products and recursive functions to the type erasure of the map function defined in equation then we obtain the type in syntax see the complete unfolding of the algorithm in appendix d thanks to the precise typing of the typecase our type is slightly more accurate than the ml type since it states that the application of map to any function and the empty list returns the empty list finally the type returned by the type reconstruction algorithm is not always very readable and often needs to be simplified for instance the type we showed for map was obtained after apply ing some simplifications one of which was done by hand and defining an algorithm that does the right simplifications is not obvious eg how to detect that the type is much more readable than the type for by our algorithm the simplification of types or of type constraints is a stand alone research topic that further investigation nevertheless our reconstruction algorithm can already be used as is to make type declaration of local functions optional indeed for local functions the system is not required to return a readable type to the programmer but just to check whether there exists a typing for local functions that is compatible with their usage and for that our system is enough even though we will probably have to it with bidirectional typing techniques to provide informative error messages when the check fails extensions in this presentation we omitted two key features pairs and recursive functions recursive functions do not pose any particular problem in the inference of typesubstitutions and are dealt with in a way while pairs are more challenging the rule for pairs in inference system i is the same as in the explicitlytyped calculus this corresponds to sets of typesubstitutions applied inside a pair as they can equivalently be inferred outside the pair ti and ti si instead as expected the rule for projection ie needs some special care since namely by solving a sequence of problems generated by increasing at each step the cardinality of i see the appendix in the first part of this work we studied the extension of the explicitlytyped calculus with in its typing and efficient execution see section of there we distinguished variables by them is mostly useful when combined with to extend our reconstruction to let we use a separate type for these variables while we for abstracted variables as in w algorithm we need to de fine t the generalization closure in of a type t wrt the type environment where i are that is t fresh then the r x x let r e t s r let x x t r e in e t s e t s s related work this section discusses related work on type inference and inference for type systems discussion about work on explicitlytyped intersection type systems and on xml processing languages can be found in part of this work type inference in ml has essentially been considered as a constraint solving problem we use a similar approach to solve the problem of type unification finding a proper substitution that makes the type of the domain of a function compatible with ie a supertype of the type of the argument it is applied to our type unification problem is essentially a specific set constraint problem this is applied in a much more complex setting with a complete set of type connectives and a rich settheoretic subtyping relation in particular because of the presence of intersection types solving the problem of application demands to find sets of substitutions rather than just one substitution this is reflected by the definition of our relation which is much more than the corresponding relation used in ml inference as it instantiation expansion and subtyping the important of our work comes from the use of settheoretic connectives which allows us to turn sets of constraints of the form st into sets of equations of the form s t a technique that in our is original to our work this set of equations is then solved using work on infinite trees the use of type connectives also implies that we solve multiple sets of constraints which account for different alternatives finally it is worth that use a richer language of constraints that includes binding this allows separating constraint generation and constraint solving without efficiency therefore an interesting direction of future research is either to our work into a richer language of constraints or to extend the work in to our richer setting this could be a first step towards the study of efficient constraint solving algorithms for our system the programming language to our language ie polymorphic is typed since it has recursive types union types top and singleton types subtyping dynamic called occurrence typing in and explicitlytyped polymorphic functions the goal of typed is to type an existing untyped programming language and it is to our system in that it allows the combination of both typed and untyped code in a single program for what concerns typed features however typed is just a small fragment of our system can only test basic types and tests for just some constructed types can be encoded by using boolean connectives there are no intersection types thus no overloaded functions there are no negation or difference types union types and their subtyping are quite naive eg a type is a subtype of a union of types only if it is a subtype of some type of the union distribution laws over type constructors are absent etc the typing of typed is internally defined in terms of propositional logic where atoms are the elements of a type environment eg x the use of logical formulas coincides in to computing the types of capture variable of patterns cf the operator tp in appendix e or in the use of propositional logic corresponds to the use of boolean connectives in patterns and of a formula to type emptiness this is why all the examples in the challenges section of can be easily defined and precisely typed in our system straightforwardly with the syntactic sugar defined in the appendix e of part actually these examples can already be defined and typed in monomorphic since it already captures all the features characteristics of typed recursive and union types subtyping occurrence typing etc with the exception of polymorphism a gap filled by this work typed uses a limited form of local type inference the application of a function to a polymorphic argument requires the application of an explicit type substitution to the argument we do not have this limitation thanks to our procedure that computes instantiations type both for the function and for its argument it is not clear whether using generic smt solvers for typing as suggested by also in case where subtyping is checked by type emptiness would yield a better subtyping algorithm local type inference was first formalized as far as we know by pierce and turner they consider i a type system with type variables arrow top and bottom types ii an internal language with explicitly typed polymorphic functions that to be applied must be explicitly instantiated and iii an external language in which some or all such instantiations can be omitted then they show how to infer type instantiations for programs of the external language in order to obtain when possible welltyped programs of the internal language our work shares much of the and goals of pierce and turner expressions of grammar form our external language those of grammar the internal one and our sets of typesubstitutions generalize pierce and instantiations our work extends and generalizes pierce and one in several ways first in an application we infer both for the function and for the argument while does just the former typed does the same as a consequence while the application of the polymorphic identity xx to a function f of type can be typed in their systems by inferring the instantiation the application of the same f to the polymorphic identity cannot be typed while our system types it by instantiating the argument by the substitution int second our system accounts for more expressive types expressions and subtyping relations for instance essentially solves the problem for simple whose form is the same as those obtained after applying our merge instead we manipulate sets of to account for alternatives generated to check either the typing of or the subtyping relation and iterate the problem with different because of the presence of intersection types third an instantiation for a type variable only if its occurrences are either all positive or all negative and fails otherwise while our system thanks to the use of type connectives and recursive types always generates a set of solvable equations finally we want to as a that works on type reconstruction for intersection type systems are weakly related to our study the reason is that the core of our technique consists in solving type by recursive types with recursive types pure intersection type systems are trivially decidable since all terms can be typed by the type the problem we here thus is different namely we check whether it is safe to apply to each other expressions of two explicitly given and possibly recursive types in which some basic types may occur there are however a few with some techniques developed for pure intersection type systems that are discussed in the extended version of this paper available on line conclusion the work presented here together with the one in provides the theoretical bases and all the algorithmic tools needed to design and implement polymorphic languages for data and more generally generic functional languages with recursive types and settheoretic unions intersections and in particular our results made the polymorphic extension of possible and the way to the definition of a real type system for not the current one in which all higherorder functions have type function thanks to type reconstruction these languages can have a syntax and semantics close to those of ocaml or haskell but also include primitives in particular complex patterns that exploit the great expressive power of settheoretic types as the trees and max examples in section demonstrates ocaml and haskell would certainly benefit from the addition of settheoretic type connectives we plan to study such an extension in the future some problems are still open notably the decidability of inference but these are of theoretical nature and as our experiments should not have any impact in practice the only problem open in this second part of the work that is the non determinism of the implicitly typed calculus should have a practical impact as it is theoretical in practice the semantics is deterministic but implementation dependent and it concerns only the case when the type of an instance of a polymorphic function is tested at runtime in our programming experience with we never met a single typecase for a function type nevertheless it may be interesting to study how to remove such a either by defining a canonical choice for the instances de by the inference system a problem related to the existence of principal types or by reasonable restrictions or by checking the flow of polymorphic functions by a static analysis on the practical side by implementing the polymorphic extension of and applying it we realized that it would be useful to allow monomorphic type variables to occur in patterns see appendix a for examples which in this work this would correspond to have a type case on types that may contain monomorphic type variables how to do it is not straightforward and looks as a promising research direction other interesting directions of research are the study of heuristics to simplify types generated from constraints so as to make type reconstruction for toplevel functions human the generation of meaningful type error messages the study of efficient implementation of the extension of the between ocaml and to include polymorphic types and later on the inclusion of gadts acknowledgments we want to thank the reviewers of popl who gave detailed suggestions to improve our presentation this work was partially supported by the project n xu was also partially supported by an of of and by the grant n of the national natural science foundation of references a aiken and e l type inclusion constraints and type inference in pages ­ v g and a an general purpose language in icfp acm press g k z xu h im s and l polymorphic functions with settheoretic types part syntax semantics and evaluation in popl january g and z xu settheoretic foundation of parametric polymorphism and subtyping in icfp b fundamental properties of infinite trees theoretical computer science ­ l and r milner principal for functional programs in popl pages ­ r practical checking phd thesis carnegie mellon university j et al an xml query language working draft a et de à xml phd thesis u paris a g and v semantic subtyping dealing with function union intersection and negation types the journal of acm ­ a and u an efficient unification algorithm acm toplas ­ m odersky m and m type inference with constrained types ­ c purely functional data structures bc pierce and dn turner local type inference acm trans program lang syst ­ f pottier and d the essence of ml type inference in bc pierce editor advanced topics in types and programming languages chapter pages ­ mit press s and m felleisen the design and implementation of typed scheme in popl s and m felleisen logical types for untyped languages in icfp z xu parametric polymorphism for xml processing languages phd thesis paris available at 