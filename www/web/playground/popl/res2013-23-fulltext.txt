the type discipline of behavioral separation c and de de e de abstract we introduce the concept of behavioral separation as a general principle for interference in higherorder imperative concurrent programs and present a typebased approach that systematically the concept in the context of an mllike language extended with concurrency and synchronization primitives behavioral separation builds on notions originally introduced for behavioral type systems and separation logics but shifts the focus from the separation of static program state properties towards the separation of dynamic usage behaviors of runtime values behavioral separation types specify how values may be safely used by client code and can enforce finegrained interference control disciplines while preserving compositionality information hiding and flexibility we illustrate how our type system even if based on a small set of general primitives is already able to fairly challenging program idioms involving aliasing at various types concurrency with firstclass threads manipulation of linked data structures behavioral and separation categories and subject descriptors d programming languages language constructs and features f logics and meanings of programs verifying and reasoning about programs f logics and meanings of programs type structure keywords behavioral types separation interference concurrency higher order programming introduction the purpose of this work is to introduce and develop the concept of behavioral separation as a general principle for interference in higherorder imperative concurrent programs statically verifying that higherorder imperative programs do not go wrong in the presence of possible interference has proven to be a challenging task and a ground for research since the work of reynolds in general two program fragments interfere when the effects generated by one fragment may change the state visible to the other typically due to aliasing or to concurrency some forms of interference are bad and may cause failure such as readwrite races when accessing the same memory cell other forms of interference are good and even required such as the interference between a producer and a consumer running concurrently and sharing a queue or permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm the interference between the head and tail references of a linked list structure interference is the essence of concurrency as jones frequently an issue to overcome is then to find techniques for interference between different of the same objects and ensure safety while being able to address sophisticated programming idioms significant advances have been achieved recently towards these general goals in particular by the separation logics of ohearn and reynolds and by several type and effect systems eg namely separation logic supports expressive forms of local reasoning based on the use of the separating conjunction in combination with fractional permissions to characterize the fine structure of program states extending such statebased techniques to the sophisticated program idioms arising in modern higherorder imperative concurrent programming is thus both promising and challenging in this work we from a statebased view towards a behavioral view of program assertions and introduce the notion of behavioral separation behavioral separation builds on concepts in behavioral type systems and separation logics but shifts the focus from the separation of static program state properties towards the separation of dynamic usage behaviors of runtime values more concretely we develop a type structure that systematically the concept of behavioral separation to enforce safety of programs out bad in the presence of aliasing and concurrency our presentation is on a core mllike programming language with concurrency primitives designed as a convenient abstraction for a large family of languages supporting higherorder imperative concurrent programming behavioral types based on process algebras characterize the interface of a system not just as a specification of the static type of messages but more importantly as a specification of its dynamic behavior likewise our behavioral separation types specify how program values may be safely used by client code but unlike pure behavioral types are able to capture finegrained interference control disciplines a key of our approach consists in uniformly combining in the same type structure temporal operations such as sequential separation important to capture constraints on traces with spatial operations such as parallel separation and isolation important to discipline aliasing and concurrency we carry out our development in the context of a clean type theory in which all type operators satisfy natural algebraic properties based on a calculus extended with imperative references and concurrency constructs behavioral separation types information hiding compositionality and flexibility since type assertions talk about separation constraints on usage behaviors as by the programs which use them rather than about the internal structure of program state or code as will be clear from our examples behavioral separation types are also expressive and flexible enough for proving safety of programs combining features still challenging for and even out of reach of existing proof methods including general higherorder store aliasing sharing at all types linked data structures of local behavior firstclass threads and separation based on typed synchronization constructs overview in this section we the general concept of behavioral separation informally introducing our core programming language and the various behavioral separation type operators by going through a sequence of examples consider first the following implementation of a collection adt where we assume list elements to be natural numbers and the representation data structure to be a linked list let var next elt in e elt p next in let var hd id in init null id i id add n nil in e hd scan var s in s hd rec s of null nil s l we define four operations on collections the init which sets the collection identifier a string the operation which returns the collection identifier the add operation which adds a new element to the collection and the scan operation which traverses the linked list each node in sequence we model adt objects by tuples of closures sharing memory locations and classes by object generating functions along standard lines in our language tuple fields are bound to expressions code to be evaluated only after field selection as eg in the var x in e block creates a heap allocated variable where the created cell can the lifetime of the body e embedded in the value returned cf let x in e in ml in the code shown above the private hd variable refers to the head of the linked list and is shared by the add and scan operations we represent references to list elements by variant values with abbreviated null and representing the null reference and representing a list node in n is a tuple with fields and notice that the latter two fields access the heap variable next which references the next node if any and is local to the given node using standard functional and product types we could assign to a type as sc where is a unit type and sc a record type representing the collection objects such a record type would essentially specify a flat interface listing the signature of the operations available each one modeled as a typed field quite differently in our system types specify value usage behaviors rather than value structure as a first example consider sc str add nat scan the type sc specifies a possible usage behavior by a collection intuitively the type sc says that collections may be used by first calling the init method and then the add and scan methods in iterated choice first it offers a label selection usage denoted by the label selection type the usage consists in selecting the init label to get a value of type str the stop type specifies that no usage is available the operator is our primitive functional type u v is a type for functions which do not interfere with their argument and specifies a single usage of a value as a function at the appropriate argument u and return type v the u v does not correspond to a standard function type u v which can nevertheless be encoded in our system as will become clear later it does neither correspond to the linear arrow nor to the arrows of separation or logic even if it is closely connected to all of these in a concurrent programming world there are just too many ways of using a function object in with other type operators the functional type u v allows much of such variety to be sequencing of behaviors is expressed by the sequential separation type operator a value typed by u v first offers to clients the usage behavior u and only after v in our example after the usage behavior the collection value offers a usage str add nat scan this last type specifies the iterated choice between the selection of fields add and scan each one yielding a value of respectively type str nat and choice between alternative behaviors is expressed using intersection types a value typed by u v offers to clients the choice between behaviors u and v since it can provide both u and v alternatively the star type u denotes the iteration of u clearly the type operators just described may express rich sequential protocols still they are not expressive enough to express aliased or concurrent due to the strict linearity they enforce a more flexible and still safe usage type for our collection would allow after initialization the operation to be always available concurrently with a add or a scan operation to express this possibility we use the parallel separation type operator in general a u v type asserts that behaviors u and v may be safely used by independent clients either due to aliasing or to concurrency without in unsafe interference such a parallel usage only completes when both behaviors u and v complete exploring parallel separation we may assign to function the more flexible type cc where cc str scan the type cc asserts that after initialization a collection provides two independently usable behaviors one of type str and other of type scan composed using the parallel separation type operator the type operator used in str and scan specifies an unbounded number possibly zero of separated parallel parallel in the sense of in particular the type str allows an unbounded number of possibly concurrent aliases to access the field str then the type scan specifies a usage consisting of the interleaved of some parallel of the scan behavior followed by the behavior only after all the scan operations selected in the scan phase conclude will become again available since there is no obligation to pick any scan operation in the scan phase the type cc also allows any number of operations to be sequentially performed notice that the behavior of a newly created collection c is completely separated or isolated from context no behavioral dependencies exist between and the behavior of other values in a program using the collection we express isolation which plays an important role in our framework by a specific type operator we thus assign to the function the type cc let us now consider some code using the collection type just defined and discuss valid and invalid typings let c in my let c in my both code fragments are validated by our type system in the first one it is clear that the usage of c follows the intended type in the second one the intended usage type of c is also not violated even if behaviors that appear parallel separated in the type eg str and are sequentially used in the code clearly if a value may be safely used according to u v it may also be safely used according to u v subsumption principles as this one are captured by subtyping a preorder on types written u v in particular subtyping satisfies the exchange law a c b d a b c d of which u v u v is a special case the next examples illustrate behavioral where fragments of the behavior of c are used by some function before being given back to the caller context let c in let f your in f c let c in let g in my g c g c in the second case the function is used twice at different places of the global behavior the type is declared in the function domain eg f on the other hand let c in let h your in h c attempts to use add before init and is rejected by our type system more interesting examples illustrate of behavior through the store which our type system is able to handle in a natural way even in a higherorder setting consider the following code it respects the expected behavioral constraints on the value c and the heap allocated variable a even if the behavior of c is accessible at a and is in fact in our system let c in var a in a c my heap variables are assigned behavioral separation types expressed in terms of use use read and write capabilities and related by subtyping axioms we show some of them here var use var use v v the first two axioms say that a single use of a variable consists in writing on it a value of type u followed by a matching read phase the following axioms specify how the reading phase may be separated depending on the type of the stored value the next example illustrates higherorder through the store the function attached to the add field is itself stored in memory before being called let c in my var a in a a this code does not violate any constraints imposed by the type of c even if a collection method a functional value is extracted by selecting and stored in the temporary heap variable a these last two examples get past our typing discipline because the type system keeps track of global separation constraints between all the values in the scope and relies on sequential and parallel frame reasoning to locally replace behaviors in behavioral separation type assertions in the last example the function of type nat is required to be used exactly once before scan is selected in c even if its behavior is stored in the variable a the initial footprint of of in the global behavioral separation type the type precondition of a is nat · · · and the postcondition is nat · · · notice that this last type sequentially the behaviors of a and c forcing a to be read before using c the ability to specify global separation constraints involving several values seems essential for the expressiveness of our system as a further illustration of this point consider let c in let m in here the init qualifier is selected but since the associated functional behavior bound to m is not actually the initialization of the local hd variable is not performed causing the scan operation to crash in the case expression of course this code does not type check under our current assumptions since it does not preserve the frame conditions imposed by the intended behavioral separation protocols indeed would need to be typed under the precondition · · · which states that m must be used as a function before with the continuation behavior of collection c which is not possible the type system systematically uses local reasoning and frame principles on behavioral separation assertions to compute effects of program fragments as another example consider var s in s hi let f c in x c in let u f s in s ok so f returns an initialized collection the precondition type assertion to typing f s is var f str cc we assume that the type of strings str is str str so that reading from s does not empty the variable to type function application we collect the of argument and function as f str cc var after typing let u f s the type assertion is var this says that u must be fully used as cc before the variable s can used again which is not sensible however the behavior cc is isolated as expressed by so the use of s does not depend on it by the subtyping law u v u v we actually reach var and then by rd isolated types offer a safe escape from the strict locality discipline allowing isolated behaviors to be fully and soundly separated from a global type in which they might appear embedded as a further illustration the following code is by assigning cc to f so that it captures the argument full behavior storing it in heap variable a rather than it let c in var a in let f xa x in f c my we now consider some examples with concurrency the parallel expression e e clearly up the possibility of interference the next of examples are safe and typecheck in our system let c in my let c in let f in my f c f c on the other hand the code let c in my let c in let f in my f c violate the intended behavioral separation constraints and are rejected by the type system in the last case although the function f may be given type the application f c is not since the type cc cannot provide for separately typing function and argument no parallel separated add capabilities are available on c on the other hand the following similar looking code is safe and welltyped let c in let f in my f c the form e e is actually derived from primitive fork and wait concurrency constructs thread references are firstclass values in our language created by the expression the interesting operation on threads is to wait for their return value let let c in my var a in a this code is welltyped under the current typing assumptions for c as enforced by the parallel and sequential frame conditions since the of the fork and wait expressions match the of the global behavioral type on the other hand let c in my var a in a is not welltyped under the same assumptions it breaks the separation constraints required by the type of c such type requires and to be sequentially separated but overlapping may occur at runtime causing unsafe interference as before it is not sound to assign to our collection a type allowing the add operation to be used concurrently with scan operations that would violate the intended usage protocol of the internal state causing a race on heap variable hd however our language allows critical regions in the code to be and eventually typed by separation separation allows isolated behaviors to be repeatedly interleaved in the global behavior as far as the associated invariant conditions expressed by a chosen type assertion are preserved in our example this could be achieved eg by adding a new local heap variable inv to the collection and the uses of hd in add and scan as follows add scan var s in hd rec s of · · · to type this code we associate an assertion hd var to the heap variable inv which expresses an invariant condition its footprint our type system is then able to assign to the concurrent collection the following type which allows after initialization operations add and scan to be aliased or shared by several active threads c str scan of course the main to here is not the familiar reasoning technique for lock invariants but the way our type discipline captures it even if based on a few fairly general principles it can be effectively used to reason about safety properties of higherorder concurrent programs involving difficult to handle scenarios of aliasing and concurrency we are not aware of related proposals able to address the same set of realistic programming idioms and based on a a similarly general foundation as we have achieved here this paper makes the following contributions · we and introduce the concept of behavioral separation as a general principle for interference in higherorder imperative concurrent programs · we present a behavioral separation type system for a calculus with imperative and concurrency constructs we show soundness of the system proving type preservation under reduction theorems and and progress theorem · we illustrate by means of many examples how our type system even if based on a small set of very general primitives is already able to fairly challenging program idioms a b c m n t names x y z v variables l s l labels x y expression vars e f x variable xe abstraction ee application let x e in e definition var a in e heap variable decl a e assignment a dereference l e el selection le variant case e of ei conditional recursion x recursion variable fork e new thread wait e wait synchronized block block n thread identifier figure programming language programming language our programming language presented in figure is a calculus with mutable heap allocated variables tuples variants and concur primitives to keep it close to familiar highlevel languages such as java we consider concurrency primitives and a synchronization construct our lan guage is fairly simple yet expressive enough to support challenging imperative higherorder concurrent programming idioms to formally define it we assume given an infinite set of names an infinite set of variables v and an infinite set of method labels l names in are used to identify threads and heap locations for simplicity sake we omit basic values and literals for booleans or integers their addition as primitives is straightforward the functional core includes abstraction xe and application ee following callbyvalue evaluation the tuple expression l e denotes a record collecting expressions ei each one qualified by the label li as in and without any loss of generality we consider lazy tuples where the expression ei is only evaluated after selection of the label li lazy tuples allow different of the same entity to be subject to different ence constraints both along the time and space dimensions and are convenient for encoding objects as tuples of methods the empty tuple is also written nil the let expression represents local definition and sequential composition in let x e in e the subexpression e is evaluated first its result bound to x and then e is executed using the value x we abbreviate let x e in e by e e if x is not free in e the construct le the value of expression e into the variant label l the case construct corresponds to a standard destructor for labeled sum types the expression case e of ei first evaluates e to a variant value if this is not the case execution will get stuck then v is bound to xi ei evaluated and its value returned as the result of the whole case expression variable declaration var a in e variable access a and assignment a e are interpreted as usual the expression fork e a new thread to the evaluation of expression e and immediately returns the new thread identifier a name to the caller thread identifiers are values and do not appear in source programs both the calling thread and the newly created one proceed execution concurrently the expression wait e the caller until the thread resulting from evaluating e terminates with some result if ever such result will then be returned as the result of the wait expression our language includes a simple synchronization primitive the primitive relies on each heap variable with a lock such locks are available for flexible use in programs much as object locks are used eg in java programs either to lock the variable itself or to protect any other relevant region of the state at each moment a lock may be either taken or free the expression evaluates the expression e in exclusion using the lock associated to heap variable n cf the java synchronized block only one thread may acquire the lock of n in linear write mode to track entry and exit of synchronization blocks in the operational semantics we use the auxiliary construct sy ne no occurrences of this construct or of location or thread names are expected to appear in source programs these elements belong to the runtime syntax of the full language as shown in figure the operational semantics of our programming language is defined by a reduction system using evaluation contexts a state consists of a pair h t where h is a heap and t is a set of threads a reduction step has the form h t h t h t reduces to h t expressing a computation step from state h t to state h t in any such step new heap cells may be allocated threads may be created or terminate each thread in t is represented by an element of the form t e where t is the thread name from and e is the runtime expression under execution by the thread we write t e · t for the disjoint union of t and t e a heap h is a mapping from heap locations names to values each heap binding nk v also has an counter k associated to be used as a semaphore important to support the synchronization primitives we write v to denote a heap such that nk v h and v to denote the heap obtained from h after storing v at location n with lock value k we now introduce values v and evaluation contexts e given by v u v xe l e lv t x e let x e in e e l e e ve le case e of ei a value in our language is either an abstraction a tuple including the empty tuple nil a variant value a thread name or a variable without loss of generality we restrict assignments in our source language to the simple form a v where v is a value and use a e as an abbreviation for let x e in a x the rules defining the reduction relation are presented in figure we write vx for the capture avoiding substitution of v for x defined as expected notice that there is no order assumed between elements in a thread set t so any thread t e t may be nondeterministically scheduled in a reduction step most reduction rules are easy to interpret and do not much explanation in rules red var and red fork the side condition n state that name n must be fresh in the respective left hand side rules red sync rely on the lock associated to the each heap location n when the lock is zero the lock is free rule red checks that the lock k associated to v is free before it to and allowing execution to enter the critical region e the expression signals that the execution of e is taking place inside a critical region protected by the lock of n the lock is released after the body of the sy ne block reduces to a value u in rule red red rec h t e · t h t e · t red let h t e let x v in e · t h t e · t red beta h t e · t h t e · t red sel h t e l e li · t h t e ei · t red case h t e case of lx e · t h t e · t red var h t e var a in e · t hn nil t e · t n red assign v t e n u · t u t e nil · t red deref v t e n · t v t e v · t red fork h t e fork e · t h t e n · n e · t n red wait h t e wait n · n v · t h t e v · t red hn v t e · t hn v t e · t red hn u t e · t hn u t e v · t figure reduction type system in this section we technically present our type system as already discussed types describe behavioral of values we start by systematically introducing each type operator discussing on the way their basic algebraic properties and related subsumption laws definition types type operators are given by t u stop t v function t u sequential t u parallel t u intersection lt li ltl sum t shared t isolated t thread recursion x recursion var we assume some primitive type constructors c cu such as str nat to represent basic data types and var etc to represent behavioral separation types for heap allocated variables the stop type types any value no behavioral capability in particular it types nil the sequential type t u asserts of a value that it can be safely used first according to type t and only according to type u the sequential type expresses behavioral separation along the temporal dimension sequential types induce a monoid with identity in the type structure expressed by u v t u v t u u u u the parallel type t u asserts of a value that it can be subject to two safe independent parallel specified by type t and type u respectively by independent parallel usage of a value we mean any form of sharing arising not just in concurrent programs but also in sequential programs due to aliasing the parallel type thus expresses behavioral separation along the spatial dimension it builds on the fundamental idea of separation cf separation logic but focusing on the independence of usage behaviors as from a client viewpoint rather than on the disjointness of underlying resources to this understanding of t u we from using the notation t u a key insight on is that behaviors typed by parallel separation do not interfere in unsafe ways even if they rely and write on shared resources eg as a result of invariant based separation developed in section an usage of type u v only concludes when both u and v conclude in a type such as u v t the usage t is only available when u v conclude so our type language provides an abstract way of splitting permissions without using explicit cf parallel types induce a commutative monoid with identity u v t u v t u v v u u u sequential and parallel composition are related by the exchange law the following causality preserving distribution principle a c b d a b c d a special case is the familiar interleaving law u v v u the linear intersection type u v asserts of a value that it may be safely used according to type u and according to type v the client code using such a value can therefore freely decide to pick either the u or the v behavior but not both since we exploit a linear interpretation of the following basic laws hold u v u u v v u u u notice that and induce a the recursive type with x guarded in a is inter we define u u x the shared type t asserts of a value that it can be safely subject to an unbounded number of parallel separated cf each one specified by type t in particular it may be aliased at type t the following laws hold for the type t u u u u u v u v u u u u notice that satisfies the fundamental laws for the linear logic exponential so our notation the connection the function type t v asserts of a value that it can be safely used once as a function that when given as argument a value of type t on it a usage of type t and returns a result of type v type u v is adjoint to u v so that the behavioral separation interpretation ensures the intended safety property no unsafe interference can arise even if function and argument share resources since they are separated so u v is a type for functions that do not interfere with their arguments as in the sharing interpretation of the arrow in but does not completely interference to ensure safety moreover unlike in the standard linear logic interpretation of the arrow u v a function of type u v can use its parameter more than once as long as it globally respects the behavioral type u as in the isolated type t asserts of a value that it may be used as specified by the type t but more that such usage is fully isolated not subject to any external global constraints a value of type t is completely separated in terms of behavior from the rest of the world in particular t says that the usage t is not from some larger computation we may see a value of type t as a suspended behavior of type t that may be used at any future step in the computation no liveness are imposed on client code to use a value of type t unless it actually starts to use it at type t in particular a value of type t may be safely since nothing depends on it a safe use for a value of type t is not to use it at all moreover since nothing can depend on a value of type t we expect the law u v u v to hold we also have a b a b a a a a a a a a b c a b c the first five laws express familiar algebraic principles cf the basic laws for the last two laws are proper to in particular the last one expresses the key property of global behavioral isolation a behavior of type t is isolated and can be freely used concurrently with anything no other behavior can depend from a behavior of type t by exchange we may derive the law a b b a the qualified type lt asserts of a value that it offers a usage of type t under the label l it describes a label selection capability of a tuple the usage type of the value in field l as in general tuple types may be defined by combining qualified types with other type constructors eg lt the sum type asserts of a value that it is a labeled value that can be used according to type ti if it is labeled with li client code using such a value must branch on the possible labels before actually using the selected behavior the sum type thus corresponds to a standard labeled disjoint union useful to describe variants or we abbreviate null by the thread type t asserts of a value that it references a running thread that upon termination returns a value of type t types for heap allocated variables are described in our system by specific primitives expressing usage write and read capabilities the type of a allocated heap variable is var the type var denotes the generic heap variable usage protocol and is by several subtyping laws presented in section as previously discussed a type a single value in order to type program expressions which may use in general several different values we introduce a notion of type assertion a type assertion corresponds to the usual notion of type environment assigning types to the various free identifiers in a program however our type assertions describe behavioral dependencies between the several identifiers in its domain by placing basic type assignments of the form xt embedded in a larger global type definition type assertion type assertions are given by a b xt a b ab a b a a x for an example under the assumptions expressed by the type assertion f u v the function f can be applied to z but not to y so f z is well typed but f y is not since the behavior is only available after f u v is used we denote by the finite set of variables appearing in a type assertion a if a has a singleton domain x that is refers to a single variable x we implicitly identify it with the assertion where the type ax is given by xt x t a bx ax bx ax ax xx x a bx ax bx a bx ax bx ax ax therefore we identify eg dn with and x with dn x we define type assertion contexts a as the one hole syntactic contexts associated to type assertions we also consider active assertion contexts e where the hole occurs defined e e a e a a e subtyping type assertions are related by a subtyping relation we write a b to state that a is a subtype of b meaning that the usage behavior a a a b b a a b c a b c a a a a a b c a b c a c b d a b c d a b a a b b a a a a a a a a a b a b a a a b c a b c a b a b a a a a a a a a var use var use use use use wr rd v v var var figure subtyping b is subsumed by usage behavior a intuitively a b means that if some value may be safely used according to a then it may also be safely used according to b a b a is a subtype of b notice that subtyping also apply to types by letting u v if and only if xu xv subtyping axioms defined in figure express the basic algebraic laws of the type operators discussed above we abbreviate by a b the fact that a b and b a to save space we abbreviate rules of the form xu xv by u v and omit subtyping congruence rules all type operators satisfy the expected covariant subtyping congruence principles with some exceptions eg the arrow u v which is contravariant in the domain u and which is contravariant on v see particularly interesting are the axioms defining the var behavior we may derive var var clearly a fresh heap variable offers an isolated behavior the first axioms state that a variable can be subject to an unbounded number of uses each use composed by a write and a read phase other axioms specify how the reading phase may be separated depending on the type of the stored value for example the axiom for v says that if a value of type u v can be read from the variable then the variable can also be subject to independent reading at types u and v this point is crucial eg a heap variable may be shared or aliased only if the stored value also may be notice that the axiom for use allowing a different type u to be at different of var naturally support strong updates updating a heap variable to hold values of types at different points in time typing type judgments of our system have the form a z e b e types from a to z in b where a and b are type assertions e is an expression and the index z is a variable we refer to a as the precondition and to b as the postcondition of the typing judgment the behavioral type of the value of e as determined by the type system appears embedded in assertion b the variable z stands for such a value and can only occur free in b not in a or e this idea of scoping the return value z over the postcondition appears in the hoare triple types of although here the type of z cannot be given apart from b for an example consider z xa x this judgment asserts that evaluating the expression xa x in a state providing returns a functional value identified by z in the postcondition that must be used exactly once before the heap variable a can be read we now present the several rules of our type system discussing each one on the way structural rules the identity axiom xu z x id asserts that access to the identifier x simply returns the associated value usable according to the type in the precondition nb id has the that u is free from heap variable types typing rules for heap variable dereference are given below the type system includes four other structural rules a crucial one is subtyping sub which into typing the basic subsumption principles it allows assertions in type rules to be considered up to and plays a role similar to the consequence rule in hoare logics a a a x e b a x e b b b sub the rule for let corresponds to cut x not free in the conclusion a a x y e b let x b e y e c in e c let the following parallel and sequential structural rules express basic frame principles rule par allows the footprint of an expression to be along the spatial dimension while rule seq allows the footprint to be along the temporal dimension a ac x x e b e b c par a ac x x e b e b c seq given these two rules the following deep frame rule is admissible for any active type assertion context e a e a x x e e b e b frame functional type we have the following typing rules for the calculus core y e yt a z xe t a z e t b x e a b y ee yt xu app these rules are similar to the arrow rules in linear or type systems even if our semantics for is different given the interpretation of a b app ensures that functions do not interfere with their arguments upon application notice that the type of the argument x is left in the postcondition of the premise of forcing the function body to fully exercise the behavior u of its parameter consistently with the semantics of our functional type the type of an function may be u v and the type of a function that can safely share the behavior of its argument with its own behavior may specified u v behavioral separation types allow many finegrained variations of functional behavior to be specified eg u v a function u v a non but repeatedly usable function etc notice that in our typed language as eg in the monadic calculus one cannot encode let by application and abstraction tuple type the rules for tuples and field selection have the expected form a z a x e xu l e tuple a a z x e el xt sel recall that field contents of tuples are evaluated as in so tuple allows a single field to be type checked intersection type we include as primitive the introduction rule and a y e b a a y e b y e c and c a y a e y b e bi b technically we choose to the elimination principles for intersection in the subtyping relation eg a b a however familiar elimination rules are admissible using sub types structured are assigned to basic values abstractions tuples by the following type rules y v a y v ab c y b v y v c d d a an a an x vb x vb a a y vc b y b v y c vd d rule expresses that a value can be subject to any number of shared if it only relies on resources which may also be safely used by any number of shared interestingly these rules allow values to satisfy frame principles than the structural rules in section which apply to general expressions for example the following identity axiom and frame rule turn out to be admissible for values even if the corresponding principles are not sound for arbitrary expressions a y v a b ab y y v c v a c isolated type the rule assigns to the postcondition of an expression an isolated type if it only depends on values of isolated type a an a an x e b x e b the type rules for a and a are therefore similar and express the basic principle associated to these type constructors cf the introduction rule for in intuitionistic linear logic even if their meaning is quite different sharing versus isolation a property of any type t of the form u is that t t t and t t so that t is both shared and isolated sum type sum types are also handled by familiar looking typing rules a y ec y ii b z ei c case a b z case ec of lx e c a z a z e z ii li ti option as for function application the type rule for case ensures that the matched value is separated from the corresponding case branch so to avoid unsafe interference heap variable types we have already explained how heap allocated variables are modeled in our system as special values subject to a specific usage protocol defined by certain subtyping axioms the type rule for a variable declaration types the body under the assumption of a separated complete protocol for the new variable specified by var a a x var a x e c in e c var rules for dereference and assignment are more interesting we consider two typing rules for dereference and two typing rules for assignment the alternative typings express boundary cases on usage of the variable protocol which are not naturally captured by a single typing rule we distinguish between reading just a piece of the behavior stored in the variable from reading the whole remaining stored behavior x a xu use x a xu rule states that even if the precondition states that the next use of variable a is guarded by a read usage the variable content xu is separated of the residual variable behavior specifying an empty variable rule expresses an important invariant by the type system the behavior stored in any heap variable is always separated from the continuation be of the variable object itself after all of its content gets read off so the postcondition in the conclusion of always holds even if the type of the heap variable content is not explicitly declared as isolated not of the form u we also have two rules for assignment depending on the behavior stored in the heap variable is isolated or a a z a v a a z v z a v in both rules the stored value is required to be parallel separated from the heap variable which must be in a state rule handles the case in which the value behavior to be stored is isolated here we only require the write capability as the stored value may be used later rule handles the case in which the value behavior to be stored may be not isolated in this case one must ensure that all associated reads will happen before any sequential continuation of so a whole use is required in the premise leaving the associated read usage active in the postcondition it is interesting to see why a rule as but considering a type for the stored value would not be sound let us consider a simple counterexample ru x r xu ru x a r ru v x a r rv ru v x a r rv ru v x a r rv this candidate derivation states that after executing a r the behavior rv is available before reading the variable a thus the requirement that r must be used as u v a correct typing is ru x r xu ru x a r ru v x a r rv typing rules for assignment require separation between heap variable and stored value this may suggest that typing of circular chains of references through the heap may be difficult if not impossible although it is clear that linear behaviors cannot refer to themselves that is not the case for general behavioral separation types some safe circular chains may still support separated behaviors due to the presence of qualified tuples or just because of sharing including invariant based separation we illustrate the point in section by typing a version of in the discussion above we omitted recursion and recursive types to accommodate recursion typing judgements are equipped with a recursion variable environment which maps expression variables z to type judgments and type variables x to type assertions we have the recursion environment in rules where it does not play any relevant role this technique is inspired in familiar approaches to coinductive types see for details we collect the rules of the basic system in figure for sake we present the type system in two steps first without synchronization constructs extended in section to the full language typing the collection implementation we get back to the running example in the introduction we that a collection value may be assigned the type cc and the function the type cc we now discuss how such type is actually assigned by our type system we first type the list nodes consider the following abbreviations nat node the type defines the behavior of a pointer to a list of initialized nodes as created by the function we use option types to type list pointers either the null pointer tagged null or a value of type tagged by node directed by rules and tuple the system assigns type node to the tuple · · · by checking that it can be subject to the given behavioral separation usage while safely using its local resources the variables next and elt the variable elt gets assigned type it is written just once in the operation and available for shared reading from then on notice that var since nat is assumed shared nat nat variable next is typed var after initialization execution of the behavior the node type to only operations and are available usable by an unbounded number of aliases or concurrent clients the shared behavior of the list nodes supports sharing of the linked list and allows the type scan to be assigned within cc recall cc str scan checking against type cc involves verifying that the object tuple init · · · representing a collection can be safely subject to the behavioral separation usage specified by cc after init the variable hd is assigned type var this type is kept invariant between iterated executions of the add and scan operations it is particularly interesting to see how the scan operation is typed the footprint precondition is hd note that after the assignment s hd the type assertion is var we detail the derivation of the scan loop showing the key judgments x nil x s use use x l x s l use x case s of use x rec var x rec derivation of uses is derived from and by case is derived from by seq and sub let l use x be the recursion environment introduced by rec deriving from and used by in fully detailed typing derivations for the collection and other examples in this paper are given in type preservation and progress we now state the main correctness results for the basic type system namely the subject reduction property and progress for welltyped programs type preservation and progress ensure that in a well typed program all values are properly used according to their assigned types in particular given the structure of types assigned to variables no or readwrite races while writing to heap variables are possible it is not the case that use t or use t we thus introduce rules typing for runtime configurations h s h s a h s e h s e c h e c x e xt e t t t a b s b h s a h n v s a x v b h in rule t e is an active type assertion context the notation with n fresh in b represents the update of assertion b where the behavior pieces assigned to x are substituted in place by reads to a new heap variable n essentially all occurrences of the form xu in type b are replaced by and a is inserted in sequential and linear position relative to all s we can now state our first type preservation result theorem if h s a and h s h s then h s a an expression e is live noted if it is not a value a set s of threads is live noted if there is some thread t e in s such that we can then prove theorem if h s a and then h s h s detailed proofs and definitions are given in separation we now extend the basic type system to cover the full core language with blocks and reasoning as explained in section each heap variable is equipped with an associated lock much like a java object is to each lock a resource invariant expressed by an isolated typing assertion is associated for verification purposes we only accept for lock invariant a heap assertion r such that r r let us call heap assertion any type assertion that just refers to heap variable types var use etc handling lock invariants requires some additional structure in our type system we add to typing judgments an invariant mapping that associates to heap location locks their invariants a z e b e types from a to z in b under the invariant mapping is propagated by all typing rules except in the new rule for variable declaration which may introduce a lock invariant and in the rules for and which make use the lock invariant associated to heap location n a a a x a x e a b b sync a a a x e a b x sy ae b sy a b r a x var a b ra x in e c e c var without loss of generality we assume that the invariant associated to some heap variables lock does not talk about the variable itself but only about other heap variables in scope interestingly notice that the rule for sync directly expresses an principle consider the code describing an atomic variable let atomic v var s in s v var lock in set x get in y v xu y x id a an a an x e b x e b a an a an x v b x v b a a a x e b a x e b b b sub a y e b a a y e b y e c and c a a x e b y let x b e y e c in e c let a a c x x e e b b c seq a ac x x e b e b c par a x e xu t b y e a b z ee zt app a x a x e xu l e tuple a a x e x el xt sel a xu z e zt a z xe t z a a x z x b b a y ec y ii b z ei c case a b z case ec of lx e c a z a z e z ii option a za x xb e b a x b rec a y v a b c y b v y v d c d a y v ab c y b y v v c d d x a a x v x a a xa x v b x v b a x e c a x var a in e c var a a z v z a v use x a xu a a z a v x a xu a a x e xt x fork e x t fork a a x e x t x wait e xt wait figure typing rules let u be a shared isolated type a type such that u u see section we can then derive the typing set u get u by associating to lock the invariant var this type states that atomic is a function that returns a variable object that can be safely used concurrently by an arbitrary number of and notice that if any of the two sync blocks is removed atomic would only be typed by a type that the get and set operations for example if both sync blocks are removed a possible typing is get u set u which would still allow sharing aliasing or concurrent usage of the get method but not of the set method this example illustrates how the concurrency control monitor construction can be explained as a type coercion operator in our type structure eg a b b a to a b recall that by the exchange law we can derive a b a b b a expressing the basic interleaving principle that a value of type a b can be used according to a b b a conversely given a value providing the behavior a b b a we may in general coerce it to the behavior a b by it inside a monitor enforcing the appropriate usage protocol by means of locking the object then exports two parallel separated interfaces a and b even if there is potentially sharing interference between the implementations of a and b our type system naturally assigns a b to the object relying on the modular type rules for locking and on standard reasoning invariant based reasoning is also useful in a setting in which case we may consider the sync operator essentially as a typing device for potentially shared aliased we elaborate on this point using a simple yet nontrivial example a fifo queue implemented with a linked list data structure with head and tail pointers code listed in figure we describe the type node assigned to node value in the list node let new var next in next null var lock in x next in next null x link x in var head tail in head null tail null enq let n new nil in case tail of null head tail tail case head of null head null head case head of null tail null head null head figure a fifo queue implemented with a linked list our type system assigns to function new the type node node is a parallel separation type on the one hand the behavior to be assigned to the head pointer or to the previous node in the list and on the other hand the behavior to be assigned to the tail pointer the safe separation of behaviors is enforced by the use of invariant based separation associating to lock the invariant next var so for example aliasing of n in head tail type checks since given we may separate and assign type to the first occurrence of and to the second we then derive q where this type says that the declared behavioral separation protocols are enforced even in the presence of possible interference between the state accessible from head and tail additionally type node clearly says that both link and operation are used at most once in each list node the first through the tail alias the other by the head alias and that this describes the full behavior of a node type above declares a sequential behavior for the queue where enq and operations cannot be selected concurrently a concurrent queue can be defined by the sequential implementation described with appropriate sync blocks var head tail in head null tail null var in enq for type checking this code we associate to the invariant head var tail var we then de q for enq the interface type explicitly says that the queue can be safely used by many concurrent clients as in eg let q in notice that in the assertion typing only sequential types appear that is no or so only a single thread may be the code of this means informal claim that the lock lock associated to each list node will always be free so the sync blocks in node are operationally irrelevant and may be seen as an auxiliary device for code regions subject to type checking of separation on the other hand sync blocks are of course essential to if it is to be actually used according to the more permissive type as a further example we present a code fragment a thus creating a circular chain of references in the higherorder store we may verify that it can be typed by assigning to the operationally useless lock the invariant var and to the function f the type var a in a xx var in let f a y in f f nil in principle our type system could be refined to distinguish between two different scenarios for invariant based reasoning one already useful to handle interference in sequential code another one to handle interference in concurrent code only the latter would require real locks to be introduced in the code we leave this discussion for future consideration for the issue seems orthogonal to the main purpose of this paper the key point to here is that our typing principles for the sync construct seem to capture a useful and general form of invariant reasoning about safe interference in the context of a behavioral separation type system we can now state the type preservation result for the full core language to that end typing for runtime configurations is generalized to consider the declaration of invariants this is achieved by a global invariant mapping which assigns lock invariants to locations essentially the rule h of section is replaced by the following rules covering the two possible lock states see h s ar a x v b h n v s rn hu h s a a x v b h n v s rn hl theorem if h s a and h s h s then h s a a progress property also holds for the full core language with concurrency and synchronization primitives but in a slightly weaker sense due to the possibility of deadlock on sync blocks see related work the concept of separation results from a research stream whose can be traced back to the works of reynolds on syntactic control of interference separation logics extend classical hoare logic with new connectives in particular the separation conjunction which allows to specify the finegrained structure of states in programs manipulating references and enables local reasoning to successfully programs with references and concurrency more recently separation logic has motivated the introduction of hoare type theory and has been extended to languages with higherorder store these works focus on the identification of higherorder frame principles for statebased local reasoning the idea of assigning a parallel separation type to some value even when there is safe interference between the implementations of the separated behaviors is of concepts explored in separation concurrent abstract predicates and types again these works are carried out within statebased separation logics we have shown how a type based approach to behavioral separation in principle less precise for specification purposes than a full logic can already be used to enforce interference safety on programming languages idioms and features not yet in the scope of such approaches such as higherorder store and first class concurrency work on spatial logics for concurrent systems remote for our approach but explored different notions of separation useful to reasoning about distribution and mobility rather than about interference although the fundamental notion of separation applies to many kinds of computational structures the idea of combining separation with behavioral types to discipline interference in a realistic programming language as we do here does not seem to have been considered before various forms of behavioral types have been independently introduced by several authors with the of usage patterns of computational objects some of these works have motivated more refined verification techniques for example to check resource usage disciplines in functional programs a particular case of behavioral types are the socalled session types intended to discipline message between in distributed systems although initially proposed for systems with interaction between exactly two session types have been extended to systems with an arbitrary number of participants our notion of type assertion is related with the notion of global type introduced in in the sense that it needs to talk about the joint behavior of several entities a version of session types to discipline interactions between concurrent objects was developed in but does not attempt to deal with interference or aliasing more recently the first author and pfenning developed an interpretation of session types in linear logic which also inspired some aspects of the theory presented here connections between session types and separation logic have also been investigated in but focusing on the of resources in process communications in prior work we a very preliminary approach to the concept of behavioral separation however the developments in this paper the notion of behavioral separation type in the context of a clean type theory based on a calculus with imperative and concurrency constructs and are much more general and expressive several works have proposed typebased approaches to discipline aliasing and concurrency control in various programming languages usually exploiting type and effect systems ownership types have also been studied to discipline aliasing and concurrency some of these works have led to the development of powerful programming tools typically these works do not focus on capturing the dynamic behavior of resources at a deeper level as we do here but on tracking occurrences of identifiers locks permissions regions and data dependencies essentially to linearity an important exception is typestate which uses a statebased approach to specify resource usage protocols in object oriented languages a key of the typestate approach is the use of primitive permissions to capture usage idioms rather than resource behavior in parallel research we are combinations of separation with typestate techniques to support expressive idioms in the context of typestate have been recently proposed in remarks we have introduced behavioral separation as a general principle for interference due either to aliasing or concurrency by combining concepts from separation logic and behavioral type systems we have designed a behavioral separation type system that illustrates the concept using a higherorder imperative functional language extended with concurrency and synchronization primitives our type system is proven sound using proof theoretic techniques we have also shown that the expressiveness of our approach goes beyond the state of the art for typebased verification of aliasing and concurrency and provided several challenging examples involving finegrained state manipulation thread based concurrency and synchronization constructs further examples including the implementation of a concurrent queue based on a double linked list can be found in in work we have already designed an algorithm that can effectively type check programs in our core language with a reasonable annotation burden ­ these results will be reported elsewhere we are also to separation along the lines suggested in section and the extension of our basic framework with dependent types which would support more precise specifications acknowledgments thanks to peter ohearn for remarks on safe interference to a and to the anonymous reviewers for useful comments work by ui references m abadi c flanagan and s n types for safe locking static race detection for java acm toplas ­ a ahmed m and g morrisett l a linear language with locations ­ k and j modular typestate checking of aliased objects in oopsla pages ­ s l and z free algebras in language theoretical computer science ­ r c calcagno p w ohearn and m parkinson permission in separation logic in popl pages ­ c r lee and m c rinard ownership types for safe programming preventing data races and deadlocks in oopsla pages ­ acm c b liskov and l ownership types for object encapsulation in popl c and m c rinard a parameterized type system for java programs in oopsla pages ­ j checking interference with fractional permissions in sas volume of lncs pages ­ springerverlag l types for concurrency and resource control in distributed systems theoretical computer science ­ l and l cardelli a spatial logic for concurrency part i information and computation ­ l and f pfenning session types as intuitionistic linear propositions in concur volume of lncs pages ­ springerverlag l and j c the type discipline of behavioral separation technical report c calcagno p w ohearn and h yang local action and abstract separation logic in lics pages ­ l cardelli and a d gordon anywhere modal logics for mobile ambients in popl pages ­ acm s s rajamani and j types as models model checking programs in popl pages ­ t m p m j parkinson and v vafeiadis concurrent abstract predicates in ecoop volume of lncs pages ­ springerverlag s j v a n and a z modular session types for distributed objectoriented programming in popl pages ­ c a r hoare b g and i concurrent kleene algebra in concur volume of lncs pages ­ springerverlag t hoare and p w ohearn separation logic semantics for communicating processes en computer science ­ k honda v t and m language primitives and type discipline for structured programming in esop volume of lncs pages ­ springer k honda n yoshida and m multiparty asynchronous session types in popl pages ­ acm a and n kobayashi resource usage analysis in popl pages ­ a and n kobayashi a generic type system for the picalculus theoretical computer science ­ j b and l birkedal separation logic in esop lncs pages ­ springerverlag b jones splitting atoms safely theoretical computer science ­ r jr s n s v a and t safe nondeterminism in a parallel language in popl pages ­ n r a d dreyer and d types in icfp pages ­ acm f and j and l aliasing control with typestate in pages ­ acm k r j and k a type system for permissions in popl pages ­ a j g morrisett and l birkedal hoare type theory polymorphism and separation j fun p ­ p w ohearn on typing j fun p ­ p w ohearn resources concurrency and local reasoning theor comput sci ­ b pierce types and programming languages mit press pottier hiding local state in direct style a higherorder rule in lics pages ­ j c reynolds syntactic control of interference in popl pages ­ j c reynolds syntactic control of interference part in icalp volume of lncs pages ­ springer j c reynolds design of the programming language pages ­ boston inc cambridge ma usa j c reynolds separation logic a logic for shared mutable data structures in lics j l birkedal b and h yang nested hoare triples and frame rules for higherorder store logical methods in computer science j e and c calcagno proving message passing in volume of lncs pages ­ springerverlag 