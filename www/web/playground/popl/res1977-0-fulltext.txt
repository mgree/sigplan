a consistent for a simple language by j s y introduction the problem of formal correctness proofs for programs has received a great deal of ma recently models have been developed for verification systems that allow the formulation of questions concerning the consistency and complete ness of such systems in this paper we present the of a simple programming language lm meyer and mr ll with along with model based on arithmetic p we show the verification to be consistent and complete with respect system to the model and develop a relative com result the complexity result states that in a proof of the size of any line of the proof is no larger than a polynomial in ql assuming that we dont count proofs ly ing solely in p lm is the first nontrivial programming lan guage in which a complete and consistent tive semantics has been given furthermore our complexity result is an result for those to parts of the verification process given a programmer assume can decide the validity of p formulas the verification of any program in lm is computationally feasible this is because the space necessary to write down assertions that must be checked for validity is bounded by a polynomial although l is not a general m purpose language it is fairly powerful in that it computes all the representable functions also as cooper points out co a significant fraction of arising in proofs about programs lies in p we fix an assertion language a programming language and a model for the assertion language calling them respectively a be a program in pa la pa and let a p and q assertions in then we call a formulas of the form correctness formulas a axiom system for p then a of and inference consists rules of axioms in the form whose assumptions con of and assertions and whose conclusions are for any program a and assertions p and q i a is correct wrt p q and la if is the last line in a sequence af lines consisting of axiom proofs of assertions in a instances of conclusions of inference rules where the assumptions occur on earlier lines an model for the above system con of a model for the assertion logic and a a model for computations in p this second a model is normally defined by specifying the actions of program components on program states eg changes the state s by the component in s corresponding to x we then say l such that that for all states s p is true on s and a and halts on s q is true of the state an axiom system is consistent if for all l a an axiom system is com if im a al axiom systems should be consistent however completeness is generally impossible due to three factors the logic la may be incomplete the logic la may be too weak the hoare system of the completeness of la may be incomplete k example arithmetic of is where is first a and we examine true order this is provably correct exactly when p is provable in it is true exactly a incompleteness theorem when p is valid then tells us that the axiomatic are incomplete an example of is when p is a programming say language with g cb a simple primitive statements and p then given a s gram a which halts with output zo exactly when its input x is a square to prove true a zo requires an assertion in p which is true exact ly when x is a square this is impossible in pe when a situation said to be as arises an example of a s is present in cl where call by parameters in procedures lead to incompleteness even assuming la is complete with respect we will be concerned to a with like questions in analyzing programming since p relative language lm and logic to a suitable p m is complete does not apply likewise we will demonstrate that and do not apply our main result is that lp the language can be defined by the following prog loop x prog end prog prog prog xy i xx i xx i xo where x and y are variables and and have their usual interpretations x xl if xo o otherwise the natural numbers programs in l operate m over and loop x a end is to be interpreted as executions of a a is a prog the logic p is the set of true first order statements about the natural numbers in which the allowed operations are xy xl x xy x div x rem k and the allowed predicates are x xy xy xy xy xy and xy mod k where constant a nary relation r is p table by xn provided that a an al an natural numbers is true for axioms and model let be the uniform substitution of expres sion e for free variable v in p the axioms and inference rules for al pl l then m p consist of a px x x p a xo p a px y p ri p a q q b r p a b r r zo pz a pz loop y a end pz where z and y are free in p r p p p a q q q p a q the model for lm is based upon p and its standard model in the integers with all operations in p taking their let s be an assignment standard inter of free program variables to values in in s is the program state we define comp to be a function which takes a program state and a program and maps them to the sequence of execution states resulting from the programs execution auxiliary functions and out are necessary in the definition of comp out of a program state and a program just yields the last state in the sequence defined by comp the value of predicate p under variable assignment s is denoted as ps we now define comp as follows xo s where sx s x sx s y o except y a end s where i sy if then a else where s we then write a q iff for all states s and s if p is true under the assignment of variables provided by s and then q is true under the assignment consistency and completeness provided by s frequently the case with consistency and completeness results the consistency results are the it suffices to show that the axioms and inference rules are true in the model we consider the lemma the loop rule is true case in the model proof assume n zo pz a and assume s is i sy if such that then is true y let loop y a end sh s but in this case since sy o if i then y a end s at s where ll s s from the truth of the cf assumption to the loop rule pz z thus by induction on i p si is true hence psl is true qed the remaining cases are straightforward along the lines of ck completeness as is frequently the case in mathematical logic is considerably more difficult to show we say a logic is expressive with respect to a programming language if for every assertion p in the logic program a and state s an assertion q such that q is true exactly for s when p is true of s and a executing on s yields s ie q is a strongest post con for p and a this can also be stated as q is a for p and a provided that and for all assertions r if in p a r then q r is valid in our com proof we need to show how to explicitly construct the for a in lm and p in p all cases are straightforward except for loop in the case of loop we need some lemmas let a be a statements l program m consisting of and x with lj n program variables operations correspond to the monadic the primitive functions and where x for all x a single execution of a results in a final value for each x in terms of a sequence of the above functions applied to some variable to indices be such that x let r map indices the value of x after i one execution of a is fx ri that is ri chooses the that x depends upon after one execution of a and fi is the function sequence operating on that variable we have the following lemmas lemma for each i there exist pq upon i such that pq s nl and r qi where composition of r is the proof by the hole principal lemma the value of variable xi after m executions of a is x f i i f k f rp i x r psi where p and q are as in lemma and m p sq proof we prove by induction mo xi xi mn assume for on m that xi f f ri f of i k f f i the value of any variable xi after one execution of a transforms k the index of x is rl to fx i ri since x mi transforms to k r substituting into case mn we have x fi of f i i r k if by lemma we have of of i r kl and m kl qp otherwise the formula as it stands is correct qed lemma equations of the form xi al o i n c x n where i l in are and aj is a sequence of functions are p representable from proof the proof proceeds by induction on n case o with no the equation reduces to which is in p case n assume that i al ob xi is p representable by a formula case nl to show that i o o al n x i p representable we use case n and substitute is for all occurrences of x can appear in three sorts of atomic formulas i z t x tj ii j ii z ij iii ti x t i jj m is the number of occurrences of in the atomic formula are terms free and is a constant k of a x we will and t t j only prove case i the other cases are similar a can have four effects upon x a a can increase x if s s and s o b a can decrease x if s s and c a can leave x unchanged if s s and s o d a can set x a constant if s o in cases a c consideration must be taken of small values of x ind of k eg if a and x q then x is by if x then x is by if k o then there is no effect upon x let p be the largest that any suffix of a applied to x yields in above example p let r be the of s over s in a and the of s over s in b we can now analyze cases ad case a k executions of a will transform x to x rk if x p the first execution of a will yield a constant cp then after k executions x is transformed to c x the formula then becomes x i j xp ko il mx x t zt ii i z ti i z tj j case b then any execution of a results in a constant c less than p div r then x is by if xp and k xp div r then x is set to c the formula is then xp ko k xp div r x ko k xp div r mc zt i jj xp ko i jj ko mx zt i jj case c if x p then a sets x to a con cp if x p then a does nothing to x the formula is xp ko mx zt i jj xp ko mc i zt jj ko mx et zt ij jj case d a sets x to a constant c the total formula is then ko mc i zt jj ko mx i zt j this completes the analysis and the induction qed lemma formulas arising from lemma are p representable using space linear in the size of the formula proof formulas arising from lemma are of the om is p representable where i and i as a using lemma these equations are p representable and an of that lemma shows that at most clauses each linearly related to the original formula are introduced qed theorem for any program a in l m and assertion p in p there is a function which yields the strongest post condition for p and a furthermore is bounded in the size of p and a proof it suffices to show the theorem for each statement type and prove by structural induction let z be a set of n new variables and assume we have n program variables xx i x ix p xi o z j y a z a j nl aj where w xj j ip of rp v v m q xf jj mod q div q j f i p k f rp j z j r j i is a new variable is the y t component corresponding to y and m and k are a and a p defined respectively is o nl in case and in case from case composition we see that for arbitrary program a is from lemma we can translate the iterated function sequences in linear space thus the formula is bounded by a polynomial in al pi it remains to show that the above formulas are really the strongest post cond tions we cons d er in detail case cases and can be shown using similar techniques let a be any of the assignments in case let s be such that ps is true and s the state resulting from execution of a let be the of values to free in p then pz is true as can be seen by letting za still letting zl it can be seen that s makes all the equalities true for ss except at the variable but then the equality reflects the change in the variables value to see that is a strongest post condition we will assume that it is not and derive a contradiction let r be the then and r let s be such that s is true then pz is true for some hence after execution of a on yielding from in one component we still have true for equalities are satisfied z and additionally the for z and but rz is false by assumption therefore we have a contradiction for pd is true before execution of of a e is the result of as execution and re is false the proof for case is along the same lines the value of the loop variable i which values the variables upon com of execution of the loop thus the proof that for y b end is a strongest post condition for p and a proceeds as above case follows from the transitivity of cation and the definition of is the strongest statement that can be after a execution on a state that has p true qed as an example of the theorem we construct where loop x xl end a is the following program from the body of the loop we see that rl r fl f we can now construct our output equations and al u for x l then x ki div v s mod k x v for we have mod a x then po and ri div is ql then i ml z z v iz x v x x the theorem allows us to prove our com result we only show the case that of loop the rest are straightforward using techniques such as in ck lemma in y a proof construct lp y a end q y a end p with one change it as instead of defining where w is i by iz y define a new free variable call this formula it is easy to show w a and hence lp sis a u p and by induction y a end p from the properties of the strongest post con y a end p q hence by the consequence rule and the loop rule lp qed p in l m the of the completeness result construction of a p formula expressing is the the result of executing an lm program since p is a complete theory relative to a suitable m we conclude that the axiom system for lm is complete the question arises can we get the same result for a more powerful language than lm that is is p really capable of expressing more than lm we will now prove that the answer to these questions is no that is p is the weakest theory which expresses definition a programming language exactly a a logic iff a for every program ax in pa with a output variable there is a formula r in la such that ae o ra is true and for every rz in la there is a program ra ar in p such a is true that a o note that this definition differs slightly from that given in ch theorem proof l exactly m p the two parts of the proof correspond to the parts of the above this is a simple corollary of the theorem this part is a modification of a proof in ch assume we are given formula rr in p we show that we can construct program ax in four steps a by a wellknown technique see e transform r to a quantifierfree formula r having the same free variables r has the form v q j i ik i where are constants and v are terms in p over variables xi b construct programs to compute the terms of r that is the etc the reader may do this simple construction or ch c construct programs to realize the conjuncts of r it should be clear that the functions x y xy and the constant functions are computable in lm we show how to realize the three types of conjuncts ri i rq jj xr sl ii sq after executing this fragment r s r s qo i jj zj iff xy iff ti similarly m i x rq jj mod m y mod m i z xy yx now zo iff xy iff part here is performing m the the mod mi ation a program to compute x mod m is the following m m loop x temp m o o m m in m m temp m end o d l is closed m under and v that is if programs a and b realize relations and a with output variables and z b respectively a then there are l m programs relations rb and ra v rb it is then essential to realize that in and n are constants so there are only a fixed number of to be connected by s and vs we now prove the closure property ra a b a zo a ra a b a a a aj b b zz a b g z a rb zo r a qed what this proof shows is that lm uses the full power of p so that a more powerful language p such as l will lead outside of relative complexity define the relative complexity of a tion proof to be the length ie number of symbols of the longest cf appearing in the proof the relative complexity of is then the minimum of the relative of all proofs of if is provable otherwise it is undefined the following theorem then shows that the relative complexity of the lm p verification system is polynomial relative complexity theorem the relative complexity of in the lm p system is polynomial in proof the are all bounded by a polynomial in hence the longest is bounded by a polynomial in qed conclusion we have investigated in rather de tail the completeness and consistency of a simple verification system there are other programming languages that are certainly amenable to a similar study of particular interest would be those programming languages whose assertion language lies in the first order theory of real closed fields or algebraic fields difficulties arise however in the study of such systems as to the appropriate we believe that such as above although not of immediate practical use at least the that can be encountered with even simple languages they also give some hope in particular the relative complexity result that automatic in an interactive might become more than expensive research tools references ch jc simple exactly formulas of computing to appear programs siam realize journal cl clarke em language con for which it is impossible to obtain good axioms cornell university tr august cb programming and program pp rl ab languages structure part i efficiency jacm ck cook sa axiomatic and semantics for an algol fragment tr no dept of computer science university of february co cooper dc in arithmetic without multiplication machine intelligence and cd john pp e hb a mathematical introduction to logic academic press new york ma manna z mathematical inc theory of york m e introduction to mathematical logic d van inc princeton nj mr meyer ar dm of loop programs co pp ad proc the complexity conf acm dc 