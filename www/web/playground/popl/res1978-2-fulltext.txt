record of the fifth annual acm symposium on principles of programming languages clauses scope structures and defined functions ea computer science department university of and ww computer science department university of in abstract in this paper we describe how can be extended to allow functions and scope conventions ie conventions for limiting the range or scope of the validity of definitions this is done using new constructs called clauses which are similar in form to the blocks and procedure declarations of algollike languages but are nevertheless strictly because a clause is actually a compound assertion ie an assertion formed as a program is by combining a collection of assertions each type of clause there are four has a straightforward mathematical semantics together with its own characteristic manipulation rules for general program in addition the informal operational view of some programs described in a previous paper can be extended to give an incomplete operational understanding of the effect of the clauses in this framework a compute clause defines a block a mapping clause defines a conventional pointwise function a produce clause defines a block with persistent memory or an anonymous process or actor function clause defines a sort of procedure with own variables or a general kind of coroutine introduction is a or language a program is an assertion or set of assertions defining its output rather than a set of commands which some machine must in order to produce the output is by no means the first such language the distinction between imperative and languages and the advantages of the latter have been well understood for at least a years see up until now however languages have been almost universally regarded as elegant the of for real programming the project is an attempt to demonstrate that this view is that programming can be practical and that in some respects it need not be so different from conventional well structured programming to languages are all based on the obvious fact that programs cannot be executed and that they give rise to no activity other than function calling in other words that they have no operational meaning thus iteration for example is impossible because it is an operational concept assignment is necessary to update loop variables and transfer is needed to go back and start another iteration and to exit on completion furthermore languages must so goes the reasoning be inherently inefficient because their implementations cannot take advantage of various operational such as the moving of constant expressions outside loops or sharing of variables and finally it is argued languages must always be because they lack the rich variety of constructs found in imperative languages the for loops case statements exits own variables and so on all of course to bring about a desired operational effect the programmer on the other hand is restricted to recursive function definitions so that his languages can never be anything more than syntactically variants of the acalculus the first version of the language as described in referred to as basic some of these by showing that a form of iteration can be expressed very naturally in a framework but even more we showed that it is indeed possible for programs to have operational interpretations the operational semantics for basic actually for a subset can be used informally as a guide to the programmer but it can also be made precise and used as the basic of an implementation for example a compiler of course a programming language needs much more than a facility for iteration if it is to be practical and in particular it needs facilities which allow programmers to restrict the scope of variables and to define their own functions in this paper we present an extension of basic which has these features we define the new constructs their mathematical semantics and the class of programs and give the derived rules for verification and transformation of programs clauses has constructs for structuring programs analogous to the blocks and procedure declarations of algollike imperative languages these constructs are called clauses clauses are used in programs to define data function or mapping variables but in the more general framework of the formal theory a clause is a compound assertion ie an assertion built up by combining a collection of assertions produce clauses the simplest type of clause is the produce clause a produce clause is used to limit the scope of certain variables so that the same variable can be used in different places with different meanings a produce clause has the form produce end data term using variable set of assertions list the data te at subject of the clause global list and the body of the clause the head of the clause the variable list set of assertions is the is the is the the variables occurring in the global list are the global variables of the clause the special variable output which must not appear on the global list and any other variable not on the global list but occurring free in an assertion in the body of the clause is called a local variable here is a simple example z output end here a b and c are the global variables and output and d are the local variables if this clause is in a program the definition of d in the clause is not valid outside it although the definitions of a b and c are available inside the clause this is because semantically a produce clause is an assertion about the subject and the of the clause inside the clause the special local data variable output refers to the subject the clause considered as an assertion is true iff there exist values for the local variables which make all the assertions in the body true when output has the value of the subject term thus the meaning of a produce clause independent of the choice of local variables example we could have used e instead of is the clause above is for d a produce clause is used in a program as a defining its subject when used this way the body of the clause must as in the example be a subprogram ie a set of equations and clauses defining output and other local variables in terms of each other and the for more details see the next section in particular local variables can in turn be defined by other produces ie produce clauses can be nested the definition of the meaning of a pro clause given above works makes sense even when the body is not a subprogram this is very important because it allows us to continue the practice of freely program text with assertions in the course of verifying a program function clauses function clauses about function variables to define functions are compound assertions and are used in programs a function clause is of the form function end function set of term assertions data using variable variable list list the function term is called the subject of the clause and the data variables in the parentheses are called the formal parameters as before the global variables are those in the global list but now the are those occurring free in the body which are neither nor formal parameters formal parameters must all be distinct and may not occur in the global list from here a program is a typical function clause taken function d output end root abc b ac b in this case the global list is empty and the word is a function clause is an assertion about the subject and the it asserts that for all values of the formal parameters there exist values of the local variables which make every assertion in the body of the clause true when output has the value of the subject applied to the formal parameters values when used in a program is a definition of its subject be a function variable and the must be a subprogram consisting the a function clause which must simply body of the clause of definitions of both these constructs are quite general and do not involve any of the functions in they could be added to any language give facilities for restricting the scope of variables and for defining functions to has in addition two special versions of produce and function clauses which allow the definition of they achieve this by implicitly applying to the global variables and formal parameters and to the result see these of the produce and function clauses are the com and mapping clauses respectively in form they are identical to their except that the word compute replaces the word produce the word mapping replaces the word function and the subject of a mapping clause is a mapping expression the terms subject global local formal parameter etc are defined as for produce and function clauses these clauses are used in programs to define their which in the case of a mapping clause must simply be a mapping variable when used in a program the body of compute or mapping clause must be a subprogram defining not the variable output but the variable result which is with output since the value of anything is see result must be defined to be eg by an expression of the form semantically these clauses like their are assertions about their and their a compute clause is true iff there exist values for the local variables which make all the assertions in the body true when each global has its value and result has the value of the subject a mapping clause is true iff for all values for the formal parameters there exist values for the local variables which make every assertion in the body true when every global and formal parameter has its value and result has the value of the subject applied to the values of the formal parameters an operational view the mathematical semantics of clauses is given in it is simple and precise even when stated formally and is used to justify the rules of inference for reasoning about programs and to prove implementations correct however it is not the best guide for writing and understanding programs because there is no notion of computations taking place or of anything at all we therefore present an alternative operational view of the semantics of clauses in program which extends the operational view of basic pro grams in terms of loops described in this operational view is informal and is derived from the more basic mathematical semantics of the four types of clauses the simplest operationally or at least the most conventional is the compute clause in a program it is like an algol block in that its subject is defined to be the result of a carried out in a single step of the enclosing iteration during which time the are considered to be frozen if the body of the clause has inductively defined variables the can be thought of as an inner loop for example the following program statement t in this paper we will abbreviate m by compute using x i p p pi i compute c using ab next p x first r ab next r result r r end if x c then result else ia bi end has an inner compute clause which defines each value of c to be to the cor value of ab this inner compute clause can be considered to be a nested loop which is run through completely on each step of the enclosing iteration the compute clause replaces the basic construct the other clause with a fairly tional operational interpretation is the mapping clause in a program a mapping clause defines a function guaranteed to be pointwise in its ments and ie a function whose value at a given point in time depends only on the values of its arguments and at that time it does this because it its parameters as well as its here for example is a definition of a mapping variable trans mapping result d e entry l end using if then nil else m then else l e care eq l v if then l else which when applied to the l returns the formed by replacing each atom by a corresponding the correspondence being given by the because we want the definition of trans to be recursive the function variable trans must appear on the terms involving mappings can be thought of as giving rise to algollike mapping calls will be shown when we consider the manipulation rules for clauses as the two types of clauses defined give the programmer roughly the facilities of blocks and procedures with certain restrictions on one of the reasons that these two clauses have a fairly conventional operational interpretation is that that in addition to restricting the scope of definition they also their and parameters so that they can be thought of as describing the produce and function clauses do not use this operational interpretation because inner computations of the enclosing iteration effect and therefore their is completely different can interact with those operationally the difference between a compute and a produce is that a produce clause must be considered either as an anonymous process which produces values of its subject or alternatively as a block of code which is repeatedly executed but with persistent internal memory in the form of inductively defined local variables for example the following clause produce n y t first output end defines the values of y to be the running of the values of x up to that time eg the third value of y is the average of the first three values of x the local variable t for example keeps a running total of the values of x we must imagine either that the iterations of the body of the clause are running in parallel but in step with those of the enclosing iteration or alternatively that the clause body is executed once on each step of the enclosing iteration i ii and but the values of the local variables t are between executions of the clause body function clauses can be thought of as templates for processes with each textual occurrence of a function call corresponding to the process which ia the appropriate instance of the template these processes must like those defined by produce clauses be thought of as operating in parallel but synchronized with the enclosing iteration and as updating internal variables even if on some steps of the enclosing iteration the output values are not required alternatively the function body can be thought of as a conventional algollike procedure body which is called and returns a result provided in addition that i the inductively defined local variables are thought of as own variables whose values are between one call and the next ii different textual occurrences have separate copies of these variables and iii the procedure is called on each step of the iteration containing the function call even when the value is not needed for purposes namely to keep the own variables up to date program for example the following piece of nl function i t output ti end y n eq defines y to be the average of the first five positive integers times the average of the first five whether we interpret this program in terms of processes or in terms of procedures with own variables the formal semantics requires first of all that the two occurrences of make use of separate copies of i and t and secondly that the values of these variables be kept up to date even though no actual need be computed until the fifth step of the main iteration the operational view just described can be extended to cover recursive functions but we must imagine that each recursive call sets up a new process or generates new copies of the own variables some existing coroutine languages are capable of this for example that of kahn and in fact languages already exist which exhibit similar features to most of those found in this operational interpretation of produce and function clauses but the difference is that the designers started with the operational view selecting those features which to a personal and view of what processes and are in the other hand any operational interpretations must with the mathematical semantics of clauses and this in turn is simply the result of combining the view of iteration with the ability to define functions and limit the of variables we can therefore claim with coroutine some justification that our notions and process are the true ones of program proofs by program manipulation we have rules for transforming programs which can be justified using the formal semantics using such transformations it is to reason about programs in a very natural way the first two rules allow us to carry normal reasoning within clause boundaries the first says that we can add to any any assertion that follows logically from the assertions in the conversely the second rule says that we can throw away any assertion from any on there is also a set of movement rules which allow us to move across clause boundaries assertions whose free variables are all of the clause any such assertion can be moved in or out of a produce assertion which or function is pointwise clause and any such i can be moved in or out of a compute or mapping clause furthermore in the case of a produce clause assertions which refer to output can be moved out of the clause provided output is replaced by the subject of the clause and conversely assertion which refer to the subject can be moved in provided the subject is replaced by output similarly the same is true of compute clauses if we consider result rather than output an assertion is pointwise if it is a pointwise term or a compute or mapping clause whose sub is a pointwise term or a function clause with no global variables these are the most important rules because they allow both small and large changes to an assertion in a single step the assertions being moved can themselves be clauses in order to the stage for the application of these rules we also need rules for adding global variables to a clause and for renaming its local variables we also need a rule which allows any function or mapping clause to be transformed to a produce or compute clause respectively by adding the formal parameters to the global list and by making any consistent substitution of terms for the formal parameters while these rules are natural use we know of no small subset of them which are sense and easy symmetric complete to computational behavior of functions and mappings the formal definitions of clauses and the manipulation rules above are sufficient to answer questions of an operational nature about functions and mappings can be function we will first used to perform call consider illustrate symbolic how the rules execution of a produce m function output mx if output end z output end l next x then x output rule by we first use the function with the formal parameter yielding x transformation being replaced produce m end output end l z output then output else then the definition yielding we use of z our movement rule inside the produce to move clause produce m produce first next output output z end output end first z if output then output lf else then inside for every some simple unnecessary statements the produce occurrence and after we have we substitute of z perform produce output j end output end using ll z the assertion can be moved out of the output inner produce yielding l then substitution equals for equals yields output in the body of the produce and this can be out giving of outer any mechanism to implement functions and mappings with all must produce effects that are consistent properties that can be proved using the manipulation rules in particular one such mechanism is the call by name rule as considered in to see that call by value does not work consider produce v mapping fx y result end if x eq output end f o then o else we can duplicate the mapping clause and then transform one of the copies into the corresponding compute clause setting up the parameter correspondence giving produce v result end if compute result end if output end using x eq using eq f o then f o o else o else inside the compute clause we obtain result fo which can be moved out and the compute discarded giving clause produce v m result end if x eq output end f o then o else we repeat the process with formal parameter being replaced by o and y being replaced inside the resulting compute clause get x by we result if o eq o then o else this simplifies to result o and when we move this clause we get out and discard the compute produce v output end o from this we clearly get output o which we can move out giving vo function inconsistent in a call by value implementation the program would diverge which with the fact that v o of is this name is language a more efficient the delay rule and that can actually mechanism or call by may be first use it than call need of programming by finally we will show that the tion rules can be used to the question of dynamic versus static binding of global variables of functions and mappings consider compute u mapping result end yl compute y result end end fx using xy result f y f the question is whether the value of u is or which depends on whether the inner or outer definition of y is used in the evaluation of f in a language like lisp which has dynamic binding the inner value would be used in algol the outer it is easy to see that the manipulation rules imply that uses static binding we cannot move the mapping inside the inner compute clause until we have renamed the inner local variable y the variable y can then be added to the global list of the inner compute and the mapping can be moved giving compute v yl compute result using y map fx using y result end z xy result f end end the definition the mapping finally obtain of y can now be and it is then straightforward v down into to ea no pp and language ww with iteration a cacm ea and ww a formal system for and proving programs siam j comput no pp structures computer ea and ww scope and defined functions cs science department university of revised version of cs kahn g and macqueen db and networks of parallel processes proc ifip pp north holland pj the next programming languages cacm pp j correct and optimal of recursion in a simple programming language th annual acm symposium on theory of computing austin 