predicate path expressions department of computer science university pittsburgh pa abstract path expressions are a tool for synchronization of concurrent processes they are an integral part of the data abstraction mechanism in a programming language and specify synchronization entirely in terms of the sequences of operations on an object of the abstract data type this paper describes an attempt to push the path expression synchronization construct along three dimensions verification and implementation into a useful theoretical and practical tool we define predicate path expressions which allow for a more convenient specification of many synchronization problems the predicate is a powerful extension to path expressions that increases their expressiveness we formally define the semantics of by a transformation to a corresponding nondeterministic program thus allowing the use of known verification techniques for programs to be used for proving properties of the and the data abstraction of which it is a part we also describe our existing implementation in algol of a data abstraction mechanism that introduction path expressions and allow us to express synchronization of on data objects the pe is an integral part of the data abstraction and restricts the sequences of operations on an object independent of the actual code in the bodies of the operations this raises the abstraction level of synchronization and also supports the use of data abstractions this work was supported in part by the advanced research projects under contract fc and in part by university of technology however in the pure form do not allow convenient specification of many typical synchronization problems several suggestions for constructs that would increase the expressiveness of the pe have appeared each to solve one particular part of the problem there are also no established methods for proving the correctness of concurrent programs using in their more general form except in isolated cases and we need a method that will make it easier to form and pre and postconditions to prove integrity of the data structure to specifications we also need formal methods for proving the absence of deadlock and as well as other properties of the solution finally there are few previous implementations of available et al to prove that they are practical in real systems especially there is none that with a data abstraction mechanism in a environment we see three ways in which the can be improved and made into a useful theoretical and practical tool by increasing the expressive power of we can make them into a tool that allows for easier specification of common synchronization problems by finding a constructive verification technique for we will aid in the construction of programs where size or reliability requirements were major the verification should build on the principles as the ones used for verification of data abstractions in sequential programs by making an efficient implementation of available we will provide a proving for the proposed implementation techniques and an that important aspects are not in sections we will describe what we have accomplished or hope to along the three lines of improving but first we will look at path expressions in their simplest form in section followed by an introduction in to the proposed in the form that we currently see them section defines the semantics of the path expressions in their path expressions are a highlevel synchronization construct that specifies synchronization at the level of the data abstraction ie in the type definition a mechanism for data abstraction will contain the specification of a representation for the abstract data type as well as definitions of all operations that can to objects of that type the pe then determines synchronization by specifying the sequences of operations on an object of the type suppose to define an abstraction for a buffer between concurrent producer and consumer processes we first the properties of the communication slot as an abstract data type buffer and then our particular buffer to be an object instance of the defined the type definition will contain the data representation message the operations message and message the synchronization path the path expression the sequences of operations on a particular object by a regular expression if we declare ourselves a buffer b the pe allows the following sequence of operations on read operations sequence operations on other buffers will be restricted to a similar but will be completely independent of the on the buffer b the operators in the simplest form of are sequencing selection and the execution of all operations in the pe are mutually exclusive o allows the execution of a strictly followed by the execution of b allows an execution of either a or allows zero or more executions of a following each other predicate path expressions since path expressions were first introduced by and they have been refined or in several subsequent papers and and and the basic set of operators in the pure has been augmented by parallel paths conditional path element priority operator connected path parallel operator numerical path element and others they are all basically introduced to allow the specification of parallelism in the path or control of when a particular operation can be applied we want to bring the number of constructs down while providing the expressiveness by most of we have kept the parallel operators introduced by for but have replaced all the operators in group by a single ion the predicate we have allowed control over the application of operations by introducing predicates into the pe which gave rise to the name predicate pe the operators for sequencing selection and are unchanged but predicates can be attached to any path element the predicate restricts the language that can be generated by the expression of the in that the path element can only be used if the predicate is true for the purpose of the predicate the application of an operation is further broken up into four parts request f execution and termination which are events with the implied ordering req f act f cf in time the predicate specifies a partial ordering between other elements in the execution history the predicates are expressed entirely in terms of implicit counters oct and on the number of events and any g robert and that act and specify that can occur only if the predicate is true the predicate is any boolean expression involving only constants and the implicit counters mentioned above discussion as already mentioned the purpose of introducing a into the pe was to eliminate the need for a number of od hoc operators and path elements that have been introduced to specific of the pure pe several papers have suggested synchronization scheme on the use of counters robert and and the specific choice of counters of the number of requests and was by a discussion in the operating systems review et al for efficiency reasons the predicate can be restricted to linear relation expressions connected by the boolean operators not and and or a linear relational expression can be written in a normal form av s o where al az are integer constants and vi v vn are the implicit counters and term on any function in the path expression the of counters and linear relational expressions as compared to arbitrary data structures or arbitrary boolean expressions is still under investigation as we see it path expressions advantages have the following they are part of a data abstraction mechanism synchronization is specified in one place only for each data abstraction simple synchronization relationships expressed as regular expressions are easily the path expression possible sequences of the operations determine the effect is a complete description of of operations ie the code need not be to of the pe the preserve of synchronization easy to express resource these advantages while adding the power with counters which makes it especially solutions to problems involving fixed etc example a shared bounded stack is an example where the pure pe is not powerful enough without to additional constructs like a conditional or numerical path element the predicates the very simple in this case init int n def ptr path pop the describes the fact that each instance of a stack will have a constant integer n viz the size with it at creation time and the specifies an explicit counter in terms of the implicit counters and the path expression describes the mutual exclusion of pop and top operators h also specifies that push can only be when ptr the number of slots in the stack is less than the maximum size n and pop and top which both the top element of the stack although only pop changes the contents of the stack can only be applied when there are elements in the stack ie ptr is greater than zero data abstraction mechanism to allow with the we have extended algol with a abstraction mechanism the mechanism has the following format type data representation init parameters initialization def counter path path expression suppose we have declared the type stack with the operations push pop the following is an example of the declaration and use of stack objects stack s new the mechanism will be illustrated by a complete example accepted by the current implementation we choose an array implementation of a bounded stack the program is explained in detail below mode elem real type stack ref elem eo init int n o heap def ptr pop with export proc stack s real s void id of of s z export proc pop stack j real el of of s export proc top stack s real et of of s stack s new line defines the type of the elements in the stack and lines the type definition the data part of the type is given after the equals sign in line as a record with two fields the integer is the index of the top element of the and et is a pointer to an array of unspecified size containing the elements of the stack in line of which the first part has been described earlier the initialization of each instance of a stack is given the integer initialized to zero and et is made to point to an element array of the specified size generated on the heap the three push pop and top which were mentioned in line are all to he known outside the type and are therefore defined as exported procedures in lines the bodies of the procedures are trivial using the increment i and operators of algol we have introduced the and operators as the means for accessing the internal data structure of an instance of the data type being s a reference to the value of s which can be changed while s returns the value itself line is an example of a declaration of a stack the constant s is a reference to a newly created instance of stack c by new stack which by convention invokes the in line with room for elements although s cannot be changed ie made to refer to another stack object the contents of the stack object can be changed and definition as in line by the operations defined in the type definition of semantics for a rigorous definition of the semantics of a programming construct is important both for understanding of the construct itself and for verification of programs using it the definition given here primarily serves as the basis or the verification technique proposed in section but should also the in sections and the is a list of the constructs or proposed in the currently included regular operators fg selection f k sequence f b restriction parallel operators j g t we will now define the semantics of a in terms of the restrictions that it imposes on the partial ordering in time of particular instances of calls to the operations mentioned in the to do this we first introduce the transformation c that transforms a p into a corresponding program cp an execution of the program cp will define a partial in time between the executions of operations on a particular object the program notation for the program cp is guarded commands dijkstra augmented by a parallel construct when the guards of more than one guarded command in an if or do construct is true there is a nondeterministic choice of one of those the do construct when none of the are true the specifies a total order in time between the units whereas the in the cobegin construct specifies ordering between the cg if true cf i true cg fi cf g cf h cg c if true skip i true cj fi here we have introduced recursion which will result in an infinite program an alternative is to use iteration only by introducing a ghost variable true do false cf od next we define the expansion for the predicate b c b if b c i not b fi b is a w relational expression in program etc some of the paths defined by this maybe because does the constructs require cobegin cv cg c if c i cobegin fi ci cf this last example again contains a recursion if we introduce another construct for creating and terminating processes fork and join we can use an iterative statement here also the fork statement names a procedure invocation and a process class it allow the execution of the named procedure invocation in parallel with the main process and assigns it to the given process the join statement names a process and will cause the main process to wait for completion of all processes in the specified class cf true do c k j fork cf in x od join k finally we define the expansion for the operations in terms of the events and term ff the symbol c an empty action that corresponds to an execution of the body of operation f h serves the dual purpose of defining the partial order between such executions of and allowing us to generate invariants over the of the events are expanded in the following way where the square brackets indicate that the events are request activation termination note that the event is not restricted by the path expression but only serves to update a counter value also note that for simplicity we have not mentioned the identity of the object upon thus the above definitions of c and c apply only for the case where we have one object of the type for which the path expression was given for the case with more than one object we can take the object identity into account by the events and counters with the creation number of the object we can now semantics of a predicate path expression p in terms of the partial orderings generated by cp each possible execution of cp generates a partial ordering of the events ff n where fn are the operations mentioned in the the execution history elt ej em is said to satisfy the pl fn m el e em restricted q fl fz fn is a subset of the partial ordering of events generated by m of f r pn note that by the definition of the events we will have the following axiom for a particular instance of an operation e req f act f f specification of synchronization the tasks of solving a programming problem are specific at ion implementation and verification the first task consists of analyzing the problem and specifying the requirements of the solution the second task involves the proper algorithms choosing the data representations constructing the program the more suited the specification method is o the problem and the programming implementation the easier we will make the at the extreme if the specification language were also the programming language we have eliminated the second task this section deals with the question of how close to this extreme we can get the third task is to verify or informally that the implementation accomplished exactly the of the specifications a suitable semantic definition of the language constructs will simplify the verification task especially if it itself to section will deal with that aspect of the problem in the use of pure path expressions and the extensions introduced to solve various problems that were very hard to solve without them we have found at least two areas which need improvement one is the specification of desirable parallelism between operators in the fe this is already possible to some extent by using p but we feel that certain classes of problems require other constructs the other is the weak power of regular expressions in specifying complex sequencing we need the power of a context free language to describe the relations between operations on a stack for example synchronization takes places between two or more processes that are operating on one or more a objects the sharing of a data object is essential since otherwise there would be no need for synchronization we need to the integrity of the shared data object and the correct operation of the which can be expressed as basically two separate synchronization problems exclusion to that data is consistent certain classes of operations on the object must other classes of operations from simultaneous access data to the proper of operations on a shared object they must be able to communicate information about availability of resources etc scheduling of processes is not a synchronization problem and should therefore not be built into the synchronization primitives it is of interest that scheduling can be expressed with the help of these primitives as we shall see in later examples but we do not want to introduce any discipline on the handling of waiting lists other than an assumption of fair scheduling exclusion one type of exclusion mutual exclusion is already built into the pe the semantics of specify that all evaluations of the path state are mutually exclusive and further that constructs by the sequencing fi selection or operators are mutually exclusive to specify weaker exclusion we must be able to detect the execution of classes of operations and be able to restrict the execution of other classes of operations in section we viewed an operation f as consisting of three events req and we say that between req and f is w and between and term is executing we can now express exclusion of f by g as follows o where f p means that can only execute if the predicate p holds the construct can also be used to relax the mutual exclusion section in see the problem in certain types of sequencing can be specified directly in pe in the case we need to be able to detect the presence of resources etc in fhe shared data object in a problem with a finite buffer the messages are produced by and consumed by while slots are produced by remove and consumed by if n is the initial number of slots we can express the synchronization as follows def slots n pat h there are other ways of expressing a solution to the bounded buffer problem without predicates but the shared stack problem of section is an example where they are necessary scheduling there is no scheduling implied for the queues maintained by the implementation except for the basic fair scheduling requirement informally this means that no operation allowed by the pe will be delayed however the predicates and counters give a powerful tool for specifying certain kinds of scheduling with the themselves in particular scheduling is possible as illustrated et al by the rw problem readers and writers access the same data base to of data no readers or writers should be able to access the data base while a writer is changing its content mu exclusion of readers and writers is one obvious way of doing this mutual exclusion path read however we can relax this by allowing concurrent access by readers to get weak reader preference path read note we now have introduced the possibility of of writers if it is that the data is kept we give writers priority which leads to writer preference def ww path write in this solution any waiting writers reader another alternative follows the paradigm that it is better to information than nothing at all ie we waiting readers writer activation reader preference def wr path read the next solution readers in as long as they keep coming then allows writers until no more are etc this is so because the predicate in this case applies to the ie waiting writers can only e start of the first once no writers are waiting readers can be in this solution both readers and writers can each alternating solution def ww path read write ey simply inserting a d places in the we have the to most variations on the rw however solutions all contain the problem to specify the th solution which maintains the order in which the requests arrive we need to to multiple levels of path expressions or introducing some other way of specifying the fifo order in a sense we introduce a concept of variable priority where the priority is determined by time one possibility is to introduce a strongly coupled selection which will cause a strict fifo order between the elements in the selection the justification of such an operator is still to be determined fair solution path read verification of solutions to synchronization problems we will look at synchronization problems as just a special case of data abstraction when we prove the correctness of an abstract data type we first prove weak correctness or the consistency of the abstraction this can be done by separately verifying integrity of the data structure by showing and to specifications by pre and postconditions for each operation second we want to prove strong correctness by showing that each operation in the concurrent case however strong correctness also requires us to show the absence of deadlock and and possibly scheduling properties if part of the problem and for the weak correctness we concentrate on verifying data integrity any verification technique needs a rigorous specification of the semantics of programming constructs and to some extent it is by the way this specification is done the first attempt to formally specify the semantics of can be found in and we are relying on another technique for formally defining our a technique that makes it possible to directly apply existing verification techniques for sequential programs we will now try to describe how the semantic description in section can be used in the verification process an overview of different synchronization primitives and some proof techniques that have been proposed with them can be found in weak weak correctness involves proving the consistency of the data abstraction ie the integrity of the data and the to specifications for operations on the data type the transformed path expression is a more suitable form for standard verification techniques eg method of weakest dijkstra and or inductive assertion method hoare invariants we use invariants to specify conditions that will always be true about a data abstraction conditions that guarantee the of the data structure the invariants are shown to hold prior to and after all operations which guarantees that each operation will restore the data structure to a consistent state in the concurrent case invariants will sometimes contain predicates to guarantee exclusion etc recall the transformation of an operation in the cfl f since the body of operation will be executed between and we have already said that c corresponds to such an execution we can now make the following observation any statement that can be shown to be true at fin cp will be invariant over the body of pre and postconditions the specifications for an abstract data type include pre and for each operation the task of verifying to specifications for data abstraction involves showing that the postcondition will be implied by the precondition in conjunction with the body of the operation in the absence of parallel operators the predicates of the will serve as preconditions for the operations strong correctness verifying strong correctness or total correctness for a program can involve proving that the program is deadlock free or free these concepts have been formally defined in and based on a model of parallel program execution in terms of a nondeterministic program for each operation on the abstract type that is mentioned in a program we can informally define absence of deadlock and in the way a program is deadlock f for operation from each execution state there is m execution path that either halts or permits to execute a program is q for operation from each execution state m execution paths either halt or permit to execute f a program is free it is also deadlock free we can prove such properties sequences paths nondeterministic program conditions of the by looking at of the corresponding and interpret the above initial deadlock free for f if al least some path with this initial path contains free for fi if w initial path contains p with this and give axioms inference rules and theorems to allow the verification of these properties in a model that closely our transformed cp we hope to be able to use these or similar rules to prove the absence of deadlock and in the path expression or the program that uses it of path expressions and data abstraction in in order for to be a practical programming tool there must exist efficient implementation techniques an actual implementation will also put the proposed implementation techniques to a test and make sure that they are technically feasible for several reasons we chose to implement the in algol s a subset of algol implemented on the multiprocessor at university by peter et al et al the language supports and type mode definitions and the availability of the was a major advantage algol supports type checking but not information hiding and other features that we associate with data abstraction since we also need a means for associating with the type definition we decided to add a data abstraction mechanism to algol s the implementation which is described separately and is made flexible by the use of a that translate type definition into a slightly extended algol s and runtime support routines for access to the internal representation of data objects and for synchronization it implements the as described in section with the following exceptions the parallel operators are not implemented as a consequence the event counters and be replaced by a single counter the req is not implemented the effect of parallel operators and the counter can be simulated by dummy procedures in a straightforward way the works at the level of the compiler ie it uses the lexical of the compiler does the transformations on the stream of and the new stream of directly to the the parts of the implementation that deals with are of the algorithms for reducing states and removing runtime routines pro and to support synchronization parsing the the parsing stage builds up a graph representation of the finite automaton corresponding to the path expression each operation in the pe will be an arc in the the nodes in the graph will be identified by the set of arcs that et the node see figure the set of arcs associated with each node thus the set of operations that can be in that state the function gives the state that each given arc will lead to the set of arcs can be represented as and the test for of an operation is then a simple bit operation arc d arc op i path a bc d figure implementation graph and transition table between the set of arcs on which the operation can be applied and the set of arcs that can lead from the current state in other words the of an operation can be determined by the intersection between the m in the current state and the possible for the operation if this intersection is nonempty the operation i feasible if the intersection contains only one the next state is uniquely determined and reduction if the graph that was generated by the parsing step is such that one or more intersections between the arcs in some state the possible for operation contains more than one element we have an ambiguity ie two or more arcs with the same operation are leading out of the same state and we thus dont know on which arc the operation will execute such can be removed by techniques for transforming nondeterministic finite automata into deterministic ones and unman the implementation also contains algorithms for equivalent states and with the resulting graph from the previous steps we now have enough information to implement the synchronization restrictions with the simple inclusion of a call to a common and at the beginning and end of each procedure mentioned in the pe the takes as parameter the set of possible arcs for the operation and returns as value the arc on which the operation will execute if the intersection between and possible a is empty the process invoking the operation in the until the intersection becomes the takes as parameter the unique arc on which the operation executed and finds the next state from a table associated object see figure for predicates this simple implementation scheme will work for containing the sequencing selection and operators when we add predicates to the pe the implementation changes slightly we now have to counters in the data fields of the object and in the transition table indicate which counters should be updated and how the will have to first make sure the intersection of arcs possible arcs is nonempty and then evaluate and test the predicate lf the predicate is false the process is put on a waiting list al test are after the execution of a procedure that could change the outcome of the predicate waiting transition state list table j o waiting processes j figure tw instances of an abstract data type a possible layout is shown in figure in a situation where efficiency is required the instructions for updating counters that are now stored in the transition table could be compiled into the code of each function conclusion this paper shows that it is feasible to improve path expressions in several respects to make them a theoretical and practical tool for the programmer of concurrent systems we have move along three directions and analyzing by the predicate to the need for parallel constructs we will increase the expressive power of the pe this will allow direct specification of most occurring synchronization problems and greatly simplify solutions to others by formally specifying the semantics of path expressions in a tractable way we allow the use of wellknown verification techniques for sequential programs this to verify consistency of a data abstraction and absence of deadlock and in the synchronization scheme expressed by the an implementation of in a environment will provide a proving ground for implementation techniques and the practical test of the the of the research is on the first two points specification and verification we believe that the research will contribute in the following ways combining the use of predicates and the regular expressions of in a way that allows for easy verification and efficient implementation formally specifying the semantics of in such a way as to allow the use of wellknown verification methods for sequential a method for verifying properties about synchronization by the path expression without taking into account the actual code of the operations that are synchronized cnt cnt i ii i increment instructions w figure the transition table for a specifying the algorithms for and the theoretical parsing the building a graph reducing the graph and removing the runtime routines providing an in terms of a that with the compiler at the level acknowledgements the author wants to thank for and on the ideas presented in this paper peter for providing insight into algol and paul for constructive ideas on the specification references s synchronization concurrent primitives and the verification of programs in proceedings of the second international systems le france oct and s and pg types in algol in of the fifth annual iii on the implementation and design of le france may et al s p a n vr and w letter to the editor v denotational and axiomatic definitions for path expressions laboratory for computer science mit mass rh and an the specification of process path expressions in and editors lecture computer science vol operating systems pages springer verlag rh and tj a path pascal language draft department of computer science university of illinois at illinois april et al pj f and dl concurrent control with reader and writers of the acm dijkstra dijkstra ew a of programming prentice hall new l on the design and verification of systems phd thesis department of computer science university pittsburgh pa may and l and an toward the construction of software systems proceedings of the acm conference on abstraction definition and structure notices issue march and l and n complete proof rules for the total correctness of parallel programs in proceedings of the annual ieee conference on the foundations of computer science ann oct rw assigning meanings to programs n schwartz editor mathematical aspects o computer vol j pages mathematical society ri aj process synchronization by counter variables systems review oct aj letter to the editor systems review july an operations on shared data by function modules in type definitions department of computer science y pittsburgh pa sept an path expressions technical report department of computer university pittsburgh science pa june et al a n l l p l and rs and hierarchy in a family of operating systems technical department of computer science university pittsburgh pa et al p and ew a runtime implementation scheme in proceedings of the international conference on algorithmic pages institute new hoare hoare car an axiomatic basis for computer programming communications of the acm oct and pe and rh a description of path by petri nets technical report computing laboratory university of upon upon great may robert and robert p and jp toward descriptions of synchronization modules in b editor information processing pages northholland co ha on the efficient implementation of conditional critical regions and the constructions of monitors acts in 