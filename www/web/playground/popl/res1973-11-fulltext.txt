recursively defined data types part by c h lewis b k rosen ibm thomas j watson research center heights new york introduction many recent programming languages ei permit construction of data types defined in terms of themselves for example struct x ref a y int the tation of type expressions some interesting problems in semantics when do two such forms describe the same type are a and ins struct ref a y t the same if the language types is union a struct from a the answers to these questions for particular languages are often rather complex algorithmic criterion for equality is and struct x ref b x ref c y int different in some cases a the present paper describes a view of data types which permits a reasonably natural treatment of these issues as a basis for discussion a system of data types will be useful a data type in this system is any of certain sets of values for each type there exist cells capable of containing exactly the values which and character are members of the type types called int and char are given consisting values in addition a number of functions generators of suitable integer are provided ref t where t is any type is the set of all values which are references to cells of type t struct s tl sn tn where the si are selectors and the ti are any types is the set of all values which have n components selected by the si of type i vector t where of type t t is any type is the set of all values which are vectors of components vector m t where m is an integer and t ia any type is the set of all values vectors of components of type t whose index is m which are vector n t where n is an integer and t is any type is the set of all values vectors of components of type t whose last index is n which are vector mn t where m and n are integers values which are vectors of components index is n with rm and t is any type is the set of all of type t whose first index is m and whose last another way of producing types is ordinary union any finite union of types is a type for ex a cell of type int u ref int may contain any integer or any reference to a cell of type int the relationships to be assumed among these types and generators are given in the form of a list of axioms in section recursively defined types are introduced into this system in the following manner it is required that any system of type equations of the form z ge ek stand for types each is an expression k built up from these are type generators have a unique solution mapping identifiers where the zs are identifiers variables using type generators which may and u and the g to types the condition on the form of the equations is designed to equations like while equations like a struct a some points can be made about this system of data types first some recursive type definitions are permitted which are from many languages development below will show that there is nothing for example struct a b int the about such types from a logical point of view though their exclusion on efficiency may be justified second large families of different type descriptions indicate the same type consider a ref struct a and ref struct a b j ref struct a l let t solve the first equation that is suppose t ref struct at then give the value t in the second equation the right side becomes ref struct a t u t ref struct at t so t solves the second equation as well since each equation has a unique solution both have the same solution and hence describe the same type in algol types defined in this way would be considered different on syntactic in el no two separately defined types can be identical the of types made in the present system correspond closely to those in though has no between types like vector t and vector t which are not ex union types two questions arise in considering the type system description given above first is it consistent that is can a system exist which satisfies all the stated conditions simultaneously second does the system completely define the relationships among types or could there be two in which some types compare differently to see that consistency is not an idle question notice that the stated conditions cannot be satisfied if the form of equations for which unique solutions are guaranteed is not restricted the equation u has as solutions both int and int g char which are certainly not the same type consider also the type generator deref t defined to be t if t ref t and t otherwise the use of deref in recursive definitions would have to be restricted since deref ref a is satisfied by any type at all these questions will be by constructing a model for the axioms presented in section and by that all such models are isomorphic the model is constructed in similar to those of scott the isomorphism proof is given in section by techniques of the type system the following axioms specify the relevant properties of the types and generators described in section l every type ia a nonempty set every finite union of types is a type in stating the next axiom a classification of the type generators will be useful the types and char will be considered generators taking the argument list and producing and char the generator ref ia monadic any notation of the form vector a b where a and b are integers or will be considered a monadic generator if a and b are integers we require for example vector will be thought of as the result of applying the generator vector to the argument int the notation struct stl will be thought of as for struct si si t ti where k k the s are s sk in some so struct si si will be to be a generator k axiom let g be a type generator for some nonnegative integer upon order k and let r rl rk be a list of length k of types then g r is a type we now need an axiom that systems of of the sort mentioned in section have unique solutions at the same time we will close off the collection of by specifying that only objects which are solutions to certain equations are types in section we considered systems made up of the form z ge ek where built up from variables generators z is a variable g is a generator and the ei are expressions and the union symbol u by adding new variables the operations in each ei by equations and exploiting the associativity of union we can replace such an equation by a set of much simpler equations which we will call proper equations a proper equation has one of two z u where g is a generator is a variable z ul u are j restriction on the use of variables all variables prevents equations and xl may be or the like a a u int from being as sets of proper equations a proper each variable system of equations is a finite set of proper equations involved if every proper system has a unique solution that has exactly one defining then so does every system of the sort discussed in section for example the system a ref int can be as u struct x ref u u v u int v struct axiom every proper system of equations has a solution every type is expressible not necessarily uniquely as vz where z is a variable in a proper system and v assigns to each variable its value in the solution of the system note that the restriction that types be expressible as solutions does not rule out any of the types discussed in the earlier axioms for example if t is vz for some variable z in a proper system p then ref t is expressible p as vz in the proper system formed by adding the z ref z to we next state axioms specifying the possible overlapping of types let gg be type generators and let rr be argument lists for gg suppose g r n gr then r rand either g g or both are vector generators the next axiom the relationships among types produced by the various vector generators when they are applied to the same argument axiom for any type t and any integers mm nn with and vector vector mn m t n vector m n ut vector mn mn t t and vector mm and n t nn u vector mn t vector t u vector mn t mn we now consider a few lemmas derivable from these axioms proofs are in lemma let gg be type generators and let rr be argument lists for gg unless are both vector generators iff g g and if g and g are both vector generators let g be vector ab and g be vector ab then g r gr iff g is a or b is b or and rr g and g lemma let be the set of all types which may result from the application of any type generator to any argument list there is a map parts from types to finite nonempty subsets of such that for all types s and t us p in p st iff vp in q in p g q this lemma permits a convenient decomposition of any type as a union of a finite set of constituent types in such a way that of inclusion of types may be reduced to questions of inclusion of their it is easy to show that if one eliminates redundant terms from then the position obtained is unique lemma no member of is expressible ae a finite union of other types lemma every member t of is expressible as t g r for a unique generator g and a unique list r of types these last two lemmas taken together assert that a type in can be produced in a unique way other than by redundant uses of lj for example indicated except for forms like u the type ref int cannot be produced other than as having stated these axioms and a few consequences can be readily generalized for example other we can step back and note some points at which they generators not overlapping int or char would cause no problems nor would any other new generators as long as no or would be introduced a discussion of this topic including some more general statements axioms may be found in of types of these consistency construction in this section we outline the construction which shows that there is at least one family of sets together with operations define some terms int ref and so on that satisfies all five axioms from section first we a relation on a set t is any set of ordered pairs of elements of t if the name of the relation is then rs that rs is in iff and st if and s are relations for some s in t a relation on t then so is their composition on t is reflexive iff for all r in t it is iff rs and sr imply r s it is transitive iff rs and s t imply rt a reflexive and transitive relation is a partial and a set together with a partial order on it is a partially ordered set abbreviated a partial order on t is linear iff for any rs in t either r or sr if t is a poset an element s is maximal iff the only element t with is s similarly s is a minimal if the only r is s any relation on t has a reflexive transitive closure h which set of ordered pairs for which r s iff rs or r f i we begin with purely formal symbolic expressions trees whose nodes are labelled by symbols from an alphabet which includes symbols for type generators in addition to formal symbols like int such aa ref for ref and a symbol for union union ref monadic and union we use two a and d we think of trees as descriptions of types and we think of a and l aa we use to represent a tree which is not immediately available perhaps because it is too large to fit on the page a subtree in a tree whose place is held by a is not in any sense unknown or undefined it is merely on the other hand holds the place of a tree which is not yet determined the trees to be used will be into two infinite sequences of sets of trees and tree in general will consist of trees not rooted in union and with height bounded by h in addition to will contain certain trees rooted in union whose maximal proper subtrees are all in considering a l as one node trees we begin with before defining l later and u ui sets in the sequences l inductively we specify a partial order s as the smallest reflexive transitive relation on tree o such that because is indeed it is correct to call it a partial order we refer to this relation as scott precedence because it was suggested by the ordering on trees used by scott in let o a spirit be the set of trees in which are maximal with respect to scott precedence thus is just for ho will not be so trivial right now we just want to start things moving in the same we define formal inclusion on to be just the equality relation for ho formal in will not be so trivial among members of figure illustrates the next definition definition for any nonnegative integer h consists of all trees where g is a symbol other r l k than union and rr rk is a list of length k of members of denoting such a tree by tree gr we define scott precedence on by tree gr s tree g r iff g or g g k k rk formal inclusion is defined on as follows g r and s tree g r with argument lists first s s for all s second suppose s tree rr that include only members of ma unless gg are both vector symbols iff gg r r if gg are both vector symbols say g vector ab and g vector ab then ss iff a a or a b b rr to continue the construction we define in terms of for all h the definition of in and is a special case of the general definition definition for any nonnegative integer h consists of together with all for some list r rl rj of members of such that jl r lacks r follows some arbitrary linear order on there are no j k with rj there are no with ri rj here is defined by p q iff pq and p q similarly for scott precedence is defined on as follows for trees pq in h and tree tree p q in iff p s p q in h iff v k p sk sq iff j unions in j s s unions v j k k j rj sk let be the set of all members of that are maximal with respect to formal inclusion on is defined to be the equality relation on together with the relation on ma defined as follows where pq are again trees in h pq q n i ref ref i i union l a uc i w dec tor vector union a vector i r r a t ref i a vector a i ec tor a figure xi with the heavy arrow represents formal inclusion shown light arrows represent scott precedence and the of l not shown p tree union s iff k sk tree tree r tree union s iff union r j q iff k j def is much more complex than def because of the special properties of union as an operation on types the conditions under the definitions reflect chosen the properties of union and some technical considerations it can be shown that and are both partial orders and that acts as a bottom minimal element under s for each h it can be shown that any sequence r r r in tree h is finite lemma for any nonnegative integer this is called the h and are partial chain orders property on under has bottom l and has the the set ma of all maximal with respect to members of is precisely the set of all members of without occurrences of we now have formal names for types let us define formal operations on the names that the operations on types if g is a c type generator symbol and l rk formal operation g maps r r to a tree in are in tree then the g r tree gr we will also need an operator union whose definition is more complicated we begin with an operation called merge if a is a finite nonempty subset of we form a list r of the members of a using the arbitrary linear order on from in def there may be indices jk or which in def enough components we can eventually for each contradiction arrive at a list which we delete r from the j satisfies both conditions list say by deleting s s sk it can be shown that s is determined by a let if k then s else tree unions so that merge maps finite subsets of into now let the mapping parts corresponding to the mapping parts on types go in the opposite direction parts r rj rj jj parts p p for p in for all ko we set t tk u parts tk lemma for each h the formal operations g and union are monotonic with respect to s if is any of these formal operations and r rj s sj are argument lists for then j ro s furthermore vj rj is in our symbolic type system is still iff r is not adequate for solving proper systems of equations even in a purely formal way for example no finite tree can have s ref s but axiom requires that some type s have s of trees to use although no single tree describes s there is an obvious infinite sequence ref ref i ref i ref ref i ref i a i ref i ref a i i a i ref ai a for each h is in the h a out in the sequence just as see appendix points indicates that more information is available to more details in a here we allow to to to as much as necessary for s the go on forever for ref int the sequence ref ref ref ref a i i i i a int int int when a type is described by a sequence t of trees each projection th is in ma however trees with l will be very important in existence proofs to illustrate the ideas we solve the equation z since nothing rooted formally the operation ref is defined on a sequence t of trees in ref appears in we set t a to find the hl as follows projection we apply ref as defined by we begin with an to t value for z l l l j given viz we find by z to the value of the right side of the equation under i viz a ref i ref ref ref vz a i a ref ref i l and so on clearly s to generalize the sequence this example we need to specify to our type description s with s ref the class of sequences of trees to be considered as partially defined type descriptions we need to define convergence we need to show that proper systems of equations always define iterative processes and we need to show that solutions are unique most of the work is actually behind us in the proofs of lemmas and what remains is to specify just what we mean in saying that is a more detailed version of and to invoke some very general theorems about partial orders and fixed point computations for each h a h subtrees of r tree is defined h are replaced by a if r is already in then is r if not then some so as to form a tree that r the root but within the of union nodes the definition but the concept is like the simple map used by scott sec the important technical properties of the map are in the following lemma for each h the map th is monotonic with respect to both and it also preserves g r the bottom r g k hi l th finally and the formal operations th union r rk are compatible with union definition let seq be the set of all infinite sequence s of trees such that the projection is in for all h and such that by th for all h we define scott precedence on seq rs iff all h and define formal inclusion on seq by rs iff all h such that are in ma scott precedence partially orders seq let be the sequence l j l in seq the system seq s is what we call property that every directed subset a complete m a partially ordered set with a bottom and with the has a least upper bound a directed subset a of seq is one such that rs in a a and ao a least bound for a is a member l for all is seq that is also an upper bound r in a and such that l s m for any m the theorems on complete lattices used in are equally good for complete posets some of the proofs are different but they are no more difficult we prefer to use the complete poset concept because it is much less difficult to obtain in applications see for further discussion of the differences between our construction and that of scott the lemmas we have stated and general theorems similar to those used in lead to a proof that every proper system of equations has a unique symbolic solution in which each variable z has a value vz in seq the set vz i z is a variable in a proper system v is the systems symbolic of formal descriptions is a subset of seq with the property that is maximal for all h and all t in solution with respect to s formal inclusion is a partial order on and the formal operations map arguments in to results in this collection of sequences of trees is as close to being a model for the axioms as any purely symbolic formal system could be to complete the outline of the consistency construction we need to assign a set to each formal type description we begin with a map set defined on the set of sequences in which have no terms rooted in union for each choice of r in there ia a unique type generator symbol g and a unique ss sk for g with each si in such that if g is not a vector symbol then set r consists of a single ordered pair set rg s if g ie a vector symbol suppose it is vector ab then set r is defined to be the set with at b unless a ia of all pairs and bb unless b is s where a for example and b are integers vector is is vector s vector now that set set r t has been u defined set p in for each p r in we extend the map to all of with the parts map does extend to in the natural way the collection of acts types t is easily seen to be a model for the axioms r set s implies rs set r once it has been checked that s iff rs set r u set s set rs the type generators are defined on the types by rk m g r where g is the type generator uniquely determined symbol corresponding to g and each has rk and is thus isomorphism of type systems we know there is at least one model for the axioms because we constructed one what light does our special model on the models we ultimately care about can a type checking procedure validated in the special model be used with in an actual implementation this section will show that any two type systems satisfying these axioms are where questions of equality inclusion or intersection of types are concerned the rigorous definition of systems which display a perfect of structure is in terms of isomorphisms mappings between following the usual algebraic practice we begin by defining morphisms and then define to be morphisms that have inverse morphisms definition let tt be type systems and let f be a map from t into t then f is a morphism from t into t iff for all type generators g all in tk for g and all st in t fg rl rk fs u t fs u ft implies es f thus f t t lets us carry type computations from t into t an isomorphism also let us go from t to t via an inverse morphism definition let tt is an isomorphism be type systems and let iff there is a morphism i i ft be the identity t such that maps on tt ff i and a morphism ff i lemma let be type systems and let f t t ad f t t be morphism the composite map ff t t is also a morphism lemma let tt be type systems there is a unique morphism f t t proof following lemma we assign to each t in t a finite nonempty subset of the type expressible as values of type generators let x and be disjoint sets of variables in one to one correspondence with v va and let z be x thus we have maps i the identity map on t the variables z will be used to form proper equations as discussed in section with the variables in x being designated the variables and those in x being designated for each t in t we choose an equation et if t is expressible as a finite union of other types then et is at u where pl pj is a listing in any order of the of if t is in then lemma implies that there is a unique type generator g and unique rl rk in t for g such that t rk we let et be the equation at a rk now consider by the infinite we conclude collection et et i t in t of equations that the assignment of values v z specified by and solves all the equations in et except for being infinite et looks like a proper system of equations and to have a solution in t as well we specify some finite subsets of et that are indeed proper systems if rs are in t and s appears on the right side of e r in or we say that letting indicate reflexive transitive closure we set er es i r uses a r uses s to show that er is proper we must show that it is finite by axiom there is a proper system f which defines r both er and f become directed graphs when we specify that there is an arc from e to e iff the right side of e contains the variable defined by e a depth first search of f can be followed in er in such a way that f is mapped onto er therefore er is finite now we pass over to t each system er has a unique solution vr t where is the subset as i r uses s of z consider the set of pairs variable v u v r type defined by and suppose that v is actually a function mapping z into t that is that v is single valued we can then define a map from t into t we claim that f is a morphism condition in def follows from and here to verify the other conditions we will first show that for all pq in pq implies fp g fq indeed p g q implies that some generators g and g rk where g and g are either identical and some r rk or are appropriately in t have rk related vector generators applying f to both equations and that lemma holds in t also we find that fp g fq condition in fs def will u p in be verified fp next by and here any s in t by and lemma for t any st in t with s fq ft p in q in t have this verifies condition in def to verify condition in def we need only show fs u t g fa u ft since the other inclusion already v follows from ut s s l t and aq in t s u t lemma implies s q that therefore fs u t u p in fp u t by l q in parts su u fs ft fq by by this completes the proof that f is a morphism at least if v in is singlevalued now suppose that g tt is also a morphism for any r in t er is solved in t by v r and by vr where for all z in thus vr vr and so gr therefore f is the only morphism from t into t all that remains ie to show that v in is singlevalued let rs in t and z in z be chosen so that z is in both and zs we must show that let t be vz so that r uses t and s uses t we have et er es zt fl zs restricting vr to zt yields a solution to et in t so does restricting vs to zt since proper have unique solutions vr and vs must agree on zt in particular as we conclude with a typical algebraic argument theorem any two type systems t and t are isomorphic proof by lemma there are morphisms f t t by lemma ff is a morphism from t to t and therefore ff i by the uniqueness in lemma similarly f f i and so f is an isomorphism m references van a editor and c h a math b j j e l algol b studies in extensible programming languages ph d thesis language massachusetts manual massachusetts computer associates inc c h a on infinite vol no march modes algol in sigplan notices p and m m the formal definition massachusetts computer associates inc part i massachusetts scott d the lattice of flow diagrams in semantics of algorithmic by e springer lecture notes series verlag languages tarjan r depthfirst search and linear graph algorithms siam j computing j the equivalence of modes and the equivalence algol no march of finite automata rosen b k and lewis c h recursively report in preparation defined data part ibm research m the ctl storage model r ibm research w lewis c report rc do and p heights ny s m explained the type system to us r pointed out the need to relate the constructed realization of the axioms to other v the manuscript under very difficult m r w d an d p defined a type system on which the one presented here is based 