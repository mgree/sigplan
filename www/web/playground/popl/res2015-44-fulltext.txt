specification inference using contextfree language reachability stanford university stanford university aiken stanford university abstract we present a framework for computing contextfree language reachability properties when parts of the program are missing our framework infers candidate specifications for missing program pieces that are needed for verifying a property of interest and presents these specifications to a human for validation we have implemented this framework for a taint analysis of that relies on specifications for library methods in an extensive experimental study on our tool performs verification with only a small number of queries to a human categories and subject descriptors f semantics of programming languages program analysis f specifying and verifying and reasoning about programs mechanical verification keywords program analysis verification specification inference introduction interprocedural analyses are the building blocks for many applications of program analysis including program slicing bug finding and taint analysis one limitation of most interprocedural analyses is that they assume the entire programs source code can be analyzed in practice many programs call methods in libraries that may be written in languages use dynamic features such as java reflection or do not have source code available for analysis in fact in our experience for large systems it is if any of these situations does not occur many times handling missing or code in a fully automatic way generally results in using either very pessimistic and assumptions or very optimistic and unsound assumptions one pragmatic approach to address these problems is to manually write specifications encoding the relevant behavior of the library or methods so that the library source code does not need to be analyzed for this approach to work it is critical that i the manual effort of writing the specifications is small and ii the analysis produces sound results even if some specifications are missing prior work has addressed these issues to some extent have applied data techniques permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm to infer specifications which helps address i and has developed techniques for inferring minimal sets of specifications needed for program verification which addresses both i and ii in this paper we consider the problem of inferring missing specifications in the context of solving a general contextfree language cfl reachability problem many important interprocedural analyses can be formulated as cfl reachability problems and our framework makes these algorithms more practical and easier to apply to large programs where parts of the code are either missing or too difficult to analyze statically we instantiate our framework for taint analysis of and perform an extensive experimental study on many of these have of of bytecode instructions and of calls to library methods instead of analyzing the library methods we infer two kinds of specifications that help capture their taint behavior · missing taint flows between parameters and return values of library methods and · missing alias relations introduced by library methods our work has three main contributions first we develop a general framework for describing potentially missing specifications for cfl reachability analyses section in particular the framework can be instantiated to compute the two kinds of specifications above among others second we present a specification inference algorithm based on this framework section that produces sound results infers accurate specifications to large applications and allows a human to refine the results third we evaluate an implementation section of our specification inference framework with the experimental study in which our tool infers a large collection of library specifications and verifies whether or not have taint flows section motivating example we begin with an example that the need for specification inference to verify reachability properties of partial programs the technical development begins in section the of the framework which is on over has led to a of these malicious exhibit behaviors including of information sending text messages to numbers and location tracking many of the malicious behaviors by current can be described as the flow of sensitive data to untrusted such as location data to an untrusted web server or an untrusted number to an send request in principle standard static taint analysis can identify such for example suppose we want to look for that leaks location data via messages consider the code in figure in principle a static analysis can track the data returned by and determine that it is passed to unfortunately the library written in java with calls to native code is a classic example of how system libraries cause difficulties for static analyses library methods frequently use reflection and native methods making it very difficult to construct a precise call graph or to perform a sound and precise context sensitive pointsto analysis examples of such problems in practice include · is a native method · indirectly calls the native library method are used to pass data to and receive data from the system · is part of a library so the source code is while implementations of the library methods may be missing the net taint flows through these methods are generally simple for example we can summarize the net taint flows through and as follows i may be aliased with ie they may point to the same object and ii if taint flows to then taint also flows to here is the return value of fn is the receiver of fn and is the parameter passed to fn named the library specifications in figure capture these properties note that the code in figure is only a specification for the list and double classes ie it soundly captures the information flows and aliasing introduced by their methods and is not a valid implementation of the classes there are two kinds of specifications an alias specification summarizes the potential aliases caused by a library method these are written as short methods that do nothing except introduce the desired aliasing for example the specification for means that calling may cause and to be aliased also the specification for says that calling may cause and to be aliased note that if and are aliased then these specifications cause and to be aliased a taint specification describes how taint flows through a library method these specifications are expressed as flow annotations where the taint on the first argument either a parameter arg a return value ret the receiver this or a special label such as loc representing a taint source is to the second argument similar to the first argument except in this case a special label would represent a sink eg for example the specification of means that if is then is also the specifications in figure enable the analysis to find the flow from the source label loc to the sink label in figure first the return value is with the source label loc second this taint is passed to which is stored in third the value is from list and stored in before being converted into a string and passed as the text argument of the library method text finally our specification says that the text argument of the method is sent to the sink labeled so the code a flow from loc to we may expect that flow specifications are sufficient to capture all information flows for example we may consider using taint specifications that handle field accesses and replace the alias specification for with the flow specification however this specification is fails to capture the flow from loc to in figure double list list new list double string figure a flow through the list and double classes class list object val void arg val arg object index return val class double return string class return static string class static void text figure specifications for library classes class box string f list list new list box box new box box figure an information flow not captured by taint specifications is by loc so is since and are aliased but the proposed specification for does not transfer this taint to even though taint flows to in general we need alias specifications to precisely and soundly capture flows due to aliasing manually writing library specifications is expensive the library contains over classes many complex taint flow behavior typically a human must search the application for calls to potentially important library methods and then manually write specifications for these methods even large contain of library method calls but most of them are irrelevant to finding taint flows our experience is likely representative over a one year period spent analyzing potential we have written specifications for just library classes and we continue to find important new specifications missing specifications can cause false in the static analysis for example suppose we remove the library specification for from figure then the static analysis cannot find the flow from loc to since the taint path between them is broken causing a false negative unlike false positives where the has a list of flows to in detail false are difficult to track that a tool has not produced a false negative such as the missing flow from loc to may require examining every library method call made by the application intuitively the visible application code contains useful information about the correct specifications for the library methods for example if we remove the specification for then there is still a flow from the loc to and a flow from to however and are no longer aliased so the flow is broken only one additional assumption ie that is aliased with is needed to complete the flow this example an approach to specification inference that searches for specifications that complete broken flows our approach proceeds in two steps first our tool finds potential flows by making worstcase assumptions about the missing specifications second for each potential flow our tool keeps track of which assumptions are sufficient to prove that the potential flow is a true flow which we call sufficient assumptions for the potential flow finally the tool proposes that these sufficient assumptions are true these assumptions correspond to specifications that are the inferred specifications produced by the tool our example our tool would find a potential flow from loc to by making worstcase assumptions about the specification for which includes introducing aliasing between and this specification for is a sufficient assumption for the potential flow from loc to so it is inferred by our tool upon this inferred specification the human can that it is correct and thereby determine that the potential flow is a true flow in practice there may be multiple sufficient assumptions for each potential flow our tool keeps track of a minimal set of sufficient it looks for flows that are broken in the places possible the principle is that potential flows that require fewer assumptions are more likely to be real flows than potential flows that require more assumptions by extension potential flows that produce the inferred specifications are most likely to be correct and should be checked first by an we use interprocedural taint analysis to and validate our general framework taint analysis is a example of a program analysis that can be expressed as a cfl reachability problem and has many practical applications furthermore it is built on top of pointsto analysis which is a key part of many interprocedural program analyses one of our goals is to infer aliasing relationships potentially introduced by library methods that are missing specifications cfl reachability for explicit taint flows in this section we present a static analysis for finding explicit taint flows and illustrate it using the example in section our analysis performs cfl reachability on the portion of the code that is available and uses specifications for the portion of the code that is the specifications are usually manually generated for example by a human our understanding is that many practical systems have this design and we do not claim that it is novel however as far as we know this approach is not in the literature so we describe it in some detail in section we generalize this analysis to one where some specifications in addition to the code are also for example because the has only produced partial specifications and the task is to infer the possible missing specifications let c u p t be a contextfree grammar cfg where u is the set of nonterminals is the set of terminals p is the set of productions and t is the start symbol we assume c is normalized so that every production has at most two symbols on the righthand side we write a where a is a nonterminal and is a string of terminals and nonterminals if can be derived from a let g be a directed graph such that the edges v v in g are labeled with terminal symbols a path v v g is a sequence of edges v w k v such that k the transitive closure of g under c is the graph gc such that v a v gc if and only if there exists v v g such that a if v t v we say v is from v definition given a cfg c a graph g v e and subsets of vertices v the cfl reachability problem is to determine whether there exist v and v such that v is from v typically a program analysis as a cfl reachability problem involves converting the input program into a graph g v e and a cfg c and then solving the cfl reachability problem for c and g for some given sets of sources and v this problem can be solved by finding the closure of g under c using a dynamic programming algorithm explicit taint flows we now describe a standard flow and explicit taint analysis explicit taint analysis only tracks taint through data it follows data as it is copied in the course of program execution we defer discussion of implicit flows where the information depends on control flow decisions to section as a part of the explicit taint analysis we perform pointsto analysis to find taint flows due to aliasing for java pointsto analysis can be expressed as a cfl reachability problem we extend the pointsto analysis to a taint analysis by including source and sink edges that pass taint into and out of the system a set of taint specifications s consists of three relations the source specifications the sink specifications and the flow specifications v here v v g are formal method parameters or return values and l is a label representing a taint source or a sink the relations have the following semantics · says v is with source · says v is passed to sink and · v says that any taint on v flows to v given a program p the taint graph for p is g v e where v l here o is the set of abstract objects in the program each of which uniquely corresponds to an object allocation site u denotes the programs set of reference variables and l is the set of labels introduced above figure gives rules for generating an initial set of edges for the graph rules handle primitive forms of statements rule says that the contents of the abstract object o flow to the reference v on the lefthand side of the assignment more formally v may point to o rule similarly encodes the flow when a reference variable v is assigned to another reference variable u rules and record the flows induced by field writes or puts and field reads or gets respectively note that there is a distinct operation for each field f rules formalize the description of the taint specifications s given above rule symbol says that a source a reference variable rule symbol says that the contents of a reference variable flow to a particular sink and rule symbol says that the contents of one reference variable flow to another reference variable rules and are technical devices intuitively rule ensures at least one abstract object flows to the target reference variable of any flow specification which eliminates the need to include alias specifications for every method allocating a return value rule is discussed further in section finally rule allows us to express paths with backwards edges by introducing a label to represent the reversal of an edge labeled we handle interprocedural taint flow as follows arguments passed by the caller are assigned to formal parameters which are assigned to the corresponding references in the callee values returned by the callee are assigned to a formal return value which is assigned to the corresponding reference in the caller vertices representing formal parameters and formal return values are added to g by the analysis for example assign assign and assign assign this indirection ensures that method boundaries are clear figure shows the taint graph generated from the code in figure and the specifications in figure using the rules in figure for clarity we have not included formal parameters and formal return values in the graph but have assigned caller arguments directly to the corresponding callee references and callee return values directly to corresponding caller reference the graph describes the explicit flows in the program for example the edges assign list assign capture the fact that any value stored in the list through the method can potentially be the result of the method more precisely the middle two edges show that the reference list the receiver of and the receiver of all potentially point to the same abstract object the next step is to identify the paths through the graph that correspond to explicit taint flows which we specify using the cfg defined as follows with f denoting the set of fields in p taint new assign f f f f we also include symbols and a in taint and respectively the start symbol of is the source vertices we consider are the taint source labels ie and the sink vertices we consider are the sink labels ie the productions are shown in figure rules build the pointsto relation o v which means that the reference variable v u may point to the abstract object o o for example because figure contains the path rule adds edge here and are the abstract objects allocated to and list respectively then we have path therefore rule adds which causes rule to add this means that and may point to the same abstract object ie and are aliased the backwards edge in the example path above is added by rule which introduces a edge v a v for every nonterminal edge v a v in this way rule plays the same role for nonterminal edges that rule plays for terminal edges note that the forward edge arises from the path of terminal edges new list assign and the application of rule followed by rule implicit library taint flows because and can point to the same object if one of them is then the other should be as well x o new v uv v assign u v u v u s v s v v s v v v v s new v v v v v where figure program fact extraction rules for taint analysis in rule is a fresh vertex new assign a a where a a figure productions for instead of keeping track of taint on the reference variables it is simpler to keep track of taint on the objects in figure rule adds the edge loc which says that is for this taint to flow to the sink the analysis must be able to pass the taint to the object allocated to but here we a problem there is no explicit flow through because no data is copied from the input to the output of the method instead there is an implicit flow through a sequence of converting in the double value to characters in the string that is information still flows from the input to the output of the method but through control flow decisions rather than through explicit data flow implicit flows are much more difficult to analyze precisely than explicit flows because it is much harder to avoid far too much of the program when analyzing implicit flows another way to handle implicit flows is to use explicit taint analysis but include appropriate specifications for methods that have implicit flows we consider the set of specifications that pass taint from one argument to another argument or to the return value in our specification s this behavior is described by the relation v where v v is a library method parameter and v v is a library method parameter or return value such specifications require rule from figure which adds objects to the graph recall that we taint to objects not references thus no taint can flow to parts of the code that have no objects associated with them if a library method does not have an alias specification then the method will have no object associated with its return value rather than manually add alias specifications for every method with a return object rule in figure automatically adds a fresh abstract object that the return value points to for example rule adds new causing rule to add figure the taint graph g corresponding to the code in figure and the library specifications in figure edges are facts extracted from the code in figure backwards edges added by rule are not shown dotted edges are facts extracted from the library specifications in figure edges corresponding to alias specifications are boxed in a red line and edges corresponding to flow specifications are boxed in a dashed blue line dashed edges are edges added by productions in figure not all such edges are shown now we can capture the flow in figure in figure we have the path loc o rule adds the edge loc now we have loc so rule adds the edge loc problem statement in this section we formulate the problem of performing a sound and precise cfl reachability analysis when some specifications are missing along with the problem of inferring the missing specifications our formulation extends the framework defined in section missing specifications cfl reachability suppose we want to perform a cfl reachability analysis on a program p assume g v e is the graph constructed from p with complete specifications if specifications are missing then the constructed graph g v e may be missing vertices and edges ie v v and e e the goal is to perform a sound and precise worstcase analysis given some information about the missing vertices and edges we encode the possible missing data as a family of graphs g where we only know that g g definition suppose we are given g v e a set of sources v a set of v along with some family g of graphs such that for each g g g is a subgraph of g ie g g we call g a completion of g let a × bool be the result of a static analysis where av v true indicates that taint flows from v to v class list void arg arg arg figure an alternative and incorrect specification for · a is sound if for every v and v av v false if and only if there does not exist any g g such that v t v gc · a is precise if for every v and v av v true if and only if there exists g g such that v t v gc the idea behind this definition is that an analysis is sound if it does not miss any taint flow present in at least one of the possible completions of g and the algorithm is precise if it does not report any flows that do not occur in any completion of g an analysis a solves the missing specifications cfl reachability problem for a family g if it is both sound and precise while definition captures the notion of performing a worst case analysis that is sound and precise we are also interested in keeping track of the assumptions that the worstcase analysis makes about missing specifications in practice many assumptions may produce the same results therefore we are interested in producing a minimal set of assumptions suppose we have a partial order g where g g should mean that the graph g makes at most as many assumptions as g the definition of depends on the family g in addition to producing sound and precise results a we would like to produce a minimal g g with respect to such that performing the cfl reachability analysis on g yields a definition suppose we are given the inputs as in tion along with a partial order g we use the notation e g this expression evaluates to true if e g and false otherwise the cfl reachability specification inference problem is to produce sound and precise results a along with sufficient assumptions en coded as a graph g g satisfying av v v t v gc for every v and v furthermore we require that g is minimal ie there does not exist sufficient assumptions g g such that g g in the remainder of this section we describe how we apply this framework to inferring alias and flow specifications g using regular languages to design an algorithm for solving a missing specifications cfl reachability problem we must first specify the family g of graphs to which g may belong our goal is to define a family g that is simultaneously general precision in practice and admits efficient algorithms we our presentation to inferring specifications for missing methods this restriction is without loss of generality and is done to simplify notation and discussion throughout the rest of the paper one restriction we do make is that inferred specifications do not access static fields our algorithms in fact work without this restriction but the results are almost always not useful it is easy to see why if there are at least two missing methods that can access static fields it is possible for one to store a value in a static field and the other to read it whether or not these methods have anything else to do with each other furthermore specifications involving static fields are none of the specifications we have manually written have involved static fields consider the taint graph g in figure suppose the specification for the method in figure is missing so the edge in figure is missing giving us the graph g without access to static fields the only way to complete a flow through g is if there is a path connecting to in general for a method m the only possible taint flows through m are from a parameter of m to ms return value or from one parameter to another parameter we use vm v to denote the vertices of g corresponding to the formal parameters and return value of m to be sound we must assume that the specification of could execute any sequence of operations in other words g con of g with some additional subgraph connecting to note that for any subgraph corresponding to a possible specification of behavior the only information relevant to the cfl reachability problem is the possible sequences of terminals that can occur along paths generalizing from this example for a missing method m it suffices to consider the family of graphs g consisting of all graphs containing g as a subgraph with additional paths w w where w w vm for example one completion of g is the taint graph g in figure which is just g with the edge added back in but there are other ways to complete g even for this simple example consider the graph g obtained when the specification for is given in figure then g is g with the additional path in general there may be infinitely many possible paths because the sequence of operations can be arbitrarily long thus we need some compact way to represent an infinite language of strings the regular languages are a natural choice this discussion our definition of the family definition let w v and let r be a regular language over the family of graphs contains the graph g if · gg · if w w w then the nondeterministic finite automaton nfa n with the transition matrix given by the subgraph satisfies ln lr here is the subgraph connecting w to w not including w or w this definition exploits the insight that we can think of the subgraph as the transition graph of an nfa n with start state w and final state w any path w w satisfies ln conversely for any ln there exists a path w w in general choosing r will produce sound results since this choice imposes no constraints on the allowed paths connecting w and w in practice a more restrictive language may be chosen either to incorporate known constraints on potential specifications or to some soundness for improved scalability inferring specifications for we now formulate the corresponding missing specifications problem our goal is to infer specifications of the following form there exists a path or set of paths connecting w and w as discussed above both alias and flow specifications can be described in this manner we need to define a partial order on that captures the notion of making minimal assumptions about missing specifications because we are searching for paths it is natural to define in terms of paths through g to simplify notation we assume there is a single source and a single sink ie and let p g g t denote the set of all possible paths in g we define the weight of a path p pg to be times p passes through ww w in other words the weight of a path p equals the number of assumptions used along p note that if an assumption is used multiple times ie p passes through multiple times then each use is counted separately define the weight of g to be the minimum weight of any path in g arg now define g g if in other words we want to find g with the path of lowest weight in section we show how to reduce this problem to the cfl reachability problem we are interested in inferring both flow and alias specifications let vm rm where is the set of formal parameters of a method m and rm is the formal return value of m first we infer missing flow specifications ie specifications v which describe implicit taint flows through library methods w w w and w vm for example we could use the family g to infer the tion for if it were missing second we infer missing alias specifications which describe alias relations potentially introduced by calls to methods such as and w w w w vm assign assign new assign ff ff new assign ff ff assign assign the possible sequences of operations are by assign assign because allocation and field access operations cannot be performed on formal parameters and formal return values since they are added to g by the static analysis and do not correspond to references in the program as described in section algorithms for specification inference in this section we present an algorithm that solves the missing specifications problem stated in definition for next we discuss an optimization that enables our algorithm to scale to large programs finally we describe how to extend the algorithm to solve the specification inference problem stated in definition by using a extension of the cfl reachability algorithm this allows us to construct an algorithm that with a human to produce results that are sound and precise with respect to g an overview of our system is given in figure algorithms for consider w w w recall that every potential path w w satisfies lr to be sound and precise with respect to it suffices to construct a subgraph connecting w and w such that there is a path w w through this subgraph if and only if lr the subgraphs that satisfy this property are the transition graphs for nondeterministic finite automata that accept lr for every w w w algorithm constructs the transition graph n s r f for one such nfa and then adds this transition graph to g to connect w to w resulting in graph g finally we compute figure an overview of our specification inference system the system infers specifications s and proposes them to the oracle o ie the human who the proposals and generates a new set of specifications then s s and the process program fact extraction is described in section while not depicted here c may depend on p the graph transformation and cfg transformation are computed by algorithm the cfl reachability algorithm is described in section and appendix a the specification refinement loop is performed by algorithm n v v v v for all n v rr v n v r t n t r v n v rr v n v r v n v r v n v r v v t n t r t t v figure given v r v n constructs the transition graph for a nfa that accepts r with start state v and final state v in rules and t is a fresh vertex the transitive closure g c of g with respect to the contextfree language c the following correctness result follows from the correspondence between lr and n s r f described above theorem algorithm is sound and precise for optimizations consider the subgraph gi n si r fi constructed by algorithm for a pair wi wi w where i is an index over pairs wi wi one issue scaling algorithm is that the cfl reachability algorithm may add a large number of edges that are only among the vertices within gi any such internal edge ni a mi where ni and mi are vertices in gi is added whenever there is a path ni mi gi such that a the problem is that the subgraphs gi are all the same edges are many times by the standard cfl reachability algorithm this observation suggests that we can benefit from the internal edges one convenient way to implement this optimization is to the grammar c instead of adding graphs to g that is we embed an optimized version of gi in c since the graphs gi are all isomorphic to one another this embedding only needs to be performed once intuitively such an transformation is possible because gi encodes a regular language and c is contextfree the essential idea is that for every wi wi w we replace gi by a single vertex because we are only interested in algorithm a sound and precise algorithm for here n s r f is defined in figure function g w r v v return v t v w rc end function function w r g g for all w w w do s and f are fresh vertices g g w s f w n s r f end for return g end function the transitive closure of gi with respect to c we only need one vertex to represent the net effect of gi though this vertex may have many edges more specifically we modify g in the following ways to define a new graph g · we add a new vertex vi to g here the single vertex vi will represent gi · we add two new distinct terminal symbols b and e to for beginning gi at wi and gi at wi respectively these terminals are needed to mark in the modified grammar where we enter and exit gi · we add the edges wi b vi e wi to g we now turn to the transitions of each gi into c defining a new grammar c let ni mi and ri denote vertices in gi corresponding to nfa states n m and r respectively let v v recall that v is the set of vertices of all the vertices not in any gi finally g is the graph constructed by algorithm we want c and c to correspond in the following way if there is an edge v a ni g c then there should be an edge v an vi gc intuitively the nonterminal an records that a was matched ending at the vertex in gi corresponding to state n if there is an edge ni a v g c then there should be an edge vi an v gc intuitively the nonterminal an records that a was matched starting at the vertex in gi corresponding to state n if there is an edge ni a mj g c that is not an internal edge then there should be an edge vi vj gc intuitively the nonterminal records that a was matched starting at the vertex in gi corresponding to state n and ending at the vertex in gj corresponding to state m finally we need to define the productions for each of the additional nonterminals so that conditions above are satisfied we generate these additional productions of c from the productions in c and the of gi using the rules in figure in the figure we refer to vertices si and fi in gi introduced by algorithm which correspond to the start state s and end state e of the nfa respectively we briefly explain rules af the rules for nonterminals of the form an for producing productions of c in figure rules af and ah are similar a suppose we have edge v a wi g c because we have edge wi si g we produce v a si g c in gc we productions for an a as ab c b si a ni an b c c ni mi am an c productions for an a af ea c b ni a fi an e c c mi ni am an c productions for a ans c b c c ni mi c d mi ni arm c productions a a af e c b a c c a bd c a c d a b c an bn c e a bd c an c a bd c f ni d mi am bn c d a b c an bn c e a bd c an c a bd c f mi b am ni dn e a b c c f a bd c c a bd c g ni d mi arm c a bd c h mi b ni c d a bd c an c e a bd c an dm c f a bd c c figure productions for c algorithm optimized algorithm for here t gi c applies the rules in figure to c for the given graph gi also s and f are fresh vertices function g w r v v gi n s r f c t gi c return v t v w c end function function w gg for all w w w do v is a fresh vertex g g w b v v e w end for return g end function rule f n rule f rules e f n rule f n rule e figure examples of production rules added by figure along with the rules that generate them figure algorithm adds the dashed edges to figure if the specification for is missing we only show edges relevant to the production of the edge labeled have edges v a wi b vi and we need to produce v as vi this is achieved by the production as ab c b suppose we have internal edge si a ni because we have edge wi si g we produce wi a ni g c in gc we have edge wi b vi and we need to produce wi an vi this is achieved by the production an b c c suppose we have internal edge ni mi and edge v a ni g c then we produce v a mi g c in gc we have edge v an vi and we need to produce v am vi this is achieved by the production am an c d suppose we have edge v b ni g c and production a b c then we produce v a ni g c in gc we have edge v bn vi and we need to produce v an vi this is achieved by the production an bn c e suppose we have edges v b v d ni g c and production a bd c then we produce v a ni g c in gc we have edges v b v dn vi and we need to produce v an vi this is achieved by the production an c f suppose we have edge v b ni g c internal edge ni d mi and production a bd c then we produce v a mi g c in gc we have edge v bn vi and we need to produce v am vi this is achieved by the production am bn c note that cases e and f correspond to two possibilities for binary productions e handling the case where one edge is fully outside of gi and f handling the case where one edge is fully inside gi in the case where only the middle vertex is in gi and both are outside then we need the production c in figure we describe productions a b and c a suppose we have edge v a fi g c because we have edge fi wi g we produce v a wi g c in gc we have edges v af vi e wi and we need to produce v a wi this is achieved by the production a af e c b suppose we have edge si a v g c because we have edge wi si g we produce wi a v g c in gc we have edges wi b vi as v and we need to produce wi a v this is achieved by the production a c c suppose we have edges v b ni d v g c and production a bd c then we produce v a v g c in gc we have edges v bn vi dn v and we need to produce v a v this is achieved by the production a the productions d e and f are similar to c finally we show that the rules given in figure are complete as above we focus on rules af first note that we need to add an edge v an vi whenever there exists a path v wi and there exists such that a and si ni gi in other words is the portion of the path in g and is the portion of the path in gi and the path ends at vertex ni gi consider the production that is the first step in the derivation of a · case a then so v wi and we need to add edge wi an vi the fact that also implies that a so si a ni hence this case is handled by rule b · case a bd either is a prefix of bd and is a suffix of d handled by rule e or is a prefix of b and is a suffix of bd handled by rule f · case a b then is a prefix of b and is a suffix of b so this case is handled by rule d rule a is added to satisfy the semantics of the symbol b finally we have to consider transitions that occur in ie ni mi these transitions are used in conjunction with the implicit productions a a and a a these transitions are handled by rule c rules af and ah follow similarly next we show that rules af are complete note that we need to add an edge v a v whenever there exist paths v wi and wi v and there exists lr such that a here and are the portions of the path in g and is the portion of the path in gi as before we can consider production that is the first step in the derivation of a this time we only need to handle the case where the production is split at vertex a bd where b and d and this is handled by rule c rules df follow similarly when considering productions for an an and finally the semantics of the symbols b and e are handled by rules b and a respectively while we only described the case where the path passes through a single pair wi wi the general case follows because the first step in the derivation can be split only at a single vertex vi we denote the subroutine constructing c by t ie c t gi c note that any gi can be used since gi and hence is the same for every wi wi w algorithm calls t to obtain a new grammar c it then computes the transitive closure gc we have the following correctness result theorem algorithm is sound and precise for we briefly discuss the complexity of algorithm the rules in figure are not recursive so the number of productions in c is a constant multiple of the number of productions in c similarly the graph g constructed by algorithm is a constant of the size of g the complexity of algorithm is dominated by the complexity of computing the transitive closure gc this is where g is the number of vertices in g and c is the number of terminals and nonterminals in c as an example consider g defined in section let pt new assign f f as before we include symbols in pt recall that assign assign then n s f produces the transition graph for the nfa n s n f s f where n s assign n s assign n n for all pt f assign n and f assign n productions for and n f f are shown in figure consider the code in figure and suppose the specification for is missing so in figure we show the following edges that are added by algorithm this edge represents two edges is added by b rule a and is added by rule f because assign this edge is added by n rule f because this edge represents two edges is added by e rule a and is added by rule f because assign this edge is added by n rule c because we have used the production that comes from normalizing the cfg once algorithm adds the edge it will add the edge loc as a consequence of the productions in interactive refinement we extend algorithm to find sufficient assumptions for the edge e t recall that sufficient assumptions are encoded as graphs g such that e gc if algorithm does not produce any edge e then we simply return g otherwise we record the inputs for each edge produced by algorithm when computing the closure gc recursively searching through the inputs of e we a path p such that t we record the index of every pair of edges wi b vi e wi that occurs along p which we denote by i then we add the corresponding graphs gi n si r fi to g ie g g gi i i the resulting graph g has the desired property e gc there may exist multiple paths p such that t each of which may yield different sufficient assumptions g we further extend algorithm to find minimal sufficient as g for e recall that this corresponds to ie finding g with path p of min to do so we define a weight function on by setting other this extends to and weight for by setting all k i note that for path p pg weight consider the following definition let g be the graph defined above the cfl reachability problem is to return the shortest path p arg weight or return if pg knuth describes a generalization of algorithm to find the shortest string in a contextfree grammar this algorithm generalizes to solving the cfl reachability problem we replace the worklist of edges in with a heap of edges where the priority of an edge is the weight of its shortest path see algorithm in appendix a for details by using algorithm to compute the closure gc we find the path p pg algorithm iterative refinement of results here s and f are fresh vertices function g w r v v o gi n s r f c t gi c repeat g w p g v t v for all w b v e w p do g g ow w w w w w end for until v t v gc or return v t v gc end function that passes through the possible edges w b v e w then the sufficient assumptions g constructed from p has minimum weight finally we describe an algorithm for refining the static analysis results with the help of an recall that the graph g is missing some vertices and edges from g suppose we can query an oracle to obtain information about g definition we say o is an oracle for g if for every w w w ow w gw w we use a human as an oracle o on input w w the the library documentation and return the true specification gw w the problem is to produce static analysis results that are sound and precise with respect to g while making as few queries ow w as possible algorithm solves this problem it obtains the shortest path p pg for the edge e t by calling p g e then the algorithm replaces every edge w b v e w in p with ow w algorithm this process until either or until pg in the former case the path p does not contain any symbols b or e ie p does not pass through any potentially missing specifications this proves that p g ie e gc gc in the latter case because algorithm is sound it only returns p if there does not exist any g such that e g since we have assumed that g this proves that e gc therefore theorem algorithm computes t gc implementation we have implemented the system described in figure for java and specifically for the framework a number of extensions are required beyond the we have described but these extensions do not introduce any new ideas for example we include rules for primitive variables that are essentially rules for reference variables without fields our current implementation does not consider specifications involving static fields as discussed in section in our experience such specifications lead to many false positives as there are few constraints on the possible flows between static variables and in practice there are few flows among them prior to this work we had manually written many specifications over a period of more than one year these specifications s cover library classes including a number of taint sources location device id sim data and data and a number of network messages and user settings modifications this also includes specifications for important container objects including spec type total correct specifications proposed total specifications proposed overall accuracy average specifications proposed accuracy of random sample flow alias na figure statistics on inferred library specifications and since our focus in on the long tail of missing specifications we our implementation of the specification inference framework with these specifications in our implementation program fact extraction is performed using the platform modified to work with the intermediate representation provided by in order to improve precision of our analysis we extend the pointsto rules rules in figure so that they are context precisely we use a cfa pointsto analysis additionally because java is type safe we use type filters in the pointsto analysis ie a reference of type t can only point to an object of type t if t is a subtype of t our solver detects and pointsto edges that are not consistent with the type constraints of the program our cfl solver is based on the cfl solver in modified with the algorithm from to compute shortest paths details are given in appendix a within our specification inference framework we implement both flow and alias specifications for each inferred specification we manually reference the library documentation to determine if the specification is correct and the analysis with the updated specifications we repeat this process until no new specifications are inferred when inferring alias specifications the large size of the sound pointsto analysis makes it difficult to scale the inference algorithm we implemented a demanddriven optimization first we perform the entire analysis using as the solver however cannot compute shortest paths instead we use the results from to irrelevant edges ie edges that do not contribute to a path from g finally we the analysis using our cfl solver we would infer alias and flow specifications simultaneously however worstcase flow specifications introduce a large number of incorrect taint flows causing the demanddriven optimization to fail to eliminate enough edges for the specification inference algorithm to scale for some benchmarks as a result we perform the two analyses separately in our experiments nevertheless inferring alias specifications alone is already sufficient to be sound with respect to finding explicit taint flows experimental results we ran our tool on a of our results are for the optimized version of our specification inference algorithm ie algorithm since preliminary experiments with algorithm did not scale even to of size the running time for one iteration of algorithm is in figure c the flow specification inference algorithm ran on all running in fewer than seconds per iteration on average for most which is fast enough to allow a human to run the analysis the alias specification inference algorithm successfully ran on the worstcase assumptions cause a substantial increase in the pointsto relation size see figure d which proved to be too large on the remaining still inferring alias specifications runs in under seconds for most with up to lines of code app name browser cb ed loc spec critical spec total spec accuracy na na na na na na flows run time s spec type flow flow flow flow flow flow flow flow flow flow alias alias alias alias alias alias alias alias alias alias figure specification inference results on large critical specifications are both correct and lie along a true path total specifications is the number of worstcase specifications is the number of iterations in algorithm accuracy is the of proposed specifications that are correct and flows is the number of new flows discovered accuracy is na if no specifications are inferred class method signature int double void specification this return arg return this return this return arg this spec type flow flow alias alias alias figure sample of inferred specifications specification is the pair w w w returned by algorithm results for selected including the largest four that ran successfully for each analysis are shown in figure we show the number of specifications proposed by our tool spec along with the number of worstcase specifications total spec our tool may propose specifications that are correct ie represent valid paths library methods but do not contribute to a correct path in the program therefore we also show the number of specifications that are both correct and contribute to a true flow critical spec which is a lower bound for the number of specifications proposed we call such specifications critical specifications because they are the specifications that an must examine in order to find all flows the number of inferred specifications is as black in figure a and b along with the number of inferred specifications that are correct as red and the number of critical specifications as blue for readability a is a and the of b is the accuracy of the specifications are shown in figure note that the accuracy is directly with the manual required by the oracle higher accuracy means that the oracle will have to examine fewer incorrect specifications specification inference accuracy our first experiment demonstrates the accuracy of the specifications inferred for each app we ran our inference algorithm with the specifications s the inferred alias specifications are very accurate in part because of type filters we show some examples of inferred specifications in figure we compare our results to randomly chosen specifications we randomly chose possible flow specifications in the following way randomly choose a method randomly choose a pair of formal parameters v and v or a formal parameter v and the formal return value v and propose the flow specification v v the accuracy of a specification randomly chosen in this way is only whereas the overall accuracy of the specifications inferred by our tool is the number of specifications proposed which grows roughly linearly with app size is very it is usually a small multiple of the number of critical specifications for alias specification inference each app produced fewer than proposals each of which could be checked in under a significantly more flow specifications are inferred but these are even faster to check all but five of the required fewer than proposals in total the tool discover of new specifications and flows a task that we estimate would have taken without the tool specification our second experiment demonstrates how our tool can be used to quickly build a useful collection of library specifications consider analyzing the in some arbitrary order and specifications along the way that is the ith app is analyzed using all of the correct specifications discovered in analyzing the first i intuitively the most frequently used methods should have their specifications discovered relatively early in the process and we should subsequently benefit from already having those specifications and not to infer them again figure e shows the of new specifications proposed by algorithm with to the number of specifications proposed when algorithm starts from the the red series shows for each app the percentage of new a b c d e f figure for a flow and b alias specifications proposed black correct red and critical blue c run time of the flow black and alias red specification inference algorithms d ratio of worstcase pointsto relation size to known pointsto relation size e ratio of specifications with to specifications from over random orders black line and for two different random orders red blue f of common specifications proposed for c black blue dashed and red dotted over random orders tions that the must examine after the th app more than of the needed specifications are already known and for many no new specifications are needed the blue series shows the same effect from processing the in a different random order the black line shows the average number of new specifications over such runs varying the order of the each time as can be seen the for a new app with approaches about of that without the red and blue series give a sense of the considerable variance but the overall is clear regardless of chosen order the of new specifications quickly becomes small and the only does a fraction of the work compared to starting from the the required work would drop further after processing more figure f shows the of common specifications that are identified after analyzing each number of we say a specification is common if it is proposed by the tool for at least c in this graph the black curve corresponds to c the blue dashed curve corresponds to c and the red dotted curve corresponds to c each line shows the average over random permutations the tool quickly up a large fraction of the common specifications reaching more than after just a of the have been analyzed in the case c verification we ran algorithm to termination ie until no new specifications for missing parts of the program could add any more taint flows which means that the remaining taint flows all occur in the original graph g in the case of alias inference this also proves that no additional explicit taint flows can occur figure b shows the number of specifications that had to be checked by an to completely verify the absence of explicit taint flows in an app this number is very reasonable at most showing that the tool makes verification of large practical in the case of flow specification inference taint flows due to missing alias specifications can still occur and verification requires that the supply all relevant alias specifications in practice this analysis still many library methods that need alias specifications since taint often flows through these methods thus our tool finds many taint flows even if alias specifications are missing there are currently two primary limitations to our tool one we have already discussed inferring both alias and flow specifications simultaneously is too expensive for our tool on some the second is that while we can infer missing flow and alias specifications we still require a complete list of the possible sources and in the program to be able to find flows at all while manually annotating sources and is a much easier problem by orders of magnitude than finding flows it would still be useful to consider how to provide automatic in discovering sources and in large as can be seen from the total number of potential specifications shown in figure without our tool an would have to examine a number of potential specifications even if many of these can be easily eliminated our experience has been that without the aid of our tool performing verification on can take or even and performing verification on large is almost impossible related work sound analysis with missing specifications there has been previous work that shares our goal of inferring specifications for verification based on inference there are several differences in the two approaches first we handle the general class of cfl reachability problems whereas addresses standard graph reachability problems second inference is a very general tool and solving inference problems is nphard our algorithm which is to specification inference runs in polynomial time as a result our system appears to scale considerably better and we are able to a much larger experiment on many more than there has also been prior work on sound call graph generation their work constructs a library that every possible behavior that can affect the call graph our technique in addition to being more general actually proposes library specifications and allows an to refine analysis results specification inference there has been work using data to infer specifications several of these techniques use dynamic traces to propose specifications while others apply domain knowledge and statically infer specifications from the source code our tool differs in that it applies to cfl reachability problems furthermore our tool produces sound results which enables interactive verification cfl reachability for program analyses a large number of program analyses have been expressed as cfl reachability problems for example pointsto analysis many set constraint problems various interprocedural analyses and type qualifier inference our work makes these techniques more applicable for analysis by providing a practical and sound approach to dealing with missing or portions of the program our work makes use of ideas for combining contextfree reachability with additional regular language properties such as applications of program analysis to security work on taint analysis for includes which statically tracks taint flows between applications which is a dynamic system that performs real time monitoring and which uses static analysis to find information leaks static analysis has also been applied to finding in web applications algorithm algorithm for computing cfl reachability function c e gc graph i map h heap for all v v g do v weight iv v end for while do v a v gc gc v a v for all d ab c do for all v b v gc do b v if d v then d v iv d v v a v v b v end if end for end for for all d ba c do for all v b v gc do b if d v then d v iv d v v b v v a v end if end for end for for all b a c do if b v then b v iv b v v a v end if end for end while if e i then return e end if return end function function e if ie then return e end if e ek ie return end function conclusions we have developed a general framework that applies to any program analysis formulated as a cfl reachability problem our framework allows us to perform a sound analysis by inferring missing specifications and furthermore allows an to refine the results we have demonstrated the quality of the specifications inferred by our tool on a of realworld our results show that our tool can both help build large collections of specifications very efficiently and make it practical for an to perform verification a cfl reachability the algorithm in algorithm generalizes algorithm for finding shortest strings in to computing cfl reachability essentially algorithm builds on an algorithm for determining emptiness of a contextfree grammar it adds a heap that keeps track of the shortest sequence of terminals that can be derived from each nonterminal symbol similarly algorithm generalizes the algorithm for computing cfl reachability described in in the arrays are denoted as x xk and addition of arrays is defined to be x xk y x xk y we introduce a heap h that keeps track of the shortest path for each edge v a v the current priority of the edge v a v is the length of the current shortest path if a path is found then the heap is updated with the new path and the new priority at every iteration of the algorithm the lowest priority edge v a v with priority is removed from the heap added to gc and then processed note that once this happens there can be no way of producing v a v with lower priority every subsequent edge removed from h must have priority at least so any edge produced while processing such an edge must also have priority at least since every possible way of producing v a v is considered the shortest path is correctly identified the heap h supports the following operations updates the priority of edge e and adds e to h if e h empty returns true if the heap contains no edges returns the current priority of edge e and removes the lowest priority element in the heap and returns it along with its current priority we assume that priority returns for edges not yet added to h and for edges already removed from h the complexity of algorithm is g log c because of the additional cost of updating the heap as before g is the number of vertices in g and c is the number of terminals and nonterminals in c the shortest path itself is stored in a map i which keeps track of the edges e ek where k used to produce v a v the shortest path itself is by recursively the shortest path for each edge in iv a v algorithm does not handle edges labeled with the empty string or productions a in order to handle the former our solver introduces a fresh terminal symbol replaces every edge v v with v v and adds productions a a and a a for every nonterminal a in the input grammar the latter is handled by adding self loops v a v for every v v and every a u such that a c see acknowledgments this material is based on research by the force research laboratory under agreement number fa the us is to and for purposes any copyright notation references a aiken s i t b p an overview of the project in k ali o analysis without the whole program in ecoop r p c p w synthesis of interface specifications for java classes in popl g r j specifications in popl s s c e a j y l d p precise context flow field and taint analysis for in pldi t ball s rajamani the slam project debugging system software via static analysis in popl n a probabilistic modular and scalable inference of typestate specifications in pldi w p b l j p a an informationflow tracking system for realtime privacy monitoring on in a p a j s foster automated security certification of applications in ieee symposium on security and privacy d j s foster type qualifier inference in java in oopsla j a aiken a scalable analysis in sas j a aiken annotated set constraints in pldi j a aiken the set reachability connection in practice in pldi d knuth a generalization of algorithm in information processing letters t p g back a ng d from uncertainty to inferring the specification within in b a v s k rajamani a specification inference for explicit information flow problems in pldi b m s lam finding security in java applications with static analysis in usenix security symposium b m s lam tracking pointers with path and context sensitivity for bug detection in c programs in d t reps of a class of set constraints and contextfree language reachability in theoretical computer science m a aiken j effective static race detection for java in pldi j w m d automatic generation of program specifications in m k a s static specification inference using predicate in pldi t reps program analysis via graph reachability in t reps s horwitz m sagiv precise interprocedural data flow analysis via graph reachability in popl s e s m static specification using abstractions in m d l r demanddriven pointsto analysis for java in oopsla m s m s o r ff taint analysis of web applications in oopsla m r contextsensitive pointsto analysis for java in pldi o m s j m o effective taint analysis of web applications in pldi r p co e l p lam v a java bytecode optimization framework in j m s lam contextsensitive pointer alias analysis using binary decision diagrams in oopsla y a aiken static detection of security in languages in usenix security symposium j yang d d t m temporal api rules from traces in h t i automated inference of library specifications for property verification in 