martin hofmann edit lenses benjamin pierce university of pennsylvania daniel university of pennsylvania abstract a lens is a bidirectional transformation between a pair of connected data structures capable of translating an edit on one structure into an appropriate edit on the other many of lenses have been studied but none to date has a satisfactory treatment of how edits are represented many foundational accounts only consider edits of the form the whole structure leading to behavior in many situations by failing to track the between corresponding parts of the structures when elements are inserted and deleted in ordered lists for example other theories of lenses do maintain these either by annotating the structures themselves with change information or using auxiliary data structures but every theory assumes that the entire original source structure is part of the information passed to the lens we offer a general theory of edit lenses which work with descriptions of changes to structures rather than with the structures themselves we identify a simple notion of set of states plus a monoid of edits with a partial monoid action on the construct a semantic space of lenses between such structures with natural laws their behavior we show how a range of constructions from earlier papers on statebased lenses can be carried out in this space including composition products sums list operations etc further we show how to construct edit lenses for arbitrary containers in the sense of and finally we show that edit lenses refine a wellknown formulation of statebased lenses in the sense that every statebased lens gives rise to an edit lens over structures with a simple edit language and conversely every edit lens on such structures gives rise to a statebased lens categories and subject descriptors d programming languages language application languages general terms design languages theory keywords algebra bidirectional programming edit lens symmetric introduction recent years have seen growing interest in bidirectional programming languages where a program describes how to maintain a connection between data structures of permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm two different shapes translating updates to one structure into appropriate updates to the other the core concepts of bidirectional programming have roots in early work on the database view update problem see for a survey more recently they have been explored in areas including software development data synchronization user interfaces and unix system configuration management the meaning of a bidirectional program connecting a set x to a set y often called a lens from x to y is intuitively a pair of transformations one mapping x updates to y updates and the other mapping y updates to x updates subject to some behavioral laws specifying how the two transformations fit together technically this intuition can be realized in numerous ways a naive definition is to say that a lens from x to y is just a pair of functions f x y how to map an updated x state to an appropriate y state and g y x but this is too simple if the lens laws impose the reasonable requirement that f and g should round then our bidirectional programs will only denote an important but limited special case to allow for situations where each structure can contain a of information that is shared with the other and information that is not something more than just the updated structure must be given as input to the transformations different variants of lenses differ as to what this something more should be we might for example give the transformation from x to y both a new x and an old y ie f x × y y with the intention that f should together the shared information from the new x with the local information from the old y to produce a new y or instead of a whole y we might pass f some smaller structure a complement representing just the information that is needed to build an updated y out of an updated x or perhaps one of these plus some additional information about the alignment of the updated information eg a new element was inserted at the beginning of this list so the second element in the new x corresponds to the first element in the old y either in the form of an auxiliary data structure or perhaps embedded as annotations in the updated x itself what all these variants have in common is that the inputs to a lens always include the whole updated state this leaves an gap between the theory and practical which generally represent updates in some simpler more compact form that only describes what has changed in a possibly large structure in this paper we offer the first foundational treatment of edit that operate directly on edits rather than on whole structures our theory of edit lenses is built from simple and familiar algebraic structures § it supports a wide range of fundamental syntactic products sums list operations us to construct lenses for complex data structures together with appropriate representations for edits in a compositional fashion § indeed the theory includes a general account of how to construct mapping lenses for a wide class of container data structures such as lists and trees § this rich set of syntax constructors should form a suitable basis for the design of new germany a initial ins mod germany b a new is added to one replica ins mod germany c the lens adds the new to the other replica mod italy mod germany italy d the makes some mod germany italy some text e the lens a small edit ins mod ins mod germany italy germany f two different edits with the same effect on the left figure a simple edit lens in action bidirectional languages for example in the style of our theory can support a wide variety of edit languages we mostly concentrate on the simplest form where compound edits are freely generated from some set of atomic edits § considers the extension to richer languages with additional algebraic laws finally our theory generalizes and refines the statebased symmetric lenses of hofmann pierce and in a precise sense § the paper ends with a discussion of related work § and some remarks on future directions § overview before into lets take a brief of the main ideas via some examples figure demonstrates a simple use of edit lenses to two in part a we see the initial which are in a synchronized state on the left the replica is a list of records describing and years on the right a list of records describing the same of origin in part b the user interacting with the lefthand replica to add a new at the end of the list this change is described by the edit script ins mod the script says to first insert a dummy record at index three then modify this record by replacing the left field with and replacing the right field with one could of course imagine other edit languages where the insertion would be done in one step we represent it this way because this is closer to how our generic container mapping combinator in § will do things the lens connecting the two now converts this edit script into a corresponding edit script that adds to the righthand replica shown in part c ins mod note that the translated mod command the name component but leaves the component with its default value this is the best it can do since the edit was in the lefthand replica which doesnt mention later an editor notices the missing information and it in at the same time a error in name as shown in d in part e we see that the lens the information when translating the edit from right to left but propagates the correction of course a particular new replica state can potentially be achieved by many different edits and these edits may be translated differently consider part f of figure where the lefthand replica ends up with a row for at the beginning of the list instead of at the end two edit scripts that achieve this effect are shown the upper script the old record and inserts a new one which happens to have the same data at the top the lower script the order of the list the translation of the upper edit leaves with a default while the lower edit is translated to a preserving all the information associated with we do not address the question of where these edits come from or who in cases like part f which of several possible edits is intended as argued in answers to these questions will tend to be with the of particular editing andor tools and will tend to be heuristic and domainspecific material for a foundational theory rather our aim is to construct a theory that shows how edits however generated can be translated between of different shapes abstractly the lens we are discussing maps between structures of the form x × y and ones of the form x × z where x is the set of names y the set of date strings and z the set of we want to build it is the whole lens should have the form where is a list mapping lens combinator and is a lens for translating edits to a single record ie is a lens from x × y to x × z moreover itself should be built as the product × of a lens x x that translates edits while is a lens that maps every edit on either side to a trivial identity edit on the other side in analogous fashion the edit languages for the toplevel structures will be constructed the set of edits for structures of the form x × y written x × y will be defined together with the list constructor its elements will have the form where i is a position in where i in is a permutation on positions rep we use the word informally to mean simply maintain a correspondence between two by propagating edits in both directions a synchronization tool would also include at a minimum some mechanism for dealing with conflicts between edits to the two structures which is outside the scope of this paper inl inr inr inl a the initial a tagged list of and authors on the left a pair of lists on the right a complement storing just the tags inl inr inr inl ins mod b an element is added to one of the partitions inl inr inr inr inl ins mod c the complement tells how to translate the index figure a lens with complement eg as a branching program and dv where dv x × y is an edit for x × y structures pair edits dv x × y have the form x × y where x is the set of edits to and y is the set of edits to finally both x and y are sets of primitive edits that completely replace one string with another together with an identity edit that does nothing at all so x can be just x with inl and similarly for y and z our lens will consist of two for edits from the left side to the right written x × y x × z and another for edits from right to left written x × z x × y we sometimes need lenses to have a little more structure than this simple example suggests to see why consider defining a partitioning lens p between the sets x y and x figure demonstrates the behavior of this lens in part a we show the original on the left a single list that authors and with tags showing which is which and on the right a pair of lists one for authors and one for now consider an edit as in b that inserts a new element in the author list on the right it is clear that we should this into an insertion on the left replica but where exactly should we insert it if the function is given just an insertion edit for the author list and nothing else there is no way it can translate this edit into a sensible position in the combined list on the left since it doesnt know how the lists of authors and are interleaved on the left the symbol is put an edit through the lens from left to right or just put right it is the of the putr function of the statebased symmetric lenses in and the put function of the statebased asymmetric lenses in the solution is to store a small list called a complement off to the side recording the tags inl or inr from the original list and pass this list as an extra argument to translation we then the types of the edit translation functions to accept a complement and return a new complement so that p x y × c x × y × c and p x × y × c x y × c part c demonstrates the use and update of the complement when translating the insertion note that the complement stores just the tags not the actual names of the authors and in the lefthand list in general the information stored in c will be much smaller than the information in the indeed our earlier example illustrates the common case in which c is the trivial set unit the translation functions manipulate just the and the edits which are also small compared to the size of the edit lenses a key design decision in our formulation of edit lenses is to separate the description of edits from the action of applying an edit to a state this separation is captured by the standard mathematical notions of monoid and monoid action definition a monoid is a triple m m of a set m an associative binary operation m × m m and a unit element m m that is with and m such that x y z x y z and m x x x m when no confusion results we use m to denote both the set and the monoid drop subscripts from · and and write mn for m · n the unit element represents a change nothing edit multiplication of edits corresponds to up multiple edits into a single one representing their combined effects modeling edits as monoid elements gives us great flexibility in concrete representations the simplest edit language is a free monoid whose elements are just words over some set of primitive edits and whose multiplication is concatenation however it may be useful to put more structure on edits either a to allow more compact representations or b to capture the intuition that edits to different parts of a structure do not interfere with each other and can thus be applied in any order we will see an example of b in § for a simple example of a recall from § that for every set x we can form an monoid where the edits are just the elements of x together with a fresh unit edits can be represented as elements of the disjoint union unit x combining two edits in this monoid simply the second unless the first is the unit inl · e e and · e these equations allow this edit language to represent an arbitrarily long sequence of updates using a single element of x and en to recover statebased lenses as a special case of edit monoid framework can also accommodate more abstract notions of edit for example the set of all total functions from a set x to itself forms a monoid where the multiplication operation is function composition this is essentially the form of edits considered by we mostly focus on the simple case where edit languages are free monoids § considers how additional laws can be added to the product and sum lens constructions definition given a monoid m and a set x a monoid action on m and x is a partial function m × x x satisfying two laws x x and m · n x m n x as with monoid multiplication we often the monoid action symbol writing mx for m x in standard mathematical terminology a monoid action in our sense might instead be called a partial monoid action but since we always work with partial actions we find it convenient to drop the qualifier a bit of discussion of is in order multiplication of edits is a total operation given two descriptions of edits we can always find a description of the composite actions of doing both in sequence on the other hand applying an edit to a particular state may sometimes fail this means we need to work with expressions and equations involving partial operations as usual any term that contains an undefined application of an operation to operands is is no way of an equation between possibly undefined terms eg as in the definition above means that if either side is defined then so is the other and their values are equal kleene equality why deal with failure explicitly rather than keeping edit application total and simply defining our monoid actions so that applying an edit in a state where it is not appropriate yields the same state again or perhaps some other state one reason is that it seems natural to directly address the fact that some edits are not applicable in some states and to have a canonical outcome in all such cases a more technical reason is that when we work with monoids with nontrivial equations making edits behave like the identity is actually wrong however although the framework allows for the possibility of edits failing we still want to know that the edits produced by our lenses will never actually fail when applied to replica states arising in practice this requirement corresponding to the totality property of previous of lenses is formalized in theorem in general we adopt the design principle that should be kept to a minimum this simplifies the definitions it is convenient to a particular choice of monoid and monoid action plus an initial element into a single structure definition a module is a tuple x x x a set x an element x a monoid x and a monoid action x of x on x if x is a module we refer to its first component by either x or just x and to its last component by or simple we will use modules to represent the structures connected by lenses before coming to the definition of lenses however we need one last the notion of a stateful homomorphism between monoids as we saw in § there are situations where the information in an edit may be to determine how it should be may need to know something more about how the two structures correspond the exact nature of the extra information needed according to the lens to give lenses a place to store such auxiliary information we follow and allow the components of a lens the and functions to take a complement as an extra input and return an updated complement as an extra output definition given monoids m and n and a complement set c a stateful monoid homomorphism from m to n over c is a function h m × c n × c satisfying two laws hm c n c here is a slightly example suppose that the set of states is natural numbers and that edits have the form x y where the intended interpretation is that if the current state is x then the edit yields state y it is reasonable to impose the equation y z · x y x z allowing us to represent sequences of edits in a compact form but now consider what happens when we apply the edit · to the state the second monoid action law demands that · which by the equation we imposed is the same as but the lefthand side is equal to since the edit does not apply to the state while the righthand side is equal to since the first edit is to the state so it behaves like the identity and returns from which takes us to so the action law is violated hm c n c hm c n c hm m c n n c these are basically just the standard monoid homomorphism laws except that h is given access to some internal state c c that it uses and updates when mapping from m to n in the second law we must thread the state c produced by the first h into the second use of h and we demand that both the result and the effect on the state should be the same whether we send a composite element m · m through h all at once or in two pieces the intended usage of an edit lens is as follows there are two users one holding an element of x the other one an element of y both referred to as initially they hold and respectively and the lens is initialized with complement init the users then perform actions and propagate them across the lens an action consists of producing an edit dx or dy applying it to ones current replica x resp y putting the edit through the lens to obtain an edit dy resp dx and the user on the other side to apply dy dx to their replica in the process the internal state c of the lens is updated to reflect the new correspondence between the two we further assume there is some consistency relation k between x y and c which describes the synchronized states of the and complement this gives us a natural way to state the totality requirement discussed above if we start in a consistent state make a successful edit one that does not fail at the side and put it through the lens the resulting edit is guaranteed a to be applicable on the receiving side and b to lead again to a consistent state we make no guarantees about edits that fail at the side these should not be put through the lens definition a symmetric edit lens between modules x and y consists of a complement set c a distinguished element init c two stateful monoid homomorphisms x × c y × c and y × c x × c and a consistency relation k x × c × y such that · init k · if x c y k and dx x is defined and dx c dy c then dy y is also defined and dx x c dy y k · if x c y k and dy y is defined and dy c dx c then dx x is also defined and dx x c dy y k since symmetric edit lenses are the main topic of this paper we will generally write edit lens or just lens for these additional to talk about other variants such as the statebased symmetric lenses of the intuition about ks role in totality can be formalized as follows definition let x y be a lens a is a sequence of word in x y the partial function run x y x × c × y is defined by run init x c y dx c dy c dx x c dy y x c y dy c dx c dx x c dy y theorem let w be a and suppose that x c particular all the edits in w succeed let dx x be an edit with dx x defined if dy c dx c then dy y is also defined an analogous statement holds for beyond its role in totality the consistency relation in a lens plays two important roles first it is a check on the behavior of and second if we project away the middle component we can present it to programmers as documentation of the synchronized states of the two as a partial specification of and one technical issue arising from the definition of edit lenses is that the hidden cause many important associativity of hold only up to behavioral equivalence this was also observed in § for the case of symmetric statebased lenses and the appropriate behavioral equivalence for edit lenses is a natural refinement of the one used there taking the consistency relations into account definition lens equivalence two lenses k x y are equivalent written k if for all w · is defined iff is defined · if x c y and x d y then x x and y y and · if x c y and x d y and dx x is defined and dx c dy and k dx d dy then dy dy and the analogous property for note that the second clause is actually implied by the third since the of the two lenses in question may not even have the same type it does not make sense to require that they be equal instead the equivalence the relying on the observable effects of the lens actions however by finding a relationship between the we can prove lens equivalence with a proof principle theorem lenses k x y are equivalent iff there exists a relation s x × kc × c × y such that init s if x c d y s and dx x is defined then if dy c k dx c and dy d dx d then dy dy and dx x c d dy y s and analogously for edit lens combinators we have proposed a semantic space of edit lenses and justified its design but the proof of the is in the whether we can actually build primitive lenses and lens combinators that live in this semantic space and that do useful things generic constructions as a first step here is an identity lens that identical structures and maps edits by passing them through unchanged id x x x c unit k x x x x dx dx dx dx here and below we the definition of the init component when c unit since it can only be one thing in lens definitions like this one the upper box serves both as a typing rule and as the implicit statement of a theorem saying that the functions in the box below it the appropriate types and satisfy the corresponding lens laws for lens combinators the definition also makes an implicit statement about compatibility with lens equivalence for brevity and because they are generally straightforward we usually these theorems now for a more interesting case given lenses k and connecting x to y and y to z we can build a composite lens k that x directly to z note how the complement of the composite lens includes a complement from each of the components and how these are through the and operations kx y y z k x z c kc × c init init k x ck c z y x ck y kk y c z k dx ck c let dy ck k dx ck in let dz c dy c in dz ck c dz ck c let dy c dz c in let dx ck k dy ck in dx ck c as might be expected composition of lenses is associative and the identity lens is a unit for composition however as mentioned above we need to be a little careful it is not quite the case that k m k min particular they have different instead what we can show is that k m k m another simple lens combinator is for each lens x y we can construct its dual op y x by and for the next definition observe that the set unit gives rise to a trivial monoid structure and for any given set x and element x x a trivial module with initial element x which we write when context clearly calls for a module we will abbreviate unit unit to simply unit now for each module x there is a terminal lens that x to the trivial unit module by away all edits x unit c unit k x × unit × unit dx the lens that we saw in § can be built from term the term lens is also unique up to equivalence the implementation of is forced by the size of its range monoid unit and the implementation of is forced by the homomorphism laws there is a trivial lens between any two isomorphic modules formally a module homomorphism f h between modules x and y is a function f x y and a monoid homomorphism h x y such and f dx x f x there is an identity x x dx dx for every module and the pointwise composition of module homomorphisms is also a homomorphism so modules form a category if module homomorphisms e g x y and f h y x satisfy e g f h id x and f h e g id y then e g is an isomorphism and f h is inverse to e g now f h x y f h is inverse to f h x y c unit k x f x x x dx dy the fact that this always defines a lens plus a of other easy facts amounts to saying that there is a functor from the category of module isomorphisms to the category of edit lenses generators for free monoids for writing practical lenses we want not only generic combinators like the ones presented above but also more specific lenses for structured data such as products sums and lists we show in the rest of this section how to define simple versions of these constructors whose associated edit monoids are freely generated § shows how to generalize the list mapping lens to other forms of containers and § discusses edit languages with nontrivial laws given a set g we write g for the set of finite sequences of elements of g we write for the empty sequence and g to denote both a generator element and the sequence containing such an element sequence concatenation is denoted by when discussing a sequence g · · · gn we also use g to refer to the entire sequence the notation g means the length of a sequence g · · · gn n it is easy to show that g together with sequence concatenation and forms a monoid it is often convenient to specify the behavior of a monoid homomorphism by giving its output on each generator given a function fg g m on generators the monoid homomorphism f g m is defined by f and f g · · · gn g · · · gn similarly given a stateful function fg g × c m × c we can define a stateful monoid homomorphism f g × c m × c by setting f c c and f g · · · gn c let m c f g · · · gn c in let m c c in m m c tensor product given modules x and y a primitive edit to a pair in x × y is either an edit to the x part or an edit to the y part dx x dy y we can turn these generators into a module by giving specifying a monoid action for the free monoid g x y dx x y g x y x dy y the full module is then given by x y x × y init x init y now we can build a lens that runs two in parallel on the components of a product module the and functions are defined via stateful monoid homomorphism specifications kx z y w k xy c kc × c init init k x z ck c y w x ck y kk z c w k ck c let dz ck k dx ck in ck c ck c let c dy c in ck c g similarly theorem · k is indeed a lens · if k k and then k k · id id id · k k k k · k m k m where assoc is the isomorphism between x y z and x y z for all x y z · k k where swap is the isomorphism between x × y and y × x proof for the first statement being a good lens first note that preservation of monoid multiplication is immediate since xy is free it remains to show that the consistency relation of k is preserved and guarantees this is direct from the definition and the assumption that k and are lenses the remaining statements are direct consequences of the definitions together with theorem for example the third equivalence can be by the simulation relation x y c d c d c c d d x y x y x c x kk x c x k k y d y k y d y k as in the tensor construction is not quite a full categorical product because information does not give rise to a wellbehaved is no lens with type x x x that satisfies all the equivalences a lens programmer would want however tensor product does yield various symmetric monoidal categories of edit lenses for lack of space we omit the details sum we now present one way not the only of constructing a sum module and a sum lens given sets of edits x and y we can describe the generators for the free monoid of edits to a sum by i l r dx x i l r dy y dx x dy y fail the idea is that edits to a sum can either change just the content or change the tag and therefore necessarily also the content which is by the given new content that is we want the atoms of the edit language to express the operations of editing content and switching sides this gives us the and edits for present purposes we could leave it at this and define the monoid of edits to be the free monoid over just these generators however in section we will introduce a more compact representation that allows multiple edits to be combined into one and this kx y z w k xz y w c kc c init k x c y kk z c w k ck c init let dy c k dx ck in let dy c k dx ck in let c dz c in let c dz c in ge c let dy c k dx c in let c dz c in fail c in all other cases g is analogous figure the sum lens representation will give rise to the other two switch operations for example represents a followed by a to avoid having two similar but different definitions we include these edits here in the basic generators as well finally we introduce an edit to represent sequences of edits that are internally a switch to the left side followed by an attempt to apply an edit which on the right side these are formalized in the application function g g g g g x g y e gv undefined in all other cases we then define the sum of modules x and y as x y x y x we now wish to give a lens combinator k that runs lens k on the parts of edits that apply to inl values and on the parts of edits that apply to inr values figure shows the full definition in there is some discussion regarding and sum lenses with the distinction around what to do with the complement when an edit switches between sides of the sum for statebased lenses lenses on recursive structures like lists were given in terms of lenses on the nonrecursive structure and the sum lens gave rise to a list mapping lens whereas the sum lens gave rise to a list mapping lens the alignment strategies given in that paper were somewhat by the maps ability to use from previous versions of a list making sums somewhat more than ones in this presentation however x y x y c c init k x c y x c y px xp cp k dx c let dy cp dx cp in dy cp cp when p n dx c fail c when p n c fail c c dx dx c in all other cases similar figure the list mapping lens theorem when k and are lenses so is k proof the homomorphism laws are again trivial we must show that the consistency relation k is maintained we have init xz init init y w k since kk so it remains to show that that and preserve this relation we need only consider the case where we begin with an arbitrary consistent triple k and dv x z for which dv is defined the cases where the triple is of the form k are similar k and in some places the cases where we are considering a dv y w are similar but use instead of everywhere since dv is defined there are three forms of dv to consider and here is the most interesting case case dv we define dy c dx and x y dx dy since k is a lens we know kk and therefore that x c y kk this means k since k dv and dv and this shows that k is preserved in this case like the tensor product this lens combinator is a id id id and k k k k list module next let us consider lists given a module x we define the basic edits for lists over x to include modifications and reorderings dx p n dx x i n i n i nf i i fail for compatibility with the generalization to arbitrary containers in § we slightly change the behavior of these operations from what we saw in § and are now always performed at the end of the list to insert in the middle of the list you first insert at the end then the list the argument i to and the mapping lens has much better alignment information so we the more complicated lenses in of simpler versions figure a consistent triple for the partition lens now specifies how many elements to insert or delete dx g x · · · xn x · · · xp dx xp xp · · · xn g x · · · xn x · · · xn init x · · · init x fail i times g x · · · xn x · · · g x · · · xn · · · g x · · · xn undefined we take dx g x to be undefined when p x and similarly take g x to be undefined when i x the list module is then x x mapping lens the list mapping lens uses to translate mod edits from x to y and vice versa figure other kinds of edits ins and are carried across unchanged the notation cp cp in the rule for mod edits means the list that is just like c except that the element in position p is replaced by cp when translating edits we update the complement in a way almost identical to the way the two are updated to reflect this similarity we use edit application from the unit init c module to define the new complement partition lens figures and give the definition of a list partitioning lens that as we saw in § a list of tagged elements into those tagged inl and those tagged inr we write fail to stand for when defining g additionally as with the mapping lens we consider the complement to belong to a module this time to the module unit these figures may be a bit at first but there is nothing very deep going some functional programming over lists to illustrate how it all works lets consider a few example invocations of the partition lens each of them begins with the consistent triple illustrated in figure note that only the middle actually available to the partition lens as it runs its other input is just an edit as a consider a simple edit changing name to with correct in the left the edit describing this has the form mod where dn describes the string edit to the name to translate this edit we first need to translate the index to an index into the list of in the righthand line in figure we can do this by simply counting how many appear up to and including that is how many l values appear in the complement list up to index in this case we then wrap this index up along with the dn edit in a new edit of the form dn the complement need not change because we have not changed the structure of the lists this to translate the index then the edit be generalized to all modifications that on the same side of the sum the count and tag functions defined in figure implement these two steps the lefttoright translation of other modifications and and the translation of modifications and to either list are built from the same primitives using count to translate indices and edits with tag in a few cases we use some edit macros since and always happen at the end of a list we write and ins for edits that do some to ensure that the inserted or deleted element moves to the appropriate position perhaps the most interesting of these is an modification to the left that switches sides of a sum line for example suppose we want to replace with the edit to do this has the form mod is at position switch from an inl to an inr here the translated edit must do four things delete from the left list insert a new element into the right list dn so that it changes the new element to and finally fix up the complement to match the new interleaving as before we can use count to translate the position in the interleaved list into a position in the left list in the right replica but then we a minor only occur at the end of a list the solution is to first the list so that appears at the end then delete one element figure defines the cycle function which constructs permutations to do this reordering the function lists of size n by moving position p to the end of the list and all the other elements after p down one to fill in the resulting hole for example cycle looks like this p so we can delete position p by first reordering with then deleting one element with the p macro this pattern there is a similar pattern for inserting a new element at position p by ins p finally since position in the interleaved list corresponds to positions and in the left and right lists respectively the final edit can be written as dn to fix up the complement we can simply set the flag at position p to match the new tag in our case position is now an inr so we should set c r the most cases involve translating reorderings consider an edit to the right that and one way to write this edit is in terms of a function that indices one and three for lists of size at least three and does nothing on lists of size smaller than three f np p n p p n p the edit itself is then our job is now to compute some f for which and in the left line there is one f and f are parameterized by the length of the lists they translating f would therefore seem to require a way for f to guess the number of in lists whose lengths do not match that of the complement fortunately f need only behave correctly for exactly those lists that are consistent with the current complement for which our guess about how many there are is guaranteed to be accurate so we need only construct a single permutation and use say the identity permutation for all inconsistent list lengths we use the count function to construct this permutation it is convenient to derive an isomorphism between positions in the left and positions tagged by which list they are indexing into in the right the function shows how to use count to do this in our example the resulting isomorphism looks like this left right inl inl inr inr inl we can use f as a permutation on the inl elements defining p and then to find out partition x y x y c l r init k z z z x y dv c fail c when p c c c when p c c d d c where n d c c p c d c dv c c cp k where pl pr c d pj d dv d pk c dv c where pl pr c fail c fail c c c c dd c where c d nl nr c d c c where h c c h nl nr c h h f c h nk p p dl inl h out dr inr h out c fail c g c c dx c c c c c c c c c d d c when n where d c c d c c dx c where p c where f n c p p nl nr c f c h g h h c c d p c where h nl nr c p d c gd c c p c d when i nl fail c otherwise fail c similar figure the partition lens l r cw f c w x y dx dy x y count c c · · · cn let nl nr c · · · cn in p m p m n m otherwise · · · cn · · · c p ins p ins p let nl nr c in cp l cp r nl nr c l nl nr c r figure functions for partition where position p in the left should come from we can simply translate p into an index into the right using apply g to find out where that index from and translate back into the left using expanding the table above with these translations yields left inl inl inl inl inr inr inr inr inl inl this indices and so our final f looks like f np p n p p n p translating a reordering of the left follows a similar path line restrict the reordering to lists consistent with the current complement then compose the permutation with isomorphisms between the indices in the two there is one here a reordering of the list in the left may which positions are and which are as a result we must take care to construct two separate position isomorphisms one for before the reordering and one for after containers the list mapping lens from the previous section can be generalized to a much larger set of structures called containers that also includes trees labeled graphs etc we will also provide a general construction for lenses between different container types over the same type of entries together with composition and tensor product this will provide a set of building blocks for constructing many useful lenses the lenses also further examples of lenses with nontrivial only a small part of § depends on this material it can safely be on a first reading containers were first proposed by and the idea is that a container type specifies a set i of shapes and for each shape i a set of positions p i a container with entries in x and belonging to such a container type a shape i and a function f p i x for example lists are containers whose shapes are the natural numbers and for which p i i whereas binary trees are containers whose shapes are subsets of access paths and where p i i itself even labeled graphs can be modeled using graphs as shapes one can further generalize the framework to allow the types of entries to depend on their position but for the sake of simplicity we will not do so here in the present context containers are useful because they allow for the definition of a rich edit language allowing the insertion and deletion of positions modification of particular entries and such as tree we can then define lenses for containers that propagate these general edit operations in the case of statebased symmetric lenses it has been observed that lens iterators to fold left for inductive data structures also permit the definition of powerful statebased lenses in the framework iterators are less convenient because it is how edits in an arbitrary module should be propagated to say list edits in such a way that the rich edit structure available for lists is exploited of course it is possible to propagate everything to a from edit thus the statebased case in the following we slightly from the presentation of containers from in that we do not allow the set of positions to vary with the shapes we rather have a universal set of positions p and a predicate live that a subset of p for each shape i we can then obtain a container type in the original sense by putting p i p p conversely given a container type in the sense of we can define p i p p p i and i p p p furthermore as we already did in we require a set of shapes i and ask that live be monotone this in the original setting would require a coherent family of transition functions p i p i when i i which is more another advantage of the present formulation of container types is that it itself more easily to an implementation in a programming language without dependent types definition a container type is a triple i p live a module i of shapes whose underlying set is partially ordered but whose action need not be monotone a set p of positions and a liveness predicate in the form of a monotone function live i pp which tells for each shape which positions belong to it if t i p live is a container type and x is a set we can form the set t x of containers of type t with entries from x by setting t x ii x thus a container of type t and entries from x a shape i and for every position that is live at every element of entry taken from x our aim is now to explain how the mapping x t x to a functor on the category of for each module x how to construct a module t x whose underlying set of states is the set of containers t x and for each lens x y how to construct a container mapping lens t t x t y we will see that this mapping is well defined on equivalence classes of lenses and respect identities and composition we begin by defining a module structure on containers definition let t i p live be a container type an edit di i is an insertion if di i i whenever defined it is a deletion if di i i whenever defined it is a if i same cardinality whenever defined we only employ edits from these three categories as of container edits any other edits in the module will remain unused this division of container edits into pure and the later definition of lenses operating on such edits definition if i p live is a container type di i and f i p p then we say f is consistent with di if whenever di i is defined f i restricted to is a bijection to i a typical insertion could be the addition of a node to a binary tree a typical deletion the removal of some node and a typical the rotation of a binary tree about some node definition container edits given container t and module x we define edits for t x as follows we give some intuition after definition fail dx p p dx x di an insertion di a deletion f f consistent with di in the last case often either di will only be defined for very few i or f will have a generic definition so the representation of a edit does not have to be large definition edit application the application of an edit to a container i f is defined as follows fail i f is always undefined dx i f i f p dx f p when p i f di i f where f p if p then f p else i f di i f i f i g di i g where g p gf ip the dx edit modifies the contents of position p according to dx if that position is absent the edit fails the shape of the resulting container is unchanged the edit the shape by di growing the set of positions in the process since di i i the new positions are filled with the edit works similarly but the set of positions may the contents of deleted positions are discarded the fail edit never applies and will be returned pro by some container lenses if the input edit does not match the current complement the f edit finally changes the shape of a container but neither adds nor removes entries as already mentioned a typical example is the of a binary tree about the root this rotation applies whenever the root has two to the left and a child to the right for this example one may about the size of f since it affects many positions however it can be to a small three line ifthenelse that we do not at this point provide edits that copy the contents of some position into other positions their investigation is left for future work we define the monoid t x as the free monoid generated by the basic edits defined above in section we discuss the possibility of equational laws in particular with a view to compact normal forms of container edits setting x when t i p live completes the definition of the module t x example for any module x we can the list module x as a particular container type i p live where i n with i generated by i z with i n n furthermore p n and n then all list edits arise as specific container edits however the generic formulation of container edits also includes some edits such as which a list to minimum length by default elements if needed in figure we define the mapping lens t into an on the category of lenses we note that this is only the second lens to have a nontrivial complement after partition given that this definition looks complex at first we state and prove explicitly that it is indeed a lens theorem if t i p live is a container and is a lens so is t moreover t respects lens equivalence and preserves the identity lens and composition of lenses up to equivalence and thus defines a functor on the category of lenses we can also define a lens between containers of different container type but with the same type of entries ie between t x and t x where t i p live and t i p live for this to be possible we need a lens between i and i and for any triple i c i k a bijection live i the complement of this lens consists of those triples i c i and thus knows at any time which bijection links the positions at either end one typical instance of this kind of lens is list reversal another is a lens between trees and lists which ensures that the list entries agree with the tree entries according to some fixed order eg or first although the live positions of the containers to be synchronized are in correspondence there in the case of list fixed edit that say a modify the x y t i p live a container type t t x t y c t c init p init dx i f dy i f when p and where f f pc dy c dx f p dx i f fail i f if p i g di i gp init when di i is defined i g di i g i when di i is defined h i g h di i when di i is defined c fail c in all other cases g analogous k i f i g i f i i f p gp f p k figure generic lens t i p live a container type t i p live a container type i i t t t x t x c k init init k i f i c i i f i c i k i f p f p x fail x dx i c i p dx i c i when p i c i di i c di i i c i di i c di i f i c i fr di i c di i in the last three clauses i c i g see below for fi fd fr di c di c fail in all other cases analogous figure container lens second position edit is mapped to indeed the lens we are about to construct can be seen as a kind of isomorphism but the full of edit lenses is needed to make such a notion precise we also require that maps to to and to note that this is welldefined on equivalence classes of lenses given these data we define the lens in figure with a few definitions below the families of fi fd fr must be chosen in such a way that the container edits in which they appear are wellformed this is possible since di is an insertion deletion or as appropriate and such that the following three constraints are satisfied in each case i i etc refer to the current values from above and p live di i is an arbitrary position i p ic di i p when ic di i p i p ic di i p i p f ic di i p the propagated edits are to be applied to a container of the current shape i so these arbitrary decisions do not really matter nevertheless it would be nice if we could be a bit more uni form this is indeed possible in the case where is an isomorphism lens but we from details the bijection fi contains a little more choice namely the behavior on the t positions in ic di i i fortunately they all contain so that the choice does not affect the resulting state after application of the edit we illustrate the propagation of an edit in the particular case where we are a tree with the list formed by its traversal thus i n p n p p i and i prefix closed subsets of p live i i the monoid i has increment and op the monoid i has operations for adding and removing nodes in leaf positions and also for tree shapes the lens i i does not know anything about the intended application it has a trivial complement unit and merely maintains the constraint that the be da ma da be ma list shape and the tree shape have na na the same number of positions it has some freedom how it translates list edits eg it might add and remove tree nodes at the left the family of models the correspondence thus for exam ple if i and i the bijection would be as shown above for illustration we also indicate be da ma da be ma ble of the positions formally we have now suppose that di i i na na and that di the result of di propagated through two children at the leftmost node in our application we then have ic di i and after applying both and we are in the inconsistent situation depicted above to restore consistency we also apply fr where we could also have chosen this is precisely the additional freedom of choice of course for i i is also completely be da ma na na da be ma after applying fr we end up with the desired consistent state adding monoid laws the edit languages the constructions in the previous two sections were all freely generated this was a good place to begin as it is relatively easy to understand but as discussed in § there are good reasons for richer languages this section takes a first step in this direction by showing how to the product and sum combinators with more interesting edits given modules x and y there is a standard definition of module product motivated by the intuition that an edit to an x × y value is a pair of an edit to the x part and an edit to the y part the monoid multiplication goes pointwise and one can define an edit application that goes pointwise as well x y x × y x y mn m n m n m n m m n n dx dy xy x y dx x dy y x y one might whether the standard definition has any con to the definition we give earlier one way to the gap is to add equational laws to the free monoid the equations below demand that left and right be monoid homomorphisms and that they commute left right it is not hard to show that the free monoid subject to the above equations is isomorphic to the natural monoid product however it is not obvious that the definitions relying on the free monoid product remain well defined after the above equations in particular we must check that any monoid homomorphisms we defined respect these laws for homomorphisms f specified via specification of fg it is enough to prove that for each equational law g g the specification respects the f g f g for example to check that we can create a welldefined tensor product module that includes the above equations we must show that g respects the equations for the commutativity equation we must show g g x y g g x y simple calculation shows that both sides are equal to dx x dy y so this law is the rest follow similar lines most importantly we must check that the and functions are still monoid homomorphisms indeed this check makes these equations interesting as a specification in addition to the usual laws we expect of statebased lenses each nontrivial equation in a monoid presentation represents a behavioral limitation on lenses operating on that monoid take again the commutativity law the force of this law is that lenses operating on a monoid including this equation must ignore the interleaving of left and right edits those two edits are treated independently by the lens lemma if k and are lenses then the g and g functions defined above for k respect all of the above equations adding the first four equations lets us create a projection lens out of smaller parts by observing that there are some new isomorphisms available let f be the isomorphism between x unit and to make this formal treat the equations as a relation between words in the free monoid take the reflexive symmetric transitive congruence closure of this relation and by the resulting equivalence relation x similarly let g be the obvious isomorphism between unit y and y we can then define id x and id y thus first away any information in the righthand part of a tuple with then the now tuple with f we conjecture that these additional laws introduce enough isomorphisms that the tensor product gives rise to a symmetric monoidal is that tuples may be and freely provided the lens program on them is and we have not explored this possibility fully we can perform a similar process for sum edits we add the following equations m d d fail in all other cases this explains why we did not originally choose to have just two combinators and which would be interpreted as switch to the left respectively right side and no matter which side we are currently on the idea of the above equations is that they allow us to any sequence of edits down into a single one if we only allowed ourselves and forms this would not be possible in particular we need to represent the fact that a edit followed by a edit fails when applied to a value tagged with inr as with products we must check that the remaining definitions are wellformed in particular it can be shown that in the module defined above for sums g respects the above equations and that if k and are lenses then k g and k g respect the above equations unfortunately the partition lens as given does not respect the above equations it seems possible to enforce them by also equations on list edits that adjacent operations we leave this to future work in a similar we can impose equations on container edits indeed we need them since we would like lists to form a special case of containers so that possibly after we can partition and containers too these equations would in particular allow us to adjacent reorderings and to and with other edits so that and always come first this would also give rise to a compact normal form of container edits again we leave this to future work from statebased to edit lenses and back in we introduced a statebased framework for bidirectional transformations called symmetric lenses we refer to them here as statebased symmetric lenses recall from that a statebased symmetric lens between sets x and y a set of c a distinguished element missing c and two functions putr x × c y × c y × c x × c satisfying the following laws putr x c y c y c x c y c x c putr x c y c equivalence of statebased symmetric lenses is defined through the existence of a simulating relation between the respective complement sets that relates the missing elements and is preserved by putr a characterization in terms of is also given statebased symmetric lenses modulo equivalence form a category they compose and support a variety of constructions in particular tensor product sum lists trees and container types now for any set x we have the monoid x whose elements edits are lists of elements of x modulo the equality xx x an action of x on x is defined by x x and x where x x w x note that this is well defined as x xy if in addition we have a distinguished element x x we thus obtain a module denoted xx where xx x and x and xx x let be a statebased symmetric lens between x and y along with elements x x and y y satisfying putr x missing y missing we then define a symmetric edit lens xy between the modules xx and yy as follows xy c c xy init missing xy c c xy c c where xy w c v c and putr x c y c analogous definitions for and k x c y putr x c y c xy is a symmetric edit lens and the from to is compatible with the equivalences on symmetric lenses and symmetric edit lenses let x be a module a differ for x is a binary operation x × x x satisfying x x x x and x x thus a differ finds for given states x x an edit operation dx such that dx x x and dx is reasonable at least in the sense that if x x then the produced edit is minimal namely for example the module xx for set x and x x admits the canonical differ given by x x x if x x and x x otherwise given an edit lens between modules x and y both equipped with differs we define a symmetric lens between x and y by c x × c × y init init putr x x c y dy y x c dy y where dx x x and dy c dx c and an analogous definition of this defines a symmetric lens between x and y and the is compatible with lens equivalence theorem let x y be sets with distinguished elements x and y and the associated modules xx and yy with their canonical differs the constructions and xy then establish a correspondence between equivalence classes of edit lenses between xx and yy on the one hand and statebased lenses between x and y on the other we conjecture that this isomorphism between statebased and certain edit lenses is also compatible with various lens constructors in particular tensor product and sum related work the most closely related attempt at developing a theory of update propagation is by et al their starting point is the observation also discussed in that discovery of edits should be from their propagation they thus propose a formalism for the propagation of edits across synchronized data structures some with our edit lenses the which we model as modules are there modeled as categories presented as reflexive graphs thus for any two states x x there is a set of edits xx x an then two reflexive graphs x y and for any x x and y y a set cx y of which roughly correspond to our forward and backward operations similar to our and then complete the picture no concrete examples are given of no composition no notion of equivalence and no combinators for constructing the focus of the paper is rather on the discovery of suitable axioms such as and of edits and a generalization of in the sense of they also develop a comparison with the statebased framework cf § above in our the separation of edits and according to the states that they apply to or relate has two important first in our examples it is often the case that one and the same edit applies to more than one state and can be propagated and more represented as such for example while many of the container edits tend to only work for a particular shape they are completely polymorphic in the contents of the container second the fact that state sets are already categories suggests that a category of would be categorical in extra technical difficulties such as coherence conditions paper on constraint discusses a form of containers for lists equipped with a notion of edits similar to our edit language for lists but does not develop a general theory of constraint a long series of papers from the group at the university of etc deal with the alignment issue using an approach that might be characterized as a hybrid of statebased and lenses work with whole states but these states are internally annotated with tags showing where edits have been marking inserted or deleted elements of lists et als matching lenses offer another approach to dealing with issues of alignment in the framework of pure statebased lenses conclusion a prototype haskell implementation of edit lenses is as well as a showing how to construct connected by lenses the main required extension to the theory presented here are extending the above constructions from algebraic data structures to strings following and identifying good heuristics for converting string edits into structured edits of the form expected by the lenses form of parsing and containers offer a convenient abstraction on which to build generic lens combinators as discussed in § to use these combinators in practice we need to show how to instantiate the module of shapes for the kind of container we are interested in as we did for lists in the future we would like to explore several other sorts of shapes in particular edit languages for graphs may be useful in development while edits for relations are relevant to database applications acknowledgments we are to foster and for discussions of many points to the members of the pl for comments on an early draft to the and participants in the january on bidirectional transformations for creating a environment for work in this area and to the popl reviewers for their suggestions our work has been supported by the national science foundation under grants foundations for xml view update and algebraic foundations for data sharing references michael and containers constructing strictly positive types theor comput sci ­ m j foster michael and benjamin c pierce matching lenses alignment and view update in acm sigplan international conference on functional programming icfp september j foster benjamin c pierce and alan lenses for string data in acm symposium on principles of programming languages popl san francisco california january frank and from state to bidirectional model transformations the symmetric case technical report university of may j foster michael b t moore benjamin c pierce and alan combinators for bidirectional tree transformations a approach to the view update problem acm transactions on programming languages and systems extended abstract presented at principles of programming languages popl s z hu k h k and k graph transformations in acm sigplan international conference on functional programming icfp september martin hofmann benjamin c pierce and daniel symmetric lenses in acm symposium on principles of programming languages popl austin texas january hu mu and a editor for developing structured documents based on bidirectional transformations in partial evaluation and program manipulation pages ­ extended version in higher order and symbolic computation volume issue june david a linux configuration api february available from designing constraint for user interaction manuscript mu hu and an injective language for reversible computation in international conference on mathematics of program construction mu hu and an algebraic approach to bidirectional updating in symposium on programming languages and systems pages ­ november bidirectional model transformations in semantic issues and open questions in international conference on model driven engineering languages and systems models tn volume of lecture notes in computer science pages ­ springerverlag isbn towards an algebraic theory of bidirectional transformations in graph transformations th international conference september proceedings page springer hu and towards automatic model synchronization from model transformations in international conference on automated software engineering ga pages ­ 