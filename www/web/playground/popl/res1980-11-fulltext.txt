a case study in specifying the semantics of a programming language sethi department of computer science the university of abstract on and off over the period of about a year i have on a semantic specification for the c programming language my was to construct a readable and precise specification of c at compiler writers and language this paper is a report on the project introduction c is a general purpose programming language in which most of the software running under the unix operating system n written notes on the development of the language may be found in what is c the de standard for c is d m compiler the portable c compiler by s c johnson which runs on a number of machines is close to the compiler the compilers for c are permissive in that they compile and run more programs than the c reference manual in would allow the of the is balanced by a program called inf which checks c programs and about constructions ranging from type to possibly constructions in is restrictive in t it about programs that the c reference manual allows the c programming ence manual language therefore lies between the compilers int and the c refer choice of semantic method at one time or another three approaches towards defining the semantics of realistic programming languages have been suggested the operational or approach the denotational or mathematical approach and the axiomatic approach that constructs a logic for the programming language while logics of programs are interesting in their own right they are not a semantics for the programming language see for example the discussion in recent work on semantics has to use the denotational or mathematical approach in fact after doing an operational semantics for pl uc the group too has turned to semantics the denotational method was chosen because it can yield abstract semantic specifications and because it has been used to specify the semantics of a number of programming languages algol mi ten pascal ten snobol ten mi the this paper reports on the application of the denotational method to the c programming language the of the paper deals with declarations initial of the semantics of c treated all declarations together but this led to a specification that was hard to read in section two small language fragments are used to introduce the required concepts the first allows simple data declarations of arrays and pointers while the second allows structures of a simple sort using the first fragment type determination and storage management are discussed using the second fragment i he extraction of recursively defined information is discussed together these two fragments allow the introduction of all the concepts that are needed to specify the semantics of data declarations in c since denotational semantics of statements and expressions have been discussed extensively in the unix is a of bell to copy without fee all or part of this material is granted work or are to specific permission andor a fee © literature see for example sto only brief remarks about the semantics of statements and expressions appear in sections and a few language issues relevant to declarations are mentioned in section and the final section contains some notes on the project literature little of the of the denotational method is available in print sto is a general reference the best reference i have found for describing languages is the unpublished set of lecture notes by gordon as i i used ten as a primary reference the several sources where the semantics of an actual language is given tend to contain little discussion of why the particular presentation was chosen the discussion of declarations in section on the of denotational semantics if there is anything original in the section it is in the way the material leads up to the semantics of data declarations in a real language declarations by declarations we mean the part of a programming language that allows meaning to be associated with identifiers identifiers are used not only to refer to basic values like characters and data structures like arrays but also to executable functions which take parameters and return values a discussion of the meaning of declarations must therefore address issues suggested by the following phrases basic and derived types data declarations type determination block structure storage allocation function declarations discussion of declarations rather than assume declarations in the language through a sequence of examples with c we will introduce for the moment the terms type and location will be used informally think of there being a set ty whose elements are called types included in ty are basic types like integer and derived types like array of integers one of the purposes of a data declaration is to associate a type with an identifier the term location corresponds to a storage cell in a machine except that a location can hold any basic value a location will be associated with each identifier representing a basic value this basic value will be determined from the identifier in two stages first the location for the identifier will be determined and then the value held in the location will be up the following program fragment suggests the syntax of declarations in c int n char int x char c char d char e ec else ed return e we take a program in c to consist of a sequence of data declarations like int n followed by a sequence of one or more function declarations like select are similar to functions and subroutines in fortran or to procedures in pascal except that function declarations cannot be nested as in algol the char in char specifies that select is a that returns a character d the body of the declarations of the formal parameters x c and the identifier n is external to all function declarations external identifiers can be referenced inside any function without being explicitly we assume that inside a any declarations like that of e all statements within the function the syntax of an identifier declaration the identifier might appear for example in c the syntax of expressions in which float xyz says that in an expression represents a value of type float then must represent an array of five elements of type float xyz is therefore being an array of five elements of type float the declaration declared to be an array of three each int px says that the construction px represents an integer declared to be a pointer to an integer the operator dereferences a pointer so px is the constructions xyz and px in the above declarations are instances of structures the essential difference between an array fixed number of members of the same type while a structure different types there is another more subtle difference type so we must deal with recursively defined types and a is that an array contains a contains a fixed number of members of a structure may contain a pointer to its own a structure contains a fixed number of members each member has u name and may have any type we illustrate structures by a complex number z and a pointer to a complex number the identifier com p in the following declarations is referred to as a tag struct complex float re float the declaration of a structure tag and its use to declare another identifier can be combined in c so z and can also be declared by struct complex float re float z declarations like the above not only storage for z and they have the side effect cf associating a type with the structure tag complex simple data declarations a number of programming before we can give the semantics of even a simple declaration like concepts must be understood char ab in this section we will consider declarations that declare identifiers to be integers characters or some other basic type arrays of a fixed number of elements of some type or pointers to some type the syntax is as follows declaration we will not specify the syntax of any further a eg px and xyz contains the identifier being declared have the syntax constant the operator in a has lower precedence than all other operators so ap will be parsed as semantic domains all the semantic domains we will refer to here are defined in figure we will take a very view of the term type abstract entity that permits us to distinguish between identifiers between an integer and a pointer to an integer informally speaking a type will be just an that are declared differently eg distinguish the domain ty of types will be the sum of the domain tb of basic types and domains to each way of constructing derived types for example the element of ty corresponding to array of characters will be a triple array character array the only element of the domain array serves as a keyword and is included for clarity is an element of the domain n of integers and is an element of ty the association of types with identifiers will be performed by elements of the domain of type environments the term environment applies to any function that maps an identifier to something semantic domains tb le ty tb array x n x ty pointer x ty e ty e e l vi l nw w vb ve v vs nv se s l vs unused figure semantic domains for simple data declarations basic types types type environments locations lvalues lvalue environments basic values values values states associated with the identifier since the same identifier with it there will be more than one kind of environment may have a type and also some storage associated the value of an identifier y can be changed either by an explicit assignment to y or by an indirect assignment through a pointer to y the presence of pointers makes it convenient to have a mapping from identifiers to their values an identifier in a data declaration will be mapped by an lvalue environment to an lvalue for an identifier of basic or pointer type this lvalue will be a location locations are analogous to storage cells every location is included in the class of lvalues but the lvalue for an array will not be a location for example after the declaration char pair locations will be for pa and pa ir let these locations be and the lvalue corresponding to the identifier pair by itself is a function mapping to and to and is not a location in general the members of an array may themselves be arrays so there will be rather than locations for the members making the lvalue of an array identifier a function from integers to lvalues makes it easy to determine the lvalues of the array members eg if the lvalue for ab is then the lvalue for ab will be following str a useful distinction is often made between values that can be stored denoted by identifiers expressed by expressions passed as parameters can appear on right hand sides of assignments can appear on left hand sides of assignments and so on for example in most languages even if an identifier like xyz in float xyz has a value the value cannot situation in which the identifier the language be stored what is stored are the values of one xyz by itself will have a value is if array values are returned by procedures in corresponding to each basic type is a domain of basic values of that type we sum all these domains together into the domain vb of basic values included in vb is the domain n of integers in addition to basic values there are values associated with pointers and arrays since the assignment assigns the lvalue of x to px the value of an identifier may sometimes be an lvalue we therefore include w in the domain v of values an array value in v will be a function from integers to values array values are not be a state maps a location to a value in addition there will be two special values a garbage value corresponding to an uninitialized location and unused corresponding to a location that is semantic rules c i identifier i i constant n t j in let r t in let t in err tid c x s i let t nt s new ts in figure semantic lines beginning with give rules and declarations l specify rules semantic rules language of simple data declarations beginning with which new environment satisfying x if then else semantic rules the meaning of can be explained by considering the declarations char int from the discussion earlier in this section a construction like can appear in any context where a character is expected and a construction like pa i n can appear in any context where an integer is expected reading the is declared to be an array of pointers to from the type char characters similarly pa i is a pointer to an array of integers after a has been examined in addition to the embedded identifier the type of this identifier will also be known the meaning of a will therefore be a function from a type to an identifier and its type in figure the meaning of the nonterminal is represented by m similarly the meaning of is represented by and will be a type since the semantic rules associated with syntactic rules we must follow the syntax rather than as in the discussion above type t from the type and build up the type associated with the embedded identifier and read start with the new types are built from old using the functions point and arr a type r corresponding to array of n members of type r pointer to type t arr maps an integer n and a type t to maps a type r to f corresponding to having considered we now turn to declarations there are two kinds of meanings for declarations one associates a type and the other an lvalue with an identifier we distinguish between these two types of meanings by writing for the first and n for the second dt and ds are actually functions which map the semantic object declaration to appropriate semantic objects such functions are called valuations according to the semantic rules in figure under valuation dt each declaration modifies the type environment by associating a type with the declared identifier under valuation ds a declaration associates an lvalue with an identifier before valuation ds we need to the handling of storage allocation auxiliary function s new t s scalar let s l unused s in s t t let ts ll sl f ai in figure the auxiliary function new allocates an lvalue for a given type allocation given a type t and a state s the auxiliary function new in figure returns an lvalue and changes the state to s in the changed state all locations in the returned lvalue are initialized to the special garbage value a type t is said to be scalar if t is basic ie t or if t is a pointer ie t for some t we use the auxiliary function scalar t which yields true if t is scalar and false otherwise if a type t is scalar then new t s will return an lvalue that is a location if the type t is an array type then new is invoked recursively to determine lvalues for each member of the array if these lvalues are i hi then the lvalue for the array will be a function that yields when applied to i for this function is constructed by starting with a function that maps every integer to an value is modified to yield fo where is for inl and is otherwise fn and an appropriate state are returned by the new function recursively defined types we will be concerned only with type determination in this section since the storage aspects of structure declarations are just like those of array declarations the determination of types here is a good illustration of the extraction of recursively defined information from a program other examples of recursively defined meanings are those of recursive procedures and statement labels the syntax and semantics of are as in section the only purpose of the nonterminal is to collect all the declarations together declaration declaration declaration declaration struct semantic domains in addition to the basic pointer and array types of section we now need a structure type the structure tag the names and types of the members and the order in which the members appear are all significant a structure type will therefore include the structure tag and the sequence of member names and types ty tb array x n x ty pointer x ty struct x x x ty furthermore the operator applied to a structure tag and a list of pairs of member identifiers associated types yields a type to a structure with the appropriate tag and example associated with the tag complex is the type and for str complex after the declarations struct complex float re float struct complex z both complex and z have the type structure with tag complex containing members named re and im of type float but there is a difference complex is a tag while z is a structure we will need to distinguish between these two ways of associating types with identifiers by defining the type environment ty tag x ty type environments meaning of member declarations a type must clearly yield a type in order to determine this type we may need to refer to the environment for the types associated with previously declared structure tags thus the meaning of a type is a function from an environment to a type e ty i i struct t where identifier in the above rule is a structure tag which is mapped by the environment to a pair consisting of a special marker tag and a type t the marker tag is ignored here later in this section we discuss what happens if the structure tag has not already been declared from the member declarations in a structure we need to extract the member names and their types the meaning of is a function from a type environment the pairs of member names and types to a sequence con e et t pair t in pair i let in the meaning of a basic is assumed to be an appropriate types and will not be specified any further element of the domain tb of basic recursively types the structure tag z below is used to declare one of the structure members so the type of z is recursively defined struct z int count struct z p informally the type t associated with tag z will be structure with tag z containing member count of type integer and member p of type pointer to t we therefore have the following recursive definition of t str z count integer t a slightly more complex case is that of the types of x and y in struct x int count struct y py struct y int count struct x px this time we get a pair of mutually recursive definitions tx str x count integer ly ty str y tx the key problem in determining types is that of setting up the mutually recursive equations for these types actually instead of setting up equations for types we will recursively determine the environment that will map identifiers to types updating environments valuation de enters the type of the declared identifier into the environment the first rule that follows is for a data declaration similar to the ones in section and this rule for valuation de is very similar to the corresponding rule for valuation dt in figure e let t in declaration i declaration if the declared identifier is a structure tag then an ordered pair where t is the type associated with the tag is entered into the environment i struct er let t str t in em let us consider what happens when the above rule is applied to the declaration struct z int count struct z p suppose that the environment is such that zz member declarations will yield the using the environment the valuation for count integer then the following type will be constructed t str z count integer z if tz is an approximation to and to the type of z then t above is a better approximation the type of z in fact if ii count ti then the least upper bound of the chain to ti is the desired type of z rather than setting up a recursive definition that allows to be determined from de is used to construct a sequence of environments in which z ti the starting environment will map all declared identifiers to the least defined type a valuation dz will be used to construct there is another use for a valuation like dz the identifier z may be used for some other purpose outside the current and we need to ensure that on entering a function the types of any identifiers declared in the current function are reset initial environments in a block for each identifier with which a type is associated in the current set of declarations valuation dz will enter as the type of the identifier e let t in i struct identifier i declaration declaration sequence of environments the for determining the types of structure tags have been on collecting all the declarations under the valuation dz is applied to the starting environment to reset the types for all declared identifiers the valuation de is used repeatedly to construct the sequence of environments i mentioned above the desired environment is the least upper bound of io i io fix closure the above least upper bound enough to the least upper bounds while ing least fixed points that the reader might be to with the least fixed point of note however that not lin a more general setting contain valuable infer mation about external identifiers the usual approach see for example the treatment of statement labels in and is to first determine the identifiers declared in a block once the identifiers have been determined a is constructed from these identifiers then using a valuation like de we determine the type associated with each identifier but instead of entering the type in the environment as done by valuation de a of types associated with the cf identifiers is con we start with with giving the type of each identified that are better approximations to the final types the valuation we therefore introduce a new operator fix closure such that given a function nd d and i using the semantic rule c i declaration where data declarations the approach of the last two sections suffices to treat all data declarations in c types can be determined as in section even if the declaration of structure tags is nested or if the declaration of a structure tag is combined with the use of the tag to declare another identifier some of the rules change because a type may contain the declaration of a structure tag so a type can have the side effect of changing the environment statements since c contains the semantics of statements were given using continuations the section containing the semantics of statements was written by editing section of the c reference manual descriptions of the various constructs were and containing semantic rules were added the reader can easily the semantics of statements after reading or sto alternatives goto statements have been proposed the basic idea of the exit approach on pp is to associate with each statement a function from a state to a pair if evaluation proceeds normally then the label is is ignored otherwise the label gives the target of the jump in pp entries embedded labels within a statement that can be to and exits targets from within the statement are explicitly identified and rather than the meaning of a statement the meaning of an triple is considered we have not explored the use of these alternatives to continuations expressions c has a rich set of operators in addition of the form op the behaviour of except that is evaluated just once to the expected operators are a class of assignment exp is roughly equivalent to exp op exp the semantics of expressions are relatively straightforward some points of interest are noted below side effects and order of evaluation the c reference manual leaves unspecified the order of evaluation and the same expression may be evaluated differently on different machines since assignments may be embedded within expressions the value of an expression depends on the evaluation order in practice this does not present a problem since programmers tend to away from such expressions the principle we have used is only those expressions that are not sensitive to the order are legal unfortunately there is no way of checking if a given expression to this principle so we have a particular order of evaluation in the semantic specification for all legal expressions any order of evaluation gives the right value so the semantic specification will clearly give the right value there remains the problem of out expressions the best we can do is to a heuristic in the spirit of which will if the value of an expression is likely to depend on the order of evaluation checks error type this point actually applies to the whole language but this good place to discuss it for the reader it is just as easy to explain the operator as it is the least fixed point operator use of the operator simplifies some of the rules the alternative using least fixed points employed by in pascal specification ten requires the initial to be supplied as an extra argument so the rules contain two environments at the same time however care be in using the operator before writing it is important to show that by inserting the type of each identifier declared in the current block valuation dz ensures that is weaker that that the theoretical properties of been studied speaking operationally it is convenient to take the view that an error causes execution to terminate with an appropriate message this remark applies only to the semantic specification the compiler certainly does not have to work this way the to terminating execution is to propagate errors ie any operator applied to an error value yields an error value so when the program the value is f produced the with propagating errors is that the various operators have to be extended to apply to error and this may the specifications for the operators as in ten it is more convenient to separate from that assumes that nothing goes wrong it is then possible to use different methods for these two kinds of seman tics in particular treating errors as jumps to the end of the program we use continuations in the semantics that performs checks but it is not necessary to use continuations semantics a more concrete example is as follows with one minor exception the operator it is not necessary to carry around the type of each identifier when nothing goes wrong structure tags will continue to be mapped to types by the environment but all other identifiers will be mapped to locations or lvalues when type checking is performed we need to know the types of identifiers but the storage aspects need not thus checking semantics natural in this case the operator maps an identifier to an integer equal to the size of the storage for the identifier we can formalize size by defining it to be the number of locations in the lvalue for the identifier since the size is determined by the type of an identifier the semantics of the operator are given separately from the runtime semantics since continuations are not needed for the semantics of the operator its seman tics can from the semantics of type checks as well exception since the types of the arguments of a function need not fully the checking for compatibility between the types of formal and actual parameters cannot be separated from the runtime semantics language issues much of the time to specifying c was spent in learning the language of the considerations that in the process the compiler writers were most information about known here we helpful in blocks versus unrestricted jumps the c reference manual allows a goto to jump anywhere within the current function even if the jump is into the middle of a compound statement containing declarations the compilers for c resolve the issue of jumps into blocks by preprocessing blocks away declarations of local identifiers are moved to the head of the function in which the declarations appear after renaming identifiers and converting into explicit assignments several of the semantics of statements to close to the language as it is by preprocessing blocks away however we later discovered that the compilers storage for independent nested blocks thus preprocessing declarations by assigning distinct new names to distinct uses of an identifier was also not consistent with the implementations we have therefore specified semantics assuming that the language has blocks in the usual sense even if are restricted from into blocks this is not quite accurate since the compilers a label from being in an inner block oj structures structure members were originally implemented as offsets from the address of a and there is a description of the restrictions on member names in the reference manual the first attempt at specifying the semantics of structure references was an abstraction of the description in the attempt shared a problem with the compilers suppose in an outer block we have a structure declaration struct int header int count and in an inner block there is a declaration struct int count char since count refers to a different offset in the inner block from the offset in the outer block all references to in the inner block will refer to the first component of the structure the compilers now keep member names with the structure and member names can be in inner blocks without running into the problem mentioned above one pass nature except in structure declarations all identifiers must be declared before they are used this is also true of identifiers that are declared to be for types by declarations in the to structure to combine declaration that follows px is declared to be a for the type corresponding with tag x thus the following declarations are legal but reordering the declarations them into one declaration is not allowed to pointer or trying struct x px struct x int count px point the semantic specification does not attempt to be faithful to the compilers and would allow the order of the above declarations to be changed the one pass nature of the compilers also shows up in the fact that the scope of a declared identifier seems to be from the point of declaration to the end of the block thus if x is a structure tag in an outer block it can still be used to declare structures in and inner block until it is to be something else we chose to take the scope of an identifier to be the entire block in which the declaration of the identifier appears notes metalanguage a goal was to study the metalanguage needed to specify a language like c recent work on the automatic construction of interpreters from semantic specifications has used denotational semantics as a starting point we therefore decided to construct a specification of c and to see where in the specification the various features of the metalanguage were needed the style of the semantic rules was motivated by the translator generator oh except for the of letters the metalanguage is essentially that of the oxford school using the same nonterminal names with essentially the same meaning as in the reference manual to of the semantic specification supporting documents since no prior knowledge of denotational semantics was assumed a detailed introduction to denotational semantics was the need for a formal notation was motivated by a familiar construct whose meaning is hard to specify in the reference manual to readability when it gives the meaning of the for statement in terms of a code fragment this code fragment the meaning of the for when the body of the for has a con t statement in it in it would have been better to have focused on declarations before into statements the simple data declarations discussed in section are an for introducing the notations and conventions with statements on the other hand continuations were used because of goto break and n ue statements and fixed points were used for while statements for declarations the order of presentation of the semantics of declarations section was selected after the early draft doing the semantics of all declarations together was taken on by all who read it static or own identifiers the denotational semantics of own identifiers is such identifiers were therefore away by making them external to all and renaming identifiers to separate this is essentially what the denotational semantics does but it is to specify a expressions the of machine arithmetic and the order of evaluation in the presence of side effects led to more discussions than we care to recall once we to understand declarations and get a feel for the whole language these problems in although they did not go away acknowledgements it is a to the support and of my many at bell where much of the work described here was done s r f t s c johnson b w a r m d and d m at bell were all very and helpful r d of university a number of questions about his denotational semantics of pascal ten but for to the at this paper would not have been references s k a lambda calculus model of programming languages i simple constructs h jumps and procedures languages d and c b jones the development method in computer science springer verlag berlin the lecture notes con r l and j e a approach to formal semantics with application the definition of toplas july to p cousot and r cousot constructive appear versions of fixed point theorems j math to v g kahn and b lang a complete gramming language using denotational semantics de france october of a simple m gordon notes on the techniques of denotational february semantics university of edinburgh i and a meyer paper by hoare and languages san specifying programming language semantics annual acm symposium on texas january a principles and of a of programming w and c b jones a formal definition of algol as described report in d and c b jones eds the development method lecture notes in computer science springer verlag berlin in the modified the c a r hoare some properties of predicate transformers j cm july s c johnson yet another computing bell hill new july science technical report no s c johnson a portable compiler theory and practice fifth annual acm symposium on principles of programming languages january s c johnson a c program checker in unix time sharing system unix programmers manual volume bell hill nj january c b jones denotational semantics of goto an exit formulation and its relation to continuations in d and c b jones eds the development method the lecture notes in computer science springer verlag berlin b w and d m new the c programming language prenticehall p and k on the formal description ming of pl annual review in automatic program mi r e the mathematical semantics of algol unpublished research group oxford university manuscript programming mi r e and c a theory of programming and hall london and john new york language semantics f l morris the next programming language descriptions unpublished manuscript november p d the mathematical semantics of algol technical ming research group oxford university program p d sis a system using denotational semantics reference draft ref nr department of computer science university of denmark june d m s c johnson m e and b w part the c programming language d m a through the unix c compiler in unix time sharing system unix programmers manual volume b bell hill nj january b k rosen applications of high level control flow fourth acm symposium gramming languages california january on principles of pro d s scott and c towards a mathematical semantics for computer languages proceedings of the symposium on computers and automata press new york april st j e denotational semantics the scott approach theor mit press cambridge london to programming language str c of programming language proceedings international foundation april computing symposium c and c continuations a mathematical semantics which can deal with full jumps technical programming research group oxford university ten r d mathematical semantics of snobol acm symposium of principles of programming languages october ten r d the denotational semantics of programming languages comm acm august ten r d a denotational definition of the programming language pascal technical report department of computing and information science university july 