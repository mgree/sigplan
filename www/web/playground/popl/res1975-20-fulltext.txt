structured exception handling john b inc mass summary in this paper we define what exception conditions are discuss the requirements exception handling language features must satisfy survey and analyze existing approaches to exception handling and propose some new language features for dealing with exceptions in an and re way our objective is not solely to put for a proposal it is also to analyze exception handling is and principles in detail the proposed language features serve to exception handling issues by showing how in current approaches could be in a coherent and way exceptions what are they and why are they needed of the conditions that are detected while to perform some operation exception conditions attention ar ones the operation to the of its the is then per or required to to the condition an exception condition to an attention is called raising an exception the in response is called handling the exception some properties of exception conditions relevant to language features for raising and handling them are q their full is known only outside the detecting operation the operation is not permitted to determine what is to be done after they are raised q an may choose to terminate the operation at the point of the exceptions detection the operation may specify that its termination is required q an whether or not a default response is to be are defined within the operation raising the exception and are executed unless something has been done to prevent their execution this work was performed for pa under contract in essence exceptions permit the user of an operation to extend the operations domain i e the set of inputs for which effects are defined or its range the effects obtained when certain inputs are processed exceptions permit a user to an operations results or effects to his par purpose in using the operation exceptions s to generalize operations making them usable in a variety of contexts than would otherwise be the case specifically tions are used q to permit dealing with an operations or actual failure we will discuss two types of failure q range failure q domain failure and q to indicate the of a valid result or the under which it was obtained q to permit an to monitor an operation e g to measure computational progress or to provide additional and should certain con arise the value of making this uses is the insight it will various although it may sometimes precisely how to classify ambiguity is not crucial classification of exception give into the need for language capabilities be difficult to decide a given exception this for our purposes range failure occurs when an operation finds it is either unable to satisfy its output assertion i e its criterion for determining when it has produced a valid result or it it may not ever be able to satisfy its output tion for example a range failure of the first kind for a read operation would be finding an end mark instead of a record to be read the second type of failure is by ing a parity error when to read a record since in this case it is whether repeated attempts to read will or will not be successful for a numerical algorithm evidence of divergence is a range failure of the first kind failure to converge after a certain amount failure of effort has been of the second kind would be a in general to deal with range the following capabilities are needed failures q the needs the ability to request termination of the operation the operation also needs the ability to say it cant do any more tion is required sometimes it is necessary to all effects of the operation as a side effect of terminating the operation q the ability to tell the operation to try again is also required since this may be a reasonable response in some e g in the case of reading the bad tape record q the ability to terminate the operation returning partial results to the perhaps together with additional needed to make sense of the results is also required for example in the case of the bad tape record the may be able to perform some check of the records validity or he may be able to for any errors found in short he may want to modify partial results to make them valid for his purposes this capability is of obvious utility in increasing the generality of an operation since the appropriate actions or even the possibility of up the partial results will vary from one use of the operation to the next in short range failures require the ability to force termination of the operation with or with out production of partial results and with or with out the of intermediate results they also require the ability to resume the operation in cases where further attempts at completion are reasonable domain failure is a somewhat different type of failure it occurs when an operations inputs fail to pass certain tests of e g the of a letter in input that is to consist of a string of or the to find enough ment space to satisfy domain failure a storage allocation require is distinguished from range failure in that domain failure occurs when the operation finds that some input assertion is not satisfied range failure occurs when the opera tion finds that its output assertion cannot be to deal with domain failures an must be given enough information about the failure so that he can if he modify the input to satisfy the input criteria if the is unable to fix the problem he must be permitted to terminate the operation with or without the operation any actions taken before the domain failure was detected the capability an may require to deal with this type of failure is the ability to access the operands of the operation as well as additional information provided from within the operation the needs this information to help in what way the are in error exceptions may also be raised to classify the result of an operation in this case the operations result satisfies its output assertion but the needs additional de the result before he can give it an interpretation for example addition overflow on many computers produces a valid result as long as the bits of the result are inter appropriately or an operation processing a list of items or reading a file may return the last item in the list or file with an that it is the last item so the will not attempt to d more items note that exceptions of this type are different from range failures because the operations output assertion is satisfied its just that the output assertion may be satisfied in several ways and the needs to know which way it was satisfied so he can use the result appropriately result classification is a type of exception that leads naturally to the use of status variables i e output parameters whose value the type of result produced because the opera tion is complete there is no need to resume the operation because a valid result has been produced already note however that status variables are not always appropriate for res for example additional overflow is not best indicated with a status variable monitoring is the last class of exception conditions in this case the wants to be when some condition occurs not because the condition indicates a failure or the type of result being produced but because he simply wants to keep track of the computations or the operation may need additional progress information at certain points and it is too expensive to late this information every time the operation is invoked since the conditions under which it is needed occur only when a monitoring type of exception is raised an may wish to terminate an operation more frequently the may be required to resume the operation because it is not possible or to ter the operation at every monitoring point one example of a desirable use of monitor ing is in conjunction with an operation for search g through a data structure each time an item is found an exception is raised with an argument identifying the item the can then decide whether or not he to get the next item if so he the operation if not he ter it the operation is particularly if the operations state has been pre s by the exception handling mechanism then the search algorithm e g for searching a binary tree can be written recursively and intermediate results can be returned without un the recursion in short exceptions and exception handling mechanisms are not needed just to deal with errors they are needed in general as a means of interleaving actions belonging to different levels of abstraction they are not necessarily for ex in their use to deal with result tion they might be on every invocation of an operation h their use to monitor opera tions and receive intermediate results an ep tion might occur many times for a single tion of the operation exception handling methods that are committed to a fixed implementation tech are therefore not suited for dealing with the complete range of exception requirements in this paper we will propose a technique that is neutral with respect to its implementation and so tions associated with different operations can potentially be implemented differently on their expected frequency and type of use general language design issues one of the objectives of this paper is to define criteria for evaluating exception handling language features the is to document considerations that should be in a language de mind when deciding how to deal with exceptions some criteria deal with functional requirements such as those discussed in the pre section e g how well does a particular method support each of the various uses of exceptions other criteria deal with how well certain general programming language require ments are satisfied in particular exception handling language features should be evaluated in terms of their effect on q error detection how does a language feature help to prevent programmer errors or help in detecting such errors at compile time what errors are programmers likely to make in raising or ing to exceptions does a language feature a programmer to think more about the assumptions he is making in dealing with exception conditions so in these assumptions are easier to see and can be earlier in program development q is features that make connections between modules and sections of modules explicit so all of changes can be traced out more is also easily by features that limit the scope of a changes possible effects specifically when new exception con are added to an operation or when one is deleted is it easy to pro new handlers or to modify the old ones are the necessary changes or simple or complex to make note sometimes even when changes are they are simple to make if the language reduces the amount of effort involved for example consider the difference between adding a parameter to a subroutine call in a language that permits sub routines to have an number of parameters or optional parameters versus in a language where all calls must have the same number of param in the first case only those calls using the new parameter need be modified while in the second every call must be changed q we have already mentioned that exception conditions in and of themselves make it easier to reuse previously written modules in different contexts other re issues concern possible naming conflicts between exceptions raised by previously written modules when they are used to for the first time in a new system or being integrated into an existing s ys as an extension of the s capabilities q efficiency does a method imply use of an implementation technique that is sometimes costly depending on the frequency of an exceptions occurrence is it possible for a programmer to associate different implementation techniques with certain exceptions depending on his use of them and his time and e efficiency requirements the exception handling technique we are does have this property of implementation in principle a pro can choose among several implementation methods for each exception condition he identifies q readability does the syntax permit structuring a programs text so the effects of exception handling are more readily how easy is it to as sure that exception handling actions have the correct effect and that no cases have been note that readability affects both error correction and m w is the syntax natural and adequate for expressing a pro straightforwardly is the syntax uniform i e are there many or few exceptions to the general rules for dealing with exceptions depending on the type of the exception condition do different notations have to be used e g can userdefined and system defined exceptions be treated the same way can information about an exception be ed in of what is variable so the notation for dealing with exceptions is concise note this readability as well as q programming style do the syntactic and semantic constraints of a par method enforce or proper exception handling discipline do they appropriate use of exceptions in program design and implementation q complexity is a language feature just powerful enough to meet clearly understood requirements or is it as powerful and general as can be is the idea behind the language features design to nothing to the programmer even that may be needed or is some only on permitted in of simplifying the number of rules and cases that must be considered in using a particular feature are the features associated with exception handling unique to dealing with ex or are they similar or identical to features already needed for other reasons are different exception handling functional require ments satisfied with variants of a single standard exception handling approach or are a variety of notations are used are the differences worth the cost in tional language complexity e g see is the to pro the least power for which a definite need is seen or the most power that is q implementation difficulty how costly is it to implement a proposed technique is it merely a syntactic of a capability a compiler must already provide or is additional complexity in the code generator and optimizer necessary to make the technique efficient while we will not analyze exception techniques in depth with respect to each of these criteria these criteria should be kept in mind when a new language proposal or in evaluating an existing feature they have been kept in mind in the exception handling features proposed in this paper exception handling requirements and issues in this section we discuss in detail various issues and methods for dealing with exceptions in particular we will discuss q how to associate handlers invocations of operations with since exceptions occur when to perform some operation one basic is is how to the proper handler is associated with a given invocation the cation of exception handling methods presented in this sub section is basic to the discussion in the of the paper q control flow issues in this section we will discuss how exceptions can be used to support loop exits needed in go to free programming as well methods for defining what state ments are to be executed after as an exception has been handled we will also discuss how to that the user and the of an operation agree on whether termination or resumption of the operation is permitted when a particular exception is raised and how a programmer expresses which of en handling the need these possibilities is being the proposed exception language forms eliminate for explicit goto state ments in dealing with exceptions and so in this sense the proposed features constitute a structured approach to exception handling q hierarchies of operations and their exceptions up to this point our ion will have focused on is relevant to the interaction between an operation and its immediate in this section we will discuss issues that arise when an exception is passed from one to the next until one is is to deal with it q default exception handling in this section we will consider what to do with exceptions raised by an operation but not handled by any of the operation and the differences between treatment of default handlers and default handlers provided by user defined packages of operations we will also discuss how to restore and replace one issue not discussed important nonetheless associating parameters with of these issues has not in this paper are methods exceptions been completed but associating operations exception handlers with ti discussing handlers the various methods for with exceptions raised by operations the differences between an operation its invocation and its points of activation need to be kept in mind an operation is either a sub routine or a language defined operator like tion an invocation is an attempt to execute the operation an activation point is the place from which an operation is invoked for example the loop do call end f specifies invocations activation n invocations of the operation f and n of however there is only one point for f and there are two for handlers associated with exceptions raised by operations are of two kinds default and default overriding a default handler is executed only if a programmer has decided not to it with a different handler the key distinction between default and handlers is that handlers ex by default are necessarily the same every time they are invoked but handlers need not be the same examples of default handlers are those defined for certain exceptions in pl e g overflow for all arithmetic operations when this exception occurs there is a action that will be invoked by default unless some overriding action has been specified the difference between overriding a de fault handler and replacing it is sometimes subtle for example in some systems default handlers may be coded as separately compiled subroutines and linked to an operation at load time in such systems a programmer can replace a default handler with one he has written by linking his handler to the operation in place of the normal one although this means the normal default handler has been replaced it has not been because the new handler is constant over different tions of the operation this is what shows it to be a new default handler rather than an overriding handler we will discuss this tion further later the key requirement for associating with exceptions is the ability to define handlers for an exception raised on differ invocations of the same operation dynamic methods permit different handlers to be associated with the same activation point even so static methods are still able to associate different handlers with different invocations be cause different handlers can be statically as with different activation points our interest in this section is in properties of for associating overriding handlers with exceptions we have already mentioned the distinction between static and dynamic tion al methods another way of these same methods is in terms of how easy it is to see if an handler exists at a particular activation point local methods show explicitly whether an handler exists these methods incorporate a reference to a handler or the handler itself into the syntactic form of the activation point e g by specifying the name of a handler as a parameter of a sub routine call this makes the presence or absence of a handler easy to detect and so makes it easy to see whether exceptions will be handled by default global methods in con as se overriding handlers implicitly with activation points by specifying the handler independently of the activation point on conditions are an example of a global association method properties static dynamic classes the local global static and dynamic of methods lead to a classification of these methods local and global the various methods failing in these are listed in table having classified the methods for ing handlers with exceptions we will discuss the specific methods listed in table in detail and the utility of this classification s will be come more apparent local association local association methods in essence treat handlers like parameters of operations for example in languages that permit subroutine names to be passed as parameters the handler can be coded as a subroutine its name given as an actual parameter and the handle r invoked from within the operation when the exception arises this is the exception handling method ed by when the actual is not a subroutine name expression but is instead e g either a sub routine valued variable or a subroutine valued function call then the value passed to the opera tion is still the name of a subroutine but the actual handler can be from one call to the next this technique permits different handlers to be associated with the same activation point and so is a dynamic technique when a subroutine name is used as a parameter instead of a subroutine valued expression the handler is associated with the activation point and so this is an example of a static method subroutine names and expressions both as local methods because the existence of a handler is clear by examining the activation point its no of the activation context is needed to see if the programmer has provided a handler for the exceptions the operation can raise in some languages a label can serve as the exception parameter control is to the location specified by the label parameter when the exception is detected expres sions may be either label variables if a language permits them or a formal label parameter when a expression is used as a parameter the label to which control is can vary from one call to the next and so this is another instance of a tech the use of subroutines or labels as param is wellknown as a way of dealing with exceptions to these two methods we propose a third which we call the local exception name method in which the name of the exception classification table of exception association methods local global static label constants parameters as subroutine names as parameters local exception names global names exception objectoriented exceptions with constant operand recursive cache otherwise nonlocal label necessarily association label dynamic variables as parameters as parameters expressions pl on conditions objectoriented with variable exceptions operand backtracking call with argument subroutine call with label argument call with status variable external status variable status valued functions valued parameters output possibly varying association explicit handler activation evidence existence point of at no explicit of handler at activation evidence existence point will be given greater attention in this paper local methods make a reference hence these methods provide for an exception to a handler a syntactic part of an activation point explicit evidence that a handler has been provided global methods associate of the activation point handler exists a handler implicitly static or dynamic with an activation context is necessary point analysis to see if a static methods associate an overriding raised at some activation point handler with an exception dynamic methods are capable of associating different exception raised at a given activation point handlers with the same appears definition at the activation of its handler point together for example with the fa x represents of raising a mitchell the invocation of an operation capable exception x and having a single param similar notation has been proposed by global association defining exception handlers c is satisfactory a different when each activation point must have handler but when several activation points are to have the same handler it is useful to be able to substitute a single handler definition for repeated identical local definitions if local handler association were the only method pro by a language the program text would often be with information one important notational principle leading to more readable programs is to such ing information when convenient global exception handler association methods fill this need the most obvious example of a global method is the on statement an on state ment consists of an exception name and a block of statements defining the handler for that exception the association between name and handler is when the on statement is executed once process repeat do it then on f begin i first pass handler goto repeat end else on f begin second pass handler to repeat end initialize do while true file processing for pass i and u j process file f end end f f figure example exploiting on statement capability to associate different handlers with the same activation points namely the read statements in the loop for processing the records clarity it shows where of file f process is used merely file processing begins for on then else end f begin do i goto process end first pass do j goto done end second pass handler process done do while end initialize file processing i or i process file f f for pass and figure example showing static use of on statement to associate different exception handling actions with the same activation points namely the read statements in the loop for processing the records of file f process loop i to loop initialize file processing unless for both pass i and f process file f repeat if i then first pass handler else exit second pass handler repeat fall through after two iterations figure structured exception handling example handler with the body of a loop showing static association of an figure loop i to call process repeat i if i then l first pass handler else second pass handler exit structured exception handling example showing uniform treatment of loop bodies and subroutine calls we assume here that the body of process is equivalent to text in figure that actually processes the file established the association the r on statement for executed until the block ments is or until the exception remains the same containing a is executed in effect exception the se on statement until is state on conditions associate handlers with activation points is this ability to associate different handlers with the same tion point really useful in practice on state ments usually associate only one handler with certain activation points in some block the ability to associate different handlers with the same activation point is almost never exploited static association with an activation point is sufficient for example consider the program in figure this program is intended to read a file twice performing somewhat different processing each time for each pass of the file the program associates a different end handler with activation points in the inner processing loop in practice however the program in figure would probably be written as shown in figure in which the same handler is associated with the inner activation points for both passes of the file the value of i is used inside the handler to show whether the first or second pass actions are to be carried out in both figures and opera tions are executed after the second pass is com to the association established be end file f exceptions and the handler specified in the on statements the is included to make these examples semantically equivalent to the next two examples in which any exceptions raised outside the given section of program will not be processed by the handlers established in the examples figure shows how the processing in figures or could be expressed more straightforwardly with a global extension of the exception handling method proposed in the pre section the global variant of this method associates a handler with activation points in some fixed section of text in figure a handler is defined for exceptions raised from activation points inside the inner file processing loop there is no need to specify that the handler is for end file exceptions associated with f since f is the only file being read the inner loop in this figure is executed until an end file exception is raised then con is immediately to the handler attached to the repeat the end of the inner loop after performing appropriate first pass actions the exit statement causes control to pass out of the handler and the repeat associated with the outer loop is en is then increased by one the inner loop is and the next time the exception is raised the same handler will be invoked but this time the value of i will be and the second pass actions will be carried note we are referring here to the use of on conditions to define handlers for activation points existing in the same block as the on statement that establishes the association exception handling out then be increased loop control will leave to and control the inner loop i will will leave the outer the unless clause in the inner loop of figure does not take a boolean expression instead it takes a list of exceptions that can be raised by those operations within the loop that will terminate iterations of the loop this syntax for loop by raising an exception condition was s by knuth as a modification of an idea presented by i have modified idea by using the word unless instead of until both to avoid confusion with the use of until in the looping concept and because the loop is not necessarily by raising an exception as is suggested by the word until a normal exit by failure of some pre in a while clause is in general equally possible the similarity between exceptions raised by operations and exceptions raised from within loops is illustrated in figure where the file processing loop and its initialization are replaced with a subroutine process the handler for this form of the program is the same as in figure the similar treatment of tions raised from within a loop and from within a subroutine is a property of the proposed method since a loop can usually be considered a lower level refinement of a more abstract operation that could have been coded as a sub routine there are other global tech that we have not yet discussed one of the more and interesting variants is the use of objectoriented exception handlers handlers are usually thought of as being associated with operations but it is useful to associate handlers with operands of operations instead of with the operations themselves for example the free storage package permits a programmer to establish different areas of storage called each with a different handler controlling what is to be done when no space is available in the or when an attempt is made to return storage belonging to the etc an appropriate not is associated with a at the time the is created the handler is invoked as a result of some operation using a as a param for example the storage allocation opera tion when applied to some handler if will space is available the this means that depending on the allocation operators operand different exception handlers might be invoked since the exception handler cannot be replaced once a has been created if an allocation operand its and point this operation space associated is an example has a constant handler is implicitly with that activation of static global tion handling variable lf the allocation for its operand operator has a then the handler could change as allocation is performed in different so this associates a handler dynamically with an activation point some programming languages have tion handling capabilities for dealing with range failures only these are based on the idea that recovery from a range failure is impossible the only sensible action is to try some alternative operation that may succeed in obtain ing the desired effect this leads to a check approach in which when failure is reported the system the effects of all operations performed from a certain point up to the time failure was detected then a fresh start is made using an alternative approach the only information from the failure is simply the fact that a failure did occur this very limit ed approach to exception handling is useful in some applications but cannot handle the wide range of possibilities we are interested in specific techniques that have been to deal with range failures in this way are the technique and the recursive cache a proposed hardware concept for making more efficient the activity of an environment after failure has been reported hoare has suggested a similar concept written as q otherwise q meaning that if q fails then q should be per formed so q acts as an exception handler for the failure of ql in proposal the failure of q does not imply the effects of q are before q is invoked we will not discuss these techniques further since they are suited only for a subset of the various types of tion conditions some s ys give an approximation to on conditions by defining special operators for each exception condition associated with some package of routines these operators take a subroutine name as an operand where the subroutine is a handler to be invoked whenever the exception arises for example consider a package for a programs output a program using this package is permitted to define a routine say new end and specify that it is to be called in place of the default routine when a line is too long to be he establishes this between line overflow and his handler by executing se tend new end new end will now be called when a line se tend also returns the name of the replaced line over flow routine to the caller so if he wants to res the previous handler he can save the returned value and later call se tend with the previous value our earlier definition of default and default handlers should be read again with this exception handling method in mind note that new end is not a default handler because if were never executed new end is not the handler that would be executed and because handlers established with the se tend operator can be different for runtime invocations of the print routines i e is the method of establishing a handler that the default handler sup if is never executed the idea of providing the name of a handler subroutine with a call can naturally be ex to provide the name of a label to which control is to be when an exception arises if a language permits this use of labels a technique more often used with labels than this is simply the transfer out of a subroutine to a non local label when an exception arises of course this technique gives quite limited in dealing with exceptions and we will not discuss it further the last group of techniques for as ing handlers with exceptions deals with the use of status values and status variables this class of techniques does not directly associate the occur of an exception with the invocation of some handler information that an exception has occurred is made available to an of the operation by setting a status variable to a certain value and it is up to the to decide when he will test the value of this variable and how this test will be associated with the execution of some exception handling actions since executions of the same activation point can lead to different exception handling actions for the same exception see example below we classify the use of status variables as a dynamic tional technique status variables are most output parameters of operations operation is invoked the value of is tested e g often after these used as the parameters s status ok call fa s if s then else if s then else if s y then x y sometimes the status value is returned principle value of the function e g as the f entry returns do case fa x y ok end case fixed status ok x y calls could be used to es what status variable is to be set when an operation is invoked although this technique is if ever used more is the idea of providing a single external status variable that is set whenever an exception occurs serves this purpose since every s ys exception gives on code a particular value one advantage of status variables not shared by any of the other techniques mentioned so far is that with careful organization of the set of values the variable can take on a programmer can test for the existence of a whole class of exceptions with a single test rather than having to know the individual member of the class for example if a status variables values could be ok read read read i and w a programmer by writing could test for any read exception if ok s write then meaning that if s has any value between ok and a read exception has occurred this is a useful property of status variables that should be preserved with other exception handling methods evaluation of the methods in this section we the principle methods in terms of the extent to which they satisfy certain language design criteria specifically we will discuss q the extent to which or detect exception they help prevent handling errors q the extent to which program readability ability and they and q their effect on program efficiency programming error and detection make the kinds in associating of errors a programmer can handlers with exceptions are that an operation raise a particular exception so not giving due consideration how it should be dealt with can and to when more than one exception possible associating a handler the wrong exception is with to deal with ail exceptions an operation can raise is less likely if a compiler can automatically detect such means that a programmer must in some way de what exceptions can be raised and he must use an method that permits detection at of the various error possibilities satisfying both requirements means q using a static method since the dynamic methods require a flow analysis to check for and even then are not necessarily able to definitely determine if all exceptions have been dealt with and q requiring the declaration of what ex an operation can raise for example suppose a subroutine f is capable of raising exceptions x and y depending on the method to be used in dealing with these exceptions f might be declared as c decl f en entry entry for the subroutine as parameter method en label label for the label as parameter method q xy for the local or global exception name method pl of course does not even permit a program to declare what exceptions an operation can raise and this combined with the nature of on conditions is an important failing in pl s approach to exception handling associating a handler with the wrong tion the second type of error possibility is some what more possible with the subroutine and label methods since the exception name does not appear in the declaration nor at the point of use tions are only defined by their position in the argument list the proposed exception name method is in this respect because a pro or reader is of what exceptions are possible at each activation point they do not have to recall it themselves or refer to a ion to their memory w readability an important language design principle is that of an expression having some meaning in one context should not have a different meaning in another context syntax rules should not have exceptions a programmer should not have to use different language forms for the same purpose cf page violates the principle by making redundant parentheses significant in some contexts eg fg means pass the function g as a parameter fg means pass the value of g as the value of the parameter the principle applied to exception handling that whatever exception handling method is provided by a language it should be in all contexts where exception handling is required this cation of the rule against the use of the subroutine label and status variable exception handling methods because these methods cannot be used to deal with exceptions raised by operations like addition and sion in contrast the exception name method can be used with operations just as with operations for exam ple suppose a programmer to check whether the sum of a and b c note that if the sum it certainly does c using the exception name method he could write if a b then i e exceptions may be associated with expres sions and the valued form of the exit statement defines the expression ls value when the exception occurs we will discuss this use of the exit statement further in section if all tions were handled with status value s then the more flag if flag then a bc or overflow would be required label parameter infeasible the methods procedure parameter or are of course entirely one of the of the dynamic tional methods including p l on conditions is that they do permit language defined and program defined operations to be treated the same way as far as exceptions are concerned ability have tional another requirement to information already justified the need for global methods on this ground is the we efficiency it has been argued that the cost of setting up an exception handler association should be low relative to the cost of a handler since exceptions occur only this argument exceptions with failure of an operation and we have explicitly taken a view some times it is reasonable to raise an exception every time an operation is and perhaps several times per activation for the moment the exception name method the cost associated with various methods results in the following ordering from least cost to great q on conditions q calls q status variables methods and local parameter discusses in some detail why the set up cost for an on condition can be quite low the cost for a call is primarily the cost of link age overhead note the use of calls rather than direct assignment is justified on information hiding since the data structure the handler name is stored is thereby hidden from the program making the call future languages may make it possible to directly assign handlers without at the same time making too much internal information available for possible cost for the cases where a handler is a parameter is the extra cost in space by parameters associated solely with exceptions considering that they are passed at every activation point the cost could ultimately be great the the following cost of invoking ordering from a handler results in least cost to great q procedure and label parameter call on conditions q status variables the activation cost for the first class of methods is the lowest because no tests need be made to find the location of the handler the location is directly available to the operation raising the exception in dealing with pl on conditions a search must generally be made through the stack frames see for detailed discussion and this is more the cost in space is probably greatest for the status variable method since code to test a s variables value t be written after each activation point the key advantage of the exception name method is that any of these implementation tech can be used and in a properly supported system a programmer will be able to specify with a compiler what implementation method will be used for what exceptions h this case a can control implementation efficiency without having to rewrite his program this im of the explicit exception name technique is one of its most although there are few systems in existence if any that permit this property to be exploited nonetheless the notation pre an that is by the other methods control flow there are basically flow issues to be considered two sorts of control issues relevant to raising an exception q issues relevant to the method for ing an exception handler and re entering flow of control raising an exception occur the various situations in which can be characterized as either exceptions q requiring raising operation termination of the operation continuation must be the q termination of the operation requiring its continuation after the ex has been dealt with q termination or continuation of the operation at the dis the reason these three understood by examining which exceptions arise are needed the is best under q in some required cases an may be to terminate the raising the exception because no further sensible action is possible for example when a read operation finds an mark instead of a record termination of the reading attempt is required to read further is q in other cases the may reasonably be given the option of deciding whether to continue the operation or terminate it for exam ple when a parity error is while to read a tape the must decide whether attempts to the record will be or not q for domain es q termination is required when no is possible e g when sion by zero is q when is can be given possible the option the of re s the operation o r of terminating it for example when an operation finds a letter in what is to be a string of an may decide under some to replace the letter with a and continue the operation with the fixed up string in other he may reasonably decide to terminate the operation either decision should be permitted when the exception is raised q for result classification termination of the operation is always required because the operation has nothing more to do the exception was raised only to classify the result pro when an exception is raised ring an operation to help in q termination operation is never required raising the exception by the in some cases the may be permitted to choose between and the operation for example if an operation is de signed to scan through a data ture raising an exception each time an item is found the should decide whether to continue looking for more items or not q in some cases termination may not be permitted because the operation is not to terminate fully this makes an exception like a subroutine call to a higher level context the value of distinguishing this control flow possibility is that if the operation is guaranteed to be after the exception has been handled the of the ation need not any effort or space to take care of the possibility of being terminated since exceptions present an with possibilities for or terminating an operation each exception should specify what its resumption or termination constraints are for this reason we divide exceptions into three classes q exceptions which termination of the operation the exception require raising q exceptions which of the operation ter exception and require its resumption after the handler has completed its actions and q signal exceptions which permit the operation raising the exception to be either terminated or at the handlers it is an error if an exception of one of these types is treated by an as if it were some other type greater clarity in dealing with exceptions and in understanding programs is the result of distinguishing these control flow possibilities in the actual text of a program all existing exception handling techniques are either in not making control flow constraints sufficiently explicit or in not being able to handle the entire of control flow possibilities inherent in the different reasons for raising an exception for example permits an to resume or terminate operation raising an exception but it does not permit ex constraints about whether termination or resumption is permitted or required other methods are explicit about their control flow op tions but they are not flexible enough to handle all the possibilities for example status ep tion handling methods are appropriate for dealing with most result exceptions but since the status value methods require terminating an operation before the status value can be proc this technique is not suitable for or passing exception handling sub routines as parameters is really suitable only for the control flow discipline the exception handling method being pro in this paper permits an to termi or resume operations and it makes control flow cons explicit for example with the proposed method a subroutine f taking a single argument and raising exceptions x and y must be declared as follows if x is an escape exception i e if the operation of f cannot be after x is raised and if y is a signal exception i e if fs operation can be terminated or re by the handler for y f entry fixed x escape y signal the definition what exceptions of f is similarly can be raised required and their to specify type f procedure aa fixed x escape y signal to raise the exceptions programmer must write signal y eg x or y from within f either escape x or a while exception signal y end y should be raised if exception x should then escape x be raised writing escape y or signal x is an error a compiler can verify that the handler for x does not attempt to resume f and that the of f does not make incorrect assumptions about i can or cannot de after raising exceptions x or y exceptions are de and raised similarly and the con flow constraints can similarly be enforced by a compiler the dis tion between signal and escape exceptions is also made in where the word for escape is error we have used the more neutral term escape since an escape exception may be used merely to indicate that an operation is completed as with result exceptions it should be noted that our proposed method does not permit an exception to be raised with escape control flow constraints in some and signal or constraints in others once an exception is defined to be of a particular type all its uses must to that type declaration hence for example if under some the condition causing y to be raised will not permit f to be then it will be necessary to add an escape exception to the definition of f and raise it instead of y in such before an operation can be terminated by an a signal in the termination exception it may be necessary option to of release certain areas of storage close files restore external data structures to a consistent state etc mu way of dealing with provides this problem a ing a special ment inside the operation exception if an on state being terminated has established a handler for the exception it will be executed to perform the required clean p actions just since result of using before control is returned to the the need to clean up is a possible the signal operation it is natural to handle it syntactically just like any exception associated with an operation signal y local association suffices when the action differs from one invocation of signal to another if it should happen that the same actions are to be associated with every signal s in some operation the global form of exception association could be used e g f procedure x escape signal y yz signal z end in short the any exception the and other problem is treated just only differences between exceptions are like q is raised implicitly when some handler for y the operation is to be terminated q the actions within cannot raise any exceptions other than that are not handled within the scope of the handler for example could not attempt to raise exception x associated with f the com can determine whether or not any exceptions raised at activation points within the handler will not be dealt with fully inside the handler so this constraint is not difficult to enforce the exception can be passed from a local handler to a more global one but it cannot be passed outside the operation being terminated this rule can also be enforced by the computer q when control exits from the handler instead of executing the next s as is normally the case see section the operation is terminated and control returns to the point specified by the handler terminating the operation we will discuss in section other issues related to we noted earlier that exception handlers could be associated with loops and hence with loop for example the escape state ment serves naturally as a loop method e g loop unless x loop while a b unless x then escape else repeat repeat x x when x is raised both the inner and outer loops will be terminated similarly exceptions raised by operation invocations within a loop instead of with an escape s can cause from the loop e g if f is able to raise the escape exception x then we could write loop unless b fa x x pass i fa x pass x the pass statement written with each invocation of x indicates explicitly that x is not handled locally but rather that the exception is passed to a containing context it would certainly be possible to permit f to be invoked without the exception x in this case but for clarity it seems more reasonable to have a programmer explicitly declare his in dealing with x locally this should make the program more to readers who will be thereby that the exception x is raised by f and not some other operation invoked within the loop and mu support the pass operation calls it reject and mu requires that a user call the subroutine continue exceptions can be raised executed within handlers since actions permitted within handlers restricted for example it is able to write by operations otherwise the would be too convenient to be call fx call gy escape z meaning that if x is raised g fails by raising y then by raising exception assumed to exist call f g will be called if the handler for x is z a handler for z is in the context of this example suggests a question could z be an exception associated with f i e can a handler associated with some operation invoke another handler associated with the same opera tion we propose to such a possibility because it is useful to be able to write call fx call gy escape x meaning that if g fails then the handle r for x fails and it is appropriate to pass the exception x on up to a higher context note that we could not write pass in place of escape x because we do not want to pass exception y up higher we want to raise exception x now if it were possible for a handler to invoke a handler associated with the same operation then escape x in the above con text would seem to recursively invoke the handler for x and this is certainly not what is desired hence we impose the following rule only one handler in a set of handlers associated with a given operation or statement can be active at any one time no handler can invoke another handler associated with the same operation or statement one advantage of this rule is possible to add exceptions to having to about conflicts raised by previously existing implies that that is makes it operations without with exceptions handlers the rule call f x call g y pass y escape means some handler for y in invocation of f will be invoked since the handler for x cannot tion y the context of the when x is raised raise fs y the proposed rule can also be justified by appropriately the context in which handlers operate i e the y handler for f in the above example cannot be raised by the x handler for f because y exists to handle exceptions raised from within f above are the context and the escape y and pass s not being executed from within f but of the call to f hence the escape k in y is not intended by any handler to raise an exception associated with f to be the ability to pass exceptions up is con because it is quite natural to deal with an exception first on a local basis and then on a more global basis for example it is often convenient to be able to write something like this loop unless x b fa x pass repeat x pass meaning that the exception x is first dealt with locally and when either no is possible for when no further action using local context is useful the exception is passed on up to the next handler in this case one associated with the loop when this more global action is com the exception is passed up to a still more global context this is often quite natural and is more convenient than having to different exception names just to prevent apparent naming conflicts note that the program fragment given above could itself be part of a handler for an exception called x even so the flow of control as explained above would be unchanged note also that pass could have been written as escape x pass seems more natural here pass also gives useful extra power to the exception raising capabilities when a handler is identical for two or more exceptions for example call f xy pass means that exception name x or y depending on which was raised by f is passed on to an enclosing context this makes the tion handling notation more concise and readable in such we will note another use for pass in section when we discuss its use for dealing with optional exceptions the issues discussed be summarized as follows in this section may q detection of errors q the need according constraints signal to classify exceptions to their control flow escape q readability q the need for exits to support programming escape to handlers associated with loops or compound state ments q exception handling requirements q the need to clean up before terminating an operation the optional exception associated with signal q the need with an exception first locally and then more globally pass q the need to resolve certain about which handler is invoked when an exception is raised from inside a handler the rule only one handler in a handler group to be active at a time leaving a handler the difficulty presented by signal tions with traditional exception handling methods on conditions and subroutines passed as parameters is that an explicit goto statement is needed to transfer control out of the exception handler to the appropriate point in the main con flow this need for an explicit go to state ment is in light of current to replace go with more structured statements for specifying control flow in this section we discuss the various requirements associated with control out of a handler in the exception handling approach being proposed in this paper the last executed state ment in a handler must explicitly state whether the operation raising the exception is to be ter or or if the exception is to be passed to another handler if a programmer writes resume operation raising control will return to the the exception termination of the operation is expressed by having the flow of control leave the handler either by raising an escape type exception or by executing an exit statement the exit statement provides several for specifying what context is being and hence what s o r operation is to be executed next but its t form is just the word exit meaning that the statement contain ing the handler being is to be considered complete and the next statement in the normal control flow is to be executed for example in the following program fragment if exception a is raised in both cases the next statement executed will be the statement assigning c to d call dc p a exit iq a then else dc exit when this statement flow exit the context convention for a exit does not express the desired control may take an argument that defines to be left for example consider e f x l g y exit f exit dc the exit f statement means that if exception y is raised i j will not be executed and control will immediately flow to d c if y is not raised g returns normally and j is assigned to i then the assignment to e is not made because the execution of f is terminated by the final exit statement and control flows to d c we have illustrated in previous sections the use of exit to terminate execution of a function returning a value for the function as though it had terminated normally for example if the exit f statement above were replaced exit f then p would be terminated and with execution would continue as though f had returned the value which would en be assigned to e figure illustrates other possibilities exception we previously mentioned as an raised implicitly under certain there is a need for another implicitly raised operation special exception as well an exception called that the normal completion of an figure shows why sometimes action must be taken just in the cases where the operation example in a loop array an exception terminates searching found normally for for a value in an might be raised just in the cases where the loop terminates value the value is found but when normally this means the has not been found and appropriate action must be taken before the flow paths for the found and not found conditions can be merged for example a program to count the number of different and duplicate values in an array v containing n elements might be written cf o loop i to n loop j to unless found if vii aj then escape found repeat found bj exit t a v i b i repeat exit value when a function returns normally the handler needs to deal with the returned perhaps it is reasonable to use the word itself to represent the value e g b fa x exit could also be exit would the value f returned used in return expressions the complement e g of leaving to summarize an exception the issues handler are concerned with q ability to avoid explicit terminate the operation exception raising to the q the need to express what handler is being left exits from nested handlers q the need a function handler to provide a value when leaving a eg exit for q ability to define an exception handler for normal termination of an operation h escape f entry x signal returns g entry y escape loop unless z b fx cd repeat call g y resume term z exit return end fixed term effect exit exit exit exit g f f escape z escape w return exit h abort g equivalent to exit g i abort f and g do not change b i abort f and g f given value which is i as signed to b abort f and g abort f g and h abort f and g h returns equivalent to return next statement executed resume resume cd cd zs handler ws handler figure example showing effect of substituting different statements for term y figure the need for before can resume independently raised any exceptions or terminated normally necessary to perform some actions necessary the operation terminates normally of whether f it may be when q ability to refer to the value pro by a function inside an exception handler exception handling hierarchies up now we have on dis exception handling requirements that arise when the immediate of an operation deals with all exceptions the operation can raise some additional arise when the operation handling an exception is not the immediate of the subroutine raising the exception for example operation suppose operation b is called by a a expects b to raise exception x under certain conditions but it turns out that these conditions occur only when b invokes operation c so c is the that actually raises the exception b merely acts the exception raised by this section we will focus on special to operations in bs position as a c to a b problems the proposed exception handling technique uses pass to explicitly dis claim interest in further processing of an exception that the exception be passed on to some higher handler if it should happen as in bs case that an exception is always to be passed to an invoking operation without any processing at all then it violates the principle of to require that a programmer repeatedly write pass for exceptions in which he has not the in for example following the conventions and rules given previously the of b would have to write b procedure x signal c entry x signal loop while unless x call c x pass repeat end we argued before that these explicit references x were important for preventing errors and readability but in this case the loop only if b is terminated it seems more reasonable and sufficiently safe to permit a pro to declare his in dealing with exception x anywhere in b for example he could write to is b procedure x signal c entry x signal x exception pass while call c repeat end a separate declaration is used to declare bs dis interest in x rather than writing c entry x signal pass because the declaration of c might be supplied from a or include file and such a declaration of cs properties could not the pass property since it will not apply to every routine using c so a separate declaration is necessary it should be noted that if bs to b and implicitly c when x is raised there might be a need to clean up before b is terminated the exception could be attached either to the invocation of c o r to the end or in both places e g b procedure x signal c pass end exit a routine like b might also have another function in between exceptions raised by c and handled by a namely c might raise a more detailed set of exceptions than a is interest ed in for example c might raise exceptions q r and s but as far as a is concerned wants to about exception x b knows it only that when q r or s is raised x should be to do this a handler like the following would be written signal x but once again if b is solely as a cs exceptions it is and unnecessary perform this translation as explicitly and as frequently as our previously developed require ments would imply a declaration defining this translation once and for all is again the useful answer that off for for to q r s exception pass class x the ability to pass exceptions through several module levels to a module to deal with them has advantages and its advantage is essentially the same as one of the advantages of the exit it makes systems transparent to the introduction or deletion of modules at levels of abstraction the dis advantage is the potential to be s that an of an module of and explicitly con the possible occurrence of each such an exception before deciding its occurrence is of no interest the declaration of pass and class exceptions this the lack of such declarations in is a of the pl approach to exception handling default exception handling up to now our discussion has on exceptions that have handlers provided explicitly by of operations it is very convenient however to define default handlers for some exceptions these handlers are invoked unless specifically by a programmer defined handler exceptions having default handlers will be called default exceptions failure to provide a handler for a default exception is not an error to the contrary it is the way of specifying that the default handler is to be executed treat well most exception requirements for these requirements handling methods default exceptions are do not very the ability to specify for any activation point whether a default handle r is to be invoked or the ability to supply default handlers for programmer defined subroutine packages as well as for operations addition etc the method should be as similar as possible to the method for dealing with system defined the ability to pre one default handler with a higher level default handler to help prevent and detect in using exceptions exceptions having default handlers should be declared to have them only if the existence of default handlers is made to a compiler can the compiler detect proper treatment of exceptions i e failure to provide an explicit handler is an error only for tions default make able exceptions operation are invocations more they concise and read the t requirement ability to control whether default handlers are invoked or is satisfied in only for system defined exceptions like overflow for such exceptions a programmer can that the default handler will be invoked at certain tion points by writing on system for example the following sequence of statements establishes a default overriding overflow for the first addition and removes it for the second addition on overflow a b t c uses on overflow a d b will begin end handler system default handle r use default handler this technique for the execution of a default handler cannot however be applied to programmer defined exceptions e g x because the nature of the system handler for x is not known to the compiler and provides no mechanism for making it known writing on condition x system is an error and does not associate execution of xs default handler with the desired activation point so associated with programmer defined exceptions cannot be treated in the same way as pl defined this lack of is a in exception handling approach has two mechanisms permit to be defined and routine packages one is currently still implemented we will describe both plain their advantages and that for sub though and ex the method for dealing with pro defined default exceptions is that when an exception it another is raised exception and no handler is found for signal is raised with an argument giving the name of the exception the search for an signal handler with the operation raising the for no handler was found for example suppose program a calls subroutine b and b calls c c raises ex x but no handler for x is defined at cs activation point in b or at b ts activation point in a the exception signal x is then raised and a handler for signal is for in c if one is found it is invoked and it tests its argument to see if it is lx if so it performs some appropriate action in this way a default action for x is always performed if no explicit handler has been defined and differences between for x the this approach to default exception handling and the method for s ys defined exceptions is illustrated in figure figure shows that on overflow system is not equivalent to overflow and yet with the signal approach to default cation the programmer is provided only with the capability for default handlers specifically figure shows that a programmer can guarantee invocation of the default handler for exceptions but not for program defined exceptions it might be argued that if a the caller of b has a handler defined for over flow the of b should not be per to it with the default handler but equally well it could be argued that if b for its correctness on the default handlers effect as handler for overflow is by writing on overflow system but is not pre by writing overflow to make the capabilities of and system defined exceptions equivalent a capability to on condition x default is still needed this is in the current version of mu by providing the opera tions et and rather than explain how these routines are used in mu we will first explain our approach to default exception handling show how it solves this problem and then show how it can be extended to provide even more capabilities than mu currently provides in extending our proposed exception handling notation to deal with for default hand the first issue is to distinguish those tions for which default handlers exist requirement above then a compiler can enforce the rule that absence of a handler is an error unless the exception is a exception we propose that default exceptions be distinguished by them to have the attribute optional since it is optional for the programmer to provide an ex handler for these exceptions for example fx escape z signal optional means a handler for z note that their very nature must be provided for x but escape exceptions cannot have default handlers not by our next proposal is more s for a default handler is not automatically from one to up the chain of calls the search continues to higher levels only if the default exception is explicitly passed on up this is consistent with our principle of being explicit about important connections between mod we dont want exceptions to be passed by convention to an moreover there is no need to examine in a call chain for a handler unless these have been explicitly b procedure on condition begin end call c if x is raised handler will be condition x handler for x exists in b call c if x is raised and if bs callers do not have handlers defined for x the default will be invoked on overflow begin end f gh on overflow if overflow system is raised its default is f gh if overflow is raised its default handler will now be invoked even if a caller of b has defined a handler for overflow overflow f gh now if overflow is raised it will be passed to the caller of b end figure the difference between in replacing and b procedure x signal optional c entry x signal optional overflow signal optional end hl c x default handler call c x pass exception passed to bs f g h overflow default handler f g h default invocation k f g h overflow pass exception passed to bs figure program equivalent to that in figure but expressed in the proposed notation ro d end page b k figure an example of multiple default handlers call print signal default exit print default serves as for package exit t pro gram a or b d provided an resume control overriding handler returns to print substituting a default handler given the power to deal with the exception being raised figure demonstrates these new features with a program equivalent to that shown in figure the program shows clearly that in the second call to c b has any for pro an overriding handler by passing the search for a handler explicitly up one level note we consider a default handler to be if a handler exits without returning to the operation raising the exception or if control returns to the exception raising operation via a resume pass ing an exception higher does not the default handler note that in figure writing just without any handler for x means x s default handler will be invoked if x is raised even if there is an handler for x associated with the call to b this happens because the search for an over handler stops unless the exception is explicitly passed up to bs using the special mu routines referred to earlier these effects could be obtained by writing on condition x begin end call c equivalent to call cx condition x call call c equivalent to call c call default call c to call cx pass where is the name of a subroutine that tests calls to see if a raised condition is ix and if so x default the name of the default handler for x the comments in the program explain the effect of the calls to c in my proposed notation the greater complexity of the mu technique is clear the proposed notation for associating de fault handlers with some exception is illustrated below with respect to figure this is what the of subroutine c would write to define a default handler for x signal the default handler for x invoked if default is in short default is an exception condition with the signal operation this condition occurs only if no overriding handler is found for x in which case the actions associated with signal xs default exception will be the actions will of course be executed if xs handler does not return control to c the actions associated with will be executed just in case the default handler for x is not executed and c is note that this is the normal definition to the signal statement of as applied default exceptions can be associated with as well as with signal operations the ability for higher level programs to default handlers for lower level default handlers can be quite useful figure illustrates the meaning and value of substituting rather than overriding a default handler the figure shows an application program program d that makes use of two program packages a and b each of which using a print utility sub routine the print utility is assumed to raise the exception at appropriate points instead of having package a and package b over the print default handler they need to signal d to see if d wants to deal with the exception if not a and b will deal with the ex in an appropriate way as far as d is con the default response for when using package a can be different from the default response for package b in effect package a and b need to provide their own default response for the exception raised by print the solution to this problem is quite simple using the mechanisms already provided if the call to print is written in package a or b as shown in figure the desired effect will be obtained figure shows that if program a or b signal rather than pass the exception to d they can provide a special default if d chooses not to handle the exception response the de fault handler provided by a and b will be from the default provided by print and this default will be executed only if program d does not it note that the exit from the default handler in figure terminates the signal operation it does not terminate the print operation sometimes an may want to take some action in response to an exception and then want to execute the lower level default handler i e an should be permitted to invoke a default handler explicitly as well as im to permit this we add an option to the resume statement that can be used when return ing control to the signal raising a default exception or statement to specify invocation of the default handler instead of overriding the de fault handler a programmer writes resume default instead of resume this makes it look like there really was no handler for the exception and so the default handler will be executed for example with respect to figure writing call c with no handler for x is equivalent to writing call cx resume default is analogous to pass except that it control flow downward to the next default handler ins of upward to an overriding handle r h the example illustrated in figure package a or b could resume the print program by invoking default handler for end page if this were appropriate by writing resume print default instead of from the default handler this sion shows that the important distinction between default and non default handlers is in whether lower or higher level programs have the power to the handlers at a given level if a higher level handler can prevent execution of a lower level handler then the lower level handler is a default handler if a lower level handler can prevent execution of a high level handler then the lower level handler is not a default handler it is what we have been calling an overriding handler our method gives programmers the ability to per mit either a lower level or a higher level to have the final say in how an exception should be of the proposed method satisfies all default handling of dealing requirement with by extend ing our notation defined previously developed exception handling in a uniform way we assume that system exceptions like overflow will be defined as default exceptions so a programmer does not have to provide an explicit handler for every opera tion able to raise such exceptions of course this means an overflow default handler must be arithmetic by the immediate of an operation if it is not passed up explicitly unlike in pl but this is probably the way it should be dealt with only the immediate knows enough about the context of the overflow raising operation to take appropriate action a high level invoke r would not be able to conclusions in this paper we have discussed the issues by exception conditions and how these issues have been dealt with by existing exception handling methods we have proposed a new exception hand notation that solves exception handling problems in a more uniform and reliable way than any exist ing method our proposed method is not complete for we have not yet resolved how to satisfy the need for parameters associated with exceptions none our analysis shows that the wide variety of exception handling approaches that exist can be replaced with a single uniform approach that satisfies tie needs of failure result classification and monitoring efficiency exceptions equally well with reason references oj dijkstra e w and hoare ca r structured new york programming n y academic press ion semantic levels in program liskov b h a design methodology for able systems proc liskov bo ho design of the system i march dijkstra e w the structure of the the system cacm may liskov abstract april b and data types s sigplan notices with hoare g a r a note on the for statement bit d l et al project as a learn proc y d l a technique for specification with examples software cacm mod d l to detected errors in programs dept sci university pittsburgh pa july mitchell september j g signals unpublished note b w mitchell j g and eh on the transfer of control between con xerox palo alto cal jm the control of con in object programs proc ifip cc knuth d e structured programming with go to statements university palo cs alto california stanford may ct a i statement for natural topdown structure programming symp on programming languages paris d t the free storage cacm august package s w and ld jacm october j j h c p m b program structure for error de and computing laboratory univ of upon hoare c ar parallel programming axiomatic app ad october an programmers mass guide hc os and optimizing com language reference manual ibm gc g m the of computer programming van co new york n y cambridge e l the mu system an of its structure mit press mass d l information distribution aspects of design methodology c ifip z ta d l the criteria to be used in systems into modules cacm december g v multiple without the goto cacm exits from july a loop the programmers reference guide july manual vol inc ag a 