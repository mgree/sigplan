new control to aid dl university introduction this paper contains a for a calculus for constructing algorithms the calculus is a generalization of an algollike calculus and hence main some discipline over the algorithms with it the essence of the great go to seems to be that the use of the go to device allows the construction of algorithms which are difficult to control and hence that only more restrictive control structures which are well thought out should be used another way of saying this per is that the go to device is the most primitive and hence most general possible control structure and though implementations of any control structure will ultimately have to be done using it a programmer should no more be content using a go to than if he were forced to use bit strings for data types he should be higherlevel control structures to some extent of course he has them but in discussing the go to the conclusion at by knuth l for instance is that more powerful con structures than are freely available at present are needed to enable programmers to express their algorithms he a by for strengthening the set of available control structures but shows that he still needs to to the go to device he a to jump into the middle of loops the implication is that even with suggestions there is a need for more control structures we concur with this view and present here a for making more such structures available we discussion as to whether the results are for programming language design the lack of control structures is not only in the of public control structures ie made freely available to all users but also in the lack of facilities for creating private ones analogously to the notion of subroutines or data types these are not all that since control structures are in a sense devices at a third level of cation to produce data being the first level other data and programs is are upon by programs upon by control being the second to produce level other programs but the time has perhaps come to pay some more attention to control structures an algollike language as a calculus for let us take a reasonably modern version of algol eg go because they are too primitive case and for cases of control structures and procedures because algorithms we can view the control structure algol w and strip because they are we wish to consider which remains as from it special only a calculus for constructing terms of three a a restricted basic devices b c set of flowchart schemas whose def can be g in computation branch merge block then i ii iii iv v a flowchart a basic computation block or a schema of one of the are can be defined recursively following forms where sequencing conditional while until to be either and two immediate comments which can be made about the set of schemas is quite restricted for instance is not available this calculus are the following simple construction this sort of seems to be a consequence of a design which en the production of schemas which have only one entry point and one exit point and tries to us to as briefly as possible from this discipline namely in a conditional which uses a branch one entry point and two exit points and a merge two entry points and one exit point and in the looping devices while and until which also use a branch and a merge it is not clear that this is a it may be as much by syntactic considerations as anything else however since it is if there is any serious difficulty in intel control over a algorithm this seems to be unnecessary in the case of looping though the discipline may be a one however forms v are the only looping devices available in algol and when presented in the context of the above definition they appear restrictive why not permit for instance c this is what has been called appears quite programmers frequently in both of these suggestions for syntactic devices executing algorithms a loop and its n times lack is as a construction by have been pointed for including out elsewhere them have been for made instance it and a bidirectional calculus even with these however occurring schemas which is not available simple search algorithm search a sequence normally be with suitable initialization there is still for instance al an for and entry point a large class of commonly the schema which is used in a an occurrence of x which would yes no ii this is a simple example of an algorithm which has more than one exit point that is precisely the point the loop we may suppose of it and if we recall the it is also natural to regard common where it as having more than do i enter one possible entry point one if the initial value of i needs to be tested against n and one if it does not yes no ii this is one of several examples some more are given later which are as initial justification for the following generalization of the calculus discussed above the calculus is at producing schemas having more than one entry point and exit point but not in a completely manner first it is suggested that the points be in pairs an entry and an exit point a pair and each pair has an left or right and secondly only certain control structures ie ways of putting schemas together are permitted the structures are modeled on the previously defined calculus except that we have adopted our own of removing the restrictions mentioned in the discussion of that calculus thus is the generalization of which we intend to explore and because of its the calculus will be called want of a better name a calculus we will develop the calculus first without to justify it on the applicability some examples of its use will be given subsequently the definition is given as before in terms of a number of basic devices i called a decision of which there is one form for of in which one of the entry points is ignored ii lj of which there are also cl and iii i t jj two m called a computation one exit point is forms node possible in which only in which one of the entry points is ignored called a iv called a in which there are three intended as the point analogy pairs of the this branch is and merge calculus devices in the i ii iii then one or are a of the above a schema of flowchart is four basic devices one of the following with defined forms i left recursively to be where md pairs and j right either pairs the entry and exit points have been together in the only other possible way to that of ie al has r been turned on its side left pairs versa the pairs are become right pairs and so that vice iv the examples which follow use relatively serial connection any m where m s k of the right pairs of to any m of the left pairs to produce a flowchart where and q j m simple special cases of this construction m s j and are of eg sequencing construction analogous in the to the sequencing calculus iv analogous to a conditional v p again the examples of this construction connection the exit point from a pair left or right of is connected to an entry point in a pair of the entry point of a and exit point of b together become a new pair this is done for any number of pairs in the diagram the result is a flowchart ma where p i k m and which occur tend to be relatively simple eg or h it is also calculus vi possible to up to the looping constructions of the looping a flowchart with two left and right pairs is reduced to a ­ flowchart by connecting up a left and right pair two for instance a generalization of the until construction the crucial construction in this calculus un is sequencing this sort of connection is very common in computing for instance co data links here it takes on the same primitive as ordinary sequencing does in the calculus the simplest constructions in the calculus are thus relatively complex schemas as the examples below will demonstrate in fact they are as complex as nested loops in an ordinary schema calculus we also note here that the constructions appear in this calculus as special cases some examples of the calculus the or otherwise to some extent and with this in mind the first of examples are pairing and sequencing search a column array a for x of the calculus is a matter we present a number of examples of schemas which use only the operations of experiment of x this is a sequence of three basic devices it demonstrates in a rather simple way what is involved in control over algorithms there are in general four points of entry or exit at which specifications for a unit should be given or in four points at which assertions must be made and established and when two such units are connected in sequence the job of establishing the specifications involves determining the effect of an iteration for the example given the specifications may be described by search a array b for x where sj is the algorithm just given for the jth column of b notice that from the other no is selected there is a choice of two by depending on which of s one of which of the requirements is or no w also there is a choice of entry points for the resulting algorithm though in this particular case it is not clear under what the right hand one would be used determine whether x occurs in every column of a array b again xq there are two possible for st one of which results in one pass s in a quicksort routine can be expressed by which is constructed as a sequence of five elements two of which are sequences to which the operation has been applied the examples which follow are related to the implementation of procedures in par recursive procedures and involve some of the other constructions in the calculus we can think of a procedure an ordinary one that is with one entry point and one exit point which calls other procedures q and q say in terms of a construction in the following way u for example p if tx then while ax else while bx d qx can be expressed as i which is immediately if q and q happen by to be the as an application of the same procedure q this normally be implemented i q where t determines which return point to use this is of device suppose now that p calls happens to be p ie p is of the details by only one recursive procedure this q for is normally implemented another use of the sake and missing that out q most where t is a test for whether the recursion is complete eg is the stack empty this is an example of a looping construction we appear to have at the position that a algorithm nonrecursive procedure calls can be implemented as a algorithm and a algorithm with recursive procedure calls can be implemented as a looping algorithm we give an example of the implementation of a recursive procedure in order to demonstrate the above standard if construction then consider the recursive else schema let us look first at the corresponding nonrecursive schema if then else fx a straightforward implementation of this with f left unspecified is with yf ke yes to ml this is a construction in the connection among other things using this as a guide could be implemented by calculus the original using schema eg ys ko no the game of recursion removal can now be as for instance in to this algorithm into a more efficient one but that is another in this particular case a considerable simplification can be made syntax a fact of life which at present we have to live with is that diagrams however are not a suitable language for communicating algorithms to a machine we there conclude this account with some suggestions for a linear language for expressing bi algorithms the suggestions are quite and are intended mainly as a starting point for this problem we have not to define syntactic constructions for the full calculus as described here but only some of the more useful constructions and possible we have the syntax of the analogous algollike construction first for the basic devices is written p or p where the right hand arrow indicates which direction control flows in should p succeed ii m is written again depending is to flow s or s on the direction control iii then iv i i for a few of the a sequence operations is written s is written ss m v vi a there is a strong sn end s sn to write q fi is written if p then s else s the last line here as if q then but this has been vii the following simple example of a connection s from s s as an example of a in construction is written we offer to s z what does a becomes program then look like do until p s until q do example quicksort appears as follows ii j ai v k i a ai ai a end j j j i example becomes do end until stack empty f continue from begin save x bx end to begin end y cy save yf else because it is end this last example it practice because a good deal it must be to become of if restore t o then at ease is being is not too easy to read this is with any new language but to a large extent placed here on the constructions by trying to them into a linear expression however some constructions are quite readable with a little practice ease the situation in general is to work with a dimensional of the simpler ie a possible line of syntax more attack linear to summary we have suggested a possible direction for generalizing the control structures which appear in most structured languages the particular approach has been to develop a calculus which produces schemas in which entry points and exit points are in pairs and in which the most commonly occurring unit is a schema with two entry points and two exit points the result is a calculus in which the simplest schemas analogous to schemas in an ordinary calculus are roughly speaking as complex as nested iteration and the other analogous constructions such as conditionals and looping devices produce more involved schemas a series of examples involving procedure calls both recursive and nonrecursive have been given to demonstrate this in a sense therefore we are that programmers or at least some programmers who need more elaborate control structures should become to working as a matter of course with structures which are complex by present standards we have also made a at establishing some syntactic devices for expressing schemas references knuth strong de structured programming with go to statements unpublished manuscript ct a control statement for natural topdown structured programming presented at symposium on programming languages paris hr jr translating recursion equations into journal of computing system sciences pp 