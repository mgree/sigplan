prime subprogram parsing of a program robert e t computer science department stanford university department of engineering and computer princeton university science abstract a parsing method based on the decomposition of a graph is presented the parsing algorithm runs in linear time and handles a large class of flow graphs the applications of this algorithm to flow analysis and to the automatic structuring of programs are discussed introduction this paper describes an efficient process to parse ie analyze the structure of directed graphs and two interesting applications the structural analysis of flow graphs and the automatic structuring of programs the parsing method uses the linear time decomposition algorithm of hopcroft and tarjan to break the version of the graph into pieces the resulting pieces are then examined together with the information concerning edge directions which was during the decomposition process to determine the precise way in which they fit together to form the original graph while performing these dual operations useful information about the structure of the can be easily obtained the rest of this introduction is to the description of the two applications of our parsing algorithm mentioned earlier while the remainder of this paper consists of two main sections one that provides some necessary definitions and another that describes our parsing algorithm in some detail and states our main results the name flow analysis is normally employed to a collection of techniques used to improve the code generated by compilers co ali gw these tech t work supported by nsf grant and grant work partially supported by nsf provide data flow information that allows the safe application of common subexpression elimination code motion constant propagation etc a few of these techniques use information obtained during the syntax analysis phase of the compilation process most of them however use as input some intermediate form of the program being compiled and proceed as follows the program is represented by a w graph in which each vertex represents a sequence of primitive computational steps that are always performed sequentially and each edge a possible transfer of control between two such sequences the structure of this control flow graph is analyzed this structural information is combined with information about the computation performed at each vertex of the control flow graph to obtain the data flow information needed to solve the problems mentioned above we will show how to apply our parsing to the problem of structure of a control flow graph the classical approach to this problem is the technique co al i several efficient algorithms are known to perform the interval analysis of a flow graph hu the most efficient of which runs in o ma m rt for a flow graph with n vertices and m edges t interval analysis is a very general and powerful technique as a result the generation of structural information from control flow graphs and the extraction of data flow information using the structural information are complex processes recently a different method of analyzing control flow graphs has been proposed ka this method that following gh we call prime subprogram attempts to simplify the algorithms to perform the struc permission to make digital or hard copies of part or all of this work or are r copies to r for computing machinery to copy a fee andor specific permission t the a grows extremely and can be considered less than four for all practical purposes acm analysis and extraction of data flow information some power and generality the published results concerning the worst case com of prime subprogram parsing are to our the following has given a o nm worst case algorithm to parse a restricted class of control flow graphs and gh give a o rr algorithm for a different restricted class of graphs which fr later improved to run in o ma m n on a more general class of inputs we show how to obtain a prime subprogram parse tree in o mn for a class of control flow graphs more general than those considered by the authors mentioned above additionally we show that any algorithm that produces a prime subprogram parse tree for a sufficiently general class of programs can be transformed into an algorithm to decompose a into pieces with the same worst case as the parsing algorithm therefore any algorithm which is simpler than the method suggested here and performs the same task will produce a simpler components algorithm than that of hopcroft and tarjan this fact seems in our to the for a linear time prime subprogram parsing algorithm which is simple although finding such algorithms for special cases of graphs having practical may not be too difficult automatic structuring of programs the of large programs written in programming languages such as fortran in control structures presents in many cases serious problems these programs usually contain large number of control transfers s which tend to make the code hard to understand and consequently hard to modify and maintain a possible way to this problem suggested by consists of automatically translating the program into an equivalent program that uses more control statements and in which as few as possible of the control transfers occur through the use of s one could reasonably expect the resulting equivalent program to be easier to understand and maintain designed and implemented an algorithm to translate fortran programs into a fortran with a full complement of modern control structures which was quite at this task concern was focused on the translation task and as a result this algorithm although quite efficient was far from optimal the flow graphs obtained from programs that do not contain can be characterized using the concepts employed by our parsing algorithm as we shall discuss later more importantly in an arbitrary flow graph our parsing algorithm will identify the sections containing control transfers and give enough information about the other program sections so they can be easily structured definitions this section provides the definitions of the non standard terms used later on and a short comparison between some of our definitions and those used by other authors that consider similar problems some standard graph theoretical terms will be used throughout without being defined their definitions can be found in ha or any other graph theory a program is a directed graph with two distinguished vertices s and t called respectively the start and and such that for any vertex v of the graph there is a path from s to t that includes v a subprogram is a connected subgraph of a program let v be a vertex of a program p v e we will use the following notation for the set of predecessors and of v ve let s be a subprogram of p a vertex v of s is a boundary vertex if the set suc v u pre v includes at least one vertex of ps a boundary vertex v is an of s if pre v includes only vertices of s or if suc v includes only vertices of s similarly v is an exit of s if suc v contains vertices of ps exclusively or if pre v contains only vertices of s examples of these concepts are shown in fig by convention we will consider s an entry and r and exit of the program as a whole a subprogram is proper if it has exactly two boundary vertices one an entry and the other an exit clearly a proper subprogram considered independently must be a program with its entry as the start and its exit as the finish a proper subprogram is nontrivial trivial if it includes at least two edges a nontrivial proper subprogram is prime if all proper totally contained in it are trivial these concepts are illustrated in fig a prime subprogram ps parse of a program p is a process that reduces p by repeatedly replacing a prime subprogram by an edge from its entry to its exit an example of such a process is shown in fig it is a simple consequence of our definitions that any program either consists of a single edge or contains no prime or can be parsed into a program that satisfies one of the first two conditions this fact should not be even though all programs will have a prime subprogram parse it does not follow that the same amount of structural information can be obtained from all of them there will be some cases in which the information with our parsing method will be very minimal and other cases in which a great deal of information is produced some extreme examples are considered in the next section because at a given point more than one prime subprogram of the program being parsed may be there will be in general more than one way to perform the ps parsing of a program this situation common in parsing problems is normally overcome by the use of a parse tree to represent all possible we will use a ps parse tree to represent in a concise all the possible ps of a program as an example the ps parse tree for the program of fig is shown in fig we are not quite ready however to discuss exactly how this tree is constructed therefore the fact that it represents all the ps of the program should be taken on until some further explanation is given the motivation behind this parsing method should be clear we hope that the data flow problems will be easy to solve on the prime since normally they will have a simple structure and that the effects of the computation performed inside them on the rest of the program should be easy to account for due to the single entry and single exit restrictions thus we hope that the data flow problems in the total program can be solved by integrating the solutions of the problems in the prime using the information that tells how these prime fit together to form the program the application of the ps parsing process to the automatic structuring of programs on the same basic principles our approach will be to structure the total program by structuring its prime and then integrating the structured using structured control statements the prime subprogram parse of a flow graph is therefore used to provide the decomposition of the control flow graph necessary for this approach let us end this section by discussing the behind some of our definitions and comparing them with the alternatives in the literature the definitions of entry and exit try to capture the intuitive idea of having every transfer of control into a proper subprogram occur through its entry vertex and every transfer of control out of it occur through its exit vertex our definitions are the we could find to the intuitive notion described above that still retain a character this means that it can be tested whether a vertex v is an entry or exit of a subprogram s by the edges to v and knowing about each of them on whether it belongs to s the use of local definitions in this sense is justified because in most applications you want to obtain global information about flow of control from local control flow information and therefore it does not make much sense to define the parsing process in terms of the information that one to obtain our work is independent of the actual definitions we use in that any others that have this local character can be substituted for them without our results in particular the definitions discussed in the next are all special cases of our definitions ka requires entries to have all their suc and exits all their predecessors inside the subprogram and that no edge join the entry and the exit of a subprogram and gh make a more restrictive assumption the degree of all the vertices of a pro gram is assumed to be either two or three under this restriction which is reasonable in many every boundary vertex of a subprogram is either an entry or an exit according to our definitions fr requires that a single edge outside the subprogram terminate at the entry and that a single edge at the exit terminate outside the subprogram this is a slight generalization of the definitions of and and a particular case of our definitions prime subprogram decomposition parsing and let p ve be a program with start vertex s and finish vertex t and let up denote the graph obtained by adding an edge ts to p and then the directions of all the edges we call up the version of p for any vertex v of p there is a path from s to r that includes v according to our definition of program if we assume that such a simple ie not itself path exists for all vertices of p it follows trivially that up must be the of this will be discussed briefly later on we use it to simplify the description of the ps parsing lemma let p be a program and s a nontrivial proper subprogram of p with entry u and exit v and such that ps is not empty the vertices rj and v are a separation pair of up proof removal of u and v clearly the edges in s from those of furthermore according to our definitions s will have at least two edges since it is non trivial and because ps is not empty will also contain at least two edges this implies that u v are a separation pair of up according to the definition of u theorem the ps parse tree of a program p can be computed in linear time from the pieces of up u instead of a precise algorithm and a formal proof of this fact we offer a detailed example of such a computation and an informal discussion of some of the problems involved in this task which are not illustrated by the example the example begins with a brief description of the output of the components algorithm which we need for our discussion for a complete description see figure shows a graph u p and its pieces in general these pieces are graphs of three types and graphs with at least four vertices the graphs labelled b a and c in fig are examples respectively of these three classes of graphs each piece is made up of edges of two types edges of the original graph drawn as continuous lines in fig and virtual edges represented by dotted lines fig which are introduced during the decomposition process virtual edges are always introduced in pairs the two members of a pair never belonging to the same component in fig virtual edges have been assigned labels so the pair of edges introduced together have the same note that the of each virtual edge are a separation pair and that the original graph can be from the pieces by them along virtual edges with the same label and then eliminating the virtual edges note also that not every separation pair of the graph will be by a virtual edge for example two non adjacent vertices of a like d in fig the graph u pl shown in fig is the version of the program parsed in we will use this graph as an example to describe the construction of the ps parse tree of a program from the pieces of its version and to illustrate in what sense the ps parse tree represents all ps of a program figure a rooted tree tl obtained by representing each piece of u pl by a vertex and joining by an edge the vertices that represent two pieces that include the members of a pair of virtual edges as the root of this tree we choose the that includes the edge s which is included in but not in p figure shows the ps parse tree of p obtained by adding to ti a leaf for each edge e of p the leaf corresponding to e has been to the vertex of t representing the component of up that includes e the children of nodes representing or graphs in such a tree may appear in any order but the children of a node that corresponds to a must be listed in the order in which the edges of the are as one the or it does not matter all these operations can be trivially performed in linear time given a suitable representation of the output of the components algorithm figure illustrates a convenient way of associating subgraphs of a program with subtrees of its ps parse tree which will help us to show how a great deal of structural information about the program is by its ps parse tree in a hierarchical fashion for example from the fact that the root of t is a and has two children we can infer aided by a brief consideration of the directions of the edges to the entry of the subprogram represented by the root of that component that globally fl is a branch with the two alternatives being the defined by the two subtrees of the root of t performing this analysis recursively on the subtrees of the root will provide exactly the kind of information needed to perform the structuring of the program in particular when we get to the subprogram represented by the graph c we can conclude that it is an inherently ill structured section since the con flow graph that one obtains from a program that uses only structured control transfer statements if will decompose into and exclusively the information needed to generate ps is also available from the ps parse tree as the example of fig shows the figure some of the programs obtained as intermediate stages during the ps parse of pi shown in fig side by side with their respective ps parse trees in this example each parsing step can be interpreted as the application to the parse tree of one of the simple transformations shown in fig it seems therefore as if the ps parse of a program can be defined in terms of simple transformations of its ps parse tree however the image by and of how the ps parse tree encodes the ps parsing information is somewhat the program has a nice decomposition into prime subprogram and the decomposition reflects quite well what we as the control structure of the program a general case present some difficulties some of which are discussed below that were carefully eliminated from our example in order to make the basic ideas more the example given is not general in that every separation pair of up is an pair of p that this is not always the case is shown by the examples of fig if rule a of fig is applied to these two ps parse trees we obtain the ps parse trees shown in fig side by side with their corresponding programs in either case rule a corresponds to the replacement by a single edge of a subprogram which was not proper and therefore not prime thus the complete correspondence between the operations of fig and the ps parsing process has it would seem that this correspondence can be without much by testing which virtual edges have that are pairs and allowing rule a o be applied only when it is safe however new problems arise immediately for instance if we take the cross marks on the edges of the ps parse trees in fig to indicate that rule a may not be applied to the vertices below those edges no transformation from our set may be applied to the second program of that figure even though it has a ps parse although it is possible to specify a complete set of ps tree transformations so that even in the general case the ps parsing process can be described in terms of them they are complex enough so we prefer not to discuss them the interested reader can find an early version of this material discussed in detail in va instead we to point out that the correspondence between separation pairs and pairs that makes our parsing very simple is likely to be the rule rather than the exception when dealing with reasonable control flow graphs as opposed to artificial examples like those of fig after this long description of how to obtain the ps parse tree and of some of its applications let us present a that the concept of ps parsing to the concept of decomposition theorem a ps parsing algorithm with worst case f n m can be modified to produce the decomposition of a graph in o f n m steps n the worst case proof even and tarjan et describe a way to number linear the vertices of an graph g ith n vertices from to n in linear time so that a given any edge s r of g s gets number and t gets number n b every vertex except s and t is adjacent both to a and to a vertex if we remove the edge s and direct the edges of g om lower to higher vertices condition b by an easy induction that we obtain a pro ram pg with start s and finish f furthermore every pair of g must be a pair for some subprogram of pg since pg cannot have any cycles in pc we will have a relationship pairs and separation pairs because per the ps parsing of a program requires knowledge of the pairs of the program a ps parse tree for will give a concise description of the separation pairs of from which the pieces can be easily since the computation of the st numbering linear time the worst case of the composition method just described will be no worse than al of the parsing algorithm u final comments we have assumed throughout that the programs being are although it is possible to have that do not satisfy this condition they ok realistic nevertheless one can apply our technique to programs as well by eliminating points y node splitting for instance before using the components algorithm obviously the performed during the elimination of the will have to be taken into consideration during the of the data flow problems we consider the following the main main contributions our work providing an efficient algorithm for the prime subprogram of control flow graphs the close relationship between prime subprogram parsing of a control flow graph and the decomposition of a graph the idea of using the decomposition as a means of structuring programs references al f e allen control flow analysis acm sigplan notices july ba b an a for structuring jacm january co j global common subexpression elimination acm sigplan notices july et s even and r t tarjan computing an st numbering theoretical computer science g n using a manuscript fast algorithms prime subgraph for parsing grammar j d and m s an o n for parsing a proper program into its prime manuscript s l graham and m wegman a and usual linear algorithm for global flow analysis jacm january f graph theory reading mass m s flow analysis of computer pro grams northholland ht j e hopcroft and r e tarjan a into components siam j comput september hu m s siam and j d unman comput june v n distinguishing a directed graph math ro b k rosen high level flow analysis communications acm october r e tarjan flow graph journal of comp and systems sciences december va j parsing and graphs ph d thesis computer science department tech rep december stanford university ca id m j u s u f vi a 