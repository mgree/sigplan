automatic detection of floatingpoint exceptions t vo vu le su department of computer science university of california at vo abstract it is wellknown that floatingpoint exceptions can be and writing numerical programs is very difficult thus it is important to automatically detect such errors in this paper we present ariadne a practical symbolic execution system specifically designed and implemented for detecting floatingpoint exceptions ariadne systematically transforms a numerical program to explicitly check each exception condition ariadne symbolically executes the transformed program using real arithmetic to find candidate inputs that can reach and trigger an exception ariadne converts each candidate input into a floatingpoint number then tests it against the original program in general floatingpoint arithmetic with real arithmetic can change paths from feasible to infeasible and vice versa the key insight of this work is that for the problem of detecting floatingpoint exceptions this approximation works well in practice because if one input reaches an exception many are likely to and at least one of them will do so over both floatingpoint and real arithmetic to realize ariadne we also a novel practical linearization technique to solve nonlinear constraints we extensively evaluated ariadne over scalar functions in the widely used scientific library our results show that ariadne is practical and identifies a large number of real runtime exceptions in the developers our preliminary and look forward to public release which we plan to do in the future categories and subject descriptors d software engineering coding tools and techniques d software engineering verification reliability validation d software engineering testing and debugging symbolic execution f logics and meanings of programs specifying and verifying and reasoning about programs general terms algorithms languages reliability verification keywords floatingpoint exceptions symbolic execution introduction on june the european space off course and because the assignment of a floatingpoint number to an integer caused an overflow the loss is to have been us scientific results rest on software that is usually numeric and permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright © acm may results when in february control software in its of failures are being used for remote numerical software which uses floatingpoint arithmetic is in critical control systems in devices in national and care clearly we are on it floatingpoint numbers are a finite precision encoding of real numbers floatingpoint operations are not closed and may throw exceptions their result may have an absolute value greater than the largest floatingpoint number and overflow it may be nonzero and smaller than the smallest nonzero floatingpoint number and or it may lie between two floatingpoint numbers require and be and the invalid application of an operation to operands outside its domain like taking the square root of a negative number also generate exceptions the ieee standard defines these exceptions writing numerical software that does not throw floatingpoint exceptions is difficult for example it is easy to imagine writing if x y z xy and then later with the program failing due to a spurious as another example consider a straightforward implementation to compute the norm of a vector sum for i i n i sum sum xi xi norm for many slightly large or small vector components this code may overflow or when evaluating or adding the result to sum in of exceptions during its computation the norm itself may nonetheless be representable as an floatingpoint number even when some exceptions are and handled others may not be these are exceptions the in the first example is an exception symbolic analysis has been successfully used to test and validate software however little work has considered symbolic analysis of floatingpoint code although much work has formalizing ieee floatingpoint standards in various proof systems such as coq hol and one natural approach is to a satisfiability modulo theory smt solver with a theory for floatingpoint this has proved to be a challenging problem efforts simplify and from the ieee floatingpoint standard for detecting floatingpoint exceptions our core insight is that if an exception can occur at a particular operation then that exception defines a in which inputs are numerous if one of these inputs the exception over the reals then another is likely to do so over floatingpoint arithmetic by this insight we propose to symbolically execute a numeric program over the reals to search for an input to this end we transform a numeric program to explicitly check the operands of each floatingpoint operation before executing it if a check fails the transformed program signals the floating point exception that would have occurred if the guarded operation had executed then terminates in the transformed program the constraints are over real not floatingpoint numbers so we can directly them into an smt solver equipped with the theory of reals such as z if we can reach any of these injected program points we can query the smt solver for an input that that exception this input is to be a floatingpoint number so we search the of that input for a candidate floating point number that also the exception over real arithmetic to the of symbolic execution over the reals we then test that candidate against the original program concretely executed over floatingpoint arithmetic our approach which we have ariadne automatically detects floatingpoint exceptions while not all exceptions are bugs the utility of ariadne on three observations over and can be as the loss of the demonstrates the developers as bugs several of the exceptions ariadne found and invalid and exceptions are likely to be bugs ariadne reports only real exceptions when it reports inputs that cause a program to throw a particular floatingpoint exception that program run on those inputs will certainly throw that exception when ariadne finds an exception developers can use the inputs to fix the bug and to construct a test case to add to their test suite to realize ariadne we extended the symbolic execution engine to use z version as its smt solver instead of which does not support the theory of reals interesting numeric code often results in multivariate nonlinear constraints in particular the constraints we encountered while analyzing the scientific library were usually multivariate and nonlinear section we these constraints to the state of the art nonlinear smt solver but it only handled less than most of our constraints because they contain large constant values that bounds we also directly gave them to z which had recently added support for multivariate nonlinear constraints but it could only handle a small percentage these results motivated us to a novel practical method for handling nonlinear constraints involving rational functions to support division which we also incorporated into this method works effectively over the constraints arising in our problem setting a new algorithm for solving nonlinear constraints realized in a prototype called was developed concurrently with our work and added to z we ran on of our constraints uniformly selected at random and compared its performance to that of our solver section resolved of the constraints being satisfiable while resolved of the constraints and returned unknown out or had parse errors on the rest our contributions follow · the insight that for the problem of detecting floatingpoint exceptions real arithmetic can effectively model floatingpoint arithmetic since when one input a floatingpoint exception many are likely to do so and of those some will do so over both real and floatingpoint arithmetic · an llvm and implementation of our technique and its evaluation on the scientific library · a tool that automatically converts fixed precision numeric code into arbitrary precision numeric code to detect potentially and and · a practical method for handling nonlinear constraints involving rational functions over the reals we evaluated our tool on the scientific library version we analyzed all functions in the that take scalar inputs which include elementary and many differential equation double x double y return xy double x double y return x y double y return x yx double x double y return y xy double x double y int if x if y else else if y else if if y x return else return else return figure average function functions across the functions we analyzed our tool discovered inputs that generated floatingpoint exceptions of these are and while the remainder are and invalid exceptions some of these exceptions are highly nontrivial as a particular we describe in detail in section illustrates we reported preliminary results to the community they that our warnings were valid and look forward to the public release of our tool these results show that modeling floatingpoint numbers as reals to find exceptions is a in the tradeoff between and precision to and our problem section presents and explains numerical code that contains floatingpoint exceptions we open section with terminology then describe the two transformations on which ariadne the first the exceptions a floatingpoint operation may throw into program points and the second symbolically handles external functions we close section with the algorithms we use to solve multivariate nonlinear constraints section describes the realization of ariadne in section we present the results of analyzing the special functions with ariadne we discuss closely related work in section and conclude in section example floatingpoint arithmetic is illustrates this fact by computing xy the average of two numbers even for a simple function like this it requires considerable knowledge to int const double nu const double x result x double mu double mu double mu double pre double r pre return pre figure a function from special function collection implement it well the four functions in figure are a few possible average formulas they are all equivalent over the reals but not over floatingpoint numbers for instance av when x and y have the same sign and are sufficiently large and av is and requires a second expensive division performs a very interesting analysis of this problem and defines average that uses av av and av according to the of the inputs x and y proved average to be free of our tool ariadne all the paths in average and does not find any as expected to run ariadne we issue ariadne at the command line to compile and apply the operand checking explicit floatingpoint exception transformation then symbolically execute the result to produce which contains the analysis results ariadne for example x e and y e as an input pair that this exception at line we close with a function that contains each of the four floatingpoint exceptions ariadne detects drawn from our test the special functions figure contains the implementation of run on this function ariadne reports that the operation at line an invalid exception when x and a when x when nu e and x e the evaluation of at lines ­ finally when nu e and x e the evaluation of mu at line approach figure the architecture of ariadne which has two main phases phase one transforms an input numeric program into a form that explicitly checks for floatingpoint exceptions before each floatingpoint operation and if one occurs it and terminates execution the transformed program contains conditionals such as x that cannot hold during concrete execution where denotes the maximum floatingpoint value the transformed program including its conditionals are amenable to symbolic execution and any program point that symbolic execution reaches without an exception has the property that none of its floatingpoint variables contain a special value such as not a number or thus the numeric constraints generated during symbolic execution involve those floatingpoint values that are a subset of r and suitable input to an smt solver supporting the theory of reals during phase two ariadne symbolically executes the transformed program and for each path that reaches a floatingpoint exception injected in phase one it attempts to solve the corresponding path constraint if a satisfying assignment is found ariadne exception overflow invalid example x y xy x × op y x op y default result ± ± result table floatingpoint exceptions x y f § attempts to trigger the exception in the original code if it succeeds ariadne reports the assignment as a concrete input that the exception our symbolic execution is standard the key challenge in its realization is how to effectively solve the collected numerical constraints many of which are multivariate nonlinear we first present background in numerical analysis and introduce notation section then describe our transformation section and how we solve numerical constraints section background and notation four integer parameters define a floatingpoint number system f r the base the precision t the minimum and the maximum with these parameters and the m z and the e z f et m t e m t e the floatingpoint numbers for which t m t e holds are normal the numbers for which m t e holds are § t denotes the maximum floatingpoint number the minimum is the smallest normalized floatingpoint number is the smallest floatingpoint operations can generate exceptions shown in table some applications of the operations on certain operands are undefined and cause the and invalid exceptions finite precision causes the rest occurs frequently and is often an consequence of finite precision for example when by an exception occurs because the ratio cannot be exactly represented as a floating point number for this reason ariadne focuses on discovering overflow invalid and exceptions throughout this section we q to denote its arbitrary precision subset let fp q f convert a rational into the floatingpoint value down for next f × f f y returns the floatingpoint number next to x in the direction of y to model path constraints we consider formulas in the theory of reals for a formula fv x denotes the free variables in we use s to denote satisfiable or sat to denote unsatisfiable or and u for unknown below we define algorithms that return satisfying bindings to variables or or unknown for this purpose we define an f v × fn to be a disjoint union that is either an n length vector of simultaneous assignments over f to the variables v or is or unknown for an f b is returns true if a program transformation we first define t the term rewriting system we use to explicit floatingpoint exception handling into numeric code for simplicity of presentation we assume that nested arithmetic expressions have been we assume that the program terminates after a floatingpoint exception input code c c fortran fp exceptions input code explicit fp exceptions symbolic execution constraints over smt solver exception inputs figure the architecture of ariadne basic arithmetic operations the operator and variables x and y bind to floatingpoint expressions we have the following local rewriting rules overflow if x y t x y if x y x y otherwise invalid if x y if x y t x y overflow if x y xy if x y otherwise we also have a global contextual rewriting rule t ce ct e where e denotes an expression of the form x y or x y and denotes a program context ignoring behavior it is evident that p t p when the numeric program p terminates without a floatingpoint exception where · denotes the semantics of its operand figure a shows a concrete example of how t specialized to c transforms a expression line of example in figure the result of the is checked and if an exception could occur execution terminates the division transformation depicted in figure b is the most involved transformation the original expression is taken from line of the example in figure a floatingpoint division operation can throw four distinct exceptions each of which the transformed code explicitly checks for instance given the inputs nu and x the original expression would have terminated normally and returned but the transformed code would detect and output an invalid exception then terminate elementary mathematical functions calls into an library usually terminate symbolic execution calls to elementary mathematical functions such as log exp sin and are in our constraints these functions are often handled in hardware like we next describe simple yet effective transformations to deal with these functions indeed during our experiments these transformations enabled us to find approximately of the floatingpoint exceptions we report when all of an elementary functions operands are within its domain these functions do not return to handle an elementary function therefore we insert checks that its operands are in its domain and signal the appropriate exception if a check fails then bind a fresh symbolic variable to the call these symbolic variables are dependent since they depend on other symbolic variables input symbolic variables are independent we add the obvious constraints on the range of dependent variables for instance we add the constraint d x for which double z mu double abs if abs exit if abs abs exit double z a line of example in figure if x is zero if nu else exit double abs double abs if abs abs exit if abs abs abs exit double r b division line of example in figure figure ariadne transformations realized in c ariadne symbolically executes this code over arbitrary precision where the conditionals can be tested returns the absolute value of a double has a polynomial representation as shown in figure on line of the example in figure we replace the call to with the fresh symbolic variable d and add the constraint d x a dependent symbolic variable can depend on another dependent variable as when is encountered dependent variables allow us to defer a calls evaluation until that variable appears in a path constraint that we to the solver the binding of a dependent variable to a function call is recorded in a table for use during its evaluation when we a dependent variable and the variables on which it depends section table shows the contents of the dependent symbolic variable table when the t invalid if x d where d · d x otherwise overflow if x log t if x log d otherwise t invalid if x d otherwise t d where d t d where d t y invalid if x y d otherwise figure rewriting rules for elementary mathematical functions dependent variable d d expression sin x y x table a dependent symbolic variable table transformation sin x y and x which use the independent variables x y in figure we rewrite calls to to throw invalid if its operands are outside its domain our ing of could make additional checks for exceptions such as y log but we found the described handling of and the other elementary functions to be very effective over the functions we analyzed solving numeric constraints designing smt solvers that can effectively support multivariate nonlinear constraints over the reals is an active area of research smt solvers focus on linear constraints and do not support general nonlinear constraints over the real domain because linear constraints are in integer programs and solving nonlinear constraints is very expensive although decidable over the reals however realworld numeric applications contain many nonlinear constraints in our experiment over the special functions of queries are nonlinear are multivariate and are both nonlinear and multivariate algorithm is the ariadne solver for floatingpoint exceptions during symbolic execution it is called to solve the numeric path constraints to the program points that represent exceptions injected during the program transformation section in addition to the path constraint the ariadne exception solver takes t the dependent symbolic variable table built during the transformation phase section p the original numeric program itself the possible exception e and l the location program point in p of the operation that may throw e to solve algorithm first checks whether contains any multivariate numerical constraints it it does algorithm using t to convert into a univariate formula on line it calls the method which with the underlying smt solver to bind variables that appear in multivariate numeric constraints to values in f section it returns c with the selected variables replaced with concrete values and ac which records those variable to value bindings algorithm calls algorithm to solve a univariate formula when finds a satisfying assignment algorithm returns the bindings from the calls to both algorithm an f solves a numeric path constraint over the reals this algorithm handles formulae that contain multivariate numerical constraints when contains such a constraint the solver tries various up to its bound note that n fv for inputs a numeric constraint from p t t a table of dependent symbolic variables p p the numeric program under analysis e e the potential exception l n the location of e b returns true when passed a formula that contains a multivariate numerical constraint if t then return p e l algorithm else for do c ac t algorithm a ac p e l algorithm if then return a end if end for return u return unknown end if algorithm × an f × e × n an f lin nonlinear univariate constraints in finds a floatingpoint solution to the resulting constraints then checks whether a satisfying solution the given exception at the specified location inputs a formula whose numeric constraints are univariate the the bindings numeric program under analysis e e the potential exception l n the location of e algorithm a ac algorithm if pa does not throw e at l then return u return unknown end if return a and algorithm tries different up to times our experiments validate our core insight that if an exception is reachable many inputs reach it varying did not greatly change detection rate see section to convert a nonlinear univariate formula into a linear formula algorithm applies a linearization technique that finds the roots of each nonlinear polynomial constraint then rewrites the constraints into an equivalent disjunction of interval checks section when is linear while is univariate and linear upon input to on line it remains a formula in the theory of reals so the underlying smt solver used in in algorithm and here in the function may return a solution in q f the algorithm section finds a floatingpoint solution in fn for its input if one exists the functions solution reaches and an exception when symbolically executed using real arithmetic but may not when concretely executed using floatingpoint arithmetic for instance consider overflow the binding x is valid solution in the theory of reals and can return it since x f under concrete execution with standard floatingpoint semantics however the difference in magnitude of the operands means that the result of the addition operation must be to fit into the finite precision of floatingpoint which the into xs value of under floatingpoint arithmetic this overflow is unreachable and the binding produced during symbolic execution is a false positive floatingpoint arithmetic with real arithmetic can also produce false again due to thus each satisfying solution produces is a candidate solution that ariadne must concretely check in algorithm line performs the concrete check over floatingpoint here the ariadne exception solver executes p on the candidate satisfying assignments both those found by and ac from concretization to determine whether p actually the e at l the location of the floatingpoint operation under ariadne is certainly correct when it reports that executing a program on an input vector a particular floatingpoint exception at a particular operation however ariadne cannot guarantee that a program is for three reasons it approximates floatingpoint semantics with constraints over the reals which notably ignore ie multivariate into univariate constraints and rewrites loop conditions to bound the number of iterations the decision to approximate floatingpoint arithmetic with real arithmetic is the core design decision of this work this decision in the tradeoff between and precision it allows us to use smt solvers such as z it is also what the concrete execution check to that a path to an exception is indeed satisfiable it also means that we may fail to detect exceptions that said numerical software is usually robust ie small changes in its input cause small changes in its output so error due to is typically small thus an ideal execution over the reals should closely approximate the actual execution over floatingpoint especially for invalid overflow and exceptions concretization means that ariadne might a path as unsatisfiable when that path is in fact satisfiable and contains exceptions analyzing programs with imposed loop bounds also means that ariadne may fail to explore paths that contain exceptions all of these cases mean that ariadne may miss exceptions in of these limitations ariadne is an effective testing technique that detects many floatingpoint exceptions as our results in section demonstrate in particular we show that concretization is quite effective in our setting section concretization before its smt solver in algorithm ariadne must convert multivariate to univariate polynomial constraints and can no longer defer the concrete evaluation of elementary functions in the form of dependent symbolic variables algorithm takes the input formula and the analyzed programs dependent symbolic variable table t and handles these two problems the algorithm first identifies vt the dependent variables that appear in both t and then the independent variables on which they depend we define vt to avoid independent variables whose dependent variables do not appear in algorithm then identifies all the independent variables that appear in a multivariate numeric constraint in and not in vt then it builds and sorts the dag g to the variables in g so that it has all the information it needs to evaluate the expressions in t on line the choose function nondeterministically selects an element from a set but could be defined to implement an arbitrary selection policy such as selecting the free variable with the algorithm × an f builds a dag that contains the symbolic variables that appear in multivariate numeric constraints and all variables in t then them in topological sort order the function must process t because ariadne can no longer defer handling elementary functions since it is about to query the underlying smt solver inputs a numeric constraint t a dependent symbolic variable table a contains variable bindings d fv d d e t is the set of dependent symbolic variables in t that appear in vt d v d d d e t v fve is the set of dependent symbolic variables in t and the variables on which they depend that appear in m m m is a multivariate numeric constraint in vt is the set of multivariate numeric constraints in that will remain multivariate after t has been im mm vt is the set of independent variables in m that will remain after t has been iu is the set of variables that will remain symbolic after the constraints in m have either been converted to univariate or entirely while m do approximate the set of m iu iu vt for some m m m c c m iu remove those con covered by the choice made in the previous line end while g v e where v vt im iu and u v e when v depends on u ie u v x do if then independent symbolic variables c x return u if c u else dependent symbolic variables c x a end if a a x c cx end for return a degree or that appears most often since iu is a greedy overapproximation of the set of variables in the multivariate numeric constraints in algorithm may as when contains three multivariate constraints and algorithm variables to in the first two that completely the third constraint when this happens we simply hope to do better in a subsequent call to in algorithm the fact that concretization is quite effective in our setting supports our core insight in practice our constraints either have no solution or many our symbolic variables are defined over intervals if an input an exception there will almost always be many such inputs an experiment in section demonstrates the of our concretization results to the presentation we introduce the function × v × f b to check that a candidate binding does not trivially a formula for the call x c we have i do return false if false preliminary experiments using degree or count of occurrences did not uniform selection algorithm rewrites a nonlinear polynomial constraint into an equivalent disjunction of linear interval predicates here is a for any polynomial solver our implementation uses the one in the section input ci a univariate numeric path constraint ci do all constraints in if ci rx then x x · · · xn i x · · · xn where xi x j when i j i is those intervals in which rx i is those intervals in which rx eq n i x xi lt ii x i gt ii x i match with eq lt gt eq lt eq gt ci end if end for return end for return true the notation means to rewrite every of x in i with c the function the expression tree that results from the substitution and evaluates constant expressions it returns false if the recursive evaluation of constant expressions reduces the expression tree to false for example consider the simple numeric constraint x would return false for any assignment to x less than or equal to zero and true otherwise its complexity is on where n is the number of nodes in the expression tree the function checks a single binding to test a bounded number of bindings we define f u for do c return c if x c end for return u return unknown in our setting topological sort means that the condition at line will be true until all the independent symbolic variables that appear in an expression in t are at which point the condition will always be false and dependent variables will be processed at line we evaluate the expression t x in the context of a to find a concrete binding for x for example consider t x y in table when y is to x log algorithm may convert into a ground formula ie a formula with no free variables when this happens the ground formula and returns true or false via otherwise algorithm returns a rewritten that contains no multivariate numeric constraints during the topological sort algorithm calls for each independent symbolic variable over expression trees whose maximum number of nodes is bounded by for each dependent variable we must evaluate its corresponding expression at cost thus the complexity of algorithm is oi d e where v i d univariate nonlinear constraints given a univariate nonlinear constraint we transform it into a disjunction of linear constraints suitable for an smt r r x r x r r x r x r x r figure the roots of the univariate polynomial constraint rx x rx r define intervals that determine its sign solver algorithm a formula in the theory of reals into an equivalent formula by replacing each comparison involving a nonlinear polynomial with an equivalent linear disjunction figure gives the highlevel intuition that this linearization the roots of rx x rx r define intervals that determine its sign as shown in the figure we simply need to encode the intervals that the roots define and the sign of rx when x into each interval into disjunctive linear constraints to form these intervals we must find the roots of a univariate polynomial constraint thus the complexity of algorithm is quadratic the correctness of the technical details of this rewriting on lemma which we present next lemma for a rational function f x px qx where x r there exists a polynomial rx of degree m whose n m distinct real roots x · · · xn define n intervals that can be partitioned into i those intervals in which rx is negative and i where rx is positive using the roots and these intervals we have n f x x xi i f x x i ii f x x i ii proof the rational function f x px qx by definition for px qx qx multiply by qx so our problem reduces to that of solving the predicate rx which either has the form or qx we rx so that its leading is positive from the fundamental theorem of algebra we have rx x xx x · · · x xm where m is the degree of rx complex roots with a nonzero part cannot equal zero and when a bi b is a root its is also a root so the product of the complex factors of rx is positive and do not determine its sign rx holds whenever x equals any of the real roots of rx ie x x · · · x xn otherwise x into one of the n intervals defined by the roots of rx evaluating rx in each of these intervals partitions them into i those intervals in which rx is positive and i those intervals in which rx is negative thus when rx it is negative whenever x into any of the intervals in i and positive whenever x is in some interval in i finding a floatingpoint solution given a univariate linear constraint we need to find a solution over f algorithm loops over the intervals that defines it tries to solve at line then the float less than or equal to the solution into and tries to solve the resulting formula at line if that fails it then the float greater than or algorithm an f takes a path constraint and returns a satisfying assignment over f if one exists input a path constraint while true do a return a if not x v a a return a if a x return a if x x end while equal to the solution into and tries to solve the resulting formula at line if this fails it rules out the interval under consideration at line and considers the next interval the complexity of this step is linear in the number of intervals we prove its correctness next lemma algorithm finds a floatingpoint solution to a univariate linear constraint if one exists proof the solution for a univariate system of linear inequalities is a set of intervals a linear inequality has the form ax b either a and b determines the truth value of the inequality or the solution of the clause into one of two intervals defined by the root of the clause thus the path constraint defines a set of intervals ai bi for x ai bi let x f be the largest floatingpoint number less than or equal to x if either x f ai bi or f ai bi then a floatingpoint value exists that satisfies the path constraints otherwise we have x f ai bi f ai bi ai bi x f f which implies x f ai bi f in this case there is no floatingpoint number in the interval ai bi so we add the constraint x x f x f to rule out ai bi and consider a different interval if the algorithm all the intervals without finding a satisfying floatingpoint value no floatingpoint value for x satisfies the path constraint implementation in this section we present the implementation of our floatingpoint exception detection tool ariadne implementation its operation it consists of transformation or analysis components the transformation on llvm its arbitrary precision transformation uses its analysis phases extends version of the symbolic execution engine and uses the polynomial solver from to rewrite constraints we are to the community for having made these tools available to give back we will also release our tool transformations our transformations are implemented as an llvm analysis and transform pass and operate on llvm ir for this reason our transformations are language and in particular can handle c c and fortran the three languages in which most numerical software is written the principle transformations are exception loop bound and arbitrary precision exception this transformation makes potential floatingpoint exceptions explicit before each floatingpoint operation it operand guards to check for exceptions the bodies of these checks signal the relevant exception and contain a program point that can only be reached if the guarded operation can throw that we consider the closed intervals open intervals can be handled similarly exception as described in section it also handles elementary functions and constructs the dependent symbolic variable table section given an input module it iterates over every instruction in every basic block in every function it rewrites at the matching the call instruction arithmetic and conversion floatingpoint operations when handling the call instruction the transformation detects and handles elementary functions section loop bound symbolic execution maintains state for each path path explosion can resources and prevent symbolic execution from reaching interesting program points loops this problem the loop bound transformation takes a bound parameter that it rewrites every loop in its input to our loop transformation operates on llvm bytecode after loop normalization here we show how it works conceptually int i a fresh variable w h i l e e x p r w h i l e i bound e x p r body body arbitrary precision in section we propose a classifier that likely to be over and from those that are likely to be the idea is to transform a program that a floatingpoint exception into an equivalent program that uses arbitrary precision instead of then run the transformed program to check whether it terminates and the result can be converted into floatingpoint without over or the arbitrary precision transformation ap converts each float type annotation into the arbitrary precision rational type ap converts each arithmetic operation to the corresponding function ap recursively traverses structures ap rewrites internal function and definition and and the parameters to external functions analysis concurrently and separately from we added support for floating point types and operations to our goal is not to support symbolic reasoning on the equivalence between floatingpoint values like but to replace underlying smt solver which does not support satisfiability reasoning over the reals we modified to use version of the z smt solver from microsoft which supports the theory of real numbers and to support floatingpoint symbolic variables update its internal expressions when floatingpoint operations and output those expressions labeling the symbolic variables with type real as input to z to implement linearization section and find the roots of polynomials we extended to use the polynomial solver package and to internally represent every expression as a rational function ie a fraction of two polynomials limitations requires memory to have concrete size memory contents can be symbolic and handles symbolic pointers by ariadne inherits this memory handling strategy from we also restrict symbolic variables to floatingpoint parameters and assign random values to integer parameters we do not handle parameters whose type is pointer or struct we intend to support these features in the future evaluation we first our creation of a new multivariate nonlinear solver then present exceptions it found and discuss its performance as an automatic floatingpoint exception ariadne finds many and many of which may be an consequence of finite precision we close with the presentation of an classifier that to separate from and the f q type transformation on which it we ran our experiments on a machine running lts kernel server with gb ram and intel x core mb cache for a total of the ariadne engine is described in section we choose to analyze the special functions of the scientific library version because the first phase of ariadne focuses on scalar functions and most of special functions take and return scalars we examined all the special functions in the even though some are static and others share their core implementation the is a widely scientific library it is for these reasons that we selected it for analysis finding nontrivial exceptions in it is both challenging and important in of these challenges ariadne found nontrivial exceptions since ariadne analyzes programs not functions we applied a transformation to each special function in the library that a main that creates symbolic variables and calls the analyzed function in addition to applying the transformations described in section and section experimental external functions and loops cause difficulties for static analyzes like the symbolic analysis underlying we handle a subset of external functions as described in section for loops a classic tactic is to impose a timeout another is to bound the loops we did both we imposed two and to bound loops we implemented a transformation that a bound into each loop as described in section although we could have restricted the use of this loop bound transformation to functions whose analysis failed we the analysis on all functions at each loop bound the optimal balance of loop bound and the loop bound means that we did not apply our loop bound transformation concretization we performed the analysis described here with maximum set to so we only tried a single concretization per query as we found that this setting effectively performance and precision higher numbers of had minimal impact on our results when we uniformly of queries for concretization our results were stable at of the results at concretization sat at of the results sat these results validate our tradeoff of performance against precision our goal is to build a precise and practical tool to detect floatingpoint exceptions to this end we the ariadne solver with z we each query even multivariate nonlinear ones to z first and only the ariadne solver on those queries to which z reported unknown we name this hybrid solver result multiple paths or multiple inputs along a single path might reach an program point if that exception is a bug its fix might require a single condition that all the inputs are in an equivalence class or logic bounded by the number of distinct inputs that trigger it thus we report exceptions as xy where x counts unique exception locations found and y counts the unique input to location pairs preconditions the public api of the documents some preconditions so do some of the comments internal to its source code to get a handle on false positive rate we selected uniformly at random of the functions in which reported exceptions we manually examined the public api and the source of these functions to identify their preconditions and check whether the inputs reported against these functions violated those numbers of exceptions log scale invalid overflow number of functions log scale figure ariadne found pairs that trigger floatingpoint exceptions in the scientific library distributed as shown number of pairs figure bar of the number of functions with the specified number of pairs that trigger floatingpoint exceptions preconditions two of the functions were static against these two functions reports input to exception pairs even though they had no explicit preconditions in their comments their call sites may implicitly encode preconditions so we conservatively these pairs to be false positives six functions had preconditions against these functions reported exception pairs of which violated the functions precondition and are false positives against the remaining z ariadne reported input to exception pairs in this experiment therefore false positive rate was or path injection for each operation the ariadne tion in the case of division the paths to the operation the reason is that uses a conditional to com the absolute value of its operand consider double pre here the expression passed to actually contains only one multiplication because the compiler replaces the constant multiplication with a single constant considering only the multiplication in the operand of the ariadne the following if else x y if y overflow if y double pre in this example ariadne finds x e that traverses and x e that traverses both inputs satisfy the conditional and trigger overflow analysis performance and results found a total of pairs that exceptions distributed as shown in figure function prefix line inputs e e e e table of the exceptions ariadne found function prefix line inputs e e e e e e table of the invalid exceptions ariadne found finds many more than invalid or exceptions because programmers to avoid the latter and because can mask these exceptions as when an occurs in the evaluation of a and terminates exploration of that path before the division is evaluated figure shows the distribution of functions in terms of the potential exceptions they contain as expected this distribution is given the and of the it is not surprising that most of its functions contain no latent floatingpoint exceptions ariadne reports the most exceptions in defined in perhaps the most serious exceptions are and invalid exceptions for a selection of these exceptions table and table show the function in which we found this type of exceptions the line number and exception inputs for example ariadne found a exception in in line of this file is const int th lambda v v when lambda and x sh so lines and control points from function entry table shows the results from our analysis of the scalar special functions the data shows that over the special functions the loop bound the first column has little impact on the results we believe that the reason for this is that the analyzed functions do not make heavy use of looping constructs attempts to explore all paths within the time bound it is given when does not its timeout when analyzing a function we increment the no timeout column successfully a path when it determines that the path is satisfiable when it finds an exception that exception is real ie it certainly occurs with the reported inputs even though does not model because candidate pairs via its concrete execution check section of a path as unsatisfiable is for the three reasons discussed in section it approximates floatingpoint semantics with reals which notably ignores it multivariate into univariate constraints and it bounds loops of these three we can have some when reports due to concretization because as we describe above concretization is effective due to the fact that the variables in our numerical constraints in practice either have few or many solutions the former case causes to report unsatisfiable constraints when precision is good so the third column reports the count of functions fully explored without a time out ie u in some of the functions it fully explored discovered no exceptions the count of these functions is in column four the set of functions whose cardinality appears in the no timeout column contains the all paths explored functions which contain the no exception discovered functions we note that while most of the functions in which discovered no exceptions at the bound are four are not during analysis of the z handled of the total queries while ariadne handled the rest of the total queries made we can guarantee the results for at the bound the remaining represent results of which we cannot be certain since they involve concretization that said our concretization experiment shows that of them are likely to be with m we found additional sat · so is likely to resolve around of its constraints the loop bound transformation reduces the num of paths in a program so each of the function columns should be increasing this pattern does not hold over no timeout column there are two reasons for this variation first z randomly on some of the nonlinear multivariate constraints it in of its timeout second during path scheduling to ensure better coverage in short some of the analysis runs at certain loop bounds were simply the three columns that contain the of sat s q q and unknown u q queries report on overall effectiveness recall that in ariadne only handles zs unknown queries the ariadne ratio column reports ariadne effectiveness at solving zs in our context let sa and ua be the sat and unknown queries that ariadne handles the ariadne ratio then is sa sa ua in short ariadne found a substantial fraction of the exceptions and resolved ­ of the queries that z was unable to handle the unique exception field shows xy where x is the number of exception locations and y is the number of unique input to exception location pairs found by only at the specified loop bound in the case of the number of input to location pairs only the pair is unique not the path it take nor the exception it reaches at loop bound the unique exception field in table contains this means that the analysis discovered exceptions that it did not also find at another bound and input to exception pairs found only at this bound the shared also reports exceptions and paths to exceptions but without the constraint that those exceptions and input to exception pairs were only discovered at the specified loop bound our analysis is so the test partitions the functions onto available in our case then analyzes each function one by one against each loop bound it records the analysis time per function per loop bound the sum of all the analysis times for all the functions at each loop bound is reported in the total time column again we see that with our the loop bound does not have much impact on analysis time and some and are an consequence of finite precision the addition is a case in point some however may be avoided by changing the order of evaluation in or replacing the algorithm used to compute a solution because a developers time is we introduce the classifier to distinguish potentially from those that are not let a fn f be an algorithm implemented using floatingpoint and a be that same algorithm implemented using arbitrary loop no all paths no exception s u ariadne exceptions total time bound timeout explored discovered q q q ratio unique shared table the results of analysis of the special functions at the specified loop bounds here q is the set of all queries during analysis and s and u partition q into its sat and unknown queries total ratio table potentially and precision arithmetic over q when ai or we that exception potentially if a i within the range of normal floatingpoint numbers ie a i this classifier on the intuition that if the evaluation of a floatingpoint expression over arbitrary precision arithmetic within the range of normal floatingpoint numbers then it may be possible to find an alternate expression that evaluates to that same result over floatingpoint without generating intermediate values that trigger floatingpoint exceptions for example consider av where x yx when x y the under floatingpoint but the final result is a normal floatingpoint number further we know that av is the equivalent over the reals expression xy that in this case generates the correct answer without intermediate overflow to realize our classifier we a transformer that takes a numeric program and replaces its float and double types with an arbitrary precision rational type for whose implementation we use from in addition to rewriting types our arbitrary precision transformer also rewrites floatingpoint opera tions into rational operations for instance z x y becomes dominated the exceptions we found of all exceptions we defined and realized our classifier with the aim of these nonetheless the number of potentially remains high in table note that is a worst case for us in a numerical library such as the these are high because the range of many mathematical functions is small but their implementation relies on floatingpoint operations whose operands have magnitude related work ariadne is related to the large body of work on symbolic execution such as recent representative work on and dart our work directly builds on and uses its standard symbolic exploration strategy to the best of our knowledge it is the first symbolic execution technique applied to the detection of floatingpoint runtime exceptions we have proposed a novel programming transformation concept to reduce floatingpoint analysis to reasoning on real arithmetic and developed practical techniques to solve nonlinear constraints our work is also closely related to the static analysis of numerical programs the main difference of our work from these is our focus on bug detection rather than proving the absence of error every exception we detect is a real exception but we may miss some we next briefly discuss representative efforts in this area majumdar et al extended the testing engine to support floatingpoint and nonlinear constraints then the problems of path coverage range and analysis et al evaluated two techniques for solving numerical constraints alternating variable method and evolution strategies their goal was to improve the solution of numerical constraints in general not in our specific context of detecting floatingpoint exceptions they found that these techniques do not custom solvers and observed that numerical operations appear in conditionals and therefore not in the path constraint they this observation to build an analysis that aims to prove the memory safety of floatingpoint operations and the noninterference of the numeric and parts of the subject program this is in marked contrast with our work where our transformation explicitly adds numeric conditions and solves the resulting constraints in order to detect floatingpoint exceptions developed an abstract static analysis to analyze errors introduced by the approximation of floatingpoint arithmetic and later refined this work with a more precise abstract domain et al encode floatingpoint operations as functions on bit vectors then both over and the resulting formulae presents a general concrete semantics for floatingpoint operations to explain the propagation of errors in a computation in later work applies this concrete semantics and designed a static analysis for checking the stability of loops proposes an abstract approach to detect floating point errors and errors are considered and thus not considered real runtime errors summarizes the typical errors when using program analysis techniques to detect bugs in or verify correctness of numerical programs statically analyzes c programs and attempts to prove the absence of and other runtime errors both over integers and floatingpoint numbers also related are different approaches to model the floating point computation for numerical programs et al propose the use of affine arithmetic to model floatingpoint errors et al augment scala with two new data types which computes error bounds while remaining compatible with the double type and which generalizes to sets of inputs two projects that address floatingpoint accuracy problems are and a recent paper that dynamically floatingpoint values and operations with higher precision operands and operators in order to detect accuracy loss in particular ariadne these papers since its focus is the detection of floatingpoint exceptions not floatingpoint accuracy conclusion and future work we have presented our design and implementation of ariadne a symbolic execution engine for detecting floatingpoint runtime exceptions we have also reported our extensive evaluation of ariadne over a few scalar functions our results show that ariadne is practical primarily enabled by our novel combination of program rewriting to expose floatingpoint conditions and techniques for nonlinear constraint solving our immediate future work is to release the tool to benefit numerical software developers we would also like to investigate approaches to support functions such as those functions that accept or return vectors or matrices acknowledgments we thank mark david and the anonymous reviewers for constructive feedback on earlier of this paper we also thank william m and li for helpful discussions on this work this research was supported in part by nsf grants and and the us force grant fa the information presented here does not necessarily reflect the position or the policy of the and no should be inferred references f a and s a dynamic program analysis to find floatingpoint accuracy problems in pldi a d and t mixed abstractions for floatingpoint arithmetic in software to blame for problems p c and p h symbolic of floatingpoint and code in p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in popl p cousot r cousot j l a d and x the analyzer in esop d e daniel and automatic generation of tests for complex systems programs in e and v numerical computation in scala in oopsla l de and n z an efficient smt solver in tacas d e s j k and f towards an use of on software in c f t chen and r a floatingpoint error analysis based on affine arithmetic in c f r a m and t chen toward efficient static analysis of effects in applications via affine arithmetic modeling in m c t s and t efficient solving of large nonlinear arithmetic constraint systems with complex boolean structure ­ the multiple precision arithmetic library http scientific library v and d l a decision procedure for and arrays in cav p and j proving memory safety of floatingpoint computations by combining static and dynamic program analysis in p n and k dart directed automated random testing in pldi d what every computer should know about floatingpoint arithmetic acm computing e static analyses of the precision of floatingpoint operations in sas e and s static analysis of numerical algorithms in sas j handling floatingpoint exceptions in numeric programs toplas n j accuracy and stability of numerical algorithms society for and applied mathematics nd edition ieee computer society ieee standard for floatingpoint arithmetic d and l de solving nonlinear arithmetic in w a of for j c symbolic execution and program testing communications of the acm k n m and j de floating point constraint solving for symbolic execution in c and v llvm a compilation framework for program analysis transformation in r majumdar i and z wang systematic testing for control applications in m propagation of errors in finite precision computations a semantics approach in esop m static analysis of the numerical stability of loops in sas z computational science error why scientific programming does not compute nature ­ a relational abstract domains for the detection of floatingpoint runtime errors in esop d the of verifying floatingpoint computations toplas ­ k l fast and high precision volume in proceedings of the ieee world conference ieee p and t an theory of binary floatingpoint arithmetic in smt at k a unit testing engine for c in p h floatingpoint computation prenticehall 