common compiler optimisations are invalid in the c memory model and what we can do about it vafeiadis robin inria inria inria abstract we show that the weak memory model introduced by the c and c standards does not permit many common program transformations such as expression and reorderings that modern compilers perform and that are to be correct as such it cannot be used to define the semantics of intermediate languages of compilers as for instance llvm to we consider a number of possible local some strengthening and some weakening the model we evaluate the proposed by determining which program transformations are valid with respect to each of the models we provide formal coq proofs of their correctness or counterexamples as appropriate categories and subject descriptors d programming languages formal definitions and theory d programming languages language constructs and features keywords concurrency weak memory models cc compilers program transformations introduction programmers want to understand the code they write compilers and hardware try hard to it in concurrent systems even simple compiler optimisations like constant propagation can introduce behaviours the memory models of programming languages are designed to resolve this by which values can be returned when the system reads from shared memory however designing memory models is hard it requires finding a between providing an and portable execution model for concurrent programs to programmers while allowing common compiler optimisations it is wellknown that only programs that is programs in which two threads can access the same resource concurrently in conflicting ways can observe normal compiler and hardware optimisations a common approach for a programming language is permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm thus to require that code must exhibit only that is interleaving behaviours while code is undefined and has no semantics this approach usually referred to as data race freedom is to the programmer because under the hypothesis that the shared state is properly protected by locks he has to reason only about interleaving of memory accesses it is also to the compiler because it can code freely provided that it respects a study shows that it is indeed the case that in an model common compiler optimisations are correct these include elimination and reorderings of memory accesses and the socalled reorderings moving a memory access after a lock or before an unlock instruction intuitively the latter amounts to a critical section which should be obviously correct although the design is integrating it into a complete language design is not straightforward because additional complexity has to be taken into account for instance java relies on of pointers to enforce its security model and the java memory model must impose additional restrictions to ensure that all programs including programs some basic memory safety guarantees the resulting model is and fails to allow some optimisations implemented in the reference compiler despite efforts no satisfactory fix to has been proposed yet the recent memory model for the c and c languages from now on referred to as c is also based on the model since these languages are not type safe the java restrictions are unnecessary and both languages simply state that programs have undefined behaviour however requiring all programs to be via a locking mechanism is when it comes to writing lowlevel code for which c and c are often the languages of choice an escape mechanism called lowlevel atomics was built into the model the idea is to not consider conflicting atomic accesses as races and to specify their semantics by attributes annotated on each memory access these range from sequentially consistent sc which imposes a total ordering semantics to weaker ones as release rel and acquire which can be used to efficiently implement message passing and relaxed whose purpose is to allow performing single hardware loads and stores without the overhead of memory barrier instructions as a result accesses do not with one another and provide extremely weak ordering guarantees a common is that the c memory model enables all common compiler optimisations and indeed et al proved correctness theorem for and reorderings of nonatomic accesses holds in the c memory model the authors however did not consider transformations involving lowlevel atomic memory accesses compilers are in performing optimisations that involve atomic accesses for instance in gcc reorderings of sc atomic loads with nonatomic loads can be observed as a side effect of elimination while nonatomic and accesses a complete understanding of the validity of compiler optimisations in the c memory model is now a to guide not only the future standard evolution but also current compiler development in this paper we set out to perform an study of optimisations in the c memory model in particular we build on and extend the results of by considering optimisations that involve atomic accesses behind the corner standard transformations are invalid in c surprisingly and the common we discovered that the c model as defined in the cc standards and by et al does not validate a number of transformations that are performed by compilers and are intended to be correct as an in what follows we show that a simple transformation that adds synchronisation by two concurrent accesses cc c c is unsound even when c consists of a single nonatomic variable access most of our counterexamples exploit the causality cycles allowed by the c semantics to understand these first consider the following code r r lb in all our examples all variables are to before the parallel composition unless specified otherwise since relaxed atomic accesses by design do not race and do not it is reasonable to get r r at the end of some execution the memory accesses in each thread are independent and the compiler or the hardware might have them the c standard keeps track of relative ordering between the memory accesses performed during program execution via the happensbefore relation hb defined as the transitive closure of the program order and of the between actions of different threads nonatomic loads must return the last write in the hb relation this is unique in programs and guarantees a sequentially consistent semantics for programs with only nonatomic accesses for relaxed atomic accesses the of the standard are more and basically state that a relaxed load can see any other write which does not happen after it according to hb and which is not by another write effectively allowing the outcome r r above unfortunately the definition above enables some behaviours for instance the program below can terminate with x y as well if if again there are no and relaxed loads can see arbitrary stores however this in terms of compiler or hardware optimisations is harder the first thread might that x has value executing the store to y while the second thread that the value of y is executing the store to x the two threads then check if the was correct each others stores that justify the for simplicity we assume there are no consume atomic accesses a x y figure execution resulting in a x y several authors have observed that causality cycles make code verification infeasible we show that the situation is even worse than that because we can exploit them to show that standard program transformations are unsound consider a if if a if seq first notice that there is no execution consistent execution in the terminology of section in which the load of a occurs we show this by contradiction suppose that there is an execution in which a load of a occurs in such an execution the load of a can only return the initial value of a because the store a does not happen before it because it is in a different thread that has not been with and nonatomic loads must return the write that happens before them therefore in this execution the store to y does not happen which in turn means that the load of y cannot return and the store to x also does not happen then x cannot read and thus the load of a does not occur as a consequence this program is not since the load of a does not occur in any execution there are no executions with conflicting accesses on the same nonatomic variable we conclude that the only possible final state is a x y now imagine we apply the first two threads and moving the assignment to the start a if if a if running the resulting code can lead to an execution formally depicted in figure in which the load of a actually returns the value since the store to a now happens before via the load this results in the final state a x y which is not possible for the initial program consequences the example above is an instance of program transformation the semantics of both the source and target code are defined by the c memory model it might be argued that the main purpose of compiler is not to perform a translation but rather compile c programs to to three architectures and a correctness statement for a compiler should relate the c semantics of the source program to the semantics of the generated indeed if we compile the transformed code above using the standard mapping for lowlevel atomics for x or then the problematic new behaviour does not arise in practice to the best of our knowledge no modern relaxed architecture allows the causality cycle or the other of the c model we exploit built by the program labelled by to terminate with x y this implies that our counterexamples do not break compiler correctness statements in contrast to what happens in java however compilers compile c code into assembly code in just one pass our counterexamples imply that the c memory model cannot be used to give semantics to the intermediate languages used internally by a compiler as for instance the compiler to they also imply that reasoning about the correctness of program transformations cannot be done at the c level but must take into account the actual mapping of atomic accesses to a particular architecture architecture independent reasoning and preventing compositional reasoning about compiler passes the design of a memory model that causality cycles while enabling common compiler optimisation is currently a our counterexamples exploit a precise form of causality cycles involving control dependencies and not the most general form unfortunately it turns out that there is no simple local fix to the c model that makes all these transformations valid contributions and outline · we show that several transformations intended to be correct can introduce new behaviours in the c memory model the transformations we consider include strengthening and reorderings we present them and demonstrate that c them in section · we explore a number of possible local to the c model some strengthening and some weakening the model these involve replacing one c consistency axiom by another we them in section and study their basic metatheory in section these include the condition by boehm and as well as weaker conditions for each model in sections and we an study of the soundness of a wide class of program transformations involving reordering and of both nonatomic and atomic variables for each we either provide a proof of its correctness in the coq proof assistant with one exception or a counterexample for the condition in under an additional condition on sequentially consistent accesses all the intended transformations are valid the weaker conditions either some transformations or do not satisfy the theorem additionally we show that the side conditions on the memory attributes of the operations involved in each sound optimisation are locally maximal in that we have counterexamples for any weakening of them · we show that elimination of atomic accesses is unsound in the c memory model both in the current formulation and in the models section · our investigation also some corner cases of the c model which break important metatheory properties we discuss them together with possible in sections and to make the paper we recall the presentation of the c memory model and the to reason about program transformations in section we finally discuss related work in section the coq proof scripts and our appendix with the counterexamples are available at the following url abstract optimisations in c in this paper we are not looking at the actual algorithms used to implement compiler optimisations rather we are concerned by the effects of compiler optimisations on program executions we thus build on the representation of abstract optimisations introduced by and adapted to the c memory model in et al which we recall below the subsection refer to the relevant files in our coq development representation of programs to abstract from the syntax complexity of the c language we identify a source program with a set of descriptions of what actions it can perform when executed in an arbitrary context more precisely in a source program each thread consists of a sequence of instructions we assume that for each thread a threadlocal semantics associates to each instruction instance zero one or more shared memory accesses which we call actions the actions we consider ranged over by act are of the form skip w v r v v v a act tid where ranges over memory locations v over values and tid n over thread identifiers we consider atomic and nonatomic loads from denoted r and stores to w memory f c and allocations a of memory locations to simplify the statement of some theorems we also include a skip action each action specifies its thread identifier tid the location it affects the value read or written v when applicable and the written as a subscript when applicable we assume a labelling function lab that associates action identifiers ranged over by a b r w to actions in the we usually omit thread and action identifiers we introduce some terminology regarding actions a read action is a load or a a write is a load or an a memory access is a load store or where applicable we write for the memory order of an action for its thread identifier and for the location accessed we say an action is nonatomic iff its is na and iff it is sc an acquire action has or stronger while a release has rel or stronger the is stronger relation written pm o × m o is defined to be the least reflexive and transitive relation containing sc rel and the thread local semantics captures control flow dependencies via the sb relation which relates action identifiers of the same thread that follow one another in control flow we have b if a and b belong to the same thread and a precedes b in the threads control flow even among actions of the same thread the relation is not necessarily total because the order of evaluation of the arguments of functions or of the operands of most operators is in c and c the thread local semantics also captures thread creation via the relation that orders all the action identifiers of a thread after the corresponding thread fork which can be represented by a skip action the thread local semantics identifies each program execution a triple o lab sb called an as an example figure one for the program on the left and one for the program on the right both correspond to the executions obtained from an initial state where y holds and we omit consume atomics and sequentially consistent the semantics of the former is and at the time of writing no major compiler from their weaker semantics treating consume as acquire the semantics of the latter is despite their name sc do not guarantee sequential consistency even when placed between every two instructions this is because while they rule out the relaxed behaviour of the sb store example they permit those of the independent reads of independent writes example def x v rx v cx v v def v def def x v wx v cx v v def v def def def def na b def def def sc b def b def def rel b def a b b b c c b c b def c d b rf d a c c d b b hb def sb sw def a b a b b a observation def a b b world figure auxiliary definitions for a c execution lab sb rf mo sc a rf b rf sw b a sw c rf b rf b a rf d sw rf d b a c sw rf d rf d b figure illustration of the definition the four cases an sw edge the environment does not perform any write to the shared variables each read returns the last value written the set of all the of a program is an denoted by s we require to be s is if for every o for every read action r in the o for all values v there is an o in s which only differs from o because the read r returns v rather than v and for the actions that occur after r in sb intuitively an is if it defines a behaviour for each possible value returned by each read we additionally require to be assuming that a program can halt at any time formally we say that an o is a prefix of an o if there is an injection of the actions of o into the actions of o that behaves as the identity on actions preserves sb and and for each action x o whenever x o and sb y x it holds that y o program transformations abstract the syntax of programs by identifying each program with the set of actions it can perform in an arbitrary environment we can then the effect of an arbitrary source code transformation directly on on a given the effect of any transformation of the source code is to eliminate or introduce actions and modifying the sb and relations accordingly in the example in figure taken from et al the loop on the left is into the code on the right by loop invariant code motion as we said the figure shows for the initial state z y assuming that the code is not run in parallel with an context observe that the effect of the optimisation on the first is to eliminate the actions and to the stores to x thus mapping the of the code into an of the code an captures a possible execution of the program so by applying a transformation to an we are actually one particular execution lifting pointwise this definition of semantic transformations to enables all the execution paths of a program one at a time thus abstracting from actual source program transformation soundness of program transformations can then be by identifying the set of conditions under which eliminating reordering or introducing actions in the of an does for i i i z z y i x y t y x t for i i i z z t i figure effect of loop invariant code motion on an not introduce new observable behaviours we must thus define what it means to execute an executing programs cv the mapping of programs to only takes into account the structure of each threads statements not the semantics of memory operations in particular the values of reads are chosen arbitrarily without regard for writes that have taken place in our coq development we present such a mapping from programs to for a concurrent while language the c memory model then filters inconsistent by constructing additional relations and checking the resulting candidate executions against the axioms of the model for the subset of c we consider a witness w for an o contains the following additional relations the full model includes two additional relations dd data dependency and dependency ordered before used to define hb for consume reads a b b mo mo sc sc hb mo × sc b c rf b c a b a b rf b a v a b rf b a b a b rf b a a b x x x b a a a b rf b a a a b b a a b b b rf a a b b b a a b b rf a a b rf a b b a a b a a b where r def a ra a r r r p × p a b def ra b c ra c rc b r def a b p a p b a b ra b rb a b def b figure axioms satisfied by consistent c executions sb rf mo sc · the map rf maps every read action r to the write action w that the value read by r · the mo relates writes to the same location for every location it is a total order among the writes to that location · the order sc is a total order over all actions the standard calls this relation s from these relations c defines a number of derived relations written in the most important of which are the relation and the happensbefore order · sw relates each release write with the acquire reads that read from some write in its release sequence this sequence includes the release write and certain subsequent writes in modification order that belong to the same thread or are operations the sw relation also relates under similar conditions roughly speaking a release turns writes in sb into and an acquire turns preceding reads into acquires for details see the definition in figure and the illustration in figure · happensbefore hb is a partial order on actions the intuition that one action was completed before the other in the c subset we consider hb sb sw we refer to a pair of an and a witness o w as a candidate execution a candidate execution is said to be consistent if it satisfies the axioms of the memory model which will be presented the model finally checks if none of the consistent executions contains an undefined behaviour arising from a race two conflicting accesses not related by hb or a memory error accessing an location where two accesses are conflicting if they are to the same address at least one is a write and at least one is nonatomic programs that exhibit an undefined behaviour in one of their consistent executions are undefined programs that do not exhibit any undefined behaviour are called welldefined and their semantics is given by the set of their consistent executions consistent executions according to the c model a candidate execution lab sb rf mo sc is consistent if all of the properties shown in figure hold relates only actions the standard distinguishes between races arising from accesses of different threads which it calls data races and from those of the same thread which it calls races the standard says races can occur even between atomic accesses writes on the same location are totally ordered by mo the sc relation must be a total order over sc actions and include both hb and mo restricted to sc actions this in effect means that sc actions are globally the map rf is defined for those read actions for which the execution contains an earlier write to the same location each entry in the map rf should map a read to a write to the same location and with the same value if a read reads from a write and either the read or the write are nonatomic then the write must have before the read et al additionally require the write to be visible ie not to have been by another write that before the read this extra condition is unnecessary as it follows from sc reads are restricted to read only from the immediately preceding sc write to the same location in sc order or from a write that has not before that immediately preceding sc write the happensbefore order hb must be an action cannot happen before itself a read cannot read from a future write next we have four coherence properties relating mo hb and rf on accesses to the same location these properties require that mo never contradicts hb or the observed read order and that rf never reads values that have been by more recent actions that before the read accesses execute atomically they read from the immediately preceding write in mo the same location cannot be allocated twice by different allocation actions this axiom is sound because for simplicity we do not model deallocation the c model by et al does not even model allocation observable behaviour the observable behaviour of a candidate execution is the restriction of the mo relation to the distinguished world location if none of the candidate executions of a program exhibit an undefined behaviour then its observable behaviour is the set of all observable behaviours of its candidate executions in our counterexamples we often distinguish executions based on the final values of is valid because there could be a context program reading those values and writing them to world s sc sc sc sc r s s t t t behaviour in question r s t s t s t mo mo sc mo sc rf mo sc sc figure a consequence of the axiom strengthening the into sc introduces new behaviour invalid transformations in the introduction we discussed how a simple transformation rewriting cc c c can introduce new behaviours in c programs here we present other surprising problems that arise from program transformations strengthening is unsound a desirable property of a memory model is that adding synchronisation to a program introduces no new behaviour other than deadlock the following example shows however that replacing a relaxed atomic store with a release atomic store is unsound in c consider a if if if a if as in the seq program from section the load of a cannot return because the store to a does not happen before it and this time we can name the axiom responsible for this therefore the only final state is a z x y if however we make the store of z a release store then it with the acquire load and it is easy to build a consistent execution with final state a z x y a symmetric counterexample can be constructed for strengthening a relaxed load to an acquire load what is more interesting is that even in the absence of causality cycles strengthening an atomic access into a sequentially consistent one is unsound in general consider for example the program in figure where coherence of the relaxed loads in the final thread forces the to be as shown in the execution on the right of the figure now the question is whether the can read from the first store to x and return r in the program as shown it cannot because that store happens before the sc store which is the immediate store to x before the load if however we also make the be sequentially consistent then it becomes the immediately store to x and hence reading r is no longer blocked reorderings are unsound reorderings are a class of optimisations that let compilers move accesses to memory into blocks but not move them out the intuition is that it is always safe to move more computations including memory accesses inside critical sections in the context of c reorderings would allow moving nonatomic accesses after an acquire read which behaves as a lock operation or before a release write which behaves as an unlock operation however the following example program shows that in c it is unsound to move a nonatomic store before a release store rel a if if if a if as before the only possible final state of this program is a z and x y if however we the two stores in the first thread we get a consistent execution leading to the final state sw rf rf rf rf figure execution generating new behaviour if the expression evaluation order is a z x y again we can construct a similar example showing that reordering over an acquire load is also not allowed by c expression is unsound a simple variation of is expression evaluation order a transformation that adds an sb arrow between two actions of the same thread and that every compiler is bound to perform this transformation is unsound as demonstrated below t if t if if y rel the only possible final state for this program has all variables including t set to zero indeed the store y does not happen before the load of y which can then return only however if the t y is into t t t y then a synchronisation on x induces an order on the accesses to y and the execution shown in figure is allowed further c and proposed in this section we consider possible solutions to the problems identified in the previous section as well as to two other with the c model which however do not manifest themselves as invalid program transformations all of the models in this section as well as the relationships among them are in cv causality cycles and the axiom we first discuss possible solutions for the most important problem with c namely the interaction between causality cycles and the axiom naive fix a first rather naive solution is to permit causality cycles but drop the axiom as we will show in sections and this solution allows all the optimisations that were intended to be sound on c it is however of as it gives extremely weak guarantees to programmers the that programs whose sequential consistent executions have no data races have no additional relaxed behaviours besides the sc not hold as a counterexample take the program from the introduction replacing the relaxed accesses by nonatomic ones hb rf cycles a second much more reasonable solution is to try to rule out causality cycles out causality cycles while allowing loops in hb rf is however difficult and cannot be done by stating additional axioms over single executions this is essentially because the execution of the program from the introduction is also an execution of the lb program also from the introduction as an approximation we can rule out all hb rf cycles by stating the following axiom a b rf b a this solution has been proposed before by boehm and and also by vafeiadis and here however we take a different approach from the proposals in that besides adding the axiom we also drop the problematic axiom in sections and we show that this model allows the same optimisations as the naive one ie all the intended ones except the reordering of atomic reads over atomic writes it is however known to make relaxed accesses more costly on as there must be either a branch or a lightweight between every shared load and shared store only nonatomic cycles another approach is to instead make more behaviours consistent so that the nonatomic accesses in the seq example from the introduction can actually occur and race the simplest way to do this is to replace by rf b b b a nonatomic load can read from a concurrent write as long as it does not cause a causality cycle this new model has several nice properties first it is weaker than c in that it allows all behaviours permitted by c this entails that any compilation strategy proved correct from c to hardware memory models such as to and power remains correct in the modified model contrary to the previous fix theorem if then proof straightforward since by the condition rf b b b hb and hence follows from second this model is not much weaker than c more precisely it only allows more behaviours theorem if and not then x note that the definition of executions does not depend on the axioms of the model and is thus the same for all memory models considered here finally it is possible to reason about this model as most reasoning techniques on c remain true in particular in the absence of relaxed accesses this model is equivalent to the model we are thus able to use the program logics that have been developed for c namely and to also reason about programs in the model however we found that reordering nonatomic loads past nonatomic stores is forbidden in this model as shown by the following example if t a b if t if if b a in this program the causality cycle does not occur because for it to happen an hb rf cycle must also occur between the a and b accesses and that is out by our axiom however if we swap the nonatomic load of a and store of b in the first thread then the causality cycle becomes possible and the program is introducing a race is clearly unsound so compilers are not allowed to do such reorderings note that these accesses are nonatomic and adjacent it is not clear whether such a constraint would be acceptable in cc compilers the axiom as we have seen in the counterexample of figure the axiom places an odd restriction on where a sequentially consistent read can read from the problem arises from the case where the source of the read is a write in this case the axiom that write to happen before the immediately write to the same location it may however happen before an earlier write in the sc order we propose to the axiom by requiring there not to be a happens before edge between rf b and any write to the read as follows a b rf b a a b x x b going back to the program in figure this stronger axiom rules out reading r a guarantee that is provided by the suggested of c atomic accesses to we also considered an even stronger version where instead of hb the axiom mo as in the coherence axioms but this axiom is unsound for the suggested compilation of c atomic accesses to the power and arm architectures strengthening the release sequence definition the definition of release sequences in the c model is too weak as shown be the following example y rel if in this program assuming the test condition holds the acquire load of x need not with the release store even though it reads from a store that is after the release and hence the program is the reason is that the irrelevant store of can interrupt the release sequence as shown in the following execution mo mo sb mo rf in the absence however of the first thread the acquire and the release do and the program is welldefined as a fix for the release sequences definition we propose to replace the definition of release sequences by the least fixed point of the following recursive definition with respect to b def a b b b rf b our release sequences are not defined in terms of mo sequences but rather in terms of rf sequences either b should belong to the same thread as a or there should be a chain of actions reading from one another connecting b to a write in the same thread as a in the absence of accesses this change the semantics every consistent execution in the revised model is also consistent in the original model despite being a strengthening it does not affect the compilation results to x power and arm the reason is that release sequences do not play any role on x while on power and arm the compilation of release writes and issues a memory barrier that affects all later writes of the same thread not just an of such writes allowing synchronisation a final change is to remove the slightly odd restriction that actions from the same thread cannot this change allows us to give meaning to more programs in the original model the following program has undefined behaviour define f x y rel f x y f x y that is although f uses x as a lock to protect the increments of y and therefore the y accesses could never be adjacent in an interleaving semantics the model does not treat the as because they belong to the same thread thus the two increments of y are to race with one another as we believe that this behaviour is highly we have also considered an adaptation of the c model where we set b def b rather than we have proved that with the new definition we can drop the b conjunct from the sw definition without hb since by the axiom every sb edge has the same thread identifiers the change also the model by assigning defined behaviour to more programs summary of the models to be considered as the four problems are independent and we have proposed to each problem we consider the product of the § § § × × × we use tuple notation to refer to the individual models for example we write for the model corresponding to the c and c standards in sections and we show that the and components despite further the set of consistent executions permit all the transformations allowed by the and components respectively basic metatheory of the c models in this section we develop basic metatheory of the various to the c model which will us in verifying the program transformations in the next sections the subsection mention the coq source file containing the corresponding proofs executions we observe that in the monotone models see definition the happensbefore relation appears in all axioms except for the direction of the axiom it turns out however that this apparent lack of monotonicity with respect to happensbefore does not cause problems as it can be by the following lemma this restriction breaks monotonicity in the presence of consume reads definition executions an execution is with respect to a model m iff it satisfies all the axioms of the model except for the direction of the axiom lemma given a execution o rf mo sc with respect to m for m there exists rf rf such that o rf mo sc is consistent with respect to m proof we pick rf as the greatest fixed point of the functional f rf x rf x undefined if y x otherwise that is smaller than rf with respect to such a fixed point exists by theorem as the function is monotone by construction it satisfies the axiom while all the other axioms follow easily because they are in rf monotonicity we move on to proving the most fundamental property of the models monotonicity saying that if we weaken the access modes of some of the actions of a consistent execution andor remove some sb edges the execution remains consistent definition access type ordering let pm o × m o be the least reflexive and transitive relation containing rel sc and we lift the access order to memory actions × ev by letting act act rx v rx v wx v wx v cx v v cx v v fx fx and skip fx whenever x x we also lift this order to functions pointwise lab lab iff a monotonicity does not hold for all the models we consider but only after some necessary have been applied we call those models monotone definition we call a memory model m monotone iff m and m theorem monotonicity for a monotone memory model m if lab sb rf mo sc and lab lab and sb sb then there exist rf rf and sc sc such that lab sb rf mo sc proof sketch from lemma it suffices to prove that the execution lab sb rf mo sc is we can show this by y def y we can show that hb hb and then all the axioms of the model follow straightforwardly from theorem we can immediately show the soundness of three simple kinds of program transformations · expression evaluation order and because in effect they just add sb edges to the program · strengthening of the memory access orders such as replacing a relaxed load by an acquire load and · insertion because this can be seen as replacing a skip node an empty by a stronger hb x a rf hb b a hb mo b c rf a mo rb hb rf db c mo a rb rf hb b a hb rf b mo c rf a a c mo a rf mo b rf mo b figure executions the coherence axioms all contain a cycle in a b hb com alternative presentation of the coherence axioms next we consider equivalent alternative of the coherence axioms which can be used to gain better understanding of the models and to simplify some proofs about them since mo is a total order on writes to the same location and hb is the axiom is actually equivalent to the following one a b b b the equivalence can be derived by a case analysis on how mo orders a and b for what it is worth the cc standards as well as the formal model of et al include both axioms even though as we show one of them is redundant next we show that the coherence axioms can be in terms of a single axiom to state this axiom we need some auxiliary definitions we say that a read a reads before a different write b denoted b if and only if a b and a b note that we need the a b condition because actions are simultaneously both reads and writes we define the communication order com as the union of the modification order the map and the relation b def a b a b b def b rf b a b in essence for every location com relates the writes to and reads from that location except for reads and loads reading from the same write com is a total order on all accesses of a given location we observe that all the violations of the coherence axioms are cyclic in a b hb com see figure this is not from and we know that any execution acyclic in hb com is sequentially consistent and coherence essentially guarantees sequential consistency on a basis based on this observation we consider the following axiom stating that the union of hb restricted to relate actions and com is acyclic b hb com this axiom is equivalent to the conjunction of c axioms as shown in the following theorem theorem assuming and hold then proof sketch in the direction it is easy to see that all the coherence axiom violations exhibit cycles see fig in the other direction careful analysis reveals that these are the only possible larger ones can be as mo is a total order et al call this relation although the alternative presentation of the coherence axioms developed here is much more concise than the original one it is of limited use in verifying the program transformations because we need to reason about yet another transitive closure besides hb prefixes of consistent executions another basic property we would like to hold for a memory model is for any prefix of a consistent execution to also form a consistent execution such a property would allow for instance to execute programs in a operational fashion generating the set of consistent executions along the way it is also very useful in proving the theorem and the validity of certain optimisations by an alternative execution prefix of the program that contradicts the assumptions of the statement to be proved eg by containing a race one question remains under which relation should we be considering execution prefixes to make the result most widely applicable we want to make the relation as small as possible but at the very least we must include the dependent part of the program order sb and in order to preserve the program semantics as well as the reads from relation rf in order to preserve the memory semantics moreover in the case of models as shown in the example from section we must also include definition prefix closure we say that a relation r is prefix closed on a set s iff a b ra b b s a s definition prefix an lab sb is a prefix of another lab sb iff lab lab sb sb × × and sb and are prefix closed on theorem given a model m o and o lab and a witness w rf mo sc if o w and o is a prefix of o and a b rf b a is on and either m or mo is on then there exists w such that o w proof sketch we pick w to be w restricted to the actions in then we show hb hb × and that each consistency axiom is preserved to be able to use such a theorem in proofs the relation defining prefixes should be acyclic this is because we would like there to exist a maximal element in the relation which we can remove from the execution and have the resulting execution remain consistent this means that for example in the model we may want to choose hb rf as our relation unfortunately however this does not quite work in the model and requires switching to the model verifying instruction reorderings we proceed to the main technical results of the paper namely the proofs of validity for the various program transformations having already discussed the simple ones we now a b thm thm a a thm a thm thm a a a a a a a a a a a thm a thm thm thm thm a thm a thm a thm a thm thm a thm a thm a thm thm a a a a a a a a a a a thm a a a a a a a a a thm thm thm a thm a thm thm table allowed a b a b in monotone models and therefore reorderings a b b a we assume where multiple entries are given these correspond to the appropriate theorem the counterexample question marks correspond to unknown cases we conjecture these are valid but need a more elaborate definition of prefixes to prove focus on transformations that adjacent instructions that do not access the same location we observe that for monotone models a reordering can be decomposed into a followed by a a b under some conditions a b by theorem b a we the allowed in table there are two types of allowed updates § instruction reorderings and § reorderings against the semantics for the negative cases we provide counterexamples in the appendix instruction reorderings the reorderings are the among those in table and are annotated by thm this category contains all pairs of actions a and b that are adjacent according to sb and we say that two actions a and b are adjacent according to a relation r if every action directly reachable from b is directly reachable from a every action directly reachable from a except for b is also directly reachable by b every action that reaches a directly can also reach b directly and every action that reaches b directly except for a can also reach a directly note that adjacent actions are not necessarily related by r definition adjacent actions two actions a and b are adjacent in a relation r written a b if for all c we have rb c ra c and ra c c b rb c and rc a rc b and rc b c a rc a two actions a and b are if they belong to the same thread they do not access the same location a is not an acquire access or b is not a release access or if the model is based on or and a is a read then b is not a write if a is a release then b is not an atomic write if b is an acquire then a is not an atomic read and a and b are not both sc actions definition pair two distinct actions a and b are in a memory model m written a b if and and and and i and ii and and and theorem for a monotone m if sb w a b a b and a b there exists w i lab sb a b w ii w w and iii lab sb w lab sb a b w proof sketch by lemma it suffices to show the main part is then proving that hb hb a b where hb resp hb denotes the happensbefore relation in lab sb a b w resp lab sb w hence these transformations do not really affect the behaviour of the program and the preservation of each axiom is a simple corollary the proof of theorem and similarly those of theorems and in section require only conditions and from the definition of adjacent actions conditions and are however important for the theorems of section and so for simplicity we presented a single definition of when two actions are adjacent reorderings with the second class is of a few valid reorderings between a and a memory access of the same or stronger type in contrast to the previous set of transformations these new ones remove some synchronisation edges but only to instructions as do not access any data there are no axioms these incoming and outgoing synchronisation edges to and from and hence they can be safely removed theorem for a monotone m if sb w a b a b and then i lab sb a b w and ii lab sb w lab sb a b w theorem for a monotone m if sb w a b a b and then i lab sb a b w and ii lab sb w lab sb a b w that is we can an acquire command over an acquire and a release over a release command thm rel thm rel verifying instruction next we consider eliminating redundant memory accesses as would be performed by standard optimisations such as common subexpression elimination or constant propagation to simplify the presentation and the proofs in § we first focus on the cases where eliminating an instruction is justified by an adjacent instruction eg a repeated read or an immediately write in § we will then the general case consider the following program x y t t t t the outcome t t t t is not possible if however we remove the then this outcome becomes possible x y mo mo rf sw mo rf rf x y mo mo rf rf rf rf figure counterexample for the write after read elimination optimisation elimination of redundant adjacent accesses repeated read the first transformation we consider is eliminating the second of two identical adjacent loads from the same location informally if two loads from the same location are adjacent in program order it is possible that both loads return the value written by the same store therefore if the loads also have the same access type the additional load will not introduce any new synchronisation and hence we can always remove one of them say the second rx v rx v rx v skip formally we say that a and b are adjacent if a before b and they adjacent according to sb and that is b def b a b a b we can prove the following theorem theorem for a monotone memory model m if lab sb w b rx v skip and lab rx v then there exists w such that i lab sb w ii w w and iii lab sb w lab sb w this says that any consistent execution of the target of the transformation can be mapped to one of the program prior to the transformation to prove this theorem we pick rf rf b rf a and extend the sc order to include the a b edge in case x sc read after write similarly if a load immediately follows a store to the same location then it is always possible for the load to get the value from that store therefore it is always possible to remove the load wx v ry v wx v skip formally we prove the following theorem theorem for a monotone memory model m if lab sb w b wx v skip lab ry v and either y sc or m then there exists w such that i lab sb w ii w w and iii lab sb w lab sb w write if two stores to the same location are adjacent in program order it is possible that the first store is never read by any thread so if the stores have the same access type we can always remove the first one that is we can do the transformation wx v wx v skip wx v to prove the correctness of the transformation we prove the following theorem saying that any consistent execution of the target program corresponds to a consistent execution of the source program theorem for a monotone memory model m if lab sb w and b and skip and wx v and lab wx v and world then there exists w such that i lab sb w ii w w and iii lab sb w lab sb w note that as a special case of this transformation if the two stores are identical we can alternatively remove the second one wx v wx v skip wx v wx v skip write after read the next case to consider is what happens when a store immediately follows a load to the same location and writes the same value as observed by the load rx v v rx v skip in this case can we eliminate the redundant store well actually no we cannot figure shows a program that the transformation is unsound the program uses an atomic instruction cas to update x in parallel to the thread that reads x to be and then writes back to x consider an execution in which the load of x reads enforced by t the cas succeeds enforced by t and is in modification order after the store to x enforced by t and the axiom then because of the atomicity of cas axiom the cas must read from the first threads store to x a synchronisation edge between the two threads as a result by the axiom the load of y cannot read the initial value ie necessarily t if however we remove the store to x from the left thread the outcome in question becomes possible as indicated by the second execution shown in figure in essence this transformation is unsound because we can force a operation to be ordered between the load and the store according to the communication order in the counterexample we achieved this by the atomicity of instructions we can also construct a similar counterexample without operations by exploiting sc a more advanced feature of c which for simplicity we do not model in this paper elimination of redundant operations we proceed to the general case where the removed redundant operation is in the same thread as the operation its removal but not necessarily adjacent to it in the appendix we have proved three theorems the theorems of section the general set up is that we consider two actions a and b in program order ie b accessing the same location ie without any intermediate actions accessing the same location ie c c b in addition for the of theorems and respectively of lemma we also require there to be no acquire respectively release operation in between under these conditions we can the action to be eliminated using theorem past the intermediate actions to become adjacent to the action so that we can apply the adjacent elimination theorem then we can the resulting skip node back to the place the eliminated operation was initially related work the c model was introduced by the of the c and c standards a rigorous mathematical of the c memory model was given by et al and was later extended to cover and instructions sample compilation schemes for atomic accesses have been proved correct both for the architecture and for the architecture the aim here was to study how expensive it is to enforce the intended c semantics on architectures the compiler considered applies a mapping from c memory accesses to machine memory accesses no optimisations at all behaviours are being as the most corner of the design of modern language memory models the java memory model tried to effectively results in its specification complicated causality rules were introduced for this purpose which turned out to some program transformations that the reference compiler actually performs the work is closely bound to the of the java memory model and his counterexamples cannot be translated to c the existence of causality cycles is in the c and c language standards and is stated clearly in sec since then independent lines of research including program logics and model checkers into issues related to causality cycles it is that code verification is infeasible in their presence it turns out that it is very difficult to define a language memory model that both allows programmers to take full advantage of memory accesses but still correctly results the for an updated model for java is still open it is the objective of the but no concrete design has yet been proposed surprisingly the simpler requirements of the c language did not lead to a quick fix a solution preventing relaxed loads from being with subsequent relaxed stores has been proposed by boehm and by vafeiadis and which we also studied in this paper this condition imposes a cost on some architectures arm and its adoption in the standard is as already mentioned the study of correctness of compiler optimisations in an model was done and later adapted to c for some optimisations by et al this paper uses the same but in a far greater depth the interaction between optimisations and lowlevel atomic accesses with the surprising results presented the certified compilers compcert and the latter extending an earlier version of the former to concurrent shared memory programming with a memory semantics share the same memory model for all the intermediate languages a compiler could not use the c memory model for this purpose expression is performed in the first pass of compcert and as we have shown it cannot be proved correct in the c model unless the c model is fixed along the lines we discussed the would have to expand the compilation of atomic accesses immediately after parsing and then reason in terms of the target architecture memory model this is not an option for an efficiently implementable general purpose programming language hardware memory models are not models and prevent most optimisations on memory accesses acknowledgements this work is supported by the ec fp project and the grant we would like to thank peter sewell and the anonymous reviewers for their helpful feedback references j l and m modelling simulation testing and for weak memory toplas ­ m m and a library abstraction for cc concurrency in popl m k s s sarkar and p sewell and compiling cc concurrency from c to power in popl m s s sarkar p sewell and t c concurrency in popl boehm n specifying the absence of out of results available at boehm and b avoiding results in programming language c programming language c x leroy formal verification of a realistic compiler cacm ­ j w and s v the java memory model in popl r p and f compiler testing via a theory of sound optimisations in the cc memory model in pldi b and b checking concurrent data structures written with cc atomics in oopsla s sarkar k s m p sewell l j and d cc and power in pldi pages ­ acm d and m efficient and correct execution of parallel programs that share memory toplas ­ a v vafeiadis and d dreyer with protocols and separation in oopsla v vafeiadis and c relaxed separation logic a program logic for c concurrency in oopsla js the sun jvm does not with the java memory model technical report school of university of edinburgh js safe optimisations for concurrent programs in pldi js and d on validity of program transformations in the java memory model in ecoop js v vafeiadis f s and p sewell a verified compiler for concurrency j acm ­ june 