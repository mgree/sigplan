expressiveness of the operation set of a data abstraction lab for computer science massachusetts institute of technology cambridge ma abstract in a strongly typed system supporting user defined data abstractions the designer of a data abstraction to be careful in choosing the operations for the abstraction if the operation set chosen is not expressive enough it might be impossible or to implement certain useful functions on the values of the data abstraction in this paper we characterize the expressive power of the operation set by defining two properties for data abstractions expressive completeness and expressive the operation set of an complete data abstraction is adequate enough to implement all computable functions on its values an rich data abstraction is complete with an operation set that is rich enough to extract from a value all relevant information required to the value from practical applications of the properties of expressiveness introduced are also discussed introduction an important feature of a data abstraction is the constraint that the values of the abstraction can be constructed and observed only by the applications of its operations this feature by the use of a data abstraction from its implementation supports modular development of software it also program verification by to decompose proofs into small and independent this research supported in part by the advanced research projects of the department of by the of the research under contract and in part by the national science foundation under grant ao to work or are copies the to prior r a is by permission of machinery requires a to copy fee and or specific permission acm units however the very same feature can make the use of a data abstraction restrictive if the operation set of the abstraction is not designed carefully this is especially so in a programming environment where a programmer is to build on the abstractions provided by other programmers if the operation set of an abstraction is not expressive enough to discover all the properties of the values of the abstraction it might be impossible or to implement several useful functions on the values consider the following design of the familiar immutable set n abstraction where for the abstraction number the definition of set n is given in appendix i set is null insert remove has max equal null returns the empty set insert returns the set obtained by inserting a given number into a given set remove returns the set which is obtained by removing a given number from a given set has tests the membership of a given number in a given set empty tests if a given set is empty max returns the largest number of a given set equal tests if its two given sets are identical with a little bit of thought it is possible to that the above set of is adequate to discover all the properties of set n values now consider the following two alternative designs of set n which are obtained by some of the operations from the above design the operations common among the three designs have the same meaning note that all three designs have the same value set which is the set generated by null and insert since all the values are in each of the cases is null insert is null insert equal in the second design the operation set is not expressive enough to discover all properties of the set values for instance it is impossible to implement the remove operation in terms of the given operations the third design can be shown to be logically as powerful as the first one but in this case the implementations of even simple functions not provided such to be so and that the design is from a practical point of view how can one characterize this notion of expressiveness of the operation set of a data abstraction how does one determine if the operations of a data abstraction form a fully expressive set or not can one distinguish between the expressiveness of the operation sets of different designs of the same data abstraction such as designs and morris is the first one to have some of these questions he proposed that a new data type should be in the sense that the primitives ie the operations are adequate to translate between the new type and any other existing type such as integers he introduced and read transfer functions from the new type to integers the difficulty of implementing the primitive operations of the new type in terms of the existing type using the transfer functions gives an of how expressive the operations of the new type are his characterization is very informal and it does not distinguish between situations such as design and design in the above example in this paper we formally characterize what it means to say the operation set of a data abstraction is fully expressive we define two properties of a data abstraction related to the expressiveness of its operation set expressive completeness and expressive the second property is stronger than the first we will be able to distinguish among the three designs of set n mentioned earlier using the above two properties we will see that the second design is not even complete while designs and are however design is rich but design is not the purpose of introducing the notion of a design is to compare the expressiveness of subsets of the operation set of a data abstraction a design of a data abstraction is defined so that it has the same behavior of the data abstraction while its operation set is a subset of that of the data abstraction the properties of expressiveness discussed in the paper are strictly speaking the properties of a particular design of a data abstraction however at several places in the paper the reader may find the properties being associated with a data abstraction when we do this we actually mean the expressiveness of the design whose operation set is identical with that of the data abstraction this notion of completeness should not be with the completeness property of a specification of a data abstraction the properties discussed in the paper are properties of data abstractions and are independent of the specification technique used to specify data abstractions an extended overview in the next chapter we discuss a few preliminary concepts and state the assumptions made in the paper about the behavior of a data abstraction we precisely define the value set of a data abstraction and describe what we mean by different designs of a data abstraction in the third chapter we formalize the notion of expressive completeness we wish that the operation set of an complete data abstraction allow us to discover all interesting properties of the values since programmers are going to be interested only in computable properties we require that the operation set of an complete abstraction be expressive enough to implement all computable functions over the value set of the data abstraction we specify what it means for a function to be implementable by the mechanisms from which the function to be built the remaining step in the process of formalization therefore is to define and computable functions over the value set of a data abstraction we do this by reducing the over an abstract domain to over the set of natural numbers for this we use a scheme to encode the values of the data abstraction as natural numbers every function on the abstract value set can then be mapped to a corresponding function on natural numbers a function over the abstract value set is considered to be computable if its image function is computable over the set of natural numbers the main result of this chapter is theorem which states that if the operation set of a data abstraction d consists of computable operations only and the equal predicate on d which computes the identity relation on the value set of d can be implemented in terms of the operation set then d is complete the theorem enables us to define a minimal set of operations that makes an abstraction complete in the fourth chapter we introduce the notion of expressive of the operation set of a data abstraction the motivation for this arises because of the existence of several complete data abstractions whose operation sets are not enough to be of any practical use we wish that an rich data abstraction be complete with an operation set that is rich enough to extract all relevant information from a value to formalize this notion of we identify a set of functions called distinguished functions associated with every abstraction the distinguished functions permit one to extract from any given value all information required to it there are two kinds of information that one needs to know how to construct a value we need to have a set of values of other types which is used in the construction of the value secondly we need to know the constructors and the order in which they should be used in creating the value we define two kinds of distinguished functions the and the to extract the above two pieces of information respectively an rich data abstraction is defined as one in which every distinguished function can be implemented in terms of the operation set using only composition and conditional expressions we believe that if the distinguished functions can be implemented in terms of the operation set then so can most of the other useful functions on the data abstraction we show that a data abstraction that is rich has the desired logical power by proving that it is also complete the final chapter discusses a few practical applications of data abstractions that are rich according to our characterization assumptions and preliminary concepts assumptions informally speaking we view a data abstraction abstract data type data type type d as consisting of a set of values and a finite set of operations to create and manipulate those in this paper we consider only immutable data types we denote the operation set of d by normally the definition of d involves other data types these data types appear as the domains andor range of the operations of d we call these types the defining of d and denote their collection by a we refer to d itself as the defined we assume that every operation in q yields exactly one value the operations that yield values of type d are called the remaining operations are called constructors which do not take any arguments of the defined type are called basic the remaining constructors are called we assume that every operation of d is total and does not signal any exception this assumption is made only for convenience since the properties proposed in the paper can be extended to handle exceptions once a suitable model for characterizing the behavior of a data type is adopted in the examples discussed in the paper we have arbitrarily decided on some normal behavior for an operation on certain inputs on which the operation would otherwise have an exception definition data abstraction heterogeneous algebras are a natural way to model the behavior of a data type l a heterogeneous algebra data type d consists of i corresponding to d and a domain corresponding to every defining type in and ii a function corresponding to every operation in il we take a behavioral view for defining the semantics of a data type first by and later developed by according to this view every value of d is created by finitely many applications of the constructors of d the values are only of d is defined as a set of equivalent heterogeneous every algebra in the set is called a the data type two algebras are informally speaking equivalent if they have the same observable behavior as expressed by their corresponding to d in a model defines a set of d in the context of a model by a value of d we mean an element of the value set the observable behavior of a model is characterized in terms of the relation on values the relation is defined inductively in terms of the of the values of the defining types the basis of this induction is the data type bool that does not have any defining types the only two values true and false of bool are assumed to be two values of a model are if and only if there is a sequence of operations of d with an as the outermost operation that produces results when applied separately on the values if two values are not they are equivalent observable equivalence relation and hence can be used to define a set a set of equivalence classes on every domain of a model furthermore the observable equivalence relations are preserved by the functions in the two models are equivalent if the models induced by the observable equivalence relations are isomorphic to each other specify the behavior of a data type by presenting a model for it data types used as examples in the paper are all defined in appendix i in this fashion set in this paper when we discuss an arbitrary data type d we use a standard model for it whose value set is constructed in terms of sequences of constructors of d the advantage in using this value set is that its method of construction is generally applicable better suited to the formalization of on data types the construction of this value set is explained below every sequence composition of constructors of d creates a value of d and hence can be used to denote that value sequence of word several different this view abstraction of which merely abstracts from the representations of the values in an algebra a data type in their view is defined as a set of heterogeneous algebras the behavioral view is closer to the view taken in programming languages supporting data types words may create equivalent values let denote the set of all finite words of d we drop the index whenever it is evident from the context w is constructed inductively by assuming that the word set is given for each of the defining types a data type with no defining types serves as the basis let e stand for the observable equivalence relation on w we use the set we as the standard value set also denoted as v except in case of the models given in appendix i whenever we refer to the value set of d we mean its standard value set by a function of d we mean a function on the word set w that preserves the equivalence relation e so a function f cm w that preserves e can be viewed as a function f on v we such that fw fw where w is the equivalence class containing w w is a value of d the same view can be extended to functions with several arguments for example the equivalence relation e w x w bool can be viewed as the equality predicate on v that tests whether two values are identical we denote the equality predicate on d by equal or different designs of a data type given a definition of d a design of d is a variant of d whose operation set q is a subset of q the operations in should be such that they can create and distinguish all the values in we we will present a design by giving its operation set for example for with q null insert remove has empty max equal the following are some of the possible designs q is itself a design o null insert has null insert equal however null insert remove max is not a design because it cannot distinguish all the values of we for instance two different sets with identical maximal elements are not by the idea behind the definition of the design of a data type is to capture the nature of the designing process of the data type when a designer designs a data type he normally starts out by a value set for it and a set of constructors to generate the values then he starts designing other operations since operations are the only means of creating and observing the values the in and view the of values is not defined in terms of the behavior of the operations instead an equivalence relation on words is independently defined if two words are not related they are of whether they can be distinguished by the operations in the behavioral sense the discussion and the results of the paper can be applied to this view es well by using the given in the observable equivalence relation e designer at the least needs to provide enough operations to distinguish among the values later with increasing experience the designer the operation set by adding more operations all along his initial of the value set remains unchanged we study the expressiveness of various operation sets by comparing the expressiveness property of different designs of a data type as pointed out earlier the properties of expressiveness are properties of a particular design of a data type at several places in the paper when we are not comparing the expressiveness of subsets of the operation set of a data type we simply associate the property with the data type and make references such as an complete data type etc when we do this we actually mean the expressiveness of the design whose operation set includes all the operations of the data type expressive completeness in this chapter we discuss the expressive completeness of the operation set of a data type in the first section we formally define expressive completeness in terms of over the value set of a data type in the second section we characterize over an abstract domain by reducing it to over the set of natural numbers the third section proves a useful result about expressive completeness the last section illustrates the definitions and results by discussing several examples definition of expressive completeness we wish an complete data type d to permit all computable functions of d to be implementable in terms of its operations following we only use the simple mechanisms of functional composition conditional expression and recursion to implement a function on d in terms of a given set of functions auxiliary functions are also allowed as functions let denote the collection of functions implementable in terms of a set f of functions on a data type it is important to notice a subtle difference in the method of definition for functions used by us and the one widely used in the literature on in the latter functions are defined using a scheme that assumes a pattern matching mechanism to reveal the top level structure of the argument value for example the addition function denoted by on n is defined as r xo x x sy s sx y we instead take an abstract view which indeed is the view taken by a programming system supporting data types the internal structure of a value is not explicit any information about a value must be obtained through its operations every operation we use has to be either an explicit part of the operation set of d or be implementable in terms of the operation set in our approach for example would be implemented in a manner as x px px y e if y o then x sx py if x o then o else px o z if x sz then z else px sz where notice that the above implementation of is given in terms of o s and p p is defined as an auxiliary function in terms of o s and however it seems that the definition of above did not need and p these functions are implicit in the pattern matching mechanism used by the definition let denote the class of all computable functions on the value set of d on d is defined in the next section then we have definition a data type d is complete if cq for example it is known that co s thus corollary the data type n whose operation set il o s is complete using the definition of over of we also get the following corollary type whose operation set il nil car cdr cons null is complete we were able to obtain the in the readily because over n and has been formally characterized in the literature however the notion of has not been formally characterized for an arbitrary datatype d the next section addresses this issue over abstract domains if the value set v is finite the notion of is trivial since every function be specified finite table and is thus computable below we shall concentrate on a d whose v is infinite our strategy is to reduce over natural numbers on w a computable function preserves e is a computable function on d on d to we define on w that we define on w by means of an effective function q w n that encodes every word into a natural number we call q an encoding function for d and ql a function for d every function on w can be viewed via n as a function on n an q for d is constructed inductively using an n for each of its defining types the basis of this induction is a data type having no defining types for which an v can be constructed in a straight forward manner definition given a f w w its image n n via q is defined as fn the concept of an image of a function on d can be extended to functions defined over several domains by making use of an scheme for each of the domains involved in the definition using thesis we have definition a function f w w is computable if there exists an encoding v such that the image of f via o is computable over n the above definition of on w has the following desirable property theorem the set all computable functions on w is invariant with respect to the encoding function chosen proof we show that any two different encoding functions define the same set of computable functions on w we show that for every pair of encodings o and qz there exist computable functions t and t on n which behave as follows t maps the code of a word associated by to that associated by does the mapping in the opposite direction it can be shown that the image of a function f via q can be constructed from the image of f via and vice versa using t z and t definition a function f of d is computable if f on w is computable and f preserves the equivalence relation e defines on v directly his abstract thesis can be shown to be equivalent to our definition of we believe our approach is simpler and more natural we concern ourselves only with data types having computable operations as the ones with operations are of no practical interest furthermore if a data type has operations it cannot be complete since the word set of a data type is always recursive having all the operations computable makes the value set recursively enumerable a useful result here we prove a useful result about the expressive completeness of the operation set of a subclass of data types for which is decidable a set s is its characteristic function which checks whether element is in s or not is total computable s i recursively enumerable re if it is the range of a total computable function in other words an re set s can be generated by a total computable function theorem assuming that i for d and for each of its defining types the equal predicate is decidable and ii every defining type of d is complete d is complete if the equal predicate on d is implementable in terms of its operation set fl the proof of the above theorem follows immediately from the following theorem which states that if equal is an operation of d then d is complete this is so because if equal then fl u equal theorem assuming that i for each of the defining types of d the equal predicate is decidable and ii every defining type of d is complete d is complete if the operation set of d includes the equal predicate on d proof see appendix ii theorem can be used to show the following corollary a minimal set of operations that makes a data type d complete is o u equal where is a minimal set of constructors sufficient to generate the value set of d examples in the following examples we investigate the expressive completeness of different designs of stack n and set n data types see for definitions of these data types the operation set of each of them includes only computable operations this can be inferred by intuition as well as shown formally using the method discussed above in each of the following cases we just need to see if it is possible to implement the equal predicate for the type or not the following designs are complete stack n is null push pop top empty vz if then else if then false else set n is null insert remove has empty v v o v i if then else if then false else if i i then i i il else false the following designs are not complete because equal is not implementable in terms of their operations in both the following cases it is possible to apply the above algorithm to find an answer when the two sets are however when the sets are equal the algorithm does not terminate because of the absence of the operation empty in the first case and the absence of the operation remove in the second case set n is null insert remove has set n is insert has empty expressive in this chapter we introduce the notion of expressive the motivation for this from the existence of several complete data types whose operation sets are not rich enough to be of any practical use for such types implementation of even simple and useful functions that are not provided as operations of the types can turn out to be extremely tedious and for instance consider the following design of set n set n is null insert remove has empty this design has been widely used in the literature it is an complete design as was shown in section above since the equal predicate is implementable in terms of the operations note that the implementation of equal required enumeration of n upto the minimum of the maximal elements of the two sets the following is an implementation of the function size that computes the size of a set this implementation also needs an enumeration of n the auxiliary function count in the implementation does this job every time it finds a number that belongs to the set it removes the number from the set and increments the count in the variable cnt by o o i cnt s if then cnt if i then else il cnt the enumeration in the above example would be more complicated if the elements of the set were of an arbitrary type that does not have a natural ordering defined on it in that case we would need to encode the values of the element type to perform the enumeration the enumeration was necessary in the above implementation because the data type set n does not provide any operation to pick an element of a set in general this problem arises when the operation set is not rich enough to extract all relevant information from a value we would like an rich data type to avoid the need for such enumeration while extracting all relevant information from a value to characterize this aspect of of the operation set we first introduce the concept of distinguished functions we later formulate a definition for expressive in terms of them explanation distinguished functions the distinguished function for every data type d are defined corresponding to a minimal subset of constructors of d that can generate the whole value set of d a family of distinguished functions defines a set of sufficient to extract all relevant information from a given value necessary to the value back from in general there can be more than one minimal subset of constructors ie for d so d can have more than one family of distinguished functions with every family being associated with a particular lc furthermore d can have more than one family of distinguished functions corresponding to the same oc we will illustrate this point by means of an example later there are two kinds of information that one needs to know to construct a value we need to have a set of values of the defining types which is used in the construction of the value secondly we need to know the constructors and the order in which they should be used in creating the value which of the above two kinds of information they extract the distinguished functions are classified into two kinds the and the the permit us to extract from an arbitrary value of d a set of values of the defining types necessary to the value using the constructors in the are such that every such value of the defining type can be extracted by means of a finite composition of the definition nary n o d such that dl d or the defining types of d associated with ai there are n d d such that for every i s k n d d d and df satisfies the following property pi for every value of d there exists a family of finite compositions of ds denoted by g s s where every sj is of the form si d dj such that i sv aj is a value of one of the defining of d and ii it is possible to construct v from al using the constructors of types a if ui is then it not have any associated to keep the simple we first explain the definition of for the simple case of a data type where every constructor in its takes at most one argument of a type we discuss the general case in a subsequent section in the simple case every value of the defined type can be constructed using a sequence of constructors from oc we call such a sequence a constructing sequence for the value the first constructor in every constructing sequence is a basic constructor and the rest of them are all constructors every constructor in the sequence uses a set of values of the defining types as arguments to it for instance consider the following design of stack n stack tl is null push pop top empty for stack n push a stack value with n elements has the unique constructing sequence that has the form null push denotes a of n push operations the associated with a constructor ci can be viewed as functions as for ui they can be considered as functions that the effects of a particular instance of the constructor ai in a constructing sequence for the given value the for every constructor are designed by the instance of the constructor in the constructing sequence one to by a single application of the the design should be such that all instances of the constructor are after a finitely many applications of the on the value for n there are no associated with null since null is a constructor the operation push has two associated du by selecting the to the effects of the instance of push in the constructing sequence we require the two to satisfy the following properties e v e e note that pop and top satisfy these properties and hence can be used as the to see how the can be used to extract all the values of the defining types we classify the into and a decompose yields a value of the defined type and an yields a value of a defining type in the case of stack n is the decompose and du is the for push to extract the values of the defining types we go through a reverse process using the and instead of the constructors we first find a sequence of to decompose the given value to a basic value ie a value constructed by a basic constructor in we call such a sequence a sequence for the value a sequence can be easily derived from a constructing sequence for the value it is the reverse of the sequence of that is obtained by substituting every constructor in the constructing sequence by its corresponding decompose every initial of the sequence when applied on the value under question yields a value of the defined type that was generated at some point during the construction of the value under question the values of the defining types are obtained by applying appropriate to each of these values for instance for stack n there is only one way of a stack value using pop the sequence for a stack of depth n is pop the following set of sequences of extracts all the numbers used in the construction of the stack top top pop top pop the set of associated with a particular need not be unique for instance for stack n a function that removes the last element of a stack and a function that the element of a stack could just as well have as for push notice that these the effect of the instance of push in the constructing sequence the file example we further the definition of by designing a set of for a reasonably sophisticated file t example the definition of file t appears in appendix i the following is an informal description of it general be used in several different ways to create a file value in contrast for stack n there is exactly one constructing sequence for every value in such cases it is useful to select a canonical constructing sequence for the values and then design to the effects of specific instances of the constructors inside the canonical sequence every nonempty file value with n records can always be constructed by a constructing sequence of the form skip insert null the integer argument to skip is the position of the pointer in the file based on this canonical sequence we propose the following design for the i the corresponding to skip are chosen to the effects of the single instance of skip in the canonical sequence so the have to satisfy the following properties v n n n it is easy to see that the operations satisfy the above properties hence they can serve as the ii assuming that the effects of skip are already the of can expect to receive only values that have a constructing sequence of the form o insert ie the file is the operation is it the pointer no matter where the pointer was even if the file is already reset prior to its application such that it acts as an inverse of we choose to design it as an identity function since that leads to a more natural set of distinguished functions so we have the following trivial definition for file t is null insert skip delete read pos length a file value can be considered to be a sequence of records with an pointer where every record is of type t the pointer could be pointing to one of the records in the or to an position called beyond the last record in the file the pointer in an empty is always at the skip moves the pointer forward by a specified number of records the pointer to the first record insert inserts a record into the file immediately before the record to which the pointer is pointing it leaves the pointer pointing to the same record if the pointer is at the the record is inserted at the end delete the record if any pointed to by the pointer read the record pointed to by the pointer pos returns the current position of the pointer empty and are predicates which have the behavior naturally implied by their name length returns the number of records in the file for file t lc null insert skip in this case it is not very obvious what the can be the difficulty arises because the constructors in can in iii assuming that the effects of skip and are already as explained above the of insert can expect only values that have a constructing sequence d the form o insert we choose the to the effects of the rightmost instance of insert in the above constructing sequence informally we want for insert to behave as follows insert insert m null rl m rl the above properties can be expressed as follows r r r the operations delete and read can serve as the two respectively the we have chosen for the file t type are such that there are in general several sequences for a file value instance since an identity function it can be applied an arbitrary number of times at any point in the decomposition however the canonical form we have chosen suggests an obvious sequence this is to the effects of the constructors in the order in which they appear in the canonical form this strategy will decompose a file starting from the leftmost record since is chosen to be an identity function it need not be used in the decomposition process at all a possible set that extracts all the records from a nonempty file of length n is d the design of the above was by the particular canonical form of a file value we chose if we had chosen a different canonical form for a file for a different application it have perhaps led to a different set of note that the definition of does not require that they have to be designed with respect to any canonical form of a however the methodology based on a canonical form simplifies the design process for as illustrated above knowledge about the structure of the value of the defined type for this we need a device that can help us extract the structural information of a value we introduce a set of functions called as a part of the set of distinguished functions for this purpose take the form of predicates they are defined so as to guide us in the decomposition they help us pick the appropriate in an appropriate order to decompose any given value to a basic value for this the have to satisfy the following two properties a they should help us terminate the decomposition process that is they should help us determine whether we have decomposed the given value to a basic value b at every step in the decomposition process they should help us pick a decompose which makes us move closer to a basic value note that in the absence of this information the decomposition process cannot be guaranteed to terminate discussion in the general case of a data type where the constructors can take more than one argument of the defined type a value might have to be constructed starting from arbitrarily many basic values a binary tree is an example of such a situation then we need a set of sequences to decompose a value every sequence in the set will be generating one of the several basic values needed to construct the given value we have to use each of these sequences manner explained before to get all the sequences of that extract the values of the defining types in the above definition of we associate n for every nary constructor in however this association is not essential the only requirement needed is that the set of satisfy the property pi the advantage of having this association is that it the methodology for designing that was discussed in the preceding sections we believe that the methodology is simple and elegant the the property pi in section that defines the guarantees the existence of a set of sequences of that extracts all the values of the defining types from a given value given the information about the structure ie a constructing sequence of a value we saw how the values of the types can be extracted from it but for the to be useful in implementing other functions on the defined type we should be able to extract the values of the defining types without any a priori the first requirement can be handled easily by having predicates to test if a value is a basic value so we have p associated with every basic constructor ui in there exists a pi such that v iff v is the value constructed by ri to formalize the second requirement we need to define a relation on the value set of the data type that reflects how close a particular value is to a basic value we call this relation for ease of we first define the relation for the simple case where every constructor in of the data type takes at most one argument of the defined type we extend the definition to the general case later for the simple case we need only a single sequence to decompose a value to a basic value we define the of a value to be the least number of necessary to decompose a value to a basic value ie the length of a shortest sequence for the value then v v iff the distance of v is less than the distance of v we define a set of that helps to pick the appropriate decompose p associated with every constructor exists a pj such that iff v ul there assuming that stack n and file t have as chosen earlier we define for them below for stack n the associated with null should test if a value is the one created by null ie if a stack is empty the decompose associated with push ie pop reduces the distance of a stack value if it is so has to determine if a stack is nonempty we have the following implementations q for file t there are several sequences based on the we have proposed in section let us design a set of that us through a sequence of the form d d according to this strategy we want to be applied right at the beginning but only when the file is not ie when the position of the pointer is greater than one secondly we do not intend to apply at all so can always be false our intention is to decompose the file starting from the leftmost record so d should be applied if the file is nonempty and the file is e q false that one might want to perform on values all useful functions on values can be implemented in terms of them since they permit one to extract all relevant information from a value easily the requirement that the distinguished functions be implementable in terms of the operation set without the use of recursion avoids the use of enumeration in the implementation of the distinguished functions theorem assuming that every defining type of d has a decidable equal predicate and is complete if d is rich then d complete proof we show that the equal predicate for d can be defined in terms of the distinguished functions of d and the equal predicates on the defining types then the required result follows from theorem let us suppose the following fl cl un ni is the arity of u al uk are the basic constructors ie constructors that do not take arguments of type d ki the constructors for the general case we need a set of sequences to decompose a value since a value could be constructed from a set of zero or more basic values every value may have several such sets of sequences so we have to change the definition of the distance of a value the length of a longest sequence inside a set of sequences for a value is called a relative for the value we then define the distance to be the minimum of all relative for the value note that the definition of distance in the general case reduces to the definition given before in the simple case the rest of the definitions for remain as before so p above would be interpreted as follows if is true then the set of associated with uj could be applied to v successfully definition of expressive for convenience in the following implementation we use to denote the equal predicate on all types inside the body of the code the first k main clauses constitute the basis condition the remaining clauses form the recursive step since they involve recursive invocations of equal on d v q if dv else if dv then pv else if then pv z else if then i based on the notions of and we capture the informal notion of of the operation set of d by means of the following definition for expressive definition the operation set of a data type d is rich if every function in a set of distinguished functions with respect to a minimal subset of constructors q can be implemented in terms of the operations in fl using only the mechanisms of composition and conditional expressions the above definition satisfies both the goals that motivated the extension of the notion of expressive completeness the theorem to follow shows that the definition maintains the logical power of a type as before the aspect is taken care of by the distinguished functions the distinguished functions characterize all desirable basic dn vi v examples in this section we investigate the expressive of the designs of the data types we have discussed so far the method we use is to design a set of distinguished functions for the type and then see if the functions are implementable in terms of the operations of the type without the use of recursion stack n is null push pop top file t is null insert skip delete empty length read pos the above two designs are rich for each of them we designed a family of functions in the preceding sections which were demonstrated to be implementable as simple compositions of the operations the type is null insert remove has empty equal lc u null insert one possible set of distinguished functions is s removes where max returns the maximum element in the set another possible set of distinguished functions is s where min returns the least element of the set s p and are the same as before set nl is not rich as it is because it is not to implement without using recursion a function to extract some element from a set however if we include max or min as an additional operation of set n then the modified design is rich remarks in a strongly typed system with abstract data types the designer of a type to be careful in choosing the operations for the type if the operation set chosen is not rich enough it might be impossible or to discover certain useful properties about the values of the type in this paper we have provided a formal characterization of the expressive power of the operation set of a data type we defined two properties related to the expressiveness of a data type expressive completeness and expressive we believe that such a characterization can help one gain a better insight into the intuitive aspects of the design of a data type in the following we discuss a few situations in which requiring a data type to be rich proves to be an important advantage of a data type is that it the use of the type from its implementation this enables among other things one to provide several versions implementations of the same data types each version can be made suitable for a particular class of applications in such a context the user might often want to convert among the values belonging to different versions having the data type rich or at least complete can be very helpful for the user in such a situation the user will be able to easily write conversion routines since the operations of an rich type can be used to extract ail the information needed to any given value there is no need to any information about the representation for this purpose the property of expressive of a data type also enables its user to convert any of its values to an external representation of his choice this makes it possible to write output routines to either store a efficiently in a store or to display the value in a suitable format on a device an elegant way to incorporate protection for data objects in a system that supports abstract data types is to control the set of operations that is made available to the user based on the kind of information that needs to be protected from the user some operations are made to in such a context comparison of expressive power of different sets of operations of a data type becomes the expressiveness properties discussed in the paper are of help here for instance one should make sure that the subset of operations that is accessible to the user is not complete the distinguished functions can be used as a guide to determine which operations of the data type to be made to the user another interesting situation where the property of expressive plays a useful role is in automatic synthesis of an implementation of a data type in terms of another data type rep type from their algebraic specifications the synthesis procedure under investigation in derives implementations for the operations by transforming the axioms of the type in two stages in the first stage the axioms are transformed into a form in which they are expressed as formulas on the values of rep type in the second stage the axioms are converted into implementations involving the operations of the rep type the concept of distinguished functions are helpful in the second stage the axioms in the intermediate form can be systematically converted into implementations involving the distinguished functions of the rep type this is because the distinguished functions provide the information that is implicit in the pattern matching mechanism used by algebraic axioms so the job of the synthesis procedure is reduced to one of finding implementations for the distinguished functions of the rep type although this is a nontrivial task it turns out that the task can be automated with relative ease for rich data types in this paper we have only on immutable data types it would be interesting to a similar analysis for mutable data types also we imagine that the requirement in the mutable case has to be stronger since the ability to distinguish object identity also to be taken into consideration acknowledgements we are to for his suggestions throughout the development of this paper and to craig for to our notice a in an earlier draft of the paper we are also to john liskov and n for their helpful comments references ig in proofs about programs mac tr m i t cambridge ma goguen ja eg initial algebra approach to the specification correctness and implementation of abstract data types current in programming methodology vol iv data structuring ed rt prentice hall automatic computation series new the specification and application to programming of abstract data types ph d thesis university of e dr abstract data types and software validation comm acm vol no dec hoare car proof of correctness of data representations acts vol no pp jones ak liskov bh a language extension for controlling access to shared data ieee on software vol se no pp d m k the set of a data abstraction computation structures group memo lab for computer science mit cambridge ma june revised d towards a theory for abstract data types phd thesis dept of ee cs m i mass jan kleene sc general recursive functions of natural numbers mathematical pp liskov bh a r c abstraction mechanisms in clu cacm vol no pp liskov bl as exception handling in cl u computation structures group memo lab for computer science m i ma dec revised march to appear in ieee trans on software engineering j a basis for a mathematical theory of computation in computer programming and formal eds and north holland co amsterdam london pp morris jr towards more flexible systems lecture notes in computer science springerverlag pp h jr theory of recursive functions and effective series in higher mathematics inc m k draft of a thesis proposal on automatic synthesis of abstract data types mit december k a generalized thesis lecture notes in computer science springerverlag pp w london rl and m abstraction and verification in introduction to language and methodology university technical report also information sciences institute research report sn an introduction to data draft working paper ibm san research lab sept appendix i definitions of data types we present the definitions of various data types discussed in the body of the paper for a lack of space we have not included their algebraic specifications they can be found in the expanded version of this paper we first give the syntactic specifications of the operations of a data type and then we give a model of the data type we usually use the first two letters of an operation name to stand for its interpretation in the model the definitions of the functions are presented in any convenient mathematical notation a data type is the set of all algebras equivalent to the given model set n is null insert remove has empty max equal null insert remove has empty max equal set n set n x n set n set n x n set n set n x n bool set n bool set n n set n x set n bool the model is a natural model of set n in the sense that its value set is the set of all finite sets of natural numbers and the interpretations of its operations are defined in terms of the set operations n b nu in re ha em ma eq where b true false a value set of bool n a value set of n and o o a value set of set n s u i res i s i is the difference operator has i true is the empty set false otherwise o if s is the empty set s n otherwise true if s and are the same set false otherwise stack n is null push pop top empty equal null push pop top empty equal stack n stack n x n stack n stack n stack n stack n n stack n bool stack n x stack n bool the model of stack n h natural numbers as the values of stack n n b nu pu po to em q where is the set of sequences of natural numbers c o w z s the interpretations of the operation names are defined follows ej is the empty sequence if j k i as nu em e el em e po e to o ez em em t e en t if m n and for each f otherwise file t is null insert skip delete read pos empty length null insert skip delete read pos empty length file t file t x t file t file t file t file t x n file t file t file t file t t file t n file t bool file t bool file t n the model l has a set of tuple whose first element is a sequence of records and the second element is a natural number as the value set we assume that the function corresponding to read returns the element r when the pointer is at the end of file the functions corresponding to and read are denoted as re and rd respectively nu in re sk de rd po em eo le where fi is a subset of qt n where is the set of sequences of elements of type t such that every member f m k of f has s k s nl let s stand for a sequence r of n records nu c inf r r r rk kl m s km if km s nl s nl otherwise g def r k f k n f otherwise ref r t k no k nl n otherwise appendix proof of theorem theorem assuming that i for each of the defining types of d the equal predicate is decidable and ii every defining type of d is complete d is complete if the operation set of d includes the equal predicate on d proof a function f in is a function on w preserving e as explained in chapter f can also be viewed as a function on v ie we in the following we take this latter view of f so that we do not have to consider the equivalence relation e we already know that for any d it is possible to construct an encoding function q that can be used to map every function of d to a function on natural numbers because of our change of view of functions of d it is convenient to come up with a similar scheme that encodes values as numbers the two premises of the theorem guarantee the existence of a computable function n v we call is a numbering for d let be the inverse of t we show later how one such numbering scheme can be constructed from a pair of functions q and for d we use n f ii as the image of f for convenience we define the inverse image of a function on n as the function h note that if f is computable ie f c then so is its image via v and if on n is computable so is its inverse image to prove that d complete we have to show that cq we do this in two parts part i cfl g every operation in q is computable and the mechanisms of composition recursion and conditional expression preserve so it is obvious that g part s co let the functions od sn and d on d be the inverse of the natural number functions o s and respectively the proof of g co follows from the following two claims i g u od sd d ii f od sd d g a to prove i let f so there a computable function on n such that f f v e o s let x s where is the implementation of f expressed using composition recursion and conditional expression using a set of auxiliary functions now consider the function f d d whose implementation is obtained by replacing every of o s and the auxiliary functions in by their corresponding inverse f obviously belongs to ff od sd d below that f is indeed the inverse image of f and hence is equivalent to f lemma fx f proof we prove the equivalence of the two recursively defined functions using induction rule we augment the value set of every data abstraction d by the undefined element denoted by jd and order the augmented domain such that d v where v is any and the values are the functions on d are assumed to be defined on the augmented domains the numbering function is also extended so that ln id let id denote the constant function on d in function on n that returns ln then we have let gi stand for the ith function of g we can show the lemma by proving that i os x ii if v i j fx t then fj where fx and for i fix fx fix and the proof of i is trivial ii can be proved by induction on the structure of the definition def where def being o s or serves as the basis the inductive step involves two cases a when def is a composition and b when def is a conditional expression qed we prove claim ii by giving implementations for sd and d in terms of he equal operation of d in conjunction with a minimal set of constructors of d note that the latter is the least we can assume about let ic denote a minimal subset of constructors of d so without any loss of generality we assume that every constructor in takes i at most one argument from d and in order to simplify the proof we have not considered the case when f is defined mutually recursively using a system of recursive definitions for this case also the proof can be out along the similar lines ii at most one argument from the value set of a data type other than d we classify lc into the following four subsets c cj where ci d n ql q d d different from d rl dd ql sl sin where where di is different from d d we define a numbering scheme that induces a total ordering on the value set of d the least element of this ordering is chosen to be od the function sd is defined so that when sd is passed a value v of d it returns the value whose number is one greater than that of v so sd can be easily implemented in terms of q and as s v the predicate d is the same as the predicate equal of d below we briefly sketch how a numbering can be constructed from an of d the implementation of the numbering in terms of equal and the constructors in involves complex enumeration techniques implementation see for details of a complete qed construction of a numbering for d in order to simplify the presentation we assume that the cardinality of each of the sets tl il fl is the approach discussed below easily extends to the general case where the are arbitrary fp c c lg rt fl r q s c d q d d r dd s let and q denote the pairs for d and d respectively the following table the encoding function for d an implementation of q maintains a counter it increments the counter while the words out of the constructors in q in the order indicated below until it the word which is to be encoded the value of the counter at this point is the code for the given word v c ro o rl o s qi rn v o a numbering for d can be derived from the above table by together all words that yield equivalent values for let us suppose that among the first words the following set of represent the same value c qa o qj o i rn then the first values are encoded as depicted in the following table an implementation of t is also based on the enumeration of all the words formed out of the constructors in it the words in the same order as an implementation of q would but it increments the counter it increments the counter if and only if the next word generated in the enumeration is the first word to be generated from the equivalence class to which the word belongs cl wo lv o 