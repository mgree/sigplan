final data type specifications a new data type specification method de le france abstract a new specification method presented which is distinguished for data is by the semantic objects it specifies in particular only final data types are a final data type is one in which no two elements are input output equivalent it is argued that the properties of final data types characterize on the semantic level examples are given to show that final data type specifications are easy to construct and use i introduction two of computer science in recent years are that proper choice of data types is critical to good program structure and that unambiguous is critical to successful software not surprisingly then much attention has been turned to the problem of data type specifications data type providing aid both the users a source of information of a about it and the against which to a standard their implementations the approaches operational gt currently in use may be distinguished and axiomatic is an survey article as although these techniques are quite syntactically they all describe the same class of semantic objects namely the computable data types semantically there is nothing more abstract about one method than another this paper presents a new data type tion method which is different from techniques in the semantic objects it t the work reported here derives from the authors phd thesis presented to the state university of new york at and was supported in part by an ibm permission to make digital or hard copies of part or all of this work or ee copies are or on to prior its date appear and no ias copying is by permission of the association for computing machinery to copy otherwise or to republish requires a fee and or specific permission acl specifies these it is argued that semantic objects specification are the final data types final data types are the correct and that this leads to a power technique section gives some terminology and an introduction to the ideas of final data types and their specification section iii gives some examples after which we hope the reader will be motivated to read the somewhat more technical sections iv and v section iv gives the semantic side of the and is a of ideas in and section v describes the method of final data type specifications in detail section vi demonstrates its in two important areas of application properties of data types and correctness of implementations section vii gives some observations ii data types type tion the most fundamental information is the set of operations which on its elements and the arity ie its argument and result about may be of each types a data as a running example d with operations we will use null add int x union x member int x it is assumed that int defined or od data types data type and are previously is the z the operations of a new type can be divided into input operations such as null add and union which form new elements of the type and output operations such as member which return elements of old types the meanings of these operators will be to the reader we give an axiomatic and an implementation for first the axioms no false member if nn then true se s s ns en true else union s s here nn s are variables implementation are variables ranging ranging over over int and now the data type sets are represented by unordered lists rep null returns return nil end if then else returns returns w member if then returns then else end returns if then returns ee ss end end notice that certain of are not for example the list cannot occur those representations do occur what we call set of the implementation which the throughout this paper the term data type refers to any particular mathematical structure set and functions which implements a certain da ta abstraction thus the reachable set of the implementation above and the initial algebra of the axioms are both data types which imple ment the intuitive data abstraction sets of integers certain axioms about sets are implied by the above axiomatization without actually being provable from it for example similarly this but is not true lead in general is implicit that is to distinct in the implementation the two expressions representations my do we call this axiom it is because the two expressions same set but we can state this on our prior knowledge of sets true obviously represent the without relying as follows for all m indeed we take the view that elements of data types are abstractly identical if their cannot be inferred from the results output operations new of call a data type if it has no two ments which are abstractly identical final data type are small in that they make as many as possible thus our implementation of is not final as indicated above and n n are distinct reachable identical representations the initial which are abstractly algebra of our axioms is not final the congruence classes of and being distinct but abstractly identical to each data abstraction however does correspond a final data type implementing it data final just other data this paper types which data types mentioned satisfying specifications abstraction presents a method of specifying is capable of expressing only as a result of the these specifications have mathematical properties or implementations of the iii examples of final data type specifications the specification method is based upon a close of those operations which are witnesses to the of elements of a data type thus define a distinguishing term for a new data type d to be any expression over the tions of d which has exactly one variable of type d which we write as and whose value is in an old type for example for any is a distinguishing term for for top and are two terms distinguishing terms may be used to compare two elements of d to try to demonstrate their for a data type d a set of distinguishing terms is called a distinguishing set ds if it is capable of the difference between any two elements of d that is if are not abstractly identical then there is some term t in the given set such that a ds for is for any two different sets some operation has a different value for the two sets for a ds is top note that really belong to data abstractions a ds for a data type is also a ds for any other data type implementing the same data abstraction a ds for a data abstraction property stated and interpreted leads to a representation and operations having the property of tional operations may then be defined over the representation without this property thus a final data type specification has three parts a list of operations and their a ds which is interpreted according to a rule given in section v to give a presentation and certain operations and definitions of the remaining operations the intuition behind the method is very simple as this first example will show the data type is with operations create store x values content values let error element of the data type values some special obviously if two m and m are abstractly identical then we write not so content is a function on we can therefore take the representation of to be values representing each by its content and define content to be the identity func tion clearly this representation is big if we were correct in our statement about content being ll and the definition of content shows that the specification when completed will be final if two elements of the representation values are distinct content will certainly them it remains to define the other two functions create values store values x values values defining create means finding values such that error of content leaves no choice that element but the so create is a whose content is v so store vv v in this as in all examples the specification is typed in to separate it from the explanation example with the usual operations create push pop top x int int it is possible to distinguish stacks by and thus between any two top u pop by considering the ranges of the two in the ds we arrive at the representation int x and operation operations top ns pop ns n s we now define create and push create returns a stack whose top is error and whose pop is create ie an empty stack has no effect thus create has returns s so obviously push s t t s top t and when true this notice that the axiom although we made no special effort it is of course a direct result s is to ensure of example with the operations already given as previously mentioned this ds has a slightly different form from previous ones in this case the representation is int bool the set of total functions from int to bool furthermore member is defined by member ns sn the gi we now define the remaining operations elements the empty set has value of int so false for all null in add modifies the results true for its argument so of member to answer add ns finally ss an int ij an then true else sn example with operations init x var x x x var bool the finds any occurrence of the variable in the symbol table starting with the current block while looks only at the current block it is easy to see that a ds for is u u which gives representation var bool x var x and operations cfgs fv gv s init is a whose function is uniformly false whose function is error and on which has no effect so init init has an is false a function which that of s and will of s function is the course which same as return f gs false g f gs finally modifies the and re portions of a symbol table but leaves the portion as is thus the reader axioms given in may verify are that verified the symbol in this table iv ­ final data types we now present understand what is these will already and related the algebraic ideas needed to special about our specifications be familiar to readers of w ideas appear in def two data types we same operations start from the same are comparable if they with the same set of old types have and def a es is a map taking e such that between comparable data elements of d to elements of if fd xx d dn dn then for all dn h where h is for each i either h or the identity function depending upon whether did or not for example data type in which sets are represented by unordered lists just change add in to the function which removes from these lists is a homomorphism from to if a homomorphism exists d and e behave very similarly although they may be different sets in fact a user observing only the results of output operations will not be able tc tell d from d and e are implementations of the same data abstraction and may be used this may be the case however even when no morphism exists in either direction def me data comparable data types d and e the data iff there is a comparable type f with homomorphisms and consider two more implementations of using ordered lists and ordered lists these four data types form the following picture the arrows representing homomorphisms u or n thus or and un are not related morphism on is in fact final by any def two elements dd of data type d are ty if for any parameterized term t whose result is in an old type it is easy to show that u is a congruence relation and the following ob theorem in the class of all implementations of a abstraction there is up to one data type f such that from any other data type d in the class there is a homomorphism thus f is the categorical final object moreover d among the consequences of fs being final are these f satisfies all the axioms of the data abstraction that any data type d satisfies a set of axioms a without using equality interpretations is equivalent to the existence of a from the initial algebra of a to d but such a homomorphism must exist for f for exam ple the axiom not true in un is true cation given in section in on and in the ln fact f could be defined as the initial algebra of the maximum con extension of any consistent sufficiently complete axiomatization of the type implementations can always be proved with respect to f by the method of abstraction hi or rep functions the data abstraction no other implementation of guarantees this it means that it is never necessary to modify the specification to handle a new implementation ­ two terms are iff they evaluate to elements of f the axioms for fail to identify many terms but it would be to conclude that these terms are therefore it is unfortunately also data type may not be computable ble implementation of the data in fact true that the final even if a abstraction exists theorem if a data abstraction has some computable implementation d then the final data type f is computable iff the relation abstractly identical in d is decidable proof see appendix an example of such a data type appears in appendix it may be argued that data abstractions whose final data types are not computable are too complicated the theorem says that it is to define an equality operation which is it turns out that such data types are nonetheless using our it is certainly difficult to prove equality of expressions in such specifications appendix gives a specification of the data type of appendix v final data type specifications as already mentioned has three parts a final data type signature that is the names and of the operations of the data type ­ distinguishing set definition of the remaining operations the signature is this section contains second and third parts common to all specifications a detailed discussion of of a specification the a distinguishing set ds is some set terms capable of distinguishing any two elements of a data type the choice is entirely and is based upon the intuition about the data abstraction syntax of a ds for data abstraction d is of between of a ds the fl u u fn dl el the result type of any of the fi may be d long as d is not the result type of all the f furthermore none of dl em be d they all must be old types so the ds may contain derived operators which lead to more complications are unnecessary in most cases in particular are needed only when the ds must contain function symbol but they a binary the ds leads of f to a representation and to namely the specified d dl x x x x el x x where cl cn are the result types of fl f respectively x stands for cross product as usual and represents function space the operations l f are n specified by dk fn em where pi is presentation empty then the ith projection if the list of fi d pid of the parameters specified of fi is because any of c cn may giving the specified representation technical problem appendix h be d the equation may involve a is discussed in having given a ds for the data type the must define the remaining operations of the type as functions over the specified representation these are given as recursive functions over the following primitive operations operations of the old types operations on tuples pp projections operations on functions abstraction ­ application ­ function on all types modification additionally functions the may define of any functionality it is well to go back and recall the intuition behind the method the specified representation is the largest set for which the fi can distinguish every element thus if the ds is this set will be large enough to represent the data type type but the definitions of fl fn guarantee that this representation with these functions is final addition of other operations over this set will not the property thus theorem final data type specifications final data types specify to the properties of final data types given in the last section we may add this observation about our method it is the first method which is in a mathematical sense free from imple surprisingly any data abstraction having some computable implementation is even if its final data type is not computable see this suppose we wish to define data type with as above and that an implementation exists having representation type r to d denoting the implemented version we can define is specified representation function from as follows of fi by r to the n di f dk e m imp where te f are regarded as auxiliary functions and abs is for each i either abs or the fy depending upon whether abs is in fact the unique homomorphism from the reachable set of r to the specified representation abstraction function its name h now any remaining specified by operation can be d where such that may be coded as a search through the terms whose result type is d then every ble concrete representation r is checked and since d is reachable some such r must eventually satisfy the ability to test for equality in the is critical here however this equality is not in general decidable since il abstractly identical to is equivalent to the power of the specification method when equality tests are is at present an problem vi applications the specification formation to its users of a data type as well as its provides in of primary interest to the users are the axioms of the type we have shown that the necessarily satisfies the axioms so that the specification is speaking a reliable source far this information however it is still necessary to prove the axioms using the following kinds of knowledge facts about old types facts else about tuples functions and proof methods for recursively defined functions it of the to give h for is also necessary distinction between elements of the what amounts to a it in general reachable specified representation to be aware and invariant we can for section readily section example prove for from example the its specification axioms n spec of false of abstraction application ns of add if nn then true sn fn modification nn then true else spec of member s i then true if sn then true else sn if sn then sn else sn false naturally easily shown missing axioms such as are just as the obvious question is whether a complete set of inference rules can be given for axioms considerations make it clear that no such set exists ourselves to effective rules as a practical matter however the proofs which arise are well within the power of looking to an implementation of this method then the with a system like is interesting in the system is perfect can extract all possible information from the specifications but may be incomplete any system we design will necessarily be incomplete but the cation are always perfect in a certain sense implementations of data types can be proved by the method of abstraction functions that is one gives a map from concrete representations to specified representations furthermore one to this method of proof the tion function is derivable without effort it is in fact the map abs of section v we illustrate again using the data type int and attempt to prove the implementation the homomorphism conditions ns ss with abs list of int n z the definition of abs makes the homomorphism condition for member obvious we prove the other three operations if then false else if then else imp if member ns s else member if ns then else if nn then true else member nn then if member s else e if then member else if nn then true else member if nn then true else n for union we use induction first argument on lists in the true else n n then true s n s ih n true else nn then true n then true else if else then true if n then true se vii conclusion w e have presented a new method for data type specification and its mathematical basis the ma tells us that all questions about a data abstraction can be referred to its final cation this is we believe a good start what remains to be shown is that a practical system can be built around these ideas that is the subject of our current research acknowledgements it is a to the help of my at john and also of my former paul j goguen j e an ini tial algebra approach to the specification correctness and implementation of abstract data types in current in program ming methodology iv r cd prentice hall pp ah i m r the structure of and implementations of data abstractions university of ter science dept r sept b quantifiers in abstract data types in automata and programming th pp e j toward an understanding of data structures cacm pp g the specification and tion to programming of abstract data types university of comp sci research group tr sept v f u concepts in abstract type specifications math found comp sci pp j data types pp d and software e validation abstract cacm ct j goguen j an introduction to obj a language for writing and testing formal algebraic program specifications proc ieee conf on specifications of ble software may pp h car hoare of correctness of data representations acts informatica pp j cb jones implementation in cons specifications of abstract objects ibm sept k g kahn the semantics of a simple language for parallel programming proc ifip northholland co lz b liskov s specification tech for data abstractions ieee on software se pp m r milner implementation and application of logic for computable functions proc acm conf on proving assertions about programs sk p r toward program synthesis obtaining from formal specifications at comp sci dept tr sept v j proof techniques for recursive programs phd thesis stanford univ wi m final algebra semantics and data type extensions univ of comp sci dept rr july w r london m an introduction to the and verification of al ieee trans on software g pp theorem for a data table implementation computable iff the in d is decidable abstraction d the relation having final data abstractly some f is identical proof fi assume an ordering d of terms whose result ty given two elements find the terms tt which evaluate to them then evaluate t and t in f if the results are identical i then d is abstractly identical to d take the representation of f to be the same as that of d to compute an output operation in f compute it as in d to compute an input operation f again proceed as in d then take the result and find the first representation in d which is abstractly identical to it first refers to the ordering of terms appendix suppose m is a turing machine whose behavior is undecidable then write the data type halting following data ty inp at st start returns n returns then end returns nat st op end end m returns rr bool the data type with operations and is assumed ble it is concerned with the details of the machine m which need not us the only representation they represent computation way that two distinct reachable can be abstractly identical is different points in a from the same input if if they represent different inputs operation distinguishes the then if they represent different points in a terminating computation it is only to apply until one of them terminates then apply thus is abstractly iff fails identical to terminate to n u wa false compute nat ns x i t en w true s zn false y appendix we solve the defining simple case assume that where f d x a b g equation for d in a u then the equation tion of d is for the specified d ab x cd which we solve as an isomorphism specified representation to be c ab thus take the c is oft and as c qs usual all finite sequences is the empty sequence now c ab ab dd of elements define q s ab cc d c to show that d ab x c functions define the two h d ab x cd t j and hl ab x cd d fg ic yf cc then f se it is quite straightforward and h are in fact to show that h as well as being homomorphisms with respect to the projection the generalization to arbitrary is easy in order to give the usual fixedpoint semantics to functions specified recursively we must regard the set d as having the usual function all c cc dc dc for ds d d if for in a can be use to the least semantics of specified functions abs and in turn to justify the computation tion proof rule see k for a related but simpler case in stream processing it may be added that is not a flat ring even when ab and c are however it is possible that the reachable set of is flat for example when only of arise as elements this is the case in all paper of the specified the examples elements data type of this 