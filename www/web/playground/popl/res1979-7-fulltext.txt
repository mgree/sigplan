recursion in logics of david t abstract laboratory for computer science massachusetts institute of technology cambridge ma the problem of reasoning about recursive programs is considered a simple analogy between iterative and recursive programs viewed as unions of finite terms we carry out an investigation analogous to that carried out recently for iterative programs the main results are the completeness of axiom systems for contextfree dynamic logic and its extension for dealing with infinite having the power of expression of these in mind these results can be seen to supply as complete proof methods for the various kinds of correctness of recursive programs a of the work done to date in reasoning about computer programs seems to be concerned with programs eg programs or etc some of the better known examples are when reading this and other relevant it becomes apparent that when these programs are replaced by programs ie contextfree programs the problems become much harder for example the important paper of de and to indicate that methods for proving the partial correctness of recursive programs using invariant assertions required infinitely many such assertions subsequent work by apt and and and pointed to the fact that was not quite so namely by the assertion preceding a recursive call to the values of all the program variables in order to refer to them upon completion of that call a natural extension of the hoare technique to recursive programs is possible using only many assertions work has been done regarding recursive programs and park have the termination of a recursive program with the well of a certain binary relation and and contain approaches to the problem of ax the total correctness of deterministic recursive programs major parts of all of are to one or both of the tasks of designing substitution rules or rules of adaptation for dealing with parameters or local variables and presenting the methods for mutual recursion our point is that these and other t present address mathematical sciences department ibm tj watson research center heights ny s apparent complications tend to whatever basic concepts and ideas were involved in the essence of the from regular to contextfree reasoning this paper is concerned with the problem of clean reasoning about recursive programs we establish a very simple analogy between iterative and recursive programs and use it to obtain results similar in spirit to those known for iterative ones but usually somewhat harder to come by in order to be able to put this analogy to good use we choose to carry out our investigation with a simple recursive program construct which we write cj this is the program specified by the cx which consists of executing with every of the special symbol x for a recursive call to c conventional notations for j include x motivated by work on the least of functional the analogous simple iterative construct is a namely the program consisting of carrying out a any zo number of times with true and false respectively for the identity skip and empty abort programs we define a true ail aa false t where a is the usual composition of programs and is the application of programs ie with all free of x replaced by the of a and cf are binary relations over states defined respectively inductively that is knowledge of the semantics of a and t for any as follows ma m cy then illustrates the essence of the analogy the iterative recursive construct is an infinite union of terms consisting of composition of simpler ones starting with the skip abort program in most of the recent work on dynamic and its variants has been placed on working with a simple but powerful iterative programming language and part of the of this work seems to come from the which a such as a with it the work we report upon here makes use of the experience and knowledge in s for the regular operator u in order to investigate the problems encountered when reasoning about recursive programs via the simple but powerful contextfree analogue although we would to that we regard the developed in this paper and the potential it might carry for further research as its most important contribution we point to the specific results proved contextfree dynamic logic is defined and an r of it constructed r is proved to be complete for relative to complete s this result subsumes those of much as the completeness of the of dl in s subsumes completeness result for system for partial correctness as an it also the problem of a complete natural of the total correctness of deterministic recursive programs the result also seems to answer a question of de regarding the weakest precondition of recursive programs in passing it is shown that the main rule of inference for the partial correctness of recursive programs appearing m m simply an instance of fixpoint induction principle next the question of the divergence of a recursive program is considered us to extend the binary relation semantics of the programs to semantics this gives rise to the definition of the special formula for a program cy being true in a state whenever u started in that state can diverge enter an infinite loop this concept has been shown to be essential for the definition of the total correctness and weakest precondition of a nondeterministic program s and besides a similar concept defined in for different purposes has not been defined yet for recursive programs we prove using a result of that is expressible in however the proof results in an extremely formula the addition of to as a primitive this addition we show gives rise to an complete axiomatization of the resulting logic contextfree dynamic logic we are given sets of function symbols and each symbol with a fixed nonnegative arity we assume the inclusion of the special binary predicate symbol equality in the latter set we denote predicate symbols by p q and function symbols for ko by f g function symbols are denoted by zx y and are called variables a term is some function symbol followed by a of terms where we restrict ourselves to terms resulting from applying this formation rule finitely many times only for a x we abbreviate x to x thus fg x y is a term provided f and g are binary and unary respectively an atomic formula is a predicate symbol followed by a k tuple of terms the set of firstorder formulae is defined as the closure under v and x for variable x of the set of atomic formulae we define the set t of program terms as follows using the special symbol x for any variable x term e and firstorder formula p the assignment xe the test p and the symbol x are ali in t for all program terms cl and t t c u and t are m t remark is not a function symbol it is merely of value and is used to the difference between rx and t an occurrence of the symbol x in a term cl is said to be bound if it is in a subterm of the form and free otherwise a term with no free occurrences of any program variable is called closed the cf clause is intended to represent the program consisting of an execution of c where the free occurrences of the symbol x in c represent t calling itself recursively the set cf of contextfree programs is taken to be the set of closed terms m t for example x u yo f is a legal program in cf the set of formulae of contextfree dl is defined just as dl in but using cf instead of the set of regular programs any atomic formula is a for any p and q a in cf and variable x p xp and typ are we use a d and v as m the standard way and m abbreviate ap to ap note that a formula is a throughout we denote by the tuple in some fixed order of all variables appearing in a to the left of a symbol semantics the semantics of is based on the concept of a state a consists of a non empty domain d and a mapping from the sets of function and predicate symbols to the sets of functions and predicates over d such that to a function symbol f resp predicate symbol p there corresponds a total function resp predicate over d denoted by f resp pj in particular to a variable there corresponds an element of the domain and to a predicate symbol propositional letter a truth value true or the standard equality predicate over d is that corresponding to equality symbol we will sometimes to the domain of j as dj the value of a term e in a state is defined inductively following by el we now define by simultaneous induction the binary relation over r the set of ail states corresponding to a program a of cf and those states in i which satisfy a p the relation will be denoted by ma and for the latter we write being an element of ma can be thought of as representing the fact that there exists a sequence or of sx starting in state and terminating in thus will be seen to be making an assertion about all terminating computations of a starting in state j namely the assertion that the final states of these computations satisfy p similarly ap asserts the existence of a computation of a starting in state and ending in a state satisfying p notation for any function c d fy arbitrary element e and we define e ac to be the function with domain d and range giving the same values at points in da as g and such that a for any variable x and term e jl ej xl b for any p mp c for any a and d in cf and term c in t ma ma o composition of binary relations ma u mp union of binary relations m tj where and is the cf program obtained by replacing every free occurrence of x in c by i d for an formula whenever is true e for any p and q a in cf and variable it n not the case that p k iff either or iff there exists such that d b p x iff there exists such that and fp ve will be interested in special subsets of r namely simple a u is a set of states all of which have a common domain d a function symbol f resp predicate symbol p is called in u if for every state lf u and for every function f resp predicate p over d there exists u such that and differ at most in the value of f resp p which in s f resp p a symbol is called fixed in u if its value s the same in all states of u thus n fixed in any universe a universe is a in which every predicate symbol is fixed and in which every function symbol is either fixed or uninterpreted a universe is called if the only uninterpreted symbols in it are a designated set of variables in a simple universe the fixed variables will sometimes be called constants following ordinary usage in this paper we will primarily be interested in the truth of in a given simple universe u however one can see that for some cu and some assignment xe the unique state such that ie the state ej xi might not be in u at all we this by from now on the convention that in the context of a given universe the only programs we consider are those in which the variables assigned to eg x in xe and the quantified variables eg x in xp are uninterpreted thus for and for any p the truth of in p can be seen to depend only on states in u we will often omit the simple when no confusion can arise an universe a is a universe in which the domain includes the set of natural numbers the binary function symbols and are fixed and given their standard meanings addition and multiplication respectively when to the natural numbers in the domain and o and are fixed function symbols interpreted as the natural numbers zero and one respectively furthermore there is a fixed unary predicate symbol with the interpretation is true iff d is a natural number that is for every state is the set of natural numbers we are able to distinguish the natural numbers in the from the other elements and we do not care say what the value of xy is in state j when it is not the case that nat x holds an additional property we require of an universe is the ability to encode finite sequences of into one element the formal definition of this property s as follows there exists a total predicate r x over the domain of a such that for any natural number n it is the case that we have e intuition is that r holds iff x is the ith component of y so that any finite sequence can be encoded as such a y note that one particular universe is the n of pure arithmetic that m the universe in which the domain is precisely the set of natural numbers and o and nat which in this case is true are the only function and predicate symbols serves as the finite sequence encoding function for this universe when about we will often want to use n stand for variables ranging only over the natural numbers we do this by the following convention any we will use in which we have explicitly mentioned say the variable n as a free variable is assumed to be by nat n thus for example k p n q stands for pn q that in state pn q is true f nj happens to be a natural number furthermore by convention stands for and hence n t is important to note that any universe u can be extended to an universe by it if necessary with the natural numbers and additional for encoding finite sequences thus reasoning about any of program written over any domain can m principle be carried out with a suitable universe a p is written if it is true in all states of the universe and is valid pp if it is for every universe u example consider the program a z yl ij z x which is of the form zx the following is u u u false in general it can be seen that the meaning ma restricted to the universe n of pure arithmetic is the binary relation and thus a is a program computing over the natural numbers m one can see that mf iff there exists a nonnegative integer n such that ht other words the intuition is that executing a recursive program tx which calls itself in effect at each of x is executing for some n the program consisting of allowing calls of at most depth n we remark that in fact this is in perfect agreement with semantics of recursive programs as defined say in or using terminology from these papers our ls are all continuous over the domain of binary and therefore defining the of c to be the least solution of the relational equation x c x in the sense of and is by theorem consistent with our definition of x which is really in the sequel we will need a fundamental notion to aid in constructing our rules of inference and in our meta reasoning we allow in this reasoning a special kind of program the achieve program pz defined for any firstorder formula p and tuple z consisting of disjoint variables the meaning of pz is given by the following additional clause to the definition of m for some tuple v of from dj and z z p thus p is thought of as having free variables z and z where z is a tuple of versions of the members of z for example xy is xy then p is the program which assigns nondeterministically to z any value v such that in state j p is true of the value of z in j and v thus pz achieves between and the induced by with zx and being xx v we have u now let cf cf u p and z as above is defined exactly as but replacing cf with cf our axioms and rules will take advantage of being able in to construct an achieve program of the form pz to correspond to a given real program ie a firstorder formula p which expresses the relation induced by the program preliminary results the facts in this section are in the main result of section first we show that the regular programs are embedded in cf recall that u was defined in such that ie the reflexive transitive closure of ma lemma for every ma u a x u xu p ma uo u ma u ma a u u u ma true u ma u uo m true u a u u a xj similarly for the second equality theorem for any universe a the firstorder language is for ie for any p there exists a firstorder formula q such that pa the theorem is proved similarly to theorem in and the reader s to that reference for details however here a different treatment for x is necessary it can be shown by the encoding of finite sequences of elements of the domain of a that there exists for every term c x a formula such that for every n n expresses in the sense that where as in theorem of if ql is a firstorder equivalent of q then an equivalent of cq is a a ql z in the sequel we will write zz to abbreviate and by convention will assume that for programs of the form p z the tuples z and z appear m that order in the of free variables of p thus for example will abbreviate p with members of z replacing free corresponding members of z we now show how to lemma for every and term cx if and if furthermore for all io we have express the fact that pz is an upper or lower bound on the relation represented by a program a using notions from for any universe u and let mu be ma restricted to elements of u if a then iff then for all io by induction on i for io we have assume so that by thus we have iff l assume and assume we have to show that for some tuple v of elements of dj and that z the first however one can show by induction on the structure of c that uo this follows from the continuity of c over the domain of binary relations cf s and so we have is trivial by the fact that now by the definition of and since a does not change z if u s then also where and zj z zj zl however by the assumption since we have constructed such that we must have or zj which is the same as saying z conversely assume pz and assume that for some we have and that we must show that pz z by assumption so that z which by is equivalent to however by we know that zl so that assume and assume axiomatization of consider the following axiom system r for axioms a b c d e f c ah of propositional calculus ep p for a firstorder formula qp qp a a up for firstorder formulae p and q p par cj where wr r p mu pz we prove by the second assumption zf so that by the first we have zz zj thus we can conclude that finally from fv for some v we inference rules h p pq that zz and hence that q conversely assume mu pz and that for some zz we show the existence of u such that and z z take to be zj z certainly z furthermore by the definition of pz since zj z f s simply itself and since we assumed that we conclude that hence m and it is straightforward to show that our ts are monotonic in the sense that if then we induction principle park for any universe u and term cx if then zz zz cf where c k n zz j zz for a f formula p with c n t for any universe a denote by ra the axiom system obtained by r with the set of all a valid firstorder formulae as additional axioms in f a is defined as usual the intuition behind axiom c is that allows r across a program when that program cannot affect the truth of r the in rule j is that if upon the values of z in execution of t with the p in whenever a recursive call was to be performed results in p holding between the initial values and the current ones then p holds when the recursive calls are indeed carried out lemma the are derived rules of r where z and n are as in j and k j zz k d we now prove the soundness of r lemma for any firstorder formulas t and q r and s term c x the following are valid z o s s j ry where var r straightforward from the definitions h lemma for any universe u firstorder formula and term where if then o t by the hypothesis is simply mu p by lemma we obtain which again by theorem is precisely the conclusion n j assume we apply j to obtain using axiom c we get a t a from which we deduce ra thus by ax k and the second assumption the conclusion follows k similar to j m we now show that rule j can indeed always be applied when its conclusion is lemma invariance lemma for for every term tx and r and q if pa then there exists a firstorder formula with such that and n lemma for any firstorder formula p n z z and term c where n and if and s tj zz then ne can how equivalent to saying that map n act furthermore by theorem the second assumption amounts to that by lemma we conclude that mac for ali n thus again by theorem we have the conclusion b by the way theorem is proved is the fact that there exists a order formula of arithmetic which expresses the program in the sense that z ma p m a tf have pa certainly then by the assumption we also as noted in the proof of lemma mac and so we have which by theorem n box completeness theorem for for every ccp and firstorder formulas r and q if then kr a of r for any if p then p follows from the soundness of our regular dl cf of and lemmas of we will apply theorem of which is theorem of to prove the completeness of r but we are required to prove the appropriate completeness theorems for formulae with one box or one these will be established with the ad oc proof by induction on the structure of a the and u are treated precisely as in s the case cy is treated using derived rule j and lemma similarly to lemma rule k can be when needed lemma convergence lemma for for every term cx and r and q if ka q then there exists a firstorder formula such that ba b and l n n again by the method used in the proof of theorem there exists a formula p n zz representing in the sense that for every n we have three a hold for p it is easy to see that all s theorem for for every and firstorder formulas r and q if then w but and rule k instead of lemma and rule j we conclude that for in ia are equivalent and theorem soundness and completeness for for every universe a and a p iff ra p m one direction is theorem and the other follows from the general theorem of which is of and the present theorems and fl the results in section that as far as is concerned reasoning about pure recursion is analogous to more complicated than that of reasoning about pure iteration here we are using the integers to count how deep we are in the recursion using in rule k whereas for a we counted how far we are in the iteration it is interesting to note that the proof method for formulae of the form r which is incorporated into r down to inductive method and to and induction method respectively when regular programs are translated into recursive ones the two methods appearing in lemma thus the holding between these two methods which was described in length in shows up as from the two dual ways of a the reader familiar with can of this fact quite easily by deriving formulae and of from our rule j by using the two equalities of lemma n section of s we extend this system to the mutual operator cl cn of s contain examples of proofs in r and l of section divergence of recursive programs in this section we define the operational notion of the of program ie it entering an infinite loop is done by introducing for any state the of a program a denoted by we show that computation trees are in fact an extension of the semantics of cf the trees however in addition to the inputoutput information contain information regarding the presence or absence of the concept of has been shown inl to be essential for describing the total correctness of nondeterministic programs and hence the importance of it for recursive programs as well as iterative ones the main result in this section based on a result of k is the fact that is expressible in each node of ct aj will be labeled with a state in r or with the special symbol f and will be of at most the root is labeled with and nodes labeled with f will always be leaves the is that a path from the root represents a computation of a starting in state accordingly a leaf represents a termination state if it is labeled with a state in r or reaching a false test if it is labeled with f any node with descendants represents an intermediate state of a if a node has two descendants then there is so to a choice as to how to continue execution a node will be represented by a pair tl where t is a finite string over describing the location of the node m the tree by o denoting go and go right and the label of the node is either a state in r or the symbol f for example the tree q f m represented as a ll as can be seen a the empty string marks the root of the tree by convention a single descendant is marked as going left ie by o formally for any and arc is defined by reduction on the structure of a to be a subset of x r u f as follows where we use i to range over u f and s t to range over a j af if if tp a u u let e fr a and let c e then c u a s u informally to construct ct t one starts constructing u tx and whenever so to ct xj was to be attached to a node labeled ct c is attached instead cf course this process might lead to an infinite tree the additional union with is introduced so that the process of recursively would itself cost an edge in the tree so that eg the program will diverge see below let j be some state m n for which and in the diagram we let i stand for i yl take a to be the program u x then yl is f f o fo of h we omit the proof of the following fact which serves to show that computation trees are consistent with the binary relation semantics defined above lemma for every a leaf labeled iff has define now for any a boolean constant by iff j is infinite note that being of we can apply lemma see tc conclude that in fact iff there exists an path from the root ie there is an infinite sequence of nodes in f of the form we would like to supply a syntactic characterization of oo recall that in it was proved that a divergence m the iterative a m due either to a local divergence ie a divergence in some reachable execution of ty or to a global one ie being able to execute as for ever the former was captured by which can be written we can and the latter is so loops v characterizing m similar here a local divergence is a divergence some application of a reachable c and can be expressed by global on the other hand is more subtle here we want to express the possibility of being able to apply c for ever which amounts to being able to proceed infinitely deep into the recursion n order to do this we apply m the sequel the following restriction on the we consider the domain is to have at least two elements and the set of symbols s to include two fixed variables having these two elements as values we will therefore use the symbols a and b freely as two variables with values now for any term t define the term c which intuitively allows tests recursive calls to t and other recursive constructs but forces any such skip to be recorded in a new flag variable x given t x let xy be two variables and let cx be cx with every free in the case of x of a subterm a of one of the forms x p or c replaced by a u x b also define a ya u for any no denote the program xa by n we can now present our characterization of theorem for any loop v assume we have lt is quite easy to see that has at least as many nodes as ct k and hence we also have for the rest of the proof we be some additional notation for any i and we would like to define the set s of those states which occur immediately before an application of c at depth i define where v is the set of states such that the process of constructing ct cf j for xi var requires constructing ct xx in other words v is the set of states which of c can reach just prior to calling recursively at level certainly if for some i we have s i then labels some node m and furthermore the path from the root of ct to that node m of length at least note that this would not be the case if we were to assume now that we show that for any io we have fa and thus has paths of arbitrary length and is therefore by lemma note that the assumption is sufficient where reads there exist infinitely many n so that vn can be replaced by mn in the statement of the theorem indeed for any such i by assumption we have or so that there exists a finite path p m starting from the root which in a node labeled by a which y is b the nodes can be denoted by jk where let i be the least integer such that by the construction of cu tt is evident that in order for y to have changed value from a to b it must be the case that the value of x was a all along more precisely for all jj we have x al so that tests p and of j the form were indeed out and not avoided by executing xb instead in other words the initial segment of the path p ending m j can be thought of as being a simulation in i u of a path from the root to the in ct consequently we have js this completes the proof of one direction theorem of the conversely assume now that holds and that for all nl we have consider the infinite sequence s of successive labels of the nodes of an infinite path from the root in ct cj it is easy to see that by the second hypothesis there must exist a subsequence of s say such that for every i we have and such that corresponds to the first m s that depth i of recursion was reached we show that holds for every i by an algorithm for executing ci m such a way as to m a state in which the value of y s b simulate the path corresponding to the initial segment of the sequence s ending in i ie assign xa and ya and then proceed in exactly as s in y executing tests and recursive constructs and nor the xb parts by the of i reaching i in s corresponds to reaching u for the first time m thus we have reached u with and x a and therefore y is assigned b execution in m then to be by choosing the xb parts instead of tests of x and recursive constructs certainly this execution will terminate no tests to fail no recursive constructs or recursive calls to diverge moreover by the construction of u any subsequent at u will not change the value of y and since yi rw this value is not changed by any other part of the rest of the execution thus yb upon termination an obvious arising now is whether pa is m ie whether for any there exists a pd such that h pa s pa we have to be able to deal with both of theorem we state the following two results and prove the second the proof of the due to k is omitted here theorem for every term cx and firstorder formula p there exists a q such that eq theorem for every term cx there exists a such that q z q and hence from theorems and and the remark in the proof of which replacing vn in its statement by mn we obtain pa is expressible in proof of theorem l consider the set z s ic which intuitively is the set of states labeling those nodes in ct cy corresponding to points just prior to a recursive call to c assume we have defined for any q and term t x a formula such that ie tq holds iff q n true immediately prior to some reachable recursive call to t in an execution of c starting in state j assume also that we have defined for every program and term cx a formula pa such that holds there is a divergence ill to the part and not to the a part ie the divergence from some recursive construct appearing in cx lt is quite clear that holds iff at some state in the execution of r prior to a call to it is the case that there n a divergence m ct tt which is due to the first c and not to the inner cy in other words c now we proceed to define these concepts and then observe that they give rise to for any and terms x and k x define now for tq we use similar to those used in and u for theorem given cx let x y be two variables let t and let be a tuple of versions of the in var c define c x to be tx with every of a subprogram a of the form p or replaced by u u xb and every of the program variable x replaced by zz u xb u x where zz the composition of the assignments zz for all zz now define cq to be xa ya yb a the is that m xa one has the option of whenever x is reached storing the current values of the variables z in z as long as the computation until that point has been an simulation of a computation in cj once such a store has been carried out it cannot be carried out again because of the ya guard furthermore as in the proof of execution can always choose to surface quickly to the end of t by executing xb whenever possible then when the execution we assert that q m true for the values of z which we stored in just before the recursive call it should now be clear that reason the theorem now follows is that when using induction on the structure of c and the theorem holds for the subterms of t we can deduce that our inductive hypothesis m in fact that is expressible in for a which appears in c this follows from theorems and thus the of p which uses pa for such a gives rise to a n augmented in this section we augment with the to reason about directly without having to go through the translation of pa into equivalent the language will be called the reason for doing so even though by the previous section and are equivalent in expressive power is rooted m the fact that the equivalent of above including the part from the omitted construction in the proof of has the property of being strongly dependent on the structure of a and on the variables appearing in a calling that equivalent pa one can see that pa cannot be obtained from pa by substituting a for a throughout consequently proving a formula with an of pa will involve carrying out the transformation of pu to pa and then reasoning in the point is that the intuition one might have about is in a strong sense lost in the process is defined to be u with the semantics of the part being as in and the semantics of as defined m section our here too be of an extension which is as but with the programs coming from the set cf as in section we be using the fact that in an universe a there exists for any a firstorder formula p such that pz expresses a the problem that arises s that of we would like to be the case that for any p holds however for a given r it is possible that the set is infinite one solution to this problem is to define ct a to be a tree of possibly infinite with the of the node given by a of natural numbers as opposed to a list or string of s and ls for pz the tree would be defined roughly as u x j u then we would define to hold iff f has an path which in this case n not necessarily equivalent to ct a being another equivalent method n to associate with any and fl a set of trees for pz we would define lhe rest of the is carried out analogously to the of above for example is the set of trees by following the construction of d for every tree in any tree in ct to a node labeled whenever ct was to be attached to that node in constructing fl let a xx p and zx that we have for any such u a i xl and thus j i xl e now define to hold iff there is an infinite tree in ct a we remark that either way is uniquely defined for and that for now consider the axiom system r for defined as of section augmented with the following axioms and rules in the following p and q are firstorder r m a tx is a term x and y are variables xy v s the tuple of variables obtained by z with x and y and u t and d are as defined in the proofs of theorems and respectively axioms l m n o p false v pa v pz false of inference q r d xa yb a v cj zz r r yb v a vv zz c vv vv r let a be any universe la is defined analogously to r a in ra is defined usual as theorem of r if ra p then ap for any p the proof of the p is left to the reader we show that rule q is sound noting that the soundness of the dual rule r follows immediately consider rule q we argue that the of the first premise of this rule under the assumption that the other three are asserts that ia r v which by theorem that recall that tn is an abbreviation of xa and indeed by theorem in section the premises other than the first assert respectively one can then show by induction on n using monotonicity that consequently since qz is smaller as a relation than but is can see that pc and one hence also that along however by the proof of theorem the latter is moreover since for any n pn v is smaller than one can see that ya pn yb implies in order to prove the completeness of r we need to show that of one of the forms r or where r is firstorder are provable in a then the general theorem in in s is used to obtain the final result more details can be found in s f for every and firstorder formula r if fa then er a by on the structure of u the only nontrivial case is when a is of the form cf for some term t pa r we show the existence of firstorder formulas q and pn such that the premises of rule q are since these premises involve only and the formula qz m which the program is of complexity lower than tj the result follow indeed by theorem we can take q and pn to be firstorder formulae involving respectively only variables in z and v and such that ka q cy and for all n all the premises are easily seen to be for this choice we for every and firstorder formula r and thus as we conclude em a soundness and completeness for for every p iff r a p acknowledgments we wish to thank a for a version of rule k and n a and vr pratt for discussions the research was supported by the foundation in and by nsf grant no references apt kr and completeness with finite systems of intermediate assertions for recursive program schemes iw math cent amsterdam sept recursive programs as predicate proc ifip conf on formal specifications of constructs st aug de and on the completeness of the inductive assertion method j of computer and system sciences s de and wp a calculus for recursive program schemes in automata languages and ed north holland s de and d scott an of a theory of programs manuscript l a g h and a an introduction to algorithmic logic in the theory of programs in and editors math found of comp sc center burstall rm program proving as hand simulation with a little induction ifip cook sa soundness and completeness of an axiom system for program verification j comp vol no a axiomatic and semantics for an fragment tr dept of computer science u of l dijkstra e w guarded commands and formal derivation of programs comm of the acm no rw assigning meaning to programs in schwartz cd mathematical aspects of computer science proc symp in math r math j semantics and correctness of with recursive procedures n automata languages and programming springerverlag july ca a complete axiomatic system for proving assertions about recursive and nonrecursive programs tr s dept of computer science u of sa theory of program structures lecture notes m computer science s d completeness in of programs in automata languages and programming springerverlag july d logics of programs axiomatic and power phd thesis mit available as mit tr may d ar meyer and vr pratt and completeness in of programs proc th ann acm symp on theory of computing col may d a and j completeness issues for assertions and method tech rep dept of a math u aug d a and j a complete axiomatic system for proving about recursive programs proc th ann acm symp on theory of computing col may d and vr pratt programs proc th acm symp on principles languages jan in logics of of programming p and d park rules and proofs in automata a programming cd m northholland hoare car an axiomatic basis for computer programming comm of the acm vol s hoare car some properties of predicate transformers jacm no july kleene sc introduction to s d van c d der by new york manna z and r s sometimes better than always assertions in proving program correctness proc nd conf on software engineering oct morris jr and b induction comm of the acm vol no april park d induction properties in machine intelligence press and proofs of program edinburgh university pratt vr considerations on logic proc th symp on foundations of computer science oct s total correctness for procedures manuscript univ of a the semantic of truth and the foundations of semantics and res k private communication 