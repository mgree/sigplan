dynamic session types yoshida college london abstract multiparty session types enforce structured safe communications between several participants as long as their number is fixed when the session starts in order to handle common distributed interaction patterns such as protocols or algorithms we propose a new multiparty session type theory where roles are defined as classes of local behaviours that an arbitrary number of participants can dynamically join and leave we offer programmers a operation that gives access to the current set of a roles participants in order to fork processes our type system with universal types for can handle this and retain type safety a multiparty locking mechanism is introduced to provide communication safety but also to ensure a stronger progress property for joining participants that has never been guaranteed in previous systems finally we present some implementation mechanisms used in our prototype extension of ml categories and subject descriptors d programming languages formal definitions and theory f semantics of programming languages process models general terms theory types design keywords communications roles multiparty session types mobile processes dynamic protocols introduction as a type foundation for structured distributed programming session types have been studied over the last for a wide range of process calculi and programming languages the original binary theory has been generalised to multiparty session types in order to guarantee stronger to session structures between multiple endpoint participants since the first work was proposed the multiparty session type theory has been developed in process calculi and used in several different contexts such as distributed object communication optimisations security design by contract parallel and web service programming and some of which see § and while many interaction patterns can be captured in the existing multiparty sessions framework there are significant limitations for describing and dynamic protocols since the number of participants is required to be fixed both when the session is designed and when the session execution starts this makes it unable to express interaction patterns frequently found in oriented and computing permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm the central of multiparty session types is that critical properties such as communication safety essentially a correspondence between send and receive and are guaranteed by the combination of two means first a static typechecking methodology based on the existence of a global type a description of a multiparty protocol from a global viewpoint and of its endpoint projections the global type is to endpoint types against which processes can be efficiently second a synchronisation mechanism which ensures that all the wellbehaved ie welltyped participants are actually present when the session starts this paper introduces a new multiparty type system and synchronisation mechanism that together can specify verify and dynamically protocols in the rest of this section we illustrate our motivation approach and solutions through protocols of increasing complexity introduction of the notion of roles and universal quantification pp projection challenges and branching and communication safety we imagine a server that wants a task to be computed on a cluster made of three cluster clients the server sends them and they give back their answers we give a picture this communication pattern and the corresponding global multiparty session type written in the original theory client client µ map map map reduce a client bc reduce o reduce x this session starts with the server sending the messages map to participants client client and client each of them answers back with a message reduce recursion µx denotes an unbounded number of repeated interactions the problem here is that such a session cannot start without one of the clients and once running is not able to handle a fourth client joining or one of the current clients leaving in the original multiparty sessions any of these scenarios requires ending the session writing an appropriate global type for the new situation and starting a fresh session again this paper proposes a theory of dynamic session types that can describe global interactions between roles which are classes of participants that share a common behaviour eg the clients in the above example is by a simple universally quantified type that allows to spawn further interactions by the set of participants currently a given role in the above session we notice that the three clients have the exact same behaviour receiving a map message and sending a reduce message we call this behaviour the client role and now expect a varying number of participants to it on the other hand the server role is as usual instantiated by exactly one participant and the session does not start without its presence the follow since the previous multiparty session types do not support explicit parallelism we rely on to express the desired behaviour ing picture illustrates this dynamic protocol its global type features the new universal type g map client reduce x the repeated interaction in the global type g involves a map message to be sent by the server to ev a client bc o participants x of the client role the server then expects a message reduce in answer at the type level such an operation is specified using a universal quantification x rg the current participants p pn of role r and in parallel processes binds x to each in the subsequent interaction as in g px g in our example g map reduce is executed in parallel for each client x then the recursion variable x points the interaction back to its beginning local types since the implementation written here in a variant of the calculus is distributed the typing system first projects the global type to each endpoint local type for each role the projection algorithm computes a local type that describes the behaviour of any participant that wants to play it the local types for this session are the following µx server map server reduce x client x map x reduce x first the client behaviour is straightforward as it is only involved in two messages at each iteration with the server the local type of the client expresses that it expects a message map from the server server map and that it sends a message reduce as an answer server reduce the server role is involved in all the messages of this session we note the presence of the quantification over all x the client role processes we write some process examples that would be well typed against the local types the session identifier s denotes an active session az server map s server reduce x az clients x map s x reduce x a session starts through the join operation az clients which gets the session name s of a running session on a a participant z the client with is simply messages map and reduce with the server through sending s and receiving s operations the server needs to fork for its interactions with each client to this effect the operation sx clients x map s x reduce creates as many processes s x map s x reduce as there are participants x the client role note that late joining client participants are incorporated in the session at each iteration the of the operation sx client is able to ensure a safe interaction between all in this session there is only one role the client whose behaviour is to always broadcast its messages to all the other clients we give the global type and a representation of the interaction when four clients are present g client msg string x this type features a double quantification which specifies that each pair of clients x y will interact in the form of a unique msg the explicit exclusion of x from the list of clients y prevents messages this second example shows the projection difficulties that arise from quantification local types to illustrate the projection of nested quantifiers we first rely on our intuition each client should send a message msg to every other client and concurrently should expect a message msg from each of them client z y client msg string x client z x client msg string x let us examine how the projection algorithm gives this local type suppose we project for a generic client z the first quantifier x client of the global type necessarily involves z meaning that among these parallel processes there is exactly one where x is z in the other parallel processes although x is not z z can still be involved the projection of the second nested quantifier y client x works in the same way this is why the first parallel part is y client z msg string which explicitly the possible z msg string process once the local types are known the client processes have a similar structure including the explicit operator written sy client z az client zs y msg m sx client zs x x we now illustrate the expressiveness of our universal types when combined with instantiation of participant identities and branching session in this session we have three roles the multiple here participants alice alan and here bob which all connect to a single this will then form matching pairs x y of and who will then continue their interaction separately a stop price alice order bob price order g x y xy yx price xy order y xy stop end the x specify that every possible association between and is considered by the when he makes his choices for each pair x y of and the selects to send to x either a message match y if he has found y to be a match for x or a message y otherwise if the message match was sent x y and the interaction proceeds in the other branch x needs to y by the message stop that the chose the second branch for this example we just write a process for a s match y s y s y price s y order y s y stop s from the above process we can see the importance of the communication of the participant identity y with the messages match and the of y to the messages is necessary for x to know to which y to send the message note that the y in match y is not a regular as all the y are already known by x at x matches his known y against the one coming along match or this example presents a nonrecursive session where all participants leave the session through the expression s at the end of their interaction since late always start at the beginning of the session they cannot safely interact with the participants that have already to guarantee progress we require that late if we want our global type to include those message it can be done explicitly by writing a global type msg string y msg string x wait for the current participants to end before joining themselves and beginning their actions to provide consistent synchronisation we introduce a multiparty locking mechanism to protect the global session executions main contributions § a new multiparty session type framework where participants can play several roles in a session its semantics allows participants to dynamically join and leave a running session and create new parallel sessions § § introduction of a universal type for participants along with explicit parallel compositions and a type system that provides subject reduction theorem and type safety corollary no type error for values and labels the endpoint projection and the wellformedness conditions of global types deal with the subtle between universal quantifiers parallel compositions branching and instantiations of participant identities § a semantics and type system with a simple locking mechanism by which communication safety theorem every receiver has a corresponding sender with the right type progress theorem processes in a single multiparty session always progress and join progress theorem late can always join to an existing session and progress are established § practical implementation techniques used in our prototype extension of ml the proofs detailed definitions additional examples and the prototype implementation are available from session calculus we describe here an extension of the multiparty session calculus presented in our new system handles roles and allows programs to in protocols that include multiple parallel interactions and dynamic role instantiation u x a b shared channel p p r x r participant with role p p p x p participant list c sp y session channel e v x e e expression v a sp r true values p c c p l p e c p li pi cx r pp p p p p if e then p else p x a gp sp s h a s r processes session join send receive parallel sequential conditional recursion variable null restriction session restriction buffer r r p rn pn role set h h · p r p r l p v buffer figure session calculus syntax we give in figure the syntax of the processes of our session variant of the calculus a session is always by a process of the form u g where g is a global type formally defined in § session attributes a particular global interaction pattern g to a shared channel u once the session has been on channel u participants can join with where p a participant identity p or x associated with a particular role name r joining binds the variable y with the session channel that this particular participant can use when he plays the role r leaving the session is done by c where c is the session channel corresponding to the participant and role the asynchronous c p l p e allows to send to p a value e labelled by a constant l and participant names p the c p li pi expects from p a message with a label among the with participants pi the message is then received in variable xi which binds in pi messages are always labelled the list of participants pi the label li in order for the receiver to be able to messages that have the same sender and label but different continuations the operation cx r pp is the main way to interact with the participants that instantiate a given role p is replicated for each participant x role r with the exception of the participants mentioned in p parallel and sequential composition are standard as are the conditional and recursion the creation of a shared rendezvous name is done by a gp this fresh name can then be used as a reference for future instances of a session specified by g once a session is running our semantics uses some that are not directly accessible to the programmer first session instances are represented by session restriction sp second the message buffer s h stores the messages in for the session s last the session a s r records the current association between participants and roles in the running session s for simplicity we write c p l p xi p if there is a unique branch similarly we omit the empty list of participant and unit eg c p l we also do not write and roles r eg in x r if they are clear from the context we use syntactic sugar for the special roles that cannot be multiply instantiated is done implicitly for these roles their participants names p or x do not have to be explicitly mentioned the mention of the role r is sufficient and unambiguous in the example from § server is such a role we call a process which does not contain free variables and runtime syntax initial semantics figure lists the reduction rules the init rule proceeds to a session by reducing a g it creates a fresh session channel s and two processes first the session a s r is an entity that the association between participants and roles in the particular instance s of a session initially r does not record any participant for any of the roles of g the second process is the sessions message buffer s which is also initially empty the rule join the of a participant to a running session the participant with ap to join the session on channel a and specifies his identity p and which role r he wants to play this information is added to the session a s r · r p p and the session channel is the rule the of a participant from a session sp r forces the deletion of p r from the the rule send describes asynchronous sending which its labelled message to the buffer s h in rule recv the takes from the session buffer the first message p r p r lk pk v that has a proper address label and participant list and selects the matching continuation pk the rule details the reduction of the process sp r x r pp the set a g sa s r s ap a s r · r p ry a s r · r p p ri g init join sp r a s r · r p a s r · r p p sp r p r l p v a s r s h a s r s h · p r p r l p v p rr p rr send sp r p r li pi a s r s p r p r lk pk v · h a s r s h p rr k i recv sp r x r pp a s r a s r rr p p pk p rr if true then p else q p if false then p else q q iff p q p q e p q e p q par p p e p e p p p q q p q e e p e p ae se sp r p r l p e if e then p else p e e v e figure reduction rules for the session calculus of participants p pk that play role r once the ones in p are removed is received from the session and the process p is accordingly with x appropriately substituted in par bound names in e and free names in q are disjoint the reduction is defined modulo the standard structural equivalence we just mention here the session garbage collection rule a g sa s r s when ri g and the permutation rule s q p l p v · q p l p v · h s q p l p v · q p l p v · h which allows to put forward in the session buffers the messages that have different labels or participants lists others are standard reduction example we take the process from the mentioned in the introduction § figure gives reduction steps of a situation where we have two client processes and that want to interact on session channel a we call qz the process client y msg m client x x and abbreviate the a s client p p by r aa g pp pp init a sa s client s pp pp join a sa s client p s qp pp join a sa s client p p s qp qp a sr s qp sp p msg m client x qp send a sr s p p msg m qp client x qp a sr s p p msg m qp sp p qp a sr s p p msg m sp p qp sp p msg m client x qp send a sr s p p msg m · p p msg m sp p qp client x qp a sr s p p msg m · p p msg m sp p qp sp p qp recv a sr s p p msg m sp p qp qp recv a sr s qp qp figure reduction for the example session types in this section we present the session types which specify the communication patterns that are to be enforced we start with the definition of global and local types and follow with projection and wellformedness properties g t u s pp li pi ui x r pg g g g g x end p li pi ui p li pi ui x r pt t t tt x end st g bool unit global types labelled messages universal quantification parallel sequential recursion variable end local types selection branching universal quantification parallel sequential recursion end message types sorts figure global and local types global and local types global types g describe global scenarios between multiple participants as a type signature when a participant with a global type g his behaviour is defined by a local protocol called local type ti that is generated by the projection of g to the role he wants to play if each of the local programs p pn can be against the corresponding local types t tn then they are automatically guaranteed to interact properly following the intended scenario the grammar of global types g g and local types t t is given in figure there are four key extensions from the standard multiparty session types association of each participant to a role universal quantifiers to bind participants identities parallel compositions for local types and labels that can be extended by lists of participants in the global types g g a global interaction can be a labelled message exchange pp li pi ui where p and p denote the sending and receiving participants with roles recall that p denotes either pr or xr pi is a list of participants ui is the type of the message and gi the interaction that follows the choice of label li i is a finite set of integers value types s include shared channel types g or base types bool unit message types u are either value types s or local types t which correspond to the behaviour of one of the session participants for parallel composition is written as g g and g g denotes sequential composition is a recursive type where type variable x is guarded in the standard way they only appear under some prefix marks the absence of communication while end denotes the end of the session for all roles the universal quantification is written x r pg where the participants of role r bind free occurrences x in g it corresponds to the operational semantics of sp r x r pp see § ie a parallel composition for some list of participants p pk the role r which is decided at runtime from which the list of participants p has been in local types t selection expresses the transmission to p of a label li taken from a set with a list of participants pi and a message type ui followed by ti branching is its dual counterpart the other local types are similar to their global versions we consider global and local types modulo the following equalities for local types we define t t t t t end end t t t t end t end t end and p li pi ui end p li pi ui ti similar equalities are applied to global types we also use similar tions for global and local types as the ones for processes mentioned in § in particular we write pq l p u g or p l q u t for a single branching and pq l if the list of participant is empty and the type is unit end is also often example global types to give some additional clarity to the semantics of global session types we give here several variations on an additional example we imagine a protocol similar in spirit to the session where the clients must interact through a single server we have thus two roles the unique server and the multiple clients each clients behaviour is to send a message to the server who will then broadcast it to all the others in the following picture we only represent the msg that one client sends to the server and that is followed by the server its content in message to all the other clients ck ce c c c msg server the global type for this session relies on the that links each msg to its following we write it as g msg x it starts with a quantification over all clients x upon by the server of a message from x the global type specifies that should be sent to all the other clients y client an alternate server could be one where the server collects all incoming messages and then sends a digest to all clients in that case the global type would be written g msg y x the central synchronisation between the two quantified types is important in our model the semantics is different if this synchronisation is removed g msg x the global type g means that independently for each client the server first collects a message msg and then immediately sends back to this same client a message projection from global types to local types we now define the projection operation which for any participant z a role r in a session g computes the local type it has to to we say an endpoint projection of g onto z r written g is the local type that the participant z should respect to play the role r in session g as mentioned in § the main difficulty lies in the projection of the quantifiers let us first consider informally the global type x rg this global type has the same semantics as for some p pk the role r if we write the projection of x rg for a participant pi role r written as x rg pi r we can single out the instance corresponding to pi pi r pi r pi r x r pi r based on this intuition behind the projection of quantifiers we give the projection definition in figure projection is ie for each role r of a session g a local type t g p is computed with p z r the case p p r is defined by replacing z by p pp li pi ui p p li pi ui gi p pi ui p p li pi ui gi pi ui p p li pi ui p li pi ui gi p ii p p li pi ui p ii gi p x r pg z z r x r z pg z r z p x r pg px r pg p otherwise g g p g p g p g g p g p g p p p x p x p end p end figure projection the projection of communication leads to a case analysis if the participant to ie p is the sender then the projection is a selection sent to p if p is the receiver then the projection is an input from p if participant p is both sender and receiver then the projection is an output followed by an input otherwise the communication is not observed locally and is the operator then merges the different remote branches this operation was introduced in § roughly speaking it makes sure that the locally observable behaviours are either independent of the chosen branch or can be properly identified through their labels it is defined by t t t and the following equality p li pi ui p l j p j uj tj jj p lk pk uk lk pk uk lk pk uk tk tk when k i j pk pk uk uk note that the merging operation may not return a result if the session uses labels an example can be found in § finally the most critical rules define the projection of a quantified global type x r pg p the first rule applies only when the quantification acts on the same role r as the projection and when p is not in the exclusion list p in that case as explained above the local type is the parallel composition of g where x r is substituted by p for p and a quantification p the second rule the projection through the quantification on a different role or if p is in p other rules are as well we say that g is if g can be ie projection gives a result for each of its roles example projection example we give an example of projection for the session from § which features nested quantifiers the local type t z client is calculated in the following way p is z client client msg string x z client client msg string z client x client msg string z client x client zy client msg string z client x client msg string z client x client msg string z client y client msg string z client x client z y msg string x client z x msg string y client z x client z y msg string x client z x msg string x from example we give the projections for each of the three global types the projection of g for the server and client roles gives tz server client x client msg y client x y client x tz client µx server msg x client z server x note that the between msg and is present in the servers local type the projection of g results in tz server µx x client x client msg y client y client x tz client µx server msg x client z server x we note that the servers local type represents a behaviour which first collects all incoming messages and then sends a digest to all clients on the other hand the client behaviour is the same as in session g the projection of g is given as tz client x client msg y client x tz server msg server x in the above types for each client the server first collects a message msg and then immediately sends back a message to this client wellformedness for typechecking to work global types need to follow a set of rules that will ensure a reliable and unambiguous session behaviour syntax correctness we apply rules to construct syntactically correct types a first point that is verified is that every participant variable x is bound by a quantifier and that it is consistently used with the same role then we check that recursion variables do not appear under quantification or explicit parallel composition formally if a global type is of the form x r pg or g g then g and g are required not to contain any free recursion variables this condition prevents any race condition between different iterations of the same loop we give a few examples of correct and incorrect global session types × g msg x x g msg x g msg x y other checks include the verification that the position of end is indeed correct for example g end g end is not wellformed as seen in § projection does not always return a local type due to the verification made when branches are merged the merging operation verifies that each branch is properly labelled and that no local process can be about which branch to follow we thus require that any global session type g should be × g msg pay msg g price pay stop the in g cannot distinguish the two msg sent by the in g the knows which branch has been taken by the since the upper one is labelled by price and the lower one by stop linearity the concept of linearity is introduced in but in our case we use a relaxed version to allow flexible parallel compositions explicit or through quantification and branching it makes sure that messages are always labelled in a way that prevents communication to verify the linearity of a global type g we first need to transform the quantifiers into explicit parallel compositions to this effect we associate to each role r of g a big enough list of participant names p p then we compute for each role r the local type tr g p r and replace every subterm of tr of the form xr pt by tp with pi p j the first two participant names for role r that do not appear in p this transformation is called we leave the implicit quantifiers of the instantiated roles definition linearity we say that a global type g is linear if for all roles r of g the tr of tr g p r satisfies if p li pi ui and p l j p j uj tj jj are both subterms of tr then i ji li l j l j jj ui uj pi p j ti tj this definition checks that if two exist in the local type of a role r then either they share no label and thus cannot be or they share exactly the same set of message labels with identical types in which case they should only differ by the distinguishing lists of participants these lists allow to target different continuation types even when concurrent threads expect messages with the same labels × g x msg xy g x msg y xy the of g p is are p p are q q msg q msg q these two concurrent threads have identical guards but different continuations the of g p is msg q q msg q q in that case the participant identity y is added to the label msg and is able to the concurrent wellformedness we now give the formal version of the wellformedness condition note that it is decidable definition wellformed global types we say that a global type g is wellformed if the following conditions hold syntactically correct g is syntactically correct g z r is defined for each role r of g linearity g is linear definition example wellformedness we test the wellformedness of the example from § the numbers below correspond to the wellformedness conditions recall the global type g g x match y xy yx price xy order y xy stop end the syntax correctness is checked easily there is no recursion participant variables are bound and used for a unique role and end is g is since the two branches match do not to use different labels stop to propagate to the y the choice that the makes concerning linearity the potential problem is in the first message when a x receives a message match or from the x should know which parallel instance it concerns among the ones the quantification y creates we only give below the verification details for the with p p and q q the result of the of g p is match q q q price q order q q stop match q q q price q order for g q q q stop the result gives p p price p order stop p p price p order stop we check linearity by looking at the different occurrences of the same label for example match in g p being received from the same participant eg we verify that the lists of participant identities are different whenever the continuations are different linearity is thus only achieved here thanks to the communication of the y in messages match and as it can be seen in the case the and here omitted linearity are trivial session typing system this section introduces the typing system and proves subject reduction theorem and type safety corollary there are three main differences with previous session systems first a participant x can appear free in environments types and processes and is necessarily bound by universal quantifiers second previous systems did not allow any parallel composition of types which use common channels since the projection of a universal quantified type generates parallel compositions we relax this restriction thanks to the wellformedness of the global types definition the typing system for initial processes is kept simple third our runtime typing system needs to track parallel behaviours by and joins typing systems environments we start with the grammar of environments u s y r x c t is the standard environment which associates variables to sort types or roles shared names to global types and process variables to session types is the session environment which associates channels to session types we write u s only if u dom similarly for other variables we define the sequential and parallel compositions for types as follows dom dom c c c c dom dom where and c c is syntactically wellformed typing systems for initial processes we detail the typing system for expressions and processes in figure the judgement for expression typing is given as e s the judgement for process typing is given as p which can be read as under the environment process p has session type rules are standard env means that is wellformed and s type means s is wellformed under since a participant variable with role can appear both in types and environments we need to use techniques to make sure that types with free variables do not appear before the variables declarations and ensure wellformedness see definition rules are introduction rules for participants associated with roles rule init types the of a session with global type g the judgement end means that only contains end or the rule ensures the is not bound by the prefix rule join types a joining process that follows the projection to p a leaving process is typed if the remaining session type is completed ie end rule sel is for the selection of label li participants pi and e we first infer the destination p from if e is an atomic type eg bool or a shared channel type then it is typed as in standard selection rules for the expression by recording participants pi in the resulting type this way we can preserve the dependency between the participants during and session communications rule is a session rule rule is the dual of the selection rules note that the participants p and pi in c p li pi are free so that they are bound by the and dynamically instantiated by reductions rules assume and are defined rule is the introduction rule for the universal quantification it only concerns a single session otherwise other sessions are copied after the other rules are standard since checking wellformedness is decidable following the standard method § we have proposition assuming the bound names and variables in p are annotated ie processes whose bound variables are annotated by types typechecking of p terminates typing runtime processes while the session typing systems for initial processes are simple typing runtime which keeps tracking intermediate invariants to prove the theorems is not trivial due to parallel processes and participant instantiations generated by we first extend the syntax of types t to include message selection type p r l p u which is an intermediate type for labelled values stored in the message buffer to type runtime processes we need to extend judgements to p which means that p contains the message buffers whose session names are in we only show the most interesting typing rule for the register a g g xi ri ti a s r sp ji ri tip ip ji i pi i i p p assigns to the a type which holds a set of local types for all roles with participants which are not recorded in r session typing p is erased once it with the process ap ji see rule join in figure and the resulting ji holds p ji tip see the proof of subject reduction theorem in when two runtime processes are put in parallel rule a queue associated to the same session does not appear twice for composing the two session environments either we sequence a message type t and a local type t for the same session channel as sp r t t or we check whether sp r t and sp r t can be parallel composed as sp r t t by checking the linearity condition for t t following definition and otherwise undefined then we define replacing by in the definition of subject reduction as session participants join interact and leave runtime session types need to follow this is by a type reduction relation on session environments as follows sq r p r li pi ui sq r p r lk pi uk tk sp r q r lk pk uk sq r p r li pk ui sp r sq r tk if k i sp r p r lk pk uk p r li pi ui sp r tk if k i sp r x ri pt sp r t px t with pi p t t if if in the above type reduction rules message selection types are considered modulo the type equivalence relation and e is a type evaluation context ie e e t t e e t rule corresponds to the choice of label li rule corresponds to the exchange of a labelled value from participant p r to participant q r rule is about and receiving rule universal quantifiers and types with respect to the participants which are not in the exclusion list p rules are congruent rules we assume all processes are derived from the initial processes § ie subterms of those who are reduced from using the above definitions theorem p then e p and p we say p has a type error if expressions in p contain either a type error for a value or constant in the standard sense eg if then p else q or a label error eg the sender sends a value with label l while the receiver does not expect label l from the env ei bool i env env y r s type u s true false bool bool e e bool or rl pr us id a g p a g end u g p y g p p c end a gp new ag init join c p c end leave p p j e s j p c tj j i p p j p c tj j i c p l j p j e p c p li p j si sel c p l j p j c p c p li p j t c t p i i pi yi si pi c ti ui si or c p li pi pi c ti yi ti c p li pi ui ui ti x r p c t p cx r pp c x r pt end nil e bool pi i p q pq x p x env if e then p else p if p q par p q seq µ x p rec x x figure session typing for initial processes subject reduction theorem and the wellformedness of global types definition we can prove corollary type safety suppose p for any p such that p p p has no type error communication safety and progress this section discusses the difficulties that a distributed session semantics creates when participants can dynamically join leave and we illustrate two limitations of the semantics and typing system presented so far and propose a solution based on multiparty locking that allows more flexibility for leaving a session and guarantees communication safety we give two progress properties one of which goes beyond existing limitations leaving a session while our operational semantics in figure allows a participant to leave a session at any time the typing rule leave in figure only allows a participant to leave when its local type is end recall the example from § g is of the form x end with g x client msg string the recursive type prevents any participant from ever leaving since a process will never reach type end we however remark that a client can play just one interaction round ie g and leave safely before another session iteration occurs if the starting and ending points of global types are known some participants are able to leave a session safely while others communication safety and progress in traditional multiparty sessions the subject reduction theorem immediately communication safety and progress in a single session the reason is that standard multiparty session ensures that all are eventually present it for the expected fixed number of participants to join while the typing system guarantees the safety of the communications when they start this does not hold in our system due to the between joining leaving and we illustrate this point with the example from § in that global type every client is msg to all the others recall the client process from § az client zs y msg m sx client zs x x at each iteration every client does exactly two operations now suppose that a client does the first operation to send msg before another client joins it means that this new client will not receive the message it expects more generally the that correspond to the need to always give the exact same result as the this suggests that some mechanism to distributed processes is required to guarantee consistent results multiparty locking for synchronisation this subsection shows that a simple locking policy that can be automatically computed from the global type is able to ensure a safe synchronisation to allow flexible session and consistent results the key point is to block late participants from joining in the middle of a session execution in order to prevent any interference with this is simply done by automatically surrounding global types by locks means that the interactions specified by g are protected from late and is called a locked global type this condition is easily implementable using a standard two phase protocol which the necessary synchronisation between processes figure and is easily implementable in ml § the example from § is now defined by msg string x this type allows participants to join at each recursive iteration preventing while the exchange of msg is under way syntax we first extend the syntax of processes figure as p c lock c unlock ar p r the process syntax is extended to locking and operations the has two new states ar represents a that is in the process of being locked so far by participants while represents a that is locked and where participants are still involved semantics the operational semantics with multiparty locking is given in figure it defines the relations between the three states of the and is based on a standard two phase locking protocol commonly found in distributed applications the first phase is the state if the is of the form a s r participants can join and leave the session through join and the only other reduction rule that can be applied is lock which puts the in its second state the locking state ar then the session can only wait for all the current participants in r to their locks by the rules up top a new process can join by join and a current process can finally decide to leave from the active session the difference between up and top lies in the side condition a g sa s r s ri g init ap a s r · r p ry a s r · r p p join ap a s r · r p ry a s r · r p p p r join sp r a s r · r p a s r · r p p sp r a s r · r p a s r · r p p sp a s r a s r p r p r lock sp a s r a s r p r s r p r sp s r p r s r a s r sp r p r l p v s r s h s r s h · p r p r l p v r p r r p r up top down unlock p rr p rr send sp r p r li pi s r s p r p r lk pk v · h s r s h p rr k i recv sp rx r pp s r · r p s r · r p rr p p pk p rr other rules are from figure operational semantics with multiparty lock r holds when p r p r r r · r p p consequently top is only when the set contains the exact same combinations of participants and role as the set r meaning that all participants have their locks the application of rule top marks the beginning of the interaction state with a of the form s r only in this state can the rules send recv be safely applied the goes back to its state by the application of rule unlock which can occur only when besides one participant has the unlock operation by rule down types and typing the syntax of global and local types are extended from figure as follows g t lock unlock we say that a global type g is if there exists at least one finite path whose leaf is up to the unfolding of g a type can be easily defined by a system is pp li pi ui is if for some k i gk is and others are defined see for example l u l u x is but l u x l u x is not we define the condition for global types and environments definition and we say that a global type g is if g is closed ie no free participant and recursive type variables and of the form end and g does not include any lock we say that a closed global type g is if g is of the form x end with end and g is we call if for all u g g is either or we call if for all u g g is type means that a single multiparty session is locked type x states a multiparty session is repeatedly locked the persistent lock ensures if a new participant p wants to join it can join at the beginning of the interaction g and if one to it can at the end of the session consequently it requires the global type to be of the form x with a g that does not contain any infinite loop which would prevent from reaching a new iteration unlock the persistent condition is needed for the final strong join progress discussed later local types lock and unlock come from the projection z r lock g z r unlock this way correct locks are automatically inserted at the right points of the local types typing lock and unlock is straightforward env env c lock c lock c unlock c unlock we add the following rule which types c as some projection of session g in the environment p c end u g c p c g p the above rule is useful when g is sup pose g g x end by the above rule we can type lock q unlock c if q has type g p since g pg p g p where t t means t is isomorphic to t once session is one can leave the active session at c instead of the same session g p as a simple example recall the server from § the following client leaves a session after one interaction which is typable under g x end with g x client msg string ap client zs y msg m sx client zs x s communication safety and progress we first state communication safety it states that in a session execution no receiver for a message that will never come and that there is no messages sent but never received definition we say p is communication safe if · p e q with q sp r p r li pi implies that there exists e q e q s p r p r lk pk v · h with k i and · p e q with q there exists e q s p r e q p r lk pk sp r p r v · li h implies that pi with k i the first statement means that branching processes can always find out a correct element in the message buffer and the second one is its dual note that combining with type safety the receiver will input a value v of the expected type definition join we write p £ if p is typable and with a type derivation where the session typing in the premise and the conclusion of each prefix rule is restricted to be at most a singleton more precisely in and contains at most one element in in seq in in in figure deleting we say q is a join if a g q and q does not contain shared name restriction and any join process p £ ensures that p contains several join processes each of which holds a single session while join has only one active point a and once the session at a q can only perform session communication at that session we prove the communication safety in a single multiparty session theorem communication safety suppose a g p and p is initial assume a g is and p does not contain any shared name restriction for any p such that p p p is communication safe the proof starts by a definition of coherent environments a certain kind of duality relation over multiple participants § then we prove a stronger subject reduction theorem that shows the reduction of processes preserves the of the resulting environment we note that session corollary comes also as a corollary now we prove the progress property in a single multiparty session as in theorem ie if a program p starts from one session the reductions at session channels do not get stuck definition progress property we say p can progress or satisfies the progress property if whenever p p then either p p r or for some join a g q with a g such that p q r and r can progress the above definition means that a process satisfies the progress property if it can never reach a deadlock state ie if it never reduces to a process which contains active sessions this amounts to containing waiting process at some session channel and which is irreducible in any context with join q running in parallel theorem progress suppose p and p is initial assume is and p does not contain any shared name restriction then p can progress join progress the above standard progress property is not strong enough since all late cannot to existing sessions this subsection states a new progress property not found in the literature recall the example from § and change the position of the recursion in the global type to g x map reduce x from g we have the following welltyped processes ps z client s server map server reduce x ps z server sx clients x map x reduce x while the interaction between them is communication safe the problem is that a late client will never be to by the existing server because the servers operation is not repeated to include in other words the late client cannot join an existing already running session persistent locking ensures this situation does not happen the property can be generalised to from a g if we compose a parallel composition of processes to e q in definition as definition a similar is possible for definition below we write q if p q and p q is derived using send recv or at sp r with ie p with a queue or through sp r definition join progress property we say that a g p satisfies the join progress property if · p can progress and · if p sp a s r then for any join a g ap with p r fresh and for any r such that p a s r ap s r r q if sp r r then there exists q r and sq satisfies the join progress property the above definition says that a fresh ap can always join the existing session s in p in addition it can always progress at the created session channel s by interacting with p more intuitively once some participants under any role start a session the late can still join that session and interact with earlier further note that we can consider any join ap to make a process progress which with the definition of the progress property definition where p is only composed of joining processes theorem join progress suppose a g p and p is initial assume a g is and p does not contain any shared name restriction then p satisfies the join progress property we have for our examples proposition properties of the examples assume that each global type g in the protocols ­ of § is replaced by then all examples are safe and can always progress moreover if each global type in the protocols of § inside the recursive type ie x is replaced by x then they additionally satisfy the join progress property implementation prototype implementation the calculus has been implemented as an extension of ml following the technique used in the global types that the programmer writes are compiled into an endpoint function for each role this choice allows to replace the implementation of the typing system by an automated generation of welltyped processes that can be used through an api by the programmer the session semantics is thus entirely generated and implemented by communication libraries a distributed implementation the main issue for our compiler is to as much as possible the aspects of the semantics of figures and first concerned the message buffers are completely distributed and implemented on the sender side a thread is to make sure that the message gets across the tcp channel second the can be partially distributed with one per role that deals with the corresponding joining leaving and activities these distributed however need to in to the global locking events rules lock top unlock are attributed to participants by age the first for a role plays the as well until he in which case the is transmitted to the second extension instantiated roles like the server or from examples in § are modelled through an inefficient implicit quantification our implementation gives a special status to these roles we use the fact that they play their own as a consequence no separate is necessary to send them messages and the extra messages required by the quantification can be avoided efficiency to gain we propose an implementation with and improved first since the operation is communication our implementation tries to the number of messages that are the main illustration is that if two messages are specified to be sent in a row between the same participants they are automatically a more change is to do the only once for every participant at the beginning of each locked part of the session execution the advantages are to limit the number of sent messages and to remove in effect the global synchronisation point of rule unlock as soon as all operations are done the distributed session execution can safely proceed until the list of participants of the next iteration is rule top related work the first motivation for the present work is a strong need to extend session type theory with dynamic of multiparty sessions and abstraction to support a range of communication protocols found in practice the for multiparty session types comes from the design of highlevel global protocol signatures for web services choreography description language in types of participants are declared as instances of types of roles which represent collections of interaction behaviours later some of the members of the wc working group have started developing a language called based on the theory of multiparty session types is currently being with for several different application domains in distributed systems including and protocols our example in § was extracted from the specification document the need for roles in session programming is also by our in implementing web service and parallel algorithms for clusters using session java sj in this work we first describe communications between processes in a global topology eg a mesh or a ring in the form of multiparty session types the compatibility between and our present work is yet to be investigated as complex with dynamic features need sophisticated distributed synchronisation algorithms see also § the second motivation for the present work is the of dynamic features most suited to and compatible with existing multiparty session types ­ the conversation calculus models distributed behaviours among places using new primitives such as conversation contexts ie shared interaction points and up communication similar to a conversation models the interactions between a client and various services with dynamic joining into a conversation for a possibly unknown number of processes while both their work and ours aim to support dynamic for sessions the two join mechanisms are quite different their join is encoded by base primitives for late joining into a point of conversation which more closely the late asynchronous session in on the other hand our join mechanism is and at the level of global types by a single type construct which binds participants to a role in contrast to the process which joining might be a sender or depending on the result of the projection ie the position of this flexibility enables direct modelling and clear ie without encoding of different patterns of dynamic parallel protocols including symmetric § and examples and by types in they proposed a sophisticated typing system that builds a wellfounded order on events similar to the line of to guarantee progress for processes under the assumption that all communications are matched with sufficient they do not however explore type inference for progress decidability of a generation of wellformed ordering our progress can be on the other hand guaranteed by wellformedness of global types with an automatic insertion of locks which means a typing system with progress is decidable with proposition this leads to a simple but practical prototype implementation as discussed in § a strong joining property has not been studied in contracts record abstract interaction behaviours of processes and typable processes themselves may not always satisfy the properties of session types such as progress it is proved later by checking whether a whole contract to a certain form proving properties with contracts requires an exploration of all possible interleaved or nondeterministic paths of a protocol see § the first to use roles to model dynamic in the context of session types was made in this idea is further developed in a thesis which a core calculus for session interactions a session structure is described as a collection of binary session types for broadcast channels used to send messages to role participants new participants can only join a conversation before it starts type structures for global protocols and their induced properties in particular progress are not studied in for further comparisons of session types with other calculi and behaviour typing systems see for a wide ranging survey of the related literature conclusion and future work this work introduced a session type discipline for dynamic behaviours among an unspecified number of participants a wellknown open problem of multiparty session types is through a powerful universal type construct which can represent many communications protocols ranging over parallel computations pp protocols and despite the greater expressiveness projection and type checking are decidable global types offer a practical for a correct multiparty synchronisation mechanism by which the theorems properties are as subject reduction and type safety with dynamic join and leave semantics communication safety and progress and x join progress our prototype implementation demonstrates the direct applicability of the present theory to the full potential of the session type theory several challenges need to be addressed first the theory can be integrated with the multiparty session exceptions developed in in order to handle system failure and in a larger class of distributed protocols preserving type safety it is especially useful to directly express more complex and dynamic in combination with the type theory from one extension that comes immediately to mind is the addition of an explicit existential x rg it however raises many semantic issues consider g x msg in that example every client a server the intuition is that each x chooses his y the question is how can we ensure by local typing that servers will be to the right number of requests the difficulty is that a server y can be potentially chosen by every client x or by none and that this choice is distributed and thus very hard to locally type check consequently the global existential quantification rather abstracts complex distributed al a different solution is an extension to subtyping between roles r r by which we can represent a protocol with eg a client sends a message to a subset of second typebased approaches for correct locking has been widely studied including in a framework of linear program analysis and types our aim in § is to propose a simple way to synchronisation by global types another use of global descriptions for different purposes one such instance is studied in where multiparty session types lead to an efficient buffer analysis along with automatically guaranteed communication and buffer safety a benefit of using global types ie a choreography framework is that the analysis can be done solely based on global types without directly possibly distributed endpoint types or processes since we can assume all processes agree with that global specification an integration with global and local locking is however an interesting future topic from the viewpoint of local refinements third we are currently with several working on open for protocols and architectures and to the practical use and expressiveness of the session framework for which an integration with multiparty logic and security for monitoring is our next task we are to honda hu and for their helpful comments we thank the anonymous reviewers for their precise questions and suggestions this work was supported by and g references web services choreography description language advanced message protocols online appendix of this paper l et al global progress in dynamically multiparty sessions in concur volume of lncs pages ­ springer k r pm c fournet and j cryptographic protocol synthesis and verification for multiparty sessions in pages ­ l k honda e and n yoshida a theory of for distributed multiparty interactions in concur volume of lncs pages ­ springer m g and s access control for mobile agents the calculus of boxed ambients toplas ­ l and h t conversation types in esop volume of lncs pages ­ springer a full version will appear in s i m and t session types for access and information flow control in concur volume of lncs pages ­ springer s e and n yoshida global escape in multiparty session in th to appear g and l contracts for mobile processes in concur number in lncs pages ­ g j and f z the calculus inf comput ­ r and p a protocol compiler for secure sessions in ml in volume of lncs pages ­ springer pm and n yoshida communication analysis in distributed multiparty sessions in concur volume of lncs pages ­ springer full version prototype at m and u de sessions and session types an overview in volume of lncs pages ­ springer e m s and s safely role for session types preliminary online ­ pages k honda a g tc chen and n yoshida interactions with a formal foundation in lncs springer to appear k honda v t and m language primitives and type disciplines for structured programming in esop volume of lncs pages ­ springer k honda n yoshida and m multiparty asynchronous session types in popl pages ­ r hu d o n yoshida and k honda typesafe sessions in java in ecoop volume of lncs pages ­ springer r hu n yoshida and k honda distributed programming in java in ecoop volume of lncs pages ­ d n yoshida and k honda global principal typing in partially commutative asynchronous sessions in esop volume of lncs pages ­ l n yoshida and k honda multiparty symmetric technical report department of computing college london to appear in express project at o n ng r hu n yoshida and y safe parallel programming with session java technical report department of computing college london a of roles specification specification and thesis college london project project k c k l and p efficient session type distributed interaction in coordination volume of lncs pages ­ springer k typebased verification for lock primitives and mutable references in volume of lncs pages ­ k k honda and m an language and its typing system in volume of lncs pages ­ springer international organization for standardization universal message scheme h a calculus for modeling and analyzing in computing phd thesis university de n yoshida graph types for monadic mobile processes in volume of lncs pages ­ n yoshida pm a and r hu multiparty session types in volume of lncs pages ­ n yoshida v t h and k honda compilation framework for programming in volume of lncs pages ­ springer 