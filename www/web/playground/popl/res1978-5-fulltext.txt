record of the fifth annual acm symposium on principles of programming languages syntactic control of interference school john c reynolds of computer and information university science abstract in programming languages which permit both assignment and procedures distinct identifiers can represent data structures which share storage or procedures with side effects in addition to being a direct can impact type structure source of programming errors this which we call and parallelism we show how to eliminate these difficulties interference by syntactic restrictions without the kind of constructive interference which occurs with higherorder procedures or classes the basic idea is to interference between identifiers but to permit interference among components of collections named by single identifiers the problem it has long been known that a variety of can arise when a programming language combines assignment with a sufficiently powerful procedure mechanism the simplest and best understood case is aliasing or sharing between variables but there are also of the kind known as side effects in this paper we will show that these are instances of a general which we call interference we will argue that it is to constrain a language so that interference is syntactically and we will suggest principles for this constraint between simple variables the only form of interference is or sharing consider for example the program procedure f integer n f ko integer fl k while k n do lk kl end suppose n and f are called by name as in algo or by reference as in fortran and consider the effect of a call such as z in which both actual parameters are the same then the formal parameters n and f will be aliases ie they will interfere in the sense that assigning to either one will affect the value of the other as a consequence the assignment f will the value of n so that z will not behave correctly in this case the problem can be solved by changing n to a local variable which is initialized to the value of the input parameter this is work supported by national and by the of great science foundation grant science research to calling n by value solution is adequate for simple become for arrays procedure but while variables it for example this can the procedure y real array x y for i until do for j until do yi j xj i will for a call such as z which causes x and y to be aliases but changing x to a local variable only solves this problem at the of in both time and space certainly this should not be imposed upon calls which do not produce ence on the other hand is best done by a completely different algorithm this suggests that it is reasonable to permit procedures such as but to calls of such procedures with parameters although these difficulties date back to algol and fortran more recent languages have introduced new features which the problem of interference one such feature is the union of data types suppose x is a variable whose value can range over the union of the disjoint data types integer and character then the language must provide some construct for branching on whether the current value of x is an integer or a ter and treating x as one type or the other for example one might write x of integer s character s where x may be used as an identifier integer in s and as an identifier in s however consider of type of type character x of integer y a character n x it is evident that aliasing between x and y can cause a type error in the expression x thus in the presence of a union mechanism interference can type security this problem occurs with variant records in pascal and is only avoided in algol at the of copying union values the introduction of parallelism also causes serious difficulties hoare and have argued that programming requires all interactions between parallel processes to be by some mechanism such as a critical region or monitor as a consequence in the absence of any critical regions or monitor calls the execution of two statements written s s can only be permitted when s and s do ot with one another for example x xl y y x would not be when x and y were aliases in this paper we will not consider interacting parallel processes but we will permit the parallel construct s ii s when it is syntactically that s and s do not interfere although evident this kind of determinate parallelism is for cal concurrent programming ih ia sufficient to make the consequences of interference especially for example when x and y are aliases the above statement becomes equivalent to whose meaning if any is machine dependent and useless these examples demonstrate the of a language so that variable aliasing is syntactically indeed several authors have suggested constraints which would eliminate aliasing completely however aliasing is only the simplest case of the more general of interference which can occur between a variety of program phrases we have already of two statements when one can perform any action which affects the other similarly two procedures interfere when one can perform a global action which has a global effect upon the other interference raises the same problems as variable aliasing for example p ii q is only meaningful if the procedures p and q do not interfere thus the case for syntactic detection extends from aliasing to interference in general however the complete of interference would be restrictive since unlike variables expressions statements and procedures can have different meanings both the and the of inter between procedures arise when procedures are used to data representations as an example consider a finite directed graph whose nodes are labelled by small integers such a graph might be represented by giving for each node n a linked list of its immediate successors nl nk item link bk this representation is used by the procedure procedure begin integer k k while k o do end integer n procedure p k causes the procedure p to be applied to each immediate successor of the node n if the graph is ever to change then something ­ probably a procedure such as or must interfere with by assigning to the global arrays item and link on the other hand the correct operation of requires that the procedure parameter p must not assign to these arrays ie that p must not interfere with indeed if involved parallelism eg if the body of the while statement were m integer m m ii k end then noninterference between p and would be required for rather than just correctness of course the need for procedures would if the graph representation were a parameter to the procedures which use it but this would an important style of programming by in which data abstraction is realized by using collections of procedures which interfere via hidden global variables in summary these examples the basic goal of this paper to design a programming lan guage in which interference is possible yet syntactically to the authors know the only current language which tries to meet this goal is the approach used in is quite different than that given here and procedural parameters and callbyname the basic approach before the idea of interference further we must more precisely by a mean a or procedure denotation expression in the first statement three cases we of the phrase p meaning either assigning or evaluating p if it is a variable evaluating p if it is an expression or executing p if it is a statement for phrases f and q we write p q to indicate that it is syntactically that p and q do not interfere more precisely is a syntactically decidable symmetric relation between phrases such that if neither p nor q denotes a procedure then p q that for all ways of p and q the exercise of p will have no effect on the exercise of q and thus the meaning of p and q in parallel is welldefined and determinate if p denotes a procedure a an are syntactically appropriate ac t p q q q then a q thus p q captures the idea p cannot interfere with q via global variables it should be that these rules have a character p q implies that p and q cannot interfere but not the converse indeed the rules are satisfied by defining to be universally false and there is a sequence of satisfactory definitions which come ever closer to the semantic relation of interference at the of increasing complexity where to stop is ultimately a question of p q should mean that p and q obviously do not interfere our own approach is based upon three principles i ring then if i j for all identifiers free in p and j occurring p q i in q in effect all channels of interference must be named by identifiers for the language discussed this paper this principle is trivial since the only such channels are variables in a richer language the principle would imply for example that all devices must be named by identifiers in ii if i and j are distinct then i j identifiers this is the most of our principles since it enforces a particular convention for distinguishing between and phrases procedures and other entities are still but they must occur within a collection which is named by a single identifier an example of such a collection is a typical element in a class indeed the idea of using such collections was suggested by the class mechanism although we will permit collections which do not belong co any iii certain types of phrases such as expressions and procedures which do not assign to global variables are said to be passive when p and q are both passive p q passive phrases perform no assignments actions which could cause interference cannot interfere with one another or themselves although an active phrase phrase can interfere or other thus they even with and a passive an language to illustrate first introduce an although it satisfies the above principle principles we will language which i permits principle interference we will to make interference then impose syntactically finally we will explore the consequences of principle unlike algol the language is completely typed so that reduction ie cation errors of the copy rule cannot introduce it provides lambda expressions syntax and fixed point operators for all program types cartesian product which is needed for and a named the collections declarations classes are discussed under principle ii procedure procedures and treated as syntactic sugar ie as abbreviations which are defined in terms of more basic constructs arrays unions of types references jumps and and critical regions are not considered we distinguish between data types which are the types of values of simple variables and program types which are the types which can be declared for identifiers and specified parameters the only data types are and boolean as in algol but there number of program types specifically for integer are an the real infinite set of program types is the smallest set such that tl if meaning expression is a data type then var variable and exp meaning are program types t type sta meaning statement is a program t f if u and u are program is a program type types then t if identifiers a program is a function into program type from a types then of is a formal parameter specified to have type var can be used on either side of assignment statements while a formal parameter specified to have type exp can only be used as an expression the program type u m describes procedures whose single parameter has type w and whose call has type u for example the algol procedures integer n n real procedure px real x p x x x would have types integer real exp respectively var sta and real exp the program type ii is a cartesian product in which components are indexed by identifiers than by consecutive integers specifically collections in which in the domain a component of type i the function u will always be written as a list of pairs of the form thus for example sta val integer exp describes collections in which inc a statement and val an integer expression a typical phrase of this type might be inc n n val n x n to simplify the description of syntax we will ignore aspects of concrete representation such as and we will adopt the that each identifier has a fixed program type except when used as a component index when in fact the program type of an identifier will be specified in the format iu when the identifier is bound we write u id and i to denote the sets of identifiers and phrases with program type lo then the syntax of the language is given by the following production in which ranges over all data types lo o wi un range over program types and il in range over identifiers integer exp o i integer boolean exp true i integer i boolean and similarly for operations on data other types constants and sta var exp sta i sta sta i while boolean exp sta sta new var w u id id in sta w w a id w t oj u iii u i on i u nn wk iii u i k if boolean exp then else although a formal semantic specification is beyond the scope of this paper the meaning of our language can be by various reduction rules for lambda expressions we have the usual rule of xi p q q where the right side denotes the result of substituting q for the free occurrences of i in after changing bound identifiers in p to avoid conflicts with free identifiers in q note that this rule implies call by name if p does not contain a free occurrence of i then ai pq p reduces to p even if q is nonterminating side effects for collection expressions or causes we have inp for example inc n nl val ik n pk inc n nl again there is a of since the above reduction would still hold if were replaced by a nonterminating expression the fixedpoint operator can also be by a reduction rule in addition to lambda expressions the only other binding mechanism in our language is the declaration of new variables the statement new i integer real boolean algol statement in s has the integer begin real boolean same meaning i s end by themselves lambda and as the new variable declarations are an vocabulary for variable binding but they are sufficient to permit other binding mechanisms to be defined as abbreviations this approach is for the language constraints which will be given below since it that all binding mechanisms will be affected uniformly following curry procedures are treated pa an pa an ai in b e ai ai b n and definitional declarations forms are treated including following procedure let i q in p u ii pq u ai q however unlike we are using callbyname we will omit type specifications from let and let rec expressions from q when the type of i is apparent as shown in the appendix classes in a slightly more limited sense than in can also be defined as abbreviations as an example the declaration of the procedure fact shown at the beginning of this paper along with a statement s in the scope of this declaration would be written as let fact ln integer new k integer in exp f integer var k f while k n do k kl f ins after eliminating abbreviations this becomes integer exp integer var in integer exp af integer var new k integer in k o f while k n do k kl f sta s controlling interference the language already satisfies principle i if we can constrain it to satisfy principle ii as well then p q will hold when and q have no free identifiers in common by assuming the most pessimistic definition of compatible with this result and the consequences of principle iii until the next section we get p p q fq where fp denotes the set of identifiers which occur free in p to establish principle ii we must consider each way of binding an identifier a new variable declaration causes no problems since new variables are guaranteed to be independent of all previously declared entities but a lambda expression can cause since its formal parameter will interfere with its global identifiers if it is ever applied to an actual parameter which with the global identifiers or equivalently with the procedure itself to avoid this interference we will restrict the call pa of a procedure by the requirement p a the following informal argument shows why this restriction works ai pq consider a within p there may be a pair of identifiers which are syntactically required to satisfy the relationship and therefore must be distinct if so it is essential that the i q preserve no problem occurs if neither identifier is the formal parameter i on the other hand if one identifier is i then the other distinct identifier must be global thus the relation will be preserved if k q holds for all global identifiers k ie for all identifiers occurring free in ai p this is equivalent to ai p q more formally one can show that with the restriction on procedure calls syntactic correctness is preserved by beta reduction and also by reduction of collection expressions and continues to be preserved other productions restricted by are added when eg sta sta l sta when sta sta the restriction p a on pa also affects the language constructs which are defined as tions for let i q in p z ai pq and for let rec i q in p n except for i no free q we see that of q can occur free in p thus although one can declare a procedure or a collection of procedures which use global identifiers the free identifiers of q these are masked from occurring in the scope p of the declaration where they would interfere with the identifier i for procedures pa an pa an implies the restrictions p al pa a pa which are equivalent to requiring p ai for each and ai aj for each pair of distinct parameters for example consider for a repeat statement the following procedure let repeat as sta b boolean s do s exp in any useful call a the statement al will interfere with the boolean expression a although this is permitted in the unconstrained language as in algol it is by the restriction a a instead one must group the parameters into a collection let repeat xs ax sta b boolean xb do xs exp and use calls of the form repeat sa ba this example is characteristic of principle ii although parameters are permitted they require a somewhat notation in it is immediately clear to the reader of a procedure body when interference between parameters is possible passive phrases in making interference syntactically detect able we have been restrictive for example we have forbidden parallel constructs such as or let twice as sta x s s in ii yx moreover the right side of the reduction rule yf ff violates the requirement f yf a clear sign that there is a problem ith recursion in the first two cases we have failed to take into account that the expression n and the procedure twice are passive they do no assignment to global variables in the case of procedures and therefore do not interfere with themselves similarly when f is passive f f holds and the reduction rule for f becomes valid this the recursive definition of procedures which do not assign to global variables recursive procedures which assign to global variables are a more difficult problem within the body of such a procedure the global variables and the procedure itself are entities and must therefore be represented by components of a collection named by a single identifier this situation probably doesnt pose any fundamental difficulties but we have not it the following treatment of is more than the previous development expressions in our language are always passive since they never cause assignment to free variables procedures may be active or passive independently of their argument and result types thus we must distinguish the program type u p u describing passive procedures from the program type m u describing possibly active procedures more formally program types with we augment the definition of t t p if o and u are program is a program type types then and we define passive program smallest set of program types pi exp is passive types to be the such that p w u is passive p if domain of is passive for all then ii is passive i in the next for any phrase r we define ar to be the set of identifiers which have at least one free occurrence in r which is outside of any of passive type note that since identifier occurrences are themselves ar never contains identifiers of passive is a of itself ar type and since r is empty when r has passive type then we relax the definition of p q to permit p and q to contain free occurrences of the same identifier providing every such occurrence is within a passive we define p q fp define global finally we a passive identifier modify the abstract syntax procedure to be one in which has an active occurrence we no q i u id p ut when au u id passive permits procedures can occur active procedures in any context which t p but only fixedpoint passive procedures operator can be operands of the u p some questions our abstract syntax is ambiguous in the sense that specifying the type of a phrase does not always specify a unique type for each for example in the original language the if p then x else y might a variable or expression in contexts be either such as z if p then a if p then x else x else y y b b similarly permits either the type the introduction as sta or of passive sta s s sta in p procedures to have the context as sta s sx xl although these could probably be eliminated our intuition is to retain them while that they must not lead to ambiguous meanings indeed it may be to extend this to a variety of implicit conversions in normal usage a procedure call will be active if and only if either the procedure itself or its parameter are active although other cases are syntactically they seem to have only trivial instances thus it might be desirable to limit the program types of procedures to the cases pa ea where ei and are passive types and a and a are types the most serious problem with our treatment of is our to retain the basic property that preserves syntactic correctness consider for example the reduction ap mixed x pa ii y pa bn o x a nl a where stands for the program type integer exp b sta although the first and last lines are reasonable the inter line is rather since it contains assignments to the same variable n within two statements to be executed in parallel less our definition of still permits the inter line on the that assignments within passive phrases cannot be executed however if we accept x a nl y a nl then it is hard to is sta x a nl b n y a nl but this permits the reduction s sta x a nl b s y a nl x a nl b a n a nl a x nl a here the intermediate step in which the under statement is clearly illegal is by our syntax this kind of problem is by the possibility of procedures for instance in the above examples one might have n o where has type integer exp sta mixed in place of the collection a nl b n o a possible though solution to these problems might be to permit illegal phrases in contexts where guarantees a more possibility would be to alter the definition of substitution to avoid the creation of illegal phrases in such contexts directions for further work beyond dealing with the above questions it is obviously essential to extend these ideas to other language mechanisms particularly arrays in addition the interaction between these ideas and the axiomatization of program correctness needs to be explored we that many rules of inference might be simplified by using a logic which imposes preservation upon substitutions a somewhat aspect of this work is the distinction between data and program types which obviously has implications for userdefined types note the absence of this algol in less algollike distinction languages in data types might have as much structure as program types and user definitions might be needed for both types of type indeed there may be for introducing more than two types of type finally these ideas may have implications for the optimization of callbyname perhaps to an extent which will overcome the of which this concept for example when an expression is a single parameter to a procedure as opposed to a component of a collection which is a parameter then its repeated evaluation within the procedure must yield the same value although nontermination is still possible this suggests a possible application of the idea of lazy evaluation appendix classes as syntactic sugar in a previous paper we have argued that classes are a less powerful data abstraction mechanism than either higherorder procedures or userdefined types the greater generality of higherorder procedures permits the definition of classes in the sense of hoare rather than itself as in our language in fact the basic idea works in algol although the absence there of lambda expressions and named collections of procedures makes its application we consider a class declaration with scope s of the form class init ip s which defines c to be a class with component names i here decl is a list of declarations and procedures which will be private to a class element init is an initialization statement to be executed when each class element is created and each p k is the procedure named by ik in which the private variables may occur as within the scope s one may declare x to be a new element of class c by writing the statement x c in s then within the statement s one may write denote the component pk of the class element x to express these notations in terms of procedures suppose p pn have types respectively the we define to be an abbreviation for to let c ab sta decl init ins where b original expressed then we is an identifier not occurring in the class declaration and where decl must in terms of new and let declarations define to an for be s as an example where for are procedures simplicity pi and p class n n o inc n nl val k counter x in n in is an abbreviation for let counter ab sta val integer exp sta new n integer in n o n nl val n sta val integer exp x which eventually reduces to new n integer n n o nl x n in the process of reduction identifiers will be renamed to protect the privacy of n the only effect of our constraints is that c must be a passive procedure ie init and pi pn cannot assign to any variables which are more global than those declared by decl this that distinct class elements will not interfere with one another otherwise if c is not passive then s in the definition of cannot contain calls of c so that multiple class elements cannot most of this research was done during a and at the university of edinburgh special thanks are due to burstall and robin milner for their and helpful working suggestions group and to the members of ifip especially hoare for establishing the viewpoint about programming which this work references n the programming language pascal acts informatica pp van a cd b j j e l and c h a report on the algorithmic language algol mr amsterdam february hoare c a r towards a theory of parallel programming in operating systems techniques academic press new york hoare c a r monitors an operating system structuring concept pp comm acm october comm acm p structured july pp hoare c a r procedures and parameters an axiomatic approach in symposium on the semantics of algorithmic languages cd e springer york g j j j b w mitchell j g and london r l notes on the design of in proceedings of an acm conference on language design for reliable software sigplan notices no march pp o j hierarchical in structured programming new york program academic structures press curry h b and r combinatory logic volume i northholland amsterdam p j a correspondence and lambda notation between algol comm acm february and march pp and p and morris j h jr a lazy evaluator third acm symposium on principles of languages pp friedman d p and d s cons should not evaluate its arguments third int colloquium programming on automata edinburgh languages university and press pp hoare c a r representations proof acts of correctness of data informatica pp reynolds j c types and procedural data structures as complementary approaches to data abstraction in new directions in algorithmic languages s a pp ed 