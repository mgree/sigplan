consistency analysis of programs rice university university of university of abstract applications in many areas of computing make discrete decisions under uncertainty for reasons such as limited numerical precision in and errors in inputs as a result individual decisions made by such programs may be nondeterministic and lead to decisions at different points of an execution this means that an otherwise correct program may execute along paths that it would not follow under its ideal semantics essential program invariants on the way a program is said to be consistent if it does not from this problem despite uncertainty in decisions in this paper we present a sound automatic program analysis for verifying that a program is consistent in this sense our analysis proves that each decision made along a program execution is consistent with the decisions made earlier in the execution the proof is done by generating an invariant that abstracts the set of all decisions made along executions that end at a program location l then verifying using a fixpoint that no contradiction can be derived when these decisions are combined with new decisions made at l we evaluate our analysis on a collection of programs implementing algorithms in computational geometry consistency is known to be a critical and studied correctness property in geometry but ours is the first attempt at automated verification of consistency of geometric algorithms our benchmark suite consists of implementations of convex hull computation and point location algorithms on almost all examples that are not consistent with two exceptions our analysis is able to verify consistency within a few categories and subject descriptors d verification correctness proofs f semantics of programming languages program analysis f computational geometry and object modelling geometric algorithms languages and systems g mathematical software reliability and keywords program analysis uncertainty consistency geometry this research was partially supported by nsf and an discover grant permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm if q then l else l if r then l else l if r then l else l figure a code introduction the problem of making decisions under uncertainty has computer for a long time abstractly a process is a program that information about an external world using a set of queries and based on this information makes changes to its discrete internal state an issue with such programs is that the information that they from the world may be and this uncertainty may affect programs decisions even a single wrong decision may lead the program down code paths that were never meant to be followed leading to errors for example consider a program that queries the world for the relative positions of three points p q and r on a line let v denote the decision by the program that u lies to the left of v and v the fact that u is actually to the left of v now suppose the program makes the decisions q and r in this case the program should also decide that r as the laws of geometry demand that q r r however uncertainty creates a difference between what to be and what is different queries to the world can be independently and if p q and r are close enough to be within the of error the program may very well decide from the final query that not r holds suppose now that the program in question looks like the one in fig then in the above scenario it will execute the code l l l a sequence that would not be executed under any input in the programs ideal semantics where the laws of geometry hold since algorithm design often does not consider this scenario the consequence could be a serious error a program is consistent if it is from errors like the one described above abstractly let r be an axiomatic specification of the laws that we know to hold in a world eg a program is consistent if it does not any axioms in r no matter what answers it receives as the result of its queries to the world consistency is an essential concern in applications where programs make boolean decisions under uncertainty it is for example a studied problem in computational geometry where programs make decisions about relative positions of objects in continuous geometric spaces often these positions can in the geometry literature consistency is known as we avoid the latter term given its recent use in the program verification literature to denote an entirely different concept if q then l if r then l l else l if r then l else l else l if r then l if r then l else l else l l figure consistent variant of code in fig only be known with limited degree of and up to a limited level of accuracy for instance a robot doing geometric reasoning to detect with other objects must base its discrete decisions on data even on a computer the outcomes of discrete queries about geometric are typically due to numerical it is wellknown that inconsistency between such decisions can cause geometric algorithms to crash go into infinite loops and violate essential postconditions at the same time consistency in our sense is not easily enforced through usual software engineering it is difficult to test a program for consistency since by definition errors due to uncertainty may not be furthermore as software is typically designed without uncertainty in mind consistency is usually outside the scope of manual reasoning about algorithms for example most algorithm designers assume the axioms of geometry to hold to reason about correctness of their designs and would not imagine situations where they might break down when these axioms are finally reasoning about consistency requires one to relate decisions made at different points in a program execution to each other most programmers find this type of global reasoning about programs to be inherently difficult given all this the problem of automatic formal verification of the consistency of a program seems to be important there is very little prior work on this problem researchers in application areas like computational geometry have traditionally clear of static reasoning about consistency instead focusing on dynamic approaches while there is an literature on quantitative reasoning about programs in the formal methods community to our knowledge there has been no prior work on verifying that a program makes sequences of discrete decisions consistently in this paper we present a sound automatic program analysis to address this verification problem our analysis applies to programs that query a world consisting of an arbitrary number of abstractly defined data objects a decision is the outcome of a query we model uncertainty using nondeterminism assuming that each query by the program can return either true or false to see how a program can be consistent under such a model consider the code in fig which is equivalent to the program in fig in the absence of uncertainty ie when y if and only if y however even if the left queries resolve nondeterministically due to uncertainty this code is still guaranteed to satisfy the axiom in the subtle difference between the two codes is that the one in fig does not query a fact when from the context and the set of axioms the only answer to the query is known to automatically prove the consistency of programs like the one in fig we must track the dependencies between different decisions made by the program this is especially challenging when the program an unbounded number of objects for example suppose that a program by repeatedly the world that p p pn for objects p pn if the program now also queries for the relative positions of p and pn we may have a consistency violation this is because we have pn as a logical consequence of the programs decisions by while due to uncertainty the result of this query may very well be not pn to prove consistency we must be able to reason that this type of violations namely those that are derived through unbounded trees of reasoning cannot occur our approach to the automation of such proofs is based on an inductive argument first for each program location l we compute an invariant hl called the history invariant that abstracts the set of all decisions made along all possible executions leading to l inductively we assume the decisions in hl to be mutually consistent next we compute a invariant dl that abstracts the set of new decisions that may be made at l consistency verification now amounts to establishing that no decision in the set represented by dl taken together with a subset of decisions in hl can violate an axiom we show that this check can be accomplished using a standard fixpoint constraint solver decisions taken during the execution of a program over a collection of input objects are abstracted by tuples of integers where integers stand for object identifiers eg may stand for the decision p this then the abstraction of decision invariants as defined above by integer linear arithmetic formulae we evaluate our analysis by applying it to a suite of programs from the domain of computational geometry including implementations of standard algorithms for convex hull computations and point location algorithms while small in size programs like these are at the of geometric libraries used by large realworld systems such as information systems computer and various scientific computing applications these examples are also complex the reasons why they satisfy consistency or fail to do so are often subtle and small changes to the code can turn a consistent algorithm into an inconsistent one or vice versa however in almost all of the programs that are actually consistent our analysis is able to prove consistency automatically and efficiently we summarize the contributions of this paper as follows · we formulate the problem of verifying the consistency of programs sec and give a sound automatic program analysis to solve it sec · we identify an application domain for our analysis where consistency is a critical correctness property and where program analysis has not been tried before sec · we provide a prototype implementation of our system and evaluate the practical utility of the system using a suite of convex hull and algorithms sec formalizing consistency in this section we formalize the property of consistency for programs we start by defining the worlds that are by our programs these queries are with uncertainty and it is this uncertainty that may cause a violation of consistency modelling the world a world consists of a set of typed objects together with a set of predicates that are used to query various relationships between these objects formally a world is a tuple base o q r where base is a set of base types o is universe of objects with types ranging over base q is a set of predicate symbols whose arguments have types in base and r is a finite set of axioms where an axiom is a universally quantified firstorder formula over the predicates in q intuitively the predicates in q form the interface between programs and the world we assume for easier that each a q has the same arity m the axioms r the laws of the world eg the laws of geometry since the understanding of nontrivial worlds is often partial we do not expect our axioms to be complete in a mathematical sense example let tc o be a world in which is the type of points on a line o is a set of such points and consists of a single predicate left the predicate v holds for u and v iff u lies to the left of if ux vx where ux and vx are respectively the of u and v with respect to a fixed origin a sensible set of axioms for tc is as follows the transitivity axiom used in the introduction y y y y y y y y y lefty y lefty y lefty y an axiom that asserts that left is complete ie any two distinct points on the line are related by left y y y y left y y left y y to reduce notation we adopt two simple syntactic conventions while writing down axioms first we drop the explicit universal quantifiers over the axiom variables second without loss of generality we use distinct variable names in the axioms to represent distinct objects in models of the theory for example the first axiom in the above example is written simply as lefty y lefty y lefty y the assumptions y y y y and y y following from the fact that y and y are different symbols it is acceptable however to write the axiom rx x to state that a predicate r is reflexive programs next we define a core language of programs programs in this language are a symbolic transition systems that can manipulate both individual objects and lists of objects there is a key modelling question in the definition of how do we model the uncertainty in a programs queries about the world our definition does this via nondeterminism we assume that every call of a program to a world predicate may return an incorrect answer this model may appear too conservative at first given that we do not model uncertainty however it has several advantages the first and is its generality the model is equally applicable to settings where uncertainty is the result of errors as it is to the settings where floatingpoint error is the source of uncertainty any reasonable quantitative model of uncertainty on the other hand would have to be domainspecific and perhaps consider lowlevel details of the hardware used for or computation second our model is simpler and therefore more amenable to automated reasoning than quantitative models indeed given the highly challenging nature of the consistency analysis problem this model offers a for static analysis finally our empirical experience with the model is satisfactory we ran some experiments with our benchmark examples from sec for the case when uncertainty is only due to numerical error for the examples that are inconsistent under our model it was always possible to produce a concrete input that forces the program to violate basic invariants under floatingpoint semantics in other words these examples would be inconsistent under any other reasonable definition of consistency program syntax let us fix a world base o q r and a universe of variables each variable represents either an object in o or a list of such objects variables of base types are denoted by x x x and variables of list types representing collections of objects are denoted by x x x we assume an alphabet q of symbols whose members have a correspondence with the predicates in q for a q we denote the corresponding symbol in q by a also we define a symbol a for each a q and let q be the set of such symbols it is assumed that q and q do not have any overlap with each other or with q intuitively for objects p pm the notation ap pm represents the decision made by the program that the fact ap pm holds and ap pm represents the decision that the fact pm holds we allow a program to test and manipulate its local variables using the following primitives · we allow boolean expressions that test whether a list is empty x and x · we allow the following kinds of assignments to variables x x an assignment where an variable x is set to the value of another variable x x and x respectively set x to the value of the first and last element of the list x the list x is not updated x and x respectively remove the first and last elements of the list x and set x to the value of this element x sets x to the empty list x x sets the list x to the value of the list x x x adds the object x to the front of the list x append x x adds the object x to the end of the list x the syntax of programs is now given as follows definition programs a program over a world is a tuple p loc l t where loc is a finite set of locations l loc is the initial location and t is a set of transitions a transition l t l from a location l to a location l is of one of the following forms l ax xm l l ax xm l l l l u l where a q a q xi var b is a boolean expression and each u is an assignment of one the forms above each transition l t l takes the program from location l to location l transitions of forms and represent queries to the world and decisions made on basis of those queries a transition of form is taken when a call to a q returns true and one of form is taken when it returns false transitions of form are local tests on program variables while those of form are updates to variables for instance the transition l x l is executed when control is at l sets x to the first element of x without updating x and moves the control to l note the used for q which distinguishes this set from q the sets of locations and variables of p are respectively denoted by and var p note that a location may have multiple outgoing or incoming transitions however we assume without loss of generality that whenever p has a query transition l l then it has no other outgoing transition at l we denote by the set of locations in p that have an outgoing transition of the above form locations like this are known as query locations we assume all predicates in p to be welltyped if a transition is guarded by ax xm and xi is of type i then the type of a is × · · · × m semantics now we sketch the semantics of programs under uncertainty let a state of p be a pair s l where l is a location and is a function that maps variables xi and xi to appropriately typed values the set of states of p is denoted by p the semantics of p is defined using a labelled transition system in where is a set of semantic transitions and in is a set of initial states an initial state of p is a state of the form l for some and where each object o appears at most once in at most one list in the domain of ie initially the contents of the lists are and pairwise disjoint the set is the least relation such that for all transitions t l t l in p · if t is a query x xm for q q then we have l t l for all · if t is an assignment x e or x e then for each state l we have l t l where is obtained by updating the variables of p according to the semantics of assignments sketched earlier · if t is a test and l is a state that satisfies b then we have l t l we define an execution of p as a finite sequence l t l · · · ln n such that l in and for all i li i ti li i for each location l the set of executions ending at a state l for some is denoted by the set of all executions of p is denoted by it seems intuitive to define a semantics of programs in absence of uncertainty where queries obtain true information about the world eg a query transition l ax xm l is enabled at a state where xi has value pi if and only if the relation ap pm holds in the world however such an ideal semantics is of no use to our analysis where the core concern is the effect of uncertainty and therefore we do not develop this semantics consistency an execution of a program p may issue a sequence of queries whose answers taken together violate r we say that p is consistent if this cannot happen in any execution to formalize this notion of consistency we need a formal definition for decisions a decision in the world is a literal p pm where q q p pm o and the type of pi matches the expected type of the ith input to q we denote the set of decisions over by dec or simply dec for a decision denotes the literal ap pm when equals ap pm and pm when equals ap pm now let l t l · · · tn ln n be an execution of p we define a decision of to be any decision p pm dec such that for some i we have ti li x xm li for all j m pj the set of decisions of is denoted by dec one can represent the decisions made during an execution of p using a logical formula which we call the decision formula of that execution which is defined as dec consistency of p is now defined as follows definition consistency the program p is consistent with respect to the world if for all executions the formula rr r is satisfiable thus our goal is to verify that a given program p is consistent under the above definition example let us consider the code in fig once again it is easy to translate this code to a program over the world tc from example we assume ll are simple assignments this program a bounded number of objects and has a bounded number of executions by these executions we find that it is consistent now let us consider a more involved program also over tc that issues queries over an unbounded number of objects as with the previous example we write the program in a more readable structured syntax which can be easily translated into x x while x do if x then skip else skip x x x in our model the test in line can always evaluate however we can argue that this program is consistent nonetheless let the objects in the input list x have identifiers to n consider the execution that takes the of the code in all iterations the decision formula for is left left left n now note that r where r is the conjunction of the axioms in example is satisfiable it is not hard to see that for every execution of r is satisfiable therefore the program is consistent on the other hand if the program made an extra decision in the execution then the conjunct would be added to and the above property would no longer hold consistency in geometric programs in this section we show how the notion of consistency plays out in the context of computational geometry we do so using two examples both are algorithms for computing a convex hull for a set of points in two dimensions d one of the algorithms is not consistent while the other is as before we describe the algorithms using a more readable structured syntax rather than that of the world any convex hull algorithm queries a geometric space about tions of points in it this space ch is our world formally we let ch o where is the type of points on the d o is the set of all d points and consists of a single predicate v w the se of this predicate is that to the left of the infinite directed w is true when example in fig w is a we have p p under the ideal semantics of reals this cyclic symmetry y z z x y z z y y z z y y t z t x t y z transitivity y z y t z t z w y w y w figure axioms for convex hull algorithms predicate can be defined as vx ux where ux and are respectively the x and of u we define using an axiomatization of convex hull fig by knuth consider fig a again and note that p p axiom says that this implies the facts p p and p p axiom says that we cannot have p p in this case axiom is an tion that no three input points are points form a case for convex hull algorithms fig a is inside the if p is to the left of pp ppp and more oriented defines counter or a transitivity property p is to the of to understand its geometric intuition consider fig b with x p y p z p t p and w p in this case we have p p p p p p p p p p the axiom demands that we also have p p which is indeed true here p p p a b p p p p p p figure and transitivity axioms axioms ­ are easily seen to be consistent with geometry in knuth that if the results of all predicate checks for a set of points satisfy these axioms then a convex hull always exists while the above axioms are specific to convex similar are known for other classes of geometric computations inconsistent convex hull consider the algorithm in fig which is a naive and slow algorithm for computing the convex hull of a set of points s note that it is standard for convex to have a following the convention developed earlier we use v w to denote the decision made by the algorithm that v w the algorithm iterates over all pairs of points u v as potential convex hull edges if there exists a point w such that the decision v w is made then u v is removed from the set of edges forming the convex hull since if u v is an edge of the convex hull in the direction then every other point must lie to the left of u v it is easy to see that if the algorithm is implemented using input a set s of points in the d output a list e containing the edges of the convex hull e for all ordered pairs u v s × s with u v do valid true for all w s with u w and v w do if v w then valid false if valid then add the directed edge u v to e figure inconsistent convex hull ideal reals without any uncertainty then in fact computes a convex hull on the other hand under uncertainty for example due to floatingpoint error the decision v w can evaluate nondeterministically consider the input set in fig where the correct hull is illustrated in a p p is true but the points p p p are nearly first note that the algorithm may evaluate for all permutations of the three points p p and p if due to numerical uncertainty the program that p p p p and p p then none of the three edges p p p p and p p will belong to the convex hull and the resulting hull will be as illustrated in b which is not even a closed curve similarly we could have a scenario where all three edges end up in the convex hull where all the three queries return true and the result will be as in c again completely wrong since it has two cycles p p p p p p p p p p p p a p p p p p p b p p p p c p p d figure inconsistency in convex hull the main problem is that for both cases b and c where de p p and p p are both taken there is an inconsistency with the axiom of fig the consistent executions of this program result in either a or d the convex hull in d is obtained from deciding that p p p p and p p these decisions are not all correct but they are consistent while figure d is slightly different from the ideal answer it is structurally a convex hull an output that would be produced by the ideal which p is algorithm to move to on some input the left of line is an input in in contrast b and c are outputs that the ideal algorithm could never produce to see why this difference is substantial consider a procedure that iterates over the hull computed by the convex hull routine starting with p and terminating when it comes back to p again in case d it will terminate as usual in case b it will not be able to proceed past p in c it could get stuck in an infinite loop the inconsistency of the above algorithm is by no means a many implementations of convex and other geometric computations are inconsistent the infinite loops and other errors that inconsistency can lead to are we refer the reader to for an in depth discussion of the consequences of inconsistent geometric computations consistent convex hull graham scan graham scan fig is an example of a consistent convex hull algorithm the point p which we know belongs to h is our in the main loop we p check if the last two points u and v of h together with a new point w from s make a left turn p p p this test is encoded using the predicate if so then we p assume that these points belong to the hull and add w to h if not then v cannot p p belong to the convex hull of s since both edges adjacent to v figure graham scan have a point to the right of them and therefore they cannot be convex hull edges and we delete it from h for example upon considering p p p in the figure p is deleted from h in gen we keep deleting until the last two points in h together with w make a left turn note that there is no bound on the number of points that may be deleted during this step the graham scan algorithm unlike the naive algorithm is con we discuss why in sec it is very difficult to reason about consistency of this algorithm manually one needs to reason about all program paths containing many facts dependent on the size of input and argue that none contains an inconsistency with respect to the axioms an user may be able to argue why none of the first axioms in fig can ever be by this algorithm the algorithm in a way that for every three points p q and r it evaluates the q r predicate exactly once the last point r is always a fresh new point there it is not possible to find two predicate evaluations that are not consistent with any of the first three axioms which all need two different evaluations of the predicate on two different permutations of the same points but extending this reasoning to axioms and manually is difficult in the next section we present an analysis that is able to easily verify the consistency of the above algorithm we note that the assumption that the input points are sorted on basis of their from p is needed for the algorithms functional correctness however it is irrelevant to the programs consistency even if the input points were ordered arbitrarily the decisions made in an execution of the algorithm would not violate axioms and structurally the output would still be a simple closed cycle our analysis chooses to ignore the assumption that the input list is sorted in this way this information is lost in ab and still an automated proof that the algorithm is consistent verifying consistency in this section we describe our method for algorithmic verification of consistency let us fix a world base o q r and a program p the broad idea of our algorithm is to prove p input a point p rightmost point in the set and nonempty list of s of points the points in s are assumed to be sorted on basis of increasing from p output list h containing the points forming the convex hull also sorted on basis of their from p s if s then return p s h for w do v u while ¬ v w do if h then v u else break append w to h w p v u while ¬ v w do if h then v u else break append p to h return h figure consistent convex hull algorithm graham scan the operation returns the second last element of the list without modifying the list consistent by an inductive argument each time a new decision is made we assume that the set of decisions that have already been made are consistent and prove that the new decision does not violate consistency in combination with past decisions we this reasoning in two phases as follows in the first phase we approximate the sets of decisions that can be made by executions of p by constructing an integer abstraction of p and then computing numerical invariants for example illustrates the idea behind the integer abstraction which models objects as integer identifiers and sets of decisions with sets of integer tuples we analyze with an abstract interpreter to compute for each query location l of p a invariant dl that symbolically represents the set of decisions that can be made at l a history invariant hl that symbolically represents the set of all decisions made along executions that end at location l our representation of a set of decisions by a numerical invariant makes use of a set of integer auxiliary variables which represent the arguments of queries that our encoding represents objects as integer identifiers a set of decisions ie a set of tuples of objects is represented by an arithmetic formula over the program variables as well as the auxiliary variables the set of models of such a formula can be interpreted as a set of decisions or more accurately as a function mapping program states to a set of decisions for example let us the program of example here for convenience x x while x do if x then skip else skip x x x let us assume that the objects in the list have strictly increasing ids eg the first point on the list has id the second id and so on and let us use auxiliary variables left and left to respectively represent the ids of the first and second arguments of the call to left at line we have the invariant x x and we have outgoing query transitions ax x and ax x the invariant at this location is dl left x x left on the other hand in a history invariant left and left refer to the ids of the arguments of an arbitrarily selected past call to left while x and x refer to the current program variables since the program processes list elements in order of increasing ids the following history invariant holds at line hl left left x x in the second phase of the algorithm we verify that for each query location l in the program p there is a model of the world that is consistent with the decisions dl and hl ie dl hl and the world axioms r together cannot derive false the challenge here is that there may be no obvious inconsistency between dl and hl but false may be derived using the axioms in r and there is no a priori bound on the size of such a proof to overcome this challenge we generate a logic program from the world axioms r that given a invariant dl and a history invariant hl generates every decision that can follow from the decisions in dl and hl the problem now reduces to verifying that this system cannot possibly derive a contradiction this task can be solved automatically using existing fixpoint constraint solvers such as next we describe the two phases of the algorithm in detail generating history and invariants to generate the history and invariants used by our consistency verification procedure we first abstract p by a program over the integers in each object accessed by p is modelled as a integer id in addition to simulating the execution of p records the decisions it makes using a set of auxiliary variables denoted by constructing we abstract lists by pairs consisting of the ids of the first and last element of the challenge in this list abstraction is to maintain information about a list as objects are added to it or removed from it our approach to doing so is to maintain the invariant that the objects in appear in an order sorted by their ids note that there is no relation between these ids and any values associated with the objects themselves we just assign the ids to the elements of the list in order in which they appear on the list for instance let x and x respectively denote the ids of the first and last items in a list x assuming that our invariant holds the integer abstraction of returns the value of x and sets x to a nondeterministically chosen value between the current values of x and x note that since the abstraction assigns the integer ids they are not part of original object information all the input lists to the program are initially assumed to satisfy this invariant based on the precondition about the disjointness of the lists and the elements on each list that we already mentioned in section of course the invariant can be violated when the program tries to insert an item x into a list x we detect such violations by comparing the id of x with the value x if is violated we conservatively flag the program as inconsistent our analysis can be generalized to one where object ids are not integers but tuples of integers or even more generally elements of a partially ordered set for simplicity we to integer ids in this paper we now present the construction of formally to avoid introducing more notation we describe the program in a syntax an integer program is a tuple loc var l t where loc is a set of locations var is a set of variables ranging over the integers and booleans l loc is an initial location and t is a set of transitions transitions between locations l and l have the following forms · test transitions l l where b is a linear arithmetic formula · l l which changes the value of the variable x to an arbitrary integer value · l x e l an assignment to variable x and · l l which asserts that a property b expressed as a linear arithmetic formula holds we do not give a detailed semantics for these transitions as they are standard for simplicity we sometimes write sequential compositions of transitions as a single the syntax l x e l is abbreviation for a pair of transitions l x e l and l l where l is a location that is not used anywhere else in the program now let p var p lp tp we construct the pro gram loc var l t as follows · the initial location l of is a fresh location not in loc contains and l and also a number of auxiliary locations introduced in the translation of transitions fig inherits a notion of query locations from p for all q q we define loc loc p · var is the least set such that for each variable x in p var contains an variable that tracks the id of x notation we call this variable x as well for every variable x in p var contains two variables x and x that track the ids of the first and last elements of x for each a q and each i m var has an variable ai ranging over the integers these variables are used to record var contains a special variable for each a q this variable is set to true when the ai variables are initialized ie the arguments of some query is assigned to them initially each variable is false · the set of transitions t of is defined by the rules in fig here the rule init captures the fact that the ias are uninitialized at the beginning of program executions the two rules query and query abstract query transitions one of them sets the a variables while the other does nothing together they model a nondeterministic choice to save the arguments of a decision in the a variables the remaining rules are integer abstractions of updates to and tests of object and variables and history invariants having constructed an integer program abstraction of p we may use standard techniques to generate for each location l loc a numerical history invariant hl our implementation an abstract interpreter over a domain of partitioned which we describe further in sec each hl is a linear arithmetic formula over the variables var which includes the variables which correspond to variables of p as well as the auxiliary and q a aq init l false false l t l x x l tp l x x l t l l tp l x l t l l tp l x l t query l x xm l tp a a l a x ma xm true l t query l x xm l tp a a l l t first l x l tp l x x x l t next l x l tp l x x x max x x l t last l x l tp l x x x l t tl l x l tp l x x x x x l t la l x x l tp l x x x x l t empty l x l tp l x l t app l append x x l tp l x x x x x l t l x x x x l t af l x x l tp l x x x x x l l x x x x l figure construction of the transitions t of from p var p lp tp our construction of ensures that any such formula hl can be interpreted as a mapping from traces to sets of decisions made along those traces the intuition behind this interpretation is as follows let be a program trace which ends in a state l for any a consider the set of models of hl which send each variable to its value in and in which the a variables have been initialized is true each such model m corresponds to an namely the decision am a m am where m ia denotes m s interpretation of the variable ai the set of decisions obtained from models of hl in this way is a superset of the set of decisions made along the precise statement of this interpretation of hl is the following lemma lemma suppose that is an execution of p ending in a state l let id be any mapping from the objects accessed in to integer ids such that ids increase along every list in the initial state of let a q and let v be the set of all variables in var except the a variables define v hl true x idx p then for any ap pm dec the model m that sends each ia to pi is a model of and similarly for any ap pm dec proof let l t l · · · ln n with ln l let p pm dec then there is some i such that · ti li x xm li · for all j m pj with the exception of query append and transitions for any transition of p there is a unique sequence of corresponding transitions in given in fig for append and transitions there are two corresponding transitions but their guards are disjoint so there is a unique choice for the translation of these transitions when the is fixed for query transitions there are two corresponding transition sequences given by the query and query rules consider the execution of which executes the sequence of transitions corresponding to using the query rule for the query transition ti and query for all other query tions along and which chooses the correct nondeterministic updates to the list variables to make the executions and agree let l be the final state of then sends each variable x to idx sends each ia to and sends to true since hl is an invariant at location l we must have hl it follows that m the restriction of to the ai variables is a model of now we describe how to compute invariants consider a query location l with an outgoing query transition l x xm l where a a for some a q by the syntactic assumptions out in sec l has no other outgoing transition the invariant at l can be computed from hl as m dl hl xi ai i where denotes the existential quantification of each variable intuitively dl the relationships between the program variables and the objects involved in the new decision made at l proving consistency of decisions once the history hl and dl invariants have been generated for each query location l consistency verification can be reduced to the problem of proving false cannot be derived from the combination of hl dl and the world axioms r our reduction makes use of our inductive assumption that there is no derivation of false using only decisions from hl now we show how to this proof obligation decision proof systems for purposes we will begin by defining decision proof systems a normal form for the world axioms r after we proceed to the construction of a logic program that can be used to verify consistency of the program p normalized axioms can be of two forms · generators these rules derive new decisions that are logical consequences of decisions taken by the program formally a generator is a rule of the form y ym y · where i are in q q and the range over objects · these rules identify direct between decisions that have either been made by the program or derived by the generators such a rule has the form ym ym where is a special symbol intuitively indicating false a q and the range over objects we interpret the relations in the above rules as sets of decisions and the rule as a way to derive new decisions or derive now we describe how to construct a decision proof system mr from a set of axioms r first we construct the formula rr r and convert it into the conjunctive normal form per our current notation we assume that the initial quantifiers are omitted from formulas in r let the formula have clauses c cn now consider any clause cj t · · · tk of the formula constructed in the previous step here each ti is either of the form or of the form we define two literals ti and ti for each ti if ti then we have ti ti if ti then we have ti ti mr is defined to be the least set of rules such that for each clause cj t · · · tk and each r k mr has the generator tr t · · · tr tr · · · tk for each predicate a q mr has the ay ym ay ym example consider once again the world tc of example which supports the predicate left over d points the following decision proof system is obtained from the axioms of tc lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y lefty y proving consistency we now show how to construct from the invariants and history invariants and the decision proof system a logic program which derives the symbol if p is inconsistent if this logic program cannot derive this proves that p is consistent first we provide some intuition let l be a query location we compute for each predicate a q a relation which relates the final states of program executions that end at l to the decisions of the form a or a which are logical consequences of the decisions made along those executions we also compute for each q q a relation new l which is similar to except that note that since the outcome of decisions are we need not compute a corresponding relations because it would be they would be identical to the relations it includes the decision made at l but not necessarily the decisions which are consequences of decisions in the sets and new l can be described using a set of rules given in the following we use x x xn to denote the list of the variables corresponding to variables of p these variables will be through each of the inference rules so they may be thought of as symbolic constants that help to relationships between the current decision and previous decisions they may be thought of as a way of adding a degree of to our analysis we may think of each valuation of the variables x as a universe and x through each inference rule as a way of keeping separate we begin with rules that initialize and new l using the history and invariants ym x y ma ym new ly ym x y ma ym if l loc and a a new ly ym x otherwise now we give rules to derive the consequences of decisions in dl taken together with decisions in hl for each generator rg mr of the form y ym y ym · · · where a a and for all i i ai ai we add ym x la y ym x yk x new ly ym x l y ym x lk yk x where li new li and such that at least one of the li s is new li the requirement that at least one of the li s is new li ensures that new l does not include decisions that are solely derived from decisions in hl this is used to encode our inductive assumption that there are no in hl finally for each predicate a q we generate three rules that detect direct new ym x ym x new ym x ym x new ym x new ym x let mr be the system of all rules constructed as above we have the following lemma lemma suppose that program p is inconsistent then belongs to the least fixpoint of mr proof let l t l · · · ln n be an execution of the program p such that mr can derive from dec without loss of generality we may assume no proper prefix of satisfies this property it follows that tn the last transition of must be a decision transition ln z ln for some z for notational convenience we use l to denote ln and use to denote the trace with its last action omitted let id be any mapping form the object accessed in to integer ids such that ids increase along every list in the initial state let x be the vector of the variables of p and define p let t be a derivation tree for using the inference rules in mr with the elements of dec taken as axioms initialization new lefty y x x x y y x new lefty y x x x y y x lefty y x x y y x x totality lefty y x x lefty y x x lefty y x x lefty y x x new lefty y x x new lefty y x x new lefty y x x new lefty y x x lefty y x x new lefty y x x new lefty y x x lefty y x x new lefty y x x new lefty y x x transitivity lefty y x x lefty y x x lefty y x x lefty y x x lefty y x x lefty y x x lefty y x x lefty y x x lefty y x x new lefty y x x new lefty y x x new lefty y x x new lefty y x x lefty y x x new lefty y x x new lefty y x x new lefty y x x lefty y x x new lefty y x x new lefty y x x new lefty y x x new lefty y x x lefty y x x new lefty y x x new lefty y x x new lefty y x x lefty y x x new lefty y x x new lefty y x x new lefty y x x new lefty y x x lefty y x x new lefty y x x new lefty y x x new lefty y x x lefty y x x figure for the program in example for any subtree t of t we say that t is new if one of its axioms is nz otherwise we say t is old we first prove that for any old subtree t of t with root q qm we have p la where a a · base case t is an axiom so we must have p pm dec it follows from lemma and the fact that is closed under the following inference rule ym x y ma ym that p pm p la · inductive step t ends with the application of a generator rule rg mr say q qm q qm ··· where a a and i ai ai let t tk be the subtrees of t corresponding to the premises of rg since each of t tk is a proper subtree of t we have qi p for each i by our inductive hypothesis since is closed under the following inference rule ym x la y ym x · · · yk x we have that q qm p la we can use a similar argument to show that for any new subtree t of t with root q qm we have q qm p new l the final inference rule used in t must be the application of a rule at least one of the immediate subtrees of t must be new since if they are all old the axioms of t are contained in dec which violates our assumption it follows that we may use one of the rules to derive and therefore belongs to the least fixpoint of mr example the logic program constructed for the program program in example with respect to the specification of the world tc is given in figure since the only query location is line of the program we omit location subscripts in this figure is able to determine that this program cannot derive so the program is certified consistent our algorithm for verifying the consistency of p is as follows first we construct an integer abstraction and generate numerical invariants using an abstract interpreter we check that each assertion in the program is safe according to the invariants produced by the abstract interpreter if a assertion violation is found indicating a violation of our sorted list abstraction we report p to be possibly inconsistent second we construct the logic program mr and check if mr can derive if it can we report p to be possibly inconsistent otherwise we report p to be consistent by lemma we immediately have theorem if the algorithm a program p to be consistent then p is consistent limitations our algorithm is sound but incomplete there are several possible sources of loss of precision here the abstraction of lists by pairs of integers which require to maintain the invariant that the lists are sorted by ids the limitations of the abstract interpretation used to compute the history and invariants and the incompleteness of in our empirical experience so far these have not much the only substantial source of has been the abstraction of lists by pairs but as in the next section only in two of our benchmark examples does this pose a problem also one could eliminate this issue with a more sophisticated list abstraction implementation and evaluation we have implemented our approach and with a collection of standard geometric algorithms in this section we report on the results it is important to bear in mind that it is very difficult to declare an algorithm by a light inspection even by an user and it is even more difficult to manually prove it is consistent implementation our tool is implemented in ocaml on top of a frontend in addition to taking a c file as input the tool requires the user to supply a proof system m in the form of a set of rules see fig the tool operates in three phases first an integer c program is generated from the original program then numerical invariants are generated for the integer program using an abstract domain we will describe below then for each control point in the program at which a decision is made two datalog programs are generated using the invariants from the first phase and the decision proof system m one datalog program for the case that the new decision is positive and one for the case that its negative we use to check whether a query in any of these datalog programs succeeds if all queries fail then the input program is consistent the abstract domain we use to generate numerical invariants is a partitioned domain partitioning is a technique used to reduce the precision lost in an abstract domain due to an join operator an element of this domain is a partial function f from a finite set of cells to the cells form a covering of the state space and we require that for every cell c the concretization of the f c lies inside c such a function represents a finite disjunction of where each belongs to a different cell in our partitioning scheme the cells corresponds to sets of program variable equalities we built our partitioned domain on top of the domain implemented in benchmarks we collected a set of geometric algorithms from computational geometry these include several convex hull algorithms a few point location algorithms and a few algorithms algorithms like this are the core building blocks of geometric libraries such as the algorithms are presented in the as and therefore there is more than one way of implementing them note that we are not referring to implementation details such as choice of data structures we included more than one version of the same algorithm whenever there was an algorithmic choice about list traversal strategies and other similar notions that can make a difference in the outcome of our verification algorithm below we provide a high level summary of the benchmarks convex we have already discussed two convex hull algorithms and in sec the former is not consistent we discuss the details of the consistency check for the latter in the following the set of benchmarks consists of three other convex hull algorithms the algorithm the incremental hull algorithm and algorithm for the algorithm we present two different variations on how the point set is traversed the incremental hull is a recursive algorithm which has three variations on how the recursive step is performed algorithm uses a major subroutine that computes a half of a convex hull which is effectively called twice we include this subroutine as a separate benchmark note that consistency is not trivially implied by the consistency of this subroutine in a slight variation of original algorithm was presented which is inconsistent in contrast to the original algorithm being designed specifically to be consistent since all other examples were collected from we included this version in the set of benchmarks as well a of a point set p is a of the determined by a maximal set of edges whose vertex set is p the word maximal in the definition indicates that any edge not in must the interior of at least one of the edges in the rule g z x y z rule g x z y z rule g y z y s z s x s rule g y t y z y s z s z t y t rule v y z y z figure decision proof system for the predicate in our benchmarks we have splitting incremental and splitting makes use of a point location algorithm see below and therefore its consistency depends on the consistency of the underlying point location algorithm ie if the latter is inconsistent then the former is also inconsistent since we have two different point location algorithms in our benchmarks we have two versions of the splitting algorithm respectively incremental is similar to the incremental convex hull and we similarly included three versions of it depending on the strategy both splitting and incremental algorithms use the same predicate that is used by the convex hull algorithms is a specific type of that has special uses in many areas eg in reconstruction these algorithms use an operation called to turn an arbitrary into a one or to construct a incrementally relies on a new predicate called that tests if a given point lies within a given the predicate comes with its own complete set of axioms for brevity we omit the definition of this new predicate and its corresponding axioms here and refer the interested reader to unfortunately all algorithms are inconsistent and this inconsistency leads to nontermination under some inputs point location in a point location algorithm the input is usually a of a point set and a point p and the goal is to find the particular that contains p point location queries arise in various settings such as finding ones location on a map and computer it is an essential part of algorithms in the example that we now consider the location is a target there are various inconsistent point location algorithms proposed a consistent algorithm for point location we included algorithm and a standard inconsistent algorithm that is used in implementations axioms and decision proof system all our benchmarks use the predicate introduced earlier we assume an axiomatization as in fig for this predicate fig offers a sketch of the decision proof system derived from these axioms here rules g and g represent the case of axiom in fig rules g corresponds to the cyclic symmetry and axioms while rules g and g represent the and transitivity axioms rule v is the rule for the predicate experimental results table presents the result of the experiments carried out using our tool the upper middle and the lower part of the table respectively show the results for a variety of convex hull point location and algorithms the first two columns after the benchmark names indicate whether the benchmark is consistent and whether our tool to prove it consistent a no answer by the tool means that a counterexample was found for the consistency of the integer c benchmark graham scan v v incremental hull v incremental hull v incremental hull v half hull hull hull t point location v point location v hull location incremental v incremental v incremental v splitting v splitting v splitting v v v consistent no yes no no yes yes yes yes yes no yes no no yes yes yes yes no no no no proved consistent no yes no no yes yes no yes yes no yes no no yes yes no yes no no no no invariant generation time s s s ms ms ms s ms s s ms ms ms ms ms s ms s consistency analysis time s s s s ms s s ms s ms s s s ms s ms s s invariant size table automated consistency verification results invariant generation time refers to the time that it takes for the invariants to be generated for the integer program consistency analysis time refers to the time that it takes to prove the consistency claims invariant size refers to the size of the invariants in number of conjuncts where there is more than one decision location in the program we add the invariants up into a total number but indicate the number of claims within parentheses program however since this integer program is an overapproximation of the behaviour of the original c program the counterexample may not be a real one note that since our tool is sound a combination is not a possibility for these two columns and since it is not complete a option is a possibility for some of the benchmarks no times are reported this is because the benchmark was declared inconsistent in the integer program generation phase since the proper ordering constraints were not followed while manipulating lists in the program interestingly in all such cases the program is indeed inconsistent summary of results out of the benchmarks are consistent there are inconsistent benchmarks that are declared inconsistent when the integer program generation fails to generate a meaningful program note that the terminates much faster in the case where an inconsistency is found since it finds a satisfiable assignment relatively quickly in these cases whereas for the consistent cases it has to effectively prove the lack of a satisfiable assignment for almost all except two benchmarks if the program is consistent our tool succeeds to prove it for a variation of incremental convex hull v and the corresponding incremental algorithm v the list abstraction is too to prove the example consistent the reason for inconsistency is that in the integer program the program is practically making repeat queries in our semantics we assume that repeat queries may get different result from the original ones if we drop this assumption then the tool can be easily to prove these two benchmarks consistent as well the fact that we can prove almost all consistent examples correct using our tool suggests that our proposed abstraction technique is powerful despite its simplicity detailed discussion of graham scan we discussed the graham scan algorithm as an example in sec here we provide a more detailed consistency argument to provide some intuition why our tool succeeds in proving it consistent first an integer program is generated from this program here we assume that the points in s are assigned integer ids in the order that they are from the input list from to s the point p has an id as stated earlier we ignore the assumption that the input points are sorted according to their from this point on we just refer to the points by their numeric identifiers now consider line of the graham scan code fig where the query v w is made we note that u v w is an invariant here and from this observation we can deduce the following history invariant for this location h u v w p p now consider the new decision that is about to be made at line v w invariant generation provides us with the following facts about values of uv and w u v w p u v w w p note that the actual invariant generated by our tool contains many more conjuncts and variables here we are it to the essential core to demonstrate the reasoning also this is a specific case where the outcome of the query was false there will be a similar case where the outcome of the query is true u v w p u v w w p but the reasoning below will be the same though done separately for each of the two cases combining the information for the history and the current decision it is easy to argue that if the history is already consistent then the new decision added will not create any new with respect to any of the rules in fig since the third argument w is provably strictly greater than the arguments which characterize all past decisions it is easy to see why this is the case each argument of the predicate appears at least twice among the premises of every single rule in fig therefore any decision with fresh new point w cannot be involved in generating any new facts or causing a violation the actual reasoning for this is done by in our implementation now consider the decision at line here w never changes and always points to p ie naturally the history for line is also part of the history for line but the history for line also includes the decisions made previously in the same loop our analysis produces the following history invariant h u v w p p p p where the first disjunct refers to the history based on the decisions made at line and the second disjunct refers to the history based on the decisions made at line the current decision invariant is u v w p u v w p p u v w p v p p and similar to above there is a positive version of this decision it is a bit harder to manually reason about this case intuitively it is easy to reason that the decision where the last argument is always a fresh new value cannot generate any new facts or violations when considered together with the history decisions that are generated at line in which never appears the argument about why no new violations are created as a result of combining the new decision with the part of history that comes from line is similar to the case of line related work the problem of consistency has been studied in depth in the computational geometry literature this literature has developed several different notions of consistency for geometric programs our definition coincides with a definition used by among others however so far as we know there is no prior work on static verification of consistency in this area to the extent that verification is mentioned at all it is stated to be too difficult to be realistic instead existing approaches focus on dynamic techniques that are often based on library operations the inherent limitation of such approaches is that they do not reason globally about decisions made at different program points and hence do not give guarantees of consistency the only work on formal verification of geometric programs that we know of comes from the theorem proving community and this work does not study consistency there is an body of work on reasoning about program behaviour in the presence of uncertainty however none of these analyses can reason about the notion of consistency considered in this paper instead they focus on quantitative differences in a programs behaviour due to uncertainty also not applicable are techniques for numerical errors in programs as none of these methods reason about divergence in control flow caused by uncertainty in contrast control flow is perhaps the most central aspect of the geometric programs studied here conclusion we have introduced the problem of automatically verifying the consistency of programs that make decisions under uncertainty and taken the first steps towards solving the problem our solution can automatically verify the consistency of a set of algorithms for computing convex and while this paper focused on finding proofs of the dual problem of finding inputs that cause a geometric program to violate is also of interest also we restricted ourselves in this paper to a model of uncertainty where every predicate can evaluate nondeterministically as we showed even under this highly execution model many computations are consistent however future work should also study less models of numerical uncertainty there are several ways to account for this fact for instance a possibility is to consider quantitative models of uncertainty properties where a query with a certain probability or under certain conditions on the inputs references computational geometry algorithms library j and a a library of numerical abstract domains for static analysis in cav pages ­ abstract interpretation by dynamic partitioning journal of functional programming ­ s s gulwani and r continuity analysis of programs in popl pages ­ s s gulwani and r continuity and s of programs acm ­ l chen a j wang and p cousot interval polyhedra an abstract domain to infer interval linear relationships in sas m de o and m van computational geometry algorithms and applications springerverlag mark de van mark and computational geometry algorithms and applications springerverlag s and j discrete and computational geometry princeton university press s stable of point set in two dimensions in pages ­ e static analyses of the precision of floatingpoint operations in sas pages ­ l graham an efficient algorithm for determining the convex hull of a finite set inf process ­ j reasoning about uncertainty the mit press k n and l de an efficient engine for fixed points with constraints in cav c j hopcroft and m towards implementing robust geometric computations in pages ­ cm the problems of accuracy and in geometric computation computer ­ de knuth axioms and lncs springerverlag r majumdar e and p a theory of robust software synthesis abs r majumdar and i symbolic analysis realtime systems symposium ieee international ­ k the reliable algorithmic software challenge pages ­ k and c robust geometric computation d the of verifying floatingpoint computations acm trans program lang syst c necula scott and intermediate language and tools for analysis and transformation of c programs in cc pages ­ d and y formalizing convex hull algorithms in volume of lncs pages ­ springer j and b pierce distance makes the types grow stronger a calculus for differential privacy in icfp r adaptive precision floatingpoint arithmetic and fast robust geometric predicates discrete computational geometry ­ 