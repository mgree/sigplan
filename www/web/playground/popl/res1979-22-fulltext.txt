type in an world c applied and information c of california la cl sciences san diego we present an for the determination of runtime types which functions in the presence of errors show that it provides more information than that published obtained algorithm using a previously and in section we define the problem and state the requirements for a practically useful type prediction algorithm in section we introduce a model inference and in section j define rules for that language typ section presents a type prediction algorithm and section results describes how to apply the to solve the pro stated in section section presents an f our procedure and demonstrates how work does not satisfy all requirements a requirement fr the efficient translation and execution of is the ability to predict at can the types of variables and expressions a type is defined to be subset of all possible that be in the in question factors which can be used to types rank number of dimensions size storage and the meaning of the data typ can be in to permit compilation instead of interpretation of a language with typing mechanisms the work of describes the of this facility os part of an apl in addition even languages with extensive declaration facilities such as pascal contain areas which can not be reasonably can without type prediction an example is va r i j integer k set integer ki u en in which the set k is a set over the integers set a considerable pro to any pascal which as most do represents sets as a bit vector with a position for each possible p ro code generation of more efficient to permit elimination of redundant run time type checking and b demonstrated for apl the of this and a situation holds for value type checking in pascal p da claim that to be practically useful type prediction must work presence of errors and generate additional information as follows in a the the type determination system identify type conflicts and their source so that an appropriate can be for each type requirement identified system must also the point in the execution of the or before at which the satisfaction can be verified the execution must between for legal execution and of the result of any we claim that the algorithm described below meets these requirements it is derived from an earlier version presented in m the form in which the described is derived from that used by kaplan unman in k and we use their results is m programming language the model programming operations are with the form is stated language an assignment in terms of the basic a xm where x s are variable is a function names of degree and a predicate of the form d where the xi s are variable names pred is a boolean function degree d of a following is a directed graph with the types of nodes assignment nodes which have and equal to one and which are labeled with an assignment statement start node one and only one has zero and equal to one which stop nodes which have and zero one fork nodes which e in degree and two and which are labeled with a predicate join nodes which have and out degree one one two a the program start node execution is a path through graph which ins at the and ends at a stop node ex in a real programming language are represented by creating additional variables to hold the result each single operation except for operations in the real language which use the variable specified and modeling the expression a sequence of assignment nodes of as structure in a real language is by converting it to an equivalent if the n else form can be modeled using the fork and join nodes we associate each of the edges ing a fork node with a particular result of the pred thus the predicate information for type but we consider all paths as possible type inference we associate each edge of the program graph information about the type of each variable the type information at a given is that in ation which is valid when execution of the program takes that edge for each j and variable name w have tw constant functions giving an all types and t in the set the set t is the cartesian product of the sets of the sets of all possible values for each measure which may be applied to a variable in the real programming language in question the type t containing the set as the possible values of each measure is written as and the type containing all values is written as in cases we will be concerned only with a small number of the of a given set and will give those elements names the value of a variable for may be described as integer real mm or character without the set of values for a particular measure included in a type t is specified by of t p specifies that a given variable will have the specified type each time program execution takes the en edge we use p to refer to the vector whose elements e the at each edge r specifies requirements on the type of a given variable which must be met each program execution takes a given edge w use r to refer to the vector whose elements give the requirements at each edge the set expressions for contain property variables a measure these variables are used as place type information not available expressions are symbolically with each variable is may for he a set ex press ion ak g iv ing all values for z k inference within statements using possible property variables it is to specify the requirements and guaranteed individual specifying for ex an ple expression results associated with an assignment or fork node by types on the edges the model and the rank rules for the apl ab are l t rank plt l is z b rank ra is b is where ti is a created and where zi is a unique variable property variable legal pascal whose value may range over array a second fragment all is the var i j k o o begin if then end j u else k where the if statement is modeled as b r value value i lo value p i yf is is is inference across statements for each node containing as statement of the an form m we define d functions t and t d where the it s specify which can be made about the type of the result of the function based on of the type of an operand and the to is specify the requirements which must be placed on operand k in order to satisfy placed on the result forward inference given a prediction of the types of the variables before execution of a node it may be to refine the prediction of the types of variables after execution of the node the new prediction f is the union of the pred f derived each edge j entering node and is applied intersection the old prediction to all edges the node lhe forward inference giving a new prediction for the that with leaving function type of variable xk is given as which is defined by if node is not an assignment to xk the intersection an of all if node is to xk with x m for convenience to be for all enter node we will define f edges k which do not backward inference given variables execution to refine a requirement on the types of which must hold after the of a node it may be possible the requirements which must be before the node executes the new bl are the intersection of those b generated from each edge j leaving node and are edge entering node e inference requirement function g for the type applied on backward a new of variable each is given as which is defined by if node is not an assignment or reference to if node is an assignment to and xk is an operand xk if node is an assignment with operand to x o xk and k for convenience for all edges we define b to be k not leaving node inference forward across the program en the functions f we c an construct using the method given in e a function f x mapping p to p which generates the new resulting from a single parallel execution of every step of the an f x is the inner using set union and function application of the matrix f is f where edge m leaves from node and x given a safe prediction s we can generate a new prediction fs x fx starting execution of the program with every variable undefined p we generate final under the constraint of known information s applying x f x until no change x by results x least fixed of f kaplan unman k prove that this procedure will terminate backwards in a similar fashion given the functions b we can construct a function b x mapping r to r which generates the new resulting from a single parallel execution of every step of the an b x is the inner product using set intersection not union and function application of the matrix b is f where edge m enters node and requirement x given a sufficient s we can generate bx s o bx a new starting execution of the program variable undefined x when the program starts executing we e established no requirements we generate final known information under the constraint of s by applying ux bx until no change results x type prediction algorithm the generating identifying steps of the type necessary runtime for and checks are translate the real program model language into the initialize all type to and apply set intersection within a single ill node apply any information declarations available from if after steps and there exist or requirements which have not been fully specified new property variables to represent the eventual value for each such location in systems such as that described in m which compile at first execution the values of property variables may be available from inspection of the values of the actual variables propagation of these place to other will permit identification of the locations for time checks and the point at which information needed to compile parts of the is available the functions and to the since forward and backwards propagation do not interact only one application of each is necessary simplify the set expressions representing type and and assign values to property variables the property v connect the requirements and which were propagated separately interpretation of type information the distinction made between and requirements allows identification of runtime checks and of type errors the type a type at an operation of the real will be at the node of the model to that operation by the type of the variable assigned to after execution of the node contains the empty set as the possible values of measure the required type of one of the variables with its value before execution the node contains the set possible values of some measure of as the type checking correct execution of the model requires that at each edge and for each variable the actual value be a of the required type if the type prediction making use of all information know about the value of property variables does not guarantee this runtime type checking is necessary the test can be specified as a requirement on the value of a property variable the location s at which the test is required is the location s at which the property variable appears and which dominates as defined by in h the node generating the requirement exam ple we now present a simple program in the programming language and apply our algorithm to it the chosen is the as that used in an earlier paper k presenting a type prediction algorithm and we will our results to i the program we the following program a input b b yj a stop b where the variables a and real integer a subset of character and the properties fl and sum are defined by b may real of be of type or functions y xl y real real integer real character error in er real integer error error x f x real io er character integer in er character w also demonstrate introducing type program of the function the effect by changing sun to be of into the definition the sum xy xl y real integer character real error error error integer error error error character error error character type prediction the type statements are and the place within variables pa u zl pb integer oa z ra real a is z n real integer a z a b z z z zn z the across are given statement by inference b tf a and tf functions x real integer character tf i real real x a and tb b b x real integer character i tb x real integer x real integer character tf x er character in er integer character x tb real integer real x tb b tf b integer the above in formation yields edge pa z integer u character o integer u character ra l real z z v real z u real z u real n z real integer u integer u z z u real edge pb d h integer integer in er integer in er integer rb i l type compatibility together requirements ak generate the values for property variables with the is z is z is integer real integer using these values we obtain edge z z in er integer in er ra l real real real real real real i edge pb integer integer in te er integer in er integer rb l real real real real real one runtime check is required that a is of ty real at edge to verify when our algorithm is erroneous version of this results are to the the edge pa z z character character character character ra character character character character character character edge pi b rb in integer in integer integer integer er er character character character a type exists because assignment made in node of the p re vr o s or k the kaplan k presented an for making type it assumes a correctly executing and does not make the distinction between requirements and we feel as shown in the that there ex in which useful information is developed by our algorithm and not by the kaplan that unman indicates c a real integer b integer there is no that the type integer assigned to the variable b is a prediction which will always be true but that the types assigned to variable a in positions are requirements which must be verified further there is no ind ic at ion that satisfying the at makes checking at un necessary in the the kaplan predict case of the erroneous unman program will c error a b error error error does not indicate the source of the references b am really need al h j does runtime checking and experience apl el m s flow analysis computer programs el holland new york of r kaplan m a and j d unman a general for the inference of variable fifth acm on principles of languages l t c for an apl compiler i d thesis dept of con science yale pl with several pascal compiler workshop on systems programming pascal institute extensions to for l formation systems university of california san diego 