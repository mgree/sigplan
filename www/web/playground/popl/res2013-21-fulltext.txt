fault via idempotence g and microsoft research abstract building distributed services and applications is challenging due to the of distribution such as process and communication failures a natural solution to these problems is to detect potential failures and the failed computation andor messages ensuring correctness in such an environment requires distributed services and applications to be idempotent in this paper we study the aspects of process failures duplicate messages and idempotence we first introduce a simple core language based on calculus inspired by modern distributed computing platforms this language formalizes the notions of a service duplicate requests process failures data partitioning and local atomic transactions that are restricted to a single store we then formalize a desired generic correctness criterion for applications written in this language consisting of idempotence which captures the desired safety properties and which captures the desired progress properties we then propose language support in the form of a monad that automatically ensures idempotence a key characteristic of our implementation is that it is and does not require distributed coordination we show that the language support can be with other useful constructs such as compensations while the nature of the implementation we have implemented the idempotence monad and its variants in f and c and used our implementation to build realistic applications on windows we find that the monad has low runtime overheads and leads to more declarative applications categories and subject descriptions d operating systems c networks distributed distributed applications general terms reliability languages design keywords fault idempotence workflow transaction monad introduction distributed computing is several modern platforms offer distributed systems at low entry cost with the of scaling out on demand but distributed comput permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm ing comes with its own such as process failures and concurrency consider the account transfer service in fig the goal of the service is to transfer between accounts potentially in different if the accounts belong to different ensuring that the transfer executes as an atomic distributed transaction is usually not feasible and the natural way of expressing this computation is as a workflow consisting of two steps a followed by a credit what if the process executing the workflow fails in between the and credit steps a natural solution is to detect this failure and ensure that a different process completes the remaining steps of the workflow a challenging aspect of this solution is out whether the original process failed before or after a particular step either or credit if not done carefully the or credit step may be executed multiple times leading to further correctness concerns services often rely on a central workflow manager to process failures during the workflow using distributed transactions now consider a different problem messages sent between the client the transfer and the service may be lost the only option for a client when it does not receive a response within some reasonable time is to its request yet the client does not want the transfer to occur twice in this paper we study process and communication failures in the context of the different problems caused by process and communication failures are in fact idempotence a correctness criterion that requires the system to duplicate requests is the key to handling both communication and process failures efficiently idempotence when combined with gives us the essence of a workflow a fault composition of atomic actions for free without the need for distributed coordination in the transfer example a fault account transfer can be implemented without a central workflow manager if the and credit steps can be designed to be idempotent formalizing idempotence in this paper we introduce a simple core language fail inspired by platforms this language formalizes process failure duplicate requests partitioned data and local transactions a local transaction provides guarantees but is restricted to access data within a single partition typically a single server computations in fail are like but without any guarantees for the composition ie the computation may fail between transactions we then formalize a generic correctness criterion for applications written in fail a simple powerful and criterion is that an applications behavior in the presence of duplicate requests and process failures should be from its behavior in the absence of duplicate requests and failures we formal in general detecting failures in an asynchronous message passing system is impossible conservative failure detection can also lead to the same problem of duplicated computation let process request match request with branch account atomic branch lookup account transfer atomic update lookup atomic update lookup transfer complete figure a service example in syntactically fail that is neither idempotent nor a slightly weaker but more appropriate correctness criterion namely modulo message duplication informally this criterion permits the system to send duplicate responses this weakening is appropriate from the perspective of composition if the of the responses can also duplicate messages then the sender is of the obligation to send the response exactly once idempotence next we address the problem of automatically ensuring idempotence for a service we present our solution as a monad the idempotence monad we then show that idempotence when coupled with a simple mechanism provides a free solution to the problem of process failures modulo message duplication we then propose language support for idempotent computations idempotence and workflow the idea underlying the idempotence monad is conceptually simple but tedious to implement manually ie without the monad given a unique identifier associated with a computation the monad essentially adds and checking to each effectful step in the workflow to ensure an important characteristic of our implementation of the monad is that it is designed to work with distributed storage systems such as tables specifically it does not assume the presence of storage for that can be accessed atomically with each transaction the monad the underlying store in this case a table to simulate a distinct address space for this leads to a implementation of idempotence that does not require any storage or any distributed coordination between different stores thus the implementation of preserves the nature of the underlying computation this in turn leads to a completely implementation of a workflow unlike traditional workflow implementations which use a workflow andor a for runtime status information extensions we then extend the idempotence monad with other useful constructs while preserving the nature of the construct one extension allows the application to associate each transaction in a workflow with a action another extension allows the application to generate intermediate responses to client requests and then the requests on clients this idiom especially useful in long running computations the client from having to track status of requests and leads to more clients implementation we have implemented the idempotence workflow monad in f the windows platform we have implemented several realistic applications using the idempotence workflow monad we find that the core logic in these applications can be expressed using the monad our evaluation shows that performance overheads of using the monad over implementations are the rest of the paper is organized as follows in section we introduce a language fail and formalize duplicate requests and process failures we formalize what it means for a fail application to correctly duplicate requests and failures in section we present the idempotence monad and show how it can be used to duplicate requests as well as process failures in section we describe extensions of the idempotence construct in section we evaluate the idempotence monad and our implementation from the perspective of expressiveness benefits and overheads section discusses related work idempotence in this section we present a language fail that essential elements of distributed computing platforms such as windows and formalize the concept of idempotence the language fail informal overview a fail program e represents a service that receives input requests and produces output responses an input request v is processed by creating an agent to evaluate e v when the evaluation of e v terminates producing a value v v is sent back as the response multiple input requests can be processed concurrently and their evaluation can be interleaved shared mutable persistent data is stored in tables agents an agent has its own internal state captured by local variables of the code an agent may fail at any point in time a failure models problems such as hardware failure software and data stored in tables is persistent and is by agent failures tables tables are persistent maps they provide primitives to update the value bound to a key and lookup up the value associated with a key the language provides a limited form of an atomic transaction which enables a set of operations on the same table to be performed specifically the construct atomic t e evaluates e in the context of table t and updates are permitted only on table t within e isolation no other agent can access t in the middle of es evaluation and the property no process failure can happen in the middle of es evaluation example fig presents a simple example in syntactically fail this example is neither idempotent eg executing the same transfer request twice is not equivalent to executing it once nor eg if the agent processing a transfer request fails in between the and credit steps syntax fig presents the syntax of fail which extends calculus with the primitive operations on tables explained above in the rest of the paper we will use extensions such as natural numbers arithmetic operators and ordered pairs for brevity these can be encoded in the core language or added to it in the usual fashion we also use syntactic sugar such as lookup e where e val as shorthand eg for xe semantic domains fig defines the semantic domains used in the semantics of fail let val denote the set of all basic values these basically consist of function abstractions as usual natural numbers string constants ordered pairs of values etc can all be encoded within val or added to it let val opt represent the set of optional values of the form none or some v an element of st a map from val to a evaluation contexts e · e e v e b the set of evaluation rules a used to define the standard semantics of fail input v val e µ i o inv e µ v e v i v o output vo val e µ vi vo i o e µ i o vi vo normal µ e µ e p µ v e i o p µ v e i o fail p µ v e i o p µ i o atomic e t v v val µ atomic tn e t v update t kv t update k v tk some v lookup t lookup k t tk context u te t e u t ee t ee context µ e µ e µ ee µ ee lift ee te te lift ee µ e µ e beta xe v vi e µ i o e µ v e v i o c additional rules used to define the ideal semantics of fail v val v i e µ i o inv e µ v e v i v o v val v i e µ i o inv e µ i o vo e µ i o e µ i o figure operational semantics of fail v val e exp x identifier x x e v e e atomic v v update v v lookup v tn t st µ t req resp v e a val val val opt st val req × val req × exp exp × t × a × req × resp figure the syntax of fail and its semantic domains val opt represents the value of a single table an element µ t represents the values of all tables as explained earlier an agent represents a thread of computation to process a given input request the state of an agent is represented by a pair of the form v e where v represents the input request being processed and e represents a partially evaluated expression and represents the local state of the agent let a represent the set of all the state of an executing program is represented by a system configuration e µ i o where e is the program itself µ represents the values of all tables is the multiset of currently executing agents i represents the set of all input requests received so far and o represents the set of all responses produced so far a response to a request vi is a pair of the form vi vo where vo is the result let represent the set of all configurations let denote the union operator for multisets semantics fig presents an operational semantics for fail as a labelled transition relation r on the set of configurations the evaluation of a program p starts in the initial configuration p p where initially all tables map every key to a default value of none we a standard encoding of optional values consisting of either none or some v system transitions r as rule input indicates the of an input request v a new agent to evaluate e v as rule output indicates when an agents evaluation completes the resulting value is sent back as a response the labels on system transitions represent requests and responses rule normal describes a normal system transition caused by a potentially effectful execution step performed by a single agent described below as the rule indicates the execution steps of different agents can be interleaved in a nondeterministic order rule fail indicates that an agent can fail at any point in time agent transitions execution steps in the evaluation of a single agent are described by the transition relation on t × exp a transition µ e µ e indicates that an agent expression e is transformed to an agent expression e with the sideeffect of transforming the from µ to µ the label represents a sequence of updates to a single table performed atomically in this step this label however identifies an internal transition not visible which is why the label is omitted in the corresponding system transition in rule normal these transitions are of two types pure standard calculus evaluation beta and effectful which take the form of atomic table operations atomic table operations the expression atomic t e identifies a set of operations to be performed on a single table t in an atomic and fashion its semantics is defined by rule u atomic which a transition relation on atomic evaluation configurations of the form t e which indicates the atomic evaluation of an expression e at a table t the labels on such transitions are either or represent a single update to a table rules define the semantics of an operation on a table the rule atomic indicates that no other execution step with the evaluation of an atomic expression note that the evaluation of an atomic expression cannot fail in the middle in other words either all effects of the atomic expression evaluation happen or none does the rule models one of the key used to process failures namely a mechanism the rule indicates that a request must be typically logic is built into clients a client will a request if it does not receive a response within a amount of time this basic scheme can be optimized as discussed in section the system application can send an back to the client after which the client can stop a request and the application takes on the of the request to ensure progress in the presence of failures the system can exploit various optimizations in implementing the logic but rule suffices for our purpose here as we will soon see the key reason for adding the rule to the semantics is to formalize a progress guarantee progress modulo that is appropriate in the presence of failures formalizing idempotence we now formalize a natural correctness goal of any fail program namely that it correctly handles process failures and duplicate messages we will later see how we can automatically ensure this property for any program we formalize this correctness criterion as follows we define an alternative semantics for fail which we refer to as the ideal semantics representing an execution platform we then define a program to be correct iff its behavior under the standard semantics is equivalent to its behavior under the ideal semantics ideal semantics let a denote the set of all rules defined in fig b we will define the ideal semantics as a different labelled transition relation on program configurations by adding and removing some rules to set a let s denote the labelled transition relation on induced by a given set of rules s thus a is the transition relation capturing the standard semantics of fail we first omit rule fail eliminating process failures from the ideal semantics in the ideal semantics we assume that all input requests are distinct by replacing the input rule by the and rules we also drop rule finally process failures make it hard to ensure that an application sends an output message exactly once a common approach to this problem is to weaken the specification and permit the application to send the same output message more than once we do this by adding rule we define ideal to be a fail input we refer to ideal as the ideal semantics for fail observational idempotence safety we now consider two notions of behavioral equivalence in formalizing our correctness criterion recall that p denotes the initial configuration in an execution of program p which is the same under both semantics given a labelled transition relation on configurations an execution of a program p with respect to is an alternating sequence of states and labels denoted r · · · n representing a sequence of transitions starting from the initial program state p we say that the observed behavior obs of an execution is the sequence of non labels in note that obs is a sequence of input requests and output responses specifically it does not include updates to tables which are internal transitions but not visible definition we say that a fail program p is observationally idempotent if for every execution of p under the standard semantics there exists an execution of p under the ideal semantics such that obs obs we present a simpler more abstract formalization of idempotence in the appendix however the preceding definition in terms of the ideal semantics will be useful in formalizing progress properties as below and in proving correctness of our implementation idempotence progress an observationally idempotent program by definition gives no progress guarantees consider a modified version of the example that checks the input request to determine if it is a duplicate request and processes it only if it is not a duplicate this ensures that the program is idempotent however if the agent fails in between the and credit steps we would still have a problem this the following stronger correctness condition based on the notion of weak bisimulation a labelled transition system s consists of a relation s × s for every label definition a weak bisimulation between two labelled transition systems and is a relation × such that for any we have we will write to indicate that there exists a weak bisimulation between r and r under which where ri represents the set of states in i that are reachable from i via a sequence of i transitions we will omit and in this notation if no confusion is likely definition a fail program p is said to be idempotent iff p a p ideal this definition requires a idempotent program to provide progress guarantees at any point in time if the system can produce a response r under the ideal semantics then the system should be capable of producing the same response r under the standard semantics also however the inclusion of rule in the standard semantics means that this progress guarantee holds provided requests are absolute progress guarantees are not possible since an agent may fail before it executes even its first step theorem a idempotent program is also observationally idempotent let v fun tc tc v let t f fun tc atomic t let key tc in match lookup key with none let v f in update key v let f fun tc let v tc in f v let x let x x in v let key val update key val let key lookup key figure the idempotence monad idempotent realization idempotence is a generic correctness property we expect of a fail program more generally the following definition combines this property with a specification provided as another fail program q definition a fail program p is said to be a idempotent realization of q iff p a q ideal idempotence we now present a generic strategy that can be used to ensure idempotence informally a function is idempotent if multiple evaluations of the function on the same argument potentially concurrently behave the same as a single evaluation of that function with the same argument consider the example in fig in this example the parameter serves to distinguish between different transfer requests and identify duplicate requests this service can be made idempotent and by a using this identifier to log and credit operations whenever the operations are performed and b modifying the and credit steps to check using the log if the steps have already been performed this strategy can ensure that multiple potentially partial and concurrent invocations of transfer with the same identifier have the same effect as a single invocation manually ensuring idempotence is tedious and it introduces the possibility of various subtle bugs and in general makes implementation less we now describe a library that idempotence and in a generic way the idempotence monad the intuition a computation performed by a single agent consists of a sequence of steps pure as well as effectful ones namely atomic local transactions which can a single table we use the following strategy to make a computation idempotent associate every computation instance that we wish to make idempotent with a unique identifier associate every step in an idempotent computation with a unique number whenever an effectful step is executed we simultaneously record the fact that this step has executed and save the value produced by this step every effectful step is modified to first check if this step has already been executed if it has then the previously saved value for this step is used instead of executing the step again note that fail does not have any nondeterministic construct in a single agents evaluation nondeterministic constructs can be supported by treating them as an effectful step so that once a nondeterministic choice is made any of the same step makes the same choice details we now describe in detail how individual computation steps can be made idempotent and how these idempotent steps can be composed together into idempotent computation our solution is essentially a monad fig we represent an idempotent computation as a function that takes a tuple tc as a parameter where and tc represent an identifier and a step number used to uniquely identify steps in a computation and returns a value along with a new step number we can execute an idempotent computation as shown by the function using the functions argument itself as the value and an initial step number of the function the monadic return primitive values to idempotent computations this transformation can be used for any pure expressions sideeffects table operations are permitted only inside the atomic construct the function is used to make a local transaction idempotent specifically t fm is an idempotent representation for atomic t f where fm is the monadic form of f constructed as described later as explained above this is represented as a function that takes a pair tc as a parameter and the memoization strategy described above the pair tc is used as a unique identifier for this step we check whether this step has already executed if so we return the previously computed value if not we execute this computation step and the computed value in either case the step number is in this process and returned it is however critical to do all of the above steps atomically to ensure that even if two agents concurrently attempt to execute the same computation only one of them will actually execute it however note that an atomic expression is allowed to access only a single table hence the memoized information for this computation step must be stored in the same table that is accessed by the computation step however we must keep our memoization and information logically distinct from the programs own data stored in the same table we achieve this by creating two distinct address spaces of key values for the table we convert a key value k used by our idempotence implementation to k and convert a key value k used by the program itself to k the functions and do this for the users code thus the expression f to be evaluated in the atomic transaction is transformed to its monadic representation fm by replacing lookup and update in f by and respectively we now consider how to compose individual computation steps in an idempotent computation the monadic bind function consider a computation of the form let x step in step which is equivalent to we transform step to its monadic form say we transform step to its idempotent form say g the function bind applied to and produces the idempotent form of the whole computation a formal and more complete description of the transformation is presented later the result of f is defined as follows it is an idempotent function that takes a parameter tc and invokes the first step it uses the value and the step number returned by the idempotent function and invoke the second idempotent function f thus the monad effectively threads the step number through the computation it in every atomic transaction note that a key characteristic of this implementation is that it is completely when a transaction completes the current agent simply attempts to execute the next idempotent transaction in the workflow no coordination with a transaction manager is required in general distributed coordination requires the use of expensive blocking protocols such as phase commit in contrast a workflow implementation based on this idea of idempotence coupled with logic are nonblocking the implementation does not have a single or single performance which can lead to increased scalability also note that this implementation creates one log entry per transaction once for idempotence is separated from the core logic it can be optimized in several ways we can avoid redundant if the underlying storage engine maintains its own log can be avoided if the transaction is declared to be semantically idempotent example the monadic library lets us construct the monadic version em of any fail expression e by using the monadic version of any primitive and the monadic bind in place of function application eg the monadic version of the following code fragment from the transfer example atomic fb update fa lookup fa atomic tb update ta lookup ta is the following fb fa fa tb ta ta where e is shorthand for xe where x is not free in e idempotence monad programs are in this section we show that programs written using the idempotence monad are idempotent executions consider any execution of a fail program we refer to any transition generated by rule normal as an and identify it by the triple v e v e thus an a b represents a transition caused by an agent a that transforms to an agent b with a sideeffect on the tables an a b after an execution is said to be a repeated if the execution contains some of the form a b note that this does not a cycle in the execution since the states of the tables could be different in the two corresponding configurations definition an execution is said to be operationally idempotent iff for any two a b and a b in the execution in that order a a implies that b b and is empty note that operational idempotence is a property that involves the sideeffects on the tables unlike observational idempotence as we show below it is a stronger property that can be used to establish observational idempotence lemma any operationally idempotent execution of a program p in the standard semantics is observationally equivalent to some ideal execution of p in the ideal semantics ie obs obs proof sketch let be an operationally idempotent execution of a program p under the standard semantics a we show how to construct an execution of p under the ideal semantics such that obs obs we first omit any transitions in due to the fail rule since their labels are empty we next omit the transitions corresponding to repeated the key point to note here is that an a b affects the of subsequent transitions in two ways indirectly through the sideeffects on the tables and directly through b which may take part in subsequent transitions a repeated is redundant in any idempotent execution that has no failures transitions due to the fail rule it has no sideeffects on the tables and if the value b is subsequently used in a then we can show that another agent identical to b already exists in the configuration we then omit any transition due to the rule we finally replace input transitions corresponding to a duplicate and replace input transitions corresponding to a input request by a transition this leaves us with duplicate responses that may be produced by the output rule for the same input due to multiple agents that process it we replace these transitions by corresponding transition this transformation produces an execution of p under the ideal semantics such that obs obs our next goal is to show that all executions of programs written using the idempotence monad are operationally idempotent however this claim requires the programs to be welltyped as defined below welltyped im programs the idempotence monad can be used to write monadic programs in the usual way the monad may be thought of as defining a new language im obtained from fail by replacing the keywords atomic lookup and update by the keywords and a im program can also be thought as a fail program using the definition of the monad in fig we first mention a few type restrictions used to simplify presentation we refer to calculus terms as pure and their types as pure types we assume that the types of keys and values of all tables are pure types we assume that the types of the input request and the output response are also pure types we use k v to denote the type of a table with keys of type k and values of type v we assume that table names come from some fixed set of identifiers and that the typing environment maps these table names to their types the terms can be classified into two kinds the first kind are expressions such as k v which are meant to be evaluated in the context of a single table as part of a local transaction fig presents typing rules for expressions the type k v a term that can be evaluated in the context of a table of type k v producing a value of type the second kind of expressions are the ones that use the idempotence monad used to represent workflow computations which execute one or more local transactions fig presents typing rules for such expressions which are the standard monad typing rules in the sequel we will use the term welltyped im program to refer to any expression e such that tn e i id o where i and o are respectively the types of input and output messages and tn provides the typings of tables this is a program of the form e where e is constructed from the other monadic constructs e k k v e v k v x e k v xe kv k v e k k v e v k v e e unit k v x x k v e kv k v e k v ee k v figure a type system for expressions e e im e im e im e e im t k v e unit kv k v t e im e im e id var x x lambda x e xe figure a type system for idempotence monad apply x e xe lemma all executions of a welltyped im program are operationally idempotent proof sketch let us refer to a value of the form k used as a key for a table operation as a system key consider any execution of a welltyped im program it is easy to verify that once the value associated with a system key k in any table is set to be v it is never subsequently modified consider any two a b and a b in the execution in that order where a a the idempotence property follows trivially whenever these steps are steps the only effectful steps are produced by the evaluation of an construct since a a the key value used in the evaluation of in both steps must be identical the implementation of guarantees that whatever value is produced by the evaluation of in the first step will be memoized with the given value this guarantees that the second step will find this same value in the table thanks to the property described earlier hence it will evaluate to the same value and will have no sideeffects on the table it follows that the execution is idempotent theorem any welltyped im program is observationally idempotent proof sketch follows immediately from the previous two lemmas as stated earlier observational idempotence does not give us any progress guarantees in the presence of failures we now establish progress guarantees in the form of a weak bisimulation definition let p be any set of configurations by the execution of p under the the set of configurations be produced by the execution of p under the ideal semantics we define the relation between pa and pi by p µ i o p µ i o iff i i and µ µ note that in the above definition the condition i i implies that both configurations have received the same set of input requests the condition µ µ implies that the processing of each input request v in both configurations have through identical sequences of effectful steps so far this follows since every effectful step is memoized and is part of the table state µ and µ theorem if p is a welltyped im program then is a weak bisimulation between pa a and pi ideal proof sketch consider any the interesting transitions are those that are effectful involving an atomic operation or produce an output if either or can perform an interesting transition we must show that the other can perform an equivalent transition possibly after a sequence of transitions consider the case when an agent v e in can perform an effectful transition in the standard semantics let v e be the state of the same agent after its most recent evaluation then we must have some evaluation e e · · · ek e consider configuration by definition we restrict our attention to reachable states hence there exists some execution in the ideal semantics that produces this execution must have received input request v and produced an agent v p v consider the evaluation of this agent the effectful steps in this agents evaluation in the ideal semantics must have produced the same sequence of values as in the evaluation in the standard semantics since the memoized values for these steps are the same in both and thus must have some agent of the form v ei for some i k this will produce after zero or more transitions the agent v e that can then perform the same effectful transition in the ideal semantics as in the standard semantics consider the case when an agent v e in can perform an effectful transition in the ideal semantics we can create a new agent v p v using rule in the standard semantics we can then xv x preserves types translation of a welltyped fail program satisfying the restrictions mentioned above will produced a welltyped monadic program xi x realization via idempotence n ei ni xx ei n val given any fail expression e we can construct its monadic version em as explained above the preceding results imply that em must v ni ni xv xi v val n we now establish a stronger result namely that em is v v i vv v v v v val a realization of e is a weak correctness atomic x ei x ea fv where fv x criterion it indicates that a programs behavior under the standard semantics is equivalent to its behavior under the ideal semantics the notion of does let us simplify verifying cor xa x of a program by considering only its behavior under the ideal semantics in particular we have update e ea ea ea lookup ea ea theorem if p and q are weakly bisimilar under the ideal semantics ie if p ideal q ideal and p is then p is a realization of q e e e x y x xe y proof sketch follows as we can compose the two weak bisimulations together figure transforming fail expressions into idempotent expressions duplicate the entire execution history of v e which is guaranteed to be the same in both semantics by the definition of thanks to the idempotence property this duplicate execution will have no extra sideeffects and will eventually produce the same effectful transition as in the ideal semantics theorem a welltyped im program is transforming fail programs to idempotent programs we have seen that the idempotence monad lets us construct programs given any e we can construct its equivalent monadic representation using standard techniques which are conceptually straightforward though the details are the transformation is presented in fig based on the transformation in we make a few simplifying assumptions type restrictions about the source fail program e in this transformation algorithm similar to those mentioned in section we assume that the types of keys and values of all tables are pure types we assume that expressions do not manipulate values of workflow type eg atomic t s e is not allowed the translation is defined using multiple translation functions vv is a translation function that applies only to values which must be of the form x or xe the translation function ei is the of the monadic transformation and can be applied to expressions it uses the idempotence monad to sequence local transactions the translation function ea is applied to expressions and it is used primarily to replace occurrences of update and lookup by and respectively note that a single local transaction expression evaluation is done using standard evaluation without using any monad the auxiliary function e x is used to transform the monadic values used in the evaluation of to standard values required in the evaluation of a single local transaction finally given a toplevel fail program e which is assumed to be a functional value of the form xe its monadic form em is defined to be ev as usual it can be shown that the trans this theorem simplifies proving that a program is a realization of another in particular we have already seen that a monadic program is theorem hence to prove that em is a realization of e it suffices to show a weak bisimilarity between the ideal executions of a fail program e and the ideal executions of its monadic representation em theorem let em be the monadic representation of e then em is a realization of e proof sketch as explained above it is sufficient to relate evaluations of e and em under the ideal semantics in this setting it is intuitively simple to see why the monadic program em simulates the given program e the key distinction is that the monadic implementation uses to perform any effectful step this step will first check the memoized data to see if this step has already executed in an ideal execution this check will always fail and the monadic implementation then performs the same effectful step as the original program and it the check is guaranteed to always fail because the keys g i used in distinct executions of are distinct the value of g will be different for executions corresponding to different inputs x and y the value i will be different for different steps corresponding to the same input x idempotent computations as a language feature we have now seen how idempotent computations can be automatically realized using the idempotence monad we now propose a new language construct for idempotent computations the construct v e indicates that the computation of e should be and should be idempotent with respect to v ie multiple potentially concurrent invocations of this construct with the same value v behaves as though only one of the invocations executed the above construct permits users to specify the code fragment for which they automatic idempotence and provided by the compiler this enables users to rely on other methods perhaps to ensure these properties elsewhere for instance some computation may be semantically idempotent already it also lets the users specify what should be used as computation identifier to detect as illustrated below we refer to this language as a formal semantics of appears in the appendix we illustrate the meaning of the first parameter of using the incorrect fail example of fig we can wrap the construct around this example in the following two ways with different semantics note that the input in this example is a pair req consisting of a as well as the actual request consider f req process req f req req process req the behavior of these two functions differ in the cases where multiple inputs arrive with the same but in the second parameter req f treats such requests as the same and will process only one of them while f will treat them as different requests and process them all one of the subtle issues with the semantics and implementation of the construct is the treatment of invocations that have the same id first parameter but have different expressions as the second parameter we take a simple approach with our semantics that the effect is as if only the first invocation occurred this has some implications for the underlying implementation in the presence of failures one solution is to use a continuationpassing style computation and the entire continuation in the memoization step rather than just the value computed for the step extensions we have seen how idempotence can serve as the basis for composition of computations essentially a simple form of workflow in this section we describe two extensions that this construct namely actions and asynchronous evaluation which simplify writing applications these concepts are not new but what is interesting is that they can be integrated without the lightweight nature of our idempotence implementation actions the construct allows us to compose several transactions into an idempotent workflow that appears to execute exactly once without process failures however the lack of isolation means that when a transaction in the workflow is executed its precondition may not be satisfied and we may need to abort the workflow for example in the transfer example fig the step may succeed but we may be unable to complete the subsequent credit step because the account does not exist one way of from this failure is to for the by the amount back to the source account if actions are correct the workflow can guarantee semantics ie either all or none of the transactions in the workflow appear to execute we first formalize the desired semantics of with actions we present a language which provides language constructs to associate transactions with actions and to declare logical failures finally supports a construct id e which transactions with actions into a workflow we present semantics of this construct and then show how this construct is realized using a compensation monad syntax modifies and extends fail in the following ways see fig atomic t ea ec extends the atomic construct of fail by specifying ec as the compensation for the atomic transaction ea abort indicates that a logical failure has and the workflow must be aborted id e represents an idempotent workflow with identifier id where e is the workflow consisting of a composition of atomic transactions with compensations expression of the form e ec arise only during evaluation and are not source language constructs semantic domains the semantic domains for are the same as for fail with minor extensions the runtime expression e ec is used to represent a workflow during its execution here e represents the partially evaluated form of a workflow and ec represents the action to be performed in case the workflow needs to be aborted agents can also be of the form id ew ec indicating an agent evaluating a workflow semantics the semantics of is defined using a set of rules consisting of all the rules in a used to define the semantics of fail except for fail and atomic plus the new rules presented in fig the of a workflow rule creates a new agent of the form id ew ec provided no agent has already been created for id this agent evaluates the workflow ew and tracks the action ec to be performed in case of an abort rule indicates how the computation proceeds once the workflow evaluation is complete or if a previous workflow with the same id has already been the rules atomic and define the semantics of transactions in a workflow informally the expression atomic t ea ec is evaluated as follows first ea is evaluated atomically to produce a value v then as a sideeffect the action is updated to indicate that ec v should be evaluated as the first step of the compensation before executing the original compensation finally the whole expression evaluates to v thus note that the value produced by the atomic action ea is available to the subsequent computation as well as the action ec when a workflow is aborted rules and the compensation expression is evaluated rule atomic of fail is replaced by the pair of rules and which describe the behavior of a transaction that is not contained within a workflow describes the successful completion of a transaction while describes the case where the transaction is aborted the auxiliary relation used here is defined by the rules for fail compensation monad we now describe the compensation monad that can be used to realize with actions for simplicity we describe an implementation of the monad that focuses only on logical failures and compensations we assume there are no duplicate requests or process failures we can realize idempotent with actions by composing this monad and the idempotence monad the compensation monad shown in fig is a combination of the exception monad and the continuation passing style monad transactions return a value of the form on successful completion or a special value abort to indicate that the transaction was aborted are represented as a function in continuation passing style the function associates a transaction a with a action to construct a primitive workflow constructs a function in continuation passing style this function first evaluates a if a aborts the whole transaction aborts and returns abort otherwise the continuation is evaluated using the value returned by the transaction if the continuation itself aborts because one of the following transactions aborts we evaluate the action and return the value abort the monads return simply a value with no compensation into a workflow the monadic bind is standard for continuation passing style computations the function run shows how to execute a workflow by passing it an empty continuation asynchronous evaluation are commonly used to perform computations involving several transactions consequently are often long running with highly variable large the a syntax and evaluation context x identifier v val x xe e exp x x e e e atomic vt va vc vi vw abort update v v lookup v e a exp × exp exp × exp e · e e v e e e ec b evaluation rules in addition to a atomic v id w p µ i o p µ id e id e w i o p µ id u u val v id w i o p µ v eu i o normal µ e µ e p µ v e i o p µ v e i o atomic ea t v v val µ tn ea ec e t ev ec v e ea t µ tn ea ec e µ e µ ec µ ec context µ ee ee ec µ ee ec ea t v v val µ atomic tn ea ec t v ea t µ atomic tn ea ec µ figure syntax and semantics of let a comp fun f match a with abort abort match f b with abort let comp b in abort let bind v f fun g v fun a f a g let return a fun a fun v let run a a fun x figure the compensation monad problem of duplicate requests because clients cannot easily distinguish between a long running workflow and one that has failed to generate a response while the idempotence monad guarantees correctness in such cases idempotence does come at a performance cost due to log a design pattern commonly used to reduce the number of duplicate requests is for the system to take over the task of a part of the request on of the client and sending an intermediate response to the client typically with the transaction identifier the client can use transaction identifier to for the status of the request the idempotence monad can be extended to support asynchronous evaluation as follows at a programmer defined point in the evaluation of the workflow we create a checkpoint a checkpoint is essentially a closure representing the rest of the workflow along with relevant state variables the checkpoint is then typically in a distributed queue essentially a worklist once the checkpoint has been created an intermediate response is sent to the client a set of special agents query the queue and continue evaluation deleting the checkpoint only when the workflow has been fully evaluated supporting asynchronous evaluation requires some additional support from the platform and a minor change to the monads bind function we assume that the platform provides a channel that can only be accessed by the idempotence monad hence not exposed in fail messages can be sent to this channel using the function send and received using the function recv we assume the channel supports the following protocol for messages in order to guarantee processing of messages in this protocol recv does not delete messages from the channel instead an agent that receives a message must the message using before the message is deleted if an agent after receiving a message and before it the message in the channel and may be processed by other agents windows provides such a channel implementation which our implementation uses the changes to the idempotence monad are illustrated in figure instead of invoking the remainder of the workflow the modified bind fig creates a closure for the rest of the workflow and the closure in a special queue worklist using the function send special agent processes agent the using recv and continue evaluating the rest of workflow if an agent to evaluate the workflow without failing it the workflow from the queue using in our implementation the choice of using asynchronous evaluation and the particular step at which to create a checkpoint is left to the programmer we evaluate the benefits of these optimizations in section let agent while true let msg recv let f msg in let result f in let worklist in result let bind f fun tc let v tc send worklist f a figure average message size in bytes of the and workflow implementations figure the idempotence monad with asynchronous evaluation let response do responses response return atomic let summary summaries do return summaries summary figure the save survey operation expressed as in idempotent workflow evaluation we have implemented the idempotence workflow monad and its variants in c and f windows a platform for distributed applications provides a store with explicit support for data partitioning where partitions are units of serializability in this section we focus on evaluating the expressiveness and performance overheads of the idempotence monad sample applications we found several real world applications whose core logic can be expressed as we briefly describe an management application and a survey application other applications we have implemented include applications for online and survey application the application enables users to design a survey the survey and collect the results of the most performance critical scenario in this application is when a user a survey this operation involves two steps recording the response and updating the survey summary with the response for scalability survey responses and summaries are stored in different data partitions figure shows an implementation of this operation using the syntax here is from the actual f implementation and differs from fail in ways the workflow is composed of two transactions a transaction that the response and a transaction that updates the summary in this implementation survey responses do not reflect in the summary immediately in general deferred writes are often acceptable as long as the writes will eventually appear to occur exactly once a guarantee provide the use of the idempotence monad guarantees that even if multiple requests are received with the same survey the appears to execute just once application the application allows users to for items on and track the status of their can register items for with a time limit and a minimum price sites are often high volume sites and both and scalability is important the most critical operation in this application is the operation that processes new this operation can be expressed as a workflow composed of several transaction the first transaction checks if the is valid and then checks if the the current maximum in which case the is recorded in a table the second transaction marks the current and in a separate table the web frontend is to this table for the status subsequent transactions update other tables such as an aggregate table that maintains the most frequently items more etc with the idempotent workflow monad it is easy to guarantee that each is processed exactly once even if clients with little change in complexity overheads there are two sources of overheads associated with idempotent compared to implementations first asynchronous evaluation requires and closures which can be expensive compiler generated closures tend to capture a lot more state than implementations idempotent also add unnecessary to transactions that are already idempotent fig shows the average size of messages sent in and workflow monad based implementations as expected the workflow based implementation generates significantly larger messages however experiments on windows show that the size of the message does not significantly influence the readwrite or of channels as by our experiments below next we evaluate the overall performance overheads of using the idempotence monad relative to implementations for each benchmark application we evaluate three versions the original version and two monad based versions the first version synchronous evaluates the workflow in the context of the current agent and the of operations to the client the second version uses asynchronous evaluation we each of the applications on windows and that each variant was assigned the same hardware resources ie virtual machines each with a core processor and gb ram we assigned two virtual machines each for the front end agents that service browser requests and agents that interact with the storage system and one virtual machine for a background agent uses for evaluation in the synchronous evaluation variant we assigned an additional virtual machine to the storage interaction agent for each benchmark we created a that simulates users performance critical scenarios in the application for example in the application the consists of a mix of response requests and survey analysis requests in each case the is towards write requests eg responses and analysis requests in the survey application to ensure that transactions are on the critical path we ran the for with a seconds period and measured number of requests per second and average response time for varying number of simultaneous users fig shows the measured and for the application in the version both and synchronous asynchronous number of concurrent users sec synchronous asynchronous number of concurrent users figure average and for various versions of the survey application synchronous asynchronous number of concurrent users synchronous asynchronous number of concurrent users figure average and for various versions of the application increase almost linearly with the number of users all monad based implementations closely follow this very little additional overhead due to our implementation the and are along expected lines the expected of tables is per second whereas our operation is a workflow consisting of two transactions the application fig has slightly different performance characteristics the of this application is lower than the application and it decreases with load this is expected since the workflow is significantly longer synchronous evaluation achieves better than the implemented which is asynchronous at almost the same as expected asynchronous evaluation improves especially at low loads but at the cost of reduced up to lower at high loads all monad based implementations perform better than the implementation this is due to a few low level optimizations such as of requests performed by our implementation we leave a more detailed performance analysis and optimization of the idempotence monad for future work related work our work builds on previous literature in the topics of building reliable distributed systems and transactional workflow idempotence has been widely and informally recognized as an important property of distributed systems our key contributions include a a formal specification of the desired correctness properties both safety idempotence as well as progress failure freedom b an automatic technique for idempotence pre as a monad this implementation technique is and does not require distributed coordination c language constructs for idempotent workflow the need to move beyond atomic transactions to sequential compositions of atomic transactions ie motivated the early work on and long running transactions these constructs are weaker than distributed transactions and are generally used to processes that run for extended et al discusses several issues relating to the implementation of transaction in and a distinguishing aspect of our work is that it exploits the fact that a service is required to be observationally idempotent from its clients perspective to simplify the internal implementation of the workflow in particular this lets us avoid the need for distributed coordination with workflow modern web applications often exploit partitioning for scalability which involves storing data in a number of different databases or this leads to a need for computations even within a single application since scalability is key and the motivation for data partitioning conventional workflow are considered for use in this context instead the programmer usually the workflow manually themselves to all the of such workflow correctly describes programming for use in these scenarios our goal is to provide lightweight language mechanisms that can be used to realize idempotent correctly in such scenarios explains in detail why idempotence is an essential property for reliable systems et al define a correctness criteria known as for replicated services a history is said to be if it is equivalent to some history where every request is processed exactly once much like idempotence is both a safety and liveness criteria our notion of idempotence is generalizes beyond replication requests to there are also significant differences in our implementation techniques our work is also related to open nested transactions these two constructs share the use of actions but are semantically different open nested transactions provide a way for dealing with conflicts at a higher level of abstraction which often leads to increased concurrency our basic setting is similar to argus however the construct that argus provides programmers to deal with process failures is a conventional transaction as with we show that many applications can be expressed using as we cover in section with actions to for the lack of isolation the transactor programming model also provide primitives for dealing with process failures in a distributed system however there is no shared state in the transactor model the primitives provided by the transactor model checkpoint and rollback are different from the primitives we study et al formalize actions in an abstract language their formalism however does not explicitly model state their paper in fact suggests study of compensation in the context of imperative features state variables controlflow constructs as future work our work provides a transactional construct as a library in a real language f for a real system in addition to the theoretical treatment in the setting of lambdacalculus with mutable shared state et al propose an abstract model of actions based on process calculus for reasoning about correctness for that use actions lambda calculus is a programming language and a type system for fault however fail is addresses process failures while lambda calculus addresses data errors jacm ­ and a theory of replication distributed computing and in proc of pages ­ pat idempotence is not a condition acm queue ­ and correctness issues in workflow management distributed systems engineering paul hudak and mark jones monad transformers and modular interpreters in in proc of popl pages ­ liskov distributed programming in argus communications of acm ­ march j b nested transactions an approach to reliable distributed computing base an alternative queue ­ may philip wadler and peter the of effects and monads acm trans comput log ­ david walker a and david i august static typing for a lambda calculus in in acm international conference on functional programming and concepts and applications of transactions and open nested transactions in database transaction models for advanced applications pages ­ and transactional information systems theory algorithms and the practice of concurrency control a an abstract definition of idempotence we now present a more abstract definition of idempotence in terms of histories acknowledgments the users of the system issue requests to the system let i denote a set of input messages or requests the system we would like to to requests with a response let o denote a set of output values an and for their contributions output message or response is a pair i o i × o indicating that the output value o is produced in response to input request i references a history is a sequence ee · · · ek of requests and responses ie each ei can be either a request or a response we will restrict and for windows our attention to histories that satisfy the simple property that every response corresponds to an earlier request in the history we define june a specification to be a set of histories in the sequel we use a set now sample june of histories to specify desired safety properties of the system the scenario june windows patterns and in the sequel let q i range over requests and let r i × o range over responses let and range over sequences of requests and responses com and theoretical foundations for compensations in flow composition languages in definition a a specification is said to be asynchronous if it satisfies the following properties proceedings of popl pages ­ q q and a process calculus r r analysis of compensations in global computing volume of lecture notes in computer science pages ­ the above conditions are a natural restriction on specifications because of delays that cannot be controlled the above john field and a transactors a programming model property is also related to the notion of linearizability given any for maintaining globally consistent distributed state in environments in proceedings of popl pages ­ mj fischer na and ms of distributed consensus with one process journal of the acm sequential specification s linearizable s can be defined as the smallest asynchronous specification that contains s every linearizable specification the asynchronous property defined above but not all asynchronous specifications are linearizable idempotence two requests q and q in the same history are said to be if q q two responses q r and q r in the same history are said to be if q q definition a a specification is said to idempotent iff duplicate requests have no effect qq iff q responses have the same value q o o o duplicate responses are allowed rr iff r the above definition is intended for asynchronous specifications hence the conditions have been used to simplify the definition idempotence closure we define a history to be if it contains no duplicate requests or duplicate responses we define a specification to be if all histories in are given a specification we define its idempotence closure to be the smallest specification that contains and is idempotent we now summarize our goal given a program p that satisfies a specification in the absence of process failures and duplicate requests construct a program p that satisfies even in the presence of process failures and duplicate requests extension the above definitions can be generalized to permit requests to be of the form k v where k is a key for an input request and allowing responses to be of the form k o where k is the of the input request for which the response is produced note that the above definition does not capture the progress conditions of b the semantics of we adapt the earlier operational semantics of fail as shown in fig to define the semantics of we extend the definition a the set of agents previously an agent was of the form v e now an agent may now also be of the form v e indicating a evaluation of expression e with identifier v syntax extension e exp · · · v v semantic domain changes a exp × exp exp × exp additional evaluation rules v id e e id e p µ i o p µ id e i o id w w val p µ v id e i o p µ v ew i o normal p µ v µ e µ e e i o p µ v e i o figure the language defined via extensions to language fail rules and must be duplicated for v id e as well rule handles the evaluation of the construct v e when no preceding computation with the same identifier v has been this has the effect of creating a new agent v e rule allows the computation v e to proceed once the created agent completes evaluation as indicated by the presence of an agent of the form v w where w is a value the same rule also applies to duplicate evaluations with the same id 