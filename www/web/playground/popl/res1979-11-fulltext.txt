automatic generation of for grammars by and institute of technology abstract attribute grammars are an extension of context free grammars by knuth as a formalism for specifying the semantics of a contextfree language along with the syntax of the language the syn tactic phase of the translation process has been extensively studied and many techniques are available for automatically generating efficient parsers for contextfree grammars attribute grammars offer the of similarly ing the implementation of the semantic phase in this paper we present a general method of construct ing for any attribute grammar a deterministic translator which will perform the semantic evaluation of each syntax tree of the grammar in time linear with the size of the tree each tree is traversed in a manner particularly suited to the shape of the tree yielding a optimal evaluation order for that tree basically the translator consists of a finite set of local control automata one for each production these are ordinary finitestate acyclic automata augmented with some special features which are used to the evaluation process of each syntax tree with each node in the tree there will be associated the local control automaton of the production applying at the node at any given time during the translation process all local control automata are except for the one associated with the currently processed node which is responsible for the next steps taken by the translator until control is finally passed to node its local control automaton the local control automata of nodes communicate with each other the construction of the translator is custom to each individual attribute grammar the dependencies among the attributes occurring in the semantic rules are to produce a evaluation strategy for that grammar this strategy ensures that during the evaluation process each time the translator enters some subtree of the syntax tree at least one new attribute evaluation will occur at each node visited it is this property which distinguishes the method presented here from previously known methods of generating for unrestricted attribute grammars and which causes the trans to be introduction attribute grammars are an extension of context free grammars by knuth k for specifying the semantics of languages along with the syntax each grammar symbol associated set of attributes specifying the various of its meaning and each production is provided with semantic rules defining the attributes of symbols in the production in terms of other attributes associated with the tion to find the meaning of a string first we construct its syntax tree and then we determine the values of all the attributes of symbols in the tree a process which is called semantic evaluation of the tree an attribute grammar is if the system of semantic definitions given by the grammar avoids circularity in all possible instances the problem of detecting circularity in an attribute grammar first solved by knuth in k was shown in to be of inherent exponential complexity since their definition attribute grammars have interest in the area of programming languages they have been used by in fields such as natural language recognition and question systems p program optimization and the theory of program correctness g but their most important contribution was toward the formal definition of programming languages and automatic design of compilers two highlevel programming languages namely and pl were fully defined and implemented using the attribute grammar model when an attribute grammar is used to specify the translation and code generation performed by a compiler the attributes may represent such things as data types of expressions symbol table records translating identifiers register usage information or machine code generated for a statement the definition of and its compilation process by means of an grammar offers the following advantages i the semantics is given in a declarative non procedural way and is independent of any parsing scheme ii the semantic description is modular given on a production by production basis which makes the definitions more and the addition and removal of features from the language iii the context sensitive features of the language can be expressed iv the description of the language can be checked for consistency and used for automatic compiler generation despite these advantages attribute grammars have not become a widely used tool for compiler generation because of the difficulty in obtaining implementations efficient enough for practical use until now efficient translation algorithms introduction have been developed only for restricted classes of attribute grammars kw a general framework for studying implementation of attribute grammars was developed in w in this paper we present a general scheme for automatically constructing a linear time deterministic translator for any attribute grammar the translator will traverse each parse tree of the grammar in a manner which is particularly suited to the shape of the tree yielding a evaluation order for the tree as a result our translator will never around in the tree before reaching a place where new attributes can be computed instead it is guaranteed that each time the trans enters some subtree of the syntax tree at least one new attribute evaluation will occur at each of the nodes visited the construction of the translator is custom to each individual attribute grammar the dependencies among the attributes in the grammar are analyzed to produce a evaluation strategy for that grammar basically the translator consists of a finite set of local control automata one for each production these are finitestate acyclic automata augmented with some special features which are used to the translation process of each given parse tree with each interior node of the tree is associated the local control automaton of the production apply ing at the node during the translation process whenever control reaches the particular node its local control automaton is starting from the state in which it was last suspended the automaton is responsible for the tion process while control is at the node when finally control is passed to a node along with some parameter the currently active local control automaton is suspended and the local control automaton associated with the node will be this goes on until eventually the local control automaton associated with the root of the tree enters a final state at which point the translation process is complete attribute grammars an attribute grammar is a contextfree grammar augmented with attributes and semantic functions formally an attribute consists of the underlying grammar a context free grammar g where vn is the vt is the set of terminals p is the set of productions and is the the start symbol we assume that there are no useless nonterminals and that s appears on the left hand side unique initial production po and does not appear on the right side of any production let v stand for a production pp is written in the following form p xn where for for p convenience we sometimes x n ple denotes the kth symbol from vo appearing in production p attributes for each symbol there are two finite disjoint sets the inherited attributes of x and the synthesized attributes of x for x s and for we require that ix sx a production for ix u p n p has the attribute occurrence a p if semantic functions for each production pcp there is a finite set of semantic functions as follows for every synthesized attribute occurrence k o and for every inherited attribute occurrence ak with s k s np there is a semantic function fp ak which defines the value of attribute occurrence ak from the values of other attribute occurrences appearing in the same production the value of an attribute occurrence defined by a semantic function is taken from a given set possibly infinite of attribute values the semantic functions usually involve simple operators like assignment boolean operators numerical sums etc example the following attribute grammar n sa b is an example of an t ab is ss s ia ill sa ss ib ii sb s production o semantics s o s i s s s i i i i s s s t s s evaluation of attribute grammars a parse tree of an attribute grammar is a derivation tree of the underlying context free grammar ie a finite tree whose nodes are label led with symbols from v for each interior node n there is a production pp such that n is label led with the symbol po has np sons and for each k the kth ­ p son of n is labelled with in this case we say that production p applies at node n by the kth of node n for we shall mean the of n in case k o or the kth son a parse tree with root x x in which the root is label led a semantic tree of an attribute grammar is a parse tree augmented with attributes ie each node labelled with is a structured variable whose field selectors are the elements of ax jn order to determine the meaning or translation of a string generated by the underlying contextfree grammar we first parse the string and build the semantic tree then we have to fill in the fields of each node by computing the attribute values according to the semantic functions this process is called evaluation of the semantic tree an algorithm which accepts as tree generated by a given attribute grammar g and evaluates it is called a evaluator for g the only restriction imposed on the translator is that at any point in time during the evaluation process it can only evaluate an attribute occurrence whose semantic function is ready to evaluate that is all attribute occurrences which are arguments of the semantic function have been previously thus the translator will move in the tree from node to node at each node evaluate some which are ready to evaluate until all occurrences in the tree have been evaluated consider the attribute grammar of example and the semantic tree of fig the fields have been filled in as by the semantic functions note for example that il of node cannot be evaluated before s of the same node is which in turn demands of s of node in later sections we shall describe how to sys construct an efficient translator for each attribute grammar the construction of the translator will be carried out once and for all at construction time once the translator for the attribute grammar has been constructed the eval process for each semantic tree as described above will take place at run time the dependency graph let p be the production p lp a convenient tool for describing production p and its semantic is the dependency graph of p denoted dd the nodes of dd are the attribute of p there is a directed arc from node a k to node ak if a k on a k ie he a k as argument this means that dp reflects the dependencies among attribute occurrences imposed by the semantic functions of p fig shows the dependency graph of production of example in order to represent the semantic dependencies of a whole semantic tree rather than a single production we define the compound dependency graph of a semantic tree t denoted this graph is constructed by together copies of the for the productions occurring in the tree each one of the is selected according to the production p applying at the interior node of the tree fig shows the compound dependency graph of the tree of fig circularity the compound dependency graph of a semantic tree reflects the flow of information among the attributes in the tree in the semantic tree there is a flow of information from the root towards the leaves by the inherited attributes and from the leaves towards the root by the synthesized attributes since information may flow in both directions a cycle may be created an attribute grammar is said to be circular if there exists at least one semantic tree whose dependency graph con a cycle circular grammars are clearly ill defined in that there is at least one semantic tree which cannot be evaluated knuth kl has presented an algorithm which tests an attribute grammar for circularity the time taken by the algorithm is exponential in the size of the grammar a faster but still exponential algorithm appears in where it was also established that the circularity problem for grammars is of inherent exponential time complexity a normal form for attribute in the general definition of attribute grammar for each every semantic function may be defined in terms of all other attribute occur ak itself without loss of we may assume that a semantic function ak does not use as argument an attribute occur ence which is defined in the same production this leads to the following normal form jl definition an attribute grammar is said to be in normal form if it satisfies the following tions for each production p x xl xn a a synthesized attribute occurrence s xo may depend p attribute occurrences i attribute occurrences s k b an inherited attribute occurrence i k may depend only on attribute occurrences i attribute occurrences sk there is no loss of generality in the above restrictions provided there is no local circularity for any production p in the grammar local circularity means that the dependency graph dp of production p contains a cycle and its exist ence clearly implies circularity the characteristic graphs we now construct for each nonterminal of the attribute grammar a tion of directed graphs called the characteristic graphs of the nonterminal these graphs play a major role in test for circularity are essential for the understanding of the tion process and translator construction to be described in subsequent sections definition for each semantic tree tx with root x the root dependency graph of the tree tx is derived from the compound dependency graph of tx by pro the attribute dependencies on the root x as follows the set of nodes of the root dependency graph is ax and there is an arc from inherited attribute i to synthesized attribute s if the compound dependency graph of ty has a path from i to s figure shows the root dependency graph of the subtree rooted at node of the tree in fig o n n la k n ii n ww ih observing the compound dependency graph of fig one can see that there is a path from il of the node to i of node to s of the same node and ending in s of node this yields the arc from il to s in fig the root dependency graph of a semantic tree tx reflects the dependencies among the attribute occurrences of the root x induced by the tree tx since the node set is ax there can be only finitely many distinct root dependency graphs for trees with root x in the evaluation process of semantic trees to be described in the following sections each subtree of the semantic tree will be characterized by its root dependency graph define of nonterminal x to be any graph node set ax st c is the root dependency graph least one semantic tree t with root x c c denote the set of all tic definition production x let do be the dependency graph p and let for gn be any given set of directed graphs st for each k n the nodes of gk are the elements of then the merged gr denoted is the directed graph obtained from d by an arc from ak to ak when ever te graph gk has an arc from a to a the above definition is illustrated in fig let dp be the graph of production a fig let g and g be the graphs shown in fig on top and let g and g be the empty graphs corresponding to the terminals a and b with the merged graph is shown in fig for instance the arc from il to s origin from the arc from il to s in gz algorithm construction of the sets of characteristic graphs i initialization for each let cx be the empty set and for each let cx contain a single graph whose nodes are ax and which has no arcs ii repeat until no more graphs can be added to any of the sets cx for each production p xn and for every choice of np graphs cd st n k c cx for k l np k form the graph c with node set ax st c has an arc from node i i to s whenever the merged graph cn has a path from io to s add it to cx c is not p yet in cx then o it is that the above process must terminate with no more graphs created since there exist only finitely many such graphs fig shows the sets of characteristic graphs generated by algorithm for the attribute grammar of example knuth has shown that for each nonterminal the set cx constructed in algorithm is precisely x the set of all characteristic graphs of x thus for every semantic tree t with root x there is in cx a corresponding characteristic graph of coincides with the root dependency graph of t and for each graph in cx there at least one semantic tree with root x from now on the root dependency graph of a semantic tree t will be referred to as the characteristic graph of the tree t an the evaluation process given a semantic tree root s the start symbol the evaluation process consists of evaluating the semantic functions of the attribute occurrences in the tree sometimes the goal of the evaluation pro is defined to be the evaluation of some distinguished attribute of the root s shall consider evaluation to be complete only when all attribute occurrences in the tree have evaluated the evaluation process is carried out in two phases the first phase serves as a preparation for the evaluation itself which takes place in the second phase the first phase consists of a depthfirst left to right traversal of the semantic tree the computation in each node takes place after all of its sons have been computed during this phase the translator will compute for each node nx label led by x e v of the semantic tree the char graph the subtree rooted at nx this characteristic graph belongs to the set cx of char graphs of x and represents the among the attributes of nx imposed by the structure of the subtree of nx during the second phase the translator will again process the tree however this time the order in which the nodes are processed is not known a priori but is determined dynamically at runtime according to the individual structure of the tree we may view the second phase as a processor with control that always points to some current node of the semantic tree while at a node nx the pro may perform one of the following types of elementary actions or instructions i call for the evaluation of semantic function fp where p is the production applying ak at the node nx ii transfer control down to a specific son of the current node nx ii i transfer control up to the of the current node starting with control pointing to the root of the semantic tree the translator will process the tree until all attribute occurrences in the tree have been evaluated at which point control returns let us examine the evaluation process from the point of view of an individual node n during evaluation control is moving around t he tree and in the the processor computes new values from the point of view of our node nx nothing seems to happen until for the first time control at nx from above some semantic functions associated with the applying at nx may then be evaluated and control leaves nx in some later on control re turns from the same direction it left perhaps some more attribute occurrences are evaluated and again control leaves the node this goes on until all attribute occurrences of the production applying at nx have been computed and control leaves nx going towards the root never to return thus from a local point of view evaluation consists of and of control with evaluations of attributes performed while at our node we shall refer to a part of the evaluation process from the point control leaves our node nx towards its kth and until the next time control returns to our node as a visit to the kth of nx at each stage of the above evaluation process the choice of the next elementary action to be taken by the evaluator at the particular node nx may depend on the following a the production p which applies at the node nx and its associated semantic functions b the current state of the evaluation process as our node nx ie the set of attribute occurrences of the pro p applying at nx which are currently available c the dependencies among the of nx which are induced by the subtree rooted at nx these dependencies are represented by the characteristic graph of this subtree which has been computed during the first phase to keep track of the sets of available attributes and to the evaluation process at the par node nx the local control automaton al for production p is introduced the local con automaton is an ordinary finite state automaton augmented with some special features in its tion function each state of the local control automaton represents a set of attribute occurrences of production p which are available upon entering this state each transition in the automaton rep an instruction of one of the types call a k transfer up associated with each node of the semantic tree is the local control automaton of the production p which applies at the node the is for control when it at the node and it calls for the evaluation of the sem functions of production p whenever control at a node it its is the first time control reaches this node then the starts from its initial state otherwise it action from the state in which it left off in our translator control must be capable of passing parameters among the various this passing of parameters serves as a means of between the of nodes and is used for two main purposes a when control is down of node the translator has to the receiving what activities took place while the latter was specifically the parameter passed down is a set of inherited attributes of the receiving node which are currently available these inherited attributes are used ing to determine its next move and their values may be used by the translator as arguments in computing semantic functions b when control is up in the tree the translator has to the about the activities which took place in the subtree just visited specifically the parameter returned to the is the set of synthesized attributes of the son just visited which are currently available in both cases we see that the parameter carried along by control is a set of currently available attributes of visited such parameters will be called transmitted sets the evaluation process described above uses the as basic building blocks in order to obtain a translator for a given attribute grammar a finite set of one for each production will have to be constructed local as mentioned above an will be associated with each production the grammar at runtime to each node of the semantic tree there will be attached the of the production applying at the node whenever con reaches a particular node the of the node will be and will the next elementary actions to be taken by the translator when eventually control is to a node the will be suspended and will send along with control a parameter the transmitted set definition consider a production p x let denote the set of all attribute p of p for each k ol np define a for each set of attributes t t b for each set of attribute occurrences a ap if k o then ak a i ak ca if then the operator transforms a set of attributes of onto the corresponding set of attribute of production p while the operator maps a set of a of attribute occurrences of production p onto a set of ak of attributes note that for k o ak contains only synthesized attributes while for k n ak contains only inherited ­ p attributes ak will be called the kth projection of a definition a local control automaton for production x xn is an ordinary finite state automaton some features in its transition function the set of states is divided into two subsets a active states each active state is labelled with a set of attribute occurrences no two active states are labelled with the same set a an active state will therefore be identified by its label a and will be denoted by ap the super script p will be omitted when p is understood b each state is labelled by a pair ka where and a gap as above for each pair ka is at most one labelled with this pair we shall denote this state by with the p omitted when p is understood during the evaluation process whenever is found in an active state a or enters a state then a is precisely the set of attribute occurrences of production p which have been evaluated so far there are of transitions in an transitions leaving active states each transition an active state to one of the following three types of instructions i call for the evaluation of semantic k ii transfer control up to the ie of the current node ii i transfer control down to the kth ie kth son of the current node every active state a may have precisely one of the following three types of exits i call transition exit from a leading to another active state a such a transition is labelled by where and a a u ak there can be no other transition ing state a a transition represents an instruction for evaluating the semantic function storing the result in the appropriate k d of the semantic tree such an instruction is executable only if the semantic function ready to evaluate therefore we shall s impose the additional requirement that whenever transition leaves state ap all occurrences ak which are used as are contained in a figure n a k illustrates a call transition note that the active states are represented by ii a tion from active state a to a where o kn and p n the tion is labelled with and represents an instruction to the translator to transfer control to the kth again this is the only transition leaving state a fig illustrates an note that the are represented by iii conditional a set of tl exits for some t np from active state a leading to tl states a a a same a as t for the active state il n and xj is a nonterminal for j it tie transition into state is labelled by the pair where cj is a subset of cx the set of characteristic j graphs of nonterminal j the last transition into state is labelled by figure illustrates a set of conditional the above set of conditional leaving state a has the following meaning during the evaluation process of a given semantic tree if is associated with node and an enters r state a the exit to be taken from a depends on the characteristic graphs of the sons of in the tree specifically for each j i the conditional transfer transition labelled by transfer cj j will be called admissible iff the characteristic graph attached to the jth son of nx in the semantic tree belongs to cj as we shall see below a transition is precisely when the corresponding visit to the jth son of the current node is guaranteed to produce at least one new attribute of the jth son therefore when the of node enters state a the conditional transfer transitions leaving state a will be checked one by one until the first admissible transition is en this will be the transition to be taken if however none of the first t transitions is admissible then the will be taken thus control will be up to the of nx only if in the current situation no more occurrences can be evaluated for production p not even after some more processing of the subtree of before any further tion at nx can take place some new inherited nx must become available o transmitted sets whenever a instruction either conditional or leading into state is executed a transmitted set t is passed as parameter to the kth along with control specifically this set is t ak the projection of a on the kth for ko this set t consists of all synthesized attributes of xo which are currently available and for kl n t consists of all inherited attributes which are currently available transitions leaving every state s may have several exits each labelled with a distinct set t li of attributes of xk st ti k a exits be denoted by if ko then ti is a set of inherited attributes of the lhs xo and if k then t is a set of synthesized attributes of the son the exit labelled by will lead to the active state a since by assumption ti ka no transition ing will state fig illustrates the exits from a to explain the meaning of the sets ti recall that during runtime when the attached to node enters state a tion leading into this state is executed the of node is then suspended and control is to the kth after some activities take place in other regions of the tree control finally returns to the node its kth carrying with it a transmitted set t at this point at is starting from the same state the exit taken from this state is chosen according to the transmitted set t received namely it will be precisely the exit whose label t coincides with t in this way the transmitted by the kth determines the next move of the after it action in state the sets ti labelling the exits from a represent all possible transmitted sets k can be returned by any kth in any particular situation initial and final s each has precisely one initial state with no which for some set a each has at least one terminal state with no every terminal state for some set a state a state a state is a let us now summarize the structural of properties o q g d s s figure a figure a figure s figure figure lo a aa ua k b k aa ua k dt k a k c k c a figure each is acyclic this is because for every path in the the sets of attributes a labelling both active and along the path must be ordered by inclusion and no more than two con states can be label led by the same set every the ini tial state has precisely one from the active state with same label a while there may be several for any active state figure illustrates a complete set of for the attribute grammar of example each state is given a number c is an abbreviation for call the set a of available attribute occurrences and the label omitted evaluate a semantic tree with a given set of suppose that we are given a for some attribute grammar the translator is made up of a finite set of one for each production in order to carry out the evaluation process two variables will be associated with each node nx of the semantic tree a variable indicating one of the characteristic graphs ci of nonterminal x namely the characteristic graph of the subtree rooted at node nx this variable is computed during the first phase of the evaluation process a variable which during the second phase will store the state of the of nx at the time it is suspended while control in other regions of the semantic tree when control returns to nx the of nx will be starting from this state this vari able is initialized during the first phase the first phase the first phase consists of a depthfirst left to right traversal of the semantic tree during this traversal with each node of the tree there will be associated the characteristic graph of the subtree rooted at the node the characteristic graph associated with a terminal node nt t s vt will be the trivial graph with node set at and no arcs due to the manner of traversal when the translator reaches a nonterminal node nx to compute its characteristic graph the characteristic graphs of all sons of nx have already been computed let us describe the construction of the char graph for node nx where the production applying at the node is p xo xx xn and let the characteristic graphs associated with nodes nx i np be di form a graph i c whose nodes are such that c has an arc from inherited attribute i to synthesized attribute s whenever the merged graph dn has a path from io to s d c is precisely the characteristic graph of node xn to avoid the need for storing characteristic graphs as part of the translator and then al runtime comparing the characteristic graph c con above against all graphs in the set cx some kind of numbering for graphs can o be used graph will be identified by its number which will constitute the first variable of the node nx and during runtime comparison will take place only between the numbers an alternative way for obtaining the tic graph c would to use a look up table which gives for each production p and for each set of characteristic dd dn as above the corresponding p graph c such a look up table can be once and for all at con time while computing the characteristic graphs when using this method there is no need for numbering and each graph will be represented simply by its in the set cx the graphs o themselves need not be kept in memory but the look up table will have to be stored as part of the translator after determining the characteristic nx and the appropriate according graph of to the production p applying at nx the second vari able of the node is initialized state of a p to the initial the second phase the manner in which the semantic tree is traversed during the second phase is custom to the individual structure of the tree evaluation begins by sending control to the root a control begins executing the instructions po of a which after a while transfers control p one of its sons thus control will start in the tree from node to node in an order by the and by the characteristic graphs associated with the nodes at each point in time during the evaluation process all of the tree are except for one which is active the active may call for the evaluation of seman tic functions or it may direct control to one of its eventually when all subtrees of the semantic tree have been evaluated control will return for the last time to the root which possibly after executing a few call tions will enter its final state and control will leave the tree from above evaluation is then complete algorithm evaluation of a semantic tree perform the first phase transfer control to the initial state of the root a along with an empty transmitted p set a terminal state of p is entered o let the currently active ap be in state s and let t be the transmitted set received upon of this i take the exit from s label led by t let t be the active state entered ii execute the instructions of a starting from the state t until a say is reached iii transfer control to the kth along with the transmitted set ak the kth starting from the state stored in the second variable of the kth node figure illustrates the evaluation process of a semantic tree of the grammar of ex according to algorithm using the set of in fig i o i i figure a complete set of o i n s i n s figure a parse tree evaluation process starting from the root control moves down to node due to entering state in then down to node for each node visited the attributes evaluated at the node are indicated in the figure eg at node s and s are evaluated and then control moves up back to the root after evaluating the inherited attribute il of node control moves down again this time to node after evaluating s for node then s of node control returns to the root and evaluation is complete we see that every visit to every node in the tree produces at least one new attribute value to ensure that step i in algorithm can always be carried out the set of must satisfy the following condition the closure condition whenever at runtime control is to an a with transmitted set t the in ap must have an exit labelled by t the above closure condition us that algorithm will always terminate upon entering a final state of the root p theorem if the set of for attribute grammar g satisfies the closure condition then algorithm terminates for each semantic tree t after executing elementary operations where indicates the size of t the completion attribute to guarantee that the above evaluation will result in the com evaluation of every semantic tree a slight modification of the attribute grammar has to be made a new dummy synthesized attribute called the completion attribute is added to each non terminal for each production p xn the completion attribute of x is defined in p terms of inherited attributes of x and of all synthesized attributes including the completion attribute of all sons xk an attribute grammar to which a as above has been added for each nonterminal will be called an augmented attribute grammar in an augmented grammar the completion attribute is dummy in the sense that it is not computed at run time however this attribute enables us to construct such in which the complete evaluation of every semantic tree will be enforced for this reason we add to the definition of the following condition completion condition for each terminal state ap of the root contain the completion symbol s a the set a must p attribute of the start theorem for every augmented attribute grammar g and for every set of for g which satisfies both the closure condition and the completion tion algorithm fully and correctly evaluates each semantic tree of g in time proportional to the size of the tree the a a given attribute grammar in this section we describe informally how a complete set of satisfying the closure tion and the completion condition can be built for each attribute grammar the are constructed in parallel state by state and transition by transition until all of them are complete the construction is based on simulation of all possible situations that can arise at runtime before starting the actual construction of the set of characteristic graphs cx for each non terminal x is constructed after this preliminary computation the construction is initialized by defining fo production an consisting of the initial alone as the algorithm pro the are expanded by adding new states and new transitions in a specific order so as to ensure that the closure condition will be always satisfied for this reason whenever we add to a transition leading into state we must be able to identify all states in all which at runtime might be as a consequence of executing this instruction each of these states must have an exit labelled by the trans set t ak definition for every in define the set to be the set of all in all to which under certain conditions at runtime control might be as of in state the states in may below to any which in some semantic tree with as its kth therefore if k o then pk must coincide with p and if k o then must coincide with one of the sons of p the next definition enables us to keep track of the states in which the were left after the most recent visit definition for each exit from a state s define the set to be the set of all in all which at runtime may pass control to and cause it to be in state s and take the exit clearly will consist only of states of the form whose transmitted et ak coincides with t moreover if k o then pk po while if k o then pk p thus each s is associated with its set and each transition leaving a s is associated with its source set these sets are kept in memory and updated during the construction process a central role in the construction process is by q q consists of of the form where sp and sp are in p and ap respectively and is an exit from sp labelled by t the meaning of such a appearing in q is that exit has to be created in ap unless already there and state sp must be added to source it follows note that by definition of the that t must be precisely the transmitted set of sp the construction process is based on and processing of from q one at a time the pro of a consists of creating the exit and adding sp to its source set the exit will lead to an appropriate active state a u t k which must also be added if absent this new active state will then be developed which in turn may cause the addition of some new to q the process goes on until eventually q remains empty at which point construction is completed developing an active state recall that an active state ap may have three types of exits a single transition a single trans transition or a set of conditional transfer transitions in developing the active state ap we first try to construct a transition out of this state for some attribute occurrence ak of production p st ak a such a can be created only if the semantic function ak is ready to evaluate ie depends only on attribute occurrences in a if such an exit is indeed created it leads into another active state au ak and we proceed to develop this new state unless this state already before in ap in case no exit out of state ap can be created we attempt to construct an exit for some k l np if this turns out to be impossible as well a set of con will be constructed processing a new when a new s is created it is not developed in the usual sense ie no exits from it are constructed right away instead the set of s is computed giving rise to a set of to be entered into the queue q these represent the need to construct new exits label led with the transmitted set of s from all in it follows that exits from are created only via and processing from the queue q and different exits from the same are created at different times the construction algorithm uses a subroutine develop ap for developing an active state after computing the characteristic graphs and the queue q and the a loop for processing the queue q is entered unfortunately a full presentation of the construction algorithm requires quite a few additional technical tions and is therefore omitted here the reader is referred to ch for a complete formal description of the algorithm including a proof of the following theorem theorem for every augmented grammar the construction algorithm terminates with a set of which have the structure described above and which satisfy both the closure condition and the completion condition main theorem for every augmented attribute grammar there can be constructed a translator based on a set of which will perform the complete evaluation of each semantic tree using algorithm in time proportional to the size of the tree and in a fashion relation to previous work the first implementation of attribute grammars is due to f who used parallel processes one for each semantic function a deterministic approach was first developed by lewis and and by b who introduced an algorithm which traverses the tree in a depthfirst lefttoright fashion performing evaluation of all a single pass because of this restriction the class of attribute grammars for which this method applies named in is rather limited to increase the class of attribute grammars that can be efficiently evaluated proposed to allow evaluation to occur in several lefttoright passes such that on each pass the attributes evaluated by previous passes can also be used jl observing that not all programming language features are amenable to evaluation from left to right extended method by intro the alternating semantic evaluator that makes lefttoright then passes showed that certain situations could be evaluated by a single left pass even though no fixed number of right passes was sufficient kennedy and kw noted that s extension still leaves many attribute grammars which cannot be evaluated by any fixed number of alternating passes they an example of an attribute grammar with a rule such that the first visit to a son cannot be made until during the second visit to its no method of evaluation in passes can handle such a grammar for which nested passes are required kennedy and were the first to develop a deterministic approach in which the traversal order is not a priori but is to given attribute grammars by analyzing their dependency constraints their evaluator works like a recursive routine with a tree node to visit as parameter while at a node the evaluator may evaluate semantic functions or call itself recursively to visit sons their construction works only for a restricted class of attribute grammars the grammars for a grammar in this class the action at a node need not depend on the structure of the nodes subtrees in our the attribute grammars are the ones for which our translator construction will yield without any conditional transfer instructions for such grammars the evaluation algorithm can be significantly simplified by eliminating the first phase because in this case the characteristic graphs of the subtrees need not be computed in wa introduced a general model for deterministic evaluation of grammars called the coroutine evaluator and developed general methods for constructing such evaluators however both the evaluator and the coroutine evaluator are not because they may in the tree making a lot of to subtrees before finally reaching a node where a new attribute value can be in this paper following the deterministic approach suggested in kw and w we have pre a general construction of a translator for any attribute grammar by introducing the characteristic graph as the main tool for and representing dependencies among attribute occurrences in a semantic tree we have been able to obtain a evaluation strategy which takes into account the structure of the subtrees of the node being processed the trans introduced in this paper will usually be smaller than the ones constructed in w some reduction techniques used here implicitly which produce minimal as opposed to the tree evaluators in w which tend to be redundant because of this and due to their being optimal our will be by far more efficient complexity issues the constructed in this paper all work in linear time wrt the size of the parse tree provided that one unit of for the evaluation of a semantic function and assuming a random access memory in fact as was noted in one could always produce a evaluation strategy for each individual parse tree by the dependencies in the tree at runtime one would then construct the compound dependency graph of the tree and perform a sort on that graph by the method presented here the dependency analysis is done once for all for each grammar during the translator tion thus us a considerable runtime as for the time complexity of the translator construction it may grow exponentially with the size of the grammar in fact this is in view of the inherent exponential complexity of the circularity problem as our construction will also detect circularity the size of the may also be exponential as the set of characteristic graphs may be of cardinality which is precisely what accounts for the of circularity test a similar situation occurs with respect to parser construction for instance it is a well known fact that lrk parsers can have number of states which is exponential with the size of the grammar moreover the problem of determining whether an arbitrary contextfree grammar is lrk with k unspecified was shown to be npcomplete when k is expressed in unary complete for nondeterministic exponential time when k is expressed in binary nevertheless both the parser and the translator may be worth constructing once and for all for each attribute grammar to be later on used for the efficient implementation of the entire tion process furthermore both can be generated automatically when an attribute grammar specifying a programming language and its translation is given as input to a compiler generating system references aho av and unman jd properties of syntax directed translations j corn systems sc no pp au aho av and unman jd the theory of g translation and compiling vol prenticehall nj au aho av and jd a context free grammar pp b semantic evaluation from left to right comm of the vol no pp ch r and e automatic tion of for attribute grammars technical report dept of computer science march d ta a declarative semantic definition of pl computer science dept f folds a declarative formal language definition system computer science dept stanford g s correctness preserving pro gram transformations proc second sigplan symp on principles of programming languages palo alto pp jl m on attribute grammars and the semantic specification of programming languages phd thesis computer and inf sci dept case university j m live variable analysis grammars and program optimization draft of comp sci university of n hill nc m wf and wc the exponential complexity of the circularity problem for attribute grammars comm of vol pp kl knuth de semantics of context free languages no pp k knuth de semantics of context free languages correction theory j no p v k knuth de examples of formal semantics symp on semantics of algorithm lecture notes in mathematics vo springerverlag new york kw kennedy k and sk automatic generation of efficient evaluations for attribute grammars proc of the rd acm symp on popl l lewis p m dj and re attributed translations j of comp and s sciences vol no pp l p m dj and re corn design theory ls lewis pm and re syntax directed translations jacm vol no na pp d and m removal of invariant statements from nested loops in a single effective compiler pass sigplan notices vol no pp p sr semantic interpretation in system ibm res report rc w sk the coroutine model of evaluation phd thesis rice university texas iii hb tg and unman jd on the complexity of lrk testing vol io pp 