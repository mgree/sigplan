analysis of pointer rotation xerox palo alto research center palo ca introduction pointer manipulation is one of the operations in programming and is a major source of programming errors a great deal of research effort has been to making programs with pointers more reliable in this paper we will present pointer operations which reduce conceptual difficulties when writing pointer programs and increase reliability of programs we will analyze as well as why these operations are more convenient finally we will define the w of and show that it is decidable to check whether the rotation is safe and also show that it is a good measure of the correctness of programs that is if the rotation is safe it is highly that the program is correct and if it is unsafe it is highly that the program is incorrect probably the most successful effort to eliminate difficulties associated with pointer manipulation is the of abstract data types and the use of implementation modules pointers are often used to implement complex data structures which in turn represent abstract data types we cm relevant pointer using abstract types we can easily check correctness of pointer programs rt or are not e to prior is by permission of © the computing machinery otherwise or to republish requires a fee to copy and or specific permission acm this approach is successful when the structure data types is simple or efficiency is not required however programs like garbage collection list marking and copying and balanced tree have not been well specified by abstract types the approach taken abstract data types and makes programs like list marking and copying more reliable and easy to write the idea behind this approach is to introduce higherlevel pointer manipulation primitives instead of pointer assignments since most pointer assignments do not appear isolated we can group several assignments together and replace them by one of these new primitives we also show some theoretical evidence why these operations are two primitives are introduced paper the pointer rotation which is as being equivalent to the following x x begin w x xx where all the locations of arguments xi x are distinct is as pointer assignment yet keeps the of rotation section of this paper previous work related to this subject we give definitions of pointer operations analyzed in this paper in section using these operations algorithm is rewritten in section in section we analyze pointer extensively and obtain several properties which are not by ordinary pointer assignments in section we define the safety of rotation when applied to linear lists and trees then we extend this definition to pointer data structures and show a decision procedure to check safety in section we show two examples list marking and list copying programs written using and we examine how we can directly code the algorithms using these operations and safety checking algorithms are useful history the first time i was exposed to pointer rotation was when me that pointer is a nice for structuring complex operations showed me an example of a priority queue where insertion and deletion are implemented by a set of pointer later i a program for the algorithm in and discovered that the pointer in the program can be fully described by pointer rotation a generalization of pointer i peter whether he this and he me that he realized this fact when he the marking algorithm but he never published it in a recent conversation me that and dijkstra had been studying multiple assignments but almost all of their examples can be described by the results in this paper are therefore applicable to their examples passing parameters by var parameters is crucial to the definition this ensures that all the arguments are evaluated in parallel before any assignments take place therefore these operations can also be defined by multiple assignments xl x begin xx xx end xl x begin xx xx end since rotation is a kind of permutation the question arises whether rotation should really be defined as a composition of there is a wellknown theorem that any permutation can be represented by a composition of however y is not equal to y as shown in fig this is because the value of x in the first swap is not the same as the value of x in the second swap marking algorithm we will observe how these operations make this marking algorithm compact the original algorithm using pointer assignments is comments are placed between definition we will analyze the following two pointer operations which are defined in terms of equivalent procedures xl x begin ar wt w x xl x xn w end xl x begin xl x x x end where locations of variables xl x xn are all distinct from each other for both operations we note here that begin z nil while true do begin left while a w x z end right while a do zx x w end if x nil then exit w z z w end end the version written using pointer is improved algorithm begin x ni while true while a do z end while a do z if x nil end end pointer assignments are replaced by three pointer each node is visited three times corresponding to scan lefttoright scan scan of preorder traversing in the program each rotation one scan of a node the first rotation is the scan the second rotation is the scan and the third rotation is the lefttoright scan this example is again in section properties of i why pointer rotation is convenient in writing algorithms such as list marking i that there must be some measures associated with the graph structures of pointers that remain invariant over rotation operations obviously a single pointer assignment will change most such measures if i could find such measures and show that their invariance would guarantee the safety of a class of like marking algorithms and balanced algorithms this would be strong mathematical evidence of the safety of pointer rotation the first conjecture was that the number of loops in the graph would remain invariant under rotation even though this conjecture looks promising and a counterexample was quickly found suppose y points to a linear list then will introduce a loop such that the previous pointer will point to itself fig c fig effect of however some properties that do hold are property invariance of reference counts the number of pointers to a record will remain the same no matter how many are performed therefore if every record has a reference count field the value of which remains constant property of trees are often applied to linear lists and trees what is unique about these structures is that the reference counts of all the records are always one therefore from property after any number of the reference count of each record is still one hence the structures reachable from the roots remain and what will happen is that some records will form loops and become unreachable from roots see the example of fig it is easy to show that if the reference counts of all records are one and there is a loop no records in the loop are reachable from outside pointers a here is that always use when manipulating linear lists and tr sketch of proofi we will prove here that if all the records reachable from a pointer x have reference counts of one then the data structure is a tree suppose it is not a tree then there is a cycle or a sharing if there is a cycle then either any member of the cycle is not reachable from x or there is a record with reference count more than one we will enumerate the values of pointers address of records along all the possible paths this enumeration may terminate because we took the path on which we a record from which no pointers are in this case there is no circularity if it does not terminate there are addresses which appear more than once then the first address in this enumeration which appears more than once is the record with reference count more than one i consider two linear lists which are pointed to by x and y to move one record from the head pointed by x and to the list pointed by y is var w w y y x x w but the program with rotation is y similarly a linear list is written y nil while do y y points to the reverse of the original list as property of arguments furthermore the arguments can be without changing the effect for example in way and all have the same effect as you can see we can partition into equivalence classes according to their effects for there are n syntactically different and nl equivalence classes each of which consists of n therefore even though there are syntactically different of three arguments there are only two distinct classes of way m once we decide that we can create an algorithm by rotation there is very little of introducing bugs we will see why this is particularly useful in the case of the marking algorithm in section property closure here we mean by closure that some number of applications of will restore the original data structures if all the arguments of are simple variables it is easy to show that this property is true using simple facts from however the application of to a linear list the data structure and no will restore the original data structures therefore we need some premise about kinds of which we can operate in order to assert that there are applications of to restore the original data structures we need some more definitions in order to express the closure property in particular the safety property to be introduced in section is closely related we state the theorem without the definition of safety and prove it in the appendix this property was and suggested to me for investigation by al theorem suppose we have on some data structures and they are all safe then there is a sequence of such that the applications of them will restore the original data structures property completeness of pointer rotation finally we would like to know what can be done by pointer rotation and what cannot be done facts essential to this question are if a part of an algorithm that the reference counts be the same at the entry and at the exit and no new records are introduced the part is implemented by one rotation furthermore if the number of records reachable from pointer variables is the same at the beginning and at the end of computation and if the reference count of each record is the same then there is an equivalent program which uses only pointer pointer however cannot do all pointer using pointer assignments to augment the power is not desirable for example xy yz wu cannot be written using unless one efficiency and writes w u an operation which is both universal and compact is the pointer operation the above example can be written as this is as powerful as primitive pointer assignment since x y is equivalent to z are shown in this figure if there are no other pointers this operation is unsafe since the record a is lost safety of properties investigated in the previous section are mostly facts invariant under what we will see in this section are facts not necessarily be invariant but facts easily whether it holds or not and furthermore they will increase the reliability of programs as we observed in the previous section if are applied to trees some records previously reachable from the roots will become unreachable in most of the cases a record in such a manner is a bad practice these unreachable records have to be eventually by garbage collector and in many reference counting garbage collection schema they are simply forever lost both of them add to the cost of computation in the case such as a programmer will write instead to free the record explicitly since a record by rotation over trees is a bad practice other caused by some program errors we call to be if no records are lost there is also a simple method to check whether a given rotation is write a graph representing pointers this method does not work unless every pointer operation is a rotation since it is impossible to check whether a given structure is a tree let us analyze what we meant by safety of on arbitrary data structures consider the operation z on an arbitrary data structure in the case where the data structures before and after the rotation are shown in fig note that only the pointers and records appearing in the arguments of fig effect of z in arbitrary data structures there may be many other pointers to a b and c therefore it may be possible to still reach a from some other pointers however checking whether there is a pointer to a certain record in an arbitrary data structure is therefore we will only consider pointers and records explicitly mentioned in the arguments of rotation we define that a record is lost in rotation if it is not reachable from any program variable appearing in the arguments through pointers mentioned in the arguments we say a rotation is safe if it does not lose a record in the above sense we will observe in the next section whether this definition of safety is a useful one we will see that all the are safe and all the by arguments are unsafe therefore simple errors are verification method of safety we will show in this section an algorithm to decide whether a pointer rotation is safe this corresponds to research in array bound overflow checking these data structures require some invariant to be maintained over operations on them which gives rise to semantic of the correctness of operations without user supplied assertions notation graphical representation used in fig is a very convenient way to capture two important attributes of of pointer expressions and locations where these values are stored in this paper all the pointer values are addresses of records and locations of these values are addresses of records or of program variables therefore we will give names to records denoting addresses of records and notations to capture the meaning of pointers we use letters for these names of records the following notation is used to represent a pointer variable x xb which states that the pointer variable x points to record b if the value of x is nil it is represented as when b denotes a record which has two fields hd and tl we can use l which states that the value of hd field is c and the value of tl field is d combined with xb we can infer that has value c the following notation facts are direct consequence of the a for all valid selectors s of xt a l ac bd we are not going to address of this notation for arbitrary programs however this notation is sufficient for describing the effect of one rotation on finite number of and records we say that record b is reachable from a program identifier x if xb is true or there is a sequence of records al a ai such that a a a a representation of rotation using this notation we can represent data structures before and after consider the application of z pointers involved are x z and we introduce record names b c d and f and can describe a state before the rotation a a a then the result state of the rotation is xb a l a we say that the rotation is safe if all the records are reachable from program identifiers or the is the origin of a program identifier in the above example we assumed that all the pointers have distinct values that is xz a xz a a a in order to say that this pointer rotation does not lose a record we have to show that it does not lose a record for all the cases for example if we assume xz a a a but then the state before the rotation is xb a a a zf the result state of the rotation is xb a f a zd and again this is safe the decision procedure the example in the previous section suggests an which check whether the rotation is safe using the notation for all the cases of equality and inequality relations among pointers the number of distinct cases can be defined by all the different partitions of pointer values the number of partitions of n objects is bn the bell number of n which is asymptotically close to the factorial of n the algorithm is shown below step enumerate all the pointer expressions appearing in the arguments of rotation assume there are n expressions step obtain all the of n expressions for each partition do the following steps to step obtain the conjunction of equalities and inequalities among expressions according to the partition if two expressions are in the same set make them equal if they are in different set make them step because pointer expressions are not independent x and are examples of dependent expressions some of the conjunctions of these equalities and inequalities are unsatisfiable for example x y a is unsatisfiable check to see if the obtained conjunction is unsatisfiable if so go to step and repeat with the new partition step construct the conjunction representing reachability like the one at the end of section step operate rotation on this conjunction and obtain the result conjunction step check if the formula indicates safety of rotation if safe and all the partitions terminate with the result safe go to step and repeat with the new partition if it is not safe terminate with the result we there are two simplifications of this algorithm first it is not necessary to consider the partition where all the pointers take the same value since any will keep the values of pointers the same they are always safe the other simplification is observed by the fact that if all the arguments are simple variables the change of the value of any pointer expression does not affect the values of the other pointers however it is possible that some variable x is an alias of another variable y the change of x will affect y even though they are y distinct this is avoided by the fact that all the locations of pointers must be distinct actually we can state a little stronger fact for the rotation e en if any argument ei is not an initial section of all the other arguments and there are no aliasing the rotation is safe for example z is a safe rotation assuming x is not an alias of z application of safety check we will examine how these definitions of safety are useful in actual example the following is the marking algorithm let us look at example again and see how the decidability results we obtained can be applied begin d while a to begin x z end while a do z if x nil then exit end for the first rotation x z there are five cases to consider depending partitions of x z and case x z xa a l the result is xb a a case x z xa a a the result is xb a a case z x xb a za a the result is xa a a case x z xb a a the result is xb a za a therefore in all cases all the records are reachable from x or z and the rotation is safe another advantage of using rotation here is that the only different rotation is z x which is unsafe therefore there is very little freedom of what one can do to make the algorithm work furthermore verification becomes simple each record is scanned three times by in the order x z z z but it is very easy to see that successive applications of these three operations will restore the values of x z and therefore it is not difficult to show that all the pointers have the same values as at the beginning when the program terminates finally we see that the definition of safety is actually very useful in bugs consider all the of the above example x z z and z kinds of bugs which might occur are wrong ordering of arguments because of of arguments there are only two cases for each rotation they are z x z and except for the last case which is safe no matter what is the order of arguments they are all unsafe o l back pointer r back pointer l back pointer r forward pointer l forward pointer r back pointer l forward pointer r forward pointer the second phase the tree and rewrites pointers to the correct values therefore each cell is scanned six times in the first phase and three times in the second phase the program for this algorithm is shown below a fact is that just like marking algorithm pointer operations for scanning once cell on one direction are described by one rotation or one except when a new copy cell is created example list copying algorithm we will show how a more complex algorithm than marking algorithm can be written using and the algorithm we examine is a list copying algorithm by the major characteristics of this algorithm are that no extra storage is the computation time is linear the algorithm consists of two phases lefttoright scan phase and scan phase the first phase creates a copy cell for each cell and cells into four classes according to kinds of pointers they have information is stored in the right pointer field of the original cell the classification of cells according to types of cells is as follows type node record lr t node end var mark mark function n node integer ns if its otherwise returns the mark if n then o else if n then else if n mark then else if then end function marked returns true if and only if n is begin marked end function node begin if then nil else nt end procedure mark n i integer begin case i of nr mark nr mark end end procedure copy n node begin gf f down boolean gf nil f n copy nil gf c correspond to and son if f nil then return phase down do down and and not mark gf f fl jl top to left down and f nil or and f d top to right down and f nil or and down false gf d left to top not down down true t u left to right and g right to top od phase down true do down and l down and ii top to right o top to right to left down and ft down false d top to right to top not down and gf nil and f fl down true b right to left not down and and not s f od left to top copy s end body of the program end conclusion we methods to increase reliability and readability of pointer operations we analyzed pointer and as operations to implement pointer such as marking list copying and balanced tree we found several properties are invariant under in particular the number of pointers to each record remains constant we then defined the safety of rotation to be not a record showed that there is a decision procedure for finding out whether a rotation a record we finally examined carefully how and can be used in list copying algorithm are several other advantages of over assignments one is that we can execute rotation more efficiently than pointer assignment in particular for a system using a reference counting memory management rotation can avoid most associated with reference counting another advantage is that the operation can be executed fast for example can be realized by a multiple assignment x y yz zx it will be a challenge to other structuring operations and properties so that we can write more reliable and efficient programs without using expensive and acknowledgements i comments from peter ed and alan appendix closure of we will prove the theorem about closure property introduced in section the same as the one in section suppose we have on some data structures and they are all safe then there is a sequence of such that the applications of them will restore the original data structures we first need a of lemmas lemma let el en be program expressions such that their values are bl bn if we apply a safe rotation which takes only the subset of el en as its arguments then we can still reach bl bn from some program variables in el em f without loss of generality we assume that we apply ei in and this is a safe rotation then bl bi are reachable from some program variables in el ei from the definition of safety we will consider how bj i ln is still reachable from some program variable before the rotation bj is pointed by tj whose explicit form is sk therefore there are k pointers x c sk which form a chain leading from x to bj there are k pairs of locations and values to represent these pointers x location cl value d location c value d x ss sk location ck dk if none of these pointers change value then bj is still reachable from x suppose some of these pointers change values let cl be the location which has the largest subscript among all locations whose contents changed since d is one of bl bi we can assume without loss of generality that d bm since the rotation is safe is an expression f such that f bm after the rotation since there is a path from d to bj l sk is pointing to dk or bj after the rotation h lemma if ei is a safe rotation tk is another rotation fi such that the data structure after the applications of ei fi is the same as the data structure before the rotation in other words every safe rotation has an inverse f suppose ej li is stored at location aj and its value is bj after the rotation the value contained at the location aj is bj li and b is contained at the location ai because the rotation is safe there are pointer expressions which denote pointers at the locations al ai we name these pointers fi fi fl in other words fl is stored at ai and its value is bl f is stored at ail and its value is bi and fi is stored at al and its value is b then fi will certainly restore the values at locations al ai furthermore this operation is safe since all the data structure is exactly the same as the original and all the records bl b have to be reachable from some program variables i proof of the theorem now the proof of the theorem should be easy suppose we have applied safe let us name these as rl r rm from the lemmas the data structure after these applications is still safe then apply the of these in the reverse order namely apply rm q then after each application the data structure is safe and inverse with the original from lemma therefore we obtain the exactly the same data structure at the end i references private communication lp and d g an efficient incremental automatic collector sept l on the design and verification of operating systems phd th u may d the multiple assignment statement ieee trans on software se march private communication jm a bounded storage algorithm for copying cyclic structures h and w m an efficient procedure for garbage collection in various list structures n and k implementation of an array bound checker conf rec of the fourth acm symp on print of prog lang jan 