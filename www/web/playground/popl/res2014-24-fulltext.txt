verifying eventual consistency of optimistic replication systems ahmed univ paris paris paris france abstract we address the verification problem of eventual consistency of optimistic replication systems such systems are typically used to implement distributed data structures over large scale networks we introduce a formal definition of eventual consistency that applies to a wide class of existing implementations including the ones using speculative executions then we reduce the problem of checking eventual consistency to reachability and model checking problems this reduction enables the use of existing verification tools for programs in the context of verifying optimistic replication systems furthermore we derive from these reductions decision procedures for checking eventual consistency of systems implemented as finitestate programs communicating through unbounded unordered channels categories and subject descriptors theory of computation logics and meanings of programs general keywords message passing concurrency model checking static program analysis introduction optimistic data replication is a key technology for achieving high availability and performance in distributed systems it consists of a set of techniques for maintaining multiple copies of the same data called on different sites in a network many interactive applications ranging from networks to spaces and online use this technology in order to increase the quality of their services in fact they use this technology even though the latter lets diverge and thus users may see inconsistent data from time to time this is due to the fact that ensuring strong consistency ie making all always consistent ­ which can only be achieved by all after each update ­ is practically infeasible and therefore users generally prefer high and availability to strong consistency in fact systems implementing optimistic data replication called optimistic replication systems can only ensure weak consistency notions and one of the important issues in this context is to determine what are precisely these notions by the permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm cap theorem ensuring sequential consistency or linearizability together with availability and partition is not possible and thus the correctness criteria adopted for must in general be weaker than these ones that are more suitable for shared memory systems one of the most popular correctness criteria for and which is in some sense the weakest that can be accepted is eventual consistency many that are widely used in practical applications eg simple storage service and app engine are to satisfy eventual consistency optimistic replication systems such as those mentioned above are extremely complex and hard to get right and therefore there is a real need in developing automated formal methods for reasoning about their behaviors and verifying their correctness wrt criteria such as eventual consistency however the first issue to be addressed to achieve that is defining precisely and formally these criteria that are still not well understood in general for instance many works adopt different variants of what is called eventual consistency then the second issue to address is the limits of decidability and complexity bounds for checking these criteria and designing effective algorithmic methods for their verification in this paper we address both of these and algorithmic issues for eventual consistency we introduce a formal definition of eventual consistency that is applicable to a wide class of including systems with speculative executions and and we provide an approach for its automatic verification based on effective reductions to reachability and modelchecking queries in the following we explain in more details the context and the nature of our contributions optimistic replication systems many variants of have been defined eg ­ in general they are based on the following scenario users operations ie updates or queries to one of the sites operations are immediately applied to the local replica to let users continue working based on the effect of those operations and in the background sites exchange and apply remote operations actually this is the scenario used by operation transfer systems there also exist state transfer systems where the sites exchange the contents of their although they may use different techniques state transfer systems can be by operation transfer systems where the allowed operations are only to read and an entire object therefore we focus in this paper on operation transfer systems the communication between sites is usually based on propagation which allows every operation to be to all sites independently of the communication topology when applying remote operations several critical components come into play see and shapiro for a survey · scheduling policies used to order operations in a way expected by users and to make sites eventually agree on some ordering a generic scheduling policy is to label operations by timestamps and execute them in the order of their timestamps · conflict detection used to detect operations that are submitted concurrently by users to different sites and touch the same data eg two requests to a system that concern the same room and the same time slot · conflict resolution used to define the effect of a set of conflicting operations eg in the system the system might require that each request comes with some alternative time slots and in the case of two conflicting requests one will get an alternative time slot · protocols used to make sites agree about the order in which they execute the operations in particular a large class of eg use speculative executions ie operations are applied as they are received from the user or from the other sites in such systems the sites may receive the operations in different orders and thus they may have to repeatedly rollback some operations as they converge towards a final order for example in the case of the final order is decided by a designated primary site eventual consistency in its simplest formulation eventual consistency requires that if the users stop operations then all the sites will eventually reach a consistent state ie they agree on the way operations should be executed however as mentioned in et al this formulation is too and the reason is first this definition does not impose some notion of correctness for the operations executed by the system ie the fact that they should satisfy some welldefined specification second this property offers no guarantees when the system never stops ie when the users new operations for that eventual consistency should take into account infinite executions of the system involving infinitely many operations in fact works the formal definition of eventual consistency and correctness criteria for distributed data structures in general are still very to our knowledge et al is the first attempt to provide a formal framework for reasoning about eventual consistency however the proposed formalization in that paper does not allow to reason about that use speculative executions and as the authors of that paper mention so the first issue that we address in this paper is providing a general formal definition of eventual consistency that is applicable to a class of we define eventual consistency as a property over traces a trace models the view of an external of the system it is a set of sequences of operations where one sequence consists of all the operations submitted to one site it abstracts away implementation details such as the messages between sites eventual consistency is defined as the composition of a safety property that specifies the correct effects of the operations and a liveness property that sites will eventually agree on the order in which the operations should be executed let us look closer to each of these components safety following the scenario described earlier the return value of an operation o submitted to some site n depends on the operations received and scheduled by n before o and the order in which these operations are executed the conflict detection and conflict resolution policies applied by n and the behavior of the executed operations a trace is called safe iff the return values of all its operations are correct in a sense described first the correctness is defined with respect to a specification that roughly models also called consistency in this paper we make the simplifying assumption that are copies of the same object in general a replica may be composed of copies of multiple objects but most replication systems each object independently the expected outcome of executing a poset of operations on a single site concretely a poset of operations models a schedule where incomparable elements are considered to be in conflict ie submitted concurrently to different sites and executing a poset of operations involves the actual implementations of the operations together with the conflict resolution policy that defines the effect of concurrently submitted operations a specification s associates return values of operations with posets of operations intuitively the return value r of an operation o is associated with some poset if o returns r whenever it is executed after the poset of operations more precisely a trace is safe wrt a specification s iff for each operation o there exists a poset of operations in which is associated by s with the return value of o the poset is called the local interpretation of o additionally because of physical constraints we define an relation eb over the operations in the trace such that o o eb iff o belongs to the local interpretation of o and we require that the union of eb with the program order relation is an acyclic relation concretely o o eb iff o is an operation submitted to some site n and o is scheduled by n before o while the local interpretation models the result of applying the scheduling and conflict detection policies note that for that use speculative executions and the local interpretations associated with two operations are arbitrarily different even if the two operations are submitted to the same site the issue of convergence is left to the liveness part liveness the liveness part of eventual consistency requires that there exists some partial order relation gi for global interpretation over all the operations in an infinite trace such that it is possible to choose some local interpretations satisfying the safety property which converge towards gi the convergence is formally stated as follows for any prefix p of gi a prefix of a poset is a restriction of the poset to a downward closed subset there exists only finitely many local interpretations for which p is not a prefix this corresponds to the informal definition given in and shapiro verifying eventual consistency after providing a formal and general definition of eventual consistency we address the problem of checking whether a given satisfies eventual consistency wrt some given specification our aim is first we investigate the question of defining a generic algorithmic verification method for eventual consistency which is independent from the class of programs used for the implementation this is actually a hard problem since regardless of the complexity of the implementation eventual consistency requires reasoning about nested quantifiers over infinite partial orders then our second goal is to derive from the generic verification method decidability and complexity results for particular as large as possible classes of implementations let us then examine each of these points from eventual consistency to modelchecking problems we show that the static verification of the safety and liveness parts of eventual consistency can be reduced to reachability and model checking problems this reduction allows to use any existing tools for verification of concurrent programs in the context of verifying eventual consistency the reduction is done by defining a monitor which when composed in parallel with the system reaches some specific error state or violates some temporal logic formula in ltl extended with presburger predicates if and only if there exists an execution of the system that violates eventual consistency the monitor is a sequential program that in a way the operations submitted to all the sites in the network therefore its observations are interleavings of operations performed by the reasoning about such observations is possible since we are concerned with the static offline verification of the monitor is the parallel composition of two monitors one for checking the safety part in eventual consistency and one for checking the liveness part these monitors are abstractly defined as state transition systems that take a step each time an operation is executed in the system actually they can be seen as a way of every operation performed by the system in order to obtain a program on which the reachability and modelchecking queries mentioned above are applied for these reductions we assume that the operations are instances of a finite set of methods with a finite set of possible values however system implementations can still be very complex users are allowed to many operations and systems can use unbounded domains for timestamps or unbounded channels for communication the constructions we provide are based on subtle arguments indeed one of the issues is that return values of operations depend on arbitrarily large sets of prior operations and unbounded number of possible orders between these operations the effect of each operation depends on the local view of the site n to which it is submitted the local view consists of the set of operations known by n and the order in which n they were executed by other sites in fact when considering the safety part we only need to check that for each operation such a local view exists and it is consistent with the return value of the operation unlike for the liveness part we do not need to check the convergence of the local views toward a global view ­ which is a partial order over the infinite set of operations in the trace in order to know if such local views exist it is sufficient to count the number of methods previously a careful analysis of the definition allows to show that it is possible to count only up to some finite bound and thus only consider the minimal posets in the specification therefore the problem of finding a violation for the safety property can be reduced to some bounded counting argument where the monitor counts the number of times the system executes each of the methods and then compares the counter values to the number of methods in the minimal posets of the specifications this raises the problem of computing the number of methods in the minimal posets of the specification in order to address this problem we need to consider some concrete formalism for describing the specifications therefore we introduce a class of automata for describing specifications of essentially each poset of operations in the specification is abstracted into a sequence of multisets of methods each method in these multisets corresponds to the method instantiated by an operation in the poset which is then recognized by an automaton called multiset automaton where the transitions instead of being labeled by symbols as in the case of automata over words are labeled by presburger formulas the sequence of multisets corresponds to a decomposition of the poset in levels used in algorithms for parallel tasks scheduling where a level is a set of elements for which the length of the longest path to a maximal element is the same these automata offer a good between and expressive power in particular they allow to define a of specifications eg specifications of replication systems that use the last writer conflict resolution policy or commutative conflict resolution policies like in the case of the we then prove that for specifications recognized by multiset automata it is possible to effectively compute the number of methods in the minimal posets for the liveness part of eventual consistency we consider again a parallel composition between the system and a monitor that counts the number of times the system executes each of the methods we show that the problem of finding a violation can be reduced to the problem of checking that the monitor reaches a state where its counters satisfy some specific property and from there on the methods executed by the system return only some particular set of values the property that the counters should satisfy is quite complex it characterizes the number of methods occurring in the limit of an infinite sequence of posets belonging to the specification however we show that for specifications recognized by multiset automata this property is definable by a presburger formula which can be effectively computed decidability and complexity based on these reductions we define decision procedures for checking eventual consistency of which are defined as the parallel composition of a fixed set of boolean programs communicating through unbounded unordered channels indeed we consider that it is natural in our context to assume that channels are unordered since in general networks offer no guarantees on the order in which messages arrive even if they are sent by the same site these decidability results are based on the fact that this class of systems can be modeled by vector addition systems with states for short since unbounded channels can be encoded as counters and the problems to which we reduce checking the safety resp the liveness part of eventual consistency are decidable for sets relations for a set a pa denotes the set of all subsets of a let r a × b be a relation for any y b ry denotes the set of elements x a such that x y r the notation is extended to subsets of b as usual sequences let be a finite alphabet the set of all finite resp infinite sequences over is denoted by resp also a set of sequences is called if the prefix of any sequence in the set is also in the set posets let a be a possibly infinite set poset for short a path of length n in a is a sequence of elements xx xn such that for all i n xi xi the downward closure of b a wrt denoted by b is the set of all elements in a smaller than b ie b b similarly the upward closure of b a wrt denoted by b is the set of all elements in x a such that y x for some y b the may be omitted when the partial order is clear from the context we say that b is downward closed resp upward closed wrt iff b b resp b b the poset a is called a prefix of a denoted by a a iff a a is the intersection of and a × a and a is downward closed wrt we say that a poset a is iff for all finite sets b a b is finite labeled posets a labeled poset is a triple a where a is a poset and a is a function that labels each element of a with a symbol in the set of all labeled posets is denoted by poset given the projection of a labeled poset a over is the labeled poset b where b is the subset of a containing all the elements labeled by symbols in ie b a a and resp are the projections of resp over b × b resp b the parikh image of a possibly infinite labeled poset a is the multiset n mapping each symbol a to the number of elements x of a such that x a if some symbol a occurs infinitely often then a note that the parikh image of a labeled poset can be also interpreted as the multiset of symbols in the notion is extended to sets of labeled posets as usual a labeled poset a is called a prefix of a iff the poset a is a prefix of a and y y for all y a we also say that is a completion of this is denoted by if a a where we say that is a completion of two labeled posets a and a are isomorphic iff there exists a bijection h a a such that for all x y a x y iff hx hy and x hx a set of labeled posets a is called iff any labeled poset isomorphic to some labeled poset in a belongs also to a functions let a and b be two sets we denote by a b the set of functions from a to b for a function f a b and a a b b f a b is the function which maps all elements a a to f a and which maps a to b if a a an and b bn are possibly equal elements of b we denote by a b an bn the function f a b which maps ai to bi for all i n likewise for b b we denote by a a b the function which maps every a a to b for functions f a n and g a n with a a f g a n maps each a a to f ga f a ga and each a a a to f ga f a modeling optimistic replication systems a concrete execution of an is modeled as a trace that abstracts away many implementation details a trace is a poset of operations where all the operations submitted to the same site are totally ordered we suppose that operations are instances of a fixed set of methods for static verification of eventual consistency an is viewed as a set of sequential observations these are sequences of pairs of the form n o where n is a site name and o is an operation such a pair denotes an operation o submitted to site n the trace represented by a sequential observation contains all the operations in such that any two operations submitted to different sites are incomparable and the order between any two operations submitted to the same site is consistent with the order in which these two operations appear in the sequence let m be the set of method names and d the domain of return values for simplicity we suppose that input parameters are encoded in the method names a method is a pair m r where m m and r d we denote by m d the set of all method an operation o is a pair i a formed of an identity i n and a method a m d we denote by o the set of all operations given a method a m r we let m r and given an operation o i m r we let i m r and m r an operation o i m r may be called an or an m also given a set of method names m m resp a set of method y m d o is called an m operation resp y operation iff m m resp m r y a trace is a possibly infinite poset o po where o o and po called the program order is a disjoint union of a set of total orders over o we assume that a trace does not contain two operations with the same identity the set of operations resp the program order in a trace are denoted by o resp po given a fixed set n of site names a sequential observation observation for short of an is a possibly infinite sequence over on n × o we assume that such a sequence does not contain two operations with the same identity a sequential observation models the view of a sequential over the concrete executions of the replication system then an optimistic replication system i is a state machine that produces a subset of on by an of notation the set of sequences produced by i is denoted also by i given an observation let o denote the set of operations that occur in ie the set of operations o for which there exists n n such that n o occurs in given an observation on the trace of is defined by trace o po where · o o and · po o o n n st n o occurs before n o in next we give examples of that we use throughout the paper example register the register register maintains an integer register and supports the set of methods mr i n rd where assigns value i to the register and rd reads the current value of the register a method rd can return any value from n while the methods return some special value ie the domain of return values is dr n we thus have m dr rd i i n example register the register maintains an integer register and supports the same set of methods as the register a method rd can return any set of values from n thus the domain of return values of the is pn and its set of method is m rd i i n and i n example set the set maintains a set of integers over which one can apply the set of methods i n where adds the integer i to the set removes i from the set and tests if the integer i is in the set we assume that the methods add and rem return some fixed value while can return or thus the set of return values is and m i n eventual consistency in this section we introduce a formal definition for eventual consistency whose main are presented specification in the context of resp the correctness of the operations associated to some object usually involves some mechanism of conflict resolution in order to define the effect of a set of operations executed by different threads resp submitted concurrently at different sites in the case of systems the conflict resolution mechanism is usually specified by the notion of linearizability which requires that the effect of a set of concurrent operations that overlap in time is the same as the one of a sequential execution of the same set of operations in the context of where each site maintains its own copy of the object some more general mechanisms of conflict resolution are required to specify both the sequential semantics of the operations and the conflict resolution mechanisms we use posets of operations instead of sequences of operations as in the case of linearizable objects we dont use a total order because in general it is that all sites agree on a total order of operations and sometimes even unnecessary in case of commutative operations for instance moreover the mechanisms used to detect conflicting operations are not always precise we assume that the specification cant distinguish between two posets that are identical ie isomorphic when ignoring the identities and the return values of the operations the to return values is motivated by the fact that in real implementations the sites exchange operations without their return values in such systems it is not expected that an operation returns the same value when executed at different sites a specification associates to each method m r an set of posets the closure under isomorphism and the fact that we use labeled posets model the fact that the specification doesnt observe identities and return values the fact that a poset is associated to m r means that any site that the set of operations in in that order reaches a state where the call to m produces the value r definition specification a specification is a function s m d where for each method a m d sa is an set of posets wr wr wr rd wr wr wr rd wr wr wr wr wr b a rd rd wr wr wr rd wr wr rd rd rd wr rd wr a b figure traces of the register for simplicity the return values of the wr operations and the ids of each operation are omitted the program order is defined by the vertical lines from top to bottom add rem add rem rem add add rem rem rem c figure examples of labeled posets belonging to a the specification of the register b the specification of the and c the specification of the the order relations are defined by arrows an arrow from an element x to some element y means that x is ordered before y we omit arrows implied by transitivity we give several examples of specifications for the replication systems mentioned in the previous section example register specification the specification sr of the register is given by for every a is the set of all sets and for every a rd i is the set of all sets where the maximal element labeled by a write is labeled by figure a contains two examples of sets in example specification the specification of the is defined by for any a is the set of all posets and for any a rd i is the set of all posets such that i i iff there exists a maximal element labeled by in the projection of over the elements labeled by write methods i n figure b contains an poset in example specification the specification is given by for any a or a is the set of all posets and for any a resp a is the set of all posets such that the projection of over the elements labeled by or contains a maximal element labeled by resp contains no maximal element labeled by figure c contains an example of a labeled poset that belongs to both and local interpretation the return value of some operation o submitted to some site n depends on the set of operations applied at n before o and on the the effect of applying the scheduling and conflict detection policies over this set of operations taken together they can be represented by a poset of operations called the local interpretation of o and denoted by because of speculative executions one has to consider a local interpretation for each operation o in the trace the order in which known operations are executed can change at any time the local interpretations define another relation over the operations in the trace called and denoted by eb we say that some operation o is executed before another operation o ie o o eb iff o belongs to the local interpretation of o for example figure a a trace of the register where the arrows define a possible eb relation note that the is executed before the first occurrence of rd but not before the second occurrence of rd we say that the return value of some operation o is correct iff the labeled poset defined by where every operation o is labeled by belongs to then a trace is safe iff the return values of all operations in are correct for example in the case of the first rd operation in figure a one can choose to order the before the this local interpretation defines an poset which belongs to the specification of the register similarly one can show that all return values in figure a are correct because of physical constraints eb must not create cycles together with the program order for example the trace in figure b could be one of the register if the relation eb is defined by the arrows in the figure we assume that the initial value of the register is however this means that the site executing the operations in the left received a message from the other site containing the wr operation and this message was created after rd has finished thus in real time rd has before the which contradicts the eb relation global interpretation the fact that the sites will eventually agree on the way operations should be executed is defined as a liveness property over infinite traces of the system given an infinite trace we consider a partialorder over all the operations in called the global interpretation and denoted by gi the liveness property requires that the local interpretations defined for the operations in converge towards gi more precisely for any finite prefix p of gi the number of local interpretations for which p is not a prefix is finite note that this implies that any operation o in the trace is executed before all operations in except some finite set a system that satisfies only this property will be called weak eventually consistent we will require that gi satisfies some condition ie that it is which basically means that every operation can be executed after only finitely many other operations for example let us consider the infinite trace in figure we consider a global interpretation gi which in this case is a total order that the write operations in a sequence of the form wr wr and keeps the same order as in the trace for the wr operations resp the wr operations in the following we ignore the order between the because they are not important for the correctness of the return values we show that it is possible to choose local interpretations for the rd operations such that the return values are correct and such that the orders converge towards gi in a similar way this can be shown for all the other operations in the trace for each rd operation o the local interpretation is the poset that consists of all the write operations that occur before o ie if o is the ith occurrence of rd then the poset contains wr wr wr rd wr wr wr wr wr rd wr wr wr wr wr wr wr wr wr wr wr rd wr rd figure an infinite trace of register where one site executes wr rd and another site executes wr rd the jth occurrence of wr and wr for all j i totally ordered in a sequence of the form wr wr wr wr consistent with the program order the relation eb is by arrows in figure defined as such the local interpretations converge towards the global interpretation gi we now give the definition of eventual consistency for any poset a as above denotes the labeled poset where every operation is labeled by the corresponding method name in m ie a meth definition safety weak eventual consistency a trace o po is called eventually consistent wrt a specification s iff gi an partial order over o o o an poset eventual it is said to be weak eventually consistent wrt s iff eventual is replaced by in the condition above thus gi and can be removed finally it is said to be safe wrt s iff only the axioms and are satisfied ie o o an poset the relation eb is defined by o o eb iff o eb po is acyclic for all o i a o sa gi is for all o o o o o eb is finite eventual for any finite prefix p of the poset o gi o p is finite table the list of axioms used in definition axioms and are thus safety conditions and ensure that the operations respect the specification s axiom is a liveness condition which ensures that eventually every operation will be executed before all the other operations in the system axiom eventual is a stronger liveness condition which ensures that all nodes eventually agree on a possibly partial order in which to execute all the operations an i is said to be weak eventually consistent resp safe iff for every observation of i trace is weak eventually consistent resp safe in the next sections we consider the problem of verifying eventual consistency and we assume that m d is finite rd rd wr wr wr a a safe trace with one possible total order e depicted with arrows rd rd rd wr wr wr b an unsafe trace figure examples of traces of the register safety we consider the problem of checking that an is safe and we prove that it can be reduced to a reachability problem first we show that in any total ordering over the operations of an unsafe trace consistent with the program order one can find an operation o such that there are not sufficiently many operations before o in this total ordering to construct a labeled poset belonging to its specification ie for example for an unsafe trace of the register eg the trace in figure b with read and write operations this means that no matter in which order ­ consistent with the program order ­ it is read there will always exist a read that returns a value not written by a previous write this allows us to define a monitor for checking the safety of a replication system i that records all the operations executed by i and stops with a negative answer at any time that it detects an operation o for which with the recorded set of operations it build a labeled poset belonging to the specification of o actually we prove that it is sufficient that the monitor only counts the number of times the system executes each of the methods in m until some bound and then compare the counter values with the minimal vectors in the parikh image of the specification the next lemma states the characterization of unsafe traces lemma a trace is safe wrt s iff there exists a total order e ­ called the issue order ­ on o consistent with po such that for every operation o of there exists a poset vo o where vo is a subset of eo and vo o meth proof for each o define vo o this ensures that axiom holds moreover the relations eb and po are both consistent with e which implies that axiom holds conversely assume that for each operation o there exists such that and hold let e be any total order compatible with eb and po which exists since eb po has no cycle figure a illustrates one such total order on a safe trace then for each operation o define vo o as the poset lemma implies that if is the trace of an observation and it is unsafe then there exists a prefix of which ends in an operation whose return value is not correct ie it is not possible to define a labeled poset that contains only operations in this prefix that belongs to the specification of o this is stated in the following lemma lemma given an i the following are equivalent there exists an observation i such that trace is not safe there exists an observation n id a i such that there exists no poset vo o whose elements are a subset of o such that vo o meth sa proof assume that holds for n id a let o id a be the last operation of if was safe we would have a local interpretation such that sa note that the operations in belong to o which contradicts thus is not safe and implies conversely if we have an observation such that trace is not safe then by lemma there exists a prefix p of such that p satisfies indeed if there were no such prefix the total order on o induced by would satisfy the condition of lemma which would the fact that trace is not safe the following corollary is a of lemma in terms of parikh for any finite observation the image of is a function m m n that maps each m m to the number of operations o in with m the image of a finite trace denoted by m is defined similarly corollary an optimistic replication system i is not safe iff there exists n id a i such that m given an observation and an integer i im is the parikh image of where all the components larger than i are set to i that is mi m m mm for each a m d let va be the set of minimal elements of wrt the ordering relation over vectors of natural numbers so that va and let ia be the maximum value appearing in the vectors of va let i max ia a m d we remark that m is equivalent to the fact that m is not greater than one of the minimal elements va va moreover since all the components of the vectors of va are smaller than i m is equivalent to im va in general the sets va cannot be computed but in section we give a class of specifications for which they can we define a monitor which counts all the methods it up to the bound i and every time it reads a symbol n id a it goes to an error state iff the vector of methods seen is not larger than some va va formally is a deterministic finitestate transition system q q where · q m i is the finite set of states · q the set of initial states only contains q m m · q × on × q with q n id a iff q va q n id a q iff q va and q i theorem safety monitoring an optimistic replication system i is not safe if and only if the parallel composition i can reach the error state liveness in this section we give properties which characterize weak eventually consistent traces that will be used to define reductions of deciding weak eventual consistency to ltl model checking weak eventual consistency we first consider the case of weak eventual consistency because it is simpler while already showing some of the difficulties we have to solve moreover for some systems weak eventual consistency implies eventual consistency for instance when all the operations are commutative for an infinite trace to be weak eventually consistent there must exist some local interpretations which show that is safe but also which ensure that each operation o o is all the other operations except for some finite set the latter implies that any finite set of operations is every operation after some finite prefix thus for any a m d if there are infinitely many in then sa the specification of a must contain arbitrarily large posets this property of sa can be stated as a property of the parikh image of sa and this allows us to define a reduction of checking if some replication system i is weak eventually consistent to checking if i is safe and if the parallel composition of i with a monitor that counts the methods executed by i satisfies some ltl formula mainly the temporal operators in this formula are used to identify the infinitely occurring method in some execution in the following lemma we characterize weak eventually consistent traces to identify the infinitely occurring method in some trace we use the following notation given b m d and a finite trace p let pb be the set of all traces which extend p ie p is a prefix of by an infinite set of such that there are infinitely many in for each a b lemma characterization of weak eventual consistency given b m d such that m mk a trace pb is weak eventually consistent wrt s if and only if · is safe and · a bn nn nk n mp m n mk nk proof if is eventually consistent then for each operation o o there exists a local interpretation such that the axioms and hold let a b and n n since there are infinitely many in we deduce from axiom that there exists one noted o such that or equivalently contains the operations of p and at least n additional for each m from axiom we know that sa which shows that there exists n nk n such that mp m n mk nk since is safe there exists an issue order e over o that satisfies the conditions in lemma in the following we consider that the operations in are totally ordered according to e for each n n let on be the last operation in which occurs after at most n for each mi for each a b and n n let na n such that mp m na mk and let be the first operation in such that the prefix of that ends in satisfies m mp m na mk the existence of is by the fact that contains infinitely many for each a b for all n n and o in between and the local interpretation vo o is defined as follows the set vo consists of all the operations of p all the before on and some before o st mp m na mk this is possible because for each mi there are at most n before on and o occurs after that satisfies now since there exists a partial order o over the set vo such that vo o meth sa for the finite number of o that occur in before oa we use the local interpretations whose existence is by the safety of since both eb and po are consistent with the total order e axiom holds for each operation we have chosen so that axiom holds moreover for all n n each operation o that occurs before on is all operations except for a finite set ­ those that some with a b thus eb satisfies axiom which concludes the proof by lemma an i violates weak eventual consistency iff it violates safety or if it produces a trace in pb for some p and b m d with m mk such that there exists a method a b satisfying n nn nk n mp m n mk nk given b m d and a b let b a v n nn nk n v m n mk nk then can be rewritten as mp b a like for safety we construct a monitor which counts the methods executed by the but this time without any bound finding a violation of weak eventual consistency reduces to finding a b m d and a finite execution p in the system i such that ab mp b a and p can be extended by only using as well as infinitely many for each a b the latter can be checked using ltl model checking by adding to each state of the monitor a register recording the method of the last transition formally is a transition system q q where · q m n × m d · i is the set of initial states q a i iff q m m and a m d · q × on × q where q b n id a q a iff q and a b m d now given a replication system i we consider the system i defined as the parallel composition of i and define the following ltl formula b a bm d ab b bb b by an of notation b a denotes also an atomic proposition which holds in a state of the system iff the vector formed by the counters of is in b a as for the minimal elements used in monitoring safety the sets b a cannot be computed in general in section we give a class of specifications for which they can for each b m d resp b m d b resp b is an atomic proposition which holds in a state iff the second part of the state of is in b resp is b also and denote the temporal operators of ltl eventually next and always respectively theorem weak eventual consistency monitoring an optimistic replication system i is weak eventually consistent if and only if i cannot reach and i eventual consistency by following the same line of reasoning as the one used for weak eventual consistency we first derive a necessary and sufficient condition for a trace to be eventually consistent in the case of an eventually consistent infinite trace axiom eventual ensures that for every finite prefix p of the global interpretation order gi after some finite prefix of all the operations have p as a prefix of their local interpretations if b m d is the set of all a such that contains infinitely many then the specification of each a b must contain an infinite sequence of posets such that any prefix p of gi is a prefix of all these posets except for some finite set thus any prefix p of gi can be extended in order to belong to each of the sa with a b moreover if p contains all the finitely occurring operations in then the extension can only add elements labeled by methods in the set of labeled posets which can be extended in such a way is denoted by b this implies that an infinite sequence of increasing prefixes of gi must belong to b which by extending a classical definition of limit from words to labeled posets can be stated as the poset defined by gi is in the limit of b now since gi is a reordering of this is equivalent to the fact that the multiset of methods that occur in is the same as the multiset of methods that occur in some infinite labeled poset belonging to the limit of b thus the eventual consistency of a trace can also be characterized in terms of parikh we show in the following that the same monitor defined previously can be used to reduce the problem of checking eventual consistency to ltl model checking next we formally define b and the notion of limit definition given a specification s b m d and a b let ­ the of s by ­ be the set of labeled posets for which there exists an in sa then let b ab definition limit given a set a of finite labeled posets we denote by the set of infinite labeled posets a which have an infinite sequence of increasing prefixes in a such that every element in a is in a prefix and all greater ones remark in the context of sets the condition that every element in a is in a prefix is already implied by the rest of the definition however this is not true in the general case for instance let a be an infinite labeled poset where a ai i n bi i n ai a bi b for all i a a and b b this poset is not in the limit of a the set of all finite sets where all elements are labeled by a even though it has an infinite increasing sequence of prefixes which are in a this is due to the fact that the prefixes dont contain all the elements of a this leads us to the following necessary and sufficient condition for eventual consistency lemma characterization of eventual consistency let o po be an infinite in pb the trace is eventually consistent iff it is safe and m b proof if is eventually consistent then there exist gi o × o and for each operation o o o × o satisfying the axioms eventual it is enough to show that o gi meth b let p be a finite prefix of o gi meth containing at least the operations of p for any a b by axiom eventual since there are infinitely many there exists at least one o such that p is a prefix of by belongs to sa and by the fact that p contains all operations in p is a of p thus p b since we can find an infinite increasing sequence of such prefixes p containing every operation of o we have o gi meth b this part of the proof is illustrated on figure let a be an poset in b with m ma define gi such that o gi meth is isomorphic to a and let f be an isomorphism from a to o there exists an infinite sequence of increasing prefixes a a of a such that every f ai contains the operations of p and such that for all a b and for all n n an moreover each operation of o appears in at least one f ai for some i and in every f aj with j i since is safe there exists an issue order e over o that satisfies the conditions in lemma in the following we consider that the operations in are totally ordered according to e the properties on a a imply that for every a b and every n n there exists an of f an such that sa we assume that the elements added to f an to obtain come from o and that they occur after the operations in f an this is possible because contains infinitely many a ordered by e p ob occurs after all operations in ab ob all oc every o after ob has a and p as a prefix of their ob local interpretations f f a prefix containing the operations of f p a b p a b a b figure illustration of the proof of the second part of lemma for b b c operations for each a b for every a b and n n let be the first operation that occurs in after all the operations in in the following we define for every o such that all the axioms of eventual consistency hold · for every a b for the finite number of o that occur in before oa we use the local interpretations whose existence is by the fact that is safe similarly for every a m d such that contains finitely many a operations · for every n n a b and for every o between and we define note that this implies that f an and that sa axioms and hold for the same reasons given in the proof of lemma axiom holds because of the way we have defined the limit of a set of labeled posets it remains to show that axiom eventual holds let p be a prefix of o gi let an be one of the previously defined prefixes such that p f an for every a b and for every o that occurs after p is a prefix of thus there are only finitely many operations which do not have p as a prefix of their local interpretations which concludes the proof monitoring for eventual consistency is similar to the monitoring used for weak eventual consistency let b be the set b v m n v m b according to lemma in order to find a trace which is not eventually consistent it is enough to look for a trace in pb for some p and some b m d such that mp b this problem can be again reduced to ltl model checking over the parallel composition of i and the same monitor in this case the ltl formula to be checked is b bm d b bb b as previously for any b m d b holds in a state of the system if and only if the vector formed by the counters of is in b theorem eventual consistency monitoring an optimistic replication system i is eventually consistent if and only if i cannot reach and i specifications of finitestate optimistic replication systems the reductions of eventual consistency to reachability and ltl model checking are effective if one can compute the set of minimal elements in the parikh image of the specification and effective representations for the sets of vectors b a and b defined in section and in the following we introduce representations for specifications of finitestate optimistic replication systems for which this is possible essentially each labeled poset is abstracted as a sequence of multisets of symbols in which is then recognized by a finitestate automaton where the transitions instead of being labeled by symbols as in the case of automata over words are labeled by presburger constraints by multisets of symbols as vectors of integers a sequence of multisets is recognized by an automaton if there exists a run such that the sequence satisfies the constraints imposed by the transitions of this run at each step the abstraction of a poset as a sequence of multisets is defined based on its decomposition in levels used in algorithms for parallel tasks scheduling these automata offer a good between simplicity and expressiveness since they can recognize words over an alphabet they can represent specifications that contain only sets required by based on the last writer conflict resolution policy they are also able to represent specifications of with commutative conflict resolution policies ie the effect of a set of conflicting operations does not depend on the order in which they are read such as the see example for the latter case the specifications represented by multiset automata are not exactly the ones introduced by the designers of these systems however we can prove that eventual consistency wrt the original specification is equivalent to eventual consistency wrt the specification recognized by the multiset automaton in the following we give a precise statement of this result let s m d be a specification and a symmetric binary relation over m called commutativity relation we say that an poset a is canonical wrt iff any two elements labeled by symbols that are in the relation are incomparable ie for any x y a x y implies that x y and y x then the specification s is called closed iff for every a m d if sa contains a labeled poset a then sa also contains a labeled poset a which is canonical wrt and such that furthermore let s be a specification st for every a m d sa is the set of posets in sa that are canonical wrt for example the labeled poset in figure c belonging to the specification is canonical wrt the relation o that consists of any pair of methods having different arguments eg and with i j and any pair formed of an add or a remove and respectively a lookup eg and the specification in example is also the specification in example is m closed where m contains any pair of a method and a rd method the following result follows from the fact that eventual consistency imposes rather weak constraints on the local interpretations associated to the operations in a trace proposition let i be an a symmetric binary relation over m and s a closed specification then i is eventually consistent wrt s iff i is eventually consistent wrt s a specification s is called canonical wrt iff for every a m d sa contains only posets that are canonical wrt proposition shows that for like the and the it is enough to consider canonical specifications in the following we define multiset automata and show how they can be used to represent canonical specifications let a be a labeled poset the ith level of is the set of elements x in a such that the length of the longest path starting in x is i a decomposition of is a sequence an a where n is the length of the longest path in and for all i n ai is the ith level of note that the decomposition of a labeled poset is unique the decomposition of is the add add rem add add add add rem add rem rem add add add rem rem add add add add add rem rem add figure some transitions of a multiset automaton that a specification of an with at most two elements the method lookup labels the states and lookup labels the states and and so on sequence n where for all i n i is the parikh image of ai by definition the length of n is n example decomposition consider the poset in figure c the of this labeled poset is add rem add rem rem add add rem rem rem we define an effective representation for sets of posets by finite automata that recognize their ie sequences of nonempty multisets of symbols from m in order to represent multisets of symbols from m we consider presburger formulas over a set of free variables m m m where m denotes the number of occurrences of the symbol m let fm denote the set of all such formulas also for any presburger formula let denote the set of models of definition multiset automata a multiset automaton over m and m d is a tuple a q q qa a m d where q is a finite set of states q × fm × q is the transition relation q q is the set of initial states and for any a m d qa q we say that the states in qa are labeled by a intuitively an poset is recognized by a iff there exists a run in a starting in the initial state such that the transitions are labeled by formulas that are satisfied by the parikh of the n th level n th level etc where n is the length of the longest path for example the multiset automaton in figure the labeled poset in figure c because there exists a run starting in the initial state that goes through the states labeled by such that the associated sequence of formulas describe the in example a run of a multiset automaton a is a sequence q q n qn st for every i n qi i qi such a run an poset iff the of is nn and for every i n ni i we say that the length of this run is n given q q the set of all posets recognized by a run of a a that ends in q is denoted by la q the labeled posets in la q are said to be interpreted to q given a set of states f q la f denotes the union of la q with q f definition canonical specifications and multiset automata a specification s canonical wrt is recognized by a multiset automaton a iff for every a m d sa is the set of posets in la qa that are canonical wrt example a multiset automaton for the let be a finitestate restriction of the specification in example st the set object contains at most two elements and and contains only posets canonical wrt o this specification is defined over the set of methods add rem and lookup with arguments and denoted by mo rs the automaton in figure the following theorem is a direct consequence of the fact that for any multiset automaton a one can construct a over sequences whose language has exactly the same parikh image as the set of labeled posets recognized by a theorem let s be a specification recognized by a multiset automaton a then for every a m d there exists an effectively computable presburger formula a st sa a theorem implies that for every a m d the set of minimal elements in sa is effectively computable and that there exists a computable presburger formula describing b a given b m d we show that b defined in section is definable as an effectively computable presburger formula provided that the specification s is recognized by a multiset automaton a satisfying some conditions first a must recognize a set of labeled posets ie q la q is this is quite natural since the set of all posets in some specification ie a sa is usually another condition that a must satisfy can be roughly stated as follows given a set of methods m and a labeled poset interpreted to some state q the fact that there exists an m completion of interpreted to q depends only on the states q q and the set of methods m formally for all q q q m m and la q la q m iff la q m for example if we consider the automaton in figure for any labeled poset interpreted to the state labeled by there exists an interpreted to the state labeled by in the case of the poset in figure c this completion contains one more element labeled by add which is greater than all the elements labeled by rem finally we require that either a is a word automaton ie the transitions are labeled by presburger formulas that describe singleton multisets or that for all q if the limit of la q contains an infinite poset then it also contains an infinite poset with the same parikh image as and such that the decomposition of has at most q levels this last condition is satisfied by the automaton in figure and an automaton representing an specification actually the bound q can be replaced by the constant it is satisfied also by an automaton that describes a specification for the an automaton a satisfying all these conditions is called theorem let s be a specification recognized by a multiset automaton a then for every b there exists an effectively computable presburger formula b such that b b proof sketch given a m d and m m we can prove that there exists a maximal set of states such that la to decide if a state q belongs to one has to consider a minimal labeled poset interpreted to q and search for an m completion interpreted to a state in qa it can be proved that if there exists such a completion there also exists one of bounded size let b m d mb and fb ab if fb then b true otherwise we compute a presburger formula that describes the complement of b ie the set of vectors v m n such that v m b by definition b la fb first we prove that fb is the union of q with q fb let be an infinite labeled poset which has an infinite set of increasing prefixes in la fb also let be an infinite sequence of runs in a such that for all i i is a run that i by theorem there exist infinitely many runs j j that end in the same state q fb thus the infinitely many posets j j belong to la q which shows that q next we compute for each q fb a formula q that describes the set of vectors v m n such that v m q if a is a word automaton then q describes the parikh image of all the sequences accepted by a run of a that ends in a cycle on q with at least one transition for each symbol in mb and only transitions labeled by symbols in mb thus q is effectively computable otherwise we enumerate all the runs q q n qn q of a of length at most q for every such run every index i n and every mapping f mb i n we define a run f as follows for each i j n let j be a formula describing the set of all multisets v of symbols from m mb st for every integer l there exists a multiset modeled by j that consists of v at least l symbols m for all m f j and possibly other symbols from mb the run f is obtained from by replacing j with j j for all i j n the models of q are the parikh of all the posets which are recognized by a run f as above to prove that the formula q is effectively computable one can use the same reasoning as in the proof of theorem finally is the disjunction of q with q fb and b ¬ decidability results we give decidability results for the case where the specifications are given by multiset automata and where the optimistic replication system is composed of a fixed number of boolean programs communicating through unbounded unordered channels each boolean program has instructions j that can be used to send a message msg which belongs to a finite set of messages to the site identified by j when a message is sent from a site i to a site j it is put in an unbounded unordered channel from which site j can read by using an instruction i such systems are called finitestate optimistic replication systems in order to define an operational model for finitestate optimistic replication systems we use vector addition systems with states for short formally a v is a tuple q d where q is a finite set of states d n is the number of counter variables in the and q × nd × q is the transition relation the transition system induced by v is defined in the usual way a configuration of v is a pair q v where q q and v nd there is a transition from a configuration q v to a configuration q v iff there exists a transition q u q such that v v u we briefly describe how to model a finitestate optimistic replication system i using a v a configuration of i is composed of two parts the first part is a tuple where each component describes the state of a boolean program the second part is a function describing the content of each channel in v the first part can be encoded in the finite set of states q moreover if msg denotes the set of messages by the sites the content of an unbounded unordered channel ch of an optimistic replication system can be modeled by msg counters ch used to count how many of each kind of messages there are in ch we are given a finitestate optimistic replication system i and a specification s described by a multiset automaton a as a direct consequence of theorem given a m d the set of minimal elements in sa is effectively computable this implies that also the safety monitor can be effectively constructed moreover if v is a modeling i we can construct the parallel composition v of v with we get a on which we can solve the problem of control state reachability in order to know if it is possible to reach the error state of the monitor the bound i for the minimal vectors va used to construct is exponential in a and thus the number of states in and in v is also exponential in a moreover solving reachability in is known to be which leads to the following theorem theorem decidability of safety for a finitestate optimistic replication system i given as a and a specification s described by a multiset automaton the problem of checking the safety of i wrt s is decidable and in the following lemma is used for proving the decidability of both weak eventual consistency and eventual consistency lemma let v q d be a where the states are labeled with atomic propositions coming from a finite set ap let be a presburger formula with d free variables and p ap the problem of checking the ltl formula v ¬ p p pp is decidable and can be reduced to reachability in proof for the formula to be satisfied there must exist an infinite execution in v of the form q v qi vi where the valuation of the counters in vi satisfies for all j i qj is labeled by a proposition in p and for each p p there are infinitely many qj labeled by p first th in and shows that it is possible to compute the minimal elements of the set of configurations up from which there exists an infinite execution only states labeled by a proposition in p and infinitely many states labeled by p for each p p then we construct a presburger formula representing the intersection of and up the problem of checking if there exists a reachable configuration in v satisfying can be reduced to configuration reachability in theorem decidability of weak eventual consistency given a finitestate optimistic replication system i and a specification s described by a multiset automaton the problem of checking the weak eventual consistency of i wrt s is decidable related work our definition of eventual consistency is inspired by the one given in et al but it differs from it on several points in that paper eventual consistency is defined over traces that are also posets of operations but the partial order called session order is defined such that all the operations performed by an user in a session are totally ordered and operations from different sessions are incomparable then a trace is eventually consistent iff there exist two relations over the operations in the trace called and resp visibility relation denoted by ar and resp vis such that the union of vis with the session order is acyclic for every operation o the return value of o is associated by the specification to the pair formed of the poset vis meth and the projection of ar over the operations in ar is a total order and every operation o is not visible only to some finite set of operations ie for every o o o o vis is finite first the partial orders over operations that define a trace have different meanings the operations in a session can be submitted to multiple sites and thus an infinite extension of the execution in fig b where each operation appearing in the figure is executed in a different session is declared to be eventually consistent although the union of vis with the session order is acyclic then the definition of a specification in et al is different because it contains labeled posets augmented with a total order with our understanding of we think that it is not necessary to add such total orders a specification should model only the semantics of the operations and some abstraction of the conflict resolution policy the formalization of the fact that sites will eventually see a consistent state is also different in fact the formalization in et al does not apply to systems that perform speculative executions this is also by the authors intuitively the order in which two operations are executed change once they are visible for example two operations o o with which are instances of the same method must return the same value but for this class of systems it is possible that the order in which the operations in are executed changes in between the execution of o and the execution of o and thus it is possible that the two operations return different values another difference is that in our case the local interpretations may converge toward a partial order over the operations in the trace while in et al they can converge only toward a total order for instance this allows that the sites dont have to agree on the order between two conflicting operations which are commutative there are other works that provide formal definitions for eventual consistency eg but they either consider its weaker form ie consistency or they use a particular model for the in general there exist that guarantee stronger criteria than eventual consistency eg strong eventual consistency or consistency stronger notions for the safety part of eventual consistency eg consistency or session guarantees are formalized in et al by adding more requirements on the session order and the relation vis with slight modifications such requirements can be also added to our definition there are works that define decision procedures for the verification of correctness criteria like sequential consistency or linearizability eg the techniques used in these cases are different from the ones introduced in this paper for eventual consistency in particular because they are defined over finite traces conclusion we provide an algorithmic approach for verifying eventual consistency of our approach is based on reducing the problem of checking eventual consistency to reachability and modelchecking problems this connection is a fundamental result which the to using existing ­ exact or approximate ­ verification tools for programs depending on the considered class of systems for the implementation in the context of verifying our reduction is defined for a general formally defined notion of eventual consistency allowing to reason about a wide class of systems including those using speculative executions and such as or in fact one of the contributions of our paper is to provide such a definition of eventual consistency as well as a new class of automata that is expressive enough to capture usual specifications of distributed data structures and which has the needed properties for use in algorithmic verification we have in addition shown that when implementations are defined as communicating boolean programs through unbounded unordered channels the problem of verifying eventual consistency is decidable as for complexity our algorithm for checking the safety part of eventual consistency is in but the problem is it is at least as hard as state reachability in therefore an interesting question is whether it is possible to match the two bounds in this case for the general case of eventual consistency with liveness we know that the problem is also and that it can be solved using configuration reachability in which is decidable but with an unknown then an interesting question is whether configuration reachability in is needed we believe that this is the case references r k l and d modelchecking of correctness conditions for concurrent objects inf comput ­ l jm j m m shapiro p and g a semantic platform for application development in france am and m a formal model for eventual consistency semantics in pages ­ a and p constrained properties systems and petri nets in concur pages ­ a m c and j verifying concurrent programs against sequential specifications in esop s a and h yang understanding eventual consistency technical report microsoft research g d m g a a s p and w highly available store in a and p monitoring atomicity in concurrent programs in cav pages ­ springer a d gupta v n a and a a data services in pages ­ s and n a conjecture and the feasibility of consistent available web services ­ t a henzinger s qadeer and s k rajamani verifying sequential consistency on multiprocessor systems in cav volume of lncs pages ­ m and n the art of multiprocessor programming m and j m linearizability a correctness condition for concurrent objects acm trans program lang syst ­ j h m l s g d a m r n and m j scale and performance in a distributed file system acm trans comput syst ­ p r johnson and r h thomas the of duplicate databases technical report request for comments information sciences institute january am a i t m shapiro and p the approach to the of divergent in pages ­ w m j m and d g dont for eventual scalable consistency for storage with in pages ­ j x m shapiro and p a semantically rich approach for model edition in pages ­ y and m shapiro optimistic replication acm comput ­ m shapiro n c and m a study of and commutative replicated data types de rr inria jan m shapiro n m c and m replicated data types in pages ­ o task scheduling for parallel systems d b m m k a j demers m j and c h update conflicts in a weakly connected replicated storage system syst rev ­ dec r and m the of vector sets with applications to decidability problems in petri nets inf ­ 