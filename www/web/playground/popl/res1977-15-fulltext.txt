generalized left corner parsing alan cornell j demers university n y introduction br formalizes the notion that parsing methods can be classified by the positions at which production rules are recognized in an ll parser each rule is recognized at the left end before the rules yield has been read in an lr parser a rule is recognized at its right end after its yield has been read and in an lc parser a rule is recognized after the yield of its left corner has been read we generalize on these techniques by allowing the user to specify arbitrarily for each production rule the position at which that rule is to be recognized the resulting or generalized left corner technique includes the lr ll lc and methods as special cases it also allows for less conventional parsing strategies such as grammar splitting k with certain com grammars parsed topdown and the others parsed bottomup as suggested in au this paper is organized as follows in section we give some necessary background and notation section defines parsing a canonical parsing technique can be defined analogous to the lrk technique however the resulting parsers tend to be large attention we therefore to the restrict or simple our generalized left corner parsing technique which is analogous to the tech rithm parsing of d we give for the construction of tables and prove that an the resulting parser is correct in section we develop potentially useful properties some of parsers we show that there is a welldefined each production leftmost position at which rule can be recognized and that a minimal left corner parser can be constructed which each rule as early as possible we derive a simple expression relating the size number of states of an parser to the size of the corresponding parser if g is not then the minimal parser is the smallest parser for g in this class while the parser is the largest in section we ex end the techniques of to give an on to test whether a grammar with no left recursion is and if so to compute its minimal left background in this section we review some basic facts about contextfree grammars and languages let z be a finite alphabet then i denotes strings the set of all k over and z denotes the set of all strings w e z we write of length for and kw to mean the first if or w itself at most k the length k s if iw t k for of w of w a grammar a g where n and z are finite disjoint nonterminal and terminal alphabets respectively is the start symbol and p is a finite set of production rules of the form aa where a e n and a e a and a are respectively the left and right parts of the production we are from to p so it makes sense to talk about the ith production of g we to the conventions that a abc denote b abc denote c denote d denote e denote f e denotes the nonterminals terminals symbols in strings in strings in empty string z if a is in p then for any a and y in we write and say directly derives g the relations and derives g ly are the reflexive and derives nontrivial and transitive and the transitive closure of ly we omit the subscript or when no confusion respective g and write should result a si is the string lg set of a is a form the language all terminal generated if by g forms of g ie w s z i sw for any x e following sets we define the kw i kw i and w i and lx y for some al i as a relation with iff we can define as usual note that ax and ax ax y i for some a let l and l be subsets k of z then we define i and more complete descriptions above functions may be found in au of the for example parsing in this section we introduce the notion of a generalized left corner parser we give an algorithm for of a simple generalized left corner parser which is analogous to the of d and we prove that the resulting parser is correct finally we give a simple space optimization which can be per formed automatically as the parser is generated to specify position recognized based on grammar follows parsing requires the for each production at which that rule is our formalism for the output simulated of br and is defined ability rule the to be this is input as definition let be a cfg a recognition rule based on go grammar where a n i is the set of recognition symbols n and r are disjoint b p is defined by p contains let aa then p o production e be the contains of the for each en ith production exactly one form in with corner u is or leading its called part of the left the nothing else is in p informally based on g production gives some and g a recognition rule grammar is constructed by inserting into the right part of the for the next lemma between go ith lemma above definition let go and then g be as in the for any a b c ox d x proof obvious when parsing bottomup one can interpret reduction by e as that the ith rule has been recognized br has shown that a grammar g is if and only if it is lrk after recognition rules have been added at the left end of all productions he gives analogous results for lc and grammars lc and parsers recognize the left corner of each rule bottomup then parse the remainder of the rule topdown a parser operates in the same way parsing each rule bottomup until the recognition symbol is reached then the remainder of the rule onto the stack and parsing it topdown definition let an a generalized with lookahead be left corner parser for g is a triple a is a finite set containing distinguished of and ox for each x which states states occurs qs in the part of some rule of g b action is a function mapping into u the set i i c goto maps into a a parser maintains a states which it according to algorithm below a configuration of a parser is a pair w where is the contents of the stk with the top at the right and w is the remaining input algorithm parsing let the initial configuration where w is the input be to be recognized repeatedly perform of the following steps is applicable until the stack is empty or an error action is encountered let the current con be q and let a if then pop qm and from the stack b if action then read the first symbol a of x and push onto the stack c suppose action i let xr be the ith tion followed order accept reaches the its stack pop states then push by q xl in that if and only if end of the input the parser and the relations are defined way and on configurations by this algorithm in the usual note that states of the predictive in the sense that erased of the thus of an at the top of the stack only by remaining input which the state behaves much ll parser form qx are once qx ap it can be some prefix is in lx like a state example let g be the whose productions are t tf t f f a table in the first machine parser figure few enters for g is the configurations on input given in the figure also gives which the a a we is similar thus we next give an algorithm for con a parser our algorithm to the method of d call it the method while it is possible to give a full parser construction algorithm analogous to the lrk method which result are likely to be large thus we have chosen a but more practical method which is the parsers less powerful as with rithm identifies set of items the lrk method a parser state defined as follows our a definition of one of the a item following forms is an object a production where is a b x or x occurs in the production where xs or x part of some we next define closure and transition operations on sets of items again in complete analogy with the method definition the closure smallest set such that if let q be a set of c denoted cq of items containing or b is of items is the q and in and production then cy for each definition it is of the least one symbol the basis of a of all essential proper item set an item is essential form x or it has to the left of the set q of items is the items in q if q at dot set items definition let o be a set of let e nu then we define a x i b note that we extend way goto to strings in the obvious ax the analogous definition for function leads to we do not define if the goto so with the developed we an parser machinery which we have just can describe the states of quite as follows definition or states states of the for form the set of g is the set of xu where all xs or x occurs in the z part of some production x and the state where no confusion should result abbreviate c x as we defined the states we now the action function a action function using simple look of length k in the method simple are calculated using follow sets the calculation of simple also uses follow sets however for technical reasons having to do with left recursion we must introduce a second type of follow set which considers only the occurrences of a symbol in the part of some production of x if definition let the such that there x be any symbol follow is the set of exists a derivation and all intuitively consists of those strings of at most can follow an occurrence part in some k terminals of x in a form which definition items function for any let q be a set of k the action is defined by a if q with and or q contains a and b action aa with i if q c x and if q contains d if none error of ac apply is undefined then or if more action a conflict than one of ac function is said or the set q is on lookahead applies the to be said to contain u a terminal symbol to the right of the dot in some item produces a shift action and a recognition symbol to of the dot produces an action while a nonterminal to the right of the dot does not produce any action directly thus terminals and recognition are called action symbols note however that a nonterminal to the right of a dot does cause by closure have actions additional and these defined items to additional on them be added items may definition grammar function for the is consistent g is said if the states to be an action of g an inconsistent action function defines a nondeterministic machine in the obvious way in fact the nondeterministic machines for g all recognize exactly lg in the next ew lemmas we establish this fact the correctness of the parser if the parser is consistent lemma let the machine for g let be x and y be strings in z and then a if where q then xx and b if where qx then xx the sequences assumed never of moves to empty in a and b are the stack proof number the proof is by induction of moves of m on the basis one move a the move must be either which case or some production x in which shift case in some b a state qx cannot in a single move so the basis is true inductive step a if more than one step is required then x n and q must be pushed onto the stack by an i action for some i let the ith production be x ys the sequence of moves must be qx l qq y f where the i action by qr from the definitions is performed of the action function q must contain the item ay rl yl from the of the goto function definition thus for by the inductive hypothesis a for by inductive and hypothesis the result b follows b by definition an item in of the must goto have function some suffix of a to the left action cause qx to be of the in such removed dot thus an z state cannot from the stack and qx must be removed by a pop action the only successor of qx with a pop action defined is thus where f the inductive thesis applies to the sequence i to yield as desired then lemma a let let xx m be as let in lemma such that and let q and q be states that q then such b let xx let such that and let q and qx be states then with proof the proof is similar of lemma and is omitted to the proof theorem machine the nondeterministic for g lg proof immediate from lemmas and corollary if for g has no conflicts the then it parser is correct proof the parser machine is a we end this section simple space optimization performed on an by presenting which can parser a be definition parser for g is parser x by deleting for all the single state the constructed from states of the x and replacing where the form them by uc z k goto q pop theorem the is consistent lg let g be then parser for g and exactly proof the proof is straightforward and example states which figure were used gives the to construct the parser of example properties of grammars in this section we present some results on the behavior of grammars and parsers when the lengths of left are changed in we show that for each production there is a welldefined shortest left corner which can be used in a consistent parser and that this shortest left corner is independent of the left chosen for the other productions for the special case of grammars without left recursion we show that a minimal left corner parser constructed using the shortest possible left is guaranteed to be the smallest parser in the class first notation we develop definition let binary operations on the productions min of some useful go be a cfg and max are based the defined on go that is min chooses tion of the recognition chooses the rightmost extend min and max that based on go the leftmost symbol and max position we to grammars production is if g and g are then the productions of ming g are where p and p are the ith productions of g and g respectively defined analogously g q g iff iff finally is we define g g the set of all go clearly forms a lattice based on a given with min as the greatest lower bound operator and max as least upper bound the top element of the lattice has symbols at the right ends of its productions the bottom element has the recognition sym at the left ends we shall show that the set of for go is closed under min and max and forms a sub lattice in fact prove the slightly stronger result for any g and g based on hence we that go a if g and g are is then b if g is and g g then g is once this result follows that the go form a has been established based which contains it on being unique go is a finite minimum lattice the it also has bottom minimal left a unless corner or grammar for go in which the recognition symbols left as possible are as far to the to prove these claims it is sufficient to restrict our attention to tions in which a single recognition symbol is moved one position to the left or right if g g then we can transform g to g or vice versa by a finite sequence of transformations of this simple type throughout this section we let be a cfg and g be some based on go definition we define hi to be the function which moves the ith recognition symbol one position to the left in productions of an based on go ie h cy cy for any other production the function hi can be applied to items and sets of items in almost the obvious way the only difficulty we in applying hi to the item is here not dot the obvious result is a item since the symbol appears to the left of the thus we define x if the ith production of g down if the recognition appears at the left end of the then of course hi is not defined is a that whenever it is defined hi is one note and thus has a welldefined also that hi and h commute inverse if ij we denote by gi the which results from applying hi to all the productions of g function it is we also subscript the name of or relation by i to indicate to be computed with respect to a that gi thus means the closure of q with respect to g while means the closure is to be taken with respect to gi the following two technical characterize the interactions hi and closure functions lemmas between the lemma ti in let be the ith prog and let yx be a symbol then a xx xx b ay xy ay xx proof straightforward lemma let q be any proper set of ms for g let be the ith production of g then a b c d e f proof a this follows since hi leaves items of the form y and y unchanged and does not change the number of symbols to the left of the dot in other items b similar to a c by part a and by the definitions of basis and closure we know that now consider a closure item of such an item is of the c form d where and by part a hi is in this item the dot clearly has c at the right of by lemma thus h dd d similar e as desired to c with e immediate from lemma a f immediate from e the next lemma is an important it describes how states change going from g to gi the following function is useful for description one in that definition let q be a proper items for g then we define iq set lemma let machines g and m and mi with have states z q q and resp let the then ith production of g be a any yx and c y any a for b for any and any q fl c rx u such that proof we prove part c first so it may in the proof of a and b c note q contains the right is a subset that if then an item with of the dot of q now x immediately thus by lemma e to x cl x xl thus xl and the result follows ab these on the length string a are proved by of the shortest induction accessing basis for part a part b is true r inductive step let for some state r of mi and some by the inductive hypothesis ro q or consider case we show for some state q of m each case separately we r c iq for some state q in that r iq where q m clearly since r iq substituting the of goto and oi we get r by lemma c r now by lemma b r iq as desired case let q be any state of m containing state must exist clearly such a since x appears to the right of the dot cq u x thus by e x by lemma b q lj x where the last step x follows because applying to both sides we get as desired next we show that if gi is then the conditions a and b in can be to equality preliminary lemma is required lemma one lemma let g be with parser m and let q be some state of m if q contains an item then no symbol in lx appears immediately to the of the dot in any item of q right proof we assume the lemma is false and me a contradiction thus we suppose some symbol in ax occurs immediately to the right of the dot in some item of q without loss of generality we may assume the symbol is an action symbol since for any y there is an action symbol in there are three cases to consider case the symbol is az clearly thus q has a on lookahead the hypothesis that a g is to i case the symbol is since adjacent to f in a can form there exists some thus q has an j conflict on lookahead a again ing the of g case the symbol is f itself case ae and thus xn in this let q be any parser state in which an x occurs immediately to the right of the dot in some item clearly such a state must exist and it must contain the item a now consider the shortest derivation of a terminal string from x clearly this derivation cannot make use of production i since x occurs in the right part of that production thus there is some other action symbol besides f in ax there are two sub cases case and clearly some and thus q has an j conflict on lookahead a a contradiction case q has a a and a as in thus i conflict thus in every the lemma is of the is proved case the false leads condition assumption that to a violation and the when lemma exactly characterizes of the machine for the states for g the following the states gi in terms of lemma let g and gi have machines m and mi with state sets and respectively consistent then the and suppose that m is ie that states of mi are proof the proof is an induction to the proof of lemma b and the basis is identical similar c induction and some hypothesis step let for some state r of mi z nz by the inductive for some state q of m or there are several cases case and by lemma the item c and d that is iq since r contains lemma no symbol by in ax appears immediately to the right of the dot in any of r thus since it follows that y ax applying this fact to the above inequality yields since z f clearly x hi never moves t across z and tions goto z and hi commute thus the func thus and qz iq as desired the remaining to this one and reader cases are left are similar to the we are now ready to prove the key lemma for showing that minimal left exist we show that if moving to the left and moving to the left separately preserve then both f and f can be moved and the resulting grammar will still be both lemma let be and then g is also g proof let m mi m and m be the ij machines for g gi gj and respectively productions and let the ith and jth of g be and two applications of lemma show that the states of are of three types a o iq for some state q of m b c we show states that states of as this case the proofs for are left to the type a are the most b and c reader consider a state tr iq inserting definitions for t this simplifies to t jj by lemma c and the fact that commute c q similarly tg note that application of all h actions unchanged except possibly for addition of i on in fol moreover if an i action is introduced then the original set of items must have had some other action defined for every lookahead in a similar argument applies to applications of h both and sq are con since they are s of mi and m respectively j in h r involves and every conflict thus every conflict an j action in his involves an i action since t and t we conclude that the only pos conflicts in t are i and j on some f s between lookahead a in suppose t has such a conflict it is easily shown that r must have a y to the right of the dot in some item and that the unique action of r on lookahead a must be i thus however implies since by lemma b we conclude that and so since appears immediately to the left of x in the ith production and since g is assumed to this violates lemma giving us the desired contradiction and proving the be to show that the on g form a lattice we must also based show closure stronger symbols ness under max to the right we give moving preserves a slightly recognition lemma if gi is then g is proof e this the essential proof of lemma lemma is left to ideas are the the reader contained proof of finally we have reached the theorem closure under min and max based theorem let g and g be on the same underlying cfg then a if g and g are is then b if g g and g is then g is proof ns follow from finitely of lemmas and many corollary has a welldefined every grammar set of minimal left we now consider the relative sizes of parsers we assume all parsers are for without left recursion we can show that if g g then g has a smaller parser than g first and we relate parsers the sizes of lemma let go be and cfg and g be the based top on go in recognition symbols are at the right ends of their productions g is top and top which all extreme then proof it is easily seen that the parser is isomorphic to the parser except for the additional state o each reduce action of the pa is simulated by the parser as an move followed immediately by a now let go be an grammar with no left recursion the following lemma states that the number of states decreases as recognition symbols are moved to the left lemma let g and grammars based on go with be state sets and r respectively production of g be let the ith then where if x occurs part in g o otherwise in some proof which the proof is based says that the states on lemma for g are q c and on the observation one except on states that l is containing direct application of lemma l yields however x is not thus by lemmas d and for any state qz containing a this state but is mapped pop is distinct by oi into x resulting in a reduction of in the number of states finally suppose part of g an additional state a reduction of in x occurs in then cl x again the number of some is not in states repeated lemma yields application of the above theorem grammar based let g be an on a cfg go with no left recursion then lst where s is the number of distinct which occur in productions of g and symbols parts of t is the total length of all the parts of g proof follows and immediately from lemmas thus result in states the minimal the left parser with for go the few efficient testing and unman using techniques for fast composition and transitive closure of sparse rela tions have developed an n algorithm for testing whether a cfg is their algorithm can be used almost un changed to test whether a grammar g is for a particular choice of left in this section we show how their algorithm can be modified to compute the minimal left for a grammar g with no left recursion the algorithms n running time is preserved the basic approach of the testing algorithm is to construct of items which appear together parser state if a conflicting items is generated the algorithm all pairs in some pair of halts that its input is not an grammar the algorithm keeps a queue ready of pairs of items which have been shown to occur together initially ready contains all pairs of distinct items of the form sa the items are processed by the following algorithm while ready do begin remove ij from ready if else begin for each ij then error in end end do here is the set of all pairs of items which can be produced from ij by a single application of the closure or goto operations checks to see whether the pair ij has been encountered before and if not adds it to the ready queue the testing algorithm is somewhat by the fact that the for which pairs of items are being is actually being changed by the algorithm initially all left are empty that is all recognition symbols are at the extreme left ends of their productions when a conflict is encountered the algorithm must try to resolve the conflict by moving some symbol to the right most pairs of items which have already been processed are by this change to the grammar the only exception is that items in which the recognition symbol currently being immediately to the right of the dot must be processed again since they can now give rise to additional items by closure let s be the cfg whose minimal left are to be computed and assume the productions of g have been from to p to moving recognition symbols the algorithm maintains an array the value of gives the current tion of i in the ith production the items used in the items in is they algorithm contain are no recognition symbols the closure and goto operations however must behave as if the recognition symbols were present in the positions specified by the current value of one more data structure which we require is an array of the value of is the set of pairs of items which have already been processed in which appears immediately to the right of the in one of the items when i is to the right the item pairs in are removed and dot moved finally we need a procedure which when given a conflict ing pair of items as input which recognition symbol must be moved to the right to resolve the conflict the complete algorithm follows algorithm computing minimal left a cfg output the length of the each production if array giving minimal left corner for of g or an error go is the method ready x while ready do begin from ready if ij then begin if then error i for each i j in do end else begin for each next to a dot in i or j do add ij to for each ij in do end end the procedures conflict insert and decide are given below gen used the gen function in the testing is the same one algorithm c where c is the set of all such that pairs kl k e ij l comes from step and k l i or j by one closure g is empty unless i and same symbol to the right in which case g j both have of the dot the the conflict function following lemma makes use of the lemma not occur an item of the in any pair form y proof suppose y and occur together in some state then yi and but the only state must occur together in which y occurs is thus ye and contrary to our assumption that gy has no left recursion thus the of the forms only possible a vs b vs cy with conflicts with are of course and cannot be as the positions of f and the of the algorithm to avoid this difficulty we do not compute follow sets for recognition symbols we consider instead positions in g o by straightforward application of the techniques of we can compute for each position p in go and the relation fl n simply position r such that iff both of these can be computed in steps at any time during of the algorithm is where p is the current of f the insert procedure following definition is based on the definition two items if i and j are a i and j correspond of go and to the same item b i has a recognition to the right and only if j does symbol of the dot if items behave in algorithm for this reason after moving it is necessary to only items from all other items are with their old and new positions of following this definition the insert procedure is simply if no has then equivalent been added add ij pair i j to ready to ready note that there are n equivalence classes of item pairs thus insert can be implemented with a matrix of n bits and no more than n pairs of items can be added to the ready queue now only the decide function remains to be developed given conflicting items i and j decide must determine which recognition symbol must be moved to resolve the conflict there are only two types of conflicts which can occur case conflicts let it from lemma applied in reverse that moving some other recognition symbol to the right must leave some pair j of items which is to ij thus the conflict cannot be resolved without moving f and decide can safely return i case conflicts let and conflict on lookahead a as in case the conflict cannot be resolved without moving either i or the question is which one should move suppose a consistent parser can be produced without moving thus f moves right then some state contains and since a there must be some action symbol in ax with an action defined on lookahead a since we assume that moving has resolved all conflicts it follows that ex thus ye and if can remain sta then ae and xy note that the conditions and cannot occur since would imply contrary assumption that g has no left thus decide can return that to our recursion if then i else j the relation ao can be in n steps theorem computes the algorithm correctly minimal left for grammar go a proof the proof is a fairly forward formalization of he discussion and is omitted conclusions a new formal parsing algorithm the algorithm has been described parsing shares most of the of parsing including applicability to a large class of grammars and ease of testing for grammars without left recursion parsers are guaranteed to be smaller than the corresponding parsers references a t syntactic analysis of lrk languages phd thesis computing university of upon au av aho and jd unman the theory of parsing and prenticehall nj b bm deterministic translation grammars phd thesis center for research in computing technology university c ye simple left corner grammars pro princeton conference on information science and systems d fl simple lrk grammars cacm hb iii tg and jd u operations on sparse relations and efficient algorithms for grammar problems proc k aj a practical method for constructing lrk processors cacm rl dj and pm lewis deterministic left corner parsing proc q q qq q q q q q action a e i pop pop s s q s pop pop pop pop pop go to a t q q q q q q stack qo a a aa aa aa aa a a action ann shift pop ann shift pop ann figure parser qo to r tf t f f t f a q t q tf q q f f t fa q q a q pop figure item sets 