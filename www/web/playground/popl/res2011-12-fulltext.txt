a typed translation for general references pottier inria abstract we present a translation of system f with general references into an extension of system f with certain wellbehaved recursive kinds this seems to be the first typepreserving translation for general references it can be viewed as a purely syntactic account of a possible worlds model categories and subject descriptors d programming languages language constructs and storage management f logics and meanings of programs studies of program structure general terms languages theory introduction motivation building a semantic model of a programming language amounts to translating it into some mathematical metalanguage an important constraint in the design of such an interpretation is that it must explain that is translate away computational effects such as nontermination and state which do not exist in mathematics nontermination is often handled using the tools of domain theory which was created for this purpose state is usually dealt with in the style of by making the store explicit and interpreting commands as functions that map stores to stores another important consideration is that the model should exploit the type discipline of the programming language this enables it to serve as a tool in establishing type soundness and in proving typed contextual equivalence laws as a result of these considerations building a semantic model of a rich programming language can be a challenging task it is common among compiler writers that when one is with a complex translation task one should decompose it into a of independent phases connected via chosen intermediate languages in this paper we study one instance where this might be applicable in the construction of a semantic model we focus on a particular programming language namely a version of system f equipped with general references and on a particular aspect of its semantics namely the transformation whose purpose is to explain translate away references we this transformation just as if it were a phase in a compiler and present it as a translation of our typed imperative source language into a typed purely functional intermediate language permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm in so doing we move the frontier between syntax and semantics we suggest that a model of the imperative source language might be obtained through the composition of the transformation with a model of the purely functional intermediate language this makes the construction of the model more modular and may help explain it to researchers who are familiar with syntactic techniques this also extends the family of known typepreserving transformations to the best of our knowledge until now it was an open question how to define a typepreserving translation for general references which intermediate language in this an important part of the difficulty is to find out what the typed intermediate language should be and to keep it minimal it would be nice if it could be a calculus such as system f or f however these calculi are strongly normalizing whereas our source language is not general references allow recursion through the store thus one more is needed in order to find out what this should be let us first review some of the semantic models of general references possible worlds models a reference is a memory cell whose value can be read and modified at any time we consider general references which means that a reference can hold a value of any type including a function or the address of some other reference furthermore we are interested in weak references that is we are interested in a type discipline updates are deallocation is forbidden and aliasing is permitted the presence of references a interpretation of types as sets of values a sentence such as the address is an integer reference does not make sense on its own it implicitly relies on the assumption that the address is currently allocated that some integer value is currently stored there and on the knowledge that these facts will continue to hold in the future to reflect this several semantic models of weak references in the literature follow the possible worlds approach there the interpretation of a type is parameterized over a world which represents the current state of the store worlds are equipped with a partial ordering w w means that w is a possible future world of w that is every address that is allocated in w is also allocated in w with the same type bounded universal quantification over worlds is used to express the idea that a value that is valid now is also valid in every possible future world bounded existential quantification is used to express the idea that a command has the effect of transforming the current world into some possible future world at the of these possible worlds models of general references is a circularity as stated above semantic types are they are parameterized over a world however worlds too must be they must describe the store now and in every possible future one way of achieving this is to define a world as a map of memory addresses to semantic types this makes the definitions of worlds and semantic types mutually recursive and creates a need to either solve a recursive domain equation world world or work with approximate solutions of it an alternative is to define a world as a map of mem addresses to syntactic types then the circularity appears when worlds and types must be interpreted as semantic objects and again a recursive domain equation must be solved a calculus with recursive kinds in this paper we are not in in solving or recursive domain equations our purpose is to argue that a certain syntactic program mation namely a translation produces welltyped terms from the possible worlds models we wish to and to quantify types over worlds thus we need worlds to be types of a particular kind that is world should be a kind because we need world world we should look for an intermediate calculus that supports recursive kinds this is the key that was to above should we propose an extension of f with arbitrary kinds such a system would have tation at the type level that rather do we need non terminating computation at the type level yes we do wish to allow certain forms of nonterminating computation at the type level be cause we find it natural to view a recursive type as a term whose infinite reduction produces in the limit an infinite tree this is a form of nonterminating but computation is there a way of ensuring that every typelevel computation is in such a sense yes for instance presents a type system that recursion so as to guarantee computation this system has recursive types but re every cycle in the type structure to cross a later modality written · we reuse this system at the kind level therefore terms and types become our types and kinds by system we rule out certain recursive kinds for instance the recursive equation world world is in fact invalid because it does not involve the modality fortunately the modified equation world · world is permitted and still our purposes this equation states that a world is a contractive function it is able to produce some output independently of its argument this intuitively seems to correspond to the fact that if one attempts to describe the shape of the store one will be able to provide a nonempty prefix of a description before one a to the shape of the store for instance one might say the store currently contains one cell which contains one function whose argument must be a store that is a possible future of the current store the techniques of birkedal et al and of et al as for the present work so it is no that there is a close analogy between these becomes the · modality as the fixed point of a con map lemma becomes a recursive definition that happens to be permitted in system the fact that world composition is associative lemma becomes an assertion about the equality of two trees and can be automatically checked § in recent work in part by an earlier version of the present paper birkedal et al construct a metric model of a version of system this gives to the between · provides the basis for is presented here whether and how this model can be exploited in useful ways remains to be determined contributions the contributions of this paper are i the design of fork an extension of system f with wellbehaved re · · · · · · figure fork properties of the relation k k k k k k k k k figure fork kind assignment kinds ii a typepreserving encoding of general references into this calculus paper outline we first recall system § and build upon it in the definition of fork § then we explain how a version of system f equipped with general references can be encoded into fork we prove that the encoding is typepreserving and § a prototype implementation of a fork typechecker the complete source code for the encoding of references as well as the proof of semantic preservation are available online some proofs are omitted and can be found in the extended version of this paper system we now recall the definition and properties of system our version of the system is close to it is slightly simplified in that it is restricted to finite types without distinction between and finite types and as a result it does not have a type despite this difference we refer to it as system there are two levels in system which are usually referred to as types and terms types and terms are the kinds and types of fork respectively so this is how we refer to them kinds the kinds are defined as follows · a kind is a possibly infinite tree in the prototype implementation kinds are finitely represented via a set of mutually recursive defining equations thus only regular kinds can be defined a kind is wellformed iff every infinite path through a · constructor infinitely often a kind is finite iff every infinite path through enters the domain of an arrow infinitely often we restrict our attention to kinds that are wellformed and finite the condition is used in the proof of lemma where it serves to rule out types that produce an infinite stream of s and therefore do not have a head normal form in the implementation this requirement is enforced by checking that every occurrence of a kind name in the righthand side of its defining equations lies under a · constructor and in the domain of an arrow more precisely we prove that the encoding preserves convergence and sketch how one might prove that it also preserves divergence kinds come with a relation we omit its definition which is somewhat technical the reader is referred to and is irrelevant as long as the following properties hold the relation is reflexive transitive and satisfies the laws in figure where means that the relation holds in both directions the relation satisfies the following inversion lemma lemma if both and holds hold then for some n n we write for n applications of · to when kinds are finitely represented as a set of mutually recursive defining tions it is decidable whether two kinds and are in the relation in fact it is possible to decide whether there exists n n such that holds and to compute the least such n when one exists the prototype implementation takes advantage of this fact to perform bottomup kind synthesis types types are pure terms we write when reduces to reduction is permitted under arbitrary contexts a kind environment k is a sequence of bindings of the form the judgement k means that within such an environment k the type has kind the rules that define it figure are standard recursion the judgement y · where y is fixed point combinator x x xf x x is derivable the variable x receives the recursive kind · we introduce the notation µ as syntactic sugar for y this gives rise to the derived reduction rule µ µ and to the derived kind assignment rule k · k µ the prototype implementation has builtin support for recursive type definitions based on the above rules in fact it supports mutually recursive type definitions properties the system the following and subject reduction properties lemma k implies · k · lemma k and imply k a type of the form m n is a head normal form types are solvable they admit head normal forms lemma if k then has a head normal form it is worth noting that this holds under any environment k that is in the presence of type variables of arbitrary kind together lemmas and imply that every type admits a maximal tree that is one that does not contain any occurrence of the undefined tree these two lemmas have been checked by the author using the coq proof assistant type equality we take type equality a relation between types to be tree equivalence up to § several alternative of this relation are known it is the greatest consistent theory it coincides with the equational theory of d model it is the greatest compatible relation that is it coincides with the observational congruence obtained by observing we write when and are in the type equality relation in this paper this relation is used only when both k and k hold for some environment k and kind this has the following consequence lemma the relation restricted to types is proof we outline a simple this maintains a conjunction g of goals where a goal is an equation between two head normal forms the free variables of a goal are implicitly viewed as universally quantified a goal g can be decomposed into a conjunction of written g as per the following equations a case applies only if no prior case applies we write for the principal head normal form of is is is is is true is false if if we write g for the conjunction of obtained by applying · to every goal in g consider the problem of deciding whether holds enumerate the potentially infinite sequence defined by g and gk gk if some gk is found to be empty report yes if some gk is found to be false report no if holds then this reports no if holds and and have a finite tree then it reports yes if holds and and have an infinite tree then the diverges in the prototype implementation this is improved in two ways first gk is defined as gk jk gj that is any goal that has already appeared during an earlier step is considered valid goals are compared up to renaming of their free variables second an equation of the form where one of the two sides is not a head normal form is decomposed into this is done in addition to the default behavior which is to reduce both sides to head normal form before them this can have the effect of replacing a difficult goal which would lead the into a sequence of goals with a conjunction of simpler goals that the is able to prove the thus improved remains sound indeed when it succeeds the set of goals that have been examined forms an bisimulation up to and up to context as studied by which implies that these goals are valid the remains incomplete but is strong enough to prove all of the equations required by the encoding presented in § why do we require types to be if we were to remove this condition every type would be permitted still the fact that is a consistent theory would be sufficient to prove that fork is typesafe § however type equality would then become undecidable and as a result typechecking would become undecidable as well this would make it more difficult to build welltyped fork terms as we do in § if we do that types are on the other hand then every type is solvable and as a result type equality and typechecking are a valuable property another potential reason why kinds should be wellformed and types should be is that these conditions make it possible to interpret kinds in a category of spaces and to interpret types as of kinds in the style of birkedal et al · t x xt t t t t let x x t in t t t pack t as x t in t x see § see § type constants functions unit pairs figure fork kinds types terms k k · · k · · k k figure fork kind assignment constants var x x abs x t xt app t t t t unit intro t t t t t x x t let x x t in t intro t t t t intro t pack t as t x t x t in t conversion t t figure fork type assignment fork in system f a system of simple finite kinds is used to classify types in fork instead system is used as a result fork is an extension of f fork type safety but strong normalization kinds and types kinds and types figure are as presented previously § except a number of type constants are introduced as is standard in f these constants are assigned kinds by the axioms in figure xt t x tt let x x t t in t x t x tt t t x pack t as in t x tt ct ct if t t figure fork reduction semantics it may come as a that the function and product type constructors have kind · · as opposed to in f this means that these constructors are contractive in both arguments an intuitive reason why they should be viewed as contractive is precisely that they are type constructors as opposed to type operators they produce syntax for instance an application of the function type constructor to two arbitrary types and yields a type that is welldefined down to depth it has an arrow at its root regardless of how and might behave the fork axioms are more than their f counterparts and so for instance the former allow the recursive type µ to have kind while the latter would make this type naturally the encoding of general references into fork § relies on the existence of such recursive types because the function and product type constructors have kind · · one cannot expect the types that classify values to always have kind as in f instead in fork the types that classify values have kind for some n n we write k when k holds for some n n the universal and existential type constructors and are not considered contractive because the types that classify values can have kind for any n n it is natural for these two constants to admit every kind of the form as opposed to just in f the properties stated in the previous section § remain valid in the presence of type constants of arbitrary kind type assignment the syntax of terms t and type environments is standard figure a type environment can play the role of a kind environment k the type assignment judgement t is defined in figure the typing rules are identical to their f counterparts up to a few details which we now discuss the type conversion rule conversion relies on the notion of type equality that was defined earlier § the types that classify values have kind this is reflected in the following definition and lemma definition the empty type environment is wellformed the type environment is wellformed if is wellformed and the type environment x is wellformed if is wellformed and lemma if is wellformed then t implies in the following we restrict our attention to wellformed type environments the type application rule states that a universally quantified variable of kind can be instantiated with a type of kind the rule intro is similarly relaxed this makes sense thanks to the following type substitution lemma which is later exploited in the proof of subject reduction c x e e e e i s e xe e x ee i e e ei ce ce if e e s s e s s e if e e s s bind e e s e e s e return e s s e e s s new e s e s return where s s s read s s s if s s s write e s e s return if s figure system f untyped reduction semantics lemma let if is wellformed then is wellformed furthermore t implies t it is possible to give a syntaxdirected presentation of the type system where the conversion rule is merged with the other rules this allows typechecking to be performed in a standard bottomup fashion that is provided every bound variable carries an explicit kind and every bound variable carries an explicit type the knowledge of and t is sufficient to a type if one exists such that t holds the prototype implementation of fork follows this scheme type soundness fork is equipped with a standard reduction semantics figure reduction is permitted under an arbitrary context values are defined as follows v xt v v v pack v as the system the following properties lemma subject reduction t and t t imply t definition a term t is welltyped iff t holds where binds only type variables no term variables lemma progress a welltyped term either reduces or is a value theorem type soundness a welltyped term either diverges or reduces in zero or more steps to a value encoding general references into fork the source calculus the source language of the encoding is a monadic presentation of system f with general references it is due to peyton jones and wadler § the terms are the standard terms of system f extended with the monadic constants return and bind with the constants new read and write for allocating reading and writing references and with memory locations which we take to be natural numbers e x xe e e e e t e e i e return bind new read write e x t e x t e x t e t e xe t t e e t t e e e e t e t e e t e e t e e t e e t tt e f intro e e t e e t e e e t t f e e t t e i e ti e return m e bind m m m e new m ref e read ref m e write ref m figure system f typing rules the types are t t t t t t m t ref t where m is the monad the definition of the typing judgement e e t appears in figure this definition concerns programs whose execution has not and hence that do not contain memory locations a definition of the encoding of locations is needed only as part of the semantics preservation argument § the operational semantics is defined for terms that is terms where the type abstraction and type application constructs have been erased the semantics which appears in figure is organized in two layers following moggi and first simplification of terms is defined it is the compatible closure of reduction then reduction of configurations is defined where a configuration is a triple of a store s an evaluation stack s and a term e which represents a computation that is it has a type of the form m t because memory locations are natural numbers a store is just a list of terms we write nil for the empty store we write s for the length of the store s we write s for the term found in the store s at location we write s e for the extension or update of the store s at location with the term e an evaluation stack is just a list of suspended applications of bind in the following we present an encoding of this calculus into fork we begin with a series of definitions of fork kinds types and terms whose wellformedness has been by the prototype implementation of fork then we define the encoding § and § a typedirected transformation of the source calculus into fork finally we prove that the encoding is typepreserving § and § fragments in order to typecheck the store which is basically a sequence of values we need sequences of base types where a base type is a type of kind because the store grows with time we often use kind fragment type fragment tail tail type fragment fragment fragment f f tail f f tail type fragment fragment f data tail f data tail figure fragments type array · fragment type index · fragment · term array empty array term array extend f data array f data array f data term array read f data array f index f data data term array write f data array f index f data data array f term array end index f array f data index f data data term index monotonic f f data index f data index f f data figure arrays such a sequence to describe only part of the store and multiple such sequences to obtain a description of the complete store for this reason we refer to such a sequence as a fragment because we intend to types over fragments to quantify over fragments etc fragments must be types of a suitable kind and the basic operations over fragments must be type operators this is done as follows figure the kind fragment is the empty fragment is the identity function fragment concatenation is function composition it is easy to check with respect to type equality that is a left unit and right unit for and that is associative the extension of a fragment f with a base type data written f data or more f data is tail f data tail the type data tail is the application of the product type constructor figure to the base types data and tail arrays we wish to represent the store as an array thus fork must support arrays we need heterogeneous arrays it must be permitted for different array elements to have different types we need safe arrays array accesses must be statically forbidden as puts it it is to specify what happens when we read a cell something that can never occur in we need extensible arrays there must be a way of creating a new array by a new cell at the end of an existing array and any valid index into the earlier array must remain a valid index into the new array the signature in figure these requirements it introduces a of abstract type constructors for arrays and indices as well as a number of operations over arrays the type array f describes a heterogeneous array whose elements are described by the fragment f the type index f data represents the address of a cell of base type data within an array of type array f the type operators array and index are contractive as far as the user of the array abstraction is concerned they can be thought of as type constructors kind world · world fragment type nil world x type o world world world w w x w w o x w x figure worlds the zero length array array empty is described by the fragment array extension array extend is described using the fragment extension operation reading and writing are permitted by array read and array write writing is the old and new array elements both have type data the operation array end index returns the end index of an array of type array f it is not a valid index into this array but becomes a valid index once the array is extended with a new cell this is expressed by the type data index f data data the operation index monotonic witnesses the fact that a valid index into a smaller array is also a valid index into a larger array this is expressed in terms of fragment concatenation this operation is a coercion its semantics is the identity there are two ways of making the types and operations described by this signature available in fork the first way which we follow is to implement this signature this can be done by representing array data as a list that is as a sequence of nested pairs and by representing an array index as a pair of functions for reading and writing at this index the read function for instance a sequence of pair projections the code is about a lines it does not use any recursion it is in fact expressed within f this implementation of arrays shows that in principle it is not necessary to extend fork with primitive arrays it is of course inefficient reading and writing have linear time complexity the second way would be to extend fork with primitive arrays that is to consider the signature of figure as a set of axioms to extend the operational semantics of fork with new reduction rules for arrays and to extend its type soundness proof this would allow a more efficient implementation of array access although efficiency seems of little concern here worlds our arrays are extensible in width this helps us model dynamic allocation that is the fact that the store grows with time there remains to model higherorder store that is the fact that the store can contain references and functions whose type in the encoding depends on the shape of the store this dependency means that as the store grows in width the type of an existing store cell we say that the store also grows in depth an example may help illustrate this consider the ml program let x ref xx in let x ref in x xx when the reference cell x is first allocated it contains a function that has type int int however x is later updated with a function that has type int int only under a store where the cell x exists and holds an integer value thus the type of the contents of the cell x with time in order to reflect this we introduce worlds figure a world is an description of a store fragment more precisely a world is a fragment that is itself parameterized over a world the kind world is recursive it is wellformed because the recursion goes through the later constructor · a world is a contractive function of a world it produces some structure before it uses its argument the empty world nil is the constant function that returns the empty fragment world composition w o w can be described as kind · world type box a x y a x o y type unit x type pair a b x a x b x type univ body x a body a x type arrow a b x box a x box b x type monad a x store x outcome a x type outcome a x y box a x o y store x o y type store · world x y array x y type ref a x y index x y a x o y figure semantic types the result of extending w in depth and in width with w naturally its definition is recursive we the reader to check that it is welltyped in system using the derived kind assignment rule for recursive type definitions the empty world nil is a left unit and right unit for world composition furthermore world composition is associative this fact is fortunately the for type equality § proves it and others like it without in the following by convention the variable w has kind world while the variables x and y have kind · world semantic types a type in the source language is translated to a semantic type that is a contractive function of worlds to base types figure let a be a semantic type and x be a world a value v of type a x is valid now in world x is it valid also in every future world that is is it the case that v also has type a x o y for every y in general there is no guarantee that this is so where we need this to be the case we are explicit about this requirement and use a value of type box a x where the semantic type operator box builds in a universal quantification over future worlds this operator is known as the modality a semantic type of the form box a is known as necessary or hereditary remark there are semantic models see eg where is built into the world equation so that the analogue of every type is hereditary here this is not the case fork does not have a monotonic arrow at the kind level so there seems to be no way of building into worlds we follow appel et al and et al and explicitly use the box modality to keep track of which types are hereditary it is worth noting that bounded quantification over all future worlds z that is z x is expressed here in terms of ordinary quantification over a world extension y that is y z x o y in this encoding the associativity of world composition expresses the transitivity of the world ordering a hereditary value is valid in every future world hence is hereditary in every future world this is expressed by defining a coercion forward of type a x y box a x box a x o y the encoding of unit pairs and quantifiers is straightforward the world parameter x is just passed down the encoding of arrows states that functions require a hereditary argument and produce a hereditary result this is expressed by the type box a x box b x remark the reader might have expected instead the type box x a x b x which guarantees that the function itself is hereditary this type is more general than box a x box b x however this choice would cause a difficulty in the construction of certain functions such as new figure there we must be able to argue that the argument v is hereditary because this value will be written into the store and the store holds hereditary values if v has type box a x the argument is trivial whereas if it has type a x it is not clear that v is hereditary our current choice on the other hand does not seem to cause any difficulty it leads to a style where every variable in the type environment has a boxed type see definition and every expression has a boxed type see the statement of theorem in short the fact that the encoding t of a type t is not always hereditary does not us we use explicit boxes where needed another would be to set things up so that the encoding t of every type t is a hereditary semantic type one would then build this information into the translation via coercions one abstracts over a semantic type variable a one would also abstract over a coercion of type x a x box a x it seems that this would succeed it could be investigated as part of future work the encoding of the monad is standard a computation requires a store in world x and produces a pair of a hereditary result and a new store in some future world x o y we use the abbreviation outcome a x for the type of such a pair a store in world w contains values that are valid in world w and in future worlds that is a store is an array of hereditary values this is expressed by defining store w as x array w x in other words a store is of course of fixed width but is polymorphic in depth a reference of type ref a in world x is roughly speaking an index that allows reading or writing data of type a x within an array of type store x more precisely universal quantification over a world extension y is again used to guarantee that references are hereditary by direct to index monotonic it is possible to define a coercion box ref of type a x ref a x box ref a x we have the encoding of every type constructor of the source language thus any type t is translated to a semantic type t the inductive definition of this translation cannot be expressed within fork definition the encoding t of a type t is defined as follows unit t t arrow t t t t pair t t t univ t m t monad t ref t ref t where the combinators that appear in the righthand sides of these equations are defined in figure memory allocation when a new reference is allocated the width of the array that represents the store is increased by one if the allocation takes place in world x and if the newly created reference is initialized with a value v of type box a x what is the new world after allocation this new world must be the composition of x and of a world of width one which we refer to as a cell that is the new world must be x o cell a x for an appropriate definition of cell an operator that maps a and x to a world type cell · world world a x y tail a x o cell a x o y tail term store extend x a store x box a x store x o cell a x term store end index x a store x ref a x o cell a x figure memory allocation the definition of cell appears in figure as above the parameter x represents the world before allocation or a past world the parameter y represents a depth extension or a future world while tail represents a width extension the type cell a x y tail a type of kind is a product of the types a and tail this is consistent with our definition of fragment extension in figure the semantic type a is applied to the composite world x o cell a x o y the manner in which the final world is obtained starting in world x first a memory cell is allocated then the world is extended with y thus the definition of cell is recursive it is worth noting that a value v of type box a x also has every type of the form a x o cell a x o y simply because the latter is a polymorphic instance of the former thus the value that is used to initialize the cell is indeed a suitable value for the cell in every future world y how do we that this definition of cell is right the proof is in the fact that the terms store extend and store end index which respectively construct the new store and the address of the new reference have the types shown in figure the definitions of these terms are a lines each up to a number of suitable type abstractions and applications store extend is just array extend while store end index is just array end index encoding the monadic constants all of the infrastructure is now in place we are in a position to encode the constants return bind new read and write to do so we must define five terms that admit the types shown in figure and that implement the machinery we present and explain only the definitions of the term new figure the definitions of return bind read and write are omitted and can be found online we believe that the definition of new is representative so that the reader who has studied it could if he or she so the other definitions as an exercise the structure of the definition of new is in large part imposed by its type by definition of box univ arrow and monad figure the desired type for new box univ a a arrow monad ref a nil is equal to x a box a x y store x o y outcome ref a x o y thus the definition of new begins with abstractions over a world x a semantic type a a value v of type box a x a world y and a store s of type store xy the type xy is defined on the as a local abbreviation for x o y it might seem that we must abstract over two successive world extensions x and y this is required by the monadic structure of the source language the world x corresponds to the point in time where ref is applied to a value v while the world x o y corresponds to the point in time where the computation ref v is run after accepting these parameters new must produce a result of type outcome ref a xy by definition of outcome figure this is equal to z box ref a xy o z store xy o z term return box univ a a arrow monad a nil term bind box univ a univ b monad a pair a arrow monad b arrow monad b nil term new box univ a a arrow monad ref a nil term read box univ a ref a arrow monad a nil term write box univ a ref a pair a arrow monad unit nil figure encoding the monadic constants declarations term new box univ a a arrow monad ref a nil x a v box a x y type xy x o y in s store xy type c cell a xy in pack c box ref a xy o c store end index xy a s store extend xy a s forward a x y v as outcome ref a xy figure encoding the monadic constants definition of new this type is existentially quantified over a world extension z which represents the new storage allocated by the computation here this new storage is a single cell which holds a value of semantic type a so according to our earlier discussion § the concrete witness for z should be cell a xy thus c is defined as a local abbreviation for cell a xy and the construct pack c as outcome ref a xy is used in order to build an existential package inside this package should be a pair of a newly allocated memory location at type box ref a xy o c and an extended store at type store xy o c the next available memory location is obtained by applying store end index figure to suitable type arguments and to the current store s this application has type ref a xy o c this is what was required except a leading box is missing we must justify that this memory location is valid not only now but also in the future this is achieved via an application of the coercion box ref which was mentioned earlier § it seems that the new store should be obtained by applying store extend figure to the current store s and to the initial value v of the newly allocated cell however there is a slight difficulty s and v do not the same world indeed s has type store x o y while v has type box a x thus before store extend can be applied the value v must be moved from the world x into the world x o y fortunately v is hereditary so this is easily achieved by applying the coercion forward § the definition of new is somewhat complex due to the many type annotations however by all type abstractions applications and abbreviations as well as all coercion applications one finds that new is just end index s store extend s v thus it is easy to informally that the untyped translation that our encoding is indeed a standard translation a formal argument of semantics preservation appears further on § e x t e x yx we o y t e x t e t t e xe t t e e t t t e e e e e t nil t t t t e e t t e e y y t ee t t e e t yt y t tt e y encode intro e e t t e e t t e e e yt y t y t t encode ee t t t e i e x x t y in xi ti figure system f encoding pure fragment encoding terms we have defined the encoding of the five monadic constants there remains to encode the pure fragment of the source language that is the terms of system f the encoding is typedirected it takes the form of an encoding judgement e e t t which the system f typing judgement that is e e t holds iff e e t t holds for a certain t the definition of this judgement appears in figure over pure terms the encoding is essentially the identity it introduces type abstractions and applications in order to introduce andor eliminate the box modality type preservation the following definition and theorem state precisely in what way the encoding is typepreserving definition with each variable x we associate a world variable wx then with a system f type environment e we associate a world we as follows w nil we we we o wx the encoding e of a type environment e is given by e e e x t e wx world x box t every abstraction x in the source program gives rise to a sequence of two abstractions of the form in the translated program this accounts for the fact that the world at the time a function is defined and the world at the time this function is applied are distinct the latter is in general an extension of the former the parameter wx represents this extension theorem type preservation e e t t implies e t box t we proof in this proof we do not consider the cases of the constants return bind new read and write which have been there remains one case for each of the rules in figure case by hypothesis under the environment e x t e x has type box t by definition of box this is y t o y thus the type application x we o y has type t o we o y that is t e o y thus the term yx we o y has type y t e o y that is box t e case by the induction hypothesis under the environment e x t the term t has type box t that is under the type environment e wx world x box t we o wx the term t has type box t we o wx there follows that the term has type t we o wx box t we o wx by definition of the encoding and by definition of box this type is box t t we case by the induction hypothesis under the type environment e the term t has type box t t we and the term t has type box t we by definition of box and by definition of the encoding the former of these types is t we o wx box t we o wx as a result the application t nil has type box t we box t we and the application t nil t has type box t we case by the induction hypothesis under the type environment e the term t has type box t we thus the term y y has type y t we o y by definition of univ this type is t we o y that is by definition of box box univ t we that is by definition of the encoding box t we case by the induction hypothesis under the type environment e the term t has type box t we as we saw in the previous case this type is y t we o y thus the term yt y t has type y t t we o y because the encoding of types is compositional ie with type substitution this type is y tt we o y that is by definition of box box tt we cases encode intro encode left to the reader semantics preservation the encoding is this is true even in the absence of a hypothesis this is not surprising one might be to say that the encoding is obviously a translation and that a translation is obviously nevertheless it is worth checking this fact the results presented in this section have been using coq the development can be found online because the rules and in figure encode type abstractions and type applications in terms of type abstractions and type applications it is possible to define an untyped version of the encoding which transforms untyped terms into untyped terms this untyped encoding is a function in the following we write e for an untyped term of the source calculus and we write e for its untyped encoding it is easy to check by of figure that the untyped encoding function is the identity over the pure fragment of system f as an immediate corollary every simplification step in the source calculus is simulated by one reduction step in the target calculus lemma e e implies e e we now wish to prove an analogous simulation diagram about the reduction of configurations this requires defining the encoding of a memory location the encoding of a store the encoding of an evaluation stack and the encoding of a configuration these somewhat technical definitions are omitted but can be found online it is then a matter of routine to check that one step of reduction in the source calculus is simulated by one or more steps of reduction in the target calculus this is stated as follows in order to allow for some in the reductions the encoding of configurations is a relation rather than a function we write s s e t to indicate that the term t is an encoding of the configuration s s e then we have lemma simulation for a closed configuration s s e the following diagram holds s s e s s e t t it is worth noting that in order to establish t t we exploit the fact that reduction of fork terms is permitted under arbitrary contexts we use this flexibility in particular to perform reduction inside the components of a pair as an immediate consequence we find that convergence is preserved by the encoding lemma convergence let e be a closed term of the source calculus if the start configuration nil e reduces in many steps to some configuration of the form s return e then the term e nil reduces in many steps to the pair e s proving that divergence is also preserved by the encoding is more difficult of course by lemma the existence of an infinite reduction sequence out of the start configuration nil e implies the existence of an infinite reduction sequence out of its encoding e nil however this is not the desired property because reduction of fork terms is permitted under arbitrary contexts the relation is nondeterministic and the existence of an infinite reduction sequence is not an appropriate definition of divergence instead we would like to consider that the term e nil diverges if and only if it does not have a head normal form an analogous arises in the source calculus where simplification is permitted under arbitrary contexts here is an informal sketch of how this problem might be solved in each of the source and target calculi define notions of standard that is leftmost and internal reduction prove that divergence that is the absence of a head normal form is equivalent to the existence of an infinite standard reduction sequence in the target calculus prove that standard reduction and internal reduction commute proves these facts in the pure calculus then refine lemma by showing that one standard reduction step in the source calculus is simulated by a of at least one standard reduction step and an arbitrary number of internal reduction steps in the target calculus use this fact together with the property that standard reduction and internal reduction commute to conclude that if a source configuration admits an infinite standard reduction sequence then so does its encoding we have not yet to this development related work several translations have appeared in the literature state monad relies on a fixed store type it does not support dynamic memory allocation monads allow the type of the store to vary with time and can be used to model systems of strong references with memory allocation and deallocation similarly hoare type theory extends type theory with a monad that is indexed with pre and postconditions p x aq is the type of computations that expect a store in state p and produce a value x of type a together with a new store in state q hoare type theory is very expressive yet does not support weak references ohearn and reynolds translate two variations of algol into a purely functional calculus with polymorphic and linear types and compose this translation with a model of the target calculus to obtain models of the source languages and pottier translate an expressive calculus which supports strong references into a purely functional calculus pottier extends and work with an rule that allows weak references to be defined in terms of strong references however it is not clear how and translation could be extended to support the rule to the best of our knowledge no typed translation for weak references has appeared in the literature the syntactic approach to type soundness deals with weak references via store types which map memory addresses to types the store type grows with time this is part of the statement of subject reduction and simultaneously describes the current store as well as all future stores this is probably the simplest approach to type soundness for general references however it does not suggest how to design a typepreserving translation fork is an ad hoc extension of system f that allows nonterminating yet computation at the type level and as a result is able to express rich recursive types far beyond the view of recursive types as regular trees that is commonly encountered in simpler type systems there exist other calculi that permit computation at the type level and come to mind perhaps these calculi could serve as target languages for a typepreserving translation of general references directions for future work in this paper we have equipped the source and target calculi with pairs is it possible to both calculi with sums and extend the definition of the encoding we believe so up to a technical difficulty in the definition of the encoding we have exploited the of box with respect to pairs that is a polymorphic pair can be transformed into a pair whose components are polymorphic the term that performs this transformation can be defined in system f and a in fork up to type erasure it is the identity if the calculi were extended with sums then analogously we would need a coercion that transforms a polymorphic sum into a sum whose are polymorphic unfortunately such a coercion cannot be defined it seems in system f instead it must be added as an axiom and one must move to a version of fork equipped with subtyping in the style of system f the typed translation that we have presented is not fully abstract there are terms that the encoding of a source type but do not encode any source term in particular there is it is permitted to duplicate or discard the store following ohearn and reynolds one could fork with linear types and refine the translation so as to encode the fact that the store is treated linearly one might then hope to prove that the refined translation is fully abstract and prove such a result for a translation that deals with local state their translation is simpler than the one considered here as they fix the type of the store all locations have the same in the absence of group regions in the source calculus and translation is typepreserving in a strong sense when the source calculus has group regions however their translation is typepreserving only in a weaker sense it uses map lookup and map update operations whose success is guaranteed by the type system of the source calculus but not by the type system of the target calculus the success of these operations depends on the fact that the population of a group region can only grow with time thus achieving type preservation in a strong sense might require a possible worlds machinery as in the present paper type and all locations are considered allocated they initially hold a default value in this paper only a limited study of fork has been carried out we have established its type soundness with respect to an operational semantics to go further we suggest building semantic models of fork perhaps by following birkedal et al and determining whether useful models of system f with general references can in fact be obtained by composition with the translation presented in this paper acknowledgments i wish to thank birkedal jan and yang for and discussions references integrating and dependent types in workshop on and recursion in interactive theorem provers par july ahmed semantics of types for mutable state phd thesis princeton university and dependent types without the sugar in functional and logic programming volume of lecture notes in computer science pages ­ springer april m and luca cardelli subtyping recursive types acm transactions on programming languages and systems ­ september andrew w appel christopher d and a very modal model of a modern major general type system in acm symposium on principles of programming languages popl pages ­ january robert notions of computation journal of functional programming p barendregt the lambda calculus its syntax and semantics science birkedal jan and a metric model of lambda calculus with guarded recursion presented at july birkedal and the solution of recursive technical report it university of copenhagen birkedal and realizability semantics of parametric polymorphism general references and recursive types mathematical structures in computer science to appear michael and coinductive axiomatization of recursive type equality and subtyping ­ and pottier functional translation of a calculus of capabilities in acm international conference on functional programming icfp pages ­ september robert harper a simplified account of polymorphic references information processing letters ­ robert and andrew w appel a theory of indirection via approximation in acm symposium on principles of programming languages popl january b bisimulation in untyped lambda calculus trees and bisimulation up to context in mathematical foundations of programming semantics volume of electronic notes in theoretical computer science pages ­ science april paul possible world semantics for general storage in callbyvalue in computer science logic volume of lecture notes in computer science springer john c mitchell polymorphic type inference and containment information and computation moggi notions of computation and monads information and computation moggi and an abstract monadic semantics for value recursion et applications ­ and full abstraction in a metalanguage for state in workshop on syntax and semantics of low level languages july a modality for recursion in ieee symposium on logic in computer science lics pages ­ june fixedpoint logic with the approximation modality and its kripke completeness in international symposium on theoretical aspects of computer software volume of lecture notes in computer science pages ­ springer october greg morrisett and birkedal hoare type theory polymorphism and separation journal of functional programming ­ peter w ohearn and john c reynolds from algol to polymorphic linear lambdacalculus journal of the acm ­ simon peyton jones and philip wadler imperative functional programming in acm symposium on principles of programming languages popl pages ­ january pottier hiding local state in direct style a higherorder rule in ieee symposium on logic in computer science lics pages ­ june pottier a formalization of type system http october pottier the electronic fork july http pottier a typed translation for general references extended version november jan birkedal and yang nested hoare triples and frame rules for higherorder store in computer science logic volume of lecture notes in computer science pages ­ springer september jan yang birkedal pottier and a semantic foundation for hidden state in international conference on foundations of software science and computation structures volume of lecture notes in computer science pages ­ springer march christopher fundamental concepts in programming languages higherorder and symbolic computation april parallel reductions in calculus information and computation ­ april robert d and abstract models of storage higherorder and symbolic computation ­ andrew k wright and matthias felleisen a syntactic approach to type soundness information and computation ­ november 