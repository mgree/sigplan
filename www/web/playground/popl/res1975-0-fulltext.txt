application of lattice algebra to loop optimization john and department of princeton university princeton nj jeffrey engineering uu unman introduction has recently developed lattice theoretic techniques for solving many data flow analysis problems it is the purpose of this paper to demonstrate that many of the loop optimization such as code motion and induction variables detection can be done efficiently and in great generality by essentially the same lattice theoretic techniques we shall program being ment the flow use the graph usual model for a to code improve g ne no where mation at information this idea as developed the entry of a region at the nodes of the can be generalized to by to the region lattices we shall of use the ideas following formulation definition work is a data flow a pair d lf analysis where frame i l is a semilattice with meet a and zero element q satisfying the bounded ness condition xl x x x implies n nk n is a set of nodes e is a set and no c n is the initial of there is a path from n to each node in n the nodes code represent there straight is an edge line from blocks of nl to n if can execution immediately of the follow program n in a possible the notion may be modeled of a loop by a in a flow graph r which with is a set of nodes n and edges e a header node nl having the property that node every path in r passes from the through initial nl node various to a loop optimization motion or eg make techniques induction such variables use of functions as code see relating work supported by nsf grant gj where yz is shorthand for ya z y and yz means yz and yz ii f is a set of functions from l to l morphisms on l closed under and meet having an identity denoted by e and satisfying the distributivity condition vf ay fx a fy iii for each xc l there such that x f exists f ef intuitively the lattice elements represent information which might be known about data at to some block of a flow graph and f represents the set of transformations on this information that could be by portions of a program basic passes blocks through in particular it in the as control case of loop optimization we shall be interested in functions relating information at the entry of a region to that at each node of the region these functions follows for each region in r define the function for all x in l may be defined as r and each node f such rn that n f p where the meet is taken over all paths p r from the the function header f of r to associated the exit of n with a path p is the composition of the functions which reflect the actions of the nodes on the path in in certain cases an efficient thm can be obtained to compute associated with various regions graph is parsed or interval the issues which we must consider the of our the functions as a flow analyzed to approach are how can morphisms be represented so that their important operations composition and meet f a g is defined by f fx can be performed efficiently under what conditions are the functions associated with regions efficiently computable are there frameworks that meet the re of and and have practical applications we shall in the following turn to each sections of these issues in section ii we shall discuss ex of representations of functions in section iii we shall give the outline of an efficient algorithm to compute these functions and discuss the conditions under which the techniques in the algorithm may be applied section iv concludes the paper by giving some practical applications of this approach representing functions for the kinds of lattices l and sets of f on l considered most representation of the functions appears to be feasible of the morphisms in fact the repre in each case a to the representation of a pair of elements of l but we cannot prove a general result of this nature the most the literature is common case considered on global flow analysis the use of bit vectors in here l is the set of bit vectors of some fixed length a is and and the elements of f are functions which deal with the components of bit vectors uniformly and in dependently in this case each f in f can be represented as a pair of bit vectors a and b where fx ax x examples where this approach has been used are the gen and kill representation of r or the dual assumptions approach of for a second example in the structured partition lattice is described for common subexpression detection a relatively efficient representation of structured partitions in terms of value numbers was given in the repre is equivalent to the dag intro in we shall show that the dag provides a natural generalization to repre of morphisms on structured partitions definition let a be a finite a xl xk set of variables let il x a let c be an infinite set of constants let o be a finite set of binary operators a structured partition with respect dag g to is a finite directed acyclic graph set of nodes v a set of edges e with two functions with together a label v set of finite g subsets of o pg o where b is the of base nodes set satisfying the following conditions no symbol or constant is in the two sets labelling two nodes of the dag each i c appears in the label of exactly one base node if v is a base node contains either one e e or c c but not both any number of symbols one constant it may contain in a intuitively if the dag represents symbols represent on entry to region r and symbols represent final values node n for example the function associated with the block a on abc bad acl would be represented by the dag of fig fig it is clear from the above example that structured partition dags representing functions associated with straight line blocks can be obtained in routine fashion composition of functions can also be performed the following manner on these dags in a let fl and f be the functions with the paths pi and p respectively let g and g be the corresponding ff path final is the consisting values function associated with of p followed by p of gl s a become the hence values of g in the composite g representing f fl to create g from and g nodes of g are linked with base nodes of g by identifying each g symbol x of g with the corresponding symbol of g the two nodes are and are resulting the final into one node and the symbols x deleted from the label of the node since the x of g is now value and the of g is now the initial illustrate value for f o f the operation an example will and g together are shown shows the with the in fig resulting a a d ab a ec required a dag node while fig b g b az ci ad e a a i e b fig a binary operation be defined to reflect on functions on the must the meet operation definition let g ve be an with respect label to g ve is a of g if includes nodes of all g base e and for all v cv label v v v for example of g in fig g is a b m g c g fig definition let gg be two with respect to there is the nodes is isomorphic a correspondence v of g and the to g if between nodes w of g such that for all vc v if gv v is a base node iff w is a base node and label v label w and g if v w are not base nodes then v op w and the left and right sons of v are in correspondence with the left and right sons of w let gl and g be two repre f and f then fl a f is repre by the maximal g which is isomorphic to a of g and a sub of g the definition of isomorphism can easily be executed the commutativity of we do not do so here to take into certain operators but it should be clear that the meet of is effectively computable the following algorithm constructs the meet of two gl and g wrt in an efficient manner first we need the definition rank of a of the definition the rank of a base node is o the rank of an interior maximum rank among its sons node is the plus the rank of an g denoted is the maximum rank of its nodes let compute v and gl and w be the g whose set of nodes meet we want of to initialization consider base nodes that unique assign integers to operators for each operator o c o there integer associated with it in o such is a let a x x xk there are k base nodes on gl and on g each has label containing remaining constants constants ad base let which g nodes c c appear have c be in one while the labels containing the finite set of the labels of such define that a linear i for order all on u c ij li jk c i for all i for all c c if c is less than for all cl c represent each base variable or constant its label sort the base representation according order sort the base node in g by the contained in nodes on this to the linear nodes of g in the same manner obtaining the merge pairs the two sorted of base nodes lists v cv tion wi c w which have the same let the total m o number of these pairs be construct m o base nodes for g such that if vw are the pairs obtained from the o merge then for all label ui label wi we assume c it this will constants that has an ordering be the are computer defined case for representable on any if v v o and u u are the mo ww sorted lists o of nodes described above define num vi i wi i and num ui i induction we now nodes constructing present the algorithm in order of increasing the g as it which rank goes con initialize increment rank consider nodes of rank r let vr be the set of nodes rank r define wr similarly of gl of if either v r then r stop assume vr and wr o for each node v in vr form the component key where k n n z are all k is op v nl where v v v respectively the integer vi are the left associated with n v and right sons of similarly for each node w in wr form the three component key sort vr and wr separately in the same fashion on the three com obtaining key merge the pairs r which have the two sorted lists of nodes vi exactly the same key ev r let the number of these pairs be mr if m r o then stop assume m let r be the create pairs nodes obtained from the ur uu un merge on r g such that the left and u i are the nodes on left and right sons of right sons corresponding of each to the v i also wi ie the number assigned to the corresponding nodes are the same for all op ui i m r op vi op wi ui label vi g wi let v r vm w and r r number the nodes in v of g r vi total i number w and u such that such that r similarly r wi i total total ui im m r total i go to step by using a bucket sort the meet of two may be obtained in time pro to the total number of nodes in the two the algorithm can be easily modified to accommodate a definition of isomorphism taking into account the commutative laws of certain operators iii functions efficiently in efficient compute regions constituent algorithm this section we shall outline an algorithm adapted from to functions for larger in terms of the functions for the regions and discuss the con under which the techniques in the is applicable the idea is to construct a rooted ordered tree representing each region leaf representing a node in the region with the following properties and i each interior node has two or three sons except that a two node tree is ii all paths from a node to its leaves have the same length the edges of the tree will be labelled by a function if the tree it represents can be computed by will be region r following the so that then path f rn from the leaf n to the root and composing the functions labelling the edges of that path function first a basic manipulation of edge labels is given in the next lemma and in fig we refer to it as an edge of et and t tk be nodes of a tree and a if the label of these edges are changed to those in fig b then the same fr n as before is computed for all the leaves of the tree algorithm initialization for a single shown in the node fig initial regions n construct consisting the tree as of fn f a fig to k app of suppose region rl created by an application that is is of t from region el consists of and those edges of the original flow b graph represented by the edge eliminated fig note identity calculation that function of loop representing followed an edge with label e the has no effect on the f when the path rn from the node n to the root is the algorithm consists of three parts one for initialization ie the tion of trees for regions consisting of a single basic constructed block the by applications second of for regions t and t where t t are transformations on flow graphs in tl is the tion of an edge from a node to itself is the merging of n and n into a single node where n is the unique predecessor of n and n is not the initial node we say n is consumed by n we assume ie under the t that a that the flow it can become transformations of reductions graph is re a single node and by tl and are available that this arbitrary algorithm framework class to it should will but not only be defined be work for on a re subsequently an a f l i times create the by the following steps tree for region ri create a new node r whose son is the root label edge r of rr the tree by f for r strip the edge rr delete r and the edge rr the root for ri r is app c let r by t from regions be the region nl el nl let f a fn with ri f formed and r create the following steps tree for region r by the create a new node r whose son is the root r of label the edge the tree for rr r strip the edge r r delete r and the edge rr merge the resulting tree with root r and the tree for region r the re tree is the tree for region r the algorithm is rather but is identical in spirit of we omit the details that the necessary and sufficient tion for the above algorithm to work is for the meet of the functions associated with all paths in r from its header to a node n in r to be equal to the meet of the functions associated with a particular re set of paths this restricted set consists of those paths which include at most one back this condition is equivalent to f in turn of we can to the easily simpler show the condition condition by in its turn is implied fx g ax which is the condition shown in to be necessary and sufficient for the depth first search technique of to be to a data flow analysis framework does not imply however the reader may easily structured partition dag satisfy condition check that the of section ii does we can also show that the tion of kl a fi io is sufficient for a straightforward general of the algorithm described above to work this algorithm requires composition and meet operations on an n node flow graph as does the algorithm above it should be noted that con are not sufficient by themselves to guarantee that any algorithm for comput ing morphisms will converge the problem is that must be replaced by a uniform would be no limit on around a loop needed its final value its argument condition the number else there of passes for a function to for every value of iv some app a invariant computations ment a b c is invariant b nor c change inside the loop of regions each path inside the from the header to the assignment b and c unchanged if the region to have some back then efficient to move the computation to just before the header an neither in terms region must leave happens it is a b c one easy way to detect many loop in variant computations is to use a lattice of bit vectors with one position for each variable the bit for a variable is to be at a point if and only if no path in the region from the header to the point sets the variable meet is logical and and the associated with a b e c sets the bit for a to o and leaves others unchanged a more sophisticated approach is use the structured partition representation described in section ii this approach enables us to compute for each region r and node n in r to is a dag including a structure in fig we could detect such that as the b is one b fig invariant bit vector at the entry to n although approach would not do so the b induction variables induction variable x at r is one for which every intuitively an a node n in region path in r from the header to the exit of n adds the same loop invariant increment to x alter successive values of x at n form an arithmetic within the region as long r if for as we all nodes n in r which are predecessors of the header of back x is an induction variable at n with the same increment then x is these an induction variables variable we wish of r it to identify is but the more general search for induction vari ables at individual nodes n seems to be the most efficient to our goal we can again use the structured par lattice to compute a dag represent ing for identify induction variety of rules each r and variables depending n we may then at n by a on how much algebraic manipulation we are to perform the basic strategy is to look for variables x such that f nq indicates that x is by a each time through n an example is fig a where x for a more subtle example consider fig b suppose y is an in variable of the region r we can only tell this by considering y at all the nodes then since x has a value which is a linear function of an induction variable namely y it can be shown to assume an arithmetic at n f i a fig b c typ e discover dependency another interesting application of these techniques is to detect the self dependency of a variable we shall discuss one tion where this idea has used lattice identifier types in lattice elements are is useful techniques setl ill sets of to discover here the types which variables could sets of types assume and the meet functions is union of associated with blocks reflect types which syntactic rules of certain may be made from setl unfortunately the lattice bounded in of all sets of for example the fig x the types piece infinite is of not flow set of types integer of set of set of or set integers of integers or or set t x i fig the approach taken in is to limit the depth of nesting of set of or tuple of to three dont know anything more complex ie the lattice is we can avoid any a priori bound on the depth of nesting of type descriptors if we detect those variables whose type depends non trivially on itself around a loop by non trivially we mean that a set ing operation is involved in the formula that relates the type after traversing the loop to the type before the loop if we detect only these variables and we can do so using a variety of techniques then we can give each of these variables the type around the loop before applying global propagation techniques as does in this way the still not tion but there graph thus to work even though his speaking not satisfied lattice of types will a bound for every flow technique made condition is strictly we can represent functions on types by a notation similar to the dag representation discussed in section ii the symbols and x represent the set of possible types for x at to the region and currently the constants are defined types such as integer or character string the operators if it is setl we are about are set former tuple former and i alternation or union of types for example the dag in fig says that the type of x currently is either x fig a set of whatever types of elements could represent at to the region or a set of elements which are each either of whatever type y could be initially or tuples consisting of an integer and an object of whatever type z was initially the meet operation in this lattice is alternation the reader can easily con struct an algorithm to perform the meet operation on dags by them together with new nodes labeled i the effect of basic blocks on types of variables is as described in it may be easily checked that condition of section iii is if k is the number of variables in order to determine all and only those variables which could assume an in finite set of types when the program was run we would have to concern ourselves with actual values assumed by variables rather than their types alone however we can using the dag representation defined above find a superset of all such namely if r is a region with header n then say x is self dependent if in the dag representing f there is a path from to x which contains the or operator a node labeled by references ga a unified approach to global program optimization proc acm symposium on principles of pro gramming pp october m fi mathematical theory of global prentice optimization hall av aho and jd unman the theory of g translation g ii prentice hall jd fast algorithms for the elimination of common sions acts pp january fe allen control flow analysis sigplan notices pp july j global sion elimination common j and j schwartz languages and their compilers inst new york av aho and jd unman optimization of straight line programs pp siam j march j and jd global problems and iterative al tr computer science lab dept of princeton university nj january ms and jd unman of a simple algorithm for global flow problems principles proc acm symp on of programming languages pp a type determination in very high level languages inst new york av aho hopcroft and jd the design and analysis of com a reading mass ms and jd unman graph pp siam j june schwartz on programming i and ii new york 