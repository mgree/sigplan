nested refinements a logic for typing m jhala university of california san diego abstract programs written in dynamic languages make heavy use of features runtime type tests dictionaries polymorphism and higherorder functions that are beyond the reach of type systems that employ either purely syntactic or purely semantic reasoning we present a core calculus system d that merges these two modes of reasoning into a single powerful mechanism of nested refinement types the typing relation is itself a predicate in the refinement logic system d logical implication and syntactic subtyping to automatically typecheck sophisticated dynamic language programs by nested refinements with theory of finite maps system d can precisely reason about the interaction of higherorder functions polymorphism and dictionaries the addition of type predicates to the refinement logic creates a circularity that leads to unique technical challenges in the metatheory which we solve with a novel approach that we use to prove the soundness of system d categories and subject descriptors f logics and meanings of programs specifying and verifying and reasoning about programs ­ logics of programs general terms languages verification keywords refinement types dynamic languages introduction socalled dynamic languages like javascript python and ruby are popular as they allow developers to quickly put together scripts without having to a static type system however these scripts quickly grow into substantial code bases that would be much easier to maintain and compile if only they could be within a suitable static type system the convenience of dynamic languages comes from their support of features like runtime type testing finite maps ie dictionaries and typing a form of polymorphism where functions operate over any dictionary with the appropriate keys as the empirical study in shows programs written in dynamic languages make heavy use of these features and their safety relies on invariants which can only be established by sophisticated this work was supported by nsf grants and from microsoft research permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm reasoning about the flow of control the runtime types of values and the contents of data structures like dictionaries the following code adapted from the popular javascript framework illustrates common dynamic features let onto callbacks f obj if f null then new callbacks else let cb if tag f str then else f in new cb obj callbacks the function onto is used to register callback functions to be called after the dom and required library modules have finished loading the author of onto to great to make it extremely flexible in the kinds of arguments it takes if the obj parameter is provided but f is not then obj is the function to be called after loading otherwise both f and obj are provided and either a f is a string obj is a dictionary and the function value corresponding to key f in obj is called with obj as a parameter after loading or b f is a function which is called with obj as a parameter after loading to verify the safety of this program and dynamic code in general a type system must reason about dynamic type tests control flow higherorder functions and heterogeneous dictionaries current automatic type systems are not expressive enough to support the full of reasoning required for dynamic languages syntactic systems use advanced typetheoretic constructs like structural types row types intersection types and union types to track invariants of individual values unfortunately such techniques cannot reason about relationships between program variables as is required for example to determine the specific types of the variables f and obj in onto semantic systems like support such reasoning by using logical predicates to describe invariants over program variables unfortunately such systems require a clear syntactic distinction between complex values that are typed with arrows type variables etc and base values that are typed with predicates hence they cannot support the interaction of complex values and dictionaries that is in dynamic code for example in onto which can take as a parameter a dictionary containing a function value our approach we present system d a core calculus that supports fully automatic checking of dynamic idioms in system d all values are described uniformly by formulas drawn from a decidable quantifierfree refinement logic our first key insight is that to reason precisely about complex values eg higherorder functions nested inside structures eg dictionaries we require full dependent type systems like coq can support the necessary reasoning but are not automatic as the programmer must provide explicit proofs to type checking obligations a single new mechanism called nested refinements syntactic types resp the typing relation may be nested as special type terms resp type predicates inside the refinement logic formally the refinement logic is extended with atomic formulas of the form x u where u is a type term read has type is a binary uninterpreted predicate in the refinement logic and where the formula states that the value x has the type described by the term u this unifying insight allows to us to express the invariants in dynamic code like onto including the interaction between higherorder functions and dictionaries while within the boundaries of decidability expressiveness the nested refinement logic underlying system d can express complex invariants between base values and richer values for example we may two predicates tag int tag str to type a value that is either an integer or a string we can then track control flow involving the dynamic type function tag to ensure that the value is safely used at either more specific type to describe values like the argument f of the onto function we can combine predicates with the type predicate we can give f the type null tag str top top where top is an abbreviation for true which is a type that describes all values notice the the types nested within this refinement formula are themselves refinement types our second key insight is that dictionaries are finite maps and so we can precisely type dictionaries with refinement formulas drawn from the decidable theory of finite maps in particular two operators sel x a which corresponds to the contents of the map x at the address a and upd x a v which corresponds to the new map obtained by updating x at the address a with the value v are precisely what we need to describe reads from and updates to dictionaries for example we can write tag y int to type dictionaries that have at least an integer field y where y is a program variable that dynamically stores the key with which to index the dictionary even better since we have nested function types into the refinement logic we can precisely specify for the first time combinations of dictionaries and functions for example we can write the following type for obj str sel f top top to describe the second portion of the onto specification all while within a decidable refinement logic in a similar manner we show how nested refinements support polymorphism datatypes and even a form of bounded quantification subtyping the in expressiveness by nesting types inside refinements is by some unique technical challenges the first challenge is that because we nest complex types eg arrows as uninterpreted terms in the logic subtyping eg between arrows cannot be carried out solely via the usual syntactic decomposition into smt queries a higherorder logic eg would solve this problem but that would algorithmic checking we choose the uninterpreted precisely to the smt solver of higherorder reasoning we this challenge with a novel decomposition mechanism where subtyping between types syntactic type terms and refinement formulas are defined thereby using the logical structure of the refinement formulas to divide the of subtyping between the smt solver for ground predicates eg equality uninterpreted functions arithmetic maps etc and classical syntactic rules for type terms eg arrows type variables datatypes soundness the second challenge is that the between the refinement logic and the type system the standard proof techniques for refinement type soundness in particular we illustrate how uninterpreted type predicates break the usual substitution property and how nesting makes it difficult to define a type system that is welldefined and this property we meet this challenge with a new proof technique we define an infinite family of precise systems and prove soundness of the family of which system d is a member thus establishing the soundness of system d contributions to sum up we make the following contributions · we show how nested refinements over the theory of finite maps encode function polymorphic dictionary and constructed data types within refinements and permit dependent structural subtyping and a form of bounded quantification · we develop a novel algorithmic subtyping mechanism that uses the structure of the refinement formulas to decompose subtyping into a collection of smt and syntactic checks · we illustrate the technical challenges that nesting to the metatheory of system d and present a novel proof technique to establish soundness · we define an algorithmic version of the type system with local type inference that we implement in a prototype checker thus by carefully the between subtyping the nested refinement types of system d enable for the first time the automatic static checking of features found in dynamic code overview we start with a series of examples that give an overview of our approach first we show how by encoding types using logical refinements system d can reason about control flow and relationships between program variables next we demonstrate how nested refinements enable precise reasoning about values of complex types after that we illustrate how system d uses refinements over the theory of finite maps to analyze dictionaries we conclude by showing how these features combine to analyze the sophisticated invariants in dynamic code notation we use the following abbreviations for brevity int x bool x str x x x true int bool str bool x we notation to use the above as abbreviations for refinement types for each of the unary abbreviations t defined above an occurrence without the parameter denotes the refinement type t for example we write int as an abbreviation for tag int recall that function values are also described by refinement formulas containing type predicates we often write arrows outside refinements to abbreviate the following x t t x t t we write t t when the return type t does not refer to x simple refinements to up we show how system d describes all types through refinement formulas and how by using an smt solver to the subtyping implication queries system d makes short work of value and control flowsensitive reasoning adhoc unions our first example illustrates the simplest dynamic idiom programs which operate on adhoc unions the function takes an integer or boolean and returns its negation let x if tag x int then x else not x in system d we can to this function the type which states that the function accepts an integer or boolean argument and returns either an integer or boolean result to establish this system d uses the standard means of reasoning about control flow in systems namely strengthening the environment with the guard predicate when processing the of an and the negation of the guard predicate for the thus in the the environment contains the assumption that int which allows system d to verify that the expression x is welltyped the return value has the type tag int x this type is a subtype of as the smt solver can prove that tag int and x implies tag int tag bool thus the return value of the is to have type on the other hand in the the environment contains the assumption int by combining this with the assumption about the type of input int bool the smt solver can determine that bool this allows our system to type check the call to not bool bool which establishes that the value returned in the else branch has type thus our system determines that both branches return a value of type and thus that meets its specification dependent unions system ds use of refinements and smt solvers enable expressive relational specifications that go beyond previous techniques while takes and returns adhoc unions there is a relationship between its input and output the output is an integer resp boolean iff the input is an integer resp boolean we represent this in system d as x tag that is the refinement for the output states that its tag is the same as the tag of the input this function is checked through exactly the same analysis as before the tag test ensures that the environment in the then resp else branch implies that x and the returned value are both int resp bool that is in both cases the output value has the same tag as the input nested refinements so far we have seen how refinement types where the predicates refine base values can be used to check adhoc unions over base values however a type system for dynamic languages must be able to express invariants about values of base and function types with equal ease we this in system d by adding types resp the typing relation to the refinement logic as nested type terms resp type predicates however nesting raises a rather problem with the typing relation included in the refinement logic subtyping can no longer be carried out entirely via smt implication queries we solve this problem with a new subtyping rule that extracts type terms from refinements to enable syntactic subtyping for nested types consider the function which takes an integer x and a value f which is either null or a function over integers let x f if f null then x else f x in system d we can use a refinement formula that combines a base predicate and a type predicate to assign the type int null int note that we have nested a function type as a term in the refinement logic along with an assertion that a value has this particular function type however to keep checking algorithmic we use a simple firstorder logic in which type terms and predicates are completely uninterpreted that is the types can be thought of as constant terms in the logic therefore we need new machinery to check that actually the above type ie to check that a f is indeed a function when it is applied b it can accept the input x and c it will return an integer type extraction to the above goals we extract the nested function type for f stored in the type environment as follows let be the type environment at the callsite f x for each type term u occurring in we query the smt solver to determine whether f u holds where is the embedding of into the refinement logic where type terms and predicates are treated in a purely uninterpreted way if so we say that u must flow to or just flows to the caller expression f once we have found the type terms that flow to the caller expression we map the uninterpreted type terms to their corresponding type definitions to check the call let us see how this works for the is trivial the assumption that x is an integer in the environment allows us to deduce that the expression x is welltyped and has type int next consider the let u be the type term int int due to the bindings for x and f and the the environment is embedded as int f null f u null hence the smt solver is able to prove that f u this establishes that f is a function on integers and since x is known to be an integer we can verify that the has type int and hence check that meets its specification nested subtyping next consider a client of let at the call to we must show that the are subtypes of the formals ie that the two subtyping relationships int null u hold where u · · · and u x tag while the smt solver can make short work of the first obligation it cannot be used to the second via implication the real types that must be checked for subsumption namely u and u are embedded as totally terms in the refinement logic once again extraction to the we show that all subtyping checks of the form p q can be reduced to a finite number of of the form type p or type predicate x u the former kind of goal has no type predicates and can be directly via smt for the latter we use extraction to find the finitely many type terms ui that flow to x if there are none the check fails for each ui we use syntactic subtyping to verify that the corresponding type is subsumed by the type corresponding to u under in our example the goal reduces to proving either null or u where the former implication contains no type predicates so we attempt to prove it by the smt solver the solver tells us that the query is not valid so we turn to the latter implication the extraction procedure uses the smt solver to deduce that under the type term u flows into thus all that remains is to the definition of u and u and check x tag int int which follows via standard syntactic refinement subtyping thereby checking the clients call thus by carefully interleaving smt implication and syntactic subtyping system d enables for the first time the nesting of rich types within refinements dictionaries next we show how nested refinements allow system d to precisely check programs that manipulate dynamic dictionaries in essence we demonstrate how structural subtyping can be done via nested refinement formulas over the theory of finite maps we introduce two abbreviations for dictionaries f y int str y x y f y u str y sel x y u the second abbreviation states that the type of a field is a syntactic type term u eg an arrow dynamic lookup structural subtyping allows system d to support the common idiom of dynamic field lookup and update where the field name is a value computed at runtime consider the following function let t c if has t c then tc else the function uses the primitive operation has d k str bool true k to check whether the key c exists in t the refinement for the input d expresses the precondition that d is a dictionary while the refinement for the key k expresses the precondition that k is a string the refinement of the output expresses the postcondition that the result is a boolean value which is true if and only if d has a binding for the key k expressed in our refinements using k a predicate in the theory of maps that is true if and only if there is a binding for key k in the map d the dictionary lookup tc is to get t c where the primitive operation get has the type get d str k sel d k and sel d k is an operator in the theory of maps that returns the binding for key k in the map d the refinement for the key k expresses the precondition that it is a string value in the domain of the dictionary d similarly the refinement for the output asserts the postcondition that the value is the same as the contents of the map at the given key the function first tests that the dictionary t has a binding for the key c if so it is read and its contents are converted to an integer using the function of type note that the the environment under which the lookup appears with the fact c ensuring the safety of the lookup if t does not contain the key c the default value is returned both branches are thus verified to have type int so system d verifies that has the type str int dynamic update to allow dynamic updates system d includes a primitive set d k str x top upd d k x that produces a new dictionary where upd d k x is an operator in the theory of maps that denotes d updated or extended with a binding from k to x the following illustrates how the set primitive can be used let t c let t c in let res set t c in res we give the function the type d c str d c f ld c int where d d k a predicate that that d is identical to d at all keys except for those in k the output type of allows system d to conclude that int from the type of set system d res t c sel c which is a subtype of the output type of next consider let d files let d d let system d verifies that d f ld files int d f ld files int f ld int and hence the field return ints that can be safely added type constructors next we use nesting and extraction to system d with data structures thereby allowing for very expressive specifications in general system d supports arbitrary userdefined datatypes but to keep the current discussion simple let us consider a single type constructor for representing unbounded sequences of t values informally an expression of type is either a special null value or a dictionary with a hd key of type t and a tl key of type as for arrows we use the following notation to write list types outside of refinements recursive traversal consider a recursive function that takes a list of arbitrary values and the strings let rec xs if xs null then else let hd in let tl in if tag hd str then tl else if tl null then hd tl else hd we the function the type str str the null test ensures the safety of the hd and tl accesses and the tag test ensures the safety of the string concatenation using the techniques described above nested adhoc unions we can now define adhoc unions over constructed types by simply nesting as a type term in the refinement logic the following illustrates a common python idiom when an argument is either a single value or a list of values let cmd let status cmd in if tag int then not status else not status here and str int the input cmd is a string and is either a single integer or a list of integer failure codes because we nest as a type term in our logic we can use the same kind of type extraction reasoning as we did for to the type str int bool parametric polymorphism similarly we can add parametric polymorphism to system d by simply treating type variables a b etc as uninterpreted type terms in the logic as before we use the following notation to write type variables outside of refinements a a generic containers we can compose the type constructors in the ways we all know and here is list map in system d let rec map f xs if xs null then null else new map f of course pattern matching would improve but we are merely trying to demonstrate how much can be and is achieved with dictionaries by combining extraction with the reasoning used for it is easy to check that map a b ab note that type abstractions are automatically inserted where a function is a polymorphic type predicate functions consider the list filter function let rec filter f xs if xs null then null else if not f then filter f else new filter f in system d we can filter the type a b x a true x b note that the return type of the predicate f tells us what type is satisfied by values x for which f returns true and the return type of filter states that the items filter returns all have the type implied by the predicate f thus the general mechanism of nested refinements subsumes the kind of reasoning performed by specialized techniques like latent predicates bounded quantification nested refinements enable a form of bounded quantification consider the function let dispatch d f df d the function dispatch works for any dictionary d of type a that has a key f bound to a function that maps values of type a to values of type b we can specify this via the dependent signature a b d a f ab b note that there is no need for explicit type bounds all that is required is the conjunction of the appropriate nested refinements all together now with the tools developed in this section system d is now capable of type checking sophisticated code from the the original source code for the following can be found in a technical report unions generic dispatch and polymorphism we now have everything we need to type the motivating example from the introduction onto which combined multiple dynamic idioms dynamic fields and the dependency between nested dictionary functions and their arguments nested refinements let us formalize the flexible interface for onto given in the introduction a callbacks top f null str a top obj a f null top top str f f ld f a top top using reasoning similar to that used in the previous examples system d checks that onto the above type where the specification for obj is enabled by the kind of bounded quantification described earlier reflection finally to round off the overview we present one last example that shows how all the features presented combine to allow system d to statically type programs that on the contents of dictionaries the function shown below is adapted from the python standard let rec x if tag x bool then if x then element true null else element false null else if tag x int then element integer x else if tag x str then element string x else if tag x then let ks keys x in let vs map v and str fun k element key k xk ks in data n vs data else element function null the function takes an arbitrary value and it as an xml string and illustrates several uses of dynamic features if we give the auxiliary function the type int str and element the type str null str str we can verify that top str of interest is the dynamic field lookup xk used in the function passed to map to recursively convert each binding of the dictionary to xml the primitive operation keys has the type keys d list str that is it returns a list of string keys that belong to the input dictionary thus ks has type list str which enables the call to map to typecheck since the body of the argument is checked in an environment where k str which is the type that a is instantiated with this binding suffices to prove the safety of the dynamic field access the control flow reasoning described previously uses the tag tests the other cases to prove each of them safe w x c w w w x e a e cw e w w w w t if w then e else e let x e in e td type t td e lw w f lw p q r p lw lw u p q p q ¬p t p u x t t a ct null s t a s values variable constant dictionary extension function type function constructed data expressions value function application type function application ifthenelse datatype definitions programs logical values value logical function application refinement formulas predicate type predicate logical connective refinement types type terms arrow type variable constructed type null type schemes figure syntax of system d syntax and semantics we begin with the syntax and evaluation semantics of system d figure shows the syntax of values expressions and types values values w include variables constants functions type functions dictionaries and records created by type constructors the set of constants c includes base values like integer boolean and string constants the empty dictionary and null logical values lw are all values and applications of primitive function symbols f such as addition and dictionary selection sel to logical values the constant tag allows on the type tag of a value at runtime for example tag tag int str e e bool fun dictionaries a dictionary w w w extends the dictionary w with the binding from string w to value w for example the dictionary mapping x to and y to true is written x y true the set of constants also includes operations for extending dictionaries and accessing their fields the function get is used to access dictionary fields and is defined get w x wx x get w y wy x wx get w x the function has tests for the presence of a field and is defined has w y wy x has w x wx x has x has w x true false the function set updates the value bound to a key and is defined set d k w d k w expressions the set of expressions e consists of values function applications type instantiations ifthenelse expressions and we use an presentation so that we need only define substitution of values not arbitrary expressions into types types we types into monomorphic types t and polymorphic type schemes a s in system d a type t is a refinement type of the form p where p is a refinement formula and is read such that p the values of this type are all values w such that the formula pw is true what this means formally is core to our approach and will be considered in detail in section refinement formulas the language of refinement formulas includes predicates p such as the equality predicate and dictionary predicates has and sel and the usual logical connectives for example the type of integers is tag int which we abbreviate to int the type of positive integers is tag int and the type of dictionaries with an integer field f is tag f int we refer to the binder in refinement types as the value variable nesting type predicates and terms to express the types of values like functions and dictionaries containing functions system d permits types to be nested within refinement formulas formally the language of refinement formulas includes a form lw u called a type predicate where u is a type term the type term x t t describes values that have a dependent function type ie functions that accept arguments w of type t and return values of type where x is bound in t we write t t when x does not appear in t type terms a b etc correspond to type parameters to polymorphic functions the type term null corresponds to the type of the constant value null the type term ct corresponds to records constructed with the c type constructor instantiated with the sequence of type arguments t for example the type of the integer successor function is x int tag int x dictionaries where the value at key f maps int to int have type tag sel f int int and the constructed record list null can be assigned the type datatype definitions a datatype definition of c defines a named possibly recursive type a datatype definition includes a sequence a of type parameters a with variance annotations a variance annotation is either covariant contravariant or invariant the rest of the definition specifies a sequence f t of field names and their types the types of the fields may refer to the type parameters of the declaration a wellformedness check operational semantics e e if c w is defined c w c w x e w let x w in e a e t e if true then e else e e if false then e else e e e e let x e in e let x e in e figure evaluation semantics of system d which will be described in section ensures that occurrences of type parameters in the field types respect their declared variance annotations by convention we will use the subscript i to index into the sequence a and j for f t for example i refers to the variance annotation of the ith type parameter and fj refers to the name of the jth field programs a program is a sequence of datatype definitions td followed by an expression e requiring all datatype definitions to appear first simplifies the subsequent presentation semantics the smallstep operational semantics of system d is standard for a callbyvalue polymorphic lambda calculus and is shown in figure following standard practice the semantics is parameterized by a function that assigns meaning to primitive functions c including dictionary operations like has get and set because expressions are there is a single congruence rule our implementation more syntax into form type checking in this section we present the system d type system several wellformedness relations an expression typing relation and at the of our approach a novel subtyping relation which obligations involving nested refinements through a combination of syntactic and semantic reasoning we first define environments for type checking environments type environments are of the form x s a p where bindings either record the derived type s for a variable x a type variable a introduced in the scope of a type function or a formula p that is recorded to track the control flow along branches of an a type definition environment records the definition of each constructor type c as type definitions appear at the beginning of a program we assume for clarity that is fixed and globally visible and it from the judgments in the sequel we assume that contains at least the definition type a tl wellformedness figure defines the wellformedness relations wellformed type schemes x fresh x top px p s a s a s wellformed formulas p lw u lw u i lw i p lw p q pq wellformed type terms t x t t x t t a a null u c dom i ti ct wellformed type environments x dom s a x s a p p wellformed type definitions j a tj i i t type t td figure wellformedness for system d formulas types and environments we require that types be wellformed within the current type environment which means that formulas used in types are boolean propositions and mention only variables that are currently in scope by convention we assume that variables used as binders throughout the program are distinct and different from the special value variable which is for types therefore is never bound in when checking the wellformedness of a refinement formula p we substitute a fresh variable x for and check that px is wellformed in the environment extended with x top to the environment where top true we use fresh variables to prevent duplicate bindings of note that the wellformedness of formulas does not depend on type checking all that is needed is the ability to syntactically distinguish between terms and propositions checking that values are wellformed is straightforward the important point is that a variable x may be used only if it is bound in datatype definitions to check that a datatype definition is wellformed we first check that the types of the fields are wellformed in an environment containing the declared type parameters then to enable a sound subtyping rule for constructed types in the sequel we check that the declared variance annotations are within the type definition for this we use a procedure defined in a technical report that recursively formulas to record whether type variables occur in positive or negative positions within the types of the fields expression typing the expression typing judgment e s defined in figure verifies that expression e has type scheme s in environment we the important aspects of the typing rules constants each primitive constant c has a type denoted by that is used by basic values like integers booleans etc are given singleton types stating that their value equals the corresponding constant in the refinement logic for example type checking c e s true true john john false false arithmetic and boolean operations have types that reflect their semantics equality on base values is defined in the standard way while equality on function values is physical equality x t x a s x x x a s w w str w s w w w w w w x int y int int x y not x bool bool x true false x top y top bool true x y w true w bool e s w false if w then e else e s e s fix a a a a tag x top the constant fix is used to encode recursion and the type for the operation uses an function in the logic the operations on dictionaries are given refinement types over theory of arrays extended with a default element which we write as bot that is different from all program values the extended theory is shown to be decidable in t x t e t x e x e x t t w x t t w t w w a a e s a e a s empty has d k str bool true k get d k str sel d k t w a s w t a t set d k str x top upd d k x keys d list str the types above use the constant empty to denote the empty dictionary and the predicate k to abbreviate sel d k bot to relate two dictionaries we use d d k to abbreviate k kk k k sel d k sel d k i ti c af t j wj a t cw t w e ct e t which states that the dictionaries d and d are identical except at the keys in k this expansion into the array property fragment shown to be decidable in by reduction to an quantifierfree formula the abbreviation is particularly useful for dictionary updates where we do not know the exact value being stored but do know some abstraction eg its type for example in from section we do not know what value is stored in the count field c only that it is an integer thus we say that the new dictionary is the same as the old except at c where the binding is an integer a more direct approach would be to use an existentially quantified variable to represent the stored value and say that the resulting dictionary is the original dictionary updated to contain this quantified value unfortunately that would take the formulas outside the decidable fragment of the logic thereby logical subtyping standard rules we briefly identify several typing rules that are standard for lambda calculi with dependent refinements and assign types to variable expressions x if x is bound to a monomorphic refinement type in then assigns x the singleton type that says that the expression x evaluates to the same value as the variable x assigns the type scheme s to an if the condition w is a expression the expression e has type scheme s under the assumption that w evaluates to true and the expression e has type scheme s under the assumption that w evaluates to false the rule is standard but notice that the arrow type of w is nested inside a refinement type in the type scheme s must be wellformed in which prevents the variable x from s e s x s e s let x e in e s s e s s s e s s figure type checking for system d its scope allows expression e to be used with type s if e has type s and s is a subtype of s type instantiation the rules uses the procedure inst to instantiate a type variable with a monomorphic type inst is defined recursively on formulas type terms and types where the only nontrivial case involves type predicates with type variables a a p b a t lw b we write a t to mean the result of applying inst to s with the type variables and type arguments in fold and unfold the rule is used for records of data created with the datatype constructor c and type arguments t the rule succeeds if the argument wj provided for each field fj has the required type tj after instantiating all type parameters a with the type arguments t if these conditions are satisfied the formula subtyping s s x fresh p px p px ri i p qi p p s a s s a s ri clause implication q r valid q r q r j valid q lw j u q u uj q i lw i ui syntactic subtyping u u t t x t t t x t t x t t a a null ct c a · · · i if i then ti i if i then ti ct ct ti ti figure subtyping for system d returned by t w defined as null tag ct j sel fj wj records that the value is nonnull that the values stored in the fields are precisely the values used to construct the record and that the value has a type corresponding to the specific constructor used to create the value the fields of nonnull constructed data as a dictionary using t defined as null tag j tj sel fj where c af t p lw and for all j tj a t for example int is null tag hd int sel tl subtyping in traditional refinement type systems there is a twolevel hierarchy between types and refinements that allows a syntaxdirected reduction of subtyping obligations to smt implications in contrast system ds refinements include uninterpreted type predicates that are beyond the scope of firstorder smt solvers let us consider the problem of establishing the subtyping judgment p p we cannot use the smt query p p as the presence of uninterpreted may conservatively the implication invalid instead our strategy is to the refinements into a normal form that makes it easy to factor the implication in into a collection of whose are either simple predicates or type predicates the former can be established via smt and the latter by recursively invoking syntactic subtyping next we show how this strategy is realized by the rules in figure step split query into we start by converting p into a normalized conjunction ri each conjunct or clause qi ri is normalized such that its is a disjunction of type predicates we use the symbol instead of the usual implication arrow to emphasize the normal structure of each clause by splitting p into its normalized clauses rule reduces the goal to the equivalent collection of i p qi ri step the normalization ensures that the of each above is a disjunction of type predicates when the disjunction of a clause is empty the is type p qi false which rule handles by smt otherwise the is type predicate p qi lw j uj which rule handles via type extraction followed by a use of of syntactic subtyping in particular the rule tries to establish one of the lw j uj by searching for a type term u that occurs in that flows to lw j ie for which we can deduce via smt that p qi lw j u is valid and is a syntactic subtype of uj in an appropriately environment written p qi u uj the rules and establish syntactic refinement subtyping by recursively establishing that subtyping holds for the matching components because syntactic subtyping recursively refers to subtyping the rule uses fresh variables to avoid duplicate bindings of in the environment formula normalization procedure converts a formula p into a conjunction of clauses ri as described above the conversion is carried out by translating p to conjunctive normal form and then for each clause literals and adding as necessary for example null ¬ null false null u ¬ null u formula implication in each smt implication query p q the operator · describes the embedding of environments and types into the logic as follows p p p true p x t x a s a t x when embedding values into the logic we represent each lambda by a distinct uninterpreted constant thus function equality is physical equality so there is no concern about the equivalence of expressions note that never need to appear inside refinement formulas in source programs and are included in the grammar of formulas just for the metatheory ensuring termination an important concern remains as we extract type terms from the environment and recursively invoke the subtyping relation on them we do not have the usual guarantee that subtyping is recursively invoked on strictly syntactically smaller terms thus it is not clear whether subtyping checks will terminate indeed if we are not careful they may not consider the environment y top x y u where u a b y top top and suppose we wish to check that true y x y top cannot derive this judgment since the implication true y x y top is not valid thus we must derive equation by type extraction derives that y u in so the remaining obligation is u x y top because of the of function subtyping on the lefthand side of the arrow the following judgment must be derivable y b y top after a fresh variable say for in both types this reduces to the clause implication obligation y true b y top this is essentially equation so we are stuck in an infinite loop we will again extract the type u for y aliased to here and repeat the process ad this situation arises only if we are allowed to invoke the rule infinitely many times in this case extracts a single type term from the environment infinitely often since there are only finitely many in the environment we cut the loop with a restriction along any branch of a subtyping derivation we allow a type term to be extracted at most once since there are only finitely many type terms in the environment this is enough to ensure termination to implement this strategy we augment the subtyping relations to take a set of type terms as an additional parameter which cannot be extracted by the rule to keep the presentation in this paper simpler we this restriction from the subtyping rules in figure the full definition can be found in a technical report the versions with and without this restriction may or may not coincide but we are not particularly concerned with the outcome of this question because in our experience the kind of problematic subtyping obligation discussed in this section is a corner case that does not arise in practice recall that our goal is to typecheck programs which use dictionaries which may contain functions as values on the one hand the theory of finite maps allows us to use logical refinements to express and verify complex invariants about the contents of dictionaries on the other without to higherorder logic such theories cannot express that a dictionary maps a key to a value of function type to resolve this we introduced the novel concept of nested refinements where types are nested into the logic as uninterpreted terms and the typing relation is nested as an uninterpreted predicate the logical validity queries arising in typechecking are by the formula in question into an implication between a purely logical formula and a disjunction of type predicates this implication is using a novel combination of logical queries by an smt solver and syntactic subtyping this approach enables the efficient automatic type checking of sophisticated dynamic language programs that manipulate complex data including dictionaries which map keys to function values soundness at this point in the proceedings it is to make a claim about the soundness of the type system by that it the standard preservation and progress properties unfortunately the presence of nested refinements means this is to us as the usual substitution property does not hold next we describe why substitution is problematic and define a stratified system system d for which we establish the preservation and progress properties the soundness of system d follows as it is a special case of the stratified system d the problems the key insight in system d is that we can use uninterpreted functions to nest types inside refinements thereby the to expressive reasoning for dynamic languages however this very strength the usual substitution lemma upon which preservation proofs rest substitution the standard substitution property requires that if x s e s and w s then wx s wx the following shows why system d lacks this property let foo f in foo fun x x suppose that we to foo the type foo f int int f int int the return type of the function states that its argument f is a function from integers to integers and does not impose any constraints on the return value itself to check that foo does indeed have this type by the following judgment must be derivable f int int f int int by and the judgment reduces to the implication true f int int ty f int int which is trivially valid thereby deriving and showing that foo does indeed have the type next consider the call to foo by the result has type fun x x int int the expression foo fun x x evaluates in one step to thus if the substitution property is to hold should also have the above type in other words system d must be able to derive fun x x int int by and the judgment reduces to the implication true ty fun x x int int which is invalid as type predicates are uninterpreted in our refinement logic thus the call to foo and the reduced value do not have the same type in system d which illustrates the of the problem the rule is not closed under substitution circularity thus it is clear that the substitution lemma will require that we define an interpretation for type predicates as a first attempt we can define an interpretation i that type predicates involving arrows as i x e x t t iff x t e t next let us replace with the following rule that restricts the antecedent to the above interpretation i p q p q notice that the new rule requires the implication be valid in the particular interpretation i instead of in all interpretations this allows the logic to back into the type system to derive types for closed lambda expressions thereby the problematic implication query in while the rule solves the problem with substitution it does not take us safely to the it introduces a circular dependence between the typing judgments and the interpretation i since our refinement logic includes negation the type system corresponding to the set of rules outlined earlier combined with is not necessarily welldefined the solution stratified system d thus to prove soundness we require a wellfounded means of interpreting type predicates we achieve this by the interpretations and type derivations requiring that type derivations at each level refer to interpretations at the same level and that interpretations at each level refer to derivations at strictly lower levels next we formalize this intuition and state the important lemmas and theorems the full proofs may be found in a technical report formally we make the following changes first we index typing judgments n and interpretations in with a natural number n we call these the judgments and interpretations respectively second we allow judgments to use the rule in p q np q and the interpretations to use type derivations in x e x t t iff x t n e t finally we write e s iff n n e s the derivations in system d consist of the derivations at all levels the following lifting lemma states that the derivations at each level include the derivations at all lower levels lemma lifting derivations if e s then e s if n e s then n e s the first clause holds since the original system d derivations cannot use the rule ie e s exactly when e s the second clause follows from the definitions of n and in the circularity and enables the proof of the following stratified substitution lemma lemma stratified substitution if x s n e s and n w s then wx n s wx the proof of the above depends on the following lemma which captures the connection between our typing rules and the logical interpretation of formulas in our refinement logic lemma satisfiable typing if n w t then in t wx stratified substitution enables the following preservation result theorem stratified preservation if n e s and e e then n e s from this and a separate progress result we establish the type soundness of system d theorem system d type soundness if e s then either e is a value or e e and e s by this with lifting we obtain the soundness of system d as a corollary algorithmic typing having established the expressiveness and soundness of system d we establish its by implementing a type checker and applying it to several interesting examples the declarative rules for type checking system d programs shown in section are not syntaxdirected and thus for implementation we the problematic rules and sketch an algorithmic version of the type system that also performs local type inference our prototype implementation verifies all of the examples in this paper and in using z to smt obligations a more detailed discussion of the algorithmic system may be found in a technical report algorithmic subtyping nearly all the declarative subtyping rules presented in figure are and directed by the structure of the judgment being derived the exception is whose first premise requires us to synthesize a type term u such that the smt solver can prove lw j u for some j where u is used in the second premise we note that since type predicates are uninterpreted the only type terms u that can satisfy this criterion must come from the environment thus we define a procedure t that uses the smt solver to compute the set of type terms u out of all possible type terms mentioned in such that for all values x x t implies that x u to implement we call lw j to compute the set u of type terms that might be needed by the second premise since the declarative rule cannot possibly refer to a type term u not in this strategy guarantees that u u and thus does not precision bidirectional type checking we extend the syntax of system d with optional type annotations for binding constructs and constructed data and following work on local type inference we define a bidirectional type checking algorithm in the remainder of this section we the novel aspects of our bidirectional type system function applications to typecheck an application w w we must synthesize a type t for the function w and use type extraction to convert t to a syntactic arrow since the procedure can return an arbitrary number of type terms we must decide how to proceed in the event that t can be extracted to multiple different arrow types to avoid the need for backtracking in the type checker and to provide a semantics that is simple for the programmer we synthesize a type for w only if there is exactly one syntactic arrow that is applicable to the given argument w remaining rules we will now briefly summarize some of the other algorithmic rules presented in a technical report uses of can be into other typing rules however uses of cannot since we cannot syntactically predict where it is needed since we do not have pattern matching to determine exactly when to unfold type definitions as in languages like ml we unfold type definitions to all situations in which unfolding might be required for to handle the fact that synthesized types might refer to variables that are about to go out of scope making them we use several simple heuristics to eliminate occurrences of local variables in all of the examples we have tested the annotations provided on toplevel are sufficient to allow synthesizing wellformed types for all inner precise types are synthesized for by synthesizing the types of both branches them by the appropriate branch conditions and them for constructed data expressions we allow the programmer to provide in type definitions that help the type checker decide how to infer type parameters that are omitted for example suppose the list definition is updated as follows type a tl due to the presence of the marker in the type of the tl field local type inference will use the type of w to infer the omitted type parameter in w finally although the techniques in would allow us to for simplicity we do not attempt to synthesize parameters to type functions soundness we write e s for the algorithmic type checking judgment which verifies e against the given type s and e s for the algorithmic type synthesis judgment which produces a type s for expression e each of the techniques employed in this section are sound with respect to the declarative system so we can show the following property where we use a procedure erase to remove type annotations from functions and constructed data because the syntax of the declarative system does not permit them proposition sound algorithmic typing if e s or e s then s related work in this section we related approaches to statically verifying features of dynamic languages for a introduction to and other hybrid approaches see dynamic unions and control flow among the attempts at static and dynamic typing was adding the special type dynamic to a language like ml in this approach an arbitrary value can be injected into dynamic and a typecase construct allows its precise type at runtime however one cannot guarantee that a particular dynamic value is of one of a subset of types cf from section several researchers have used union types and sensitive controlflow analyses to support such idioms most recently t r and s feature values of union types that can be used at more precise types based on control flow in the former each expression is assigned two propositional formulas that hold when the expression evaluates to either true or false these propositions are by recording the guard of an in the typing environment when typing its branches typechecking proceeds by solving propositional constraints to compute for each value at each program point the set of tags it may correspond to the latter shows how a similar strategy can be developed in an imperative setting by a type system with a data flow analysis however both systems are limited to adhoc unions over basic and function values in contrast system d shows how by all the information about the value resp reasoning about flow into expressive but decidable refinement predicates resp into smt solvers one can statically reason about significantly richer idioms related tags dynamic dictionaries polymorphism etc records and objects there is a large body of work on type systems for objects several early advances incorporate records into ml but the use of records in these systems is unfortunately to be flexible enough for dynamic dictionaries in particular record types cannot be when they on the type of a common field which is enabled by the use of the theory of finite maps in our setting recent work includes type systems for javascript and ruby presents a rich type system and inference algorithm for javascript which uses and width subtyping to model dictionaries objects the system does not support unions and uses fixed field names this issue is addressed in which models dictionaries using row types labeled by indexed by string constants and depth subtyping a recent proposal an initialization phase during which object types can be updated however these systems dynamic dictionaries which require dependent types and moreover lack the control flow analysis required to support adhoc unions is a powerful type system designed to support ruby code that intersections unions classes and parametric polymorphism supports typing by converting from nominal to structural types appropriately however it does not support adhoc unions or dynamic dictionary accesses dependent types for firstorder programs the observation that adhoc unions can be checked via dependent types is not new a dependent type system called guarded types that is used to describe records and adhoc unions in cobol programs that make extensive use of where the tag is simply the first few bytes of a structure presents an system for statically inferring dependent types that verify the safety of adhoc unions in c programs describes how typechecking and property verification are two sides of the same for c which is essentially it a precise type system for c and shows how smt solvers can be used for typechecking this system contains a which is similar to ours except that t ranges over a fixed set of type constants as opposed to arbitrary types thus one cannot use their to talk about complex values eg dependent functions records with only some fields nested within dictionaries in their system finally the system supports function pointers but does not fully support higherorder functions uses refinement types to formalize similar ideas in a firstorder functional data description language with records and runtime the authors show how unions and intersections can be expressed in refinements and even collections via recursive functions and hence how smt solvers can all subtyping obligations however the above techniques apply only to firstorder languages with static keys and dictionaries over base values refinement types for higherorder programs the key of system d is the introduction of nested refinement types which are a generalization of the refinement types introduced by the long line of work by xi and pfenning and further studied in the main difficulty in applying these classical refinement type systems to dynamic languages is that they require a distinction between base values that are typed with refinement predicates and complex values that are typed with syntactic constructors in particular dynamic languages contain dependent dictionaries which require refinements over the theory of arrays to describe keys but syntactic types to describe the values bound to keys this combination is impossible with earlier refinement types systems but is enabled by nesting types within refinements combining decision procedures our approach of combining logical reasoning by smt solvers and syntactic reasoning by subtyping is of work on combining decision procedures however such techniques require the theories being combined to be disjoint since our logic includes type terms which themselves contain arbitrary terms our theory of syntactic types cannot be separated from the other theories in our system so these techniques cannot be directly applied conclusions and future work we have shown how by nesting type predicates within refinement formulas and carefully interleaving syntactic and subtyping system d can statically type check dynamic programs that manipulate dictionaries polymorphic higherorder functions and containers thus we believe that system d can be a foundation for two distinct of research the addition of heterogeneous dictionaries to static languages like c java ocaml and haskell or the addition of expressive static typing to dynamic languages like javascript and ruby we several concrete lines of work that are needed to realize the above goals first we need to add support for references and imperative update features common to most popular dynamic languages since every dictionary operation in an imperative language goes through a reference we will need to extend the type system with flowsensitive analyses as in and to precisely track the values stored in reference cells at each program point furthermore to precisely track updates to dictionaries in the imperative setting we will likely need to introduce some to the type system itself strong update techniques as in and second our system treats strings as atomic constants instead it should be possible to incorporate modern decision procedures for strings to support logical operations on keys which would give even more precise support for reflective third we plan to extend our local inference techniques to automatically derive polymorphic instantiations and use types to globally infer refinement types finally for dynamic languages it would be useful to incorporate some form of staged analysis to support dynamic code generation acknowledgements the authors wish to thank foster ming david walker and the anonymous reviewers for their detailed feedback on of this paper references m abadi l cardelli b c pierce and g plotkin dynamic typing in a language in popl d an a j s foster and m dynamic inference of static types for ruby in popl c s and p towards type inference for javascript in ecoop pages ­ june j k c fournet a gordon and s refinement types for secure implementations in y and p interactive theorem proving and program development the calculus of inductive constructions g m a d gordon c and d e semantic subtyping with an smt solver in icfp a r z manna and h b decidable about arrays in pages ­ r p m and r jhala nested refinements a logic for typing r j a r jhala and s staged information flow for javascript in proceedings of pldi pages ­ j b s k and s qadeer unifying type checking and property checking for lowlevel code in popl r practical checking phd thesis carnegie mellon university pittsburgh pa usa l de and n z an efficient smt solver in tacas l de and n generalized efficient array decision procedures in pages ­ j a unified system of type refinements phd thesis carnegie mellon university pittsburgh pa usa r b findler and m felleisen contracts for higherorder functions in icfp pages ­ c flanagan hybrid type checking in popl acm m j david an j s foster and m w static type inference for ruby in pages ­ a c and s typing local control and state using flow analysis in esop p and p types for analyzing languages in ecoop pages ­ p and m an evaluation of automata algorithms for string analysis in pages ­ r jhala r majumdar and rg xu state of the union type inference via craig interpolation in tacas a j kennedy and b c pierce on decidability of nominal subtyping with variance in k and c flanagan hybrid type checking acm toplas r g s and j field dependent types for program understanding in tacas pages ­ j towards a mathematical science of computation in in ifip pages ­ northholland g nelson and d c simplification by decision procedures toplas x g y and d walker dynamic typing with dependent types in ifip pages ­ j palsberg and m i oo type systems b c pierce and d n turner local type inference in popl pages ­ d type checking records and variants in a natural extension of ml in popl p m and r jhala types in pldi p m and r jhala lowlevel types in popl pages ­ r deciding combinations of theories journal of the acm ­ j siek and w gradual typing for functional languages in scheme and functional programming workshop n j chen and r enforcing stateful and information flow policies in fine in esop the foundation the python software foundation python standard library http p towards a type system for analyzing javascript programs in esop s and m felleisen logical types for untyped languages in icfp pages ­ h xi and f pfenning dependent types in practical programming in popl t type inference for languages with implicit extension in 