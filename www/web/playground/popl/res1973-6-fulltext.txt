language semantics closed applicative languages john ibm research laboratory san california introduction this paper proposes axioms to define a sequence of the most general is that of programming language the most restricted has some simple and properties here language is used in its traditional sense as referring a set of interpreted expressions we are concerned with the syntax of an expression to the degree needed to relate its structure to its meaning a clear distinction drawn between a language and the many possible of that language to only is this introduction the paper therefore the reader skip to the next section a survey who and to get on with discussion the technical of the contents of can ea the languages these are semantics the description of a complete language or something class of languages in languages which the semantics of any very similar our hierarchy is do not depend on language requires that of complete another for their the formulation of closed the most restrictive set of axioms defines closed applicative languages languages an expression e has two distinct notions associated with it a the or value of e which is always an expression when e has a meaning and b function represented by e these languages have the following in these meaning the properties constant meaning the of the function expression if it exists is a constant e then f is an expression and is its lisp where meaning is not idempotent e expressions are those which are their own called meaning the meaning of any thus if f is the meaning of the expression own meaning in languages such as we have chains of meanings eg quote e the most languages are quote languages an expression never denotes itself but a marked expression denotes the expression e denotes e and e denotes something else in a closed applicative language an expression without applications as subexpressions always denotes itself ie is its own meaning hence a constant an application eg fg denotes the result of applying the function represented by the expression f to the expression g finding the meaning of an expression e is simply a matter of replacing each innermost application in e by the result it denotes function language represent meanings involved in an extensional then f g and fh denote the one can expressions g and the same function and for some and represent different functions not necessarily the functions system if g and h denote the same same thing in a closed applicative h which have different meanings but f and fh can have different since the expressions g and h are they represent e functions the functions same type all map constant expressions hierarchy of function types is required as lambdacalculus represented by expressions into expressions thus it is in model of are all no the of the a reductions a has extended churchrosser a every on an expression yield the same meaning for it and then every sequence of reductions on it terminates properties a and b but the and lisp sequence of b if an expression the acalculus of do not have property has church b subexpressions the meaning reduction of e and b of e is unchanged a if an expression if any subexpression e has a meaning of e is replaced then so do all the in e by its meaning two reduction framework provided rest of examples of closed applicative languages are and languages in these the fundamental semantics rather than on one of these languages corresponds to every the semantics for both types being fixed specified red languages languages is on the language the particular primitive operations set of primitive operators the for a red language with programming languages any computable function but a sophisticated set programming language a simple its syntax on the of primitive set and other of primitives semantics hand a operators are extremely red language a the turing machine yet it can with the same basic powerful highlevel of specify semantics the basic semantics of red languages beyond those of all closed applicative languages involve only one notion functional composition two kinds are provided the classical composition of functions and a new form called meta composition the latter makes possible the definition of functions with parameters and those defined by iteration or recursion red languages employ no variables or labels no go to statements no and have no builtin mechanism for evaluating recursively defined functions the red languages described in this paper are different from and simpler than those given in an earlier report languages are closed applicative languages which the they differ from the in properties and of the six properties listed above for closed applicative languages and they differ from lisp and applicative expressions or in all six in addition red languages have following properties which are not shared by any of the three other languages the every innermost application can be immediately evaluated there is no need for changing bound variables when evaluating an expression the differences between languages semantics and hence simpler and lisp and give the former simpler y although space programming examples does not allow much for red languages an appendix gives primitive operators and some languages a or l li l l a set of a domain a semantic of relation e d o we say that dd is a of the expression if u is a function ie there is only one d for any e then we say that d is the of e let e be the set of algol programs call s an stat if s is any state the algol machine in which the program e is about to be executed let ps denote terminal state if any which results from the state s let d be the set of pairs computations for states s having a terminal state ps let e ss whenever s is an state then l is one possible formulation algol as a language in our sense the semantic relation indicates for any program what states s are program are the terminating states and terminate in us thus the computations it of the or co of e of a discussion although it is a popular idea we do not try to assign a on as the mean ng of a program in the case of algol for example the domain of such functions must be the states of the algol machine and these involve one too much in notions of implementation rather than of meaning furthermore we do not want expressions to be or to have artificial and useless meanings simply like because they do not denote functions thus we use meaning in the sense of value but we shall also pay careful attention later on to associate functions with expressions in an way the real problem in describing the semantics of algol as above is that of describing states and the function w which carries a state s into the corresponding terminal state vs this is a special case of what we shall call a complete language complete languages thus play a central role in specifying the semantics of any language later we shall several examples of complete which are independent and powerful languages in their own right complete languages a language is iff cl cl u is c is a partial the set function from e onto of of u c the domain of c expressions are called defined ue is the unique language is not complete it of l is thus a subset of constant st since of e v is the is the expressions of if e is an expression semantic function of l and the of l and l if a ye is the state of let e be the set of states of the algol machine stops after starting in state e if c be the set of terminal states ue then below of algol it is a complete language major part of a realization of algol machine let ue be it does not stop let we call the and any realization the state in which the ue be undefined let state lan see of it see below is a le ic gf church let e be the set of wellformed formulas of the acalculus principal normal forms let ue be defined for when e has a principal normal form of e then is a complete language of a wellformed formula is its principal normal form let c be the set of normal form and be the in which the if is a language i ms defined and if then we say that is a complete language such that e is the of l thus a language has a state language only when its domain of is the set of pairs computations which the semantic function p of z a real r is a triple such that cr cr cse t is c is a total the set of e into e of t as with complete languages t is called the tr e the expressions function of r of r and c the constants of r if say that r is a complete realization k or that e realization and a l is a complete we which ri r r case ue is pe defined ne for we say that cc strictly iff there is an integer n such that tne c c in l or that e ti a realization ti k if and thus to find he in one computes e in some realization rec of within c then that is pe we is undefined for every complete language l if if no complete which this sequence fixedpoint realization r of reaches a fixedpoint of r is reached or if it lies in cc there is a corresponding then the complete we shall principal realization not try task in of a to formalize state this an incomplete language of l notion further language if l admits at present l is that of finding one as indicated a earlier a strict realization of the acalculus let e be the wellformed formulas and c the principal normal forms of the as in the earlier example let t be any definite rule which when applied to a wff e a performs a contraction on a selected part of e or b converts a normal form e into its principal normal form then rec is a strict realization the language of the earlier example thus if e has a normal form e j will converge at e otherwise it will not converge the churchrosser theorem states that any two such rules and t will give the same result of g realization we here are single apl realization the of an apl a partial sketch of a complete language statements except branches which probably does following are sample expressions of l followed whose expressions not have a strict by their meanings g recall that apl evaluation is from we observe that if is to must contain special expressions in have an environment part to keep realization r by giving examples of right to realize addition the values transitions left and that ai means assign to a l with a simple transition function then e to those in e these special expressions of variables we indicate such a in e produced by n no n j n ai bbi ai bb ai bb ab b we say that ak is a constructor syntax for e or for iff csl age cs each n into e cs for such that every en is a function either e from a subset sk of en for some nonnegative integer or there is a unique and unique el en c e each is called an of e or of following each is called a constructor of e or of l we write kn to indicate that kn s thus if e has a constructor syntax every expression is either atomic or has a unique representation en and every such representation provided denotes a valid expression when e is not atomic the expressions are called the components of e a of e is either a e itself or b a component of e or c a subexpression of a component of e note that cs allows constructors ko which construct a nonatomic expression e with no components ko e in this and similar cases we consider the existence of the unique el in cs to be applicative languages a complete language with constructor syntax ak is a ali al there is a constructor ap c k such that for all both defined or undefined together iff al for every except ap and every c en en when left side is defined constructed component is undefined meaning of any constructed by ap are called arm no construction in an applicative language atoms are their expression e is found by first replacing is defined own meaning its components if a and the by meanings if e is not an application this yields its meaning is unchanged and e has been simplified in expressions except applications are thereby determined themselves specify any computation only applications languages have the reduction property see introduction if general the semantics of such cannot may do so finally applicative property of closed it all is applicative languages let a be an v d g for aa let sa ae for all syntax for e the set of for the calculus set of variables let let fe denote the set of free let for all let fb and i let a be the constructor such that ae and let fe a then is a constructor wellformed formulas of the acalculus the produces a is the expression calculus fails to the normal first variable is the principal satisfy axiom form of e then by definition normal form of al thus the for applicative languages since pe if a and x are two variables in ul xx where the second first but by al we should have a and examples of applicative languages appear later in the paper as examples applicative languages one of them is very similar to the of closed applicative languages specify the closed applicative languages or representation function associates a semantics function an applicative such that language is for the with all expressions semantics of each constant but applications applications a expression iff there is a function cal cal j cal o is total over c for every pc e ce for all cd c c is total over c the function p is the function of l to find the meaning of an application in a cal one notes that by al this is the same as the meaning of where ce and df if these exist otherwise has no meaning since the meaning of is found by cal by applying the function pc to d to get the result g and then finding the meaning of g if it exists the function pc and the result g are guaranteed to exist by and cal g may be without meaning thus the meaning of is the meaning of g if it exists note that a k and p completely determine finally if for every then pe is defined for every finite expression et and such a cal with all expressions finite is trivial we should languages listed now be more precise in the introduction about some of the properties we use the same numbers of closed applicative as used there non are in extensional systems applications have the following interpretation apply the function denoted by the expression f to the function denoted bv expression g in on the other hand has the interpretation apply the function represented by f to the expression q itself in an extensional system no function can yield different results for distinct arguments g and denote the same thing in such systems as in the acalculus one gg of expressions g to distinguish between different expressions which denote same however no function can be denoted by any expression g within the system for and must denote the same object if g and g denote the same object in with this observation one that a lisp is achieved by quote which cannot be and is not a function distinct denote in each expression out represent the same the same expression serves function as its own number then and for if g and g are do not in general ions all functions represented by cal expressions are of a single type they map c into e thus the infinite hierarchy of function types required in models of the as in scott is avoided in a treatment of the hierarchy of function types is replaced by a hierarchy of orderings on e let so be the basic ordering of expressions iff ue exist and is defined on c in the usual then we define way and extended to e by f iff i for all thus while all orderings are on e one can think of as ordering functions and s ordering etc for if and gf then f and g represent equivalent that is represents the function that does for every expression e a rather theory for cal semantics should be beginning along these lines as extended if e is the cal expression where then by a reduction te of e we mean the replacement of by for any other expression e let e be the result of replacing any component f of e by tf when we say have the churchrosser property we mean that any two sequences of reductions on an expression e will converge to the same constant pe by the extended churchrosser property we mean in addition that if e is defined then every sequence of reductions on e will converge this property implies that every subexpression of a meaningful expression is meaningful have this property while the and lisp do not reduction has a slightly different meaning in these latter cases description classes expressions and of we assume the context relates to some cal we let an expression involving proper expressions obtained by replacing these variables range thus if we assign the ranges sa and then cases with constructor syntax ak variables denote the class by any expression in their the following definition by of means if z is an expression of the form of a then is the atom g if z is of the form and if x is of neither of these forms then as is definition by cases are connective denote themselves the first applicative ie both components the same element qe then ax is x q gi the atom o the connective in a marks and strings other than clause the result languages a for reduction one red differ from functions those represented by atoms and are simpler than those described in is any of the satisfying another in its atoms and in its the red languages described here an earlier report the definitions primitive from although constructor it is not necessary simply to be specific we give particular constructions for each red constructors let on nl en c e then en l n wl u for nl expressions constructed by on are called sequences of length are called pairs a simpler kind of red language would have since sequences can be built from pairs as in lisp we prefer the present approach because pairs are then always sequences there are thus four types of red expressions atoms a app sequences n and bottom or undefined the first component of an application is called its operator the second its operand if a is a set of atoms which do not use the special constructions then a and above k generate the language we assume further that strings of letters and other characters as sequence and to identify certain expressions identity function the atoms t and f are used for characters of tile above set of expressions e of a red and in general we use atoms we use for empty see below also represents true and false the semantics semantic function and dy tile representation which p depends are circular a particular atoms for red language the following p of a function and definitions red language is by the cal axioms p the definitions of p and of the predicate on thus undefined for all atoms but the definition of the extension we let gl of the definitions gn e c and of p and to all functions u t t e al gn everywhere undefined function li m function r for every scc m is the function g q such that ld g tile function for red p and the identity function this the general definition of red languages remarks the first clause in the on how p is defined on a for composition and depends final clause applies only to definition of p is the pr the particular red language on the third clause is the l and yields func tion rule the second clause composition and is depends the the if gt we say that when qi is a meta expression g is a otherwise c is a the function represented by gl n satisfies in regular composition as in psl n with regular the argument of is the result v p g m id if it exists whereas in meta composition with s meta the argument of psi is the constant qi n composition allows the definition of functions with parameters a meta expression f may be formed so that the meaning of depends on g and on h in a manner entirely controlled by pf when a meta is designed to se the functions bv its parameters rather than the parameters themselves it is called a we let subsequent p and be defined for examples let gr the c c following primitive then we define operators for use in the we now compute in following expressions composition rule of functions detail giving or the for much simpler references to the regular composition rules see below appropriate axioms rule and the meanings of the eg cal the meta to the definitions u a p l by cal a by def p by def u pa p p v p pa by def def t by def uo p p a by ali g cl by def by al aa by ali g cl aa aa by def al al cl u ab p p p ab by cal by def fst s ab by def r by def by al lj by cal and ali cl by def ali cl the above examples illustrate red semantics these transition rule for a strict the semantics realization detailed operation of the axioms and definitions are more simply given by the following of a red language lo find t the the meaning of a find an innermost following transitions red expression application to cd s in q and apply the appropriate one of tl if q is an atom r if gn t if gl n gd gl if nl qd q n if nl gd ql t if gl gd repeat until if this process g contains no more applications the resulting expression does not terminate us is undefined this does not mean the meanings of the above two examples are found by the following transitions a a aa ab aa aa fst ab is pq definition of new operators definition function when p and have defined for normally pa will be a useful primitive all atoms function a red language for relatively has been defined few atoms a called primitive for the remaining atoms pa will be the everywhere undefined function similarly s will usually be f ie is regular there are often constants s which represent very useful in such a language functions one would like to set aside some atom q to represent the function which is represented by some long g for this all sec assertion purpose we provide a definition d is the identity function until of the form q function a total function from c into c for a definition is made a definition is an maps q into g definitions be given only for atoms q and pa p ps and any former definition of pa is the effect of the function is entirely subsumed in the following definition tile functions p and satisfy the following for all gcc the effect definition definition of this rule is nil for all and all sa for which there is no thus if is a primitive operator and and then results in the sin sin u f starting with a red language l with its language l and and which differ p and each definition from the only gg yields in that the a new function pq represented by is now p instead of p and now equals and if q q was an earlier then p would also differ from pk it is possible and convenient which s occurs in q see below p and p and with a suitable set any computable function ac c to make unambiguous recursive definitions q in tie however that given a red language with its of primitive operators but no definitions then given there is a constant z such that call q the basic function and its modification of red languages this power arises composition rules a g thus our introduction of the definition function semantics is not essential to the definitional power of red from the existence of composite operators and the two in transition for any a red language realization the function t see above is to innermost application g effect change of the definition the first three function on the of c as follows recursive definitions to see why a recursive circular definition of p definition consider gg with a occurring the following definition in s need not result in a f if cn is meta then pf thus x hence pf is not defined since pf does occur on the right hand side since all represented functions are total is always defined hence pf is always defined and yields some expression y now y may or may not be meaningful ie f may be partial or undefined when we say here that f may be undefined we mean that it is everywhere nonterminating this is quite different from saying that ff is a the latter is a total function which always yields the expression l called bottom not let definition pr of then d let let be the c r or r jc bc by rl by t by by by since since r t ca since since nl since rf def def rf pr f let then the following is u an example cd of a nonterminating let operator be the nt x app nt x app nt x app it x nt x definition of nt here is everywhere defined but nt is everywhere nonterminating remarks there effect on by for are special under which a definition the meaning of an e a replacement in example consider the definition s in connection does not have the g of every occurrence with the expression same of after one transition the latter becomes z a s on the other hand and one transition replacing gives by in the original express on yields s for those for those meanings z g g whose represented function depends that depend on their own structure on the first member of the operand ie the two expressions will have different languages languages are closed applicative languages which the they serve to show the of the cal distinction between meaning and represented function there is no longer a need to require that be equal to simply because they represent the same function that there should be expressions which represent the as with all it same function but have is normal different meanings other properties of languages are they have simple strict no bound variables need changing ie no or and every innermost application of a meaningful expression can be immediately evaluated are not so simple for the acalculus because and do not hold in which we would write as n if x is a free variable of n then x must be replaced in the operator by another variable before the application can be evaluated in the expression the innermost application cannot be dealt with until the outer one is reduced to begin with we are given two disjoint sets v the set of variables and o the set of lie are also given the set k of four constructors pair lambda ap application and formal application and the constructor w which constructs to describe the range of each constructor we also need the function expressions into subsets of v where is the set of free variables a c the expressions constructed by are called formal ap they are not applications but may be later changed into applications when all free variables have been eliminated from their components the expressions constructed by the other constructors are pairs and aw for convenience we give particular constructions for each constructor ap u q e s ie now give the constructor a recursive syntax description ak for of e for languages the expressions e of a language this defines if then and if then and if then and q u if and then and x if and u then and cs if and s u then and rz e u z and the difference between s and is that have no free and the is occurrence of a free variable of s is a every subexpression of s in it occurs the first occurrence is wellformed only if and s only otherwise we say an if it is a free variable of semantics since languages are their semantics are determined function o we summarize the effects of the cal axioms for all and by a representation for expressions p p pe f u ue c is the set of expressions applications containing no applications they may contain formal function for every variable any cc is x and every constant obtained as follows g is a function from c into e for replace every free occurrence subexpression substitution of for y a replace every no free variables by the expression and is of in by this which has no remaining yields free may have a variables after the subexpression of of the form pq the resulting expression fq which is wellformed has function for as before p is circular and undefined for the primitive functions of a particular then p objects language the extension of p to objects let co and p i o t d qo pg n this completes the general definition of red languages remarks the languages fourth here clause applied of the definition to pairs only of p is the regular composition the fifth clause is the abstraction rule as in red examples we appropriate appear languages objects show in detail the operation of semantics at each step we the cal axioms or the abstraction rule or the two rules for xl and between the use of al our examples do not show regular composition since it is similar to that we use lower case letters for variables and upper case strings or letters o red for y ax xy a ay xa lr ax xa by cal by ar by al by al twice by ali and cl the resulting expression represents a function a such that when s lx xx xa ux xx x ia lx xx x la by cal bv ar the one free occurrence aa of x is replaced as with red transition function e languages of a the strict semantics realization of languages are best described by the to find the meaning of a expression find an innermost following transitions application sd in g and apply the appropriate one of the tl if s t if g t if repeat t until g contains no applications the resulting expression is iq if process does not terminate us is undefined there is no of t for because c is not wellformed due to the necessary presence of a free variable the operator as in red languages there is no for because cg is innermost application the in an the meanings of the above two examples may be found using these transition rules ay ax ax xa ax ax xx xa ax xx a aa remarks it is possible very much like red rule thereby allowing to also define another languages which have the definition of class added recursive of languages called to the definition of functions without p a meta composition the y operator this paper is essentially an outline for a number of study projects it proposes precise definitions for various and their semantics and for their it contains many assertions and no proofs much work remains to be done on other assertions and on careful proofs this work will lead to a semantic theory for a new class of programming languages one which an axiomatic foundation of the simplicity required for rigorous mathematical treatment one area is that of proving assertions about red and programs several of their properties seem to make them particularly amenable to various proof techniques certain examples in an earlier report suggest that it may be possible to an exhaustive analysis of the behavior of any operator in a large class there is also the question of constructing a theory for the semantics of these languages along the lines suggested in the discussion of functions in the section on closed applicative languages i hope to some of these issues and hope others will too the semantics formulation they have notion of a complete language of any language as state of a widely used method of few existing examples is to be useful languages they a semantic description as in discussing the precise general independent languages closed applicative languages introduce be novel the distinction between meaning interpretation of applications and hence manipulation of unlike most languages these new ones all be described by transitions entirely within several precise concepts some of which of and function represented by and the are basic notions which make expressions expressible within the system have strict their semantics the space of expressions may can almost all existing languages have the of the six properties of closed applicative languages listed in the introduction of meaning the quote property multiple and the lack of the extended and reduction properties are all such traditional language features that their has been noted the absence to date of languages with the properties of closed applicative languages may make these properties appear to some readers but i believe that it is difficult to their at least in the abstract their is demonstrated to some degree by the existence of two languages red and which them and which simple clean and expressive the functions languages notion with of parameters composition is central is thought to be novel its use in defining to the definitional power of red and in the future i hope to show that red and similar languages have properties as programming languages i also hope to show they can be used to study and model the following naming indexing and addressing systems parallel computation the semantics of other programming languages that my earlier report discusses a variety for which there is no space here including programming examples comparisons with other of topics relating to languages variants of red languages highlevel red systems and related work there are slight paper sample differences and also red between some changes primitive the red languages of that in notation the appendix operators and programs report of and those the present described in this paper gives some i al particularly to two people for a great amount of help interest and suggestions peter and john c reynolds it is a to my to them in particular john reynolds observed that what i called languages in my earlier report were really of languages although not to be for my formulation of that notion express he is i am also to the following val for providing the apl editing programs people used to for various helpful and john this paper discussions and to smith references scott d models of the calculus unpublished report distributed to ifip church a the calculi of princeton univ press princeton of mathematics studies no j recursive functions of symbolic expressions and their computation by machine comm acm april j reduction languages and programming ibm research report heights ny april pj the mechanical evaluation of expressions the computer journal jan ad and ke apl users manual ibm pr function in this appendix then we describe functions as in the following example let op a xl xn xs j describes the first component second element first clause function o represented by the atom op where when x is the atom and a z is a sequence of length of x when x is a sequence of or more which does and in all other cases is a pair whose and ax is the not satisfy the live the following operators one proposal for a list of primitive operators some operators can be defined in terms of others in the list all can be defined in terms of the primitives of see below is the language with these operators and with all other atoms representing the function if a primitive operator is meta the function represented by the primitive with its parameters is given thus for the meta operator while the regular operator is described operators functional n l l x zl n q x g when when undefined when is undefined j c constant cx y while i when when undefined when is undefined j to aa xl yn left yi yn yl yn to right element ar yl yn yl yn in insert xx i yl y yl y yn l regular operators selectors il l i xl an ai tail when nl tail zl zn z n l al l x ax t when does not have l as a subexpression ry f when neither nor y have as a subexpression apply apply y zy null null t f and tt t xx f when not t f f t zl al xn al al ny lo from the an yl redistribute yn yl from the yn l l ny x ln al n l un zi zl trans z zn kl zn t xl r n yl yj is the sequence of jth when each i is a sequence elements of the xs a of length m and each other ed in addition to the above rather list one would like the operators the binary arithmetic operators would be defined as usual special atoms called numbers one might also want operators which decompose atoms as in the of the report there are probably and powerful primitives which one might want to include usual arithmetic for pairs of could form and many other useful shorthand not ation w ne the nf is so basic to the programming techniques needed that we use a special shorthand for it we observe that many such shorthand notations can be used and then translated into the corresponding form before evaluation for any sequence of the form fn we shall write instead in n thus n is a regular operator and when applied except when zl it yields j to e yields examples several definitions of example operators are given operators is then in the same form as for the the validity of these assertions by using the transition definitions plus the above definitions of primitive effect primitives rules for operators of these defined the reader may check red languages with we begin with two examples of definitions languages the definitions of two one must define functions which are impossible to make in most to obtain the equivalent effect in lisp we a unary operator define operator which a meta from yields operator a binary t when or operator plus its operand is bu one binary parameter operator thus to unary which creates is a regular ls apply fhe effect of this definition for two parameters is x i xy for example we have the following transitions b f qr i xa in corresponding its result between for abc and eq is is a operator is difficult to which converts for vectors ee is make in some a binary operator into the thus is vector equal vector addition languages the distinction ee apply the effect of this definition is the following ee aa trans for one parameter if n then the result is i yl l e we now give two definitions for reverse one iterative one recursive l c where p and f un this gives the following we use for one or more transitions abc l l l abc f a bc l ba c l abc where and f l this gives the following abc f abc bc c b c b c al cb te give definitions for sum of the pair of compatible matrices inner product p and matrix multiply mm p gives products of a pair of vectors mm gives the product where each matrix is the sequence of its rows the of a p insert aa the first operator of mm the right matrix thus the new right matrix is the set of columns of the old the next operator pairs the set of columns with each row of the left matrix the next transforms each of these pairs in each one it pairs the particular row of the left matrix with every column of the right one thus each element of the result so far is a set of pairs of the last applies inner product to each of these pairs in each set the result is the product matrix note that this operator does not as much unnecessary order in the calculation as most programs is the composition do that the process of operations that is transparent to analysis and that it involve more than a single word or pair of words the availability of appropriate makes it possible to put operators together to form ones we give a list of sufficient i believe to define those atoms are also see then be defined all of operators primitive of arithmetic are operators for if two operators operators on they are to form and decompose number could also ll xx al q x same as for red un as for cond t y a f y l l t n xy zy xx zy f j it is rather operators operators but there is to define of the not space here operators to list an appropriate of th above set of 