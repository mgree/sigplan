conference record of the fifth annual acm symposium on principles of programming languages type definitions extended with parameters abstract university of introduction it has long been known that recursively defined types in a highly typed language such as algol or pascal may be tested for structural equivalence by the same algorithm that compares finite automata several authors for example have proposed that classes of types be simultaneously defined by the use of parametrized type tions such as record next end this paper shows that unless the use of such parameterized definitions is restricted new types may be defined which more closely deterministic contextfree languages in fact the equivalence problem for such types becomes as hard as the currently deterministic pushdown automaton equivalence problem several restrictions on type definitions are considered which allow known equivalence algorithms to be applied equivalence and compatibility the type of a value limits which operations may be performed on it for example character strings and integers have different types only strings may be and only integers may be added the type of a value also the type of the result obtained when a legal operator is applied to it for example a pointer value may be to the operation deref which the value to which it points but a pointer to an integer should be distinguished from a pointer to a string since the results of applying the deref operator to them have different types in other words the sequence deref add is applicable to a but not to a pointer informally is the collection of all information about which operations are applicable to t clearly types with distinct behaviors are not equivalent whether a much more detailed version of these results may be found in the converse is true is largely a matter of the algol definition takes the viewpoint that types that have identical behaviors are equivalent pascal tions largely for reasons of convenience generally take a more restrictive view and re that equivalent types be declared in the same way those who prefer the latter viewpoint may prefer to use the term compatibility rather than equivalence we will however identify a type with its behavior the behavior of a type may be represented by a tree for example the type declared rec record might be represented thus integer r ea leaves are labelled nodes are labelled by integer and real in this by constructors record and pointer example inter and arcs are la pointer by selectors i is like a record and from the point of view of type with one field called or deref for technical checking reasons a it is helpful to assume that each constructor has a unique number of arguments this is the reason for the subscript on record certain types are amenable to arbitrarily long se of operations and so have behaviors record represented by infinite end trees for example integer behavior trees can be completely specified by sets of strings as follows each node in a tree t has an address which is the unique sequence of selectors leading from the root to the given node for each builtin type or constructor s let be the set of addresses of nodes in t labelled by s regular and in we proved types the following theorem a tree see also t is the behavior of a type defined by a type definition such as or if and only if is a regular set for each s appearing in t m example if t behavior address address address then next next next val next type definitions in languages like algol pascal or are constructed n from builtin types builtin type constructors and defined types it has been suggested that it would be useful to include in addition defined type constructors to allow definitions such as record list etc unfortunately with the addition of defined type constructors called in and theorem no longer holds for example cfg record end is similar to or however it defines this behavior t ig record r integer val q next inter and address val n i n which is not a regular set for this reason we will call types defined in this way contextfree types nonetheless the situation is not the address sets of contextfree types are no more complicated than deterministic contextfree languages theorem if t is the behavior of a contextfree type then for each builtin type or tor s appearing in t contextfree proof sketch consider the definition record record cx end r cx end the righthand side of this definition is more clearly represented as a tree in is the infinite tree that results from repeatedly expanding by re placing a node labelled t with the definition of t viz the tree when a node is replaced a copy of its left subtree is substituted for each occurrence of xl in lq and a copy of its right subtree is substituted for each x the process is formalized in various ways in consider an occurrence of integer in either it is one of the two toplevel occurrences explicitly shown in or it is an embedded occurrence resulting from the expansion of the shown occurrence of t a path from the root to an oc of integer is thus of one of the three forms au or where u is a path to an occurrence of integer v is a path to an occurrence of x and w is a path to an occurrence of x from this we see that address is generated by the contextfree integer tx grammar a integer b i a c i a a b c a i a tx a where generates the set of paths from the root of partially expanded versions of t to an occurrence of xl thus address i m n more generally a mutually recursive set of declarations can be modelled by such a grammar to show that this language is deterministic we construct a deterministic pushdown automaton p the states of p are nodes of the tree on the righthand side of stack symbols are those nodes that are labelled by defined types and type constructors there is only one stack symbol in this example final states are nodes labelled by integer the action of p in state n is as follows if n is labelled by a builtin constructor or type then n heads a subtree of the form then p reads the next input symbol and goes to the root of el e or e according if n is labelled to whether the input was a b or c by the defined type or type constructor t then p stacks its current state and goes to the state which is the root of the tree defining t the input is not examined if n is labelled by the symbol xi then p the top symbol off the stack this symbol will be the root of a subtree of the form te ek p goes to the state that is the root of ei if the stack is empty or k i then p the input is not examined in contrast to theorem we have only a partial converse to theorem lemma if l is a deterministic contextfree language with the prefix property ie if then no proper prefix then there exists a contextfree type with behavior t constructed from the builtin constructors struct and integer such that proof address sketch l y i no prefix of y is in l by the construction in p we may assume that l is recognized by a pushdown automaton p in normal form this means that the states into scan states qs which read input without modifying or examining states and erase states qe which manipulate the stack without and a unique final state qf from which no moves are possible also of p are partitioned the stack write examining the input an erase state is never the immediate successor of a write state it is not hard to show that p may be further restricted so that the symbol pushed on the stack by a write state is the write state itself now construct a definition as follows qe and let be the transition type constructor tq for each q qe let al function an be the alphabet of l of p introduce an let de lf q qs then for stack symbol y include each there the declaration is a state qi such that for any record ae end where ei j xm if qi j qe if qi qe if q then there is a state q qe such that for any stack include the declaration em symbol y where ei j xl if xm if qc pj qe q qe finally for the final state qf add the declaration integer f lx theorem the equivalence equivalence problem problem for contextfree for deterministic contextfree types is solvable if languages is solvable and only if the proof by theorem equivalence of types reduces to equivalence of deterministic languages to prove the converse let ll and l be deterministic languages and let be a new symbol construct type definitions corresponding to ll and l as in the lemma then l l if and only if the defined types are va ml restrictions since deterministic a good deal language of effort equivalence has been on problem it may be a good idea attempts to restrict to solve the the range of definable equivalence types to keep the corresponding behaviors within some class algorithm we know of no example of a type that has a known that is of practical use for programming the idea of allowing definitions like was to facilitate the de of regular types not to allow new types so it might be reasonable to types proposition it is decidable whether a contextfree type is regular proof theorem give an effective procedure for constructing a deterministic pushdown from a def it is decidable whether a accepts a regular set the decision procedure of is rather complex it involves testing m an over nm mm states an alphabet for equivalence in practice one would probably with all finite like to restrict still further so that definable types are obviously regular automata having fewer than the definitions for example proposition if all applications of defined type constructors in a definition have the form te ek are regular proof where note each ei is either that the definition a builtin satisfies type or this j restriction then all types defined under these restrictions are all right linear the grammars constructed in of the proof of theorem n in of the above remarks it is of some theoretical interest can extend the range of definable types and still have an equivalence to see how algorithm far we under the restriction that no defined type constructor is applied to an expression containing a defined type constructor or type equivalence of types is decidable proof the restriction ensures that the automata constructed as in the proof of theorem are linear ie all push moves any pop moves on each input contains a proof that equivalence is decidable for linear all examples presented in this paper are linear references aho a v and unman j d the theory volume ii compiling of translation nj and compiling goguen j a and j w initial algebra cs switching and automata theory v ieee symposium on ifip working group with report of the on application to sorting w ab and may k and n pascal user manual and report science v springer verlag lecture notes in computer j the equivalence of modes and the equivalence ab march of finite automata algol b w et al report on the programming february language sigplan notices lewis c h and rosen b k recursively on principles of programming languages defined datatypes part mass i acm symposium c h algol ab liskov b et al abstraction group memo mechanisms in clu mit computation structures rosen b k and lewis c h recursively ibm t j watson research center defined datatypes heights part n y report rc m modes values and expressions programming languages palo alto tr computer science dept second acm symposium on principles of also available as tech cornell university n y m on type definitions with parameters publication pb university denmark november also available as chapter i of theoretical issues in the implementation of programming languages ph d thesis tech computer sciences department university of wi june r e a test september for pushdown machines inf and control u l b the equivalence inf and control problem for deterministic pushdown a van et al revised report acts informatica on the algorithmic algol w a london r l and m abstraction introduction to language and methodology university june and technical verification report in 