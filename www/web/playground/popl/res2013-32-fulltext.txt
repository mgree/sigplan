towards fully automatic placement of security sanitizers and benjamin microsoft research university abstract a great deal of research on sanitizer placement sanitizer correctness checking path validity and policy inference has been done in the last five to ten years involving type systems static analysis and runtime monitoring and enforcement however in much all work thus far the burden of sanitizer placement has on the however sanitizer placement in applications is difficult and developers are likely to make errors and thus create security this paper a different approach we aim to fully the placement of sanitizers by analyzing the flow of data in the program we argue that developers are better off leaving out sanitizers entirely instead of trying to place them this paper proposes a fully automatic technique for sanitizer placement placement is static whenever possible switching to run time when necessary runtime taint tracking techniques can be used to track the source of a value and thus apply appropriate sanitization however due to the runtime overhead of runtime taint tracking our technique avoids it possible categories and subject descriptors d software program verification validation d processors compilers d operating systems security and protection information flow general terms languages security verification keywords security analysis introduction tracking of explicit information flow has received a great deal of attention in recent years two primary applications for explicit information flow tracking stand out · preventing injection attacks within web applications such as and sql injection and · preventing private data leaks such as those recently observed in a variety of popular mobile applications permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm these attacks have motivated a great deal of research in the last five to ten years on sanitizer placement sanitizer correctness checking path validity and policy inference involving type systems static analysis and runtime monitoring and enforcement much academic work in this space focuses on finding missing sanitizers and is applied to relatively small applications several projects have explored the use of runtime techniques motivated in part by the scalability and precision challenges that static analysis typically additional motivation for exploring runtime techniques comes from the complexity of web applications with multiple potentially nested sanitizers which recent suggest is well beyond the ability of developers to address using static reasoning and code we also feel that the runtime approach is most practical in the long run however the overhead of runtime approaches can be considerable prior work on sanitizer placement dynamic sanitizer placement through a combination of inline instrumentation and instrumentation the main advantage of instrumentation is reduced overhead only library code as opposed to application code needs to be instrumented however approaches do not deal well with information propagated through code and data structures such as char byte and custom sanitizers custom sanitizers are quite common and sanitizers typically deal with string data at the level of characters the overhead of these approaches but is generally between ­ depending on the application in the case of instrumentation the depth of the data propagation path largely determines the overhead in large applications we know that data can a high number of transformations during its lifetime resulting in higher overhead than experiments with smaller applications would lead us to believe prior research has proposed the use of pointer analysis as a way to reduce the number of instrumentation points however the number of program points that are to be reachable from sources and may flow to is still quite large in practice leading to a high number of instrumentation points we feel that it is crucial to develop novel ways to decrease the performance for inline instrumentation to make it practical for simplicity in the rest of this paper we shall talk primarily about sanitizer placement for integrity preservation our techniques apply equally well to the placement of for confidentiality preservation figure motivating example of a small but flow graph sources are at the top are at the bottom we aim to fully the placement of sanitizers by analyzing the flow of data a key observation is that given a policy sources and within the application induce restrictions on the placement of sanitizers it is difficult for developers to place sanitizers so as to satisfy all of these restrictions especially in applications in fact we argue that developers are better off leaving out sanitizers entirely allowing them to be placed automatically in this paper we propose a fully automatic technique for sanitizer placement the goal is to minimize both runtime overhead and code due to instrumentation sanitizer placement is static whenever possible switching to runtime techniques when necessary we perform analyses on the interprocedural dataflow graph of the program to identify where sanitizers can be placed and where values must be tracked at runtime in order to determine which sanitizer to apply in order to reduce runtime overhead we to runtime tracking only when necessary sanitization policies large applications come with libraries of sanitizers developers are from writing their own sanitizers this is in part because most of the time they get them wrong since sanitizers are implemented as library functions they are typically pure functions with type string string policies can be given in the form of a table that for every type of data source and data sink indicates the appropriate sanitizer for values that flow from that source to that sink policies are declarative specifications and can both provide and simplify the code review process section gives examples of policies dataflow graphs and policies figure shows a simple dataflow graph that will be used as an example throughout this paper the policy for this example graph is shown in figure source types · are shown in rows and sink types are shown in columns we use as a special kind of source type and sink type for data production or consumption that is not relevant to security such as constant strings or other trusted sources of data thus we assume that every source and sink of data has a type that appears in the table entries in the table indicate which sanitizer should be applied to data we use metavariable p · s s s to range over policies i to range over source types o to range over sink types and s to range s s s s s s over sanitizers we write pi o for the entry in policy p for source i and sink o we assume that a node cannot be both a source and a sink and figure example policy sources shown shown means no sanitization required write n for the source type or sink type of node n for example in figure where ni is the node labeled with integer i we have n and n since n is neither a source nor a sink n is undefined for example let p be the policy in figure data from a source of type and going to a sink of type should have sanitizer s applied to it if pi o then no sanitization should be applied data from source type i to sink type o this may indicate for example that constant string data should not be before being displayed to the user contributions this paper makes the following contributions · fully automatic sanitizer placement we argue that sanitizer placement should be automatic given a policy and an application instead of the current approach of the being responsible for getting it right · placement we propose a simple strategy for static sanitizer placement while it is simple to implement and no runtime overhead it is incorrect for many dataflow graphs · placement we propose an strategy for sanitizer placement which attempts to place sanitizers statically and over into run time whenever necessary this strategy is appropriate to use when the simple strategy fails · correctness we define the correctness of sanitization of values in a dataflow graph and prove that our strategy for placement is correct · experiments we extensively evaluate how our placement strategies affect the number of instrumentation points on both large applications up to lines of code and generated dataflow graphs while the approach only a fraction of all nodes in most cases it fails to provide sanitization on all paths the approach while it requires more sophisticated analysis provides full sanitization while reducing the number of instrumentation points by × on average our technique works even better in the case of a precise underlying dataflow graph for generated graphs we see a reduction in the number of instrumentation points as high as × compared to the version paper organization section presents examples that the need for automated sanitizer placement section gives an overview to our approach for automatic sanitizer placement section presents dataflow analyses and algorithms to implement our approach section describes our experimental evaluation related work is discussed in section finally sections and describe future work and conclude motivating examples our of applications has shown that data processing is typically performed via a fixed set of sanitizers whose proper selection depends on the kind of source and sink and can be expressed as a table as in figure sanitization policies in this section illustrate the complexity of realworld data manipulation scenarios web applications the en security api is an url web input application security library usage of reveal that the cor sanitization to apply to data depends on how the data will be used that is on the sink context to a url function should be used but to user in put that will be used to construct a attribute function should be used web application roles in web applications sanitization requirements often vary based on who is interacting with the application this is referred to as sanitization for example allows authors to insert certain html tags in their that may not similar approaches are taken by and this complexity is reflected in sanitization libraries such as html sanitizer library and html where the can select different policies for sanitization of html this source sensitivity arises because not all users are created equal and that authentication provides a degree of trust and increase of capabilities that is not for users consider a web application us ing a public for storage the web application output wants to use the for input ability and to reduce storage hardware costs but does not fully trust the to protect the confidentiality of its data the application therefore will use encryption when ing data to the database and decryption when in this scenario the sources are of types input and and are of types output and the policy would data before it goes into the and it on the way out of the the correct sanitization to apply if any depends on both the source and sink of data mobile app privacy and security previous studies have shown that applications on and other mobile platforms leak user data to untrusted one solution is that the needs to filter out private data before it is allowed to go outside however the app often has reasons to send user input and data outside consider a app that needs to communicate with its parent site or its host in this case it is necessary to send information to that url including files on the local system if those are to be attached to email etc there is perhaps no need to send user data to a mobile whose library is embedded in the app and so data sent to a should be ie should have sensitive information removed a form of declassification this the need to treat the site differently from sites source types for this scenario are user input data from host and data from site sink types are screen output isolated app storage send to host and send to site data sent to a third party site that does not from the third party site should be also data being shown to the screen might need to be or checked for integrity in some way which we we refer to in the table below as no other sanitization or declassification is required screen output isolated to to app storage host site user input host site properties of the placement problem sink sensitivity sanitization is sink sensitive sanitization to apply to data depends on how the data will be used source sensitivity sanitization is source sensitive the correct sanitizer to use on data depends on where the data comes from source sensitivity also makes full automatic sanitization as by et al difficult as in and by et al sanitization is contextsensitive to choose the proper sanitizer the nested context needs to be determined consider the following of html code which a comment the value untrusted when the element is div this hidden comment div the untrusted comment is in two nested contexts it is in the attribute of an html tag and it is in a javascript string context to properly the untrusted comment we must ensure that the untrusted comment does not contain either javascript or html in general more than one sanitizer may be needed on a path between a given source and a sink we model this using a single function to represent the composition of sanitizers as required not idempotent or reversible note that sanitizers are not guaranteed to be either idempotent or reversible meaning that we cannot apply them more than once a recent study shows that out of sanitizers considered are idempotent and that only are reversible moreover order is important as less than of pairs of sanitizers commute finally is also a significant issue which often leads to data overview in this section we define the problem and present an overview of two solutions a completely static solution and an solution that uses static analysis and runtime taint tracking the static solution no runtime overhead but doesnt always result in correct sanitization the solution is always correct but may runtime overhead due to taint tracking valid sanitizer placement problem a dataflow graph g n e is a directed graph over a set of nodes n with edges e that describes how data flows through a system nodes represent computation andor storage locations and edges represent the flow of data in the system as the program performs computation values traverse the dataflow graph following edges in the graph with nodes representing both computation performed on values and where values are stored during execution a dataflow graph may have cycles in it this work is not directly concerned with the precision or soundness of the analysis used to produce the dataflow graph improvements to the precision and soundness of analyses for dataflow graph construction will improve the quality and soundness of our results our focus is to ensure correct sanitization of data in a program and as such we require an interprocedural dataflow graph suppose policy p describes which sanitizer should be applied to data traversing a dataflow graph we aim to provide sanitization for values traversing the dataflow graph according to the following correctness definition definition given a dataflow graph g n e sanitization for the graph is valid for policy p if for all source nodes s and all sink nodes t · if p s t s then every value that flows from s to t has sanitizer s applied exactly once and no other sanitizer is applied · if p s t then every value that flows from s to t has no sanitizer applied we require that a sanitizer be applied at most once on any given path because sanitizers are not necessarily idempotent applying it multiple times might result in incorrect sanitization we require that sanitizers are not applied we model multiple potentially nested sanitizers as a single composite sanitizer we consider two strategies for sanitizer placement a formulation section that is efficient but may fail to produce valid sanitization and an formulation section that always provides correct sanitization but may require runtime taint tracking in order to determine the correct sanitizer to apply we assume that the dataflow graph g n e does not contain any node that has both multiple incoming edges and multiple outgoing edges this assumption is without loss of generality since if a graph does not satisfy this requirement it can easily be transformed to one that does by the insertion of nodes this assumption is required for the correctness of the formulation and is analogous to assumptions in controlflow graph analysis of possible exclusive s s s s figure and nodes for figure the absence of critical edges edges that go from nodes with multiple successors to nodes with multiple predecessors formulation we say that a node n is if it is on a path from a source node s to a sink node t that requires sanitizer si that is p s t si thus if n is then at least some of the data passing through node n requires application of si we say a node n is if it is and it is not for any j i in other words node n is if it is and for any source s and sink t if n is on a path from s to t then that path requires sanitizer si ie p s t si definition node n n is if there is a source node s and sink node t such that n is on a path from s to t and p s t si definition node n n is if it is and for all source nodes s and sink nodes t if n is on a path from s to t then p s t si figure shows possible and exclusive nodes for sanitizers s s s and for the dataflow graph of figure note that while possible nodes are exclusive nodes are in fact s and have no exclusive nodes at all note that node n is on a path both from n to n and from n to n however it is because both n and n require the same sanitizer when going to sink p p s for dataflow graphs exclusive nodes will be more exclusive nodes are good candidates at which to apply a sanitizer to all data passing through the node however exclusive nodes are not necessarily unique there may be multiple nodes on a single path from a source to a sink if there are multiple nodes on a path we need to choose just one of them at which to apply sanitizer si since in many common applications of data sanitization a value is larger than the value eg special characters in a string will increase the length of the string we prefer to perform sanitization as late as possible we say that node n is if it is and for every path going through n it is the last node on that path definition node n n is if n is and for every source node s and sink node t and for every path from s to t if n is on that path then n is the last node on the path by this definition we see that in figure nodes n n and n are exclusive nodes for sanitizers s s and s respectively node n is not an exclusive node since there is another node later on a path from n it is easy to see from the definition that for any path from source node s to sink node t with p s t si there is at most one node on that path there may however be no node on a path if there is a path from source node s to sink node t with p s t si but there is no node on that path then placement will not values from s to t on that path thus placing sanitizers only at nodes may fail to produce a valid placement definition as will be seen in section the static approach does not produce a valid placement for all but simple and sparse dataflow graphs formulation we consider instead an formulation that is able to always find a correct placement of sanitizers in a dataflow graph although it may be necessary to record and track at run time some information about the path that a value has taken in the graph in order to determine the correct sanitizer if any to apply to the value figure summarizes the key concepts used in our solution we provide full definitions and intuition for each of these terms below we say that an edge e is source dependent if the sanitization to apply to values traversing e depends on which source produced the value definition an edge e is source dependent if there exist sources s and s and t such that e is on a path from s to t and on a path from s to t and p s t p s t ie the sanitizer to use depends on the source similarly we say an edge is sink dependent if the sanitization to apply to values traversing it depends on which sink the value will go to definition an edge e is sink dependent if there exist source s and t and t such that e is on a path from s to t and on a path from s to t and p s t p s t ie the sanitizer to use depends on the sink intuitively if an edge is sink dependent then when a value traverses the edge we do not yet know which sanitizer to apply by contrast if an edge is source dependent we do not know which sanitizer to apply to values traversing the edge unless we know from which source the value if an edge is neither source dependent nor sink dependent then all values traversing the edge are meant to have the same sanitizer applied we say that edge e is source sink independent if it is not source sink dependent in figure the edge from node n to node n is both source dependent and sink dependent it is sink dependent because it is on paths from n to both n and n but p n n s s p n n it is source dependent since it is on paths from both n and n to n and p n n s s p n n the edge from node n to node n is source independent since only one source node can reach it but is sink dependent trigger edges to apply a sanitizer at a edge we must know from which source a value we can use runtime tracking to taint a value so that we can determine its source however runtime taint tracking can be expensive and we do not need to track all values manipulated by the system just those for which we need to know the source in order to determine which sanitizer to apply we identify edges where it is necessary to start runtime tracking of values and edges where if we were tracking it suffices to stop tracking edge e is an edge if it is a edge but has an edge after it that is source dependent edges are the edges where we have sufficient information to know where a value from and need to start runtime tracking because the origin of a value affects which sanitizer to apply if e is an edge from node n to n then there must be at least one other edge going to node n since n is a node where paths from different sources merge definition edge e is an edge if it is a edge from node n to node n such that there exists a edge n n edge e is an edge if it is a edge that is by a edge e if we were tracking runtime values as they traverse edge e then we no longer need to track them when they traverse edge e if e is an edge from node n to n then there must be at least one other edge leaving n since n is a node where paths from different sources to different split definition edge e is an edge if it is a edge from node n to node n such that there exists a edge n n once we have a value we will not need to perform runtime tracking for the value this is an invariant that our runtime discipline will enforce only values that require sanitization and have not yet been will be tagged at run time because runtime tracking of values can be expensive we typically want to perform sanitization as early as possible we can only perform sanitization at edges because at edges the sanitization to apply depends on the future use of the value sanitization edges are the possible edges at which we can perform sanitization they are edges that are the edge for some path from a source to a sink that is if e is a sanitization edge then for at least one path from a source to a sink it is the edge definition edge e is a sanitization edge if it is a edge and there is a source node s and sink node t such that e is the edge on a path from s to t figure shows the edge edges edges edges and sanitization edges for our running example from figure for example edge n n is an edge since it is source independent but has a successor edge n n that is source dependent edge n n is a sanitization edge as it is the edge on the path from node n to n note that edge n n is not a sanitization edge even though it is sink independent this is because any path that goes through n n must first go through the sink independent edge n n in addition figure shows for each edge e the policy table at e this is simply the policy table p restricted to the source types i and sink types o such that e is on a path from a source node of type i to a sink node of type o policy tables at edges are a useful concept for computing an appropriate placement and will be used in section definition the edge policy at edge e is the restriction of the global policy p to include only source types i and term edge edge edge edge sanitization edge tag edge untag edge carry edge brief description sanitizer to apply to values traversing the edge depends on which source type the value from sanitizer to apply to values traversing the edge depends on which sink type the value will go to edge with a successor edge with a predecessor edge on some path from a source to a sink edge that dominated by sanitization edges start runtime tagging of values either a sanitization edge or an edge that is not dominated by sanitization edges stop runtime tagging of values edge that a is reachable from a tag edge without an untag edge and b can reach an untag edge and c is neither a tag nor an untag edge to propagate runtime taint values figure summary of terms for placement sink types o such that e is on a path from a source node of type i to a sink node of type o we write pe for the edge policy at edge e tag untag and carry edges edges and edges help us identify where we may need to start and can stop runtime tracking of values however we can refine these notions to reduce the amount of runtime tracking we must perform intuitively runtime tracking is necessary only when a sanitization edge needs to distinguish values coming from different sources these are exactly the sanitization edges that are source dependent we need to propagate taint information only along edges and only until we the value this also means that we only need to start taint tracking which we refer to as tagging data when data values move from a edge to a edge and the data is not yet and will need sanitization in the future similarly we can stop taint tracking which we refer to as data when tagged data is or when it moves from a edge to a edge specifically a tag edge where we tag values at run time and start the runtime taint tracking are edges such that a value traversing the edge might be and require sanitization in the future a value is if it has not through a sanitization edge and thus the tag edges are edges that are not dominated by a sanitization edge note that an edge dominates itself and thus a tag edge cannot also be a sanitization edge definition edge e is a tag edge if e is an edge that is not dominated by sanitization edges an untag edge is an edge such that a tagged value can reach it ie it is not dominated by sanitization edges and we no longer need to track the tagged values it is either a sanitization edge since after sanitization we no longer need to track taint or an edge definition an untag edge is either a an edge that is not dominated by a sanitization edge or b a sanitization edge at tag edges we tag values and start taint tracking and continue taint tracking the tagged value until it reaches an untag edge if the untag edge is a sanitization edge we apply the appropriate sanitizer otherwise the untag we define in dataflow graphs as follows edge e is dominated by edge e if any path from any source that ends with edge e must contain e tag tag carry tag tag carry figure policy tables are shown at every node and trigger edges are marked edge is an edge and we can stop taint tracking note that if we stop a value at an untag edge we may potentially resume taint tracking if the value later another edge not dominated by sanitization edges edges between tag edges and untag edges will need to propagate tag values we refer to these edges as carry edges definition edge e is a carry edge if e is on a path from a tag edge to an untag edge such that the path does not contain an untag edge that is if edges e en are a path where e is a tag edge en is an untag edge and e en are not tag edges then edges e en are carry edges in figure edge n n is a tag edge it is an edge since it is source independent and successor edge n n is source dependent that is not dominated by sanitizer edges by contrast edge n n is an edge but it is not a tag edge since it is dominated by sanitizer edge n n this means that any values traversing n n will already be and so there is no need to track their source type in order to determine which sanitizer to apply in figure all untag edges are sanitization edges edge n n is a carry edge as it is on a path from tag edge n n to untag edge n n without an untag edge edge n n will propagate the tags that tag edges n n n n and n n create and enable sanitization edges n n and n n to apply the appropriate sanitization runtime taint tracking for sanitization we have defined several different kinds of edges that are relevant to the runtime discipline for applying correct sanitization to values sanitization edges tag edges untag edges and carry edges we summarize what the instrumentation for these edges is required to do at run time · tag edge when a value traverses a tag edge if the value is not tagged then tag the value with one of the source types reaching it a reaching source node and its type can be statically determined by examining the edge policy multiple source types may reach the tag edge and any can be used since tag edges are source independent · untag edge when a tagged value traverses an untag edge untag it · sanitization edge if the sanitization edge is not by a carry edge then no tagged values can reach this edge and all values traversing this edge should have the same sanitizer applied otherwise apply sanitization only if the value is tagged by looking up the tag which is a source type in the edges policy table to find the appropriate sanitizer to apply which might be in which case no sanitization is applied · carry edge when a value traverses a carry edge any taint on the value must be propagated for example in figure consider a value from source node n to sink node n at tag edge n n the value will be tagged with its source type n the value with its tag will be propagated over carry edge n n upon reaching sanitization edge n n its tag will be examined and the appropriate sanitizer s applied note that the tag was needed for n n to determine which sanitizer to apply since a value from source node n could also traverse that edge requiring no sanitization note that if an edge e is not a tag edge untag edge sanitization edge or carry edge then e requires no instrumentation as no tagged value will traverse e and e does not need to perform any tagging or sanitization for example in figure edges between nodes n and n require no instrumentation correctness of placement the placement produces a valid placement definition we present here the key lemma that proves this lemma for every path from a source node s to a sink node t the following conditions hold for values along that path there is at least one sanitization edge on the path if p s t then no sanitization will be applied if p s t then sanitizer p s t will be applied at the first sanitization edge no sanitization will be applied at the second or subsequent sanitization edges proof condition holds from the definition of sanitization edges and because an edge whose target is a sink node must be sink independent let e en be a path from a source node to a sink node and let ei be the first sanitization edge conditions and hold by the following argument if ei is source independent then all values traversing ei will have the same sanitization applied either sanitizer s if p s t s or no sanitization if p s t suppose that ei is source dependent then there must be some other source s such that there is a path from s to ei and some output t reachable from ei such that p s t p s t since e is source independent and ei is source dependent and the first sanitizer edge there must be some edge ej on the path e ei such that ej is a tag edge and all edges ej ei are carry edges thus at ej the value will be tagged with source type s or some other source type i such that p s t pi t the carry edges will propagate this tag and so at sanitization edge ei the correct sanitization will be applied suppose that condition does not hold then there is some edge ek in path ei en such that ek is a sanitization edge and ek applies sanitization to values traversing path eo en since ek is a sanitization edge it is the edge on some path from source to a sink and so there must be some other source node s that can reach ek since ek is the first edge on a path from s there must be another edge leaving where denotes the source node of edge e such that on that edge some sink node t is reachable that is not reachable from ek and p s t p s t more over since has multiple edges coming from it by assumption that the dataflow graph has no nodes with both multiple successors and multiple predecessors node has a single predecessor edge ek and so ek is also on the path from s to ek therefore edge ek must be source dependent since ei can reach t and ei is sink independent it means that either p s t p s t or p s t p s t now consider whether ek is a carry edge suppose ek is a carry edge we will show that none of the edges on ei ek can be a tag edge and thus a value coming from ei cannot be tagged and so at sanitizer ek no sanitization will be applied this contradicts the assumption that condition doesnt hold note that ei is not a tag edge as it is a sanitization edge then there must be some tag edge em between ei and ek since it is not dominated by sanitizer edges there must be a path from a source node s such that s s to without a sanitization edge since em is an edge it is source independent that means that for all sink types o reachable from em and all source types i that can reach em we have s o i o but any sink type o reachable from em is also reachable from ei and ei is sink independent that means that for any sink types o and o we have s o s o together these imply that em is sink independent since for any source i that can reach em and o and o that can be reached from em we have i o s o s o s o em is source independent o is reachable from ei ei is sink independent and o is reachable from ei s o i o em is source independent but then em is the first edge on the path from i to em and so it is a sanitization edge this is a contradiction as em is a tag edge suppose ek is not a carry edge edge ek is an untag edge since it is a sanitization edge note that ek is not a tag edge since it is source dependent but since ek is source dependent and ek is the first sanitization edge on the path from s to ek then there must be a tag edge on the path from s to ek without any untag edges between it and ek therefore ek is a carry edge which is a contradiction the correctness of the placement follows trivially from lemma and the fact that no edge other than a sanitizer edge applies sanitization optimizations there are several opportunities for optimization in the placement approach remove sanitization edges for simplicity of the presentation and the proof we have defined the behavior of tag edges and sanitization edges treating no sanitization as if it were a sanitizer if a sanitizer is not by a carry edge and the policy that no sanitization should be applied then the sanitization edge does not perform any computation and should not be instrumented similarly if a tag edge is tagging a value with a source type that will never require sanitization then the tag edge can be removed and the value never tagged this optimization is valid because a sanitization edge that may receive tagged values will never an value sanitization edges by carry edges for simplicity we required that any sanitization edge by a carry edge needed to check the runtime tag before applying sanitization there are some situations statically where a sanitization edge will be by a carry edge yet all values going through it should have the same sanitization applied in figure edge n n is an example of this the preceding edge n n is a carry edge but n n is source independent and the first sanitization edge on any path that goes through it thus all values traversing n n will have sanitizer s applied so there is no need to examine the tag tags to runtime values we the runtime taint tracking being implemented simply by tags to runtime values this is a strategy that works well for dynamic languages such as java php or javascript the tags can be quite compact we have described it above as tagging a value with the source type that it from or a source type with equivalent sanitization requirements but it would suffice to use bit strings that uniquely identify a source type the number of sources depends on the policy but will typically be small meaning that a tag of ­ bits would suffice there are opportunities for efficient implementation of when the tags are this small such as placing the tag within the value header at run time with this tagging approach instrumentation for carry edges becomes trivial since tags will be copied if they exist thus the only instrumentation required will be to tag values as they traverse tag edges untag them as they traverse untag edges and apply sanitization at sanitization edges semilattice top initial value transfer function meet operator direction l t f n x y set of source types add n to set identity union x y forward if n is a source otherwise a available source types semilattice top initial value transfer function meet operator direction l t f n x y set of sink types add n to set identity union x y backward if n is a sink otherwise b sink types figure available source types and sink types efficient lookup for sanitization since the number of possible tags that can reach a given sanitization edge is small and known statically we can a lookup table for each sanitization edge that maps the tag number to the required sanitizer thus runtime early vs late sanitizer placement the static placement strategy performs sanitization as late as possible at nodes the placement performs sanitization as early as possible at the edges the reason for this difference is that for the purely static placement it is slightly better to perform sanitization late as many common sanitizers increase the size of data and thus place additional on memory by contrast for placement early sanitization will reduce the amount of runtime taint tracking required and we believe the cost of any runtime taint tracking the cost of increased size of data from sanitization placement algorithms in this section we propose concrete algorithms for computing the sets and relations described in section at the core of these computations we have dataflow analysis as described in aho et al as we will see we can often stage our computation and break it down into a series of two or three analyses one after another as et al observe this is often compared to a more complex approach because each analysis stage completes quickly placement to implement the placement strategy we compute the set of nodes that are and for each sanitizer si for i ranging from to k to combine the computation of these properties for different sanitizers si we use bit vectors as our representation generally a at position i for a value at node n n means that the property either possibility or holds for si first we compute available source types and sink types at every node using a dataflow analysis as shown in figure we specify dataflow analyses by giving the semilattice top initial value transfer function meet operator direction l t f n x y bit vector of length k ¯ ¯ bit i if n is identity otherwise or xy backward figure computes exclusive lattice of dataflow facts the initial values of start nodes source nodes for forward analyses sink nodes for backwards analyses the transfer function for nodes and the direction of the dataflow analysis this is a complete specification of the dataflow analyses we then combine the available sources and information as described in algorithm to determine for each node which sanitizers are possible at every node this is done by the policy table to only the available source types and sink types we write p s t for the policy table that contains only the rows of policy table p for sink types s and only the columns of p for sink types t if at node n sanitizer si appears in policy table p then n is algorithm possible nodes for all n n do for all si p do n the nodes that are are a subset of nodes that are computing nodes is a simple matter of removing from the set of nodes any node that is for any i j as shown in algorithm algorithm exclusive nodes for all i k do for all j k do if i j then for all n do if n then n the last step is to compute nodes nodes that for some path from a source to a sink are the last node on that path figure describes a backward dataflow analysis that identifies for each si which nodes can reach an node we write exclusive for the set of nodes that can reach a node nodes are simply the set of exclusive nodes the set of nodes algorithm algorithm nodes for all i k do for all n exclusive do n we place sanitizer si at all nodes that are nodes may be especially in graphs for the graph in figure this algorithm will place sanitizers only at nodes n n and n however this semilattice top initial value transfer function meet operator direction l t f n x y bool true true true if si n identity otherwise conjunction x y forward figure detect whether static placement is valid is clearly because not all values traversing the graph will be such as values from source node n to sink node n figure describes a dataflow analysis to detect whether all paths from sources to go through a node dataflow facts are booleans indicating whether all paths to the node have through a node by construction a path can have at most one node so there is no need to count the number of nodes on a path the static placement is valid if and only if the dataflow analysis produces a value of true at all sink nodes if the static placement is valid then it can be used to correctly all values with no runtime overhead if the placement is not valid then the placement can be used to ensure correct sanitization with some runtime overhead placement to implement the solution we must identify several different sets of edges summarized in figure we present algorithms to compute each of these sets of edges edges and edges first we compute the available source types and sink types for every edge similar to the dataflow analyses in figure however whereas figure computes dataflow facts for nodes we need to compute dataflow facts for edges next for each edge e we compute edge policy pe policy table p restricted to the available source types and sink types of edge e we use edge policies to identify edges and edges edge e is source dependent if and only if pe has more than one unique sanitizer in any column edge e is sink dependent if and only if pe has more than one unique sanitizer in any row and edges recall that edges are edges with a successor edge and edges are edges with a predecessor edge we can compute these edges efficiently simply by inspection of the dataflow graph let in trigger denote the set of edges and out trigger denote the set of edges sanitization edges sanitization edges are edges that are the edge on some path from a source to a sink they are the edges at which sanitization will be performed at edges the sanitization to apply to a value does not depend on which sink the value will go to figure presents a dataflow algorithm for computing sanitization edges note that the analysis computes dataflow facts for edges dataflow facts are pairs of boolean values the first value is true for an edge if and only if all paths to the edge go through a edge the second boolean value is true for sanitization edges edges that are the first edge on some path which is exactly the edges that are sink independent and have at least semilattice top initial value l bool × bool true true false false transfer function t f e fe fe true if e is sink b independent a otherwise true if fe true and b a false false otherwise meet operator x y pointwise direction forward figure computes semilattice top initial value transfer function meet operator direction l bool true false true t f e identity x y x y forward if e is a sanitization edge otherwise figure computes dom whether edge e is dominated by sanitization edges one path to it that does not go through a edge note that the transfer function for edge e is given as a pair of functions fe and fe each of which is a function from the input dataflow fact a pair of boolean values a b to a boolean value tag and untag edges tag and untag edges are where we respectively start and stop runtime tracking of values the definition of both tag and untag edges relies on identifying edges that are dominated by a sanitization edge for which we use the dataflow analysis in figure we write dom if edge e is dominated by sanitization edges if e is a sanitization edge then dom is true the following algorithm computes the set of tag and untag edges tag edges are edges that are not dominated by sanitization edges untag edges are either sanitization edges or edges that are not dominated by sanitization edges algorithm tag and untag edges for all e e do if e in trigger then tag tag e if e out sanitization then untag untag e carry edges finally carry edges are those on a path from a tag to an untag edge that does not pass through an untag edge the set of carry edges can be computed by first performing a forward dataflow analysis to compute tag set of edges that are reachable from a tag edge without an untag then performing a backward dataflow analysis to compute untag the set of edges that can reach an untag edge these dataflow analyses are shown in figure carry edges are the edges that are in both the semilattice top initial value transfer function meet operator direction l t f e x y bool false false true false identity xy forward if e tag if e untag otherwise a computes tag available reachable from tag edge without untag edge semilattice top initial value transfer function meet operator direction l t f e x y bool false false true identity xy backward if e untag otherwise b computes untag can reach untag edge figure dataflow analyses for carry edge computation benchmark dll kb loc alias management application app software field management management new report support relationship management figure benchmark applications sorted by code size tag available and untag sets as defined in the following algorithm algorithm carry edges for all e e do if e tag available e untag then if e tag e untag then carry carry e experimental evaluation our evaluation focuses on comparing the number of instrumentation points using our sanitizer placement algorithms compared to a implementation that performs dynamic taint tracking between all sources and our target applications are server applications runtime overhead of taint tracking is typically specific eg so we choose not to evaluate runtime overhead directly reducing the number of instrumentation points is a valuable goal since applications with have high code coverage over time many instrumentation points section presents the results of applying our techniques to large c web applications written in section evaluates our approach against large constructed graphs large applications figure contains a summary of information about our these are relatively large web application graph taint nodes nodes sources forward backward both ratio exclusive nodes sanitization all le ratio coverage alias management windows experience management new report support relationship management figure analysis and its effectiveness total taint dependent edge count edges sources forward backward both ratio source sink in out sanitizer tag untag carry total ratio application alias management windows experience management new report support relationship management figure analysis and its effectiveness reduction in number of instrumented edges is shown in last column applications written on top of the framework consisting of several separate as shown in column not all code contained within the application source tree is actually to the web server most of the time the number and size of primarily consisting of net bytecode is a good measure of the application size as shown in column note that in several cases libraries supplied in the form of without the source code constitute the part of an application finally to provide another measure of the application size column shows the traditional metric for all the code within the application note that correct manual sanitization for these applications is a challenge as explored in the project we therefore believe that fully automatic placement is a better alternative policy there are applications ranging from of sands of lines of code to over a in the case of the relationship management application we classified sources and into the three categories normal file resource based on their functionality ie normal file normal s s resource s s is a sink we used the policy shown in the table in this for these applications finally we completely existing sanitizers fully sanitizer placement placement figure contains the results of applying the placement strategy applications are represented as graphs some nodes of which are marked as sources or dataflow graphs are computed by the tool and are fairly sparse nodes of the graph are parameters and return results of individual methods in the application or its libraries edges represent data flow as inferred by a different static analysis tool could also be used to construct these graphs the precision and soundness of results is orthogonal to our approach the number of nodes column as well as sources and ­ ranges from to lower columns ­ summarize information about nodes in the graph column is nodes ie nodes that can be reached from a source node column is nodes ie nodes that can reach a target node column is both forward and nodes ie nodes that are on a path from a source node to a sink node and column is the fraction of these nodes compared to all nodes in the graph we can see that for a graph the percentage of such nodes can be quite high going higher than the implication is that a very high fraction of nodes needs to be instrumented to propagate the taint forward at run time columns ­ capture our exclusive node computation column is the number of exclusive nodes and column is the number of exclusive nodes column is the fraction of exclusive nodes within the nodes of the graph finally column shows the coverage which is the fraction of all paths that are properly with exclusive nodes two key from this table are as follows · the approach of on all nodes on a path from a source to a sink is very expensive with as many as of nodes to be instrumented and · while just the exclusive nodes requires less instrumentation the obtained coverage is sig coverage numbers are not available for the largest two application the large number of paths in the dataflow graph cannot be in reasonable time less than so the static approach is generally for sanitizer placement placement figure shows the results of applying the placement strategy column shows the number of edges in the graph columns ­ show the number of sources and respectively note that we use a slightly different policy for which nodes as marked as sources and compared to figure columns ­ show the number of forward and edges and edges in both directions column shows the percentage of edges in both directions as a fraction of the number of edges in the graph columns ­ show the number of edges and edges columns ­ show the number of edges edges and sanitizer edges columns ­ show the counts for the other kinds of edges computed by the formulation finally columns and show the number of edges instrumentation and the compared to the approach of edges that are both forward and we particularly in as described in section we do not count sanitization edges when counting edges that require instrumentation three key from this table are · we see that for most applications the percentage of edges that are forward and is quite high indicating that the underlying dataflow analysis of is quite leading to a great deal of within the dataflow graph · in terms of the number of instrumentation points in the last column of figure are × on average · in general our analysis is not as effective at reducing the number of instrumentation points for graphs the last several rows as it is for the graphs the first several rows graphs finally we evaluate our algorithm on some constructed graphs to build such graphs we start with sources and regular nodes we the type of the sources with equal probability and and the type of between and using the policy in figure for proper sanitizer placement we connect sources to by performing a random of length starting at a random source and ending at a random sink through the graph creating edges as we pass from node to node we use a density parameter d to vary how many such we perform the number of edges figure shows the improvements with instrumentation compared to instrumentation as the number of edges grows we can see that for sparse graphs the improvements are most at over × less only improvement for edges the improvements obtained with our strategy depends on the quality of the underlying dataflow graph results in figure suggest that our strategy performs better with dataflow graphs and performs worse when the dataflow graph is more highly connected since more precise analyses produce dataflow graphs since there are fewer conservative of dataflow instrumentation edges in graph figure graph results in precise static dataflow graph construction may improve the results of sanitization placement this conclusion with the experience of a number of projects that use static analysis to reduce the number of runtime instrumentation points if static analysis is the effect of this reduction is not very significant related work the most work is that of et al which considers the problem of type errors in programs by automatically placing statements in a program which explicitly information or the possibly information flow they construct a graph representation of information flow in a program such that source nodes are inputs and sink nodes are outputs a in this graph corresponds to a minimal set of program points such that insertion of statements at these program points would allow the program to type check their problem is similar to ours in that every path from a source to a sink must have a statement however their problem is simpler than ours because all paths require the same kind of statement by contrast our policies allow different pairs to require different sanitization as such we are unable to use a approach to identify sanitization program points also in our setting it is important to prevent values should have the appropriate sanitization applied exactly once by contrast it is though perhaps for a path from a source to a sink to have multiple statements et al share our goal of automatic sanitization but the details are very different our approach is designed to work on large applications written in languages such as java or c whereas they focus on much smaller programs in closure their technique is based on constraint satisfaction using a custom solver and has potential for scalability issues whereas our approach uses dataflow analysis with scalability properties analysis for information security several researchers have used program dependence graphs for analyzing information security of programs program dependence graphs include both data dependencies and control dependencies unlike the dataflow graphs we use in this work which typically contain just data dependencies et al consider enforcement of declassification using program dependence graphs however et al require certain nodes in a program dependence to be annotated as whereas we to infer where to insert and sanitizers software security analysis of web applications program analysis has a long history of being used for finding security bugs in web applications static analysis has been for php java and other languages multiple runtime analysis systems for information flow tracking have also been proposed placement most recently we have seen increased interest in decisions for the the use of a security type system for enforcing correctness is another case of with the to achieve better code quality and correctness guarantees sanitizer correctness et al show that custom sanitizer routines are often implemented our concerns in this paper are to sanitizer correctness the shows over two examples of strings that exercise common corner cases of web sanitizers the bek project proposes a systematic domainspecific languages for writing and checking sanitizers specification inference et al propose an approach to inferring information flow specifications sources sanitizers and using factor graphs et al propose inference as a way to infer specifications for static analysis checkers and propose policy inference to discover correct declassification policies graph algorithms and pre a range of algorithms from compiler literature is relevant for our work in particular et al describe lazy code motion et al describe a variant of it called sparse code motion partial redundancy elimination of pre is described by et al and and cooper future work the design of our placement strategies is motivated by realworld concerns for example in the strategy we perform sanitization as early as possible to reduce the amount of runtime however we do not offer a formal notion of optimality of our algorithms this is in part because it is what we should aim to optimize possible candidates include reducing the number of instrumentation points or runtime overhead for the worstcase or exploring these different notions of optimality in order to decide which is best requires building a more complete prototype our policy specification allows different sanitizers to be specified for all pairs however this may not be sufficiently expressive in all cases for example how do we properly the result of string data from two different kinds of sources we see at least two possible solutions to this lack of expressiveness one is to treat as computations that combine two or more source types effectively forcing proper sanitization to take place on values before computation occurs an alternative that works for some compositional operations eg string concatenation is to perform tagging so that the appropriate sanitizer can be applied to the appropriate bytes of the value another of our policy specification is that we a sequence of sanitizers into a single one this might prove to be a in some settings where keeping them separate would create interesting optimization opportunities we have described our approach as working on dataflow graphs that describe data dependencies we believe our approach could be extended to work on graphs that also record control dependencies however it may be difficult to ensure that sanitizer and correctly account for potentially control dependencies we also believe that the approach outlined here can apply to settings other than security consider the challenge of manually placing catch blocks in a program written in java or c this problem has a similar structure to the sanitizer placement problem instead of the dataflow graph we have the call graph of the program for source nodes we have statements that can throw exceptions instead of sanitizers we have catch blocks finally there is only one sink the main function by the exit of which we generally need to catch all exceptions conclusions traditionally developers have been responsible for properly dealing with the possibility of injection attacks and information leaks in their code leading to numerous bugs especially in large complex code bases the algorithms presented in this paper the way for completely automatic placement of sanitizers and we proposed two strategies for automatic sanitizer placement the first is a entirely static approach that has no runtime overhead but in many settings will not correctly all values the second strategy is an approach that attempts to place sanitizers statically but uses runtime when necessary to determine the appropriate sanitization to apply to values the placement strategy will always values correctly and reduces the number of nodes that require instrumentation sometimes by as much as × compared to of values between sources and acknowledgments we thank the anonymous reviewers for their helpful comments we the helpful comments of and this research is supported in part by the national science foundation under grant no references a v aho m lam r sethi and j d ullman compilers principles techniques and tools addisonwesley d m b and m s lam improving software security with a c pointer analysis in proceedings of the international conference on software engineering may d m v n e c and g composing static and dynamic analysis to validate sanitization in web applications in proceedings of the ieee symposium on security and privacy may d a and c regular expressions considered in filters in proceedings of the international world wide web conference p and k d cooper effective partial redundancy elimination in proceedings of the conference on programming language design and implementation b and j dynamic taint propagation finding without information security technical reports january e and d efficient taint tracking for java in proceedings of the workshop on secure web services s k and a c myers enforcing confidentiality and integrity in web applications in proceedings of usenix security symposium m c e and g detecting privacy leaks in applications in proceedings of the annual network and distributed system security symposium w p bg l p j p and a n an informationflow tracking system for realtime privacy monitoring on in proceedings of the usenix conference on operating systems design and implementation v d and m dynamic taint propagation for java in proceedings of the annual computer security applications conference dec c and g flowsensitive contextsensitive and information flow control based on program dependence graphs international journal of information security ­ dec c j and f nodes noninterference in dependence graphs in nd international symposium on application of formal methods verification and validation c j and g information flow control for java based on path conditions in dependence graphs in ieee international symposium on secure software engineering mar p b d p and m fast and precise sanitizer analysis with bek in proceedings of the usenix security symposium aug a l n d q and a partial redundancy elimination for access path expressions software practice and experience may f c ch dt lee and sy web application code by static analysis and runtime protection in proceedings of the international conference on world wide web n c and e a static analysis tool for detecting web application short paper in proceedings of the ieee symposium on security and privacy d s d t s and s a security placement in proceedings of the european symposium on programming j o and b lazy code motion sigplan notes ­ april t p g back a y ng and d r from uncertainty to inferring the specification within in symposium on operating systems design and implementation b and m s lam finding security errors in java programs with static analysis in proceedings of the usenix security symposium b a v s k rajamani and a specification inference for explicit information flow problems in proceedings of the conference on programming language design and implementation june m martin b and m s lam finding application errors and security using a program query language in proceedings of the conference on object oriented programming systems languages and applications pages ­ m martin b and m s lam runtime protection for web applications technical report stanford university microsoft corporation microsoft code analysis tool net microsoft corporation microsoft web protection library http n mitchell g and h the of a datum an approach to modeling runtime complexity in applications in proceedings of the european ence on objectoriented programming systems languages and applications a s d j and d automatically web applications using precise in proceedings of the ifip international information security conference t and c v against injection attacks through contextsensitive string evaluation in proceedings of the recent advances in detection sept w and g static enforcement of web application integrity through strong typing in proceedings of the usenix security symposium w and g static enforcement of web application integrity through strong typing in proceedings of the usenix security symposium aug for filter o j and b sparse code motion in proceedings of the symposium on principles of programming languages a sabelfeld and a c myers languagebased informationflow security ieee journal on selected areas in communications ­ jan a sabelfeld and d sands dimensions and principles of declassification in proceedings of the th ieee computer security foundations workshop pages ­ ieee computer society june m p and d contextsensitive in web languages using type qualifiers in proceedings of the conference on computer and communications security oct p d and b automatic contextsensitive sanitization for web applications in proceedings of the conference on computer and communications security oct b c and c dependence analysis via graph reachability technical report sun v m d k s and v a security policy oracle detecting security holes using multiple api implementations in proceedings of the conference on programming language design and implementation z su and g the essence of command injection attacks in web applications in proceedings of the symposium on principles of programming languages o m s j m and o effective taint analysis of web applications in proceedings of the conference on programming language design and implementation j and s inference of expressive declassification policies in proceedings of ieee symposium on security and privacy may m p b d and n symbolic finite state transducers algorithms and applications in proceedings of the on principles of programming languages jan j p d m r and d a systematic analysis of sanitization in web application frameworks in proceedings of the european symposium on research in computer security sept y and a aiken static detection of security in languages in proceedings of the usenix security symposium e z yang html 