sdn policies university university university of massachusetts sagiv university university the academic college of abstract sdn is a new paradigm for operating and computer networks sdn enables control over network devices through a controller software that operates independently of the network hardware network operators can run both and sdn programs on top of the controller eg to specify routing and access control policies in practice having the controller handle events limits the network scalability therefore the feasibility of sdn depends on the ability to efficiently network by forwarding rules on the switches however a rule too early or too late may lead to incorrect behavior eg packets may be to the wrong destination or packets handled by the switch may hide information from the controller leading to incorrect forwarding behavior the second issue is subtle and sometimes even by programmers the contributions of this paper are two fold first we formalize the correctness and optimality requirements for network policies second we identify a useful class of network policies which permits automatic synthesis of a controller which performs optimal forwarding rule categories and subject descriptors d programming languages language application languages i artificial intelligence automatic programming program synthesis keywords network programming languages synthesis logic programming distributed systems introduction sdn is a paradigm for operating and computer networks sdn enables control over network devices through a controller permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright c acm software that operates independently of the network hardware in practice having the controller handle all network events limits network scalability therefore the feasibility of sdn depends on the ability to efficiently and correctly of network events by forwarding rules on the switches this problem can be difficult and error even for programmers in particular there is a subtle issue that is a cause of errors in sdn implementations namely when a packet at a switch the forwarding rules determine whether the packet is handled locally or sent to the controller but when should a packet be sent to the controller we say that an event e is relevant if there is some sequence of future events that can only be handled correctly if the controller knows about e if e is relevant then the switch must the controller about it on the other hand if e is irrelevant then from the viewpoint of network traffic and efficiency it is best for the switch to handle e locally and not the controller about it thus a switch needs to test whether or not an incoming event is relevant however is in general a secondorder property does there exist a sequence of future events that may be difficult or impossible for the switch to test in this paper we solve this problem we show how to automatically go from the specification of a network policy to its implementation as forwarding rules to be initially on the switches and updated in response to events occurring on the switches we make the following contributions we define the correctness and optimality of a implementation of a network policy our definitions are given in and more formally in secondorder logic we specify a firstorder language l for expressing network policies l is reasonably expressive furthermore we show how to automatically synthesize an optimal implementation of any network policy expressible in l we identify a property that we call causality and show that any network policy f expressed in l satisfies causality with the parameter k easily determined from f intuitively if a network policy has causality then instead of considering all possible sequences of future events we only need to consider sequences of length at most k using the causality of f we show that the above secondorder definitions of correctness and optimality for a implementation of f can be written simply in a fragment of firstorder logic with equality using quantifier elimination on the resulting formulas we show how to automatically derive quantifierfree implementation rules for f the latter can be automatically translated to forwarding rules which when on the switches result in a correct and optimal implementation of the input network policy f what this paper does not do there are many issues about the distributed control of a network ie how to send forwarding rules over the network to keep all the switches in a correct state as as possible we will consider some of these questions in future work in this paper we consider the problem of computing the local forwarding rules not how we send them over the network to the switches a related interesting question which we also do not consider in this paper is how to compute the incremental changes of the forwarding rules that is which rules should we add and remove in reaction to each new relevant event this paper is organized as follows section provides an informal overview of the problem addressed by this paper the terminology used in this paper is described in section the problem addressed by this paper is defined formally in section section provides necessary and sufficient conditions for and optimality our first order policy language is defined in section the algorithm for synthesizing forwarding rules is described in section related work is described in section overview this section provides an informal overview of the problem and how we solve it the reader need not be familiar with networks forwarding policies we assume that we have a finite set of switches each of which has a fixed set of ports ports connected to hosts and other switches the events of interest are events each of which represents a packet at some switch s on some input port the possible resulting action is for s to forward the packet along some set of ports p ports a policy is a specification of what action to take given an event and the history of all previous events the policy the behavior of every switch as a function of the global history of events as a running example consider the policy of a learning switch with host migration the learning switch locations of hosts in the network by analyzing the packets incoming on its ports initially it is to any packet ie send it to all ports except where it from while learning the location of its sender future packets whose location is already learned should be directly to the learned ports instead of it to all ports this eliminates unnecessary traffic it is possible for hosts to change their location ie to the learning switch that supports host migration should forward the packet to the port where the packets destination was last seen more precisely for a packet with destination d at switch s on port p if the history does not include any previous packet that at s with source d then s should the packet ie send it over all ports except p on the other hand if there was such a packet and the most recent of these on port p then s should send the packet only on port p distributed forwarding implement forwarding policies using switches that have limited expressive power along with a controller events can either be handled locally by the switch receiving the event or to the controller algorithm controller policy state initial state while new event e do action compute state e update e rules infer rules policy state send to end while the switches follow forwarding rules that determine the ports to which the packets are according to the attributes of the packet these rules also determine when the switch must forward the packet to the controller each set of rules defines a behaviour in the sense that it does not refer to the previous history of events the rules are and removed from the switches only by the controller in contrast to the switches the controller is stateful its behavior which includes the switches how to forward packets that were sent to it as well as forwarding rules on the switches for future packets may depend on the entire log of events that it has seen so far for that the controller may maintain the history of events it has received as part of its state algorithm a simple scheme of a stateful controller parametrized by the policy note that the policy of the learning switch described above cannot be implemented by a switch alone as the handling of the current packet requires access to the history of previous events in this work we focus on the rule inference component of the controller for scalability and performance as many events as possible should be handled locally by the switches however as shown next it is subtle to correctly forwarding rules in fact even current highlevel network programming languages including essentially require that the programmer specifies conditions that determine when forwarding rules can be see section correctness of forwarding rule this paper the notion of correctness of forwarding rule our formulation is inspired by the standard but it can be adapted to other distributed systems roughly speaking we say that a forwarding rule policy is correct with respect to a policy if all packets are to the right ports as defined by the policy since the policy defines the actions to be performed based on the full sequence of events while rule depends only on the packets that arrive to the controller correctness is in fact divided to the following two conditions every packet is to the right ports either by the rules or by the controller and packets are sent to the controller whenever necessary to formalize we define a notion of we call an event relevant if it may affect the future behavior of the system thus the second condition for correctness requires that all relevant events must be to the controller learning switch forwarding rules table contains several rule policies for the learning switch example each of them specifies a set of switch forwarding rules for any history h in the rules e denotes the current event packet notice that h does not appear in the rules themselves as the switches cannot access the history for simplicity we assume that the switches send a packet to the controller iff the forwarding rules do not determine any local action for the packet our techniques can also deal with rules that explicitly send some events to the controller trivial ls ls ls rule policy none for any e h for any e e h for any e h such that e h e sw e e e h such that e h e sw e e e src and e src table sample rule policies for the learning switch in terms of current events and histories e h respectively e e means that e occurred later than e in h figure a sample topology for a learning switch s with three ports and the trivial rule policy does not any rules and thus is correct but it is far from optimal as all events are handled by the controller the ls policy a rule to forward an event e to port p if the history includes an event that to the same switch as e on the port p and its source is the destination of e while this policy seems natural it is incorrect since it rules too early figure shows a sample topology with a single switch s and two hosts a and b and table presents a scenario where following ls results in incorrect behaviour the first event is a packet from a to b that occurred in the switch s and on port since the switch initially has no rules this packet is sent to the controller which it and also a forwarding rule according to ls to forward all packets in switch s whose destination is a to port this appears to be a correct forwarding as a result of this rule the next event of a packet from b to a is correctly to port by the switch but it is not sent to the controller hence the controller does not learn that b is connected to port consequently the third event another packet from a to b is while it should have been only to output port the ls policy avoids the bug of rule as it rules matching packets for which both the source and the destination locations have already been learned ls is implemented in most sdn systems it a rule to forward e to port p if the history includes an event that on switch s in input port p and its source is the destination of e and another event that on s with the same source as e this is a more policy which rules however it cannot with host migration table demonstrates an incorrect behaviour that happens when host a from port to port indeed after the second event when both the locations of hosts a and b were learned the switch will locally handle packets between a and b the third event a packet from a to b that on port after a is handled locally and is not sent to the controller accordingly the controller is not aware of as migration this again results in an incorrect behaviour as the fourth event from b to a is to port while a its new location in port ls is a correct rule policy with correct handling of host migration it a rule to forward e to port p if the last event in the history at switch s whose source is the destination of e in input port p the last event in the history at switch s whose source is the source of e in the same input port as e thus it only rules for handling packets that come from the last known location of some host table demonstrates how ls properly handles the scenario presented in table after the second event the rules match only events coming on the known locations of a and b consequently the third event after a is handled by the controller and thus the controller that a as a result the controller replaces the previously forwarding rules with two new rules and the event is handled correctly by the switch the example of the learning switch with migration shows that deriving a correct rule policy for a given forwarding policy is challenging even for simple and examples optimality of forwarding rule with correctness being the first criterion our goal is to also ensure that the forwarding rules on the switches allow the switches to handle as many events as possible locally such a forwarding rule policy is called optimal the trivial is whereas ls is optimal we show that having the rules handle all irrelevant events is both necessary and sufficient condition for optimality our approach our approach for inferring optimal rule consists of a static part which takes place at compile time and a dynamic part which operates at runtime the static part derives from the given policy a description of the optimal rule policy which determines for each history the rules that should be for the learning switch example this corresponds to obtaining ls see table the runtime component is executed by the controller whenever an event is to it and it is responsible for computing the updated rules to be on the switches by applying the rule policy on the current history of events we consider the history of events received by the controller as its state inferring rule policies in general inferring correct forwarding rule is undecidable see section in this paper we define a restricted variant of firstorder logic called l which is powerful enough to capture many useful forwarding policies and is amenable to automatic synthesis of optimal rule policies we then describe an algorithm for synthesizing an optimal rule policy for any given forwarding policy expressed in our logic for example for the learning switch it infers ls applying our procedure to the example from actually improves its implementation by more rules as demonstrated in section event s a b s a b s a b action forward s a forward table a scenario which reveals a bug in the forwarding rule policy ls controller actions are event s a b s b a s a b s b a action forward forward forward forward s a b forward s b a a from to table a scenario which reveals a bug in the the forwarding rule policy ls controller actions are event s a b s b a s a b s b a action forward forward forward forward forward s a b s b a a from to remove the previous two rules forward forward s a b s b a table a scenario the correct forwarding rule policy ls controller actions are formulation of correctness and optimality in firstorder logic the correctness and optimality conditions of policies refer to irrelevant events where of events is examined with respect to unbounded future sequences of events which naturally requires secondorder quantifiers nevertheless we identify a bounded causality property of policies and show that for policies this property the condition for an event being irrelevant can be equivalently specified in firstorder logic the bounded causality property states that there is a computable bound k such that if an event affects the behaviour for some sequence of future events then it will also affect the behaviour for some sequence of k future events this allows us to construct firstorder definitions of an optimal correct policy specification of policies we specify policies by formulas in l which are interpreted with respect to a history and a current event l allows any boolean combination of components where components are existentially quantified formulas in which all existential quantifiers are guarded they either refer to the existence of an event in the history denoted by y¯ h where h is a special symbol and y¯ is an event variable or they refer to the last event in the history that has some property denoted by y¯ last where y¯ is an event variable and is a formula for example the policy for the learning switch that supports of hosts is specified in l by the collection of formulas p one for each port p that define when to forward to p y¯ last p in addition the formula that defines when to perform is given by ¬p if instead of p above one takes y¯ h p this results in a policy that each packet to all ports in which the destination of the packet was seen before our design of l was by common sdn applications as well as by the ability to obtain the bounded causality property have this property l allows us to express restricted temporal properties using the last quantifiers or similar variants see section remark a possible extension is to also explicitly refer to order on events we did not augment this into l since it the presentation of our approach on the other hand l formulas cannot express policies that involve counting events in the history or require arithmetic operations such as advanced load we can however handle simple load based on fixed ip distributions another source of limitation is the restriction to boolean combinations of quantified formulas if we allow alternation of quantifiers the bounded causality property breaks see section static computation of rule policy for a policy expressed in l which the bounded causality property we are able to specify the optimal rule policy in firstorder logic extended with guarded quantifiers for example for a learning switch with migration for each port p we obtain the following formula p y¯ last note that when the rule policy refers to the history of events via guarded quantifiers it refers to the history that only consists of events that were sent to the controller as opposed to the forwarding policy that refers to the full history runtime rule after generating the firstorder formulas that express the optimal policy it remains to show that given a concrete history of events that to the controller the controller can dynamically compute the rules that need to be on the switches based on the policy where the rules do not refer to the history of events for this purpose we first remove the guarded quantifiers that still exist in the definition of the policy by using the actual history at hand next we remove the quantifiers using a quantifier elimination process the result is a set of quantifierfree formulas describing the forwarding rules to be terminology sdn is a particular form of a distributed system composed of a collection of components and a single controller the components are switches and the controller is the network controller events are events occurring in the switches next we precisely formulate the notions involved in defining the problem events q is a finite set of event attributes each attribute q q is associated with a possibly infinite set of values eq events are records with one field for each event attribute we will denote by e the set of all events in the context of sdn events are events packets that arrive at a switch and may or may not be to the controller the event attributes q include sw in src dst where sw is the switch receiving the packet in is the port through which the packet is received ports is a finite set of ports src is the source field in the packet header and dst is the destination field in the packet header if needed other fields may be included in q eg time stamp logical port information etc histories a history is a finite sequence of events from e in particular an event e is considered a history of length one h · h denotes the concatenation of sequences h and h we write h h to mean that h is a subsequence of h h is the set of all histories the size h of a history is the number of elements it contains e · · en n actions a is a finite nonempty set of actions in examples in this paper the set of actions is a ports drop where an action p ports represents forwarding a given packet to port p the action represents the packet ie forwarding it to all ports except for the port in which it was received and the action drop means the packet without forwarding it policies a policy is a function from h to e p a the set of nonempty subsets of a a policy defines the behaviour of the system where its input is the sequence of events history that occurred so far given a history h and a current event e f he determines the nonempty set of actions that should be performed in reaction to e when the next event e occurs the considered history also includes e meaning that the reaction to e will be each action in f h · ee here are some examples of policies for sdn switch all packets ie on all switches forward each packet to all ports except for its input port forward to port all packets on port forward to port a packet on port from source s if the history includes an incoming event on port whose destination is s in this scenario we assume that ports and are the only ports of any switch in the network where trusted hosts are all connected through port and untrusted hosts are connected through port learning switch wo migration for a packet in switch s with destination d forward it to port p if the history includes a packet that in s on the input port p and its source was d the port p must be unique since there is no migration of hosts if no such packet in the history the packet learning switch with migration for a packet in switch s with destination d forward it to port p if the history includes a packet that in s from source d and the most recent such packet has input port p if no such packet exists in the history the packet server there is a designated host ha as an server which sends special and packets to the controller communication is allowed only between hosts a host becomes when the controller receives an packet the host and may become if the controller receives a packet for that host it is also possible to compose several of the policies by applying different policies in each switch note that any computable policy f may be implemented via a controller that keeps track of the entire history whenever an event e occurs corresponding to switch s receiving packet p s the controller about e the controller then s to perform the actions f he and adds e to its log h h · e however sending all events to a controller creates a and makes the system not scalable a scalable system requires that many events will be handled locally by components implementing the policy in a and scalable way event handlers to formalize the concept of locally handling events by the components we introduce event handlers an event handler is a partial function from e to p a which returns a set of actions to perform for the events for which it is defined at any point in time the behaviour of the components is defined by an event handler r the domain of r is the set of events that are locally processed by the components without the controller whenever an event e occurs in some component if re is defined then each action in re is performed locally if re is not defined then the component the controller and further instructions below r denotes the set of all event handlers in the context of sdn event handlers correspond to sets of forwarding rules eg drop all packets into port and all packets into port with source field the empty event handler corresponds to the empty set of forwarding rules note that the controller also implements a total event handler at each point in time remark we view the set of switches as one abstract unit that implements a single joint event handler in practice the joint event handler is divided between the individual switches by taking into account the sw attribute of the events event handler generators an event handler generator is a function from h to r it assigns event handlers to histories in the context of sdn event handler generators correspond to forwarding rule policies whenever the controller processes a event sent to it by some switch it also computes a new event handler and it on the switches note that if there are different types of switches then a given switch only needs the forwarding rules to its type in practice only relevant changes to the set of forwarding rules must be sent to each switch let i be an event handler generator the ci h for a history h is defined inductively ci and ci h · e ci h · e ci h if he is not defined otherwise for a sequence of events h e · · · en ci h is the subsequence consisting of those events that are to the controller ie not handled locally thus ci h is the log that is saved in the controller since ci out exactly those events that are handled locally and thus not to the controller we have lemma for any event handler generator i ci is idempotent ie for every history h ci ci h ci h proof by induction on h definition given an event handler generator i we say that a history h is if h ci h for some history h namely h is if there is a sequence of events for which h is the corresponding log by lemma we have that h is iff h ci h combined policies let f be a policy and i an event handler generator to see how well f and i play together we define the combined policy of f with respect to i fi h e p a as follows fi he he f ci he if he is defined otherwise thus fi is the policy that according to i and to f when i is not defined the problem in this section we precisely define the problem definition an event handler generator i a policy f if fi f definition optimality an event handler generator i that a policy f is optimal if for every history h and every event handler generator i that f ci h ci h let i be a of f i is optimal if it sends to the controller exactly those events that every of f sends to the controller ie it only sends those events that it must send in the problem we are given a policy f and the goal is to produce an optimal event handler generator i that f in addition to the challenge of another challenge from the fact that the event handlers generated by i should be implemented in some restricted language that is amenable for on the components more formally suppose we have some restricted programming language t such that programs of this language can run on the components this language is used to implement event handlers ie partial functions from e to a remark in this paper we assume that the rules supported by the components are boolean conditions on event attributes each rule defines a boolean condition involving event attributes and perhaps some constants and an action that should be performed if the condition is satisfied by the current event in the context of sdn the components are the switches which support forwarding rules according to the standard the translation of boolean conditions of this kind to rules was addressed in in the context of the netcore network programming language an event handler generator i is called t suitable if there is an algorithm that given a history h produces a t description of ih definition the problem of a policy f relative to t is given by input a specification of a computable policy f output a t suitable event handler generator i that f and is optimal note that without the optimality requirement this problem has a trivial solution let i be the event handler generator that always returns the empty event handler for this generator we obviously have fi f in general the problem of is undecidable for example if f is defined in some formalism or using full firstorder logic as shown in section in the sequel we will identify a useful family of policies for which the problem can be solved automatically characterization of and optimality in this section we provide necessary and sufficient conditions for and optimality the results presented in this section were verified by means of the proof assistant coq we show that an event handler generator i f if and only if i with f and does not hide any events relevant to the behaviour of the system definition compatibility an event handler generator i is compatible with a policy f if for every event e and history h f he whenever is defined intuitively i is compatible with f if the event handlers generated by i always perform exactly the actions defined by the policy f definition an event handler generator i is transparent with respect to a policy f if f ci h f h holds for every history h recall that ci h is the subsequence of h that is sent to the controller when using i thus events in ci h are those events that the controller and the only ones that can affect its behaviour in general this of events can the correctness of the whole system an event handler generator i is transparent with respect to a policy f exactly if this filter does not break the policy f the following theorem gives a useful characterization of when an event handler generator a policy def theorem an event handler generator i a policy f iff it is both compatible and transparent with respect to f we now obtain an equivalent definition for using the notion of an irrelevant event definition an event e is irrelevant with respect to a policy f and a history h if f h · e · h f h · h for every history h the coq scripts are available at theorem i is transparent with respect to f iff for every history h ih is only defined for events that are irrelevant with respect to f and h from the inductive proof of the previous theorem we get the following as a corollary corollary i is transparent with respect to f iff for all histories h and h f h · h f ci h · h optimality we call an event handler generator for a policy f if it is defined on all possible events definition an event handler generator i is with respect to a policy f if for every history h ih is defined for all events that are irrelevant with respect to f and h theorem an event handler generator i that a policy f is optimal iff it is with respect to f optimal event handler generator combining theorems and we obtain that an event handler generator i f iff it is compatible transparent and with respect to f for any policy f we define the event handler generator that f and is optimal with respect to f as follows definition given a policy f the event handler generator is defined by f he undefined e is irrelevant wrt h f otherwise obviously is compatible with f and with respect to f its follows directly from theorem therefore f however note that even when f is computable may not be computable since is defined in terms of all possible histories h in the following section we show that for a useful family of policies the above definition can be used to automatically produce an optimal event handler generator firstorder specifications of policies in this section we introduce a formalism for describing policies via a fragment of firstorder logic this fragment is expressive enough for a variety of useful and interesting policies in the context of sdn in the next section we provide a solution to the problem for policies specified in this fragment ie an algorithm that an optimal suitable event handler generator for a given policy the language l syntax we use an extension of firstorder language that we call l as the basis for our specification languages · ls sorts are the attributes in q · equality denoted by is the only predicate symbol · l includes a constant symbol for any element d qq eq we will use the elements themselves as constant symbols · l ordinary connectives and quantifiers as in firstorder logic · to represent events l allows event variables event constants and selector functions as syntactic sugar for example assuming that q sw in src dst and the expression y¯ is a shorthand for the v sw v in v src v dst v v to have formulas one can equivalently take v src v dst v v in this case · l has a designated free event variable x¯ which we will use to refer to the current event · l has two additional kinds of quantifiers existential quantifiers of the form y¯ h where h is a special symbol and y¯ is an event variable of the form y¯ last where y¯ is an event variable and is a quantifierfree formula whose only free variables are y¯ and possibly the designated variable x¯ semantics define the logical structure m mq eq q q as follows · m has a domain eq for each sort q q · is interpreted as equality · each constant symbol d is interpreted as the element d eq the model m and a given event e naturally induce a satisfaction relation for quantifierfree with x¯ as their only free variable since m is usually fixed we write e to mean that m is a model in the usual sense of the semantics of l extends usual firstorder semantics it is defined with respect to the model m and a given history h and event e since m is usually fixed we write h e to mean m h e defined inductively as follows · if is a quantifierfree formula with x¯ as its only free variable then h e iff e · the propositional connectives are interpreted as usual · h e v q if h e dv for every d eq · h e v q if h e dv for some d eq · h e y¯ h if there is some e in h for which h e e y¯ · h e y¯ last if h e e y¯ where e is the last event in h for which e e y¯ if no such event e exists then h e y¯ last of event handler generators recall that the set of event handlers r is the set of partial functions from e to p a and an event handler generator is a function from h to r let i h r be an event handler generator let a a a be a set of where each a includes the variable x¯ as its only free variable we say that defines i if for every history h and event e · a a h e a whenever is defined · a a h e a whenever is not defined specifications of policies policies are functions from h to e p a as with event handler generators we specify a policy via a set of formulas a a a since policies define total event handlers it must be the case that for all histories h and events e a a h e a we will define policies in a restriction l of l which we now define first define a component to be a formula of l that has only and y¯ last last m h h where is quantifierfree the language l consists of all boolean combinations of components notation for an we denote by the number of occurrences of in and by k the number of occurrences of guarded existential quantifiers in we also define k k an is a policy defined by a set of the following property of will be crucial for our main results among other things it will allow us to automatically check that a set a a a l indeed defines a policy f ie that for all histories h fh is total we first introduce the following definition definition let be an e an event and h · en a history the kernel of h wrt and e denoted is defined to be a minimal set of indices n such that for every component of of the form y¯ last last m h h · for every j m contains the maximal index ast such that e j if such an index exists is the last event in h that satisfies the above and · if h e then includes some indices i ir st e y¯ note that the size of is at most k intuitively includes the indices of all events from h that determine whether h e therefore theorem let be an then for every history h e · and event e and for every subsequence h ej · of h such that j j we have h e iff h e proof let h e · · en be some history and e some event let h ej · be a subsequence of h such that j j we claim that for every component of we have h e iff h e indeed consider some component y¯ last last m h h of a crucial observation is that for j m any event e that is the last event in h that satisfies e y¯ is also the last event in h that satisfies this property furthermore there is no event e in h that satisfies e y¯ iff there is no such event in h suppose that h e then h e by definition of and due to the fact that any last event in h satisfying remains a last event in h for the converse suppose that h e then since all last elements of h are maintained in h and since h h which ensures that the events satisfying the history guarded quantifiers are also maintained we get that h e remark in theorem we use the set of indices to define a subsequence h of e · · en and we require inclusion of in the set of indices defining the subsequence h ej · · ej rather than requiring that h h the reason for that is that e · · en may contain of the same event for an event that appears more than once we must make sure to keep in h the correct occurrence index of the event to preserve the last elements therefore it is not enough to require that h h h for example suppose that y¯ last and let h where e and e both satisfy but only e satisfies then in this case h e and consisting of the index of the last element satisfying if we just consider the corresponding subsequence h e then for h ee we cannot guarantee h e iff h e even though h h this is because we kept in h the first occurrence of e where in fact we needed the second occurrence thus changing the last element when considering the sets of indices we see that indeed using theorem and the property that k we can check if a a a l defines a policy we need to check that for all histories and events at least one of the in a a a holds this amounts to checking that the aa a is valid theorem ensures that for the validity or satisfiability of an it suffices to consider only histories that include up to k events furthermore if we want to check that some set s of actions should never take place together eg drop we can verify that the policy admits these restrictions by checking that the formula as a is unsatisfiable remark the last quantifiers allow us to select some occurrences of events from a history and refer to their properties one can extend l to include additional selectors such as last k first k etc as long as they select a fixed number of occurrences of events from the history and in addition have the property that applying the selection on a subsequence of the history that includes all the selected indices will result in the same selection these properties ensure that theorem still holds when definition kernel is adapted accordingly of sdn policies now we give l specifications for the example policies from section recall that in the context of sdn q sw in src dst and the set of actions is a ports drop where ports is a finite set of ports present in each switch in the following we use p to denote a port in ports and the formulas for the actions that are not specified are assumed to be switch the policy for the is specified by the policy for the is specified by fw y¯ fw learning switch the policy for the learning switch is specified by y¯ h p learning switch with the policy for the learning switch that supports of hosts is specified by y¯ last p server to model the scenario we introduce an attribute type in q along with two constants a and d meaning that the sent message is an or respectively we assume that the server directly to the switch so we can model the of host h by a packet whose source is ha its destination is h and its type is a d the policy for the switch connected to an server is specified by ha ha y¯ last a y¯ last a where h ha h specification of event handlers we finally complete the description of the specification language by choosing the programming language t for the components to be the quantifierfree fragment of l the is that this is convenient for us and even very primitive components such as switches in the context of sdn can run this t more precisely t is the fragment l of l consisting of quantifierfree whose only free variable is x¯ a collection ra a a of such formulas defines an event handler r if the following hold for every event e · re a a e ra whenever re is defined · a a e ra whenever re is not defined for example the event handler r which all packets in port and is undefined for all other events is specified in l as and ar for all other actions a undecidability of of if we allow to define policies using formulas in the unrestricted language l instead of l the problem becomes undecidable to prove this we show that the finite satisfiability problem for firstorder logic with a single binary predicate can be reduced to the problem of a policy expressed using let be a formula in firstorder logic with one binary predicate b we transform into an by simulating every pair of elements satisfying b by an event in the history technically let be the formula obtained from by replacing any occurrence of the binary predicate bu w by the formula y¯ u w in addition all the original variables and quantifiers in which are become sorted with sort host finally all free variables in are existentially quantified in is an note that it has no free variable and it can be used to define the following policy f drop ¬ we now claim that has no finite model iff such that drop for every event e where is the optimal event handler generator for f the construction of ensures that has no finite model iff there is no finite history that satisfies in addition if there is no finite history that satisfies then the policy simply to always drop all events this means that for the converse assume that then by induction for every history h h and hence h h meaning all events are always and by the assumption that is correct with respect to f we get that f h for any h hence no finite history satisfies our solution in this section we introduce a method for synthesizing programs that implement optimal event handler generators for given we start by showing that for any given set of that defines the policy f one can automatically derive a set of that defines the optimal event handler generator see definition then we will show that any event handler generator i that is defined by a set of is that is we present an algorithm see section that given i and a history h produces an of ih using these we obtain an implementation of a controller in the context of sdn as described in algorithm the controller is parametrized by the policy f and by which is expressed in l and from f by the method described in section the controller the sequence h of events algorithm runtime system f h while new event e do action f h e compute an action h h · e update state rules compute rules section send to end while it receives as its state for a new event it computes the action to be performed by evaluating the defining the policy on the current history it then infers rules by applying the algorithm from section to compute bounded causality for a general policy f may not be computable this is due to the fact that the of an event may depend on the behavior of the policy for infinitely many possible future sequences of events see definition however we now show that for policies we can bound the size of future sequences of events that must be considered definition for an integer k an event e is with respect to policy f and history h if there exists a history h of size at most k that distinguishes whether e occurred ie f h · e · h f h · h definition causality for an integer k we say that a policy f has causality if for any event e and history h if e is relevant with respect to f and h then it is also in other words a policy f has causality if whenever an event e is relevant it can cause a change after at most k additional events theorem let a a a l define a policy f then f has causality for k a · ka a a proof we show that f has causality given h h and e such that f h · e · h f h · h it follows that there exists an event e and an action a a such that a f h · e · h e but a f h · h e or vice versa assume the former this means that h · e · h e a but h · h e a we construct a history h h of size at most k such that the same holds when h is replaced by h in order to construct h we construct the set of indices of the events in h that in h let j h · e · h h · e h · e · h be all the indices in which refer to events taken from h to consider the actual indices in h we h · e from all of the indices the result i h · e i j is a set of indices from h similarly let j h · h h h · h be all the indices in h · h of events taken from h and let i h i j be the corresponding set of indices in h we define a set of indices j of events in h and define a subsequence h of h accordingly namely suppose that h e · · eh then h ei · · where ei h and j ei recall that the kernel size of a history wrt a is at most ka a ka since both and include all the indices of the last events from h see definition which are the same then the size of j and therefore also the size of h is bounded by a · ka k further since h · e · h h · e · h such that the set of indices of h · e · h in h · e · h is h · e j h · e · h then by theorem h · e · h e a iff h · e · h e a similarly since h · h h · h such that the set of indices of h · h in h · h is h j h · h then by theorem h · h e a iff h · h e a we conclude that h · e · h e a but h · h e a as required remark by definition and the proof of theorem and theorem it follows that in several cases we can obtain a slightly better bound lower k that will simplify our examples below in particular · if the given set of formulas a a a defining f contains only history guarded quantifiers then we can take k a a to see this note that without last quantifiers it cannot be the case that h · h e but h · e · h e for some component furthermore if we have h · h e for some e er then h e for the same events none of these properties is guaranteed in the presence of last quantifiers this allows us to choose ka elements indices to h instead of · ka for components that are satisfied in both h · h and h · e · h it suffices to choose the elements based on h · h rather than both finally we need one event less since there is at least one component for which h · e · h e but h · h e for this component we can choose k events knowing that the additional event must be e itself · if the formulas a contain only last quantifiers then we can take k a a a by the proof of theorem it suffices to consider a last events from h in the construction of h in fact since there is at least one component for which h · e · h e but h · h e or vice versa while the last events in h are clearly the same then the difference must from a last event in h or h · e either way this event is not in h making the size of h at most a unbounded causality in the presence of quantifier alternation if we allow alternation of quantifiers in the specification of policies then the causality property does not necessarily hold as an example consider a policy f which defines two possible actions a and b where a h h and b ¬a namely if in the current history h every event has a matching event with opposite source and destination then action a is performed on the current event e for any e otherwise b is performed assume to the contrary that f has the causality property for some k consider a history h of length k which consists of events such that all sources are different all are different and all sources are different from all further consider an event e whose source and destination also differ from all sources and in h clearly e is relevant however e is not indeed for any future sequence of events h with k events at least one of the events in h remains whether h follows h or h · e thus f h · h e f h · e · h e b for any e construction of an optimal event handler generator in this section we show that for any policy f defined by a set of l formulas we can define the event handler generator using a set of first we introduce the following notation notation let be an with one free event variable x¯ let y¯ be event variables we denote by y¯ the formula obtained from as follows · each of of the form y¯ h is replaced by y¯ h in · each of of the form y¯ last is replaced by y¯ last n y¯ ni y¯ in where ni y¯ y¯ intuitively the notation y¯ is used to encode the formula when the history is extended by a suffix of events described by y¯ this affects both the quantifiers and the last quantifiers formally this is stated by the following lemma lemma for any with one free variable x¯ history h events e en e and distinct event variables y¯ we have h · e · · en e iff h e y¯ using a a this a notation the is done using synthesis of the following a definition a from definition given a a a for any action a a the formula a is defined by a a mk ma where a a · k is the bound defined in theorem such that f has the causality property · ma denotes the formula y¯ y¯ a y¯ a we present several · the formulas a ma and therefore also a all have x¯ as their only free event variable which represents the current event · each ia is an but not an since it includes quantifiers · the conjunction of the formulas ma over all actions a a encodes the property that the current event e represented by x¯ is irrelevant when considering exactly m events into the future where to obtain we consider the conjunction over all m k technically y¯ represent the m future events e em and y¯ represents an event to which f is applied in the future with or without considering e on the left hand side of the comparison we therefore apply a on y¯ and use x¯ y¯ to extend the history by the events e e em similarly on the right hand side we use y¯ to extend the history by only e em e the above can be straightforwardly summarized in the following theorem that establishes the correctness of our construction in particular note that since f is defined by it has causality and so is equivalent to full theorem let f be a policy defined by a set a a a of then the set of l formulas opt a a as in definition defines the event handler generator proof follows from theorem theorem and lemma this completes the construction of an of an optimal event handler generator i that f remark in definition in the construction of a it is sufficient to include only m and m k in the conjunction mk ma the intermediate values the reason is a a that cannot detect stuttering in nonempty histories namely for any l we have h · e · h e h · e · e · h e as a result if ma which considers m events into the future does not hold for some m k it also does not hold for m k by one of the m future elements of here we show that the event handler generator i defined before as a set of is assume we are given such a set ia a a we describe a general algorithm that will take as input a concrete history h and produce a set a a of that defines the event handler ih let h be a particular history for a a to define ih the following has to hold correctness for any event e and action a h e ai iff e the computation is done in two steps as described next step first we eliminate the history guarded quantifiers and the last quantifiers according to their semantics suppose h e · · en then · every in each ai that begins with a history guarded quantifier y¯ h is replaced by a disjunction in · every in each ai that begins with a last quantifier y¯ last is replaced with the following disjunction ni e en in where ni e en y¯ note that this transformation is similar to the one defined in notation where we assume that the full history is e · · en the next proposition correctness proposition let be an with one free event variable x¯ and suppose that was obtained from as described above then h e iff e step in this stage we have a set of formulas in which equality is the only predicate symbol to make them it remains to eliminate the quantifiers for this simple case it can be done by equality enumeration as explained next definition for a quantifierfree in which equality is the only predicate symbol and a variable v v is the inductively by v v v v v v t or t v where t v t t where t v and t v where ¬ intuitively this operator any equality involving v in under the assumption that the value of v is different from the values of all other variables and constants that appear in note that the variable v does not occur in v and the following is valid in firstorder logic tv v t v where v is the set of free variables and constant symbols that occur in except for the variable v itself equipped with this operator we can now explain what we mean by equality enumeration the elimination of quantifiers from the formulas that we obtained after step directly follows from the following two equivalences that hold for any quantifierfree formula that has only equality as a predicate symbol if eq is infinite then v q tv tv v where v is the set of free variables and constants in except for v if eq is finite then v q tv the second equivalence is obvious recall that we assume a constant symbol for any element in the domain and the first can be explained as follows v q tv v q v t tv tv tv v q v t v tv tv tv v q v t v tv tv tv v tv where the last equivalence is due to the fact that eq is infinite by repeatedly applying these equivalences from the innermost to the outermost quantifier one obtains an equivalent quantifier free formula hence the second step amounts to performing this simple quantifier elimination on all formulas in the set producing a a as a result to summarize if we are given an l specification of a policy f we showed in theorem that we can automatically construct opt an l specification of an optimal event handler generator now we have given an algorithm to go from opt and a history h to the quantifierfree specification of forwarding rules that implement in conclusion we have shown the following theorem given an of a policy f we can automatically produce a program which takes a history h and produces the quantifierfree specification of forwarding rules that implement an optimal implementation of f remark the running time of our solution to the problem is determined by the complexity of the static part and the complexity of the dynamic part for a policy formula expressed in l with causality bound k the static translation produces an for of the length o · k with k nested universal quantifiers where is the length of formula denote the resulting formula by in the dynamic part for the current history h of length h h step eliminates guarded quantifiers from and produces a formula of size o · hk with the same nesting depth of universal quantifiers as step eliminates universal quantifiers from and returns a formula of size o · mk where m is a maximum of k h the number of constants occurring in and of all eq for finite eq in total the running time of the algorithm of theorem is in o · k · hk · mk in all the examples in this paper the algorithm is linear in as k can be taken to be according to remark it is important to note that the complexity is measured with respect to h where h is the log kept by the controller and not the full history this is especially important as the optimal event handler generator the size of this log and the running time analysis refers to the processing of events handled by the controller whose number is and not of events handled by the switches examples we demonstrate our technique on two examples the and the learning switch that supports recall the policy for the given by drop ¬ ¬ in the above we renamed y¯ to in order to avoid confusion for the simplicity of the presentation we focus here on just one switch to obtain the of the optimal event handler generator we use definition for each a drop we get ai a where y¯ y¯ a y¯ a a a since the policy formulas have only one quantifier we can take k as explained in remark then we can compute an equivalent formula for as follows y¯ a a a a y¯ y¯ y¯ h in step we omit the conjunct for drop since drop is a boolean combination of and furthermore the conjunct for can be omitted as step is by applying standard equivalences of propositional logic by applying rules of fol with equality it is also easy to see that the last formula can be further simplified to in particular for the empty history one obtains ¬ ¬ which is equivalent to this means that the synthesized rule policy will initially a rule to drop all packets on port this actually improves the sdn program implementing a stateful policy from by more rules learning switch with recall the policy for the learning switch that supports of hosts given by p last p ¬p again we renamed y¯ to in order to avoid confusion for each a ports we have ia a where y¯ a a a a y¯ y¯ y¯ last p p last p y¯ last p p last p p last in the initial description of we used the property that the policy formulas have only last quantifiers therefore we can take k as explained in remark we can omit the conjunct for in step since is a boolean combination of p p ports in step we used the propositional equivalence a ¬b c b a b a c and the firstorder equivalence x ai x ai in steps and we used rules of fol with equality we demonstrate the computation done at the runtime for the topology from figure and scenario from table as the current history we consider h s a b · s b a consider the current event e s a b which means that the host a has to port after eliminating the with respect to the current history and the conjuncts for equalities of switch components we get for a b b we see that for the current event the above formula is equivalent to which means that the current event e must be to the controller consider as a current history h s a b · s b a · s a b after the migration of host a to port consider the current packet e s b a after applying step we get for a b a b a a b a since e satisfies the formula i the current event is to port as intended related work verification and synthesis of correct sdn programs verifying the correctness of sdn programs has recently received a lot of attention ­ these works aim to verify a given controller program which implements a forwarding rule policy in contrast this paper identifies a specific correctness criterion we also automatically infer correct and optimal forwarding rule policies for forwarding policies expressed in a useful fragment of firstorder logic atomicity of rule this paper assumes that events are executed atomically ignoring rule consistently updating a network is an important challenge in sdn see one can enforce the atomicity of the inferred forwarding rules using barriers in the future it may be possible also infer the minimal barriers for a given forwarding policy using techniques similar to language abstractions for introduce abstractions for programming in order to simplify the task of programming and to enable more efficient implementations our work can be combined with these abstractions in order to further simplify the task or sdn programming and to reduce the number of errors for limited policies expressible in our language transforms algorithmic policies into forwarding rules which simplifies sdn programming however unlike our work they do not analyze the dependencies between the forwarding policies and the packet histories therefore that cannot guarantee correctness for forwarding policies which depend on the histories provides a high level level language called for programming sdn provides a mechanism to define functions which update the forwarding rules in an abstract way these functions are called when new packets arrive to the controller according to filters defined by the programmer note that the programmer has to write the update code and also to explicitly define the filter stating which packets should trigger an update the programmer is also responsible for that the filter definition is consistent with the update code which requires nontrivial temporal reasoning in contrast we provide a higher level of abstraction for expressing the forwarding policy and automatically infer correct and optimal of forwarding rules figure shows the learning switch wo host migration expressed in in lines ­ the programmer defines the update and in line the programmer defines the filter maintaining consistency between the filter and the update code is error and subtle for instance the consistency between lines ­ and line depends on the assumption that there is no host migration and this assumption is not explicit anywhere in the code therefore it may def def q figure a learning switch in on do where on insert into learned where not figure a learning switch in be to integrate our inference mechanism into by limiting the expressive power of the update code is an programming language for it allows the programmer to express the forwarding policy in an sql like language figure shows the learning switch expressed in lines ­ express the forwarding behavior using the relation learned lines ­ express updating of the learned relation in response to new packets line the defines for which packets the update should take place at first it looks as if the programmer can declare the forwarding policy wo about rule however the of rules is determined by the which has to be specified by the programmer requiring that the programmer manually specifies the may lead to subtle performance and correctness issues for example the programmer can interpret these rules according to sql semantics and replace the condition in the by true in sql semantics both variants are equivalent since adding an element to a relation does nothing if the element is already in the relation however in changing the to true results in sending all packets to the controller since they will all satisfy the leading to a performance issue similarly if the is inconsistent with the update that takes place eg then relevant packets will not be sent to the controller and the correctness of the system may be indeed and both split the task of updating the controller state into two interleaved mechanisms and it is up to the programmer to make sure they are used consistently in contrast we propose a way to automatically infer one from the other and guarantee correctness and optimality netcore is a novel framework for programming sdn it includes a mechanism to transform boolean combinations of conditions on events into rules which can be used to translate the rules inferred by this paper into because netcore is turing complete it requires that the programmers specify the conditions under which rules need to be in the form of an auxiliary function as argued in this paper this approach is error and requires nontrivial temporal reasoning on all possible sequences of events which may occur our approach in this paper limits the expressive power of the policy language to avoid the need to supply conditions datalog as a specification language datalog is another good candidate for expressing network forwarding policies this means expressing the forwarding policy as a datalog query over the history for policies expressed in datalog with recursion with or without allowing stratified negation causality does not necessarily hold this is also the case for policies expressed in datalog without recursion and with negation as for datalog without recursion and without negation policies expressed in it can also be expressed using and therefore have the causality for some k however not every policy expressible using l formulas can be expressed in datalog without recursion and without negation including simple policies such as the learning switch since the forwarding behavior is in the history conclusion in this work we have investigated the problem of sdn we characterized correctness and optimality of forwarding rule policies while the problem of finding an optimal correct policy is undecidable in general we show how to construct such policies for forwarding policies expressed in a natural restricted variant of first order logic as a future work it is to study the applicability of our approach in a setting of distributed systems and distributed databases extensions our approach can be straightforwardly extended in several ways our specification language of policies l includes two kinds of guarded quantifiers one which existence of some event in the history and one which refers to the last event in the history that has some property as discussed in remark our results also apply if we extend l by additional guarded quantifiers such as last k or first k we consider a finite set of actions a which allows us to describe functions from e to a using a finite set of formulas one for each action in order to handle packet rewriting performed for example in nat boxes and supported by one needs to consider an infinite set of actions since in this context an action may be forward to port and change the source field to this means that the infinite set of addresses will be added to the set of actions our approach can be adapted to handle this as well by adding another sort representing an action to be used in l formulas such that actions will be specified internally in l a policy will then be defined by a single formula with an additional free variable describing the action to be performed the conjunction over all actions that is used when defining the formulas of the optimal event handler generator definition will simply be replaced by a universal quantifier which will later be eliminated our approach can also handle multiple types of events by adding an attribute that describes the event type and any other type specific attributes needed it is also possible to develop synthesis methods which are applied incrementally each time a history is changed and to produce only the new rules to be or removed acknowledgments and sagiv were by the european research under the european unions framework program grant agreement no and by a grant from the science foundation was partially supported by nsf grant was partially supported by grant no we thank foster daniel michael and the anonymous for comments which improved this paper references the open foundation switch specification oct version c j foster n a kozen d c and walker d netkat semantic foundations for networks in popl s and p sewell eds acm pp ­ ball t n a s a sagiv m m and a towards verifying controller programs in networks in pldi june sigplan acm m d p d and j a nice way to test applications in foster n a m a m j n p c j j c walker d and r languages for networks ieee communications ­ s s t j and b t datalog and applications an interactive in proceedings of the acm international conference on management of data acm pp ­ n p j and walker d logic programming for networks in acm sigplan workshop on language design and implementation sept p g and n header space analysis static checking for networks in t k p m a b i j n p e a r li sh a j b r s a j p d a and r network in in m m t and e automatic inference of memory ­ m p m d and d a soft way for switch testing in pp ­ c foster n r and walker d a compiler and runtime system for network programming languages sigplan not jan ­ nelson t a d m j g and s programming and reasoning for networks in usenix association pp ­ m foster n j c and walker d abstractions for network update in acm pp ­ r a a and a a verification platform for applications in the coq development team the coq proof assistant reference manual typical project logical version a wang j yang y r b and hudak p maple simplifying sdn programming using algorithmic policies in acm pp ­ 