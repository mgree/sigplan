abstraction and invariance for indexed types robert university of andrew kennedy microsoft research cambridge abstract reynolds relational parametricity provides a powerful way to reason about programs in terms of invariance under changes of data representation a array of applications of reynolds theory exists exploiting invariance to yield free theorems results and encodings of algebraic datatypes outside computer science invariance is a common running through many areas of mathematics and for example the area of a is by rotation or if we scale a then we scale its area maintaining an invariant relationship between the two the transformations under which properties are invariant are often into groups with the algebraic structure the and of transformations in this paper we investigate programming languages whose types are indexed by algebraic structures such as groups of geometric transformations other examples include types indexed by information flow types indexed by analysis of analytic uniform continuity properties following reynolds we prove a general abstraction theorem that covers all these instances consequences of our abstraction theorem include free theorems expressing invariance properties of programs type isomorphisms based on invariance properties and results indicating when certain indexed types are or only by trivial programs we have fully our framework and most examples in coq categories and subject descriptors d programming techniques applicative functional programming d software engineering verification d programming languages language constructs and types and structures general terms languages theory types keywords parametricity units of measure dimensional analysis invariance computational geometry information flow metric types uniform continuity introduction the best way we know of describing the semantics of parametric polymorphism is relational parametricity whose central result is reynolds abstraction theorem its consequences include the wellknown free theorems for polymorphic types permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ italy copyright c acm results and precise between system f encodings and algebraic datatypes abstract data types and most recently higherorder encodings of binder syntax relational parametricity is in essence a principle of invariance the behaviour of polymorphic code is invariant under changes of data representation for example the type list list tells us that any transformation applied to elements of the input list will be reflected by the same transformation applied to elements of the result invariance results also in mathematics and the area of a is invariant with respect to of the the of a matrix is invariant under changes of basis and laws are the same in all frames typically the transformations under which invariants are preserved have interesting structure for example translations in the form an group inspired by this connection we study type systems that capture rich invariants in types indexed by attributes with algebraic structure for example in computational geometry points in the can be indexed by attributes representing affine transformations in informationflow security computations can be indexed by principals in differential privacy types can be indexed by distance types that are polymorphic over such indices induce invariance properties and abstraction barriers beyond those introduced by their versions as we shall illustrate this previous work by the third author on types parameterized by units of measure whose invariance properties relate to changes of units or scaling invariance to illustrate invariance properties consider geometry in a conventional type system a function that computes the area of a might be assigned the type vec × vec × vec real but in our proposed system we can assign it the following more expressive polymorphic type t × vec t × vec t real this type expresses the fact that if each of the arguments to is translated by the same vector then the result remains the same that is it is invariant under translation formally for any vector t t v t v t v v v v transformations typically compose in various ways and the compositions satisfy algebraic laws for example we can assign a function that computes the area of a given its the following polymorphic type s real s · s this captures the fact that the area of a as the square of its ie k · for any k the sorts t and gl will be explained later here s can be interpreted as the units of measure of the argument to and · units using the product we can also add an inverse operation and identity unit of measure and then impose the algebraic laws of groups this permits identification of for example real s · s with the type real of constants abstraction in his original paper on parametricity reynolds that type structure is a syntactic discipline for enforcing levels of abstraction we see something analogous here if all primitive operations are given types that reflect their behaviour under translation then there is no way to break this property for example there is no way that can depend on the actual of its inputs furthermore the distinction between points and vectors that is often enforced through abstract data types is captured here by indices instead for example the operation that takes two points and computes their vector difference can be assigned the type t × vec t vec the invariance of the result a pure vector under translations of the point arguments as a result through types alone we can in essence derive socalled geometry the invariance properties discussed above can be seen as free theorems but the abstraction by polymorphic indexed types can also induce interesting type isomorphisms the type of above is in fact isomorphic to real a thought reveals why what possible unary functions can be constructed whose outputs scale as the square of the scaling of their inputs answer just those functions of the form for some constant k in this case of course we expect that k relational parametricity to derive such invariance and abstraction properties of types we adopt the techniques of relational parametricity over an underlying semantics we construct binary relations by an environment that describes how values of primitive type are related according to their indices for example values v and w of type real s are related when v to w according to an interpretation of s ie w values of polymorphic type are related exactly when they are related for all possible interpretations of the quantified variable for example values v and w of type t vec t are related when they are related at type vec t vec t for all translations t t associated with t as it happens the relational interpretations given above are functional relating one value uniquely to another other applications make use of primitive relations that are not simple functions for example in a type system in which the index in real s is interpreted not as a unit of measure but as a measure of two values x and y of this type are related if x y s for a positive real number s rather the standard notion of uniform continuity can then be expressed as r r real real our for studying indexed types are first we believe that as with units of measure practical programming language extensions will follow for example in computational geometry and attributes on points vectors and other geometric types could be used to prevent the of different coordinate systems or frames second typebased static analyses can be based on indexed types for example in effect systems and more in continuity analysis finally we believe that expressing algebraic invariants through types has the potential to offer proof techniques for mechanized mathematics has applied the invariance properties of geometric primitives to create elegant proofs in geometry based on without loss of generality principles the invariance properties are expressed and propagated using adhoc tactics our types offer a more means of achieving the same end and the principle itself is expressed through type isomorphisms algebraic theory interpretation relational interpretation abstraction theorem theorem free theorems type isomorphisms figure summary of the paper we follow the semantics first syntax later in studying types with algebraic structure we have not yet built a practical programming language that supports indexed types nor have we designed type checking type inference or static analysis algorithms but when we do so the semantics will guide us the fact that zero is polymorphic in units of measure it can be given type u whereas other constants are having type real is justified by the invariance properties induced by the types zero is invariant under scaling other constants are not for less trivial constants and operations the appropriate types are not so apparent as we shall see but invariance properties expressed by the semantics guide us in assigning appropriate types semantics does not lie contributions this paper makes the following specific contributions · we present a collection of examples of indexed types including a novel type system for geometry a refined type system for information flow based on logic and a simple type system with types · we formulate a type system that can either be used as a programming language in its own right or as the target of typebased analyses the type system consists of the usual type constructors together with a collection of indexed primitive types universal and existential quantification over the indices and a equational theory for indices · we describe a relational semantics for the type system and prove an analogue of reynolds abstraction theorem for a given model of index sorts and relational interpretation of primitive types we prove that the semantics soundly approximates contextual equivalence · for each of our main examples we deduce free theorems that are consequences of our abstraction theorem prove specific results and derive interesting type isomorphisms for a large class of firstorder types we give a general method for constructing suitable models to prove results figure illustrates the central position of our analogue of reynolds abstraction theorem theorem in these results we improve on the earlier semantics of units of measure in a number of ways by extending the language of units with an absolute value operation we can give more precise types and obtain more general invariance properties the relational interpretation for units is both simpler and more flexible and we derive proofs of and new results our notion of type isomorphism is stronger than before being based on contextual equivalence we have fully our framework and most examples in coq using term representations throughout the is available from structure of paper our paper is structured as follows in section we present an extended case study of geometry with description of types and results in section we describe fully formally a general framework for types and prove the abstraction theorem and soundness for semantic equivalence section presents a number of applications of the theory to d geometry including free theorems type isomorphisms and section a more general technique for proving results section presents the application of indexed types to information flow security and section applies it to types indexed by finally section discusses related work and future geometry via indexed types we our investigation of indexed types and their relational interpretations by developing a novel type system for programs that manipulate geometric data geometry is rich with operations that are invariant under transformation affine operations are invariant under change of origin section vector space operations are invariant under change of basis and dot product is invariant under orthogonal changes of basis section on the other hand some geometric operations are interestingly variant under transformation for example cross products vary with of the section we incorporate invariance information about geometric primitives into type systems via indexed types origin invariance and representation independence the basic data structure used in programs that manipulate geometric data is the of numbers in the dimensional case tuples v x y serve double representing both from some in their own right despite their common representation points and vectors are very different and distinguishing between them is the key feature of affine geometry see for example chapter of nevertheless computational geometry libraries traditionally either leave it to the programmer to maintain the distinction between points and vectors or else use different abstract types for points and vectors to enforce it in this paper we investigate a more sophisticated approach based on types indexed by change of origin transformations this approach the difference between points and vectors as a change of data representation for example if and are two then the tuple with respect to and the tuple with respect to represent the same point because they have the same from these two respectively this suggests that programs that manipulate points should be invariant with respect to changes of origin programs that manipulate vectors on the other hand should not be invariant under change of origin different vectors represent different offsets and the vector always represents the zero offset invariance under change of representation immediately reynolds about two the theory of complex numbers one represents complex numbers using while the other represents them using i sin after learning the basic operations on complex numbers in the two representations the two classes can interact because the theory of complex numbers is invariant under the choice of representation reynolds the idea of invariance under changes of representation as preservation of relations for example if a binary relation r relates the and representations of complex numbers then a program that complex numbers at a level of abstraction above their specific representation should preserve r reynolds relational approach can be applied in the geometric setting to show how over all changes of origin ensures the invariance of programs under any particular choice of origin for this we first define a family of binary relations on r that is indexed by changes of origin changes of origin are represented by vectors in r and form a group t of translations under addition the family of binary relations rt r × is then defined by rt v v v v t we then consider a function f that takes as input two tuples in r and returns a single tuple in r we intend that the tuples all represent points with respect to the same origin and that f is invariant under the choice of origin reynolds relational approach this intention precisely for any t t v v rt v v v v f v v rt unfolding the definition of rt gives the equivalent formulation again for all t t v v f v t v t f v v t thus reynolds preservation of relations when instantiated with the family of relations rt yields exactly the geometric property of invariance under change of origin a type system for change of origin invariance reynolds also showed how a type discipline can be used to establish that the denotational interpretations of programs preserve relations for reynolds the type discipline of interest was that of the polymorphic calculus which supports the construction of new types by universal quantification over types in terms of relations reynolds universal quantification over types as quantification over binary relations between denotations of types by contrast in our statements of geometric invariance in section we did not quantify over all relations but instead quantified over all changes of origin and used a specific choice of origin to select a relation from the family rt this suggests introducing quantification over changes of origin into the language of types we use the notation for quantification over all dimensional translations ie choices of origin t and refer to t as the sort of t note the difference in used to distinguish the semantic group t from the syntactic sort t we use a similar convention below too since the sort t represents an group we can combine its elements using the usual group operations we write operations using e e for the group operation e for inverse and for the unit we also regard expressions built from variables and the group operations up to the group axioms for example we regard e e e and e e e as equivalent our language of types includes the unit type unit and for all types a and b the function type a b the sum type a b and the tuple type a × b we also assume a primitive type real used to represent scalars although tuples of real numbers represent points and vectors in geometric applications we cannot express this via the type real × real indeed two elements of type real are related if and only if they are equal and by reynolds interpretation of tuple types two elements of real × real are also related if and only if they are equal but since this does not give the correct relational interpretations for points and vectors we introduce a new type vec e indexed by expressions e of sort t to represent them the index e represents the by change of origin of a point of this type although we have taken to distinguish geometric points and vectors we use the name vec for both to recall the computer science notion of vector as a sequence of values with a known length in this case as is standard for parametricity every type has two interpretations an interpretation that ignores the indexing expression and a relational interpretation as a binary relation on the interpretation we denote the and relational interpretations with the notations · and · respectively to give such interpretations for the types vec e and we assume for now that we can map each expression e of sort t to an element e of the group t using some environment that es free variables the and relational interpretations of vec e are vec e r vec e r e v v v v e the and relational interpretations of are a a t t t the and relational interpretations are given formally in sections and at the end of section we considered functions f r × r r that preserve all changes of origin this property of f can be expressed in terms of types by f tt vec t t vec t out the relational interpretation of this type using the definitions above and the standard relational interpretations for tuple and function types we recover statement exactly affine and vector operations invariance under change of origin is the key feature of affine geometry whose central operation is the affine combination of points v v where this can be interpreted as describing all the points on the unique line through the points represented by v and v assuming v v we add affine combination of points to our calculus as follows tt vec t real vec t vec t v r v rv rv it can be verified by hand that the interpretation is invariant under all changes of origin as by its type example the evaluation of quadratic with two and a single control point can be expressed using the affine combination primitive as follows tt vec t vec t vec t t t p p p s t t p s p s t p s p for two p and p a control point p and s an application p p p s gives the point on the curve at time s the type of immediately tells us that it preserves all changes of origin the obvious type for vector addition is vec vec vec but we can reflect the fact that is not invariant under change of origin by giving it a more precise type that reflects how it with change of origin t tt vec t vec t vec t t intuitively this type says that if the first input vector has been by t and the second by t then their sum is by t t we can also vectors yielding a vector which points in the opposite direction negation translation arguments tt vec t vec t finally with the primitive operations of addition and negation of vectors we can define the derived operation of t tt vec t vec t vec t t t t p p p p given two points that are invariant with respect to the same change of two values of type vec t we can use to compute their offset offset tt vec t vec t vec offset t p p p p the result is a vector expressed with respect to the null change of origin note how the algebraic structure on the indexing theory induces type equalities that can be used to simplify the type of the result of offset from vec tt to vec the type of can also be to the case of moving a point by a vector tt vec t vec vec t t p v p v the types we assign to the remaining vector space primitives namely vec for the zero vector and real vec vec for multiplication by a scalar do not describe any interesting effects on translations example the vector space operators and the properties that follow from their types allow us to establish a useful type isomorphism consider functions with types following the schema n def tt vec t vec t real n times just by looking at the types n we know that their will be invariant under change of origin because of the quantification over all t in t so we may as well choose one of the input points as the origin and assume that all the other points are defined with respect to it this the common mathematical practice of stating that without loss of generality we can take some point in a description of a problem to be the origin provided the problem statement is invariant under translation each type n is isomorphic to the corresponding type n n def vec vec real n times we demonstrate these isomorphisms formally in section in the more general setting of types indexed by groups example so far we have the derivation of properties or free theorems of programs from their types but using more refined relational interpretations of types we can also show that certain types are for example the type tt vec t t vec t has no intuitively this is because we cannot remove the extra t in vec t t using the vector operations we this result in section using a relational interpretation change of basis invariance although vector addition negation and scaling are not invariant under change of origin they are invariant under change of basis as with origin invariance we can express basis invariance as preservation of relations indexed by changes of basis change of basis is achieved by applying an invertible linear map and the collection of all such maps on r forms the general linear group gl which we represent in our language by a new indexing sort gl with group structure that we will write we then extend vec to allow indices of sort gl as well as t so that vec b t is a vector that with change of basis b real s real real s real s real s real s real s real s s real s real s real ss s real s real s real ss unit abs real s real s figure operations on real numbers and change of origin t formally the and relational semantics of vec b t are given by vec eb et r vec eb et v v v eb v et affine geometry an affine transformation is an invertible linear map together with a translation we can assign types to all the primitive affine and vector space operations indicating how they they behave with respect to affine transformations tt vec b t real vec b t vec b t t tt vec b t vec b t vec b t t tt vec b t vec b t vec b real vec b vec b geometry geometry extends affine geometry with the dot product or inner product operation of two vectors the dot product is defined by x y xx yy to assign it a type we note that although dot product is not invariant under gl or t it is invariant under the o of gl of orthogonal linear transformations ie the of invertible linear maps whose matrix representations are equal to their we thus introduce a new sort o of orthogonal transformations and the multiplicative group operations for of o further assuming an injection o that takes e o to oe gl we assign dot product this type · oo vec oo vec oo real the cross product of two vectors is defined on coordinate representations as x y × x y xy xy the cross product is the signed area of the described by the pair of input vectors under change of basis by an invertible linear transformation b the cross product of two vectors with the of b this corresponds to scaling the by the change of basis transformation so we augment our calculus with a new sort gl of scale factors ie dimensional invertible linear maps semantically gl ranges over the nonzero real numbers and forms an group which we write we also add two new operations b which takes an of gl to its in gl and absolute value e which takes scaling factors to scaling factors we also refine the type real of real numbers so that it is indexed by the sort gl real e the old type real is then just real and the full collection of operations on real numbers indexed by scaling factors is shown in figure we can thus assign cross product the type × vec b vec b real b since the absolute value of the of an orthogonal transformation is always we assume to hold for any o o example we can use the operations of this subsection to compute the area of a we have area tt vec b t vec b t vec b t real b area b t p p p abs p p × p p the calculation is performed in several steps each of which re moves some of the symmetry described by the type of area first the two offset vectors p p and p p are computed these operations remove the effect of translations on the result in exactly the same way as the type isomorphism in example next we compute the cross product of the two vectors which gives the area of the described by the sides of the and has type real b this removes some of the symmetry due to in linear maps but the cross product still with the sign of the we remove this symmetry as well using abs this gives a value of type real b which we multiply by to recover the area of the rather than that of the whole if we area to just orthogonal transformations the assumption gives the following type area oo tt vec oo t vec oo t vec oo t real this type shows that the area of a is invariant under orthogonal transformations and translations combinations of such transformations are ie distance preserving maps scale invariance and dimensional analysis indexing types by scaling factors us to the original tion for the current work interpretation of his units of measure type system via scaling invariance kennedy shows how interpreting types in terms of scaling invariance the techniques of dimensional analysis to bear on programming the types of the real number arithmetic operations in figure are ex the types kennedy assigns in his units of measure system ex for that of the absolute value operation semantically our type by nonzero scaling factors whereas by strictly positive ones in our setting we can add to one dimensional scaling invariance an operation that semantically takes scale factors in gl to invertible linear maps in gl ie takes numbers s to matrices s s this operation satisfies the equation s indicating that scaling the by s in both directions areas by s example just as we the type of the area function to orthogonal transformations in example we can also areas type to scaling transformations this yields the type area tt vec s t vec s t vec s t real s as expected the area of a with the square of of the and this is reflected in the type linear maps of the form s s as generated by commute with all other invertible linear maps we thus require sb bs to hold the scaling maps s s are precisely the elements of gl that commute with all others these form the centre of gl if we keep track of then we can assign the more precise types to scalar multiplication and dot product these are shown in figure which the most general types of all the vector operations that we have described vec b t tt vec b t vec b t vec b t t tt vec b t vec b t real s vec b vec sb tt vec b t real vec b t vec b t · oo vec vec real s × vec b vec b real b figure operations on vectors example with the operations in figure it is not possible to write a term with the following type that is not zero real s real s this was shown by kennedy for his units of measure system in particular it is not possible to write a square root function with the above type the of square root is similar to the of the type in example in section we result and show that even if we add square root as a primitive the type above then it is still not possible to construct the root function the of root is related to the of an arbitrary by and constructions a general framework we now present our framework for indexed types and its relational interpretation we define the syntax of indexed types section and a syntax for terms in a general programming language for indexed types section we give an semantics to types and terms section and based on this semantics define notions of contextual equivalence and type isomorphism we then introduce a relational semantics for types by an appropriate model of the algebraic theory section prove the central abstraction theorem and use the relational semantics to define a notion of semantic equivalence that soundly approximates contextual equivalence section we will use a type system for affine geometry as a running example throughout so that by the end of the section we have enough syntactic and semantic to let us prove invariance and abstraction properties for geometric examples in section types the index expressions and types of an instantiation of our general framework are derived from the following data a collection sort of index sorts we use the variables s s s for arbitrary sorts taken from sort a collection of index operations with a function sort × sort we use the notation a to denote the set of lists of elements of some set a a collection of primitive types with a function sort describing the sorts of the arguments of each primitive type example geometry syntax the geometry system has a sort for each of the geometric groups mentioned in section so sort t gl o gl we have additive group structure on t multiplicative group structure on gl gl and o from o and gl into gl and absolute value thus g g o · where g gl gl o and t g t t t g g g t t g g o gl gl gl gl gl gl the intended interpretations of the top three pairs of operations are group unit group combination and group negation respectively when we discuss equational theories on index expressions in section we will impose the group laws for this example we also have vec real with gl t and gl we assume a infinite collection of index variable names i i i etc index contexts is are lists of pairs such that all the variable names are distinct the rules in figure generate two judgements index expressions e s and types a type since index variables may appear in types types are to be with respect to an index context the rules for index expressions are particularly simple either an index expression is a variable that appears in the context rule or it is an application of an index operation taken from to other index expressions rule the rules for types include the usual ones for the simplytyped calculus with unit sum and tuple types rules and we use bool as an abbreviation for unit unit the rule forms from a primitive type x and appropriately sorted index expressions e en the type x e en the rule forms universally quantified types where the universal quantification ranges over all index expressions of some sort existential types formed using the rule allow for abstraction by hiding substitution of index expressions it is convenient to express substitution of index expressions in terms of simultaneous substitutions given a pair of index contexts and is a simultaneous substitution is a sequence of expressions e en such that ej sj for all j n given a substitution e en and a variable in we write ij for the index expression ej we write for the set of all substitutions such that we can think of any sequence of sorts as an index context in particular we will make use of substitutions of the form since these are exactly sequences of index arguments suitable for the primitive type x by further of notation we write for the set of all substitutions such that for a substitution where is and a pair is such that i does not appear in either or we can form the lifted substitution is is i in i is application of a substitution to a index expression e s yields a index expression e s the expression e is defined on variables as i def i and on operation symbols as fe en def fe en given a type we have a type the key clauses defining a are for is is index expressions f s sn s fe en s types x s sn ej sj jn x e en type unit type ej sj jn a type b type a b type a type b type a × b type a type b type a b type is a type type is a type type figure index expressions and types primitive types and the universal and existential quantifiers x e en def x e en def def the identity substitution id is id i in where is the composition of two substitutions and where e en is defined as def e en given a context is and a pair is such that i does not appear in we define the projection substitution is is as is i in index expression equality and type equality much of the power of indexing types by the expressions of an algebraic theory comes from the equations of the theory for example in section the types vec b t t and vec b t t are considered equal by the type system because is commutative in the general framework the equations between types are derived from a set of axioms e ax e s that are in the sense that both e s and e s hold given a set of axioms we generate the equality judgment between index expressions e e s by a set of rules the following rule lets us use substitution instances of axioms e ax e s e e s we also assume the standard congruence symmetry and transitivity rules for the equality judgment example geometry axioms in section we assumed various equational axioms for indexing expressions for elements of geometric groups assuming the group axioms for translations we can this in our framework t t t ax t t t t t t t t t ax t t t t t t t t ax t t t t t t ax t t t similarly the sort of scale factors gl forms an group under multiplication and the sorts gl and o form multiplicative groups so we assume the appropriate axioms we also assume that the operations o and · are group homomorphisms and that expressions of the form s commute with group multiplication in the sort gl the absolute value of the of an transformation is always so we also assume ax similarly scaling maps have a expressible in terms of other operations ax s · s we also assume the axiom s ax s the equality judgment e e s on index expressions generates the equality judgment a b type on types the basic rule generating equality judgments on types applications of primitive types if their arguments are equal ej ej sj jn x e en x e en type the rest of the rules for equality on types ensure that it is a congruence relation and an equivalence relation the substitutions and are defined to be equal and written if their component expressions are equal in the context ie if ej ej sj for all j welltyped terms we now present the rules for welltyped terms over the collection of types we defined in section welltyped terms are defined with respect to typing contexts which are in turn defined with respect to an index context typing contexts with respect to an index context are sequences of pairs with no repeated variable names such that each type is with respect to formally typing contexts are given by a type x a x application of substitutions extends to typing contexts by applying the substitution to each type welltyped terms are defined with respect to an index context and a type context the judgment m a is defined in figure the equational theory on types is incorporated into the type system via the rule which allows a term that has type a to also have any equal type b as well for any particular theory we assume that there is a closed typing context ops that describes the types of the primitive operations example geometry operations for geometry ops would collect together the types of primitive operations as listed in figure and figure semantics having defined the syntax of indexed types and terms we turn to their denotational interpretation we first define an interpretation of types and terms that every type as a set ignoring the indexing expressions and which x a var x a m a a b type m b unit m a n b pair m n a × b m a × b proj m a m a × b proj m b m a inl inl m a b m b inr inr m a b m a b x a n c y b n c case case m of inl xn inr yn c x a m b xm a b abs m a b n a app m n b is is m a im m e s m e id ea m id ea es is a type e m m is is x a n let i x m in n b figure welltyped terms open terms as functions that map environments to final values interpretation of types the defining feature of the index erasure interpretation is that semantics of a type x e en is determined solely by the primitive type x and not by the index expressions e en we thus assume each primitive type x is assigned a set x and extend this assignment to types by induction on the type structure unit def a × b def a × b a b def a b a b def a b x e en def x def a def a we will the notation · for all interpretations and notation · for the relational semantics defined later the interpretation completely ignores index expressions and quantifiers and type equality is defined as an extension of index equality therefore it is straightforward to prove that equal types have equal denotations when interpreted in the semantics and that substitution of index terms has no effect on the interpretation of types lemma if a b type then a b and if a type and then a a interpretation of terms we assign an semantics to any typing context by induction and x a × a for a welltyped term m a we define the erasure interpretation as a function m a that completely ignores the indexing information in light of lemma we do this directly on the syntax of welltyped terms rather than on typing derivations the definition of m is completely standard except for the clauses for universal and existential types i m def m e m def m let i x m in n def m e def m n m for any particular theory we assume that there is an interpretation of the primitive operations ops ops example geometry interpretation the geometry instantiation of the general framework uses the assignment vec r and real r we assume that ops gives the usual interpretation to scalar and vector operations from figure and figure contextual equivalence we use our semantics to define when a pair of terms are contextually equivalent with respect to syntactically defined contexts following hofmann given an index context is we write a for is and similarly for m and m definition contextual equivalence two terms ops m m a are contextually equivalent written m m a if for all contexts · ops c a bool it is the case that c m ops c m ops type isomorphism we say that types a type and b type are isomorphic and write a b if there exist maps between them that are mutually inverse with respect to contextual equivalence ie if there are terms i a b and j b a such that x a x a and y b y b that is a congruence with respect to the type formation rules of figure is straightforward we can also derive isomorphisms that are independent of the indexing theory such as a × b b × a and b a for i not free in a the relational interpretation of types the relational semantics of the type a type is a binary relation on the interpretation of a we write for the set of binary relations r x × x on the set x for the unit tuple sum and function types we define the relational interpretation as a standard logical relation the relational interpretations of primitive types with index arguments and the universally quantified types require an interpretation of index contexts an index environment assigns to each index variable i s in the context a value drawn from an interpretation of the sort s that soundly models the equational theory associated with s we call such an interpretation a model it assigns to each index operation in the equational theory a corresponding operation in the interpretation so that index expressions can be interpreted by recursion on their structure for example the sort t of translations can be modelled by any group an obvious candidate here is the additive group over r which we will use to obtain invariance under translation but we could use the additive group q or even a finite group such as the group z models a model assigns to each sort s sort a carrier set s and assigns to each operation f with s sn s a function f s × · · · × sn s an index context is is interpreted as cartesian product ie def s × · · · × sn for each index expression e s we assign a function e s by recursion on the structure of e i def i fe en def f e en finally a model must be sound that is for each axiom e ax e s we have e e example geometry affine model we define the model of the indexing theory for the geometry example as follows each of the sorts is interpreted just as its semantic counterpart t t gl gl o o gl gl each of the index operations eg the group structure and is interpreted by the intended semantic operation and clearly satisfies the axioms in example given and a substitution with e en we can derive the composed index environment as def e en relational interpretation of primitive types having fixed a model we next choose a relational interpretation of primitive types for each each primitive type x its relational interpretation is by elements from the model x rel x example geometry change of basis interpretation given the model of geometric groups described above for the relational in of vec b t and real s we use vec b t v bv t v r and real k x kx x r relational interpretation of types we assign a relational interpretation to all types a type by induction on their derivations by index environments unit def x e en def x e en a b def a b a × b def a × b a b def a b def a m m s def a m m s in this definition the relational interpretation of an application of a primitive type x e en is built from the relational interpretation of the primitive type x and the interpretation of the index terms e en in the index environment universal and existential quantification are interpreted by the settheoretic intersection and union respectively over all extensions of the index environment we have also used the following standard constructions on binary relations if r and s rely then r s y is f f a a r fa fa s and r × s × y is a b a b a a r b b s and r s y is inl x inl x x x r inr y inr y y y s the following lemma states that the relational interpretation of types that we have defined in this section behaves well the first part of the lemma states that two types that are equal are given equal relational interpretations and the second part states that substitution of index expressions in types can be interpreted by the composition of index environments with substitutions lemma if a b type then a b if a type then for all and a a note that the equations in both parts of lemma are welltyped by of the corresponding parts of lemma the abstraction theorem and semantic equivalence our main result theorem is that the semantics of every welltyped term is related to itself in the relational interpretation of its type this is the abstraction theorem for every instantiation of our general framework the abstraction theorem we now state the abstraction theorem for welltyped terms to state and prove this theorem for open terms we extend the relational interpretation of types to typing contexts the relational interpretation of contexts is defined by def x a def × a the relational interpretation of contexts inherits from the relational interpretation of types the property of interpreting the application of substitutions as composition lemma if and then for all we have given a particular choice of model and relational interpretation of primitive types we can then prove the following theorem abstraction if m a then for all and such that we have m m a proof by induction on the typing derivation making use of lemma part for rule lemma part for rules and and lemma for rules and the details can be found in the coq development semantic equivalence of terms is defined in terms of the relational interpretation as a consequence of theorem semantic equivalence is a sound approximation of contextual equivalence let ops be the context of primitive operations and ops its interpretation fix a model and relational interpretation of primitive types so that ops ops ops definition semantic equivalence two terms ops m m a are semantically equal written m m a if for all and all we have m ops m ops a theorem soundness if m m a then m m a geometric consequences of abstraction we now instantiate our general framework with the indexing theory of section and present more general and free theorems type isomorphisms and results for the free theorems and isomorphisms we use the model and relational interpretation of primitive types described in section namely that of affine transformations for vectors and scaling for scalars free theorems consider the type of the area function from example area tt vec b t vec b t vec b t real b by theorem we can derive the following free theorem for all b gl t t and x y z r we have b area x y z area bx t by t bz t thus directly from the type of the area function we can see that its semantics is a invariant under translations and b if the inputs are to a linear transformation b the output with the absolute value of the of b type isomorphisms types indexed by groups induce a particularly rich theory of type isomorphisms previous work on units of measure relates these to theorem from dimensional analysis here we consider the additive groups of translations and the multiplicative group of translations consider first the group t of translations from section and section example geometry we prove that b t vec b t vec b let x def b t vec b t i def f xf b and y def vec b j def b t v b tw unfolding definitions gives that ops v v for any v r because is the identity for vector addition it follows that v y to show f x f x we to theorem and reason using the relational semantics it suffices to show f x f x that is given for any f and f with f f x it is the case that ops f f x expanding the premise we have t r v r f bv t bf v t expanding the conclusion we have to show that for any t r and v r it is the case that f bv t bv f t by instantiating equation with v and t bv t and applying a little algebra we obtain this result we can this isomorphism substantially proving that for any quantifierfree type a the type b t a is isomorphic to at where at denotes substitution of the identity translation for index variable t in type a this isomorphism the equivalence between geometry expressed by a polymorphic type whose first argument can be thought of as the origin with respect to which a is specified and a geometry expressed by the type at in which the origin is fixed at it is sometimes said that an affine space is a vector space that has its origin we have captured this in a type isomorphism lemma suppose that tt a type a contains no quantifiers and every occurrence of vec is of the form vec b then b t a at proof let x def b t a and y def at i def f xf b j def b t where terms tt b t tt b t tt b t tt b t at a a at vec b et vec b e vec b e vec b et are defined by induction over the structure of a and e for brevity we omit types on binders also note that the omitted cases for have definition symmetric to xx e xx p p x of inl y inr y f x be tv ww w ww v ww t t be tv ww w ww v ww t t unfolding definitions we deduce that ij y ops y ops y for any y at its easy to prove by induction on a that ops y y and so yy ij y y y follows for the opposite direction of the isomorphism we to theorem and so it suffices to show f x f x that is given for any f and f with f f x it is the case that ops f f x expanding the premise we have t r v r f v f bv t a t expanding the conclusion we have to show for any t r and v r it is the case that ops f v f bv t a t unfolding the definitions of j and i and expanding the erasure semantics this amounts to showing that t v r ops vf f a t in order to make progress we prove first by induction on a that for any v and w the meaning of can be characterized by ops vx y a w x y a bv w thus our goal becomes t v r f f bv t a bv t this is obtained immediately by instantiating equation with v and t bv t example and example are special cases of this isomorphism another instance is the type of vector addition t b t vec b t vec b tt b t vec b t by lemma b by lemma unit by theorem in other words the vector addition operation is the only of its type for the group gl of we can treat a argument to a function as a unit of measure with which to scale the result although the argument might be zero and this cannot be used for scaling we still can obtain the following slightly more complicated isomorphism s a as × the type of from the introduction is one instance s real s real × s by equation real × unit by theorem real trivially to prove results the model and relational interpretation used in the previous two sections are not sufficient this is true even for simple scalars with invariance under scaling consider the type s real s there are many functions f r r that satisfy its relational interpretation ie for which f k · x k · f x for any k consider f x x if x otherwise for instance yet this type contains only the constant zero function a fact that we can prove using a surprisingly simple model example if ops f real s real s then f x to show this take the model gl def def · def x yx y mod def id def id in other words the additive group z now set real z r if z if z its easy to check that ops ops ops we think of z as tracking whether or not on scale parameters are by all the primitive operations in fig produce results with even if their inputs have even but the type under consideration here does not by theorem we have that f f real s real s expanding the definitions this means that for any z gl and any x y real z z mod it is the case that f x f y real z set z then we have that if x y then f x f y the particular model and relational interpretation used here is only to rule out the square root type it does not rule out a root type for instance nevertheless it is possible to interpretations that serve up both invariance and more general results for example we can set gl def gl × q def · def · · def · id def and real k q x kx x r if q z otherwise example suppose we extend the operations ops of figure and corresponding ops with a square root operation typed by s real s if ops f real s real s then f x to show this take the model gl def q · def def def · def id in other words the additive group q now set real q r if n nq z otherwise its easy to check that ops ops ops here q is tracking the on scale parameters with real q relating only zero to itself unless the of q is a power of two a socalled number applying the abstraction theorem and expanding we have that for any q q and any x y real q it is the case that f x f y real q set q then we have that if x y then f x f y for the general framework the results in the previous section required the use of models and relational interpretations it is reasonable to ask whether or not there is a general method for constructing suitable models and relational interpretations to prove results in this section we show that this is possible for a large class of firstorder types in any instance of our general framework in example we showed that the type real s real s only has trivial intuitively this is because the index of the result type s cannot be obtained from the index of the input type s using the group operations and axioms this observation can be used to give a sufficient condition for for types of the form is x e x en x e roughly speaking if this type is then it must be the case that the index expression e can be generated from the set of index expressions e en we assume that we are working with an instantiation of the general framework from section with a closed typing context ops describing the types of the primitive operations and a chosen semantics we will use a special relational interpretation built from the syntax of the indexing expressions to prove our general result for simplicity we assume that there is only one primitive type x but the technique we describe here extends to the general case we also assume that x is nonempty to state our general condition we need to define the set of index expressions generated by some finite set of index expressions given a set s of index expressions that are all in some index context we define to be the set of expressions that are built from the elements of s and the primitive index operations to account for the equations between indexing terms we close under index expression equivalence to get the set e s e e e s now a type is if it is closed and of the form is x e x en x e and e en theorem assume that the members of ops are all of types if there exists an m with typing ops m is x e x en x e then e en this theorem is usually applied in the if e en then no such m can exist note that if ops contains operations corresponding to each of the operations as for example in figure then this theorem yields a of definable terms since the construction of e from e en can be replicated at the term level proof let is be the index context constructed from the universally quantified type variables in the type of m to interpret the index expressions we use the free model over the variables in constructed from the syntax this model assigns to each sort s the set e e s of index expressions by index expression equality index operations are interpreted by the corresponding syntactic operation on equivalence classes f e en fe en we take the relational interpretation of the primitive type x as x e x x x x e en it is straightforward to check that for any interpretation of the primitive operations ops ops we have ops ops ops because all members of ops have types hence by theorem we know that for all terms ie elements of the free model over es x x x e e em xn xn x en e em m ops x xn m ops x xn x e e em by setting ej ij and using an arbitrary element x x which we have assumed nonempty we have for all k x x x ek i im since each ek is a member of the set we are using to generate terms now m ops xx m ops xx x e and so e en application to example theorem can be directly applied to show that the type tt vec t t vec t has no the free model over the single index variable t is isomorphic to the integers and the generated by the index expression t t corresponds to the even integers the result now follows simply because ie the interpretation of t is not an even number group indexed types kennedy has given a general of at firstorder in the case of group indexing in terms of integer solutions to a set of linear equations theorem to the case of group indexing yields polymorphic constants theorem does not apply in the case when we have polymorphic constants this is the case with the polymorphic real s in figure theorem does not apply because the index expression s is not generated by the empty set s type is not nevertheless it is easy to adapt the proof of theorem to handle a polymorphic constant like by setting the relational interpretation of x to be x e x x x x x e en the conclusion of the theorem now states that either we have e en or m is the constant function this extended theorem can now be used to give an alternative proof for example as this example illustrates there may be many different models that can be used to prove a result adding index operations theorem also does not directly ap in the case of example again because assumption that the types of the primitive operations are all is not sat in this case the assumed square root operation has type real s real s and as we observed at the start of this section s is not in the set generated by s however to enable the application of the theorem we can assume an additional index operation like square root at the index level now the free model produced in the proof of the theorem is isomorphic to the numbers with addition and and the generated consists of the of the form k n again there is a of models that can be used to prove a single result logical information flow we now apply our general framework to types that are indexed by logical propositions by including a primitive type that represents logical truth we can a construction due to and information flow properties of programs as a result of our general framework being by the choice of equational theory we can alter the logic that we use for reasoning about type equality and hence alter the information flow properties of the system we first recall the concept of information flow a function f a × b c is said to not allow information to flow from its second argument to the output if for all b b b and all a a f a b f a b if we think of the b argument as representing information then we have stated that f does not allow the input to flow to the low security output information flow can be seen as a kind of invariance property of programs and so our relational interpretation of types is well to proving this kind of property as described by sabelfeld and sands information flow can be captured semantically by partial equivalence relations pers abadi heintze and built a core calculus for dependency using a type system based around a security level indexed monad using pers to prove the information flow properties and translated abadi et als calculus into system f translating the monadic type to l a for some free type variable l and using reynolds abstraction theorem to prove information flow properties for example if the type variable h represents highlevel information then the noninterference property of the function f could be expressed by the system f type a h b c if a program cannot generate a value of type h then it cannot access the value of b and hence is to the actual value relationships between security levels are captured by functions l l whenever l is a lower security level than l using algebraic indexing we refine and translation by replacing each type variable l with a primitive type t l of representations of the truth of a logical proposition l that stands for the security level l the relationships between security levels are now replaced by logical entailment so we only have functions of type t l t l when l entails l we instantiate our general relational framework to interpret t as the identity rela and translation did not satisfy all the properties that they as pointed out by and however this problem is not relevant to our discussion here tion if is true and the empty relation if is false we shall see that this the information flow properties of abadi et al and and instantiation of the general framework we assume a single indexing sort prop and assume the operations and equations of boolean algebra thus we have constants and binary operators with the axioms of a bounded lattice and a unary operator ¬ we will use to stand for index expressions of sort prop we use an equational presentation of boolean algebras to fit with our general framework but note that we can define an order on index expressions as when we have a single primitive type t with prop and semantics x thus values of type t have no runtime content their only meaning is given by the relational semantics for the model of the indexing theory we take an arbitrary boolean algebra l the relational interpretation of the truth representation type is t x x where is the top element of the boolean algebra l the primitive operations log reflect logical consequence truth t and p t p t q t p q up p t p q t p the combination of the rule and the primitive up operation allow for logical entailment to be reflected in programs if we have and m t then up m t each of the primitive operations has a trivial interpretation due to the interpretation of t as a set giving an environment log less trivially we have this lemma lemma log log log information flow we think of logical expressions as composite principals that is propositional variables representing atomic principals that are combined using the logical connectives we interpret truth for principals as stating that a principal is true when satisfied with the current state of thus a relationship indicates that satisfaction of the composite principal implies satisfaction of the composite principal in terms of security levels the ordering is if a high security principal is satisfied then all of their must also be satisfied we adapt and translation of abadi et als monadic type to our setting we define a type abbreviation ta t a where a is a type and is an expression of sort prop for every we can the types t with the structure of a monad this is due to the fact that it is an instance of the environment or reader monad we read the types ta as data of type a protected by the principal as a consequence of the relational interpretation given above it follows that if we have an index expression that is interpreted as some value other than in an index environment then for all x x we have x x thus if a principal is ie then data protected by this principal is from any other data and a program cannot get access to the exact value from this observation and theorem we obtain the following information flow result theorem let and be index expressions of sort prop in some indexing context such that then for all terms log m and all terms n n of type m n ctx m n thus there is no information flow from m s input to its output note that if then it is always possible to write the identity function with this type using the up operation the theorem also holds if we move to logics other than boolean logic for example if our equational theory models intuitionistic logic by taking the axioms of algebras then the same property for programs of type t bool holds due to the lack of middle if we take linear logic then programs of type have no information flow from their input due to of p p p types the type system for geometry we discussed in section and section made use of a relational interpretation of primitive types that relates pairs of elements by some transformation if applying the transformation to the first element of a pair yields the second thus the free theorems that we derived directly take the form of invariance properties where some equation holds between two terms in this section we examine another instantiation of our general framework that relates values when they are within a certain distance the free theorems that we obtain us of the effect that programs have on the between values for example a program m of type r real real real must satisfy the property that for all and x x y y r if x x and y y then m met x y m met x y instantiation of the general framework we assume a single indexing sort r to represent positive nonzero real numbers for the index operations we assume the operations min max and multiplication by constant reals there is a single primitive type real with r the primitive operations met are as follows where c stands for arbitrary constants c r real r real real real r real real real c r real real c up r real real max we assume that the semantics of the real type is just the set r so all except the last operation have straightforward interpretations the up operation is interpreted just as the identity function the interpretations of the primitive operations are collected together into an environment met met for the relational we construct a model of the indexing theory by interpreting r with strictly positive real numbers we set real x x x x lemma met met met uniform continuity using existential types the standard definition of uniform continuity can be expressed as r r real real for any program m of this type theorem gives a free theorem that is exactly uniform continuity x x xx m met x m met x this definition differs from the definition of regular continuity by the order of quantification there x comes before so the distance may depend on x we that to express standard continuity as a type would require some form of type dependency gulwani and have given a program logic based approach to verifying the continuity of programs function sensitivity a type system with a relational interpretation that tracks between values has been investigated by and pierce in the setting of differential privacy their system uses a linear type discipline to ensure that all programs are ie the distance between the outputs is no greater than c times the distance between the inputs for some constant c we can express their central concept of for functions on the reals as an indexed type r real real c the precise connection between their sys tem and ours is left to future work discussion we presented a general framework for indexed types and instantiated it to yield novel type systems for geometry logical information flow and types our framework further demonstrates the power of relational reasoning about typed programs from theorem we derived interesting free theorems type isomorphisms and results we conclude with some observations and suggestions for further work further applications and extensions we have covered several applications of indexed types in this paper but there are many more geometry for dimensions greater than two is an obvious candidate as are systems that are invariant under different geometric groups eg the group for mathematical is particularly rich in theories that have some notion of invariance and it will be to down the precise connections between these and type systems for which an abstraction theorem holds cardelli and describe a process calculus that builds in d affine geometry proving that process behaviour is invariant under affine transformations distinguishing points from vectors provides the appropriate abstraction barrier and the geometric group is determined by term syntax it would be interesting to their language in terms of our indexed types to obtain purely typebased invariance theorems geometric theorem proving is another application comments on the of invariance properties in this area programs in our framework automatically satisfy invariance properties removing the need for ad hoc proofs of these facts type and effect analyses use types indexed by effect annotations with algebraic structure eg sets of readwrite effect labels with an idempotent monoid structure benton et al have used relational interpretations to prove equivalences an extension of our framework with types should be able to express their monads and prove their equivalences extending our framework with type dependency would also allow for further applications for example we could consider a type of lists of length n indexed by elements of the permutation group sn et al have presented a general framework for relational reasoning and an abstraction theorem for dependent types however they work with pure type systems which define type equality via untyped rewriting so it is not immediately obvious how to integrate arbitrary equational theories into their framework semantic equality in general the semantic equality in definition is not an equivalence relation if the interpretations of all primitive types are partial equivalence relations then semantic equality is indeed an equivalence relation however this the geometry and examples more generally we can consider relational interpretations that are a relation is if whenever x y x y and x y are in the relation then so is x y is weaker than being a per but still suffices to prove that semantic equality is an equivalence relation hofmann has used relations in the setting of effect analyses covers all our examples except types note that for both pers and relations we need to close the relational interpretation of existential types under the appropriate property to ensure that all types are interpreted as relations for types it is possible that a new notion of equivalence based on is required acknowledgements the authors would like to thank benton john and martin will for discussions on geometry and types and were supported by grant references m abadi a n heintze and j g a core calculus of dependency proceedings popl pp r syntax for free representing syntax with binding using parametricity proceedings pp n benton ck a j kennedy c strongly typed term representations in coq journal of automated reasoning pp n benton a kennedy m hofmann l reading writing and relations proceedings pp jp p r proofs for free parametricity for dependent types journal of functional programming pp l cardelli p processes in space programs proofs processes proceedings pp computational geometry algorithms library user and reference manual available at s s gulwani and r continuity analysis of programs proceedings popl pp j geometric methods and applications for computer science and engineering springer j without loss of generality proceedings pp m hofmann correctness of program transformations formal logical methods for system security and correctness pp m p jones functional programming with overloading and higherorder polymorphism proceedings pp a j kennedy relational parametricity and units of measure proceedings popl pp a j kennedy types for theory and practice central european functional programming school pp ­ lncs vol s n t a coordinate free geometry adt technical report cs university of a m pitts parametric polymorphism and operational equivalence mathematical structures in computer science pp j and b c pierce distance makes the types grow stronger proceedings icfp pp j c reynolds types abstraction and parametric polymorphism information processing pp a sabelfeld and d sands a per model of secure information flow in sequential programs higherorder and symbolic computation pp n and proving noninterference by a fully complete translation to the simply typed lambdacalculus logical methods in computer science s and s translating dependency into parametricity proceedings icfp pp p wadler theorems for free proceedings pp 