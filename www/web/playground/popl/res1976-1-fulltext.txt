a complexity theory of grammar problems h b iii aiken computation laboratory university cambridge massachusetts i introduction the close relationship between programming language syntax contextfree grammars abbreviated cfgs parsing and compiling is wellknown and is extensively discussed in i unfortunately many of the problems about programming languages one might wish to solve are equivalent to undecidable grammar problems two especially important such problems are i the emptiness of intersection problem ie determining if the intersection of the languages generated by a pair of grammars is empty and the grammar class membership problem ie determining for a fixed class of grammars f and a grammar g if g is an element of f here we investigate two recently proposed ideas for the undecidability of such problems the concept was introduced in in an attempt to the undecidability of such problems as the emptiness of intersection problem intuitively the idea of fs to replace arbitrary contextfree languages by languages for which such problems are decidable the inherent limitations of the concept are discussed we show that for many different families of separating languages f it is undecidable if some language in f the languages generated by two arbitrary cfgs we also show that there are fixed lo such that for any family of languages f containing lo it is undecidable if some language in f the languages generated by two arbitrary cfgs these include ww rev i w i w and all languages over two or more letters the decidability of a variety of problems related to problem above is considered we show that for many classes f of cfgs and many binary relations p on the cfgs all predicates of the form for an arbitrary cfg g for some h in r are undecidable thus for example letting r denote the class of strong ll ll strong lc lc lr lr regular or unambiguous cfgs it is undecidable if an arbitrary cfg is is equivalent to is structurally equivalent to is covered by or covers an element of f the problem of deciding for a class of cfgs a class t of transformations and an arbitrary cfg g if some transformation t in t maps g to an element of is also considered thus for example if each t in t is language preserving ie for all cfgs g lg and the identity transformation is in t then for an arbitrary cfg g it is undecidable if there exists t in t such that tg is a strong ll ll strong lc lc lr lr regular or unambiguous cfg our results apply to many classes of transformations that do not contain the identity transformation as well we list several definitions and observations used in the remainder of this paper we assume that the reader is familiar with the basic definitions of and results concerning cfgs the strong ll and grammars turing machines and turing machine computations otherwise see i or definition ii a language l over a finite alphabet z is said to be i a definite event a n d o n l y where sets and is said to be this research was supported in part by us contract no and by nsf grant no ii a reverse definite event if and only if l where a are finite sets we note that all definite and reverse definite events are regular sets moreover the classes of definite and reverse definite events are closed under the next two definitions formalize the concept definition let ll l and s be languages over a finite alphabet z we sa that s se l and l or e q v a l e n t l y l pa n d l a r e i s e p a r a t e a b s if and only if and or and l definition let f be any family of languages two languages l and l are said to be i f if and only if there exists a language such that s l and l and are said to be ii f if and only if there exist two disjoint languages s and such that and ls clearly if two languages are f then they are f however f does not in general imply f if f is closed under then f and f are the same thus if f is the class of definite or reverse definite events over some finite alphabet z then two languages l and l are f if and only if they are f the basic construction in this section the basic technical construction needed to develop our complexity theory of grammar problems is presented unlike previous work we do not prove the undecidability of a problem by effectively reducing the halting problem for or some equivalent problem to n rather we prove the undecidability of by efficiently reducing the membership problem for turing machines that always halt to it this shows that n is of nonrecursive computational complexity for the problems considered here this suffices to show that they are undecidable let m be any deterministic tm with tape alphabet t and state set s that always halts on the right end of its tape then m is for some strictly recursive function tn given an input string x t o m two c f g s g i m x and c a n b e constructed in linear time on a deterministic tm such that l g i m x y i y z are ias of h and y z and i y is an id of h z is an accepting id of m where x i is an initial id of h on x let we assume that t and are mutually disjoint for sufficiently fast strictly increasing functions rn no pair of words in and common prefixes of length z for some positive integer c depending only upon h not x and are strong ll and grammars proposition let h tn c z and x be as described above let f be any class of languages over z containing all definite events over z let then in time cl lx cfgs g and g each of size c where c and c are constants depending only upon h not x can be constructed by a d e t e r m i n i s t i c m u l t i t a p e tm s u c h t h a t t h e following are equivalent m accepts x n lg and lg are not definite event and lg are not f lg and lg are not f g i s a m b i g u o u s gx i s i n h e r e n t l y a m b i g u o u s g i s n o t a s t r o n g l l k g r a m m a r g i s n o t an s l r k g r a m m a r a n d g i s n o t a b r c k k g r a m m a r p r o o f g a n d g a r e e q u a l t o g l h x x r e s p e c t i v e l y g i s t h e whose productions consist of and cfg a all productions of g and g b i where s and s are the start symbols of g and g respectively c d b ¢ e s f g h i i a and j w i bc we assume that is disjoint from the union of the nonterminal alphabets of g and g fs named after in topology if m accepts x then there exists a string w e lg n lg thus lg i and lg are not f or f for any family of languages f moreover since the unambiguous are closed under intersection with regular sets and is an inherently ambiguous cfl g is an inherently ambiguous cfg hence a f o r t i o r i g is ambiguous and is not a strong or grammar for any choice of g and if m does not accept x then n lg g and no pair of words in eg i have a common prefix of size k thus and lg are definite event f and f moreover by inspection of the productions of g g is a strong an and a grammar in sections and proposition is used to derive most of our grammar complexity results more details of the constructions of the cfgs gi g and g can be found in finally our undecidability proofs make use of the following two properties of recursive sets and that always halt property every deterministic tm that always halts makes tn moves for some strictly increasing recursive function tn and for all inputs of size n property for all recursive functions f there is a recursive set sf such that any tm that sf requires time fn for infinitely many n a proof of property can be found in was introduced in in an attempt to the undecidability of such problems as the emptiness of intersection problem the idea of is to approximate arbitrary by languages for which such problems are decidable here the limitations of the concept are considered we consider the question for what families f of languages is it decidable if an arbitrary of are f or f we show that this question is undecidable for many if not most interesting families of languages f one obvious candidate for such an f is the family of regular sets d e f i n i t i o n two l a n g u a g e s l and l sa t o be r e g u l a r s e p a r a b l e i f t e r e e x z s t d l s j o x n t r e g u l a r e t s r and r s u c h t h a t l l j r i and lr results in and show that regular is undecidable for the another obvious candidate for f is the family of but letting f equal the two l and l are f or f if and only if thus again f and f are undecidable we show that both the undecidability of regular and the undecidability of emptiness of intersection of the follow from a general undecidability theorem theorem below theorem let z be any finite alphabet greater than one let f be any family of languages that contains all definite or reverse definite events over z then it is undecidable if the languages generated by two arbitrary cfgs with terminal alphabets equal to z are i f or ii f proof we only prove the theorem for the f contains all definite events over z the proof for the case when f contains all reverse definite events over z is similar and is left to the reader the proof consists in showing that the decidability of f or f for any f containing all definite events over z contradicts property suppose for some such p that f or f is decidable for the cfgs then since the set of cfgs with terminal alphabets equal to z is a recursive set by proposition there exists a strictly increasing recursive function fn that bounds the time required to decide p or p h s e p a r a b i l i t y on a d e t e r m i n i s t i c tm let m be any deterministic tm with tn a strictly increasing recursive function we claim that lm is by a cn deterministic where c is a constant depending only upon intuitively given input x to f we would like dl to construct the cfgs g and g gv mx of proposition and then to if lg l and lg are f or f g and g of proposition can not be used directly because their terminal alphabets need not equal z a straightforward encoding can be used to construct cfgs gi and g with terminal alphabets equal to z such that the time and space required for their construction is still linear in ix i and such that conclusions i through of proposition hold with and g substituted for g and g respectively i in our terminology two languages are regular if and only if they are f with f equal to the family of regular sets the as follows given input x constructs gi and d f tests if and lg are f or f if x if n o t a c c e p t s x step i requires at most cn time and step requires at most time for some constant c depending only upon m not x o n if x lh then lg i and lg are definite event f and f thus j f r e j e c t s x if x then ¢ and and lg are not f or f for any family of languages f t h u s a c c e p t s x finally for all positive integers the recursive function fn n fn is strictly greater than an fan for all but finitely many values of n thus if f or f is decidable for the cfgs the every recursive set is accepted by some tm that is fn for all but finitely many values of n this contradicts proposition theorem shows how little is required for the undecidability of f or f the following corollary illustrates its power and applicability theorem let z be any finite alphabet greater than one the following classes f of languages over z satisfy the conditions of theorem i definite events reverse definite events events regular sets for all kl the languages ll languages deterministic unambiguous i linear ii context sensitive languages and recursively enumerable sets thus letting f denote any of the above classes of it is undecidable if the languages generated by two arbitrary cfgs with terminal alphabet equal to z are f or f theorem follows immediately from theorem and known properties of language classes i through definitions of these language classes can be found in ii and a slight modification of the proofs of proposition and theorem shows that the f and f problems for the cfgs are also undecidable for f equal to the in i the strict and realtime strict deterministic languages in ii and the lr languages defined in i finally since the cfgs g in the proof of theorem are strong ll and grammars many of the conclusions of theorem hold for any class of grammars containing the intersection of these three grammar classes thus for example letting f denote the definite events events or the regular sets it is undecidable if the languages generated by two arbitrary strong ll lr or grammars are f or f we have already shown that the f and f problems for the cfgs are undecidable for all families of languages that contain sufficiently many regular sets next a second sufficient condition on a family of languages f for the undecidability of f is presented we show that there are fixed lo such that any family of languages f containing lo it is undecidable if some language in f two arbitrary before presenting this result we need several definitions from definition i c is the class of all l o it is decidable if the language generated by an arbitrary cfg is a subset of l o ii i is the class of all l o for is decidable if the intersection of the language generated by an arbitrary cfg g and l o is empty definition a cfl l is said to forbidden it for all families languages f such that it undecidable if the languages generated an arbitrary pair of cfgs are be of is by f definition let l be a cfl let z be the finite alphabet such that then t el theorem there exist forbidden p t i l a r if a cfl l is not an element of i then l is forbidden similarly if both l and l are and l is not an element of c then l is forbidden proof a proof that there exist that are not elements of i can be found in we only show that if a cfl l is not an element of i then l is forbidden let let f be any family of languages containing l since l is a cfl there exists a fixed cfg go such that for an arbitrary cfg g lg and n are f if and only if thus since f is undecidable in we show that and all languages over two or more letters are forbidden the language is especially interesting because it is a theorem and results in can be used to show that f is undecidable for a variety of families f of languages that do not contain the definite or reverse define events eg the languages the languages the etc complexity of relations recently in and a complexity theory for certain types of grammar problems was presented these problems dealt primarily with the complexity of grammar class membership problems here these results are extended to a variety of other types of grammar problems we show that for many grammar classes f and for many binary relations p on the cfgs all predicates of the form for an arbitrary cfg g there exists a cfg h in f such that are undecidable thus for example it is undecidable if an arbitrary cfg g is is equivalent to is structurally equivalent to or is covered by a strong ll ll strong lc lc or lr grammar in what follows z is any arbitrary finite alphabet of cardinality greater than one and equals the intersection of the classes of strong ll and grammars with terminal alphabets equal to theorem let p be any binary relation on the cfgs such that i for all g in for some h in and ii for all inherently ambiguous cfgs g implies that h is inherently ambiguous let f be any class of cfgs such that iii of and iv f no inherently ambiguous cfgs then for g with terminal alphabet equal to z it is undecidable if there exists a cfg h in f for which proof the proof closely follows that of them let denote the predicate for an arbitrary cfg g with terminal alphabet equal to z there exists a cfg h in f for which suppose for some relation p satisfying conditions i and ii and for some grammar class f satisfying conditions iii and iv that the predicate is decidable then by proposition there exists a strictly increasing recursive function fn that bounds the time required to decide a deterministic tm let h be any deterministic tm with tn a strictly increasing recursive function e claim that lm is by a deterministic where c is a constant depending only upon intuitively given input x to we would like g to construct the cfg g of proposition and then to test if there exists a cfg h in r for which however g of proposition cannot be used directly because its terminal alphabet need not equal z a straightforward encoding can be used to construct g with terminal alphabet equal to z such time and space required to construct g is still linear in and such that conclusions i of proposition hold for g substituted for g the as follows i given input x d f constructs g i f tests if there exists a cfg h in r for which if s o d r e j e c t s x if x step requires at most cn time and step requires at most time for some constant c depending only upon m not x or i if then g is an element of and by i and iii there exists a cfg h in f for which gh t h u s r e j e c t s x if then lg is inherently ambiguous and by ii and iv there does not exist a cfg h in f for which x finally for all positive c the recursive function is strictly greater than for all but finitely many values of n thus i f is decidable for the cfgs then every recursive set is accepted by some tm that is fn for all but finitely many values of n this contradicts proposition the meaning power and applicability of theorem are best illustrated by examples theorem let p be any reflexive binary relation on the cfgs such that for all cfgs g h implies let f be any class of cfgs such that i cf and ii t contains no inherently ambiguous cfgs then for g with terminal alphabet equal to it is undecidable if there exists a cfg h in f for which proof the relation p satisfies c o n t i o n s i and ii of theorem theorem let f be any class of cfgs that i cr and ii y contains no inherently ambiguous cfgs then for an arbitrary cfg g with terminal alphabet equal to z it is undecidable if g is is equivalent to is structurally equivalent to covers or is covered by an element of r proof the definitions of structural equivalence and covering can be found in i let p be any of the following binary relations on the cfgs i if and only if gh if and only if if and only if g is structurally equivalent to h if and only if g covers h and if and only if g is covered by h then p is reflexive and implies thus each such relation p satisfies the conditions of theorem and theorem follows directly corollary let f be any of the following grammar classes i grammars strong ll grammars ll grammars strong lc grammars lc grammars grammars grammars grammars lr grammars i lr regular grammars ii unambiguous grammars basic grammars full grammars grammars and grammars then for an arbitrary cfg g with terminal alphabet equal to z it is undecidable if g is is equivalent to is structurally equivalent to covers or is covered by an element of f proof definitions of the above grammar classes can be found in i and the corollary follows immediately from theorem definition i any function t with domain and range equal to the family of cfgs the family of cfgs with terminal alphabets equal to z is called a · transformation on the cfgs on the cfgs with terminal alphabets equal ta z ii a transformation t is said to be language preserving if and only if for all cfgs g theorem let t be any set of transformations on the cfgs with terminal alphabets equal to z such that i for all t in t t is language preserving and ii the identity transformation is in t let f be any class of cfgs such that iii and iv f contains no inherently ambiguous cfgs then for an arbitrary cfg g it is undecidable if there exists t in t such that tg is an element of y proof the proof of theorem follows e a s y from theorem and is left to the reader finally we note that similar results hold for many classes of transformations that do not contain the identity transformation eg the transformations in conclusions a complexity theory for many different grammar problems was presented sufficient conditions on a class of languages f for the undecidability of the f and f problems were presented most classes of languages studied in the literature satisfy those conditions sufficient conditions on grammar classes f and relations p for the undecidability of the predicate for an arbitrary cfg g there exists a cfg h in f for which were presented relations satisfying these conditions include equivalence structural equivalence and covering grammar classes satisfying these conditions include the classes of strong ll ll strong lc lc lr and grammars i av aho and jd ullman the theory of parsing translations and and prenticehall nj and k ii and r grammars an extension of lrk grammars hopcroft and jd ullman formal languages and their relation addisonwesley reading mass hb iii and tg complexity for contextfree grammar problems princeton university computer science technical report july also submitted for publication j and hopcroft an overview of the theory of computational complexity jacm k ii and r grammars an extension of lrk grammars tg generalized bottomup parsing phd thesis cornell university new york may wf unpublished note december r and s counter free automata press cambridge massachusetts i aj and hopcroft simple deterministic languages ieee conference record of th on switching and automata theory october ii ma and im strict deterministic grammars hb iii and jl decidability of equivalence containment intersection and of contextfree languages center for research in computing technology tr university cambridge massachusetts october de knuth a characterization of languages inf and control hb iii tg and jd ullman operations on sparse relations and efficient algorithms for grammar problems proc th annual ieee symp on switching and automata theory october is on the complexity of lrk testing conference record nd acm symp on principles of programming languages january bm deterministic translation grammars phd thesis university cambridge massachusetts cn fischer on parsing contextfree languages in parallel environments phd thesis cornell university new york april tg and extensions of bottomup parsing techniques to appear in siam journal on computing 