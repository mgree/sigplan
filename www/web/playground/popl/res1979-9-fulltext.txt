the logic of a relational data manipulation language a and philip a aiken computation laboratory university cambridge ma abstract a logic for a relational data manipulation language is defined by a known logic of programs with rules for two new state ments the relational assignment which assign a relational expression to a relation and the random tuple selection which extracts an arbitrary tuple from a relation the usual operations on insert delete then defined as special cases of the relational assignment and the foreach construct scanning a relation tuple by tuple is introduced with the help of the language in as the first of database the manner of ow step towards studying applications such as we view our work the correctness those above to support our dml logic we start by selecting a framework that is adequate to describe databases and that has a reasonable underlying logic in fact we will argue that the relational model c is so close to predicate calculus that the former can be subsumed by the latter hence the question of the underlying logic is solved random tuple selection as for the dml logic we will augment a known logic of programs dynamic logic with rules introduction for two new statements assigning a relational the assignment expression to a relation and a database contains data that models some aspect of the world the description of a database consists of a set of data structure descriptions and a set of consistency criteria for data values to say that the data values in a database satisfy the consistency criteria is to say that the data the random tuple selection extracting an arbitrary tuple from a relation the familiar operations insert delete update will be defined as special cases of the relational assignment the foreach construct of sc will also be given a definition models the world as a users expect to observe consistent to updates that will such updates are called es consequence data and are preserve con transactions re we finally logic is not programs note essential to any that our to dynamic and our results should be logic of nondeterministic most of the work concerned with the correct a for data of type relation ness of database systems assumes that only transactions access the database and the interaction among actions by a general correctness criterion how ever we know of no attempt to provide a data manipulation language dml with a logic permit us to prove that a transaction indeed pre serves consistency or that a set of transactions as mentioned in the introduction we choose the relational model c as our framework for de databases mainly because it can be into predicate calculus by we mean that the key notions of the former can be re as some of the very basic concepts of the latter see fig the between the relational model and predicate calculus have executed concurrently is correct a dml logic been used before but the becomes especially important when the set of trans actions is known in advance as the general correctness criterion can be to the application in question and verified la examples of such database applications are credit verification and tion control and electronic transfer be we will investigate in this paper the logic of a sequential data manipulation in the future we plan to embed it in a general parallel of relational theories although clear and independently schema and firstorder appeared only recently to the claims of fig let us first review some concepts in the relational model stored data is viewed as relations unordered tables and is described by relation schemes giving names to the tables and their columns an integrity then becomes a relational expression written in some appropriate language a relational schema r is a set of relation schemes and a set of research research supported supported by the by the national national science de grant foundation under grant integrity one for integrity assertions each relation assertions database state if a set scheme of then s is of r s of relations r satisfies all called a con figure relational model schema attribute relation integrity name name assertion consistent state union of underlying relation extension domains predicate calculus theory standard unary predicate nonstandard predicate axiom model domain relation symbol symbol hence definition we have the way to the following definition t is called a a theory schema iff i includes lt the set of a finite set of predicate and symbols symbols of t ri ii t the axioms of t includes for each ri exactly one axiom of the form where vx xk k a i pl ai x p moreover we say that ri is a database relation the special axiom for ri name and j is the relation is an scheme of ri which we abbreviate is an integrity assertion a model state s of t is a consistent database u however not all integrity assertions can be translated as axioms the socalled dynamic assertions impose restrictions on the possible state transitions of the database rather than on the set of acceptable states a wellknown example is the of each table emp must be listed in in es the prefixes and as in and were proposed to indicate which state must provide the value of emp we do not this approach elegant because it the definition of interpretation from predicate calculus in a fundamental way therefore we pro pose a novel rewrite for dynamic integrity assertions using pairs of formulae this problem is then rewritten that avoids as follows s s where is a defined predicate symbol whose purpose is to the value of emp in the initial state that is plays the role of we then define the notion of schema with dynamic integrity assertions as follows definition called a assertions iff a triple schema with t dynamic integrity is i is a relational schema ii d is a finite set of pairs of formulae of lt the dynamic integrity assertions u the role of relational schemas become clear later on when we discuss the notion of trans action for the time being it suffices to remember that stored data is viewed as relations finally relation we introduce the notion of a key of a definition schema relation scheme set let and of such that a key of be a the ri is a j ek where xl xk u in words the value of ri at any consistent database state of t must be a relation such that if two tuples agree on the m k they are equal note that we allow subsets of k to be themselves keys of ri hence our definition although sufficient for our purposes differs from that in c a logic for a data manipulation language our efforts in this section are directed towards defining a dml logic by dynamic logic pr with rules for two new relational assignment and the random tuple selection the logic thus obtained be called relational dynamic logic in we discuss and then proceed to ments in and the overall introduce architecture of the two new state the architecture of relational dynamic logic let be the e aj a and u see appendix that there is a set of dynamic logic over i we assume predicate symbols of le lr the stored relation names we construct by adding two new statements to dl the relational assignment and the random tuple together with their corresponding axioms as discussed in and to the of relational dynamic logic we write we say that adequate universe iff has an i for any variable individual a there that x of and any is a state u such ii for and any binary relation iu such that rr stored relation r c there name is a state the motivation closely the note in we discuss for this appendix relational concept follows i and will become assignments finally we say that a schema is a schema of iff lt coincides with la the database relation names and attribute names of t are stored relation names and the underlying deductive system of t is da similarly we define a dynamic schema of the relational assignment examples of relational assignments using relation schemes and writers are the that into authors all written by and of a n a n c that updates the listed with to likewise we could give examples of and written as relational assignments thus we achieve a certain by adding the relational assignment to dl as just one statement suffices to describe the operations commonly pro by existing relational ie insert delete and update our approach to further justified by relational assignment the the relational simplicity operations of the is definition relational assignment formation rules for the r ali ij u i iff i a is called a relational of where r is an nary predicate symbol of lr xx xn is a set of distinct variables of le and free variables ax is an open wff of e with u hence ij associated with is in the binary tr a iff relation i and j differ only on r and rj consists of those tuples ev such that when z is given as value a becomes valid in i the central result about relational assignments goes as follows theorem suppose that has an adequate universe then for any wff q of la u rx ax q u q where q denotes the wff of xa obtained by replacing each atomic formula in q of the form rtl tn by a where a is a variant of a created by renaming bound variables of a that also occur in q r an example may the construction of q s i i i calling a the righthand side of s the equivalence in is obtained by replacing i in q by where a is created by renaming i in a by avoiding conflict with the use of i in q the usual follows relational operations are defined i as definition relational operations a rz al r r does not occur in a al where b insert r ai rx r c rz ai fi r aa d update r rj ai a a r a al u the translation of the update the trivial one should be read as follows the relation name affected in a transition to j only non where r is from i fm if i in y does not add add ri do satisfy to a rj to rj the random tuple selection construct and the foreach the purpose of introducing the random tuple selection is confined almost entirely to the of the foreach the main of this section the foreach construct has the same as the construct of for each where c usa key name do for each isbn do end if then a end that only published authors with more than in terms c a assignment the foreach follows algol with the relational construct is defined as for each r where a key s end a ro a ro b r r aa c u z r y do d begin rand iz e x f s g rt rj aa k end ak where xl of e k encodes is a set of distinct variables key of r and and are auxiliary predicate symbols of lr the definition can be explained of the foreach as follows sketched above a the set of tuples already equal to initially scanned is the value of b the set of tuples the value of the initial value initially equal of r for scanning to the set of and satisfying tuples a in c the loop will been scanned terminate when all tuples have d a random tuple is selected scanned hence giving the implementing the scanning from those not system freedom operation yet for e the tuple selected o f s is executed above is added to the value g as s can modify the value of r we have to the set of tuples not yet scanned this is done with the help of the key k as follows a tuple in the current value of r is for scanning if it satisfies a and moreover its key value does not match that of any tuple already scanned hence the third conjunct in g in order to express in dl we need the relational assignment which we already have tests over quantified which are readily obtained and a new statement the random tuple selection defined as definition formation tuple selection rule for the random x is called of lr variables a random tuple selection of where r is an nary predicate and x xl xn are distinct of e symbol u hence ij is in the binary relation associated with iff i and j differ only on and j comes from ri the central result about the random tuple selection goes as follows theorem suppose has an adequate universe that for any wff q of la r zl q u we emphasize that the random is in itself but it to the definition of the sketched in tuple selection gives precision construct definition the foreach construct for r ax y ay rt r aa r s end is called a foreach construct of where r and in lr r and are nary predicate are chosen for the translation of each foreach construct occurring in a program xn are distinct variables of le a is a wff of with free variables n is key of r s is a statement of u although no special rule for reasoning about the foreach construct is needed an induction rule on the number of tuples already scanned has been found useful ca the basic idea lies in intro an invariant with certain properties in order to hide the translation contained in tion instance with that such a rule one can prove p where for p true q springer at w for each key title do if e springer then update end where a a tt using as inductive assertion i vi at the rule we have in mind is stated below theorem suppose has an adequate universe below is valid in u that then rule fe stated fe api r aa a where are predicate symbols in lr as in definition p is a wff of la possibly containing i is a wff of la possibly containing r but with no occurrences of i is obtained from i by replacing each atomic formula of i of the form by ro a and w each r a key k do s rule that r processed fe should holds the be read as follows we tuples in r already that before entering the foreach p and the fact that no tuple was processed must imply i asserts that if s is started in a state j where j holds a tuple in rj satisfying a j is already in see and i holds for all tuples in nj except j then s must lead to state k where i holds for all j asserts that tuples in r in k when the ends i and the fact that all tuples have been processed must imply q summary the relational data manipulation language we consider in this paper is created by adding two new basic statements to those considered in dl the relational assignment and the random tuple selection the corresponding logic of programs called relational dynamic logic is obtained by adding two new axioms to the system of dl rs theorems and assert that axioms ra and rs are sound and moreover that the assertion language is expressive in the sense of ha for the new statements hence following ha we can state theorem completeness suppose that has an adequate universe la contains arithmetic each in the universe u assigns the standard interpretation to symbols and the deductive system for la is complete for u then for any wff q u the relational insert delete the foreach construct as defined symbols of need no special treatment however an induction rule omitted for reasons of brevity on the number of tuples already scanned can be stated in order to hide some details of the definition of the foreach construct transactions given a relational dynamic schema t we say that transaction wrt t if a program s preserves of the database described by iff s satisfies two conditions s is a the con t that is i s maps consistent states states into con ii for each dynamic integrity ab ed if s starts in a state s must terminate in a state satisfying assertion satisfying b a it would certainly be helpful find a formal characterization of but as we noted in relational logic is complete ha with the necessary theorem therefore we have if we could i and ii dynamic in the sense stated in of theorem let be constructed as in theorem and t be a relational dynamic schema of then a program s of is a transaction iff i for any axiom adt dt ii for any dynamic integrity ab d t assertion c thus at least in theory we will not fail to prove that a program is a transaction due to weak of the much more difficult question of finding a proof procedure for our logic remains conclusion in dynamic logic was augmented to include a relational data manipulation language creating a logic of programs that we called relational dynamic logic contains two axioms in addition to those of dl for the relational and the random tuple tion these new axioms are sound and the whole formal system can be made complete with certain as in ha the simplicity terms of construct statement we see in our work lies in its the four operations on relations insert delete defined in the relational assignment and the foreach was for with just one more the random tuple selection verification from the point the relational cf view of program model was shown to provide a reasonable language inter face to databases no special purpose logic is needed as the relational model can be understood as an application of the very basic concepts of predicate calculus references be ca ca ch col c c es es pa et al the concurrency control mechanism of a system for distributed databases computer corporation of tech rep dec design and information pa et al implementation systems an approach to the of interactive draft relational on math science jm on semantic issues in the model of data proc int symp foundations of computer science lecture notes in computer springerverlag sept progress ma the logic of a data language technical report in dd et al sequel approach to data definition and control ibm tech rj june a rep ef a database on the relational calculus proc workshop on data description access and control acm large ef a relational shared model of data for cacm june cook sa semantics for an algol univ of and fragment kp and dd func tional specifications of a subsystem for database of the int conf on very large data bases system kp et al and predicate cacm the notion of in a data base pp hall m pi and dj integrity in a relational data ment system proc of the int very large data bases semantic base conf on ba d logics of programs mit computer science tm completeness laboratory april in for he held gd mr and e relational database system proc national computer conf pp la m and a oriented relational int conf on very pp languages large data domain proc bases of the la lamport l towards a theory of correct ness for data base systems massachusetts computer associates tech oct rep j search strategy and selection function for an relational system acm march pp nt j first order logic formalization for functional and mutual dependencies acm int conf on management of may pp ow i ss axiomatic for parallel programs science cornell univ july proof dept tech techniques of comp rep pa ch pa and some computational problems related to database concurrency control proc of conf on theoretical comp science aug pp pr pratt vr considerations on proc of the th ieee found of comp science conf oct pp some highlevel language constructs for data of type relation acm sept pp st re pm concurrency systems proc of comp science conf lewis and dj rosen control for data base the th ieee found of oct pp th thomas rh a solution problem for multiple copy uses distributed july to the update databases which tech rep va van computational information the ifip conf of the working formal specifications of prog pp and de proc of group on lang aug ya a recursive logic academic press function theory and appendix i concepts from dynamic logic we review stand sections here just what is essential to under and referring the reader to for a full for short description of dynamic logic dl dynamic logic is based on a few parameters a language le the expression language specifying the expressions allowed in programs an extension of e la the assertion are used to express correctness assertions whose a deductive system da u of states for formulae of a with common and a vu each state being a structure for together with an assignment a with of values domain vu ya for the variables of la to these parameters of dynamic logic we often write a program in dl is relation on u two basic are provided defined as a binary programs or statements lx t an assignment where tl x x is a variable is called and t is a term of and j differ only indicates x on the value that of x i ij p is called a test where p is a wff of le i p indicates that p is valid in i programs operations are created by the following s and reflexive components and s transitive the composition union closure of their in order new formation languages to express facts about rule is added to those programs a of firstorder if p is a wff of dl or and s is a a program then sp is a wff of dl the notion sp as follows of interpretation is extended to i sp if sp is then introduced interpretation aj p as sp with i iff p dl contains the inference in addition wff of la following to those axioms of a and rules q is a of lo qt pq px q sl u sq sq bi sq s invariance la da ui has an adequate universe iff for any variable x of le and any individual there is a state u such that for adequate axioms to are sound and and invariance are valid we refer the reader to ha for a discussion of the relative completeness c of dl note are when discussing tion must be to instance if no state the binary relation empty us hence axiom is not adequacy of in principle arbitrary how a logic of programs the choice made for i in u x as associated with x is to derive l x true sound in u the notion of this appendix proofs before proving about the construction theorem we state a le of from m as de in the statement of the theorem we use to indicate that n is a variant of m that is n is obtained from m by renaming variables lemma a m nv xm r n m xx x is free in m and i is a constant the proof follows trivially from the con of m u theorem suppose that l l d r e a a u has an adequate universe then for any wff q of l a pu rl qq u proof an adequate suppose universe that let q be a wff of has la and s r al be a relational assignment of in the sequel u and n denotes the denotes u the arity of r domain of we observe q initially sq that vi if q q si iq by def and s is a total function has an adequate on u universe therefore all we have to prove is that for ij es moreover by def we know that ij e s i ff i j a iff i la we then fix ij cu satisfying and prove by induction on the height of q basis assume q s s symbol of l a case sr j q j lr i aj by i la by i la i iq a is a variant no variable of of a with q bound construction of q case s r follows similarly induction step assume for formulae less than k and let q be of height consider only the case where q xm j iq j l of height k we j mi x i is the name of some of j by j in of xr induction and m height hypothesis have the same as ml x i lemma and variant theorem i x i is also the name of some individual of i as i and j have the same domain and by of j xn i lemma i iq this construction the proof a of q r u theorem suppose that has an adequate universe then la r for any wff q of q d proof suppose that has an adequate universe let q be of la and s be a random tuple selection of in the sequel v denotes u the domain of u and n denotes the arity of r let then we have i of i ai e x ai x i and j differ only on g has an adequate universe q q of of vm from we can conclude our result sq q iff q iff sq q this concludes the proof of i u theorem suppose has an adequate universe u that then rule fe is valid in u proof the proof is a straightforward cation of the system of for brevity we present just a summary in the style of ow w p ox ai rt ri aa p vx w p ai ai p w p r ai ai p lo w rz ai u p theorem completeness suppose that has an adequate universe l a the universe contains arithmetic each state u assigns the standard in tion to symbols and the deductive system for any wff q l a of is complete for u then iff q for u proof we argue here that the completeness of dl ha extends to the completeness of it follows from theorems and that for any relational assignment and any wff p and or random tuple q of la selection s there is a wff r of la such that iu iff iu iff hence using the completeness of dl and the above results by induction on the structure of a formula s of and on the structure of a program s of we can prove for any wff s of there is a wff s of l such that a of l a for ss for any program s of and any p and q of la iff q for any program s of and any p and q of la iff from we can then conclude the result for any wff p of p iff p u theorem let be constructed as in theorem schema of and t l d d be a dynamic then a program s of is a transaction of t iff i for any axiom adt d and ii for any dynamic integrity assertion a b d dt tl u proof let s be a program of let a a where ad t of a then s is al is the a transaction of t closure iff vi for any ab d and by definition of sq is equivalent to u sl and for any ab ed u a sb by theorem and assumptions on is equivalent to s and for any ab cd finally by the deduction theorem and is closed s is a transaction iff i sz and for any a sb ab ld u 