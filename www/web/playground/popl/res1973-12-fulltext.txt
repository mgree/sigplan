mode modules as representations of preliminary report massachusetts alice e fischer massachusetts and institute michael j of technology cambridge introduction high level programming languages tend to free a programmer from concern about the underlying machine structure ad permit to talk about his problem domain in more direct terms thus he may imagine that objects such as real numbers character strings and linear arrays really exist in the machine as atomic entities and he need not understand the details of how they are actually represented in the machine of course what various kinds of objects are the operations that may b performed on them so when about the domain of real numbers we should include the basic arithmetic operations and constants and for strings operations such as length concatenation and indexing unfortunately existing languages do not permit a programmer to ignore completely questions of representation for if his problem domain does not happen to be included already in the of domains supported by the language the programmer must figure out a representation and remember it throughout his programming effort for example a fortran programmer may know that it is not meaningful to multiply two integers that happen to re policy numbers he has no way of the compiler of this fact many extensible languages do provide a wide range of data types including structured types enabling a programmer to choose a more natural his external objects representation of but the structured data types reflect only the structure of the data not its meaning they provide only one natural representation for both integers and mass and speed or vectors in cartesian or this research was supported in part by the national science foundation under research grant gj many domains that arise in practice have a deal of similarity them which one must employ in his programs for example the domain of length vectors and the domain of length vectors have the same rule of addition that is add and it would be to have to repeat this information for each new length vector thus one needs both the ability to define new domains and also a method for expressing relations among them we present here some mechanisms called which allow the expansion of a programming languages of internal domains many of the ideas in have been described previously in te literature and we their influence on our in particular the work of l and reynolds the utility of separating out the abstract behavior of an object its representation and the languages pascal which associate functions with data types and types with alternate representations modular generic functions in wide variety of structured data ad the systematic though not extensible treatment of coercion in algol our domain mechanisms certain s to those developed by morris for the purposes of protection representation of domains semantics of types a variable to be of a data type limits the set of possible values which may be assumed by the variable this has obvious to a compiler enabling more efficient code to be produced it also affects the language with to program verification and modularity even in the socalled languages where variables are not declared actual data values have types which affect the semantics of programs each type forms a domain over which functions are defined and types must be tested to determine which interpretation of the builtin generic operators is applicable in each context thus apl evaluates scalar and expressions differently and lisp between atoms and lists extensible types the the variety of types available in a language the more likely one is to be able to find a type which is a good model for the objects of his external domain thus facilities have been included in various extensible languages cf algol j el i such facilities typically permit the declaration of data objects structured objects whose parts are drawn from previously declared types restricted in various ways and types which are finite unions of other types unions and pointers permit run time and dynamic growth of data objects useful as these types are for modelling external they have two major both of which occur because the types come with a builtin fixed structure first for each kind of structure there is only one corresponding type and hence only one domain whose objects have that structure however one frequently deals with different domains whose natural representations have the same structure for example two dimensional vectors in and the same vectors in cartesian are both naturally represented by a pair of real numbers yet the representations behave differently under addition so no single definition of addition of pairs of reals is correct for both domains the second is that the kinds of structures provided are fixed and not always appropriate for a given domain for example an upper matrix can be mapped onto roughly half the number of storage cells required for a full matrix of the same dimensions but the required mapping function does not correspond to the one usually associated with rows or arrays represented types in abstractly a data type t can be characterized as a set of objects all created and accessed and all as members of t that is type is characterized by its constructor predicate and selectors a to separate from its physical the behavior structure of a type it is la structure defined in are the simple types real integer etc and the row tuple and pointer type constructors similar to those in from these represented types with different properties may be created abstractly a represented type is a completely new set of objects with no pre define structure the accessing and other primitive operations on it are all supplied by the user to permit these objects to be represented in the computer one specifies an existing set of objects usually itself a type as the representation of the new type the functions rep and make are the necessary between represented and representing modes thus if new mode n is represented by m b is an object in m and a is an object in n then is an object in m is an object in n and the two identities hold b the necessary accessing and constructor functions for n are then defined in terms of the functions rep and make this being done the program can be written using just these defined functions with no further concern for the underlying representation in this way we achieve nearly complete independence of a represented from the type used to represent it for none of the functions defined on the underlying type are defined on the new type rep and make are the only links between them thus each type is a module protected from interactions with other modules the generic function facility to be described later on plays a role here in function f to be defined over a new mode quite independently of whether has been used for a function the name defined on some other mode a relations domains frequently in an external domain there are several natural subsets of the elements which have special property enables especially efficient computation or representation thus one may wish to have several representations for a given external object to the extent that the representations really model the same external object they should be that is any representation should be acceptable to a function without the result thereby eliminating the of function definitions otherwise necessary for example a matrix can be represented as a array of storage but other techniques can be used to represent sparse matrices in less storage assuming we have defined the types and we would like to express the fact that both kinds of objects are instances of the abstract notion of structure classes all data structures of a given form constitute a natural domain with the constituent types as such as the classes of all pointers all rows of reals or all length rows these domains are in and functions defined on them may be applied to any object in the class examples are the coercion from a pointer to a value and a general print routine that can print anything domains another useful kind of is specified by a predicate on a domain example is the set of all members of matrix such that the objects two dimensions are equal in one can declare such a domain and use it as the domain of be applicable functions which may not over the full domain with the that these functions will never be executed with arguments the predicate thus one might use the domain in defining matrix inverse conversions in some cases where multiple representations of the se external objects exist it may be to convert automatically from one representation to another rather than have a special function for each combination of representations a familiar example is the numeric conversion from integer to floating point that allows to be applied to a pair of arguments one of which is an integer and one a real the mode graph the data base used in to describe the modes is called the mode graph the nodes of this are modes each the internal model of some and the of semantic information about it the edges of the graph are relationships among modes the parts of a mode below are a representation set a set of edges leading modes to related a set of typed function called generators names an individual mode might lack one or more of these parts the node graph is built up piece by piece in almost any order by declarations modes are created by the declaration decl mode mode name the single restriction on the order of declarations is that a mode must be created before its name can be used in other declarations representation sets every type has an associated mode in the language by allowing all functions to be defined over modes and all domain relations to be expressed in terms of modes representation ts are created and attached to a mode by the declaration new mode is rep representing mode this creates a set of new objects as above which will be objects of the new mode mode relations variants of the single declaration form yields mode if predicate via conversion suffice integer to express all three kinds of domain relationships and the appropriate edge from mode to mode in the mode brackets denote optional phrases the clause is used to determine the choice of when it becomes necessary to apply a function to arguments of a domain on which the function is not directly defined paths of low total are if is not specified it is taken to q the simple relationship is expressed if all the optional clauses are absent tor example yields matrix note that one main mode m may have several ml ln each being a particular representation mode and it may be the case that no data objects belong directly to m rather an object is related to by of its to some mi a mode is declared by adding the if cause the predicate here is restricted as follows it is a boolean function of one argument it is defined over the entire mode its evaluation causes no side effects within these limits the predicate can be any function or single body belonging to a generic for example matrix yields if bool declares the condition under which a matrix is square the functions and give the dimensions of a matrix note that the declaration m yields m if p necessarily implies that m is a subset of m thus the modes with their subset and predicate links form a partial order the mode any is the upper bound of this order that is all modes are subsets of any to declare that mode is to mode the via clause is added and the il clause may or may not be used the conversion given here can be any function or single body of a generic such that it takes a single argument and is defined on all mode objects which satisfy the predicate it has no side effects it returns an object of mode example real yields int if r via int yields real via note begins inline definition a function while the notation denotes that body of the generic named which is defined for a real argument of fix both coercions and conversions permit a function defined one mode to be applied to an element another however the latter causes change of representation and a corresponding change of mode of the argument while the former does not on of a generic functions we noted above that generic functions are useful in avoiding naming conflicts among domains in they serve this role but also a more important one they are the means for making use of the relationships among modes the abstract function ranging over an abstract domain is modelled in by a generic function defined over a mode m which can take as argument an object from any of m this generic s written only in terms of the generic selectors or declared for m and each of a generator declaration is a list of typed function names naming the set of functions which are required to from computation in each mi to computation in m they express all information necessary to link the functions defined on m to the modes mi each mi has a function defined on it corresponding to each generator of m whenever the evaluation of a generator of m is required the actual argument must belong to one of the representation in order for the call to be legal and the corresponding function defined on the is then executed example matrix operations such as addition and multiplication can be defined in terms of the subscript and dimension functions and arithmetic on the matrix elements thus subscript and might form an adequate set of generators for the mode matrix interpreting the function call the interpretation of a generic function is determined by the modes operands and the information the mode graph so mode matching is complex procedure than about identity of its in a more simple the interpretation chosen for a call a an will be that function f fn g such that each ai is in the mode of the fi the total cost of applying this is less than that of any other interpretation the terms in and total cost are defined as follows an object a is in mode m if there exists one or more through the mode graph from mode of a to m such that all predicates are satisfied for a the total cost of applying a function the associated with the interpretation itself plus the cost of each argument the cost of an argument a is the cost of the chosen path from to formal this path has minimal of all paths along which all the cost predicates are satisfied the cost of a path from mode ma to formal mode mf is the sum of the on each edge of the mode graph which is traversed by the path conclusion we have proposed some mechanisms to enable program modules to model external domains definable data types definable and modes and a function application mechanism which combines and generalizes the usual coercion and automatic facilities the full mechanisms is realized used in combination function conversion power of these only when they are references rm proc te fischer a and p on the basis for z an extensible language facility proc pa y oj b k base computing centre ib morris protection in languages comm acm january reynolds jc a simple language based on the principle of completeness and the reference concept comm acm may t va definition facility for programming languages thesis carnegie institute of technology pittsburgh pa ea users technical report aiken computation laboratory university van a bj and on the algorithmic algol b treatment of data types in ml report to for command and management systems electronic systems division lg field mass from university n e pascal acts informatica 