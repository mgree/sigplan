decisions for type in apl dept w ii m a of computing and information university science abstract the meaning of type in an apl extended to contain nested arrays is dis it is shown that type is closely related to the variety of empty arrays of the same shape and to the possible fill values needed in the expand and take functions choices for fill functions are systematically presented they are classified according to the possibility of maintaining important identities involving functions in the case of empty arguments to their effect on other design choices still to be made the restriction to arrays and the definition of the nature of basic data and to their ability to express type in a natural way introduction the apl community has been with the design of a recursive data structure extension to the language for several years this paper is an attempt to summarize the choices that must be made in the design of such an extension the present is mainly concerned with three issues i should one allow arrays whose items are of different type ie heterogeneous arrays or should one restrict the extension to arrays ii should the items of an array always be arrays which leads to a floating system where the basic scalars contain themselves as items or should one have two sorts of objects namely arrays and basic data which leads to a system iii should an empty array be completely defined by its shape or should the work in this paper was part by the national research grant a supported in of there be more than one possibly many different empty arrays of the same shape the first two issues are discussed extensively in where it is shown that the universe of heterogeneous arrays contains the universe of floating arrays arrays as a proper subset a natural mapping is constructed from the to the floating universe and it is shown to be onto but not arrays in the universe that contain a basic scalar in a sequence of nested arrays and that differ only by the number of such coincide in the floating universe this effect is known as the scalar in it is argued that a subset of the universe provides all the capability required of a data structure extension to apl and that this has the interesting property of using the arrays of current apl as the building blocks in creating structures a consensus on issues i and ii has not yet formed within the apl community we leave their resolution to other here we concentrate on iii an issue left in our purpose is to explore the possible decisions on iii and indicate the inter dependence of this issue with the decisions on issues i and ii the concept of type in apl the word type is used to mean many different things in the programming lan guage literature in fortran and algol declarations bind identifiers to locations or arrays of locations type is used in a declaration to indicate the contents that the location may hold this may be viewed as providing information about the repre of data in hoare gives a much more general concept of type which has adopted in pascal while a simple type in pascal is essentially the as algol type pascal allows the construction of new types from existing ones using the structuring mechanisms of record and fixed arrays thus type in the sense provides information not only about content but also about structure in recent work liskov the concept of type has been further generalized to abstract data type in which a data structure and operations on it are into a module with access to the contents of the data structure limited to that pro by the operations defined as of the data type classes an example of such abstract data types all of the languages discussed above are typed languages ie identifiers are bound to objects of specific by declarations type information is used at compile time to verify that the objects are properly typed and to generate code that is specific to the type of the objects being manipulated hence in a typed language little information is re at run time apl on the other hand is a language ie there are no fixed bindings between identifiers and objects they can represent that is not to say that apl objects do not have type attributes each apl data object is either an array of numbers or an array of characters moreover the information concerning the shape of the array and the type of its items must be carried with the object at run time type itself in apl mainly in the definition of the primitive func tions that have need of a fill item expand take and in some apl imple it also plays an implicit role in the domain constraints of many of the primitive functions the type of a nonempty array may be viewed either as describing attributes of the entire array or as describing attributes of some or all of the items of the array either view is compatible with the non empty arrays of current apl since all arrays are and only arrays exist in the two views of type are examined in the context of nested arrays and it is shown that if type is a property of items then there can be only a single empty vector but if it is a property of the entire array then there can be an empty vector corresponding to each type the same rule applies for empty arrays of other shapes in only a single empty vector is proposed whereas in apl there are two empty vectors to numeric and character hence the proposal of is not a pure extension of current apl in the rest of the paper we are concerned with finding an extension that preserves the distinction between and on the assumption that only a pure extension of apl will be acceptable to the apl thus we explore the second choice for issue iii namely that there will be more than one empty array of each shape how many should there be we are in this question by the ing assumption which we take as intuitively desirable for every empty vector there exists a distinct item distinct fill we functions defined the existence of two for all arrays empty a denoted vector with a whose value is the the same fill as a fill a denoted aa whose value array whose item is used from a is the to fill then the above more precisely assumption may be stated by the identities a a aa oa aa a which state is idempotent the fill of an array is the same as fill of its the of an array is the same as the of its fill from these identities aa aa we have by by by by which shows that fill is also idempotent the fill function provides a of the underlying attributes the array that are preserved into ness thus if one views this tion as one of type then the meaning type in an extended apl will be by the choice of the set of values that fill may take on of of the choices for fill in extended apl the universe of nested arrays given in has to be in order to provide the larger set of empty arrays that is required by the corresponding values of the chosen fill function first we from the all arrays that are empty or contain empty arrays at some nesting level then we add new empty arrays corresponding to the fill values of the nonempty arrays building all arrays that contain the new arrays as items extending the domain of the fill function to them and that process as long as new fill values occur the result ing universe can be described as the smallest set that contains original each nonempty universe array of the is closed increasing ed apl under nonempty array by the structure and functions of extend contains a distinct empty possible value of the fill each shape with at least array for one zero each and characterization of and let us characterize fill function if begin by trying ct we define to use fill to for a given an array to be aa a fa for every selection function f let ao denote the fill function of current apl are apl then all arrays of current empty figure let us arrays disjoint divide the set of all non with nonempty classes according to into basic data are items are all basic data r all not basic data u both basic data and not basic data x figure a classification characters s numbers and characters t vw yz of nonempty arrays in a system the second row items are all not basic data could be labelled items are all arrays while in a floating system this description in a floating system every array the vertical thus dis is of much importance than in a system the nonempty arrays of proposal section the arrays of figure fill function implicit in as follows the include the is defined a o if a e s b if a e where b is the proposal arrays the array unique empty vector is undefined that of the on empty the nonempty are the not a uniform arrays of section and are called arrays in and are called in are all arrays uniform for any array b in are choice of a the development of section above suggests that we should the existence of three empty arrays of each shape while this choice is intuitively if the universe consists solely of arrays it does not easily to a universe that includes arrays the for the proposal classify r s and of figure respectively if we wish to maintain compatibility with current apl and have a pro a natural of a one we must add either two new that classify t and respectively or add just one fill characterizing both kinds of at once thus either five or four must be pro for such a proposal neither choice is particularly they both involve adding more artificial empty arrays below to the universe a point we in a floating system the tion of arrays according to figure does not work well is not easily defined or preserved in a floating system and the purpose of classes is to make the distinction between and heterogeneous arrays clear the ing scalar implies that the number of levels in an array is not a good criterion for arrays and hence any attempt to impose a definition of type based on the classes above is bound to be artificial other choices let us explore some of the remaining possibilities for defining fill the fill function ao of present apl is such that all arrays are it may be whether a fill function can be found with respect to which all arrays of a heterogeneous universe would be uniform too in order to achieve this goal one has to a very fundamental principle namely that two arrays are f they the same and the same items at all corresponding positions principle of for non empty array more a fundamental that we will for nonempty from not investigate any further arrays is such present apl such con upon the use of type in other languages we see that it makes sense either to have the fill item solely the content of a nonempty array or which is the more modern approach to both the content and the structure of the array moreover the could be either local or global ie the fill could item of the array or it could all the items we will first concentrate on local fill definitions and present two with regard to the structure information pro in array theory see the prototype concept is used to define a fill which both the structure and con of the first item thus it is a local structured fill we can adapt the prototype concept to apl as follows let t be the function that maps a number to zero and a character to if other basic data types are added then typical items must be designated extend t to all arrays by applying t to the basic data held in an array thus ta is an array with the same structure as a but with the basic data replaced by the corresponding typical items then we define for a non empty array a note t that this implies ta qa this definition of a local is independent of the a ii and but not structured decision implies fill on issue p reduces empty arrays a large collection of at the other end of the we can define a fill to simply characterize the content of arrays we define a local fill cl rec to be o if its first item is a number to be t t if it is a character and to be the fill of its first item otherwise there are many choices for a fill function that lie between the a and the fully structured however c d since one seems a more suitable the amount of structure mation preserved is arbitrarily determined we now turn to global fill functions the function t above the content and of an array globally how ever it cannot be used as a fill function since it is not an extension of extensions of described above are global fill functions the one with five values also provides structure information since it distinguishes basic arrays from others the one with four values does not have this property because arrays in t and in have the same fill a definition for a global fill can be made by adding an artificial array to the universe then a of a nonempty array is defined to be o if all its items are numbers or arrays with fill o to be if all its items are characters or are arrays with fill r and to be n otherwise note that the restriction of fill requires that r must be an array ie one that cannot be constructed from the uni of recursive arrays with numbers and characters as basic data the additional one or two fill arrays required for the extensions of al must also be in this sense the properties of such arrays are not completely determined by the fill function for example the item of b may be considered a basic datum then in a floating system q r whereas in a system d x for any array x another choice in a system is to define e h defines a universe to that of the proposal where al the implicit introducing fill function an array has the property similar of is an h that el behaves like the nil of lisp in this we have only a few of the many possible definitions but we feel that ones are even less the ones we have presented investigated fill the omitted than some of evaluation of the choices on what basis should we choose among the fill functions defined in the previous section one way is to examine important identities that hold for nonempty arrays and see if they extend to the empty arrays associated with each choice a second approach is to evaluate how the choice of each fill function affects or is affected by the decisions made on issues i and ii finally we may compare the fill functions with respect to their ability of expressing type in a natural way identities we define a monadic function scalar if indexing with f to be f ie f ll f for all suitable indices in if f is a scalar monadic for any array a and any the identity function then fill function u holds for any positive this identity hold for that a when k reduces to integer k o o the k should assuming identity and using we have identities and of section fa we can express this in words as the result tion of a function array is the same as the obtained by the ing f to the fill of the of the f to empty result empty empty array of if we accept to an interesting function raise is the result of operator of ie this principle identity for i defined in applying the to the it leads the scalar which function a raise arrays is the scalar with the eg function function that al then implies that since array and the result and hence of a is always o a thus implies that unless lj in a system and raise are the fundamental level increasing functions and and lower are the corresponding level decreasing functions the identity a a holds for all a and holds for all nonempty a should empty the latter arrays if and hence identity so then also hold for must be one which implies and hence thus we might consider aa a for every array a figure gives of o and f for we have defined the values of the fill the four fill functions i i i ib i a ib i a a i a i i i i figure table of fill values the table illustrates fails for for for a a and a that any b but holds the raise and lower functions play a fundamental role in the system being used to perform data structure trans that add or remove a level to the structure of the array but do not alter the contents the functions can be generalized in a number of ways in denoted ia is defined to yield an array whose items are slices of a i is used to denote the of a along which slices are to be taken thus each item of has shape and the shape of is determined by the for example if a is p then la is a vector of items each with shape the function is defined by ia b if and only if that a ib there is a unique b such this implies a for every nonempty array a to empty generalization if we extend the latter identity arrays we have the following of and i a for every array a the importance of depends on how one views the use of data structures in extended apl if transformations of the form accomplished by are used as a programming device to ease the expression of algorithms applied to slices of an array then it may be important that such transformations are shows that the present axis operator can be defined in terms of such transformations and this may suggest that is more fundamental than one would at first of the fill functions we have defined only g pre serves enough information to permit slice raise to be defined to be the development of the identities in and has been done in the system however similar level manipulating functions exist in a system and the same considerations apply the second criterion for evaluation of the choices for a fill function is the relationship of each choice for issues i and ii let us begin with i if the arrays of apl form a heterogeneous uni lj then we can ask whether there exists a subset h that has a natural embedding in u is primarily of a system since it is difficult to preserve in a floating system in particular we would expect for a vector vh e ie preserves the extensions to al can be defined to have this property but a has it too neither a nor a have this property since wit a abc which is in set x of figure and with ub t this implies that if the arrays of apl are chosen to be in the sense of being a uniform then only a may be as an alternative for the fill function since would be undefined for a and a the evaluation relative to decision of decision i of the fill functions ii is not as the above discuss ion indicates we can note nevertheless that a a and either a are suitable a or for system is not an issue if global attributes a third way to measure the of a fill function is to determine how well it expresses type in the sense of a global attribute describing both structure and content of an array al and its five valued extension either give content information for arrays in or give structure information for the other arrays but not both information and a lose any structure however the remaining fill function a although defined locally can be used to yield global content and structure information we noted in section that ta ua more see that function calls t the function and we the choice of u as the fill allows us to construct conclusions we have seen the following the distinction and heterogeneous between arrays is interesting only in the context of a system in this context a and the extensions of to introduce artificial arrays hence a seems if the choice for i is heterogeneous however if the choice for i is the decision between an and a depends on the importance one to and simplicity relative to preserving to the properties of d make an interesting choice in this restricted form of an apl extension the resolution of iii using a permits the extension of important identities to empty arrays and is of the choices for issues i ii neither a ab nor the extensions of cy can preserve although a and p and and ah can be are is since arrays used to it if structural be less important introduces no figure summarizes these conclusions issue ii i floating st al nd a heterogeneous figure st nd cb extended rd a th for fill function in conclusion we note that a the fill function that corresponds prototype function in appears the most suitable candidate for defining the empty arrays of extended apl unless the extension is restricted to arrays references oj dijkstra ew and hoare car structured programming academic press london and new york we and ma recursive data structures in apl to appear in comm acm also available as technical report computing and information university hr the extension of apl to data structures apl quote ma and j on types in recursive data struc tures a study from the apl literature proceedings of the third conference on mation technology august also available as technical report computing and information ma and j operators in an apl including nested arrays submitted to apl quote available as technical report computing and information science university more t jr axioms and theorems for a theory of arrays ibm journal of research and development more t jr types and in a theory of arrays technical report g ibm cambridge scientific center may liskov b and s programming with abstract data types sigplan notices april n the programming pascal acts informatica language 