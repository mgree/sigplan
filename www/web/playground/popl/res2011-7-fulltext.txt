static analysis of programs via translation national university usa university national institute of yi national university abstract static analysis of programs is challenging because the basic assumption of conventional static analysis no longer holds the program text itself is no longer a fixed static entity but rather a dynamically constructed value this article presents a translation of callbyvalue programs into programs and a static analysis framework based on this translation the translation is in that every smallstep reduction of a program is simulated by the evaluation of its version thanks to this translation we can analyze programs with existing static analysis techniques that have been developed for conventional programs we first apply the translation then we apply conventional static analysis to the version and finally we cast the analysis results back in terms of the original staged program our translation handles staging constructs that have been to be useful in practice in open code as values unrestricted operations on references and substitutions this article references for which we refer the reader to our companion technical report categories and subject descriptors d programming languages formal definitions and theory d programming languages language constructs and features f logics and meanings of programs semantics of programming languages program analysis general terms languages theory this work was supported by the engineering research center of program of of science and research foundation of grant permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ austin texas usa copyright c acm keywords languages static analysis translation semantics preservation abstract interpretation projection introduction staged programming which explicitly a computation into separate stages is a unifying principle for the existing systems partial evaluation runtime code generation function inlining and macro expansion are all instances of staged computation there can be arbitrarily many stages determined by the nesting depth of program stage is for conventional programs and a program of stage generates a program of stage that generates a program of stage and so on a program of stage can be to stage for execution the key aspect of languages is to have code templates program fragments as firstclass values code templates are freely passed stored composed with code of other stages and executed when appropriate for this reason programming is also called programming is in programming schemes system is a fully system that has been to with the demands from programming cs macros and cs templates are features c javascript php and python support a form of programming a limited one and template haskell are extensions to ml and haskell respectively to support programming however static analysis of programs in order to for example find bugs or optimize is mostly aside from static typing systems such as there are as far as we know no studies on more general and more powerful static analysis la abstract interpretation for programs the primary is the fact that the basic assumption of conventional static analysis no longer holds the program text itself is no longer a fixed static entity but rather a dynamically constructed value conventional static analysis can finitely estimate the set of constructed code fragments but we reach a after that if the program executes the generated code how can we statically analyze the execution the program text to analyze at this stage is not a usual text but a finitely abstracted representation of the possibly infinite set of generated code contribution · as a solution to the problem we present a translation of callbyvalue programs into programs and a static analysis framework based on this translation we prove the translation is in that every smallstep reduction of a program is simulated by the evaluation of its version thanks to this translation we can analyze programs with existing static analysis techniques that have been developed for conventional programs we first apply the translation then we apply conventional static analysis to the version and finally we cast the analysis results back in terms of the original staged program · we present a framework of safely the static analysis results of translated version back in terms of the original staged program once the projections safety condition is satisfied we can use conventional static analysis for the language to achieve a static analysis for the language · our translation handles staging constructs that have been to be useful in practice in open code as values unrestricted operations on references and substitutions this article references for which we refer the reader to our companion technical report we illustrate the problem and our solution using an example program in the example we use syntax for staging constructs expression e denotes program e as data a program of the next stage inside which if any expression e replaces itself by the code result from evaluating e problem for example consider the following program x repeat x x until cond run x variable x initially has code the repeat statement repeatedly assigns a new code value to x the expression x becomes a code value by xs current contents into the place of x thus after one iteration x contains after two iterations and so on finally run x evaluates the xs code and returns a nonnegative even integer now consider statically the above program in order to estimate the value of the run x expression we must estimate the set of possible code values that may be assigned to x suppose that the number of iterations of the repeat statement is statically undecidable then flowinsensitive static analysis for example must finitely estimate the set of all possible infinitely many code values · · · to finitely approximate the infinite set of code suppose we use abstraction then the set of code for x would be approximated by a grammar s s however in order to analyze the code run by the run x expression at least by conventional analyses for programs every code implied by the grammar must be exposed first that is the grammar must be since the concrete image has infinitely many code values such analysis is a different static analysis technique that can such concretization trap is necessary solution as a solution to the problem we present a approach translate analyze and project to make this approach correct we prove the translation the translated version simulates every evaluation step of the original staged program and we show a sound condition for the projection to be correct ie to be aligned with the correspondence induced by the translation here we will demonstrate these steps with the motivating example just presented exact definitions lemmas and theorems are presented in sections and · translation the above example program is translated as x repeat x hh x until cond x the translation works as follows code is translated into a function that explicitly takes a record for its environment as an argument hence the run expression is translated into a function application run the function is applied to an empty record because only closed code can be run free variables inside a code are translated to record access expressions for example x code composition x is translated to a the resulting application whose actual parameter is the part for the expression x hh x the code value of x will be into its corresponding hole the place of h the h stands for the resulting code the application h is for capturing the codes if any free variables by the current environment the evaluation of the version simulates that of the original staged program for example after one iteration of the repeat statement x has after two iterations and so on these functions correspond to code values and after the same numbers of iterations in the original staged program · analysis because the translation removes all the staging features we can apply conventional static analysis techniques to translated results for example suppose we estimate the values of expressions by a simple flowinsensitive value analysis with cfa we can apply any elaborate static analysis technique but just for illustration this simple analysis is sufficient we present the analysis results in style we write vi or vx for the values of expression i and variable x respectively let us first label some expressions including x repeat x hh x until cond x the analysis will deduce set constraints as follows for brevity we write i the body expression for values from the first assignment statement vx from the assignment inside the repeat statement vx can also contain the value of the application h x ie hs body expressions value which is hence vx the parameter binding in the application h x gives vh vx hence vh and vh application expression h has values of called functions body expressions the called functions would be vh which has and thus v vh has and s value is v v vh has and s value is v similarly from the application expression x v vx has and s value is v v vx has and s value is v the above constraints can be understood as inductive rules for value sets for example the infinite sets v and v are inductively defined as follows v v v v thus we can conclude that v and v consist of all nonnegative even integers · projection finally the analysis results for the version need to be cast back in terms of the original staged program because code expressions are translated into some in the above example analysis results correspond to the code expressions in the original staged program for example analysis result vh for variable h has and which respectively correspond to code expressions and x that is code to be into the place of x can be and recursively x it is straightforward to keep track of which in the version correspond to which code expression in the staged original we can for instance assign parameter names of such from a unique to identify the corresponding code expression such as i for the lambda translated from code expression ei of index i regarding the projections we cannot use arbitrary ones arbitrary projections of the static analysis results of the translated program can have that fail to as static analysis results of the original staged program projection from abstract semantics of the translated program to that of the subject program must be a safe approximation of its concrete counterpart projection from concrete semantics of the translated program to that of the subject program section presents the formalization of this condition and an analysis example comparisons · translation and translation works only for closed code their translation does not support open code and substitution at stages macros this feature which may be in a purely functional language has long been used in practice for example by programmers for efficiency programming convenience s translation supports open code but they do not provide an observational equivalence hence it is not adequate for our purpose a static analysis approach for programs our translation is a refinement of we prove only two kinds of reductions suffice whose exhaustive application reaches the form we also define an inverse translation that converts expressions in the form back to the original staged expression · static analysis most static analyses for programs are string analyses for programs that generate code as strings but they are limited to estimate only the shape not the semantics of generated code by using a grammar or the parsing stack such string analyses do not analyze the semantics of the generated code string static type systems and their inference algorithms can be considered sound static analyses but extending them for analyzing other behavior than types la effect type systems is also constrained by the trap any extension to estimate other properties than types is limited to those that can proceed without analyzing the semantics of the generated code existing static type systems can the infinite concretization trap because typing the execution of the generated code for expression such as run e does not have to analyze the generated code itself but can just pick up the type from the generated codes type organization section defines the subject callbyvalue language s and the target record language r section defines and proves of the translation from s to r section presents a condition for safe projection section discusses related works section concludes languages in this section we give the formal definitions of the subject staged language s and the target record language r for each we present the syntax operational semantics and the type system language s the language s is a typed callbyvalue calculus with staging annotations it is based on simplified by removing code composition ie mutable reference and the lift operation also the unbox operator is restricted to stage in this work our focus is not on polymorphism thus we omit from the syntax we use them in the examples as a syntactic sugar for application definitions value n v i xe fix f xe box v vn i x fix f box vn unbox vn n run vn operational semantics n app e n e e e n e e e n e v v e n v e xe v x ve fix f xe v x vf fix f box run abs fix e n e box e n box e e n e run e n run e v value fv v run box v v e n e v value unbox e n unbox e unbox box v v e n e xe n xe e n e fix f xe n fix f xe figure operational semantics of s syntax variable x y f var s expr s e i x xe e e fix f xe box e unbox e run e the syntax of s is given above the language contains constants variables lambda abstraction application and the fixpoint operator fix finally there are staging annotations box is used to define code templates unbox is the escape operator that defines a hole inside a code template which is filled in with another code template box and unbox operators can be arbitrarily nested run executes a code template operational semantics s has a smallstep callbyvalue operational semantics evaluation rules of the language are in figure the evaluation e n e has the meaning that the expression e is evaluated to e at stage n values are expressions that cannot be reduced further values are defined for all stages at stage values are constants functions and code templates a code template is a frozen expression within a box annotation inside code templates holes denoted by the unbox are filled in by evaluating the unboxed expression to a code template in other words code templates are composed using the unbox operator only stage holes can be filled in once all the holes are filled a code template becomes a a code template can be evaluated at stage by run code to run must not have any free variable fv e in the run rule denotes the set of free variables in stage expression e to which none of es subexpression of stage s extends lambda calculus conservatively at stage app is the same as the traditional callbyvalue semantics alpha conversion and beta reduction are available at stage cont n s i nx t n s x t n x t s e t n s xe t t n x t f t t s e t n s fix f xe t t n s e t t n s e t n s e e t n s e t n s box e t n s e n t n n s unbox e t n s e t n s run e t figure type system of s type system figure shows a monomorphic type system for s a polymorphic type system is also available types in s are defined as below types t t t t type environments var s fin types we use t to denote type terms for base types t t for function types t for code template types for type environments a code template is given a t with the meaning that the code template will evaluate to a value of type t if put in a context that provides the environment the type environment in the t contains the types of the variables in the code template a type environment is a mapping from variables to types x t is a function update operation that defines a function as follows x tx t and y tx x if x y a typing judgment has the form n s e t with the meaning that a expression e under type environments n has type t n is a sequence of type environments each type environment corresponds to a stage where n is the current ie most recent type environment for a proof of the soundness of this type system and its extension see the record calculus r the language r is a calculus with record operations as the target language of our translation it is sufficient for the record expression to have only variables and values as opposed to s we include in r this is to be able to syntactically distinguish several r expressions during inverse translation section the language is still monomorphic syntax variable var p record variables h var h hole variables x y f var x var s ordinary variables w var r var x var p var h label x label xx var x ordinary variables in operational semantics e r e e e r e e e r e v e r v e we v r w ve fix f xe v r x vf fix f e r e let w e in e r let w e in e let w v in e r w ve vr r record lookup v vr x if vr vr x v if vr vr y and x y figure operational semantics of r expr r e i w we e e fix f xe r let w e in e value r v i we fix f xe vr record vr vr x v record r r rx x rx v the record language r has constants i variables x lambda abstractions applications a fixpoint operator fix and as for the record operations there are empty records record variables and the record update operation rx for field names or labels in records we use variables written in we separate variables into three disjoint sets ordinary variables var x which are the same as variables of s record variables var p and hole variables var h this syntactic distinction makes our presentation of the inverse translation in section easier the operational semantics does not need to make a distinction all variables are treated uniformly operational semantics r has a smallstep callbyvalue operational semantics the evaluation e r e means that the expression e evaluates to expression e the operational semantics of r is mostly standard evaluation rules and the definition of values are given in figure type system a monomorphic type system for r is given in figure types are defined as follows t t t tr record type tr label fin type var r fin there are base type and function types as usual a record type is a mapping from field labels to types type environments are similar to those for s ri w t w t r e t r we t t x t f t t r e t r fix f xe t t r e t t r e t r e e t r e t w t r e t r let w e in e t r r r tr r e t r rx e tr x t r r tr t r t figure type system of r translation in this section we present how staged expressions can be represented with record calculus expressions we begin with an observation boxed expressions are not executed ­ they remain frozen ­ until they are run this notion is very similar to closures closures are not executed until they are applied to an operand this observation that boxed expressions can be represented as functions the second observation is that when an unboxed expression is replaced with a code template see rule in the operational semantics the free variables in the code template may be captured by the surrounding expression in other words the surrounding boxed expression provides the code template with an environment that carries the meaning of the free variables in the code template combining the two observations we can then represent a boxed expression as a function whose parameter is an environment providing an environment to a boxed expression as in the case of is then nothing but a function application where the operator is the boxed expression and the operand is the environment the next question is how to represent environments the answer is trivial as records a variable occurrence then becomes a lookup in the current environment ie record and a binding is an update to the current environment ie record our translation at the type level translates code expression of type t into function expression of type t where is a record type for and t is a translated type for t to give a few examples consider the expression box x it can be represented as where the value of x is being obtained from the environment the expression box let x in unbox box x can be represented as note how the unbox expression becomes a function application as a special case run becomes an application where the argument § § box unbox · unbox · z hh h h · · figure illustration of the translation of a box expression with two is the empty environment because only closed expressions can be executed for example run box becomes to illustrate how variable capturing is handled let us now take the following example let a box x b box ay in run b in the example the value of b will be box note how the variable x which was free in box x is captured the evaluation run b will reduce to the function resulting in a final value of based on the translation described the example above is translated as below let a b x x y yy in b both box expressions are converted to a function that takes as parameter an environment in the first line the occurrence of x is free so it is translated to a lookup operation in the occurrence of y in the second line is not free hence it is left as it is the unbox expression becomes a function application where the operand is the environment updated with the bindings of x and y finally the run expression is translated to an application to the empty record when evaluated the translation reduces to too order of evaluation in the staged calculus unbox expressions inside box are evaluated to code templates when translated to record calculus as discussed above however the contents of a box become guarded under a lambda abstraction and hence are not evaluated consider the following example box unbox xx box box unbox box box the translation of box unbox xx box would be xx which is already a value and does not evaluate further so the order of evaluation in the callbyvalue semantics is by the translation this would a serious problem in the presence of expressions with sideeffects to preserve the order of evaluation the translation has to move the expression inside unbox to the outside of the enclosing box as illustrated in figure to do this every unbox expression is replaced with a hole variable h and a context in the form of e where e is the translation of the unboxed expression is created so that the inside of the context can be filled in with the translation of the enclosing box because e is at the argument position of a function the callbyvalue semantics of the record calculus evaluates e first and then handles the rest the correct translation of the example above is hh xx our translation to preserve the order of evaluation is similar to and they suggested the translation from the implicit modal language miniml which is similar to s to the explicit modal language their target language is still staged whereas ours is the record language with no staging also developed a similar translation that translates staged programs to system f with tuples more details on the related work are given in section reductions let us examine the evaluation of the expression above in small steps hh xx r hh r the final value is not directly the translation of box there is still a reducible term inside a lambda this residual term is seen because of the following fact in the staged calculus when an unbox expression evaluates to a code template the code template immediately ie in one step replaces the unbox expression on the other hand in the record calculus the unbox expression becomes an argument to a function in which the argument is applied to an environment passing the argument to the function takes one step of evaluation ie substitution the application of the argument to the environment still remains and is in fact the residual term that needs to be reduced via further action this kind of a reduction is called an reduction reductions simplify the record calculus terms and bring them to a form that is the direct result of a translation in general of an application where the operator is a lambda expression and the operand is a record is an reduction this reduction may happen anywhere including inside lambda abstractions the example above is as follows where the term is note that the resulting term is directly the translation of box a there are two kinds of reductions the first is the one explained above the second is related to variable capture recall that when a code template replaces an unbox expression the free variables are captured a free variable becomes a lookup expression in the current environment after the translation such need to be resolved after a hole replacement this is done by the second kind of reduction figure shows a trace that belongs to the first example given in this section both kinds of reductions are used terms are again figure shows the evaluation of the original staged expression note that any term in figure translates to a term in figure the formal definitions of the translation and reductions are given in the next section translation definition the translation is presented in figure a translation judgment has the form r e e k with the meaning that a s expression e under environment stack r translates to the r expression e and the context stack k an environment is a subset of a record expression that associates fields to variables it keeps the information of which variables have been bound so far each stage has a corresponding environment held in the environment stack hence the translation of a expression involves a stack of length n the rightmost or environment in the stack corresponds to the current stage an expression that binds a variable updates the environment with the new binding lambda abstraction and fix are such ex let a b x x y in b r let b x x y in b r let b x x y yy in b a let b xy x x y in b a let b in b r r r yy r r figure reduction trace of the example expression after the translation terms are let a box x b box ay in run b let b box box xy in run b let b box in run b run box yy figure reduction trace of the example staged expression any term in this trace translates to a term in figure see rules and a box expression starts a new environment by putting a fresh environment variable on top of the environment stack unbox off the environment from the stack the notion of a context was informally discussed in the previous section a context e corresponds to unbox e where e is the translation of the unboxed expression e contexts are used for putting the unboxed expression outside their enclosing box expressions so that the evaluation order is preserved the variable that a context binds that is h is a fresh variable that replaces the original unbox in the translation note that there may be multiple unbox expressions at a particular stage eg box unbox e unbox e therefore contexts are defined recursively as in h e this way a context is able to keep information about multiple unbox expressions in a stage while still preserving their relative order of evaluation also note that unbox expressions can be nested eg box box unbox unbox e the translation definitions environment r rx x environment stack r r r context context stack e h e k k environment lookup x rx r x if r r x x if r r y and x y if r term translation r i i r r x rx r rx x e e k r r xe xe k r rx xf f e e k r r fix f xe fix f xe k r e e k r e e k r e e e e k k r e e k new r box e e k r e e new r box e e r e e k new h r r unbox e h r k e r e e k new h r run e let h e in h k context stack merge operator kk k k k k k k figure translation from s to r therefore produces context stacks instead of a single context each context in the stack corresponds to a stage the contexts in a stack are in the following order the context of the stage that is immediately lower than the current stage is at the rightmost side stages go lower ie get closer to as we go left the stage to is located at the leftmost side of the stack new contexts in the translation are by unbox expressions see rule a fresh hole variable is also generated as a for the unboxed expression the translation of a box expression the context from the stack and puts the translated expression inside this context the translation of expressions with no subexpressions eg variables results in empty context stacks since there are no unbox contained within the expression the translation of expressions with single subexpressions eg abstraction simply threads the context stack that results from the translation of the subexpression the translation of expressions with more than one subexpression eg application merges the context stacks resulting from the translation of subexpressions a context stack merge operation respects the order of hence serves the preservation of the order of evaluation when discussing the translation informally we converted run to a function application but in the formal definition we translate to a the difference is merely syntactic we want to be able to distinguish translations of run from unbox so that the inverse translation can properly translate expressions back semantics preservation in this section we formally make the connection between semantics of s and r through the translation for complete proofs for lemmas and theorems we refer the reader to the companion technical report recall that a translation yields a pair of an expression and a context stack this pair can be constructed into a single expression using a context closure operation definition context closure let e be a r expression and k be a context stack the context closure ke is defined as follows ke k e e if k k if k in section we discussed the need for reductions here we give the formal definition definition reduction reduction of an expression is a congruence closure of the following two rules app e r a re r acc a rx the definition of reductions also extends to contexts and context stacks note that an reduction may happen anywhere even under also note that an reduction is safe to perform in the sense that no or nonterminating expression is eliminated by an reduction it is also straightforward to check that reductions terminate definition form an expression e is said to be in form iff there does not exist any e such that e a e an important observation is that a translated expression does not contain any terms lemma let e be a s expression such that r e e k for some r then ke is in form proof by structural induction on e notation the kleene closure of reductions is denoted as a notation we use ra to denote sequential application of one step of eager evaluation followed by exhaustive reductions exhaustive reductions are those that bring an expression to the form next we show the relation between the operational semantics of s and r given a s expression e we can first translate e then evaluate it in record language semantics followed by application of reductions and we will have obtained the translation of the expression that e evaluates to in the staged semantics furthermore the reductions that we apply are exhaustive we do not need to about this relation is formally stated in theorem and illustrated in figure two properties are critical to prove the semantic preservation first the translation preserves the substitution operation e n e e ra e ee figure relation between s and r operational semantics type term t t t t t t t t tr t t t tr t record type term tr t t x t tr x t figure type translation lemma substitution preservation assume e is a s expression e is a stage s expression with no free variables let r rn e e p for p n and e e where r is such that rx x for some variable x then · if n then r x ee x ee · if n p then r rn x n ee e p · if n p then r rn x n ee e p p where p x ep proof by structural induction on expression e second the translation preserves the reduction which happens in s because of open code lemma preservation assume e is a s expression and s is a substitution where s r let r rn e e k and sr rn e e k then se a e and sk a k proof by structural induction on e the substitution operations sr rn se and sk are the usual compositional operations finally we give the simulation theorem that shows our translation is an illustration of this theorem is given in figure theorem simulation let e be a s expression with no free variables such that e n e let r e e k and r e e k then ke ra k e proof by induction on the evaluation e n e using lemma lemma and lemma for complete proof see type translation a relation between the two languages exists not only between their operational semantics but also between their type systems the translation preserves the typability of an expression if a s expression is typable in the s type system its translation is typable in the r type system the type translation is a straightforward conversion that converts all the in a s type to arrow types figure theorem type correctness let e be a stage s expression with no free variables such that s e t if r e e then r e t definitions hole environment h var h term translation h xx h x h ee h xe xe e n e e eo e ra e figure given a s expression e we can evaluate its translation in the r semantics and then translate the result back to obtain the result that we get from evaluation of the original expression e h ee h fix f xe fix f xe h e e h e e e he e h e e e e h h e e e h he e e h ee h e box e h hh e h h r unbox e h ee h let h e in h run e figure inverse translation from r to s for a proof of this theorem see inverse translation we have so far seen how a s expression can be translated to a r expression and how the two expressions relate we can also translate a r expression back to s with such an inverse translation we can not only translate a s expression and evaluate the result using record language semantics as we saw in the previous section but also translate the evaluation result back to s without ever having to evaluate the original s expression the definition of the inverse translation is in figure an inverse translation judgment is in the form h e e with the meaning that under the hole environment h the r expression e translates to the s expression e a hole environment is a function that associates hole variables with expressions recall that a forward translation replaces an unbox expression with a hole variable h and moves the unboxed expression outside the enclosing box a hole environment maps the hole variable to the expression that was moved out so that we can convert the hole variable back to an unbox expression this is done in the rule note that in inverse translation we have a single environment as opposed to having a stack of environments and stack of contexts in the forward translation there are two reasons for this there is no notion of stages in r all the hole variables are generated by the forward translation and they are used only once each in unique locations hence it suffices to use a single function to keep the information about hole variables and associated expressions the key points of the inverse translation are the following · record lookup expressions are converted back to variables rule · a lambda abstraction that has a record variable as its parameter is converted to a box expression rule · a function application where the operator is a hole variable is converted to an unbox expression rule · a new mapping is added to the hole environment when translating a function application where the operator is a lambda abstraction whose parameter is a hole variable rule note that the rules of inverse translation are not ambiguous each rule matches a unique syntactic category for instance even though and are both defined for lambda abstractions in the former the bound variable is a regular variable and in the latter it is a record variable these two variables come from disjoint sets and are syntactically similarly hole variables are syntactically this distinction of variables helps us have an unambiguous coverage of expressions to make the connection between forward translation and inverse translation we first define how to interpret context stacks as hole environments definition from contexts to hole environments let k be a context stack the operation k defines a hole environment in the following way k k if k if k k h e h e if e if h e the lemma below states that we can translate a s expression to r and then translate the result back to s to obtain the same expression theorem inversion let e be a s expression and r be an environment stack if r e e k then h e e for any h such that k h proof by induction on the structure of e combining theorem with theorem gives a stronger result not only that the evaluation of translated simulate every reduction step of the original s program but also that every occurring in the simulation steps can be back to its corresponding s expression of the figure the existence of such inversion our development of the projection step which is the topic of the next section projection among our translate analysis and project approach to analyze programs the first two steps have sound foundations since we have proven that the translation is statically analyzing translated programs can replace analyzing the original subject programs the analysis for the translated programs can be proven correct using a conventional static analysis framework such as abstract interpretation the last step the analysis results back in terms of the original staged program needs a condition for its safety arbitrary projections can have that fail to as static analysis results of the original staged program for example staged program run is translated into an application and the binding of the empty record to variable has no counterpart in the original staged programs semantics hence a projection whose image is only such an extra binding effect is clearly not a static analysis result of the original program a point about the safety of projections is that the safety is defined in reference to a static analysis of the original staged program checking whether the projection image to be a static analysis result of the original staged program needs the static analysis definition this requirement is not a static analysis can always be defined though it may not be realizable a sufficient condition for projection safety is easy to see once we model static analysis in the abstract interpretation framework let e be a program and e be its translated version let e ds and e dr be their concrete semantics over concrete domains ds and dr respectively static analyses of e and e are computations of abstract approximate versions of the concrete semantics let e ds and e dr be the abstract semantics each pair of concrete and abstract domains is by an pair of abstraction and and concretization functions and a concrete resp abstract projection resp is a monotonic function from dr to ds resp dr to ds the following diagram summarizes the setting e e do s e e e dr dr e a safety condition for the abstract projection is as follows theorem safe projection let e and e be respectively a staged program and its translated version if e e and then e e proof by the first condition and the abstraction function s monotonicity because of the galois connection e e which by the monotonicity of and and by the correctness of e is e which by the second condition is e these conditions are not particularly concrete projection that satisfies the first condition e e always exists such is the inverse translation function in section composed with an function that first filters out from e if any extra things outside e such composition satisfies the condition because e always includes e since the translated program e simulates every reduction step of e and by theorem the second condition is analogous to the usual correctness condition for an abstract operation in the abstract interpretation framework once the above conditions are satisfied we can concentrate on defining an abstract analysis of r programs without considering staged constructs analyzing the translated program and applying the abstract projection to the analysis result achieves a safe analysis result of the original staged program example consider the following staged program e as in section we use syntax for staging constructs let x indexed as y x indexed as in run y the translated version e is let x y hh x in y first we consider the three concrete components concrete semantics e and e and concrete projection the concrete semantics of the two programs are collecting semantics collections of values of expressions and variables · e collecting semantics e of the staged original has entries such as x has y has x where x has run y has · e collecting semantics e of the translated version has en tries such as x has closure value y has h h h has has empty record has y has · projection that satisfies e e is straightforward it extra bindings for h and projects closure value i to code expression i whose unbox expressions code are those from the environment the closure values of r into code values of s is essentially identical to the inverse translation in section that is projects closure values as follows to h x h to where the x position has now we consider the abstract components e e and note that the static analysis will compute e and project its results by back in terms of the abstract semantic domain of e the abstract semantics e of the original staged program is only a mathematical definition that will be referenced in checking the safety of · e for the abstract semantics e of the original staged program e suppose we abstract a set of code values into a regular term grammar in a regular term grammar each productions rhs is f t t where the function symbol f is a code expression label i and each argument term t is either a code expression label or a nonterminal symbol of a grammar the nth argument term is for the code to be into the nth unbox expression inside the code expression i for example production rule s means the set of code values from code expression whose only hole unbox expression is by the code value from code expression · e suppose our static analysis e for the translated programs is defined in a flowinsensitive cfa manner that is because the analysis will be about the environment parts for closures the best such analysis result for e would be x has y has h h has has has y has · abstract projection cast the above analysis results e back in terms of regular term grammars of e additionally it filters out those for the extra variables h and of the many ways to safely project values those corresponding to code into regular term grammars a safe yet naive projection projects as follows to s h to s s where the nonterminal s represents all code s ss the argument term s in the production rule is for the values of the application expression h that encodes the unbox expression inside code expression x another more precise projection projects h differently h to s where the argument term in the production rule is from the analysis result for the h variable not the nonterminal both the two abstract projections satisfy the safety condition let us check the more precise projection case note that the concretization image by of a body is the set of closure body s for every possible environment for the free variables in body the free variables values are the of their abstract values computed by e thus the image of for h becomes h h h x where x has s which is equivalent to the abstract projection s image related work a translation that makes the order of evaluation explicit was previously given by and pfenning the translation in figure follows the same principles their translation however is not an one recently a program logic for was presented which precisely captures the operational semantics yet cannot be realizable as an automatic static analysis an translation was previously discussed by et al but has several limitations for our purpose their translation is to system f with tuples needs type and environment classifier annotations supports only two stages finally they did not prove the translations semantics preservation property another idea of translation of staged expressions is given by chen and xi they convert boxed expressions to firstorder abstract syntax expressions in a secondorder language with recursion an advantage of this representation is that inverse translation becomes straightforward chen and xi use indices to represent program variables inside code templates this has the problem that a binding at a higher stage may or occur such an example is given by et al § our translation is in principle similar to et al s closure conversion where free variables inside become environment loop operations though their translation is a typedirected one for conventional programs our translation is an improvement of we refined the reductions to only two kinds and showed that these two reductions suffice to reach an form that can be converted back to the corresponding staged expression using an inverse translation the refined proof of semantic preservation and the existence of the inverse translation is new from the perspective of cousot and abstract program transformation framework our translation can be seen as being derivable by an abstract interpretation of the staged language s most static analyses for programs are string analyses for programs that generate code as strings heterogeneous meta programs but they are limited to estimate only the shape not the semantics of generated code by using a grammar or the parsing stack such string analyses can not analyze the semantics of the generated code string static type systems and their inference algorithms are limited forms of staged static analyses any extension to estimate other properties than types la effect type systems is limited to those that can proceed without analyzing the semantics of the generated code existing static type systems do not have to analyze the generated code because expressions type comes with the type of the generated code et al s data flow analysis of programs combines static and dynamic techniques our approach is completely static smith et al presented a static analysis of code templates their language is and code templates are not firstclass variable bindings do not extend beyond the code templates they are defined in our approach does not have this limitation conclusion static analysis of programs is challenging because the basic assumption of conventional static analysis no longer holds the program text itself is no longer a fixed static entity but rather a dynamically constructed value in this article we have presented a translation of programs into ones and a static analysis framework based on this translation our static analysis approach has three steps we first apply the translation we apply conventional static analysis to the version we project the analysis results back in terms of the original staged program as long as the static analysis is correct wrt the semantics and the projection is safe wrt the staged analysis a sound static analysis for the original staged programs is obtained because directly defining a staged static analysis is difficult our technique makes it possible to use the knowledge and experience in static analyses of conventional programs without having to develop staged analyses from our translation handles staging constructs that have been to be useful in practice in open code as values unrestricted operations on references and substitutions we refer the reader to our companion technical report for the mutable reference cases and complete proofs we thank and peter for their very valuable feedback on an earlier version of this paper we thank calcagno and all the members of the group in national university for discussion correction and references improving efficiency and safety of program generation phd thesis university of illinois at martin and program logics for in proceedings of the th international conference on logic for programming artificial intelligence and reasoning to appear calcagno moggi and closed types as a simple approach to safe imperative programming in icalp proceedings of the th international colloquium on automata languages and programming pages ­ london uk springerverlag chen and xi through code representation in acm international conference on functional programming pages ­ acm august lee and a practical string analyzer by the widening approach in proceedings of the symposium on programming languages and systems volume of lecture notes in computer science pages ­ november springerverlag and yi semantics preservation proof of an translation of languages technical report center national university simon and michael i precise analysis of string expressions in proceedings of the static analysis symposium pages ­ springerverlag max and tree automata techniques and applications april p cousot and r cousot abstract interpretation a unified lattice model for static analysis of programs by construction or approximation of fixpoints in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ california acm press new york ny p cousot and r cousot abstract interpretation frameworks journal of logic and computation ­ cousot and cousot systematic design of program transformation frameworks by abstract interpretation in proceedings of the acm sigplansigact symposium on principles of programming languages pages january danvy typedirected partial evaluation in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ acm jan and frank pfenning a modal analysis of staged computation in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ acm and frank pfenning a modal analysis of staged computation journal of the acm ­ and david abstract parsing static analysis of dynamically generated string output using technology in of the international static analysis symposium r extensible very fast dynamic code generation system in proceedings of the sigplan conference on programming language design and implementation pages ­ new york acm and tree automata paul graham on lisp an advanced techniques for common lisp prentice hall heintze set based program analysis phd thesis carnegie mellon university october heintze set based analysis of ml programs in proceedings of the sigplan conference on lisp and functional programming pages ­ d jones k and peter partial evaluation and automatic program generation prenticehall and david k algebraic reconstruction of types and effects in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ and closing the stage from staged code to typed closure in proceedings of the acm symposium on partial evaluation and program pages ­ and michael staging static analyses for program generation in proceedings of the th international conference on generative programming and component engineering pages ­ new york ny usa acm yi and calcagno a polymorphic modal type system for languages in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ m and peter lee optimizing ml with runtime code generation in proceedings of the acm sigplan conference on programming language design and implementation pages ­ acm press june john m and david k polymorphic effect systems in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ h an efficient implementation of functional operating system services phd thesis university static approximation of dynamically generated web pages in proceedings of the international conference on world wide web pages ­ new york ny usa acm greg morrisett and robert harper typed closure conversion in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ acm and frank pfenning staged computation with names and journal of functional programming ­ c r and m c and language and compiler for dynamic code generation acm transactions on programming languages and systems ­ march tim and simon peyton jones template for haskell in proceedings of the haskell workshop october haskell smith greg morrisett and compiling for runtime code generation journal of functional programming ­ l steele common lisp the language nd edition digital press calcagno leroy and ed and michael environment in proceedings of the acm sigplansigact symposium on principles of programming languages acm translation of language technical report national institute of tofte and implementation of the typed callbyvalue calculus using a stack of regions in proceedings of the acm sigplansigact symposium on principles of programming languages pages ­ january and java programming using weak in proceedings of the acm sigplansigact symposium on principles of programming languages 