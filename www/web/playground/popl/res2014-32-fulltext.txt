modular reasoning about heap paths via effectively propositional formulas university university software institute software institute university of massachusetts usa sagiv university abstract first order logic with transitive closure and separation logic enable elegant interactive verification of programs however results and high asymptotic complexity of checking validity complete automatic verification of such programs even when loop invariants and procedure contracts are specified as formulas in these logics this paper the problem of verification of reachability properties of programs using efficient decision procedures that are complete that is a sat solver must generate a counterexample whenever a program does not satisfy its specification by a requiring each procedure modifies a fixed set of heap partitions and creates a bounded amount of heap sharing and b restricting program contracts and loop invariants to use only deterministic paths in the heap we show that heap reachability updates can be described in a simple manner the restrictions force program specifications and verification conditions to lie within a fragment of firstorder logic with transitive closure that is reducible to effectively propositional logic and hence facilitate sound complete and efficient verification we implemented a tool z and report on preliminary experiments that establish the correctness of several programs that manipulate linked data structures categories and subject descriptors d programming languages dynamic storage management keywords linked list smt verification introduction this paper shows how to existing sat solvers for proving that a potentially recursive procedure satisfies its specification and for automatically producing counterexamples when it does not we permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright is held by the publication to acm acm concentrate on proving safety properties of imperative programs manipulating linked data structures which is challenging since we need to reason about unbounded memory and destructive pointer updates the part is to identify a logic which is expressive enough to enable the modular verification of interesting procedures and properties and weak enough to enable sound and complete verification using sat solvers recently it was shown how to employ effectively propositional logic or logic for verifying programs manipulating linked lists it the validity of formulas of the form q using sat solvers where q is a quantifier free relational formula or equivalently the satisfiability of q formulas it has been successfully used in many other contexts in this paper we show that effectively propositional logic does not suffice to naturally express the effect on the global heap when the local heap of a procedure is accessible via shared nodes from outside for example fig shows a pre and before a list by h is the problem is how to express the change in reachability between nodes such as zi and list nodes note that eg nodes are unreachable from z in the this paper shows that in many cases including the above example reachability can be checked precisely using sat solvers our solution is based on the following principles · we follow the standard techniques eg see by requiring that the programmer defines the set of potentially modified elements · the programmer only specifies postconditions on local heaps and ignores the effect of paths from the global heap · we provide a general and exact adaptation rule for postconditions to the global heap this adaptation rule is expressible in a generalized version of called ae ar ae ar allows an extra entry function symbol which maps each node u in the global heap into the first node accessible from u in the local heap in fig z z and z are mapped to and respectively the key facts are that ae ar suffices to precisely define the global reachability relationship after each procedure call and yet any ae ar formula can be simulated by a due to and ramsey reverse x h h z z z z z z figure a list pointed to by a head h with many shared nodes accessible from outside the local heap by a rectangle formula thus the automatic methods of still apply to this significantly more general setting · we restrict the verified procedures in order to guarantee that the generated verification condition of every procedure remains in ae ar the main restrictions are type correctness deterministic paths in the heap limited number of changed list segments in the local heap each of which may be unbounded and limited amount of newly created heap sharing by each procedure call these restrictions are enforced by the generated verification condition in ae ar this formula is automatically checked by the sat solver main results the results in this paper can be summarized as follows · we define a new logic ae ar which extends with a limited idempotent function and yet is with · we provide a precise adaptation rule in ae ar which expresses the locality property of the change and in conjunction with the postcondition on the local heap precisely updates the reachability relation of the global heap · we generate a modular verification formula in ae ar for each procedure that the procedure satisfies its pre and postconditions and the above restrictions this verification condition is sound and complete ie it is valid if and only if the procedure to the restrictions and satisfies its requirements we implemented this tool on top of z · we show that many programs can be verified using our methods they satisfy our restrictions and their invariants can be naturally expressed a running example to make the discussion more clear we start with an example program we use the data structure which maintains a forest using a parent pointer at each node see fig the method find requires that the argument x is not null the formula x rx asserts that the auxiliary variable rx is equal to the root of x the procedure changes the pointers of some nodes in the closed interval x rx f to point directly to rx intervals are formally defined later definition intuitively the closed interval a bf denotes the set of nodes pointed to by a af af f and so on up until b the return value of find denoted by is rx the postcondition uses the symbol f that denotes the value of f before the method was invoked since find paths from ancestors of x to single edges to rx this root may be shared via new parent pointers fig a typical run of find we have simplified union by not keeping track of the sizes of sets in order to the smaller set to the larger requires x null x rx mod x rx f ensures rx mod f rx node x node i xf if i null i xf i else i x return i requires x null y null x rx y ry mod x rx f y ry f ensures x f f mod rx ry y f f ry void x node y node t node s if t s tf s figure an annotated implementation of in java f is the field denoting the parent of a tree node find x x x r r yy figure an example scenario of running find return value the method union requires that both its arguments are not null it potentially modifies the ancestors of x and y ie x rx f y ry f fig a typical run of union notice that we support an unbounded number of cutpoints see section working assumptions type correct the procedure references to dynamically created objects in a typesafe way for example we do not support pointer arithmetic deterministic reachability the specification may use arbitrary uninterpreted relations it may also use the reachability formula f meaning that is reachable from via zero or more y s union x y y s x t t x figure an example scenario of running union steps along the functional field f it may not use f in any other way until section we require f to be acyclic and we restrict our attention to only one field precondition there is a requires clause defining the precondition which is written in relational firstorder logic af r and may use the relation f there is a modifies clause defining the which is the set of potentially changed memory locations we include both source and target of every edge that is added or deleted the modified set may have an unbounded number of vertices but we require it to be the union of a bounded number of f intervals that is chains of vertices through f pointers postcondition there is an ensures clause which exactly defines the new reachability relation f restricted to the ensures clause written in af r may use two both f and f to refer to the reachability relations before and after bounded new sharing all the new shared nodes nodes pointed to by more than one node must be pointed to by local variables at the end of the procedures execution this requires that only a bounded number of new shared nodes can be introduced by each procedure call note that many programs exhibit limited sharing as noted in the experimental measurements of mitchell a similar restriction is also used in shape analysis techniques for device driver programs we assume that all code is loop free with loops replaced by recursive calls outline of the rest of this paper section provides a rule for local changes to states containing a global heap the idea is that the programmer only specifies changes in a small local area of the heap section introduces a new logic called ae ar section formalizes the requirements for specifying the meaning of commands and procedures the technique for generating verification conditions is presented in section extensions to the frameworks are discussed in section our preliminary verification experience appears in section section discusses related work and section concludes details of the logical proof are contained in appendix a adaptation of local effect to the global heap our goal is to reason about a procedure that modifies a subset of the heap we wish to automatically update the reachability relation in the entire heap based on the changes to the modified subset we remark that in this paper we are concerned with reachability between any two nodes in the heap as opposed to only those pointed to by program variables when we discuss sharing we mean sharing via pointer fields in the heap as opposed to aliasing from stack variables which does not concern us in this paper nonlocal effects reachability is inherently nonlocal a single edge mutation can affect the reachability of an unbounded number of points that are an c find x c zy x zy x figure a case where changes made by find have a nonlocal effect y f c but f c unbounded distance from the point of change fig contains a typical run of find two kinds of frames are depicted i x rx f specified by the programmer denotes the nodes whose edges can be directly changed by find this is the standard notion of a frame condition ii denotes nodes for which f the path relation has changed we do not and in general we cannot specify in a modular way because it usually depends on variables outside the scope of this function such as y in fig in the example shown there is a path from y to c before the call which does not exist after the call furthermore can be an arbitrarily large set in particular it may not be expressible as the union of a bounded set of intervals for example when adding a subtree as a child of some node in another tree only one edge whereas is the entire subtree added which may contain an unbounded number of branches the postcondition of find is sound every execution of find satisfies it but incomplete it does not provide a way to determine information concerning paths outside mod such as from y to c in fig therefore this rule is often not enough in order to verify the correctness of programs that invoke find in larger contexts notice the difficulty of updating the global heap especially the part in particular using only the local specification of find one would not be able to prove that f c indeed the problem is updating the reachability of elements that are outside mod in more complex situations these elements may be far from the changed interval and their number may be unbounded one possibility to avoid the problem of incompleteness is to specify a postcondition which is specific to the context in which the invocation occurs however such a solution requires reasoning per call site and is thus not modular we wish to develop a rule that will fit in all contexts reasoning about all contexts is naturally done by quantification an adaptation rule a standard way to specifications is to specify the local effect of a procedure and then to use a general adaptation rule or frame rule to derive the global effect in our case we know that locations outside mod are not modified therefore for example after a call to find a new path from node to node is either an old path from to or it consists of an old path to a node mod a new path from to a node mod and an old path from to we express this below first letting q denote an old edge that is not inside mod q f mod mod f q mod q f q eq is a completely general adaptation rule it defines f on the global heap assuming we know f on the local heap and we also have access to the old path relation q the problem with this rule is that it uses a logic that is too expressive and thus hard for automated reasoning is not decidable in fact not even a b c d figure memory states with pointers where global reasoning about reachability is hard in the memory state a there is one edge from into the and in memory state b there are two edges from into the same the two memory states have the same reachability relation and therefore are in terms of reachability the memory states c and d are obtained from the memory states a and b respectively by deleting the edge the reachability in c is not the same as in d which shows it is impossible to update reachability in general wrt edge deletion without using the edge relation mod v mod figure the function maps every node to the first node in mod reachable from notice that for any mod by definition recursively enumerable the first problem is that the q relation is not usually first order expressible and generally requires transitive closure for example fig shows that in general the adaptation rule is not necessarily definable using only the reachability relation when there are multiple outgoing edges per node we avoid this problem by only reasoning about functional fields f the second problem with eq is that it contains quantifier alternation matches an arbitrary node in mod which may be of arbitrary size therefore it is not completely obvious how to avoid existential an adaptation rule in a restricted logic we now present an equivalent adaptation rule in a restricted logic without transitive closure or extra this is possible due to our assumptions from section and it greatly simplifies reasoning about modified paths in the entire heap we require a new function symbol we call the entry point of in mod ie the first node on the unique path from that enters mod and null if no such node exists see figure note that since transitive closure is only applied to functions entry points such as in eq are uniquely determined by the origin of the path a key property of is that on mod itself is the identity and therefore for any v it holds that that is the function is idempotent it is important to note that does not change as a result of local modifications in mod hence we do not need to t t mod figure this diagram how an arbitrary path from mod to mod is constructed from three segments f ti f and ti f here i arrows in the diagram denote paths arrows entering and the box denote paths that were not modified since they are outside of mod here is an and t t are about in the as opposed to the formally is characterized by the following formula null mod ¬ f f mod mod f f using the new adaptation rule is obtained by considering for every source and target the following three cases the source is out of mod the target is in the source is in mod the target is out the source and target are both out of mod the full adaptation rule is obtained by taking the conjunction of the formulas for each case eq eq eq that are described below and the formula defining eq paths using we can easily handle paths that enter mod such paths at some mod and terminate at some mod any such path therefore has to go through as depicted in fig thus the following simple formula can be used mod mod f f observe that for any mod the atomic formula used above f corresponds to the mod q f from eq paths we now shift attention to paths that exit mod exit points that is last points on some path that belong to mod are more subtle since both ends of the path are needed to determine them the end of the path is not enough since it can be shared and the origin of the path is not enough since it can exit the set multiple times because a path may exit mod and enter it again later therefore we cannot define a function in a similar manner to the fact that transitive closure is only applied to functions is useful here every interval has at most one exit we therefore the fact that mod is expressed as a bounded union of intervals which bounds the potential exit points to a bounded set of terms we will denote the exit points of mod by ti for example in the procedure swap shown in fig mod x fx and there is one exit point t fx fx is a constant set by the precondition to have the value of f f f x using the inversion formula eq to be introduced formally in section any path that in mod and terminates outside mod must leave through a last exit point ti see fig notice that the exit points also do not change as a result of modifying edges between nodes in mod let p be a path from to and let ti be the last exit point along p note that the part of the path from ti to requires ef x fx ef fx fx ef fx fx x null fx null fx null mod x fx ensures void x node t xf xf tf tf t x t fx figure a simple function that two adjacent elements following x in a list dotted lines denote the new state after the swap the notation eg ef x fx denotes the single edge from x to fx following the f field t t mod figure a subtle situation occurs when the path from passes through multiple in such a case the relevant for f is t whereas for f and f it would be t void a node b figure an example of a procedure where the is not essentially convex consists only of unchanged edges since they are all outside of mod we can therefore safely use f rather than q to characterize it the part of the path from to ti can be characterized by f because and ti are both in mod therefore the entire path can be expressed as f ti ti f thus we obtain the following formula mod mod f ti f ti ti f tj ti tj ti f note that eq corresponds the f q in eq paths for paths between and both outside mod there are two possible situations · the path goes through mod as in fig in this case we can reuse the case by taking instead of · the path is entirely outside of mod see fig the corresponding formula in this case is mod mod f ti f ti ti f tj ti tj ti f f mod figure paths that go entirely whereas null notice that the second disjunct covers the case where there is a path from to mod null and the case where there is none null in conclusion our adaptation rule is the conjunction of the three formulas in eq eq eq and the formula defining eq we need some more formalism introduced in the next section before we show that meets our needs heap reachability logic in this section we introduce an extension of ae r from called heap reachability logic and denoted by ae ar this extension still has the property of ae r as it is effectively reducible to the fragment of firstorder logic and thus its validity can be checked by a this section the af r alternation free and ae r logics from they are decidable for validity since their negation corresponds to the fragment these logics include the relation f the reflexive transitive closure of f but the explicit use of function symbols including f until section we will use at most one designated function f per formula definition a vocabulary v c f r is a triple of constant symbols function symbol relation symbols a term t is a variable or constant symbol an atomic formula is one of the following i t t ii r t t ta where r is a relation symbol of arity a iii t f t a quantifierfree formula qf r is a boolean combination of atomic formulas a universal formula begins with zero or more universal quantifiers followed by a quantifierfree formula an formula af r is a boolean combination of universal formulas ae r consists of formulas with in particular qf r af r ae r the preconditions and the postconditions in fig are all af r formulas decidability and inversion every ae r formula can be translated to a firstorder formula via the following steps i add a new uninterpreted relation rf which is intended to represent f the reflexive transitive closure of reachability via f ii add the consistency rule shown in table which requires that rf is a total order ie reflexive transitive acyclic and linear and iii replace all occurrences of t f t by rf t t proposition simulation of ae r proposition appendix a consider ae r formula over vocabulary v c f r let def rf t tt f t then is a firstorder formula over vocabulary v c r rf and is valid if and only if the original formula is valid rf rf rf rf rf rf rf rf rf rf transitivity linearity table a universal formula requiring that all points reachable from a given point are linearly ordered when the graph of f is acyclic the relation ef characterizing the function f can be from its reflexive transitive closure f at the cost of an extra universal quantifier ef def f f f here f def f heap reachability logic the new logic ae ar is obtained by ae r with unary function symbols denoted by g h hn where · g must be interpreted as an idempotent function · the h hn are all bounded by some parameter n that is each hi takes at most n distinct values · function symbols may not be nested ie all terms involving function symbols have the form f z where z is a variable we later show that ae ar suffices for expressing the verification conditions of the programs discussed above in the typical use case the function g assigns the entry point in the for every node called above and the functions h hn are used for expressing the entry points in inner the main feature of this logic is given in the following theorem theorem any ae can be translated to an firstorder formula the proof of theorem given in appendix a begins by translating to a formula as described in proposition without modifying the function symbols g h hn the function symbols are then replaced by new relation and constant symbols we add new universal formulas to express the above semantic restrictions on the functions modular specifications of procedure behaviours notations definition let v c f r be a vocabulary including the constant symbol null a state m is a logical structure with domain m including null and null f m null where sm is the interpretation of the symbol s in the structure m a state is appropriate for an annotated procedure proc if its vocabulary includes every symbol occurring in its annotations and constants corresponding to all of the program variables occurring in proc the diagrams in this paper denote states for example fig shows a transition between two states below we define the notion of structures which are useful to describe relations between pre and definition structure for states m and m over the same vocabulary v c f r and with the same domain m m we denote by m m the structure over the v c c null f f r r obtained by combining m m in the following way f is interpreted as f m and f is interpreted as f m and similarly for all the other symbols definition differences for states m and m over the same vocabulary v c f r and with the same domain m m the set m m consists of the differences between m and m wrt f null ie all elements u of m such that f m u f m u as well as their nonnull in f m and fm for example in fig let m be the left structure and m the right structure then m m x r where is the node with an edge from x in the left diagram modification set we must specify the mod containing all the of edges that are modified therefore when adding or deleting an edge s t both ends the source s and the target t are included in mod often in programming language semantics only the source is considered modified however of the heap as a graph it is useful to consider both ends of a modified edge as modified for example in the running example program find fig since new references to rx may be introduced as a result of path compression the root rx is also considered as part of mod our are built from two kinds of intervals definition intervals the closed interval a bf is a bf def a f f b and the interval a is a def a f f null notice that f null is always true in acyclic heaps definition the mod of a procedure is a union i i ik where each ii may be si ti f or si si ti are parameters of the procedure or constant symbols occurring in the precondition in our examples the of find and union are written above each procedure by the symbol mod fig note that it follows from definition that mod is expressible as a quantifierfree formula definition given an appropriate state m for proc with mod is the set of all elements in m that are in one of the intervals defining mod see definition pre and postconditions the programmer specifies af r pre and postconditions formulas may be used in the postconditions where f denotes the value of f before the call specifying atomic commands table provides specification of atomic commands they describe the memory changed by atomic statements and the changes on the local heap accessing a pointer field the statement ret yf reads the content of the f field of y into ret it requires that y is not null and that an auxiliary variable s points to the f field of y which may be null it does not modify the heap at all it sets ret to s command yf yf null assume yf x pre y null ef y s y null ef y s y null ef y null ¬x f y mod y sf y yf x x f post s f s f y y f x ¬x f y table the specifications of atomic commands s is a local constant denoting the f field of y ef is the inversion formula defined in eq it is interesting to note that the postcondition is free and much simpler than the one provided in the reason is that we do not need to specify the effect on the whole heap edge the statement yf null sets the content of the f field of y to null it requires that y is not null and that an auxiliary variable s points to the f field of y which may be null it modifies the node by y and potentially the node by s notice that the includes the elements pointed to by y and s the two of the edge it removes paths between y and s the postcondition asserts that there are no paths from y to s also since s is potentially modified it asserts that there are no paths from s to y edge additions the statement yf x is specified assuming without loss of generality that the statement yf null was applied before it thus it only handles edge additions it therefore requires that y is not null and its f field is null it modifies the node by y and potentially the node by x it creates a new path from y to x and asserts the absence of new paths from x back to y again the absence of back paths denoted by ¬x f y is needed for completeness the reason is that both the node by x and y are potentially modified since x is potentially modified without this assertion a in which xf y will be allowed by the postcondition soundness and completeness we now formalize the notion of soundness and completeness of modular specifications and assert that the specifications of atomic commands are sound and complete definition soundness and completeness of procedure specification consider a procedure proc with precondition p mod postcondition q we say that p mod q is sound with respect to proc if for every appropriate m such that m p and appropriate m which is a potential outcome of the body of proc when executed on m i m m ii m m q such a triple p mod q is complete with respect to proc if for every appropriate states m m such that i m p ii m m q and iii m m then there exists an execution of the body of proc on m whose outcome is m the following proposition establishes the correctness of atomic statements proposition soundness and completeness of atomic commands the specifications of atomic commands given in table are sound and complete the following lemma establishes the correctness of find and union which is interesting since they update an unbounded amount of memory lemma soundness and completeness of the specification of find and union in fig is sound and complete we can now state the following proposition proposition soundness and completeness of adapt let mod be a of some procedure proc let m and m be two def q y q def sq def b then s else sq def b ¬b table standard rules for computing weakest preconditions for loop free code without pointer accesses b is the af r formula for program conditions and q is the postcondition expressed as an af r formula appropriate states for proc then m m iff m m augmented with some interpretation for the function symbol is a model of generating verification condition for procedure with in ae ar we follow the standard procedures eg which generates a verification condition for a procedure annotated with specification using weakest preconditions roughly speaking for a hoare triple p we generate the usual verification condition p for the basic commands assignment composition and conditional we employ the standard definitions given in table modular verification conditions the modular verification condition would also contain a conjunct for checking that mod affected by the invoked procedure is a subset of the outer mod this way the specified restriction can be checked in ae ar and the smt solver can therefore be used to enforce it automatically of call statements as discussed in section the specification as it appears in the ensures clause of a procedures contract is a local one and in order to make reasoning complete we need to adapt it in order to handle arbitrary contexts this is done by occurring in the ensures clause from the specification of proc with the universal adaptation rule where mod is replaced with the as specified in the modifies clause of proc table presents a formula for the of a statement containing the single procedure call where the invoked procedure has the specifications as in fig where proc has the formal parameters x x xk and it is used with a a ak used in the formula as the actual arguments for a specific procedure call we assume that each ai is a local variable of the calling procedure in general it is not obvious how to enforce that the set of locations modified by inner calls is a subset of the set of locations declared by the outer procedure moreover this can be to check since it depends on aliasing and paths between nodes pointed requires mod ensures figure specification of proc with def f f f f adapt f ax f f f f qf f r table computing the weakest precondition for a statement containing a procedure call r is a local variable that is assigned the return value a are the actual arguments passed f is a fresh function symbol to by different variables fortunately the captures this property ensuring that the outer procedure does not its own mod specification taking advantage of the structure of the mod since all the modifications even atomic ones are done by means of procedure calls this ensures that no edges to nodes outside mod are changed proposition the rule for wp of call statements is sound and complete that is when proc is a procedure with specification as in fig called in the context of prog whose is mod m m ax m m m m m m r q reducing function symbols notice that when we apply the adaptation rule for ae ar as discussed above it introduces a new function symbol depend ing on the concrete of the called procedure this introduces a the of separate procedure calls may differ from the one of the top procedure hence multiple applications of table naturally require a separate function symbol for ev such invocation consider for example the situation of union making two invocations to find in fig one can see that the mod of union is x rx f y ry f while the mod of the first call t is x rx f which may be a proper subset of the former the mod of the second invocation is y ry f which may overlap with x rx f to meet the requirement of ae ar concerning the function symbols we observe that a the amount of sharing any particular function call creates as well as the entire call is bounded and we can a bound for it b the modification set of any must be a subset of the top call as otherwise it violates the obligation not to change any edge outside mod these two properties allow us to express the functions of the using of the top procedure and extra intermediate functions with bounded image thus we replace all of the function symbols introduced by for different s s with a single global idempotent function symbol together with a set of bounded function symbols x rx f y ry f x rx f rx y x t find x x rx f y ry f x rx f t rx y x figure an example invocation of find inside union mod a a b figure the inner is constructed from the outer one by composing with an auxiliary function consider a statement r in a procedure prog let a denote the of prog and b the of proc we show how can be expressed using and one more function where the latter has a bounded range we define a b b a new function that is the restriction of to the domain a b is defined as follows def b otherwise using equality the nesting of function symbols can be reduced without the quantifier alternation fig notice that is always either · the beginning si of one of the intervals si ti f of b such as in the figure · a node that is shared by pointers from two nodes in a such as · the value null a bound on the number of si s is given in the modular specification of proc a bound on the number of shared nodes is given in the next subsection this bound is effective for all the procedure calls in prog hence can be used in the restricted logic ae ar bounding the amount of sharing we show that under the restrictions of the specification given in section and section the number of shared nodes inside mod that is nodes in mod that are pointed to by more than one f pointer of other nodes in mod has a fixed bound throughout the procedures execution consider a typical program prog containing calls of the form vi ai assume that the of prog is a union of k intervals we show how to compute a bound on the number of shared nodes inside the since there are k start points at most k elements can be shared when prog starts executing each invoked from prog may introduce by our restriction at most as many shared nodes as there are local variables in the therefore by computing the sum over all invocation statements in prog plus k we get a fixed bound on the number of shared nodes inside the k k the set of local variables in the procedure notice that if the same procedure is invoked twice it has to be included twice in the sum as well verification condition for the entire procedure since every procedure on its own is the verification condition is straightforward shared where shared is a shorthand for the ae r formula mod ef ef v see eq for the definition of ef it expresses the obligation mentioned in section that all the shared nodes in mod should be pointed to by local variables effectively limiting newly introduced sharing to a bounded number of memory locations now is expressed in ae ar and it is valid the program meets its specification its validity can be checked using logic according to section extensions explicit memory management this section how to handle explicit allocation and of memory and it on simple procedures shown in fig and fig the procedures push and extend a list at the beginning by an unbounded of fresh elements allocated using new the procedure takes as argument a list that has no pointers into it and explicitly all elements we verify that the procedures do not introduce dangling pointers table updates the specification of atomic commands provided in table to handle explicit memory management operations for simplicity we follow c semantics but do not handle arrays and pointer arithmetic the allocation statement assigns a location denoted by s to and sets its value to be all accesses to memory locations by y in statements yf yf x and x y are required to access memory finally sets the free predicate to true for the node by y as a result all the nodes reachable from y cannot be accessed the adaptation rule needs to be augmented in order to accommodate the change since nodes that are about to be allocated do not have names the mod shall refer only to allocated nodes free nodes can always be changed and they need not be specified in the mod of course the procedures postcondition should describe the new structure of the allocated area in terms of reachability if modular reasoning is desired the change would be as follows whenever there is a reference to some mod in eq eq and eq we would now consider only mod free this way the adaptation rule makes no claims regarding the free nodes everything else remains just the same requires mod h hf free free ensures f h f node h node e new node ef h return e requires mod h hf free free ensures free h f f h node h if h h return h figure the procedure push allocates a new element and inserts it to the beginning of the list the procedure calls the same list an arbitrary number of times requires h f f h f dominance ¬ f h mod h ensures mod ¬ f free free h f node h if h null j hf hf null figure the procedure explicitly the elements of a list dominated by its head where no other pointers to this list exist cyclic for data structures with a single pointer the restriction may be lifted by using an alternative formulation that keeps and maintains more auxiliary information this can be easily done in af r see doublylinked lists to verify a program that a doublylinked list we need to support two fields b and f af r supports this as long as the only atomic formulas used in assertions are f and b and not for example bf in particular we can specify the doublylinked list property h f h f f b command new access y pre y null mod post s table the specifications of atomic commands for resource allocations in a c like language unfortunately modularity presents another challenge how the should be specified and how to formulate the adaptation rule since there are two pointer fields forward and backward the adaptation rule eq has to be instantiated twice however that would require mod to be defined as a union of intervals also according to b in addition to its being defined as such using f otherwise our logical arguments from section no longer hold when the input is a valid doublylinked list this can always be done since f b in cases such where the input is somewhat or for example the logic will have to be modified to incorporate the exit points of potentially pointing to arbitrary nodes this extension is out of the current scope experimental results implementation details a vc generator described in section is implemented in python and python is employed at the frontend to parse modular recursive procedure specifications as defined in section the tool checks that the pre and the postconditions are specified in af r and that the is defined v standard notation is used to format the vc and to invoke z the validity of the vc can be checked by providing its negation to z if z a satisfying assignment then that serves as counterexample for the correctness of the assertions if no satisfying assignment exists then the generated vc is valid and therefore the program satisfies the assertions the output if one is generated is then also parsed and f is evaluated on all pairs of nodes this structure represents the state of the program either at the input or at the beginning of a loop iteration running the program from this point will violate one or more invariants to provide feedback to the user f is by computing eq and then the tool is used to and present to the user a directed graph whose vertices are nodes in the heap and whose edges are the f pointer fields verification examples we have written modular specifications for the example procedures shown in table we are by the fact that it was not difficult to express assertions in af r for these procedures the annotated examples and the vc generation tool are available with the we only examples with interesting cutpoints to show the benefits of our approach in contrast to to give some account of the programs sizes we observe the program summary specification given as pre and postcondition count the number of atomic formulas in each of them and note the depth of quantifier nesting all our samples had only universal quantifiers in the specification we did the same for the generated vc naturally the the vc is much larger than the specification even for small programs still the time required by z to prove that the vc is valid is short thanks to the fact that tools and in particular sat solvers permit multiple relation symbols we were able to express find union implementation of a dy data structure filter takes a linked list and all ele ments not satisfying some predicate c quicksort sorts a using the quicksort algorithm creates a new sorted from a given list by repeatedly running insert on the elements of the input list table description of some pointer manipulating programs verified by our tool benchmark filter quicksort find union formula size pq mod vc solving time z s s s s s table implementation benchmarks pq programs specification given as pre and postcondition mod vc verification condition number of atomic quantifier nesting the tests were on a intel core i machine with gb of ram running os x the version of z used was for bit intel architecture using gcc llvm the solving time reported is clock time of the execution of z ordering properties in sorted lists and thus in the sorting routines implementing quicksort and checked properties for table apart from find and union we also checked full functional correctness of the other examples filter quicksort insertion sort for filter we checked that elements remain in the same order and that only the elements satisfying the predicate were removed for the sorting routines we checked that the resulting list contains the same elements and is indeed sorted via an order relation examples we also applied the tool to erroneous programs and programs with incorrect assertions the results including runtime statistics and formula sizes are reported in table the table lists four kinds of bugs that were provided as input to the tool formula sizes are measured in the same way as in table in addition for every detected bug our tool generates a concrete counterexample a state of the heap some assertion we measured the size of the model generated by observing the size of the generated domain which reflects the number of nodes in the heap as expected z was able to produce concrete counterexample of reasonable size producing output which is readable for the programmer and useful for debugging in fact our tool converts z models into directed graph diagrams which benchmark nature of find incorrect handling of corner case union incorrect specification filter sharing call precondition formula size pq vc solving time z s ce size l s s s table information about benchmarks that demonstrate detection of several kinds of bugs in pointer programs in addition to the previous measurements the last column lists the size of the generated counterexample in terms of the number of vertices or tree nodes debugging our assertions since the counterexamples are slight variations of the correct programs size and running time statistics are similar related work modular verification the area of modular procedure specification is studied many of these works require that the user declare potential changes similar to the eg see the frame rule of separation logic naturally supports modular reasoning where the separating conjunction combines the local postcondition with the assertion at the call site unlike separation reachability is a higher abstraction which relies on type correctness and naturally abstracts operations such as garbage collection nevertheless in section we show that it can also deal with explicit memory we believe that our work in this paper the usage of an effectively propositional logic which is a weak logic to perform modular reasoning in a sound and complete way our adaptation rule is more complex than the frame rule as it automatically updates reachability the idea of using the idempotent entry point function to enable local reasoning about programs including an reduction has been explored independently by et al where it was used to the frame rule in separation logic in this paper we identify a general fragment of assertions for which this idea of the idempotent entry point function is sound and complete cutpoints et al introduce objects which are objects that can reach the area of the heap accessible by the procedure without passing through objects directly by parameters cutpoints program reasoning they are used in model checking and static analysis examples such as the ones in which include unbounded cutpoints from the stack are handled by our method without any changes these extra cutpoints cannot change the and thus have no effect interestingly we can also handle certain programs which manipulate unbounded cutpoints instead we do limit the amount of new sharing in paths which are necessary for the verification for example the find procedure shown in fig includes unbounded sharing which can be created by the client program a typical client such as a spanning tree construction algorithm will indeed create unbounded sharing in the future we plan to verify such clients by abstracting away the pointers inside the tree decision procedures many decision procedures for reasoning about linked lists have been proposed all these logics are based on monadic secondorder logic on trees which has a time and space asymptotic complexity we follow in using a weak logic which permits sound and complete reasoning using off the sat solvers which are efficient in practice and can be implemented in polynomial space indeed our preliminary experimental results reported section show that z is fast enough and may be even useful for automatically generating abstract interpreters as suggested by interestingly the adaptation rule simplifies the rules given in notice the specifications in table do not use quantifiers at all whereas in the formulas contain quantifiers with indeed the appropriate quantifiers are added in a generic manner by the adaptation rule and incremental reachability update formulas for updating transitive closure wrt graph have been developed by various authors eg these works assume that a single edge is added and deleted this generalizes these results to procedures which perform unbounded indeed our adaptation rule generalizes which provides reachability update formula wrt the removal of a single edge conclusion a crucial method for simplifying the reasoning about linked data structures is partitioning them into basic blocks where each basic block has only one entry point and one exit point this paper slightly generalizes by reasoning about blocks with a potentially unbounded number of entry points as demonstrated by find and union notice that this supports modularity even in the case where in every particular call context there is a bounded number of paths eg when there is a bounded number of roots in the heap the bound is not known in advance therefore the programmer has to for an unbounded number of cases it is important to note that the adaptation rule adds expressive power to verifying programs it is in general impossible for the programmer to define in af r a modular specification for all the procedures generation of a verification condition requires coordination between the separate call sites as mentioned above in particular taking note of potential sharing this coordination requires instantiation which thanks to having the adaptation rule in the framework is done automatically finally we remark that there is a tradeoff between mod and the postcondition defining a simpler but larger mod may cause the postcondition to become more complicated sometimes not even af also notice that if mod v the entire heap modular reasoning becomes trivial since it can be done by relational composition but this puts the burden of writing the most complete postconditions on the programmer which sometimes is not even possible in a limited logic therefore we believe that this paper takes a step towards modular reasoning about reachability in programs that manipulate linked lists lifting such reasoning to more complex data structures such as trees and graphs remains future work thanks to the anonymous for their comments and sagiv were by the european research under the european unions framework program fp grant agreement no and by a grant from the science foundation and were partially supported by by projects eu project grant and y grant was partially supported by nsf grant references m f a and s qadeer analysis for concurrent programs with dynamic creation of threads logical methods in computer science m m k r m leino p w and h specification and verification the spec experience acm ­ c a and c satisfiability modulo theories library a c c and m accurate invariant checking for programs manipulating lists and arrays with infinite data in pages ­ g and j su incremental and evaluation of transitive closure by firstorder queries inf comput ­ a j berdine and b cook interprocedural shape analysis with separated heap abstractions in sas pages ­ w dynamic computational complexity phd thesis in computer science june n complexity in computer science springer s s and p w ohearn bi as an assertion language for mutable data structures in popl pages ­ s a n o a and m sagiv modular reasoning about heap paths via effectively propositional formulas technical report university http s a n a and m sagiv reasoning about reachability in linked data structures in cav pages ­ s a n a and m sagiv reasoning about reachability in linked data structures technical report university s k and s qadeer back to the future precise program verification using smt solvers in popl pages ­ g t a l and c ruby preliminary design of a behavioral interface specification language for java acm software engineering notes ­ p g and x decidable logics combining heap structures and data in popl pages ­ acm n mitchell e and g making sense of large heaps in ecoop pages ­ a and m i the pointer assertion logic engine in pldi pages ­ acm r l m de and n deciding effectively propositional logic using and substitution sets j reasoning ­ r t and d separation logic using smt in cav pages ­ t w reps s sagiv and g symbolic implementation of the best transformer in pages ­ n j t w reps s sagiv and r a semantics for procedure local heaps and its abstractions in popl pages ­ n m sagiv and e interprocedural shape analysis for programs in sas pages ­ x and by e calling context abstraction with shapes in popl pages ­ r e tarjan efficiency of a good but not linear set union algorithm journal of the acm ­ j the project url g the formal semantics of programming languages an introduction foundations of computing series us isbn h yang o lee j berdine c calcagno b cook d and p w ohearn scalable shape analysis for systems code in cav pages ­ g a m m sagiv a meyer and a a logic of reachable patterns in linked datastructures j log program k v and m c rinard full functional verification of linked data structures in pldi pages ­ 