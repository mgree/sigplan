multiple for dynamic information flow thomas h austin flanagan university of california abstract javascript has become a central technology of the web but it is also the source of many security problems including attacks and malicious code central to these problems is the fact that code from untrusted sources runs with full we implement information flow in to help prevent violations of data confidentiality and integrity most previous information flow techniques have primarily on either static type systems which are a fit for javascript or on dynamic analyses that sometimes get stuck due to problematic implicit flows even in situations where the target web application correctly satisfies the desired security policy we introduce faceted values a new mechanism for providing information flow security in a dynamic manner that these limitations taking from secure we use faceted values to simultaneously and efficiently simulate multiple executions for different security levels thus providing noninterference with minimal overhead and without the on the stuck executions of prior dynamic approaches categories and subject descriptors d programming languages language constructs and features d operating systems security and flow general terms languages security keywords information flow control dynamic analysis javascript web security introduction javascript has to in a new age of interactive web applications often times developers build these sites by including javascript code from a number of different sources with minimal effort a web can build an site by composing code from multiple sources unfortunately there are few restrictions on the included code and it operates with the same authority as the web developers own code has been a particular source of malicious javascript there are a wide array of security measures used to against these problems but the of them tend to rely on web developers given the nature of security challenges even a web has difficulty keeping up with the and best permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright c acm another option is to security into the browser itself this strategy has been part of browser design since nearly the beginning but the have to be fairly minimal information flow analysis offers the of a systematic solution to many of these security challenges but to date it has not achieved its potential largely because much research on static information flow type systems is an fit for dynamically typed javascript code additionally there has been a that dynamic information flow analysis is not sound in the presence of implicit flows this is not true however and proposed mechanisms for dealing with implicit flows include the semantics and the semantics both semantics guarantee the key correctness property of noninterference which states that private inputs do not influence public outputs private information can influence termination but this channel is limited to a force attack despite this correctness guarantee neither semantics provides an ideal foundation for javascript security since both from the same in the presence of subtle implicit flows that are hard to track the semantics halts execution in order to avoid any potential information leak note that this is not caused by the web application a security policy instead it is a mechanism failure caused by the of the dynamic information flow analysis to track implicit flows thus these dynamic analyses reject valid programs that to the security policy an interesting solution to these mechanism failures is to simultaneously execute two copies of the target program a h process that has access to secret data and a l process that dummy default values instead of the actual secret data this execution guarantees noninterference since no information flow is permitted between the two processes and it also avoids mechanism failures unfortunately for a web page with n principals roughly url domains we may require up to n processes one for each element in the powerset lattice for these principals in this paper we combine the benefits of execution with the efficiency of execution the key technical is the introduction of a faceted value which is a pair of two raw values that contain low and high confidentiality information respectively by appropriately manipulating these faceted values a single process can simulate the two processes l and h of the approach the primary benefit of this approach is that for most data the two raw values in a faceted value are identical in which case we the two simulated executions on identical data into a single execution reducing the overhead in the presence of multiple principals and a complex security lattice a faceted value can contain many raw values rather than just two in this situation the semantics of tracking information flow is a little more complex some runtime performance overhead however our experimental results suggest that faceted evaluation execution as the number of principals increases this paper includes a formal description of the faceted value approach to dynamic information flow analysis and a proof that it achieves noninterference we also present a projection theorem showing that a computation over faceted values simulates n computations one for each element in the powerset security lattice we have implemented this mechanism inside the browser using the in order to validate its utility in a web context additionally we have used this implementation to compare the performance of faceted values against execution finally we discuss declassification and how it relates to faceted values noting this feature as an additional point of distinction with execution overview of faceted evaluation to the need for faceted values in dynamic information flow we start by considering the classic problem of implicit flows such as those caused by a conditional assignment if x y true the central insight of this paper is that the correct value for y after this assignment depends on the authority of the for example suppose initially that x true and y false and that x is secret whereas y is public then after this assignment · a private that can read x should see y true · a public that cannot read x should see y false since it should not see any influence from this conditional assignment faceted values represent exactly this dual nature of y which should simultaneously appear as true and false to different in more detail a faceted value is a triple consisting of a principal k and two values vh and vl which we write as k vh vl intuitively this faceted value appears as vh to private that can view ks private data and as vl to other public we refer to vh and vl as private and public respectively this faceted value representation naturally generalizes the traditional public and private security labels used by prior analyses a public value v is represented in our setting simply as v itself since v appears the same to both public and private and so no are needed a private value v is represented as the faceted value kv where only private can see v and where public or instead see roughly meaning undefined although the notions of public and private data have been well explored by earlier dynamic information flow analyses these two security labels are to avoid stuck executions in the presence of implicit flows as illustrated by the conditional assignment considered above correct handling of implicit flows requires the introduction of more general notion of faceted values k vh vl in which the public vl is a real value and not simply in particular the value for y is represented as the faceted value k true false that captures ys to both public and private based on this faceted value representation this paper a dynamic analysis that tracks information flow in a sound manner at runtime our analysis is formulated as an evaluation semantics for the target program where the semantics uses faceted values to track security and dependency information this evaluation semantics is designed to avoid information between public and private in particular if is any program context then the computation c k vh vl appears to behave exactly like from the perspective of a private and behaves exactly like to a public under a notion of equivalence this projection property means that a single faceted computation simulates multiple computations one for each element in the security lattice this projection property also enables an elegant proof of noninterference shown in section faceted values may be nested nested faceted values naturally arise during computations with multiple principals for example if k and k denote different principals then the expression k true k false evaluates to the nested faceted value k k false since the result false is visible only to to see private data from both k and k any other instead the dummy value as a second example the expression k k evaluates to the result k k k thus faceted values form binary trees with principals at interior nodes and raw values at the leaves the part of this faceted value tree that is actually seen by a particular depends on whose private data the can read in particular we define the view of an as the set of principals whose private data that can read thus an with view k k would see the result of from this addition whereas an with view k would see the result when a faceted value the control flow in general we may need to explore the behavior of the program under both for example the evaluation of the conditional expression if k true false then e else e evaluates both e and e and carefully tracks the dependency of these computations on the principal k in particular assignments performed during e are visible only to views that include k while assignments performed during e are visible to views that k after the evaluations of e and e complete their two results are combined into a single faceted value that is returned to the continuation of this conditional expression that is the execution is split only for the of this conditional expression rather than for the remainder of the entire program handling implicit flows the key challenge in dynamic information flow analysis lies in handling implicit flows to illustrate this difficulty consider the code in the first column of figure which is adapted from an example by here the function fx returns the value of its boolean argument x but it first attempts to this value by encoding it in the program counter we consider the evaluation of f on the two secret arguments k false and k true analogous to the more traditional and to determine if the argument in any way any public component of the functions result for the argument k false shown in column the local variables y and z are initialized to true the conditional the semantics is optimized to avoid such split executions where possible figure a javascript function with implicit flows function fx y true z true if x y false if y z false return z return value x k false all strategies y true z true pc z false false naive y true z true pc k y k false true x k true y true y true z true z true pc k pc k stuck y k false stuck faceted evaluation y true z true pc k y k false true pc k z k true false k true false branch on x when x k false is split into separate branches on false and the first test is clearly a and so is the second test if since if is strict in since y remains true the branch on y is taken and so z is set to false thus the function call f k false returns false we now consider the evaluation of f k true under different dynamic information flow semantics while the prior semantics that we discuss here have no notion of them in terms of faceted values is naive an intuitive strategy for handling the assignment that is conditional on the private input x is to simply set y to k false to reflect that this value depends on private inputs unfortunately this approach is not sound since it the critical information that a public should still see y true the next conditional branch on y exploits this confusion since y is k false the branch is not executed so z remains true and so f k true returns true as illustrated in column thus this naive strategy fails to ensure since the public output of f leaks the contents of its private input various prior approaches attempt to close this information leak without introducing full faceted values with mixed results with the check execution halts on any attempt to update public variables in code conditional on private data under this strategy the assignment to the public variable y from code conditional on a private variable x would get stuck as shown in the n su column of figure this strategy guarantees but only at the of getting stuck on some implicit flows a more flexible approach is to permit the implicit flow caused by the conditional assignment to y but to record that the analysis has lost track of the correct original public for y the represents this lost information by setting y to the faceted value k false where denotes that the public is an unknown non value this permissive strategy accepts strictly more program executions than the approach but it still to stuck executions in some cases if the execution ever depends on that missing public then the permissive strategy halts execution in order to avoid information leaks in particular when y is used in the second conditional of figure the execution gets stuck the original paper used the to represent k false where the p denotes partially faceted evaluation as shown in the last column of figure faceted values handle problematic implicit flows at the conditional assignment to y the faceted value k false true simultaneously represents the dual nature of y which appears false to private but true to public thus the conditional branch if y is taken only for public and we record this information by setting the program counter label pc to k consequently the assignment updates z from true to k true false this assignment updates only the public of z not its private which as true the final result of the function call is then k true false comparing the behavior of f on the arguments k false and k true we see that from the perspective of a public f always returns false correctly that f returns false and so there is no information leak on this example despite its problematic implicit flows conversely from the perspective of a private to view fs actual output f the correct behavior of returning its private boolean argument a programming language with we formalize faceted evaluation for dynamic information flow in terms of the language shown in figure this language extends the calculus with mutable reference cells reactive io a special value and a mechanism for creating faceted values despite its this language captures the essential of dynamic information flow in more realistic languages since it includes key challenges such as heap allocation mutation implicit flows and higherorder function calls in particular conditional tests can be in the usual fashion expressions in include the standard features of the calculus namely variables x constants c functions xe and function application e e the language also supports mutable reference cells with operations to create ref e dereference e and update e e a reference cell to model interactive nature also supports reading from and writing to e external resources such as files the expression k e e creates a faceted values where the value of e is considered secret to principal k that cannot see ks private data will instead see the public produced by e we initially use the terms label and principals as and focus primarily on later introduces integrity labels in the context of robust declassification the value is used to represent nothing nil and undefined it is primarily used as the public in a faceted value k v which denotes a value v that is private to principal k with no corresponding public value figure the source language syntax e x c xe e e ref e e e e e k e e term variable constant abstraction application reference allocation dereference assignment file read file write faceted expression bottom x y z c k l f variable constant label principal file handle standard encodings true def false def if e then e else e def e de de xx if e then e def if e then e else let x e in e def xe e e e def let x e in e x fv e standard semantics of as a point of comparison for our later development we first present a standard semantics for that does not handle faceted expressions in this semantics values include constants addresses closures and as shown in figure a closure xe is a pair of a expression and a substitution that maps variables to values each reference cell is allocated at an address a and the store maps addresses to values the store also maps each file f to a sequence of values w we use the syntax vw and to indicate a list of values with v as the first or last value respectively and use to denote both the empty store and the empty substitution we formalize the standard semantics via a bigstep relation e v that evaluates an expression e in the context of a store and a substitution and which returns the resulting value v and the possibly modified store this relation is defined via the evaluation rules shown in figure which are mostly straightforward for example the rule evaluates the body of the called function where the notation x v denotes the substitution that is identical to except that it maps x to v the only aspect of this semantics concern the value which essentially means nothing or no information operations such as function application dereference and assignment are strict in if given a argument they simply return via the various rules this semantics for our later use of in faceted values since for example dereferencing a faceted address k a operates pointwise on the two to return a faceted result k v where v a figure standard semantics runtime syntax a address store address p value file value subst var p value v value c a xe w value evaluation rules e v c c x x s va r xe xe e xe e v x v e v e e v e e v e e e v a dom ref e a v a e a e a e e e a e v e e a v v e e v e e v f vw f w v e v e f f v v faceted evaluation having defined the standard semantics of the language we now extend that semantics with faceted values that dynamically track information flow and which provide noninterference guarantees figure shows the additional runtime syntax needed to support faceted values we use initial to distinguish the new metavariable and domains of the faceted semantics v value store subst from those of the standard semantics v value store subst values v now contain faceted values of the form k vh vl which contain both a private vh and a public vl for instance the value k indicates that is to the principal k and instead see the value often the public is set to to denote that there is no intended visible implicit flows introduce public other than we introduce a program counter label called pc that records when the program counter has been by public or private for example consider the conditional test if k true false then e else e for which our semantics needs to evaluate both e and e during the evaluation of e we add k to pc to record that this computation depends on data private to k conversely during the evaluation of e we add k to pc to record that this computation is dependent on the corresponding public formalizing this idea we say that a branch h is either a principal k or its negation k and that pc is a set of branches note that pc can never include both k and k since that would reflect a computation dependent on both private and public the following operation pc v v creates new faceted values where the resulting value appears like v to that can see the computation corresponding to pc and appears like v to all other vn vo k rest vn vo k rest vn vo def vn def k rest vn vo vo def k vo rest vn vo for example k vh vl returns k vh vl and this operation generalizes to more complex program counter labels we sometimes abbreviate k vh vl as k vh vl we define the faceted value semantics via the bigstep evaluation relation e pc v that evaluates an expression e in the context of a store a substitution and a program counter label pc and which returns the resulting value v and the possibly modified store rule shows how evaluation of a faceted expression k e e evaluates both e and e to values v and v with pc updated appropriately with k and k during these two evaluations the two values are then combined via the operation k v v as an optimization if the current computation already depends on data ie k pc then rule evaluates only e thus preserving the invariant that pc never contains both k and k conversely if k pc then evaluates only e function application e e is somewhat since e may evaluate to a faceted value tree with closures or at the leaves to handle this situation the rule evaluates each ei to a value vi and then to the auxiliary judgement v v pc v this auxiliary judgement recursively traverses through any faceted values in v to perform the actual function applications if v is a closure then rule proceeds as normal if v is a k vh vl then the rule applies both vh and vl to the argument v in a manner similar to the rule discussed above rules and are optimized versions of for cases where k or k are already in pc finally the undefined value can be applied as a function and returns via much like the earlier rule as an example consider the function application f where f is a private function represented as k xe the rules and decompose the application f into two separate applications xe and the first application evaluates normally via to a result say v and the second application evaluates to via so the result of the call is k v thus marking the result of the call as private the operand of a dereference operation e may also be a faceted value tree in this case the rule uses the function deref va pc to decompose va into appropriate addresses the corresponding values from the store and to combine these store values into a new faceted value as an optimization any in the address va that are not consistent with pc are ignored in a similar manner the rule uses the function assign pc va v to decompose va into appropriate addresses and to update the store at those locations with v while ensuring that each update is only visible to appropriate principals that are consistent with pc to avoid information leaks via implicit flows the faceted semantics of io operations introduces some additional since it involves communication with external files each file f has an associated view view f k kn describing which may see the contents of that file the following section defines when a computation with program counter label pc is visible to a view l and also l to project a faceted value v to a value v lv we use these two concepts to map between faceted computations and external values in files a read operation may be executed multiple times with different pc labels of these multiple executions only the single execution where pc is visible to view f actually reads from the file via all other executions are via the value v read from the file is converted to a faceted value pc v that is only visible to view f where pc is the program counter representation of that view an output e behaves in a similar manner so only one execution writes to the file via the rule this rule uses the projection operation v lv where l view f to project the faceted value v produced by e into a corresponding value v that is actually written to the file for simplicity we conditional branches as function calls and so the implicit flows caused by conditional branches are a special case of those caused by function calls and are appropriately handled by the various rules in figure to provide helpful intuition however figure alternative direct rules for evaluating a conditional test if e then e else e in particular if e evaluates to a faceted value k vh vl the if statement is evaluated potentially twice using vh and vl as the conditional test by the rule the projection property recall that a view is a set of principals l k kn this view defines what values a particular is to see in particular an with view l the private vh in a value k vh vl only when k l and vl otherwise thus each view l serves as a projection function that maps each faceted value v value into a corresponding value figure faceted evaluation semantics runtime syntax store address p value file value subst var p value r c a xe v value r k v v h branch k k pc pc branch evaluation rules e pc v c pc c x pc x xe pc xe e pc v e pc v v v pc v e e pc v k pc e v k pc e v k e e pc k v v k pc e pc v k e e pc v k pc e pc v k e e pc v f va r e pc v a dom v pc v ref e pc a v a e pc v v deref v pc e pc v e pc v e pc v assign pc v v e e pc v f vw l view f pc visible to l pc l k k l pc f w pc v pc not visible to view f pc e pc v l view f pc visible to view f v lv e pc f f v v pc application rules v v pc v x v e pc v xe v pc v e pc v pc not visible to view f e pc v k pc vh v pc v k vh vl v pc v k pc vh v vh k pc vl v vl k vh vl v pc k vh vl auxiliary functions deref store × value × pc deref a pc deref pc deref k vh vl pc fa s p l i t k pc vl v pc v k vh vl v pc v v pc value a deref vh deref vl k deref vh deref vl if k pc if k pc otherwise assign store × pc × value × value store assign pc a v a pc v a assign pc v assign pc k vh vl v where assign pc k vh v and assign pc k vl v figure faceted evaluation semantics for derived encodings e pc true e pc v if e then e else e pc v e pc false e pc v if e then e else e pc v e pc if then e else e pc e pc k vh vl eh if vh then e else e el if vl then e else e k eh el pc v if e then e else e pc v of the standard semantics l value value l k v v lv if k l lv if k l lc c la a l l we extend l to also project faceted substitutions subst and stores store into substitutions and stores of the standard semantics a file f is visible only to view f and appears empty to all other views l subst subst l x lx l store store l a la f f if l view f otherwise we also use a view l to operate on expressions where this operation eliminates faceted expressions and also performs access control on io operations by eliminating accesses to files that are not under that view l expr with expr without l k e e le if k l le if k l if l view f otherwise e le if l view f le otherwise l compatible closure thus views naturally serve as a projection from each domain of the faceted semantics into a corresponding domain of the standard semantics we now use these to formalize the relationship between these two semantics a computation with program counter label pc is considered visible to a view l only when the principals mentioned in pc are consistent with l in the sense that k pc k l k pc k l we first show that the operation pc v v has the expected behavior in that from the perspective of a view l it appears to return v only when pc is visible to l and appears to return v otherwise lemma if v pc v v then lv v if pc is visible to l v otherwise we next show that the auxiliary functions deref and assign exhibit the expected behavior when under a view l first if deref v returns v then the result lv is a value that is identical to first the store l the target address lv and then dereferencing the store at the address lemma if v deref v pc then lv next from the perspective of any view l if pc is visible to l then the operation assign pc v v appears to update the address lv appropriately conversely if pc is not visible to l then this operation has no observable effect lemma if assign pc v v then l lv if pc is visible to l l otherwise a consequence of lemma is that evaluation with a pc that is not visible to a view l produces no observable change in the store lemma suppose pc is not visible to l and that e pc v then l l proof in the auxiliary material for this paper we now prove our central projection theorem showing that an evaluation under the faceted semantics is equivalent to many evaluations under the standard semantics one for each possible view for which pc is visible theorem projection theorem suppose e pc v then for any view l for which pc is visible l l le l lv proof in the auxiliary material for this paper consequently if pc is initially empty then faceted evaluation simulates n standard evaluations where n is the number of principals noninterference the projection property enables a very simple proof of noninterference it already captures the idea that information from one view does not leak into an incompatible view since the computations are independent to formalize this argument we start by defining two faceted values to be if they have identical standard values for view l this notion of naturally extends to substitutions l and stores l v l v iff lv lv l iff l l l iff l l together with the projection theorem this notion of enables us to state and prove the standard correctness property of noninterference figure efficient construction of faceted values · · · pc × value × value value vn vo vn k rest k va vb k vc vd k rest k va vb k vc vd k rest va vc vd k vc rest vb vd pc k va vb k vc vd k rest k va vb vo k rest k va vb vo k rest vn k va vb k rest vn k va vb k pc va vc pc vb vd k rest va vo vo k vo rest vb vo k rest vn va vb k va rest vn vb k rest vn vo k rest vn vo pc k va vb vo pc vn k va vb k rest vn vo vo k vo rest vn vo k pc va vo pc vb vo k pc vn va pc vn vb where k head pc where k head vo where k head vo where k head vn where k head vn where k head vn and k head vo where k head vn and k head vo where k head vo and k head pc where k head vn and k head pc theorem noninterference let l be any view suppose then l l l e v e v v l v proof by the projection theorem l l le l lv l l le l lv the assumptions imply that l l and l l hence l l and lv lv since the standard semantics is deterministic this theorem can be generalized to computations with arbitrary program counter labels but then noninterference holds only for views for which that pc is visible efficient construction of faceted values the definition of the operation pc v v presented above is optimized for clarity but may result in a representation for faceted values for instance the operation k k returns the faceted value tree k k containing a dead that is not visible in any view we now present an optimized version of this operation that avoids introducing dead the essential idea is to introduce a fixed total ordering on principals and to ensure that in any faceted value tree the path from the root to any leaf only principals in a strictly increasing order in order to maintain this ordering we introduce a head function that returns the lowest label in a value or program counter or a result that is considered higher than any label head value label head k v v k head r head pc label head k rest k if k or k rest k k head k rest k if k or k rest k k head figure the operation to build values the ordering of labels the definition is but straightforward it performs a case analysis to identify the smallest possible label k to put at the root of the newly created value the revised definition still satisfies the specification provided by lemma comparison to prior semantics prior work presented the semantics and the pu semantics for dynamic information flow in this section we adapt both of these semantics to our notation to illustrate how faceted evaluation extends both of these prior techniques for clarity in this section we assume that there is only a single principal k and omit io operations since the two prior semantics were formalized under these assumptions finally we use the optimized operation from figure in order to avoid reasoning about dead comparison to semantics we formalize the semantics via the evaluation relation e pc v defined by the rules in figure these rules are somewhat analogous to the faceted evaluation rules of figure but with some limitations and restrictions in particular the semantics marks each raw value r as being either public or private v r kr public values private values the semantics cannot record any public other than the faceted value k r is traditionally written simply as rk in prior semantics denoting that r is private to principal k with no representation for a corresponding public this restriction on values means that the semantics never needs to split the computation in the manner performed by the earlier and rules instead applications of a private closure k xe extends the program counter pc with the label k during the call that this computation is dependent on data thus under the semantics the program counter label is simply a set of principals and never con principals k pc pc label after the callee returns a result v the following operation k creates a faceted value semantically equivalent to k v with figure no sensitive semantics evaluation rules e pc v c pc c x pc x xe pc xe n s u va r figure permissive semantics extends figure pu evaluation rules e pc v e pc a e pc v v pc v e e pc a v v e pc k a e pc v v pc v e e pc a v v pc e v k e pc k e pc xe e pc v x v e pc v e e pc v e pc e pc v e e pc e pc k xe e pc v x v e v e e pc k pc v e pc v a dom v pc v ref e pc a v a e pc va v deref va pc e pc v e pc e pc v e e pc v e pc a e pc v pc label a v pc v e e pc a v v e pc k a e pc v pc k label a v pc v e e pc a v v the optimization that the label k is unnecessary if it is subsumed by pc or if it is already in v k k v k r k pc k r v kr kr this optimization corresponds to the and rules of the faceted semantics in order to preserve the restriction on values the semantics needs to carefully restrict assignment statements essentially the evaluation rules for assignment statements halt execution in exactly those situations where the faceted semantics would introduce a nontrivial public these rules use the following function to extract the principals in a value label value pc label k r k the rule checks that pc is equal to the label on the original value a of the target location a if this condition holds then the value pc v stored by is actually equal to the value pc v a that the faceted semantics would store thus this check detects tions where the semantics can avoid information leaks without introducing non public the rule handles assignments where the target address is private k a in a similar manner to because of these checks the seman tics will get stuck at precisely the points where the faceted value semantics will create non public an example of this stuck execution is shown in the column of figure when the value for y is updated in a context dependent on the value of x execution gets stuck to prevent loss of information if the semantics runs to completion on a given program then the faceted semantics will produce the same results theorem faceted evaluation generalizes evaluation if e pc v then e pc v proof in the auxiliary material for this paper permissive the limitations of the semantics motivated the development of a more expressive permissive pu semantics which reduced but did not eliminate stuck executions essentially the pu semantics works by tracking partially data which figure declassification of faceted values declassification rule e pc v up pc v v e pc v function value value r r sp v v up sp v v v up v v up v v l v v l v v we represent here as a faceted value k r v r kr kr public values private values partially values since the public is not actually stored the pu semantics can never use partially values in situations where the public is needed and so partially values cannot be assigned invoked or used as a conditional test in particular pu computations never need to split executions and so avoid the and expressiveness of faceted evaluation we formalize the pu semantics by extending the evaluation relation e pc v with the two additional rules shown in figure the new assignment rules faceted values to handle the complexity involved in tracking partially data specifically if values are stored to a public reference cell in a context the data is partially and a new faceted value with a non public is created there are no rules for applying partially functions or assigning to partially addresses and consequently execution gets stuck at these points corresponding to the explicit checks for partially labels in the original pu semantics faceted values the permissive strategy the permissive strategy gets stuck at the points where a faceted value with a non is either applied or used in assignment theorem faceted evaluation generalizes pu evaluation if e pc v then e pc v proof in the auxiliary material for this paper again the converse to this theorem does not hold since figure shows an execution that gets stuck under the permissive semantics but not under the faceted semantics declassification for many real systems noninterference is too strong of a restriction often a certain amount of information leakage is acceptable and even desirable password checking is the canonical example while one bit of information about the password may leak the system may still be secure declassification is this process of making data public in a controlled manner in these partially values were represented as rp with a p denoting partially in the context of execution declassification is rather challenging the l and h processes must be in a careful manner with all of the problems involved in sharing data between multiple processes additionally allowing declassification may timing channels and the termination channel major benefits of the approach in contrast faceted evaluation makes declassification fairly straightforward the public and are together in a single faceted value during execution so declassification simply requires the faceted value to information from one to another providing a declassification operation with no restrictions most security guarantees for instance an attacker could a users password or data that would be later by code in this manner valid code to the result of a password check might instead be into the password itself to provide more reliable security guarantees in the presence of declassification with faceted values we show how to perform robust declassification which guarantees that an active attacker able to introduce code is no more powerful than a passive attacker who can only observe the results we use robust declassification as an example but faceted values could also support other approaches to declassification robust declassification depends on a notion of integrity which in turn requires that we distinguish between the terms label and principal in particular we introduce a separate notion of principals p into our formalism a label k then marks data as being secret sp or as being or untrusted up both from the perspective of a particular principal p p principal k label sp up secret to p untrusted by p in the context of a principal p we now have four possible views or projections of a computation ordered by the subset relation to help reason about multiple principals we introduce the notation lp to abbreviate l sp up so that lp is one of the four views from the above combined lattice note that in the absence of declassification the projection theorem guarantees that each of these views of the computation are independent there is no way for values produced in one views computation to influence another views computation we introduce an additional expression form e for values with respect to a principal p the rule in figure performs the appropriate robust declassification declassification cannot be performed by arbitrary code or else could all data moreover it is to allow code owned by p to perform declassification since could that code to data on their hence the rule checks that the control path to this declassification operation has not been by untrusted data via the check up pc robust declassification allows data to move from the sp view to the view but never from the sp up view to the up view this security lattice could be further refined to indicate which other principal was by p which would permit more finegrained decisions that is secret data can be only if it is trusted the function shown in figure performs the appropriate manipulation to values the following lemma that this function values from the trusted secret view sp to the trusted public view but not into any other view lemma for any value v and view l v lv if lp l v if lp where l l sp proof in the auxiliary material for this paper in the presence of declassification the projection theorem does not hold for the public trusted view since that views computation may be by data however the projection theorem still holds for other views to prove this relaxed version of the projection theorem we extend the standard semantics to treat declassification as the identity operation e v e v theorem projection theorem with declassification suppose e pc v for any view l for which pc is visible and where lp for each p used in a declassification operation we have l l le l lv proof in the auxiliary material for this paper as a result noninterference also holds for these same views theorem termination noninterference with declassification suppose lp for each p used in a declassification operation and then l l l e v e v v l v proof follows from theorem via a proof similar to theorem javascript implementation in we incorporate our ideas for faceted evaluation into through the javascript engine and the the implementation extends the faceted semantics to handle the additional of javascript exceptions are particularly and we halt execution if an exception may leak information we added two new primitives to the language the function turns a value into a faceted value with a public of undefined this approach allows developers to specify a different public value through the javascript idiom for specifying default values the following code sets x to a faceted value of k the high value of x is set to since the low value will be since undefined var x the second primitive is a function that extracts the public value of its input for example with the above code defining x would return generally the security a string specifying the principal can be given as the second argument if multiple principals are required policy should use these two functions or variants on all inputoutput boundaries of the system in order to appropriately label data as it comes in and to appropriately monitor data as it goes out to track information flow through the document object model dom our implementation uses the dom implementation written in javascript to preventing the attacker from data by writing it to the dom and later it our implementation is available online with some examples including the code from figure example to illustrate how our can be useful for enforcing practical we consider an example of a with an our do not prevent attacks rather they provide an additional layer of reducing an attacks power we specify a simple policy that the value of all password elements should be treated as furthermore any attempts to load files from a different origin should use the public the server the however should see the true value in our example the web is making use of a library for hashing on the client side the library is but an attacker uses an in the page to wrap the hashing library and export the password to a site under the control the injected code is given below var var var var title secret var return the attack attempts to leak the password by loading an image from the password into the name of the image however in an attempt to our it first writes the password to the class attribute of the title element and then it from the first h element without knowledge of the dom structure of the page it is not possible to know whether this code leaks information however with we the different of secret to the dom so that no security information is lost while the page can only a single it is critical that we maintain other views of the document with this example only the public of secret not the true password trusted sources do see the true value and therefore work correctly with the page while our example policy is far from complete we use it to illustrate how our mechanism can enforce different information flow policies a richer policy could specify a variety of fields and potential output channels furthermore we imagine that would wish to allow web developers to specify sensitive fields such as credit numbers and allow users to protect information that they considered for instance restricting the release of information performance results our approach is similar to and work on secure to understand the performance tradeoff between these two approaches we also implemented both sequential and concurrent versions of secure in and compared their performance to faceted execution our tests were performed on a pro running os x version the machine had a intel core i processor with and gb of memory for our benchmark we used figure faceted evaluation vs secure times in ms secure faceted principals sequential concurrent execution a result of indicates a test that ran for more than one the test from the benchmark suite we modified this program to include hashing operations with some inputs marked as our test cases involve through principals in each case every principal marks one element as private additional hash inputs are public for example test input and public inputs test inputs each marked as by a distinct principal and has no public hash inputs our results are summarized in figure our results the tradeoffs between the different approaches the sequential variant of secure had the most lightweight infrastructure of the three approaches reflected in its good performance when there are principals however it can neither take advantage of multiple processors nor avoid unnecessary work as a result once even a single principal was involved it was the worst the time required roughly with each additional principal concurrent secure our faceted evaluation implementation when the number of principals is small however as the number of principals increases faceted evaluation quickly becomes the more efficient approach since under secure the number of processes increases exponentially compared to the number of principals with three principals faceted evaluation concurrent secure in our tests beyond this point execution time for concurrent secure roughly with each added principal as the elements in the lattice now the available related work a few have discussed performing multiple executions to guarantee security properties et als executions develop an approach similar to faceted values for use in information for applications they run both a public and a private copy of the application the public copy can communicate with the outside world but has no access to private data the private copy has access to all private information but does not transmit any information over the network with this elegant solution confidentiality is maintained and extend this idea to javascript code with their secure strategy using a high and a low process to protect confidentiality in a similar manner our approach is similar in spirit though we avoid overhead when code does not depend on data et al some properties of secure our semantics are closely related to work by pottier and while they prove noninterference statically for core ml their proof approach involves a core ml language that has expression pairs and value pairs analogous to our faceted expressions and faceted values our work from in that we evaluate labeled expressions and values to dynamically guarantee noninterference rather than using them to make static guarantees et al use a similar technique in a javascript virtual machine for symbolic execution designed to detect uses not to be with secure to explore multiple paths in a single execution similar to faceted evaluation their technique treats data as symbolic and both paths whenever a value branches on a symbolic value the principal difference besides the application is that faceted values represent a lattice of different views of data while symbolic heap values represent a range of possible values for different environments other research has previously studied informationflow analysis for javascript et al track information flow in to against attacks and sabelfeld study timeout mechanisms et al discuss dynamic tree structures with obvious applications to the dom et al consider noninterference in reactive environment et al create a framework for information flow analysis with holes for analyzing dynamically evaluated code and discuss browser extensions et al give an overview of how javascript is used to privacy information flow analysis largely traces its roots back to et al approach as a type system and also offer a proof of its soundness heintze and design a type system for their purely functional slam calculus which they extend to include mutable reference cells concurrency and integrity guarantees sabelfeld and myers offer an extensive survey of other research on information flow myers discusses jflow a variant of java with security types to provide strong information flow guarantees jflow was the basis for a language with information flow et al show how capabilities can guarantee information flow policies and sands describe a flowsensitive type system and sabelfeld discuss the tradeoffs between static and dynamic analyses in some depth le et al examine code from branches not taken increasing precision at the of runtime performance overhead et al use a analysis to track variable dependencies and reject more programs over time uses integrity labels to provide robust declassification and myers consider checked and myers use a framework for declassification policies and sabelfeld study a declassification framework specifying what and where data is released and infer declassification policies for java programs et al complications of output channels et al buffer output to reduce data lost from output channels and termination behavior et al study false alarms caused by implicit flows discussion information flow noninterference is a security property to enforce via dynamic monitoring since it is a safety property noninterference can be only by observing two executions theorem conversely a safety property can be by observing a single execution and so safety properties are more amenable to dynamic enforcement from this perspective various prior techniques dynamically enforce a safety property that conservatively approximates the desired safety property of noninterference but this conservative approximation introduces false alarms on implicit flows interestingly our projection property theorem is a safety property that suffices to prove noninterference theorem without introducing false alarms acknowledgements we thank the anonymous popl reviewers for their constructive feedback on this paper we would also like to thank and for valuable discussions on information flow analysis and david flanagan and for their help working with the project this work was supported by nsf grant references sabelfeld and david sands noninterference leaks more than just a bit in pages ­ springerverlag and andrew myers a semantic framework for declassification and in esop pages ­ and sabelfeld tight enforcement of policies for dynamic languages in ieee computer security foundations symposium pages ­ dc usa ieee computer society thomas h austin page thomas h austin and flanagan efficient information flow analysis in proceedings of the acm sigplan fourth workshop on programming languages and analysis for security pages ­ new york ny usa acm thomas h austin and flanagan permissive dynamic information flow analysis in proceedings of the th acm sigplan workshop on programming languages and analysis for security pages ­ acm and sabelfeld capabilities for information flow in proceedings of the acm sigplan fourth workshop on programming languages and analysis for security acm benjamin c pierce weirich and reactive noninterference in acm conference on computer and communications security pages ­ r a vn and ap preventing information leaks through executions in pages ­ dec and andrew c myers security policies for downgrading in ccs proceedings of the th acm conference on computer and communications security pages ­ new york ny usa acm jeffrey a jhala and staged information flow for javascript in pldi pages ­ e a lattice model of secure information flow communications of the acm ­ and frank noninterference through secure security and privacy ieee symposium on ­ and analyzing information flow in browser extensions in pages ­ implemented in js available on the web at j s the computer journal ­ david flanagan and page accessed october le thomas p and david a confidentiality monitoring in pages ­ heintze and g the slam calculus programming with secrecy and integrity in symposium on principles of programming languages pages ­ and david sands on flowsensitive security types in popl pages ­ jhala and an empirical study of information flows in javascript web applications in acm conference on computer and communications security pages ­ accessed october and secure information flow exploring a new approach in ieee security and privacy michael and implicit flows cant live with em cant live without em in international conference on information systems security pages ­ benjamin benjamin and technical report microsoft research technical report for the browser http accessed october andrew c myers jflow practical information flow control in symposium on principles of programming languages pages ­ pottier and information flow inference for ml transactions on programming languages and systems ­ and sabelfeld limiting information leakage in communication in proceedings of the acm sigplan fourth workshop on programming languages and analysis for security acm and sabelfeld timeout instructions in web applications in ieee computer security foundations symposium and sabelfeld dynamic vs static flowsensitive security analysis in ieee computer security foundations symposium ieee computer society sabelfeld and tracking information flow in dynamic tree structures in pages ­ sabelfeld and andrew c myers languagebased informationflow security selected areas in communications ieee journal on ­ jan scott f smith and mark dynamic dependency monitoring to secure information flow in pages ­ jeffrey and inference of expressive declassification policies in ieee security and privacy christopher and cross site with dynamic data and static analysis in and smith a sound type system for secure flow analysis journal of computer security ­ javascript benchmark accessed october programming languages for information security phd thesis cornell university a type system for robust declassification in th mathematical foundations of programming semantics conference 