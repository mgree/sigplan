gradual typing embedded in javascript fournet chen microsoft research university of inria software institute fournet abstract flexible semantics makes writing correct code hard and writing secure code extremely difficult to address the former problem various forms of gradual typing have been proposed such as closure and typescript however supporting all common programming idioms is not easy for example typescript gives up type soundness for programming convenience in this paper we propose a gradual type system and implementation techniques that provide important safety and security guarantees we present ts a gradual type system and compiler for javascript in contrast to prior gradual type systems ts features full runtime reflection over three kinds of types simple types for higherorder functions recursive datatypes and extensible records the type any for dynamically typesafe ts expressions and the type un for untrusted potentially malicious javascript contexts in which ts is embedded after typechecking the compiler the program with various checks to ensure the type safety of ts despite its interactions with arbitrary javascript contexts which are free to use eval stack prototype and other features the proof of our main theorem a form of typepreserving compilation we prove all the runtime invariants of the translation of ts to javascript by showing that translated programs are welltyped in js a previously proposed dependently typed language for proving functional correctness of javascript programs we describe a prototype compiler a secure runtime and sample applications for ts our examples illustrate how web security patterns that developers currently program in javascript with much difficulty and still with results can instead be naturally in ts a of javascript while providing strong safety guarantees by of typing categories and subject descriptors d programming languages formal definitions and d operating systems security and keywords type systems languagebased security compilers permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than acm must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ san diego ca usa copyright c acm introduction writing secure javascript is difficult even simple functions which appear safe on the surface can be easily broken as an illustration consider the script below simplified from actual scripts in the and api javascript libraries that aim to impose access on the provided by web function stand in for function var return function url msg if msg send the function call on the last line returns a function that an access control check on send if this script were to run in isolation it would achieve its intended functionality however javascript programs run in explicitly link their code with frameworks and worse code fragments can be injected into the web by attacks for example the following script running in the same as protect could succeed in sending a message to an object prototype http com true this is just one attack on protect similar attacks are often the consequence of callbacks to untrusted code caused for example by implicit coercions or prototype and global object we found and reported several such security in the and api scripts that untrusted callbacks remain difficult both to prevent and to contain attacks type errors each of these attacks can be on lax notion of dynamic many runtime behaviors that are traditionally viewed as dynamic type errors eg accessing properties from an object are not errors in javascript however almost any such error while running a sensitive script can be exploited by a malicious context as follows that the script will dereference an otherwise undefined property x which in javascript would just return the value undefined a context can define x exploit then run the script and as x is and the callback access any argument on the caller stack thus for good scripts from bad ones type errors in javascript are just as as buffer in c despite the numerous dynamic checks performed by the javascript runtime some stronger notion of type safety is called for other researchers have made similar observations for example fournet et al show several attacks on a similar piece of code and argue that carefully the interaction between a script and its context is essential for security they show how to compile f a statically typed mllike source language to javascript in a fully abstract way allowing programmers to write and reason about functions like protect in ml and to let their compiler generate secure javascript automatically this is an design but the truth is that of javascript programmers are to switch to ml et al have developed a minimal statically typed secure core of javascript primarily for writing firstorder functions using arrays of fixed size is suitable for writing code like cryptographic libraries and et al prove that the behavior of programs accepted by the type checker is independent of the javascript environment in which they may run many others propose analyses for subsets of javascript et al and et al and sabelfeld et al et al although the guarantees provided only hold if the entire environment in which the program runs is also in the subset in question efforts like and address the problem of safely loading untrusted javascript into a programs environment after analyzing and rewriting it however in order to do this various javascript features are forbidden eg et al show that by out many commonly used javascript features eg eval or explicit prototype manipulation can safely untrusted code although we find the work on javascript subsets a promising line to indeed even the standard is towards the definition of subsets such as the strict mode assumptions about the environment are hard to validate in the presence of scripts ts a typesafe language within javascript this paper presents ts a source programming language that many of the dynamic programming idioms of javascript while ensuring even in an untrusted javascript environment ts supports writing functions like protect exactly as shown while a compiler from ts to javascript ensures that the access control check in protect cannot be although significantly more flexible than f or ts still rules out many inherently unsafe features of javascript for the code we protect thereby enforcing a programming discipline and security code we intend ts to be used to protect for instance sensitive resources and on web pages that also include dynamically loaded untrusted potentially malicious scripts by most of the code running on these pages is provided by third we leave such code unchanged and unprotected nonetheless by rewriting the scripts and typing them siek and we enforce a strong notion of dynamic in addition we protect our scripts using typedirected wrappers to them from javascript environments this places them on a robust typesafe foundation from which we can reason about their security in comparison other typed extensions to javascript like typescript and closure aim primarily to increase programmer by using types for documentation and code completion but provide no safety guarantee the concrete syntax of ts extends javascript with a language based on typescript our implementation works by first using typescript to infer types for every subterm it then uses the inferred types to typecheck the program once again this time using a more restrictive type system if this step is successful the program is compiled to plain javascript instrumented with various runtime checks to enforce for execution the ts type system itself has the following features a statically typed core of functions datatypes and records the base type system of ts includes primitive types like bool number and string higherorder function types recursive datatypes and extensible records of fields with optional annotations records are equipped with a structural subtyping relation for example the type point defined below is a subtype of a record that some of its fields and function subtyping is as usual contravariant on the arguments and covariant on the results number unit dynamically typed fragment the type any is for dynamically typed ts expressions all the types from the statically typed core are subtypes of any and all ts terms whose subterms all have type any can always be given the type any in the spirit of javascript in the we view records as extensible dictionaries with keys ts supports the use of computed properties eg in code expressions like or are legal ways to safely project the appropriate field from the underlying object if it exists dynamically typed code and its interactions with statically typed code are instrumented by our compiler for safety as far as we are aware ours is the first gradual type system to soundly support mutable records and computed properties runtime reflection over types case analysis on the runtime type of a value is a common idiom in javascript and other dynamically typed et al present several typical uses of typeof operator ts this idiom and programs with runtime type information rtti to support on all source types at runtime eg checks whether the rtti of p is a structural subtype of point in addition to providing an expressive source programming construct rtti also forms the basis of an efficient and simple enforcement mechanism for gradual typing an alternative to prior proposals based on higherorder contracts findler and felleisen un the type of the adversary by wrappers finally and most ts provides a second dynamic type un any javascript term which cannot be typed either statically or dynamically can be given the type un and simply passes through our compiler without further analysis or modification as such un is the type of arbitrary potentially javascript expressions our un type is of types for adversaries as proposed by gordon and jeffrey however unlike prior uses of un in the context of secure compilers eg fournet et al un is a firstclass type in ts un values may be stored in records used as arguments and results of functions etc the type un is incomparable to any in the subtyping relation and in contrast with any all operations on un values are by wrappers that safely build coercions to and from un as well as other types the wrappers enforce a strict heap separation between the and typed ts ensuring that code cannot break type invariants evaluating ts theory and practice we specify our compiler as a typedirected translation relation § to formalize properties of the translated program we give ts a translation semantics to js a dependently typed model of javascript developed by et al which is in turn based on js by et al precise monadic refinement types in js allow us to phrase our metatheory § in terms of of js yielding three main properties memory isolation untyped code ie the adversary cannot directly call read write or with typed values static safety statically typed code is safely compiled without any runtime checks even in the presence of updates dynamic safety runtime type information is sound and at least as precise as the static type we evaluate ts by programming and several javascript web libraries § our examples include a reference library to protect against request et al and an adaptation of secure and scripts within the api in summary our main contributions include a type system and runtime support for safely composing statically typed dynamically typed and arbitrary javascript § a type safety theorem and its proof by translation to js § a prototype implementation including a protocol to ensure that our runtime support runs first on pages compiled ts and our type invariant § security applications a series of and access control patterns taken from popular web applications and libraries motivated by new attacks § as such ts is the first system to provide a notion of type safety useful for secure programming while handling all of javascript the version of our compiler programming examples attacks sample and a technical report with the full formalization and proofs are all available from an overview of ts we begin by presenting the design of ts informally using several small examples for illustration we use the concrete syntax of typescript with minor simplifications for instance we write function types as t t rather than xt t we also extend the syntax of typescript with datatype declarations and qualifiers programs by moving from un to any while we ts as the basis of a typed language we initially consider javascript programmers to safety and fragments of their code they can start by giving their existing javascript code the type un in ts and then selected fragments to dynamically typesafe code in ts using the type any this exercise is valuable since any code in ts a memory isolation property a robust foundation upon which to build secure of a larger program memory isolation alone prevents many common attacks for example the prototype attack of § occurs because of a failure of memory isolation the command causes a traversal that ends with reading a field of which unfortunately is a reference to an object controlled by the adversary passing protect unchanged through the ts compiler while giving the type any produces an instrumented version of protect with checks to prevent any property dereferences from from accessing or any other un object thereby the attack specifically from memory isolation we can prove that every dereference of a field of any object in ts will only read the immediate fields of that object and will never access a prototype controlled by the adversary this ensures that returns true only if url is immediately defined in ts programs can generally be given the type any as long as they are every function parameter in an ts program to the type any every variable is given the type of its under this convention in the program from § the type of protect is any any which is a subtype of any when a ts program we assume that the javascript global object the window object in most and all objects reachable from it are under control of the attacker thus it is not safe to simply store into since that would break memory isolation and leak a value of type any to unsafe type system prevents the programmer from doing this by instead ts provides wrappers to safely export values to the context the ts expression the closure and yields a value of type un indicating that it is safe to hand to any javascript context while preserving memory isolation for the expression safely e from the context and gives it the type any providing a javascript implementation of wrap is nontrivial we base our implementation on wrappers defined by fournet et al their wrappers are designed to safely export statically typed values from the translation of an f program roughly a simply typed subset of ml to its javascript context and to import untyped values from the context into f at specific types for example fournet et als exports a pair of translated f values v v of type t u to the context by building a new object with two fields initialized to v and a corresponding wrapper does the converse safely copying a pair from the context and building a value that is the translation of an f pair of type t u fournet et al provide and wrappers for types t including unit bool string number pairs recursive datatypes and functions we extend their constructions to additionally build wrappers to and from the type any and to handle cyclic data structures that can be constructed using records with mutable fields to illustrate wrappers in action we elaborate on our first example suppose we to protect a but simpler for object with an access control check to support this the standard library of ts provides a facility to read fields from and write fields to the global object by including the following safe interface to the window object implemented in javascript the object whose interface is shown partially below the fields of the window object safely reading and writing it within a wrapper to ensure that the window does not break type safety using within a ts program we can safely import protect it and export it back to the context using the following of code typed in a context where the object has mutable untyped fields of course the attacker may a priori obtain a copy and even before our code has the to protect and update it but this is an orthogonal problem solved once for all ts and § present our mechanisms to ensure that our scripts run first on a web page interface send un wrap un any wrappers are expensive since they copy the contents of objects back and are not necessarily for instance they values filter out some properties and prevent some aliasing thus in an attempt to minimize the amount of copying we may rewrite protect by adding a few types as shown below function un un var http return function if msg wrap un string intuitively the msg argument in the closure returned by protect is treated abstractly that is our script does not directly access it thus there is no need to import that argument from the context potentially performing a deep copy on the other hand the url argument is not is used to project a field from the and as such it had better be a string the type system of ts gives us the flexibility to express exactly what should be imported from the context us find a good balance between security and performance the explicit use of un and wrap are advances of ts relative to prior languages such as f or for that matter any prior typed programming language expressing invariants with assertions over runtime types as can be expected of gradual typing a ts program from un to any can then with some effort be made statically typed static types can improve runtime safety of code modularity as well as provide better support static types in ts also improve performance relative to code and relying on rtti can enforce data invariants this is enabled by static safety and dynamic safety two properties in addition to memory isolation provided by ts static safety ts ensures that at runtime no failures happen during the execution of statically typed parts of the source program since there are no runtime checks in the compiled javascript for such parts as a the performance of statically typed ts code will approach that of native javascript and potentially it if the type information can be to the vm dynamic safety every ts value v t where t un is compiled to javascript with runtime type information rtti that initially reflects vs static type t ts ensures that while vs rtti may during execution eg as fields are added to an extensible record it is always a a subtype of vs static type t and b a sound approximation supertype of vs current type ie the rtti of v may only with respect to the subtyping relation we call this property dynamic safety as an illustration consider the example below which codes up a lightweight form of objects with extensible records and closures in ts where point is the type defined in § function y var self d return point self the function point creates a new point it allocates a new empty record and stores it in the local variable self then it adds three fields x y and setx the static type of self is just the empty record however ts allows us to add more fields to self than those in its static type as such the static type of a record only describes a subset of the fields in the term as is usual with deleting fields from records is also discuss this in more detail in § in the last line of point checks at runtime if the content of self is compatible with the point type and fails otherwise the term has static type point although the static type of self remains unchanged assertions like allow source programmers to safely update rtti while maintaining the runtime type invariant once a value has been tagged as a point then it is guaranteed to always remain a point a programmer may choose to add fields to a point or to further update its type information eg it into a but it will always contain at least the fields of a point any attempt to delete say the x field or to change it in a way using for instance a dynamically typed alias to the point will cause a runtime error in contrast statically typed code raises no such errors ts infers that function point has type point so the code below is statically type safe and does not require any runtime checks var o point as another example consider that popular web frameworks like provide implementations of the schema standard this allows programmers to validate data writing schemas for them also as objects in ts data invariants can be expressed and enforced directly using types rather than via schemas for example to check that a string can be parsed into an array of user identities we can write the ts code below assuming that has type string any see online for a ts implementation of a parser type users function users var o if users o return users o else return the schema is captured by the type users we parse a string j as using then use the ts operator to check that os contents are consistent with t if the check succeeds we stamp o as a valid users object and return it reliable primitive operations since the global window object is shared with the adversary all objects reachable from window may be this includes all builtin objects provided by the vm eg the default string object and others in order to ensure memory isolation translated ts programs should never read from any of those objects this is difficult to in javascript since several primitive operations eg reading and writing fields depend on base as illustrated in § thus in the face of even simple of objects are there is a relatively simple way out javascript since provides a function such that creates a new object with its prototype field initialized to arg as a special case creates an object with a null prototype meaning that the created object does not inherit the our compiler uses to create new objects in the translation of a ts program allowing of object fields simply as or without that a traversal of os prototype chain will reach an object there is one exception however function objects cannot be allocated using must inherit from the however by an invariant of the translation we can ensure that the only field ever accessed of a function f is rtti so as long as contains a safe immutable rtti field accessing will never trigger code the correctness of our translation then requires a reliable way to call and to initialize to achieve this compiled ts programs are linked with a library called this library is intended to be the first piece of javascript that runs on a discusses how to make a script run first before any script takes a clean copy of and stores it in an immutable field later the translated ts code accesses from this field rather than as which is an path we show a fragment of below simplified slightly to use based on field names such as rtti instead of the longer names less likely to with source code used in our implementation function var clean function function rtti clean value clean false false undefined the listing above defines a function that is run once and then discarded within the scope of the function we construct a clean object in which to maintain copies of functions like on which our translation relies lines ­ define functions that implement queries and coercions on runtime types and discuss their implementation in detail in § line calls the javascript function to make clean immutable line and line registers the clean object at the path use to define immutable properties embedding ts in javascript the clean object in provides trusted core functionality upon which we can build a secure compiler in this section we outline the embedding within javascript of the point example from § there are a few broad features of the translation that we focus on · adding information to every object and function · checking runtime type information in the any fragment · embedding wrappers to safely values the listing below shows the translation of the ts function point to javascript the translated code is placed within a single enclosing function to introduce a fresh local scope without this ts definitions would implicitly leak into the global untyped ob the type annotations in ts are all erased in javascript function var point function xy var self self rtti write self x x write self y y var tmp function d write self x d tmp rtti number unit write self setx tmp return clean point self point rtti any any point var o point o setx line the source empty record is compiled to a new object line we set the rtti field of self to the translation of a source empty record type lines and we use the macro write to add two properties to the self object this macro defined in § checks that the rtti of the assigned field if any is compatible with the rtti of the in this case since the rtti field of self is just the empty record it does not constrain the contents of any of its fields so these assignments succeed and the fields are added to self line we translate setx and line we tag it with an rtti field recording its source type we then add it to self using write line the call to checks whether self whose static type is represented by contains a valid representation of a source point for this it the representation of the type point notice that the type requires three fields x y and setx value v x true false d v expr e v f e e f e f e ee ee e let x e in e e e d e if e then e else e q t e c t e query q coercion c wrap t y pe t u bool t any un t u access a r w sig s dt t s s env xt figure formal syntax of ts then it checks that the self object contains values in those three fields whose are compatible with the types number number and number unit respectively once this check succeeds updates the rtti field of self to point an invariant of our translation is that the rtti field of every object with respect to the subtyping relation that is was initially and to point where point the rtti of self may further but it is guaranteed to always remain a subtype of point line we add an rtti field to the point finally lines and we see the translation of a statically typed fragment of ts the translation there is just the identity as shown the translated program does not interact with its context at all however the programmer can choose to export certain values to the context by writing export function instead this the compiler to wrap and export point to the context by inserting the following code after line point clean wrap any any point un point formalizing ts this section formalizes ts by presenting its type system and typedirected translation to javascript we describe in particular our runtime representation of types and the javascript implementations of and related functions that manipulate translated terms and their types we conclude this section with a detailed comparison of ts with prior gradual type systems syntax figure presents our source syntax to aid in the readability of the formalization we employ compact calculus style notation writing for example instead of return e we also write e for a sequence of expressions e en f e for the application f e en and so on our formal syntax does not cover the untyped fragment since its typing and compilation are both trivial although of course our theorems specifically address the composition of compiled ts code with arbitrary javascript values v include variables x booleans typed abstractions and data constructors d applied to a sequence of values for we primitives like numbers and strings since they can in principle be encoded using data constructors in practice our implementation supports javascript primitives and so we use them in our examples this requires some care however since some operations on primitive types can be by the adversary in such cases we cache reliable versions of those primitive operations in the clean object built by in addition to values expressions e include record literals projections of static fields and assignments to static fields we also include projections of computed fields ee and assignment to computed fields ee e it is important to note that records even records of values are not values as in javascript evaluating a record returns the heap location where the record value is stored we have corresponding to immutable var bindings in our concrete syntax function application data constructor et s e u s s u t et s tx x x x t u s f e u record f s u sd t t e t s td d e t t xt e t s t t e st t e u f w t s e t s e f e t s f s eu f a t s e f t s f e t t s e t s e e t s s e u s xu e t s let x e in e t x s s e any s if e then e else e t i ei t if s s si else s et s t t q t e bool t s tq et s t t c t e t t s ac i ei any si e e any s i ei any si ee any reads s i ei any si ee e any writes s s s t t s t t s t t s t t s t t s t t s u u s t u t u s t t s s s f r t u f r t u s t any s t u u s s s t st s s is s t s s tt tt t t t t any t un t tt uu u ja j a j t j t j u u where let x s in s s s record f st let in x f s s t let in x e st t let return s in t f s reads s writes s s let fs in let xs in let xs in let fs in xf let xs in let fs in let vs in let t in f tf any t t t t f a t let o f t aw un figure a typedirected translation of ts to javascript cation and conditionals finally we have query operations q t e and coercions c t e types t u include a number of primitive types bool for boolean values and any and un for dynamic values abstract data types ranged over by t and records record types are written using the shorthand to denote the type f a t fn an tn where the fi are distinct and the ai are annotations r for readonly and w for mutable we also write t u for the record type where t and u the type system is given with respect to a signature s which maps data constructors d to their type signature written t t in places we need to refer to all the data constructors for a given abstract data type t in the signature s we use the shorthand st which is defined as d t t sd t t we also have a standard type environment binding variables to their types although we have data constructors pattern matching in ts is not primitive instead it can be encoded in terms of the other constructs as defined below note that we freely use and other boolean operators as well as physical equality on ts values match e with x e else e let y e in if t y d then let x yi in e else e type system and translation figure defines the judgment e t s which states that in an environment along with an implicit signature s the expression e can be given the type t and be translated to the javascript program s we present the type system in practice our type checker analyzes a fully ast produced by the type inference algorithm of typescript so implementing the system in figure is straightforward a precise description of this type inference algorithm is beyond the scope of this paper at a high level the type system is designed to enforce the following three properties mentioned in § static safety ts programs have no failing dynamic checks during the execution of statically typed subterms we achieve this via two mechanisms a the rules by t enforce the static typing discipline and they never insert any runtime checks when compiling the program b when a value is passed to a context that expects a precise type eg point the compiler inserts instrumentation to ensure that v is indeed at least a point instrumentation inserted elsewhere in dynamic code also ensures that v remains at least a point this statically typed code from future modifications to v in the other direction the type system allows for v point to be passed to context via subtyping dynamic safety the rtti of vt is always a subtype of t and a sound approximation of vs most precise two mechanisms a vs rtti initially reflects t and the operation ensures that rtti always towards the more precise types per subtyping and b the rules by a the translation of the parts of the source to enforce that modifications to v respect its rtti we that an can uses of a rules to the programmer as potential failure points memory isolation untyped code cannot directly access an object reference that ts code may dereference this is enforced by ing that the un type is treated abstractly the only way to manipulate un values is via wrappers which means that typed code never dereferences an untyped memory location and that references are never be directly to the adversary the subtyping rules are designed to prevent the presence of in records using or subtyping to any we now turn to describing each of the rules in detail the first rule in the judgment is a subsumption form which shows that a use of subtyping in ts does not change the translation of a term the subtyping relation s t t also in figure is mostly standard depth subtyping on records is permitted only for immutable fields the rule allows all types that do not contain the un type to be a subtype of any the auxiliary predicate detects occurrences of un in a type allowing un any would clearly break our invariants allowing fun any is also problematic since if a value could be to then vf would also have type any even though it produces an untrusted value the last subtyping rule provides on records the fields to weaken t u to u only so long as t contains no occurrences of un the rule tx for typing variables is standard introduces a record at type u such that u includes all the necessary for compatibility with subtyping its compilation allocates a new object safely sets the fields to and finally adds an rtti field containing u the rule td for typing data constructors is similar the typing of functions with is standard however the translation to javascript is a bit subtle it defines a javascript function tagged with an rtti field whose body s is by declarations of all the variables in e the source function body these and other rules use the javascript form e which evaluates every ei in e and returns the last one the rules and are standard one slight in is that we rely on javascript implicitly converting u to a implicit conversion is a safe primitive operation one could imagine a variant of with a runtime check to ensure that u is a boolean without applying implicit conversions however as shown is more of javascript on the other hand our treatment of local variables in from variables are always immutable in ts we make this choice since if desired can be encoded by boxing the value in a mutable record field in contrast encoding immutable local variables given only mutable ones is impossible even with immutable record fields the rules tq and ac cover queries q t e and coercions c t e in each case we have an expression et compiled to s and we apply q or c at type t so long as t and t are compatible type compatibility is a simple reflexive symmetric and relation in the spirit of siek and we discuss the implementation of these operations in the next subsection the remaining a rules the translated programs to ensure safety in we first check that s is a function then before calling the function we tag the argument with the type of the functions parameter simply checks that s is an object and that s has field s checks that s is an object it then checks that ss rtti allows for field s to be written if ss rtti does not contain s it is treated as a new property a property if it is not present in the rtti is also straightforward although we do not cover it here otherwise it should contain a mutable s field and before writing s is tagged with the type expected by ss rtti implementing coercions and wrappers as described in § runtime support for compiled ts programs is provided by the immutable clean object in the global by the script this section discusses in detail the and wrap operations provided by the runtime updating rtti with the form t et is compiled to ts where e to s in this case the first argument t is redundant since it can be from the rtti of s which by dynamic safety must be a refinement of t we keep the first argument for with wrappers as discussed below the call ts down to whose implementation is shown in figure on the left this code tries to update the rtti of s to be some subtype of t and fails otherwise there are two main concerns that the code addresses the code should not diverge if s is a cyclic data structure unless is called if the tag of s is updated then s must represent a value of type t and the new tag must be a subtype of both the old tag and t these two concerns are complementary since certain types eg nonrecursive types or types without mutable fields specifically require all their values to be acyclic the main idea of is to traverse the objects reachable from x in a depthfirst manner at each point checking that each field required by t is present in the object at the expected type lines and each object encountered in the traversal is marked line as visited by assigning to the assigned value is the greatest subtype of both and t which may not exist in which case the operation fails by calling cycles are only when traversing mutable object references and cycles are detected by looking for a marker in if the traversal succeeds the temporary marker is made by updating line if it fails a error is raised by calling which the javascript stack this is but effective failure modes are feasible too coercions based on can be conservative particularly on higherorder values for example trying to coerce the identity function id any any to the type bool bool using will fail since any bool as such coercions are most effective when working with mutable firstorder objects one way to the scope of coercions is of course to the type language eg to include polymorphism or even refinement plan to explore this in the future additionally we provide operations to query rtti t e and t e that respectively allow programmers to query the current tag of e and to test whether or not a operation on e would succeed when coercions are eg on untyped values or conservative eg on functions the wrap form is we describe it next wrappers when et to s wrap t et to shows part of its implementation on the right line is the case where both t and t are function types as expected we apply a higherorder cast to s the argument applying s and then the result thus any bool bool id succeeds where the corresponding fails from un the more interesting case of wrap is when the source type is un and the target type is any line which occurs when an untyped value from the adversary into the typed fragment of ts at line we use typeof operator to examine the simple type of x the untyped value being if x has a primitive type then the coercion is just the identity if x is an object we aim to enumerate all its fields then wrap and copy each of those fields into a newly allocated object this requires some care however since directly or accessing the fields of an untyped objects causes callbacks to the untyped adversary potentially memory isolation by objects on the stack to the context as a we build on an idea from fournet et al as follows at line we allocate a new object r into which we will wrap and copy the fields of x next we build a closure stub at line which captures function t function wrap src tgt x var if arrow arrow if tmp in x var f function y return function ok x y if t return x tgt return f if typeof x t else if un any switch tt switch typeof x case record case undefined if t record t any case string foreach t function ft case number if x case boolean return x if case object ft var r clean create null x ft typ ft var stub function return ok foreach x function p v case data r p wrap un if t any if x c stub return r var ct constructors t x c case function foreach ct function ix arg var function x return wrap if x ix var function x return wrap x ix arg false var f x return ok f rtti any any return f default default figure implementations of and selected fragments r and x but otherwise takes no arguments and returns nothing as such the stub can be viewed as a function from un to un in the body of stub we enumerate the fields of x then wrap and copy each of them into r all that remains is to call stub and return r the call itself is done using which provides a safe way to call an untyped function without memory isolation the function is defined as where id is the identity function and is the wrapper for untyped functions from fournet et al see figure in that paper when x is a function line we again use this time the argument and then the result returned value has type any any to un the implementation of for t un exports s to the context this case is somewhat simpler since s is a typed value with rtti which can be safely if s is a primitive it can be exported as is if s is an object wrap creates an empty object x all the fields f of s exports them recursively and adds them to x for functions it uses fournet et als to export it at type un un discussion and related work on gradual typing languages that mix static and dynamic types date back at least to abadi et al and and gradual typing is a technique first proposed by siek and initially for a functional language with references and subsequently for languages with various other features including objects several others have in this space for example flanagan introduces hybrid typing static dynamic and refinement types wadler and findler add blame to a gradual type system et al present gradual typing with wrappers et al describe type dynamic in c and and add gradual typing to generic java our system is distinct from all others in that it is the first to consider gradual typing for a language embedded within a larger potentially environment via the type un we are also to the best of our knowledge the first to consider gradual typing as a means of achieving security to compare more closely with other systems let us set aside un for the moment and focus on the interaction between any and statically typed ts previous type systems the interactions between static and code by implicitly casts to values higher order casts may fail at a program point far from the point where it was inserted to account for such failures blame calculi identify the cast with a label to indicate the term or context that causes the et al survey blame calculi based on the errors they detect points of failures and casts they blame in contrast interactions between static and ts is based primarily on rtti casts wrappers in our terminology are never inserted implicitly although they are made available to the programmer this design has the following advantages preservation of object identity object identity in javascript is a commonly used feature since ts does not implicitly casts to values it never implicitly breaks object identity in the source during compilation previous gradual type systems with implicit casts would always break object identity space efficiency casts can up around a value making the program inefficient et al introduce a novel semantics to gain our approach is also space efficient there is only one rtti per object but does not require machinery static safety and eager failures in contrast to our mechanism statically typed code in other gradual type systems could fail although blame would help them it to the code consider the following ts example let in int rf v compiling this term using introduces a on the argument v at type the operation at runtime recursively checks that v is a and fails thus the failure happens prior to the application a failure strategy called eager in prior works et al also argue that their system can provide eager failures but to their notation with the record replaced by a ref any the failure occurs at the property read within the statically typed term static safety when eager runtime checking seems too strict ts wrappers provide an escape for our security applications a uniform strategy is a suitable default dynamic safety and blame with no failures inside statically typed code to explain at runtime blame seems less useful with coercions however because we enforce dynamic safety rtti failures may now arise in code as in the following example let in bool rf v this time the of v to succeeds and it modifies vs rtti to be but now the update of vf to hi fails this failure in the fragment should be on the operation instrumented at the application we plan to the details of this new notion of blame as future work gradual typing for monotonic objects independently in an unpublished manuscript siek et al investigate gradual typing for a language based on an earlier abstract presented at the stop workshop in like us they notice that the type of a mutable object to at runtime enables statically typed code to be compiled without runtime checks leading to improved performance and safety for that fragment there are some important differences however first siek et al require monotonicity with respect to an subtyping relation for example to our notation the type of an object can from t f w any to t f w number although t is not a subtype of t this means that in their system writing of true can fail at runtime even if o has static type t which is by ts this difference perhaps from on static safety siek et al are to runtime errors in code whose typing the type any in our system runtime errors may occur only when values are eliminated ie in our a rules only syntactically errors in this manner does not appear as straightforward with subtyping additionally siek et al do not aim to model an is a single dynamic type not two ie only any no un exploring how to adapt our type un to against python contexts would be an interesting line of future work metatheory this section formally establishes memory isolation static safety and dynamic safety for ts programs translated to javascript clearly such a proof requires a formal semantics for javascript we rely on js a translation semantics for javascript developed by et al which is in turn based on js et al we provide a brief review of js define the central invariants of our translation and describe our main theorem a full formalism including all proofs is available online a review of js and our highlevel proof strategy js is a subset of f et al a programming language whose type system allows expressing properties of higherorder effectful programs prior work defines a semantics for javascript via translation to js the semantics is implemented by a tool called that translates javascript concrete syntax to js this semantics for javascript has been used previously both as a means of verifying javascript source programs after translation to js as well as in fournet et als proof of full abstraction from f to javascript at its core js provides a mechanically verified library called that tries to model most details of javascript including for example its object model and its calling convention the metatheory of ts is stated in terms of its translation to js ie programs that can be against the api the validity of our theorem depends on js being a faithful model of javascript an assumption that can be checked separately eg by semantics testing to set up the formal machinery we develop a model of our compiler by the translation judgment in figure to instead generate js code the relationship among these translations is depicted the translation from ts to js can be seen as the composition of the translation from ts to javascript and then from javascript to js our main theorem is stated as a result from ts to js where the types in js are precise enough to capture our desired invariants ie static safety dynamic safety and memory isolation monadic computation types with heap invariants all computations in js are typed in a state monad of predicate transformers which is parametrized by a predicate and a predicate the type a wp is the type of a computation which for any postcondition post when run in an initial heap h may diverge or else produce a result va and a final heap h that satisfy the formula post v h h h h so long as h wp post h is valid additionally all intermediate heaps in the computation satisfy and every intermediate heap is related to all its successors by that is in a wp a is the result type and wp is a predicate transformer that computes a precondition for the computation with respect to post any desired postcondition is an invariant on a heap and is a reflexive and transitive relation how the heap our online also account for exceptions and errors however we over them here for lack of space the main idea behind our proof is that a ts term et is translated to a js term e of type dyn where w pt post h ok h v h t v h post v h this ensures that if e is run in an initial heap h satisfying h and ok h meaning that all of the e are correctly to the heap in js then either it will terminate with a result v and a final heap h satisfying t v h or it will diverge the code may also raise an exception or throw a error but all the while during the execution of e will be true and the heap will according to this result holds even when e is linked with arbitrary javascript the universal typability lemma of fournet et al javascript code can always be typed in js at a type corresponding to un our main task then is to carefully define and t such that they capture our desired invariants and then to prove that translated programs are welltyped in js invariants of the translation to prove memory isolation js provides a partitioned heap model every object reference carries a tag which records the name of the into which the reference points ie each is a disjoint fragment of the domain of the heap there are six in the heap model the ref holds objects corresponding to ts records datatypes and rtti the abs holds function objects the clean holds the clean object initialized and then frozen by and the un belongs to the adversary we focus primarily on properties of these first four the remaining two inv and stub are inherited unchanged from fournet et al the former is for maintaining local variables and the latter for tracking function objects used to make safe callbacks to the attacker refined type dynamic all javascript values including the translation of ts are represented as js values of type dyn defined below we show only three representative cases s is an injection of into type dyn where the refinement typeof the static type for object references obj the refinement is ls tag ie ref abs un clean finally for functions fun o f builds a value of type dyn from a function closure f and the javascript object o for that closure its refinement is the predicate transformer of f type dyn str string obj fun wp dyn wp o args this translation of types to recover the precision of ts types in js we translate source types to predicates on values and the heap t d h states that the value is the translation of a source value of type t in the heap h the translation of a type is with respect to a heap since a source value allocated at the type f a number may to become a value of type f a number g a number in some subsequent heap this is in contrast to and a significant generalization of the translation of f to js where a values type does not and is not subject to subtyping string d h typeof un d h d t d h u t tagged u d h if t string un tagged u d h rtti dom hd rep u h is u d h is any d h d fun is d typeof d h is t d h typeof d i ti h n d h is d h typeof dom hd hd h d h is t t d h typeof d o args h t h r h t r h p r h fs d h f any h since strings are immutable string d h does not depend on h likewise an untyped value always remains define for other types t d h captures the subtyping relation stating that there exists a type u t such that the values rtti is tagged with the runtime representation of u the predicate rep u h and is u d h ie the value d can be typed at u in h is any d h states that d is either a primitive eg a string a function or a location in the ref heap where all its fields eg rtti are at any for datatypes and records we require d to be a location in the ref heap with the fields typed as expected and with all other fields not mentioned in the type being any the case for functions is most interesting is t t d h states that ds predicate transformer builds a precondition that requires the first argument to satisfy t all javascript functions are variable arity receiving their arguments in an array however a ts function will only read the first one in return the predicate transformer ensures that the result r if any will satisfy t recall that we are ignoring exceptions here un values the predicate v defines when the value v could have been produced by can be given to or is accessible by the context un values include primitives references to objects in the un heap or the immutable clean object which is reachable from the global object additionally un values can be functions whose specification indicates that it takes un arguments to un results x typeof x bool string float un clean typeof o args this post h o this args r h r post r h the global heap invariant our main heap invariant is a property of every location x in the heap its full definition contains clauses we show the most important ones h x x dom h x dom hx hx hx t tagged t d h typeof hx h clause asserts that all the contents of an un object are also un clause asserts that every object in the ref and abs with an rtti field is tagged properly clause additionally specifies that every object in the ref heap has a null prototype clause asserts that the clean object is specified by which gives a type to each of its fields within this invariant are two key properties of ts the first clause guarantees that the only values reachable from a location in the un heap are themselves lies our memory isolation adversary can never with ts objects directly since these in the ref and abs heap which are disjoint from un the invariant in its second clause also captures dynamic safety ie every object in the ref and abs heap once tagged with rtti are properly typed according to it the heap evolution invariant the full definition of has clauses we show the main one below ensures that for all objects in the ref and abs heaps their rtti fields only downward according to the subtyping hierarchy h h l dom h t t rep t h rep t h t t a relatively easy lemma derivable from these definitions implies our static safety property in particular lemma guarantees that if a value v potentially a location to a record is at type t in some initial heap h then as the programs heap according to v remains at t this ensures that it is safe for ts to a value a static type since that type is an invariant of the value at runtime lemma static safety preserves the interpretation of types for all values v heaps h and h such that h h and h h if for some t we have t v h then t v h finally our main theorem as is a type preservation result that guarantees memory isolation dynamic safety and static safety for ts programs translated to js in the hypothesis the relation f e t e is the formal translation of ts to js the index f is the name of the current function object in e a technical detail the judgment in the conclusion of the theorem asserts that in a translated environment e has a type that is described by the predicate transformer corresponding to the source type t as explained in § this ensures that the translated program respects the heap invariants and if it terminates normally produces a result theorem type preservation given a ts context an expression e and a type t if f e t e for some js expression e and function object f then f dyn e dyn we conclude our formal development with a few remarks on the scope of our theorem and the style of its proof first our result is applicable to the translation of ts to javascript only as js is an accurate model of all of et al argue for how js is adequate for all features of javascript regardless the availability of these semantics together with its program logic is what made our proof feasible given an operational semantics but a program logic our proof would have been in tedious over the operational semantics with js we were able to carry out our proof as an induction over the compilation relation and use the type system of js to structure and prove our invariants second our result includes within its trusted computing base the correspondence of to the predicate in the last clause of while it is perhaps standard for compiler and verification projects to rely on a small amount of trusted code we would like to do better in particular we aim to use the javascript verification developed by et al to verify for with the time of writing this was still incomplete more substantially we would also like to build a translation validation pipeline for our compiler implementation the generated javascript back into js for verification ie we would like our compiler implementation to be also formally typepreserving ts programs the guarantees of ts depend on being the first script to run on a web page many prior works have implicitly assumed that scripts are always executed in the order in which they appear on the page et al et al et al but as we explain this is a view instead we develop a mechanism that ensures that our scripts run first the ts runtime suppose a script s is the first element in the header of a page located at a url u one may expect that it will be guaranteed to run first on any window loaded from u however this intuition is correct only if the page has not been loaded from javascript by another web page eg within another frame on a page loaded initially from u the script s will indeed run first still a malicious script running later on the page or on a different page with the same origin may open a window or frame at u and modify all the essential primitives before s begins to run inside the new window frame this execution order is consistent with the html standard et al and we have it on all hence any simple implementation that relies on lexical ordering of script elements will fail if other scripts on the same origin are allowed to open windows or frames indeed the web browser only provides security guarantees at the of an origin separation between good and bad scripts within the same origin require mechanisms such as restricting all untrusted scripts to a like et al loading them in with few et al or modifying the browser to allow the script to all other scripts running on the page et al rather than restrict the functionality of untrusted scripts we propose a mechanism that ensures that our scripts run first for a given we use two distinct · used primarily as the service origin it does not serve any resource · that serves html pages including scripts compiled from ts but where the first two script elements on every page are as follows script the crucial step here is that after has loaded the page sets to the parent domain this is a mechanism et al by which the page gives up its to the origin for access across frames and windows instead it an effective script origin of all subsequent scripts on the page are unrestricted except that they can only read or write into frames or windows that have an effective script origin of and hence they cannot with pages on even if such pages are loaded into other frames or windows in all other ways their functionality is without the need for expensive translations or protocols as in previous approaches more generally by placing other trusted scripts after and before the assignment to we can run scripts that reliable copies of builtin libraries such as and for use by subsequent code loading scripts with embedded our protocol allows to build a environment for our compiled scripts conversely we sometimes need a way for scripts to be able to verify that their environment is this is particularly important when compiled scripts contain secret tokens embedded within them eg to themselves to other servers embedding as constants within program text may seem like an elementary but this is the way of these tokens in a javascript setting within scripts must first be protected from malicious that may try to load our scripts and second from malicious scripts on our own in this model many simple one may think of are even if we require a for authentication before the script a malicious that an user when into can make a script request and obtain the script an attack sometimes called javascript if we inline the scripts into our page malicious scripts can read their source code and obtain the token even if they are not but from malicious scripts can perform an to obtain their source code and then read them indeed these are all methods commonly used by attacks eg the to break security on the web to protect our scripts from we use a third distinct origin to serve our scripts · the secure source server only serves get requests for scripts that may embed secret tokens to be shared between the server and the script the server requests and returns scripts as so on can execute these scripts but not read its source due to the policy we the use of for any pages that contain but http is adequate if we network adversaries from our model to protect our scripts against other we need an additional check every script from is by a condition on the current location that is before making any use of its secret token the script checks that actually begins with this ensures that the script has a reliable clean object on that page introduced by we found that checking the current location of a script is quite some scripts try to read see eg in § or others rely on but then use regular expression or string matching to check it against a target origin all these techniques lead to attacks because a malicious could have with its document object or with the regular expression libraries we found and reported such attacks to notably many allow properties like and to be our origin check relies on the object which is specified as in the html specification et al in practice however we found that some allow even objects like and to be we have reported these bugs to various and are in discussions about if the of turns out to be too strong an assumption we the use of the origin authentication protocol of et al secure web programming with ts we have evaluated our compiler by javascript sources to ts while ensuring that the code after compilation exports the same api as the original we have also written from various like a parser and a reference monitor for html all the code is available online we have yet to a performance analysis of our compiler and to implement further optimizations but as mentioned previously statically typed ts should little if any runtime overhead while untyped code is unchanged understanding and optimizing the performance profile of code is left as future work in this section we describe how ts can be used to secure existing access control patterns as in popular javascript we focus on languagebased security most other details to the online notably a description of policies protocol and browser specific security assumptions and current attacks against them see also eg et al we first consider the task of client code that performs an to the pages server request suppose a w has an api available from javascript and access using ensures that only requests from a users browser are accepted conversely if the user has any another open in her browser their scripts also get access to the api and can thus or with the users data on w such request attacks are listed in top and have a serious impact on a variety of tokens as a to a w can a fresh random token into every page it serves and only accept requests that include this token other cannot see ws pages thanks to the same origin policy hence cannot requests additionally and tokens can be protected while in by using the protocol is the most protection library as an advanced feature it provides a script that calls by any similar exist for frameworks like and the token must be kept secret from other and also from other scripts loaded on the page otherwise those scripts may use it to perform arbitrary requests directly or leak it to some other attacks the original version of their code relies on and which can be with by a malicious script we found several such attacks where a malicious could load the script the location and trick it into the token we are in discussion with the author towards more robust designs such as the one proposed here for ts in ts following the approach of § we to ts the that uses the token to provide authentication to the rest of the library this small script is typed in ts that no malicious script that runs including the rest of the library can with its execution the ts listed below takes three string arguments the target url the api function name and the arguments it checks that the url is wellformed and belongs to the current site to avoid the token to any other site then it the request as a query string the token and makes an call once wrapped it exports the same interface as before to any untrusted scripts loaded on the page additionally it could be directly used by further ts code var string var string function any if var m token var request var response return else return url the first two lines define string literals by the server as it generates the ts compilation process ensures via lexical scoping that these two strings are private to this script the rpc function is our secure replacement for which performs the actual compared with the original javascript it includes a few type annotations and uses either safe copies of builtin libraries such as and string or typed ts libraries such as outlined below relying on memory isolation and secure loading from ts a simple informal security review of this script lets us conclude that it does not leak we modified the library to and protect the few scripts that directly use the token such as the above from the rest of the code which deals with complex and extensions and is kept unchanged and untrusted the modified library its original interface and functionality with stronger security guarantees based on strict typebased isolation of the token its code and sample client and code are available online to our knowledge it is the first library that provides protection from untrusted scripts api taking advantage of resource sharing provides a javascript api so that trusted may access their personal the user has in interestingly also provides a library with systematic dynamic somewhat similar to those automated by ts to help programmers catch errors we focus on two aspects of their large api the encoding of strings and encoding we give a ts implementation of the module mentioned above for the rest message format used in the api function any var res if s return res else var for var k in var kv kv return res the encode function is dual our function illustrates support for arrays provided by our this code may be used to parse untrusted messages our wrapper for un to string is the argument is already a string it is just the identity hence one can write efficient ts that calls to parse messages received from the adversary this coding style is in javascript while the checks performed by our type system and runtime prevent many another ts sample illustrates the usage of rpc and our typed library generalizing to program a higherlevel statically typed api it shows for instance how to program a for the me method of the api which the user profile this ts function has the return type type profile id string email string the api is meant to run on any and itself from a malicious host by using for example if the calls the api loads an from that the current users access token and then only sends it to the host via if the host is in a list of et al report attacks on a prior version of this code that were due to typing errors and have now been we this code in ts and show how programmers can rely on typing to avoid such attacks the function below is given the current host origin and verifies it against an array of the function uses this check to guard the release of the token to the parent host using a safe copy of the primitive function function for var k in expected return true return false function string in a previous version of the api was called with an parameter of type string rather than array string this type error leads to an attack because the untyped version of the code succeeds with both strings and arrays but with different results to see the core problem consider a call to where given h and expected the for loop iterates over each character of expected and hence succeeds when it should not in ts iteration is welltyped only for arrays and unlike javascript this only the own properties of the array thus in our code this error is statically if the incorrect call to is local or dynamically if the call is from another the check fails in both cases and the token is not conclusions and this paper aims to the scope of gradual typing not only it is useful for dynamically typesafe code to more structured statically typed code it is also useful for moving from unsafe code to security attacks to a robust of dynamically and statically typesafe code within the context of javascript we have presented ts a language with a gradual type system a compiler and runtime support that provides several useful safety and properties our preliminary experience suggests that ts is effective in scripts from safety and such properties are difficult to obtain for javascript and indeed security for such scripts has previously been thought in the presence of scripts even the adversary ts a new point in the design space of gradual typing using an approach based on runtime type information this has several useful characteristics including a simple and uniform failure semantics and its applicability to a language with extensible objects and object identity in the future we plan to develop ts along several dimensions on the practical side we expect to integrate our ideas in an experimental branch of the open source typescript compiler the construction of larger secure libraries on the theoretical side we plan to explore the formal certification of our compiler and runtime we also hope to develop our preliminary ideas on new notions of blame to explain runtime failures in ts acknowledgments many thanks to abadi siek wadler and all the anonymous reviewers references m abadi l cardelli b pierce and g plotkin dynamic typing in a statically typed language acm toplas ­ d p and d separation in html applications in proceedings of usenix security a the web origin concept a c and j c mitchell robust for request in proceedings of ccs r t e and s html wc k a and s languagebased de against untrusted browser in proceedings of usenix security g e and m adding dynamic types to c in proceedings of ecoop g and d typechecking smalltalk in a production environment in proceedings of oopsla r d and r jhala dependent types for javascript in oopsla api r b findler and m felleisen contracts for higherorder functions in proceedings of icfp c flanagan hybrid type checking in proceedings of popl c fournet n j chen pe py and b fully abstract compilation to javascript in proceedings of popl a d gordon and a jeffrey by typing for security protocols in proceedings of s and b mostly static enforcement of security and reliability policies for javascript code in usenix security symposium usenix association a c and s the essence of javascript in proceedings of ecoop a c and s typing local control and state using flow analysis in proceedings of esop d and a sabelfeld informationflow security for a core of javascript in proceedings of d a and c flanagan gradual typing higher order symbol comput l and a gradual typing for in proceedings of oopsla t n and m script injection attacks with embedded policies in proceedings of j p h and d sands safe wrappers and policies for self javascript in proceedings of user manual j g s a a and s typebased verification of javascript in usenix security j g siek and w gradual typing for functional languages in scheme and functional programming workshop j g siek r and w exploring the design space of higherorder casts in proceedings of esop j g siek m m and s gradual typing for mutable objects n j chen c fournet py k and j yang secure distributed programming with types in proceedings of icfp n j c j chen and b verify ing higherorder programs with the dijkstra monad in pldi a u j c mitchell m s and j automated analysis of javascript in proceedings of sp p wadler and r b findler welltyped programs cant be in proceedings of esop 