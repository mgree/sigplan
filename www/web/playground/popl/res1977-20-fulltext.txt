minimal and optimal computations of recursive programs des de paris and le france introduction procedure call mechanisms have mainly been studied in the framework of recursive programs without assignments for the simplicity of their operational and denotational semantics see scott according to operational semantics procedure calls act as textual computation rules select at each computation step the occurrences of unknown functions to be rewritten a computation rule is called correct if the value it computes is the one given by the denotational semantics correct ness and efficiency of computation rules have been studied in the main results are wellknown innermost evaluation call by value is not correct are correct parallel outermost or full substitution gives a sufficient condition for a rule to be correct safety later extended by into a necessary and sufficient one security also studies a particular delay rule implementation of he shows its optimality with the respect to a reasonable implementation cost provided satisfy a condition result is in fact allows elimination of useless steps and optimality follows by using sharing mechanisms in term implementation the basis of all these studies is the following theorem provided some tive conditions on programs are satisfied the set of terms derivable from a given term is a lattice under the derivation ordering aim is to extend these results for the three following reasons first though every program can be transformed to match conditions the transformations may affect the costs of computations a more direct proof can be investigated second a direct generalization to the is not straightforward since definitely do not form lattices third the symbolic or herbrand interpretation is not sequential in the sense of and no optimality result is known for it our point of view will be purely syntactic we the lattice property in derivations we study minimal computation ie finite or infinite the symbolic interpretation and transform them into optimal ones eventually we characterize interpretations to which similar results apply extension in towards the is done the lattice property of terms breaks down in general two very different derivations may lead to the same term by which two a priori we take care of this and a preorder different terms in section i fact by introducing an on derivations we give three of these relations for the main one we extend the classical notion of residuals by defining residuals of derivations tions we show that derivation classes by a ce in section ii we study the simple derivations defined by with use of labels named here derivations we give two of them in the usual formalism section iii is to and results ordering infinite derivations as well as finite one we construct computations of every syntactic approximation of the infinite tree determined by the program the associated com derivation are with respect to cost extension to interpretations is then straightforward as soon as they satisfy a syntactic condition all classes of sequential interpretations considered in do satisfy this condition the computation rule we use for constructing the optimal computations is very inefficient in general but reduces to the usual delay rules in sequential interpretations let f ff fm be a set of each symbol f is given with its arity pf symbols in k the symbols are called constants a is an object i df is a set and each f is a mapping fl where d pf from dt into a morphism i e d d of which preserves i and is a mapping the operations fi fi i f ei the free consider of variable a set vx x symbols and generates the it contains v and is such that for any i every mapping v v d extends in a unique way into a morphism iv d elements of are called terms and will by wellformed formulae or trees the morphism iv determines the value of a term for the interpretation i and the data mapping v a substitution is a mapping u v extended into a morphism u mf v we write o and for occurrences of symbols in terms let denote concatenation for and of s in t is defined and the set by c be the empty word of i ii tf for s x fe fk k u with c ei if sf and c otherwise then s f and f the size t lemma let the number of occurrences and then in either with t and or proof by induction on the length of c o recursive residuals program schemes derivation and consider two disjoint sets basic function symbols and unknown function symbols given with fm of of the ct and pi n we write all terms and belong to m and since we shall only be interested in occurrences in we abbreviate into c in t given cc in t then r if c is a prefix of c c c written and c and c are disjoint written if neither nor an occurrence c in t is outermost in t if it is not contained in another c in t a recursive program scheme z is a system of equations z ix x i i i n and pi we consider in notations an additional decomposition a fixed program scheme let tem and variable there exists t st e thus omitted and let y be a unique and then t immediately into by c written t t iff rewriting given of three cases are possible by lemma i with is created by the derivation ii in t iii then t is a oft with and then c in t is a residual see church in t ox xx fl is a residual f lf here is of f and f l are residuals of fl created and with f given et cc denote the set residuals of the elements of c by immediate tion of c and let cc abbreviate cc a derivation d t t is a sequence of d tc t k t the concatenation k of d t t and d t t is written and denotes the empty derivation when t is assumed from the context d can be written dcc ck therefore c will denote either an occurrence context tions for or its the notion derivation of residual by in each extends to and cg c the set of all denoted by t if derivations starting from ck then cd t is cc equivalence of derivations modulo permutations the preorder t t is not an ordering if conditions are removed and term classes do not even form lattices let z x x and consider all derivations from example involves the derivations x ox and d x lx which give the same result by using term spaces is the same as using spaces by te equivalence dd if d and d are of the form t t remark now that and cd the example suggests to define a written equivalence let be if dd and cd cd for all c in t then dd as a congruence for the concatenation defines a preorder by did iff d st the same definition gives the image in derivations of the preorder in terms however the equivalence generated by is not take z xy and let and then since and but d d is false therefore on derivations we define a equivalence i definition of the equivalence the following of our constructions permutation lemma is the basis lemma ifc c are in a term t then proof let and let c be in t we have dd and by case ins ld on the relative n positions of c cl c thus definition the equivalence written is satisfying i of derivations the least ii if dd then for any notice concatenation and that is that is the least congruence which satisfies the permutation a refinement of ie for implies ld intuitively dl by successive if we can match d with uses of the permutation lemma complete derivations of a set of occurrences let c be a set of occurrences in a term t following curry we are concerned with deriving all occurrences of c this notion clearly makes sense when c is a set of disjoint occurrences as previously seen but this is more difficult when there are nested occurrences in c definition of c is the derivations defined the set of set of finite and infinite by theorem and equivalent all derivations modulo permutations in are finite proof if let be the nesting level of c ie the number of prefixes of c in c let be the maximal nesting level in c and n c be the number of occurrences in c at level i the c nl c then c of thus one can check c when is all derivations easily that nc for the in c are finite ordering on furthermore any k n suppose we get by induction on nc the only problem is when and by we have c thus if d c then and by induction and hence by ij this theorem is a form of property e because we replaced by equivalent the modification seems minor here but is crucial for what follows notations we consider as an elementary step of derivation and write t t for such a simply c in a derivation context we use letters for derivations and therefore write dc c cn c c t t t hence c t n length of d is the num of nonempty derived sets and w is extended to sets all these notations are consistent because of theorem the permutation lemma extends to sets as follows and this corresponds to the socalled lemma of parallel in a term lemma if c c are sets of t then c c c occurrences in proof both sets only contain ions n f complete residuals of derivations definition residual if d d the derivation by d is inductively by i d ii dc d id this d d definition makes sense by induction taking as hypothesis that on and is illustrated by diagram square is an application where each lemma d d proof by induction on for induction on by simultaneous for and lemma if then proof by induction on id o this lemma is a of the tion lemma to derivations but is also a form of the churchrosser theorem and the proof technique is exactly the one used in but the advantage of considering equivalence instead of appears in terms of residuals of derivations equivalence exactly means consistency of residuals of derivations the equivalence defined in can be generated using lemmas or instead of lemma il lemma if d then proof we have only to consider and dc c c thus d cc cd where by lemma we get c by lemma therefore by and if and similarly hence by d disjoint occurrences of derivations of theorem dd iff proof by induction take or dd on using d and remark that by induction on using and d proposition did iff we proof by induction on and lemma because is a refinement of take or dd and apply d proposition formally the equivalence if is left then did proof obvious from since n the lattice of derivation classes we now define the preorder on derivations definition d d iff dst d dd proposition with for associated dd the relation equivalence s is a preorder and sd iff proof dd since dd assume then there are d and d st and d dd ence dd s and did now suppose then for some d thus lemma and theorem implies therefore conversely if one has by the permutation lemma ie now if we have and thus did by d notation of d and dt let d be the equivalence be the set ut class theorem ordering is dl and d the set t a have the lub with the two elements proof one has dd furthermore let and by we have lemma implies where but by and hence d and by d it is also shown in a greater lower bound that d have standard derivations standard derivations which work in an out way and by convention from left to right for disjoint occurrences are introduced in the theorem in allows any tion to be but although there can be several standard derivations between two given terms each equivalence class contains a unique standard derivation this will be our improved theorem definition for ts and let ss l where d is all i the standard or if d standard and di if is standard and for internal it only notations if cc derives the set c of of occurrences is the derivation d is internal if internal sets let s lemma for any c there st n and are n and c inter proof by theorem since any complete derivation we can consider of cn theorem there tion in each equivalence is a unique standard class of t proof existence this proof comes from consider any derivation with the above lemma we can write cn where either maximal nd be or ci is internal for all i let id with d internal st dd e the number of internal ci preceding be let some formally nd is the number of i st ci is internal and j st consider the triple we have two cases first ld ly dc d with d internal by induction on w y d is standard ld dc d dd cs d with and c and d internal and but c cannot create is a complete derivation of hence with c internal by the above lemma and therefore dd with dd c ld d then s and cc c ccp c po since if c or and by induction dd where if c and d is standard uniqueness let we prove dd by induction be standard on st dd the induction works easily when or now suppose and ds then so and eds theorem which contradicts dd by labelled derivations we use labelling system to mark occurrences along derivations given an e let the set e of words on e be the set of labels in fact associativity is not necessary but convenient for notations a p of a term t is a mapping a labelling v of the pro gram z is a vn of v of the t i given a labelled term tu and an ele derivation dt with the corresponding step of labelled derivation d is defined by if if c creates c and for example let tx and and let us write labels as of occurrences in terms suppose and then notation we write the form d d if d and d are of the permutation derivations lemma also holds for labelled lemma if c c are in t then cc z c for all u proof by cases inspection proposition all u proof obvious if d d then d d for lp from u definition a labelling p of a term t is consistent if the labels pc and pc are for any pair c and c of nested occurrences in t a labelling w of x is consistent if all the vi are consistent with then vc and ya is labelled our notations i f v is consistent and cc we remark that implies for any y and the consistency of label a technical condition used to connect terms and the equivalence lemma if uv are consistent then p is consistent and if proof labelled by cases derivation inspection o on one step of proposition for any d there st d d p if vv are consistent then is one and only one d standard proof st dd by for any d there is d standard hence by now suppose that d and d are standard st more precisely let dd we prove dd by induction on d if the induction works easily or by using assume now that and ds we have and t t along but d we get u c any c in t either with c internal to some t i and h by the consistency hypothesis and therefore either there c is created by e is no c in t st me for label hence no in t can have which s o theorem did iff consistent pv for all u iff proof by by and by instantiation family of occurrences and derivations family of occurrences in order to compute in an must share duplicated objects ring residuals along derivations necessary but not sufficient optimal way we see is certainly as shown by the let let dt x where cf lf the two occurrences and cfg l in t are not of the same object along d but it is easy to see that they have to be shared this can be expressed in two ways the first alternative used by is to share them because they have the same label in any labelling of d residuals of shared occurrences are shared but also occurrences which are created in the same way by shared occurrences the second way used here does not involve labels there is a permutation d of d namely t st cl l then are indeed residuals of a unique occurrence l in and therefore can be shared in will be shown equivalent thus labels will be explained within d the two the behaviour the usual approaches of formalism notation from now on any pair written dc is an abbreviation for dt and c in t we also consider pairs dc when c is a set of occurrences in t definitions and read has same family as follows we consider the relations for residual and belong to over pairs dc defined as s the st and if dc st and or if dc st hence the second relation is the and transitive closure of the first one it is straight forward to check that s is a preorder and is an equivalence let us remark we use the same symbols for different relations the context will always avoid any confusion proposition the two compatible with the equivalence permutations namely if dd above relations of derivations and dd we are wrt have iff and iff proof obvious since and o when proposition iff and if did and if for il then cc if d and then there is a unique c st if for il then there are a unique c and some d st d lub and proof obvious once we remark that did implies and that and we have by definition d c c if consider again the above example let and d suppose c cc have the same values as above we have representative inside but dc its family seems because more d does nothing but creating c and all the elementary steps of d are contained in the derivations d and d definition the derivation d generates dc if do or and c creating notation c if with dl generating let proposition if d generates there are dl and c st proof obvious by induction on dc and dl u then notation if d generates then let and this notation makes sense by dc and d ccl where defined definition representative bv c creates for any pair dc the of dc written is if c does not create if and c this definition means that we extract from d the only steps concerned by the creation of c we first prove that the canonical representative definition is consistent with the equivalence of reductions modulo permutations ii io lemma for any cl c c proof by cases inspection d lemma if c and if c dcc proof by induction on if u then proposition d if then proof by induction on the definition two above lemmas d of we now connect canonical prove families of occurrences and in two steps we first in fact we shall have a stronger theorem property which is then we show that not necessary d for our implies definition if dt and c is in t then c and d are iff are disjoint for any i st sin cn thus and c c i cd lemma if cd are disjoint and then c and are disjoint i and moreover proof by induction on id the only when dc by hypothesis we have c and for any c in c as residuals of disjoint are still disjoint one has c and i thus ie c cd and since residuals problem is c disjoint occurrences disjoint too but since are with respect to permutations ie we have lemmas if then if then if d d c then proof by induction on o proposition for any dc there st and is proof consider any d in d then by use an induction on id if do then now suppose by tion there is d c st let and and let cd co and o we have secondly two cases first if and therefore o we have d o c does not create c creates c then if and and c then ie where hence and as cc is a set of disjoint occurrences the derivations c o are disjoint for all c in c cj but these derivations form therefore dd c more over c and d are disjoint hence but by the permutation lemma we have dd d o by we get c by one has c let since we have by and therefore by since c and d are disjoint moreover by we get and dc cl then o in short if c c and theorem iff proof the previous proposition implies hence if then by definition hence there is d st d and dc by lemma and by proposition now when we have by transitivity n therefore two occurrences family iff they are generated belongs to a same in a same way proposition let then iff proof corollary of th clause lst clause o and we now show the connection and labels between families definition given any term labelling p is elementary if range of u is the set of letters e t the ie the lemma for any label elementary o if ij and v are there is at most one dc st d d generates proof by induction on the length of a o theorem let for il then iff when pv are injective elementary iff for all proof first implies by the definitions the converse fol from and complete derivations i definition the set of c of occurrences is with respect to d in short dc ik if cc when maximal definition st there dc are d is if c is dc with and definition dc is if cu c when aid definition the derivation d is respectively d and complete if d or when d and are resp d and lemma if d is then for any c proof do by it is sufficient to prove we use an induction on id if d then otherwise ddc with di and if then there is only and by induction else one c in c which creates c let one has by but as is we get d for all c in cl by induction and d hence so d by by proposition d is iff d is is when the initial are injective and elementary proof theorem obvious with the above lemma and notation we write t for an derivation from t to t we call derivation starting at t the set of proposition the set with the ordering with the same lub is a operation of t proof let us remark that if and d then there is c st by and suppose now that did are then it is obvious by induction on id that is for any d with use of d definition for any d in we consider the to d defined by derivation associated where this definition does not work with permutations but we will use it for the dis about straightforward the cost of derivations it is to check that d is that d and that d for any when d is least and optimal computations semantics of recursive we define the operational te as in h semantics with denotational is shown in f programs semantics in the equivalence of this or algebraic semantics definitions ordered sets let be an ordered set of least element i they exists least upper bounds and greatest lower bounds is ca directed and is are denoted and a set if st and an if it is directed and implies an ordered set d is complete if every directed set has a lub ua a mapping is monotonic if implies ordered set set containing continuous if d and d are complete and for every directed set given an d a completion d of d is a complete d up to morphism and such that for any complete d every monotonic mapping ex in a unique way into a continuous mapping all isomorphism ideals is the red by inclusion completions of d are equal up to uni as an example the completion by set dm of nonempty ideals of d it contains represented by every mapping the completion and has l for least element extends by of d is denoted definitions r ordered and complete an ordered complete is a i where d is ordered has least element l and the f i are monotonic continuous a of ordered of let o be complete is a which is also monotonic a new constant symbol let also written m let be the the least ordering a implies f on mq st f for qa for all a and all f for exam ple holds then is the free ordered generated by v and its com by ideals k lf is the free generated by v for any ordered complete data mapping extends i in morphism bi intuitively a unique is i every way into a the tic undefined an contains infinite terms re presented by all their finite the morphism iv gives the value of any term under the interpretation i of the function symbols and the data mapping v definitions any we associate its semantics syntactic to value i ii for all iii s for all program scheme on a triple the interpretation co there is a i is a complete st and v is a data mapping then t t st by induction on and the t is directed its lub inl is called et the term determined by the program value pt computed by p on t is where lt t remark that with for dt t we denote and infinite derivations computations definitions and infinite let k denote the let t be the set f fi derivations from t for ed t k first steps of and let and sq to hold iff ko st and let m be the associated equivalence let let f be the class of clearly sm implies ss make sense and the notations s and iv proposition the structure is a completion lattice of and is a complete proof notice that contains rt and that th relation m restricts to s on qt moreover every is the limit of the directed set the first part c t using this completes the proof of the completion by ideals it is easy to see that a completion of an lattice is a complete lattice we can therefore and abbreviate s and m by definition let the derivations be defined by ad k it t kt let infinite full derivation proposition proof by induction on d show kt that be the t definition let p fe a program and t be an initial a computation of p on t is a tion t it is a computation of iff a computation is correct if pt correct if it computes tl in a computation if and et t is for implies for every syntactically the full derivation correct derivation is is correct by least computations in we restrict our attention mm and construct of at to the symbolic in a least computation definition a derivation is outer most iff every occurrence derived in the corresponding term in d is outermost lemma if then there exists a least n such that every standard or such that d begins with en mo is decidable proof if there exists dt standard that if tf then no if t every standard or outermost derivation must begin with c and the result follows by induction on if n denotes the cardinality of then is equivalent n to which is decidable see definition at there exists least for a standard proof by induction o for af let and satisfy a derivation and outermost t a which is on for a then by lemma every d such that is of the form end where f and d for some then by induction where dt conditions d t al p d tk ak satisfies the we now extend tions notice that this result to infinite d holds iff st let and such that let be an increasing chain of limit a let where and as in al ak d ai is constructed let to d t z al st is least if s is a chain for a and also for of limit a then any ast proof let such that s assume by then for some d sa there exists some db such that since then dd notice can tk ak implies td that a least he constructed syntactically from the correct chain optimal computations in from now on we denote hy a derivation and by a finite or infinite derivation definitions and trivially extends to infinite derivations the cost of a derivation is its length id but as before a simple sharing tech applied to derivations allows to derive all occurrences in a complete step at cost let lf the cost of a derivation is then the number of nonempty set derived this notion of cost does not extend to infinite derivation we shall use a way of comparing derivations definition given mz ly f d c is the equivalence such that and and class the of dc for cz ck let c and define let and let fa and f be similarly defined lemma let then proof derivation obvious from and n is of fa by for cost cost and definition then a and which computes a let tc and such that is for a i it comp for any we now transform results results into outermost definitions if each occurrence a is set derived in contains an in the corresponding term dc lemma let c he outermost then assume proof we have cd form cd with therefore then otherwise n is of the lemma let with d outer most then d implies proof induction on id and lemma cl outermost proof lemma let and induction on id outermost let ddc then is c if c by and otherwise and is outermost now by and d is outermost so and follow proposition let with outer most then holds iff proof induction on let lc with outermost if zi then c f by and holds by induction if we get by hy induction and n and and zz proposition with d outermost let and then implies s and proof by definition of and ii theorem let let and acm such that be a chain of a let be such that then st is least a for a and a in m and is optimal sa and dst for a and by but st is st and as before notice ly correct derivation that an optimal is least and optimal computations in our results m in mq extend to interpretations provided the following condition is satisfied definition an interpretation if for every there exists i is mapping therefore such that a for computing a exactly means computing define for a as in theorem let cl s be let let i and any chain in mq of limit st let and m in t st then st is least for a and a and st is least and optimal for u and a in proof from and using which trivially notice follow that when and c from the definition iv is algebraic t of c iv see the condition can he restricted to hold only on finite terms example interpretations typically parallel functions as the parallel or of of give of lt and c without proofs the l or tt following does not examples write if st c assuming continuous gh exist stable l if every f satisfies and in pi then i is ii notice that m is stable sequential interpretations equivalent definitions exist several implies m s q no condition is needed on not either fl is or ai st ail implies fl and st aq a a ail for each a same situation ak fl is sequential as with de these stable and then interpretations are m is sequential computation optimal rules computations and the theorem does not suggest a cal way of performing optimal computations we do nat want to first compute in trees and then adapt this computation in pointer structures we are not only interested in the re of an infinite computation but also in the in information results i produces see step of any o such that call definition if a computation i is optimal for is at each information we give the covering implies aa an q hy the following step i without proof a result in define m by aa q then a is obtained from if aa a some construct now t and d in way hy a slight extension of i ii for some af such that c pt a exists i otherwise theorem the computation optimal t if is an the covering ai is used to some oc of i in t to he the cons of can be done directly in pointer struc tures let v is possible to construct a optimal correct tation which is also optimal in the following way starting from ti perform full derivations to reach t such that then choose a ble ai such that and apply ii to reach t notice that optimal finite which is undecidable in in mm in this q case our rule full substitutions from some ti computations may be general loops but not performing notice also that this rule is of no cal interest we first perform full derivations and then a select the useful steps what we really need is a way of selecting from this is the purpose of the de and definitions imply acm st am aa a implies a and a can be constructed from a in this ease to delay rule notice that when optimal computations are finite the delay rule loops producing useless steps instead of looping in searching for the next step in fact in such sequential interpretations the computed values form a and a stronger optimality result holds if is optimal then for any there exists such that and see such an optimality can not be values can be computed stable interpretations tial interpretations expected if non comparable as it is the case mm q or in in conclusion under some fair conditions optimal of recursive programs have been studied at a purely level we left then by considering the universe mi and dealt with the following problem how to re the ordering on derivations to the cost of derivations this has been done here with use of outermost derivations which derive only crucial occurrences intuitively any true permutations of an outermost reduction could have ie permutations which only use the permutation lemma these derivations are o ar computations in r when we consider a covering approximation step although the safe derivations are defined in some more way the conditions inl are directly derivations related to our s ordering since are the safe secure outermost derivation optimal derivations seems interesting when values of can he infinite objects as in where are evaluated with a delay rule finally nearly all propositions and in this paper seems also true in the this indicates that an approach could be taken see although it seems to the authors that such an approach could not bring simplifications references g bottomup pp computations of recursive vol n g and b and forms sta discrete interpretations automata languages and programming rd edinburgh university press uk g et des to appear the calculi of princeton of lambda conversions math b and m families of th r and r and computation recursive annual on of computer sc and data of and and networks of appear as report interpretation of the and a labelled calculus the symposium on calculus and computer sc le et appear abstract models of typed appear in computer sc r theorem for r and re presentation and computation rules for recursive program nd and program in r the interpretation program of recursive di r manipulation systems and no r theory of r techniques for recursive r et de 