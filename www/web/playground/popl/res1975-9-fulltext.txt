a semantic model for parallel with scheduling department of pittsburgh s computer science university pa abstract this paper presents a semantic model for par systems with a scheduling mechanism that is useful for expressing and proving a range of properties than semantic models that do not er scheduling we formally describe a number of properties related to scheduling and deadlock including and and show that with these properties behave in desirable ways we prove and conjecture some proof rules for scheduled systems and outline briefly the relation of this work to modelling protection in parallel systems introduction using mathematical theory of tion scott have introduced a model of parallel based on processes that communicate by sharing memory and have how to state and prove properties such as mutual exclusion formally within the system they treat nondeterminism by introducing oracle from the domain tt string of truth see kahn the determination of which to execute next depends on an initial of the oracle with the remainder oracle an values the new in of the of their system they are unable to prove certain properties of par systems that one would expect to be true primarily this from the difficulty of characterizing the of their oracle by using a model derived from work we replace the oracle with a scheduler and state a property of fair ness which is shown to be adequate to prove a property of a particular parallel system that is difficult to express in system this work was supported by the advanced research projects of the department of under contract no and by the force of scientific research factors in choosing a model there are three major concerns the particular model that in this paper that have will be de it is difficult at best to characterize since depends so on the changing nature of the state for example in a process pv system are only able to prove that one or the other will run for ever while under a reasonable fair scheduler we would expect both to run forever by providing a model with a scheduler we can characterize the scheduler in such a way that schedules can be avoided thus we will replace the oracle by a scheduler which has to the state of the system when t selects a particular pro to be run as well as producing a new scheduler to schedule the next process by modify ing internal variables or queues we want to model situations where one pro may arbitrarily start stop or otherwise con another process s the model contains a m which may be viewed as a vector of processes the scheduler specifies a process to be run by an integer index into m there is no way to easily characterize those processes which are blocked if tion is modeled aa waiting in actual sys we expect to have two functions first to schedule processes which can run and second to not schedule those which cannot thus following we describe the code of an individual process as a labelled flowchart where each box of the flowchart is called an ep elementary is process and executed an entity which an ep consists of three parts the first of which represents a if the scheduler schedules a process and the synchronization condition of its current ep is not met no action is taken and the scheduler is simply invoked to schedule again if the condition is met the other two parts of the ep are executed one part the data state s f the sys tem and one part changes the control state m of the system specifying the label of the next ep of the current process or starting or one special process otherwise label is controlling stop and another denotes the process end of a so evaluation proceeds in the following first the scheduler produces an index into as well as a new scheduler to the next iteration if the label indexed then no further action is taken for way the schedule is this iteration otherwise the labelled ep is executed first its synchronization condition is tested if false no further action takes place with the ep if true though the rest of the ep is evaluated to update both the data state s and the m the formal model primitive domains tt truth values n natural numbers label labels including arg function argument name names of functions s states the element stop constructed domains name x args name x args name x args ep x x m n label x args args arg we will indicate the least defined element of this domain as rather than uu if we know that an element of arg contains a particular fixed number of args we will use tuple notation eg abc rather than a b c where t is the string tion operator the scheduler primitive functions n name args s args s s args args m m label args ep note and map formal represent names into the functions they maps a label into a class of a particular one is selected by args the interpreter next let be in stop let s m be m in s m note that a x b and ab of type ab then we use ab a and ab b the projections of ab onto its a and b respect ab ab is to indicate components action note given an index and a ep selected to run n produced by the m action produces the exec let be in name s let be s in s note given the current state of the system s and m exec produces the new state when the scheduler has selected process n to run the reader is tc look to the applications section for an example of how a par system would be modelled in this model as in actual systems it is not so clear when computation stops for example an idle process may run in an operating system when nothing can otherwise be scheduled however for simplicity we will a continuous predicate index could for example if the scheduler returns when there is nothing to schedule define as a zero then we sm o in any case we can define the result final state of running mo with state so and scheduler as where is defined as s properties of treatment of in this paper will be independent of any particular synchronization eg pv and any par implementation or internal structure of the scheduler eg fifo queues priority order er we simply express a number scheduler proper using the model the properties described are either ones that will be used later in the paper or ones that have appeared already in the ture a comparison of these properties by example can be found in the applications section of this paper the properties as described are dependent on s and m as well as the scheduler where as commonly we are simply interested in a property of a scheduler independent of what it schedules the last section be dealt with of this paper notes how this can notes we will be using process j to indicate the behavior of the contents of mj we use the notation than also strong equivalence to mean less defined a z b iff strictly less defined than a j b iff note that string domains eg arg and defined t tt sm iff s m a scheduler is full if if does not schedule an process when a process can be run m mk label stop ff let syn be syn args s in j ks j i nv s m v full iff vj sm tt sm a scheduler is a release scheduler if when some action a set of processes then some process from that set will be the next to run let s m be tt let n be n m n in s m a sm tt s m in sm sm sm a scheduler has the ready run property when no process has to wait forever to run from the time it becomes capable of running we actually state this in the logic as any process which is unable to run at most a finite number of times must run often some thought should the reader that these are the same tj a tp p tt uu s next ready sm sm iff tt tt pointer bounded a scheduler is pointer bounded when a pro able to run infinitely often is scheduled infinitely often we will see in the application section that both and are too weak and that fairness is a more property tried ks k next sm next pointer bounded m iff sm tt o tried z tt m a scheduler is fair if any process able to run infinitely often runs infinitely often at times that it is not blocked or stop iff bk sm tt z tt we say a scheduler extension of if is an a uu a sm o b s m is an extension of this corresponds with the example definition of in the previous section it easily provable that every scheduler has an extension that sm and sm sm also sm m and similarly for fair is fairness is in general the weakest along with that we would ever demand of a actual scheduler fair ness with will be adequate for ing properties that we are interested in however proving certain properties in particular proven in the next section given the alone turns out to be somewhat difficult the key problem is knowing exactly when a particular ac tion will occur even when it ia known that it must occur eventually this problem often if the scheduler is full that to prove as well so we will a de show m it is sufficient to show that b sm m qj sm sm tt proof suppose there st were a function for any scheduler sm sm s m s now suppose sm sm but tt since tt m sm by l and full sm j tt and tt then trivially by of fair sm now let sm be an extension of then sm and tt if we can tt tt prove b then and by of fair sm we have a contradiction to sm t and therefore the original that tt must be false since it is easily shown that it must be case that tt and a follows definition of and proofs and can be found in of l applications some notion of above can be adapted from executing the loop the properties by consideration of three in the section of the example processes each i i i where the initial value of sem is we will describe execution sequence sequence of pi and vi il to denote of a p or v by the ith process as a the under a scheduler that is merely defined full the execution could simply be and pl v pl vi pl v pl vi that is processes and might never execute if the scheduler is additionally scheduler the execution could be a release pl v p v pl vt p v p v that is vi p of process and v pl but again process might never be executed if the scheduler additionally has the ready run property it helps not at all since process is never capable of running it is blocked each time process or executes a p likewise the property does not help since process might only be tried when it is blocked if the scheduler though is merely defined and fair each of pl p p vi v and v must infinitely often we will prove general case where ready noted this would have difficulty that last statement for there are n processes is a problem that proving the more as al to simplify is ing functions we will assume that sem and we will define the state s the follow args s tt s s s o s m lk kn mk introducing some notation we use cf ca when do to represent the ep where the where eliminate notation ep is the result sta or ca are parentheses as of no arguments well we further we use the n for note function names in lower from the domain upper case definitions like go have their case the formal name eg go name is the same name written in so the parallel system described above has two labels p and v and its formal de for n concurrent processes is p v when do k v when true do set k p lk stop u so range k p where k a k n now the problem prove can be stated in the as tt also prove by the results of the previous section assume that and so a tt we can simply proof so range k n s tt sm k sm sm lemma defined a be k defined a sm proof math ind on k in lemma k s k proof parallel comp ind and on lemma de so so i let sm be k be kl j be in range i n m a a i j m proof math ind on k using the system definitions in the applications section and lemma lemma tt the proof of the theorem lemmas and a follows directly from we can also state though we will not prove the mutual exclusion problem as jk mk label v deadlock briefly in the logic we can state some deadlock based on the model properties a process is dijkstra if it is not and is of running sm stop or m iff sm sm the system is dead locked if some process becomes sm sm iff safe sm we are often interested re of the scheduler whether or not a particular set of processes can ever lead to deadlock if not the system is safe yet we cannot ignore the scheduler completely as can lead to behavior as we noted in an earlier section we take as a minimal requirement that the scheduler be fair and defined safe sm iff defined sm a m a s tt section clearly is safe the pv system of the previous of course it is in general undecidable er or not is safe even in simple systems such as pv with conditionals and even knowing that under a particular fair full defined scheduler deadlock cannot occur consider s composed of a semaphore sem init o integers k and n initially o and f a description of a total function of type n it and m be running described by the two processes informally process k o n o loop if n then n n process k loop if k o then now under a scheduler that runs process first the eventual value of k will be o and there will never be deadlock but if process runs first k will be and determining becomes equivalent to deciding whether f is true infinitely often which is reducible to the halting problem modelling protection systems in the model presented each process operates on a common memory state s yet in programming systems different processes do have different ac rules for accessing the memory eg frames virtual or local name spaces and execution domains by passing the ep its slot as an argument differential accessing of s can easily be achieved for example if s n domain then if p is executing in slot k sk could represent its execution domain it would also be useful though for each pro to execute its own program set of labels rather than having a monolithic primitive function such a change is rather simple m s m n prog x label x args prog label args ep and action to be m mn prog mn label mn args all have to previous results change the definition section to be hold although of go in we would the ap m xk kn mn now the modelling of a operating system with this modification process js data segments would be part of s whereas its code segment would be modeled directly by the prog component of mj we could then model the start ing of a new program by the ep when tr do where s returns as its result the contents of segment set in state a and o up those contents and begins executing the process m start begin x into prog form with an interesting is that one can model a process changing a data segment of another pro possible in systems with shared data by us ing a whereas a change in an executing code segment most likely a bug can only be modeled by using a like in fact in this modified model just such a bug was discovered in sys tem the bug in can be by the use of frozen pages see a frozen code page is protected against modification other useful for protection results small changes in the model make describing and proving properties systems will report it more about further a induction rule we will often want to prove a s tt more difficult conditions than in the ex of the applications section the following induction principle which is a generalization of the principle applied in proving that example would be useful to prove suppose that w is a wellfounded set with a set of least elements wo and that p w x n s x m tt and closer total then to prove a it is sufficient to prove a qj sd q b wo wo js m c m j d w t wo pw js m pw a ww pw j j sm which either which from some able says that whatever state the system is in j can run or if j cannot run no matter process is scheduled j is no away being able to run and in fact there is always process that j closer to being to run for the proof in the applications section let w r n and wo under the order ing i i n let p js m s a mk label range k n p stop and pi js stop m s o a ki v p and closer i j i then it is relatively trivial to prove that a b p i c p p d pi js m a p pi m which is easily seen to satisfy the induction pred to simplify tion the system proofs it may we would have be useful to define to no tion of an independent partition and then prove that if ml mj of m under s then was an independent partition a note on scheduler properties as noted in an earlier section scheduler properties depend on s and m as well as completely since future determined behavior by the of the initial system system is all we need do is allow the scheduler to be made to the initial configuration suppose that we demand that in the initial of the system n j and call this property to the initial the use number of n of an upper processes bound allows us to define a recursive scheduler prototype n x s x m and a scheduler n x s x m we say that is fair if and similarly for other properties conclusion well we have introduced a semantic model for systems and have presented a number of of parallel systems based on the model as some proofs and proof rules as the development with the most potential ap to be the induction rule based on well sets as note proofs force the program prover to sometimes all the possible states of the system to make proofs of complex parallel programs more tractable and especially to make the proofs more amenable to automatic tion it seems clear that some elegant embedded or imposed structure is critical well sets may be a useful structure for proofs of deadlock for other properties of parallel programs further exploration is necessary a somewhat serious of the scheduler model and other models as well is its to model time dependent behavior for example interrupts in programming systems and timing considerations in machine architecture while the nature of problems to be studied with respect to time dependencies would likely call for a different model in any proving the correctness of something like a for a would likely require a scheduler model in some way to handle time dependencies perhaps the most serious problem with the model described here is in the nature of the tions made about how processes interact or should interact a formal semantics for a sequential programming language with structured control pro a better base for various proofs than a se for a language with similarly restricted interactions between processes should provide a better semantic system than the one described here in which arbitrary interactions are allowed a solution is to provide additional axioms which restrict the possible schedules pv disciplines are too work along the lines of path expressions appear basis to be more promising in which proofs will in providing a semantic be less tedious acknowledgments paper tions i want to express my thanks to for their careful and for their comments and of this and j j able proofs about parallel processes w symp on switching theory and automata october the specification of by path express ions symp on operating system theory april r h a n process synch proc int and practice systems e lu tech semantic report lu phd thesis e modelling models december for parallel protection systems dijkstra strategies dijkstra e a bounded class delay of allocation only kahn kahn programs g a preliminary report theory january for r on synchronization tive systems ph d thesis june or see proc th annual sym p on the theory of computing may manna fixpoint approach cacm vol no manna to the z j theory of computation milner milner of simulation rj between lan algebraic programs definition milner milner tion of proc of a conf programs january r implementation logic for computable on proving assertions and functions about milner milner r and r proving logic compiler machine correctness intelligence in a mechanized integers stanford m axioms lists and finite aim january and theorems for sets in keep mit phd february l making computers thesis mac tr scott grams languages mathematics scott d the lattice of flow symp on semantics of algorithmic springer verlag lecture notes scott scott d programming language mathematical semantic concepts in scott scott d toward a mathematical languages oxford university c for computer computing lab 