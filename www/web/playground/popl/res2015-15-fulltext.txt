well easy to manifest contracts for datatypes popl consist complete school of university school of university school of university abstract we study algebraic datatypes in a manifest contract system a software contract system where contract information occurs as refinement types we first compare two simple approaches refinements on type constructors and refinements on data constructors for example lists of positive integers can be described by l int list for all yy l in the former whereas by a userdefined datatype pos list with cons of type x int x × pos list pos list in the latter the two approaches are complementary the former makes it easier for a programmer to write types and the latter enables more efficient contract checking to take the best of both worlds we propose a syntactic translation from refinements on type constructors to equivalent refinements on data constructors and dynamically checked casts between different but compatible datatypes such as int list and pos list we define a manifest contract calculus to formalize the semantics of the casts and prove that the translation is correct categories and subject descriptors d programming languages formal definitions and theory d programming languages language constructs and types and structures d software engineering by contracts general terms languages design theory keywords algebraic datatypes datatype translation contract checking refinement types introduction background software contracts software contracts are a tool to develop robust software contracts allow programmers to write specifications in the same programming language as that used to write programs making it possible to check such specifications at run time they are provided as libraries or primitive constructs in various practical programming languages for example the c language provides the assert macro to check at run time that a given boolean expression evaluates to true and the language provides a construct to specify and check pre and postconditions of methods permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january ­ copyright is held by the publication to acm acm and class invariants is a representative functional language with higherorder contracts based on the work by findler and felleisen although contracts were originally as a mechanism to check software properties dynamically it was also clear that contract checking could cause significant overhead for various reasons and that it would be desirable to find contract violations earlier than run time a lot of research has been to address these problems for example and flanagan and siek and wadler address the problem that inserting contract checking can tail calls into calls findler and introduce lazy contract checking to address the problem that naive contract checking for datatypes can make asymptotic time complexity worse and there is a lot of work on static of contracts to find out statically which contract checking always succeeds in order to eliminate such successful contract checking for optimization the last line of work is also closely related to static refinement checking in this paper we the problem of contract checking on datatypes especially in the context of manifest contracts manifest contracts and two approaches to datatypes in a manifest contract system unlike more traditional latent by pierce and weirich contract systems contract information occurs as refinement types of the form x t e this form of type denotes the subset of values v of type t satisfying the boolean expression e namely e v x reduces to true for example x int x denotes positive integers refinement types can be introduced by using casts which involve runtime checking a cast t s means that when applied to a value of the source type s it is checked that the value can behave as a value of the target type t for example the cast application x int x int succeeds after returns true and returns if a cast fails an exception will be raised with the label to identify which cast has failed computational calculi of manifest contracts have been studied as theoretical frameworks for hybrid contract checking in which contract checking is performed both statically and dynamically the idea behind hybrid contract checking is to check for each cast t s whether it is an or equivalently s is a subtype of t are proved to be contextually equivalent to the identity functions and so safe to be eliminated the other casts are still subject to runtime check there are two approaches to specifying contracts for data structures one is to put refinements on the type constructor for a plain data structure and the other is to put refinements on types for data constructors for example a type for sorted integer lists can be written x int list sorted x in which sorted is a familiar boolean function that returns whether the argument list is sorted in the former or defined as another datatype with refined cons of type x int × nil xs or x head xs in the latter here the argument type is a dependent product type expressing the relationship between the two components in the pair however as pointed out by findler and neither approach by itself is very satisfactory on the one hand the former approach which is easier for ordinary programmers may cause significant overhead in contract checking to make asymptotic time complexity worse to see how it happens let us consider function for insertion sort the sorting function and its auxiliary function insert can be defined in the mllike syntax as follows type xint list sorted x let rec insert xint match l with int list x if x y then int list x l else int list y insert x int list ys let rec list match l with insert x xs without casts would be an ordinary function however in insert the four subexpressions x xl x ys and ys which are given type int list are actually expected to have type by the context to fill the gap we have to check whether these subexpressions satisfy the contract sorted notice that these casts cannot be eliminated by simple subtype checking because int list is obviously not a subtype of as far as we understand existing cannot verify these casts will be successful at least without giving to the verifier unfortunately leaving these casts especially ones with and has an effect they traverse the entire lists to check even though the lists have already been sorted making the asymptotic time complexity of insert from om to om where m stands for the length of the input on the other hand the latter approach which exploits refinement in argument types of data constructors does not have this efficiency problem if not always for example we can define sorted lists as a datatype with refined constructors type of xint × nil xs or x head xs here nil and head are functions that return whether a given list is empty and the first element of a given list respectively and a type of the form x t × t is a dependent product type which denotes pairs v v of values such that v and v are of types t and t v x respectively so takes an integer x and a sorted list whose head if any is equal to or greater than x using we can modify the functions insert and to perform less dynamic checking let rec insert xint actually there are subexpressions whose expected types are int list but actual types are we assume that can be converted to int list for free precisely speaking these functions have to be defined together with but we omit them for brevity match l with x y ys if x y then x l else y insert x ys let rec list match l with insert x xs here stands for nil xs or e head xs since the contract in the cast does not traverse xs it is more efficient than the first definition in fact the time complexity of insert remains to be om moreover it would be possible to eliminate the cast on l by collecting conditions l is equal to ys and x y this branch it is more difficult to eliminate the other cast because the verifier would have to know that the head of the list returned by the recursive call to insert is greater than y however this approach has complementary problems first we have to maintain the predicate function sorted and the corresponding type definition separately second it may not be a trivial task to write down the specification as data constructor refinement for example consider the type of lists whose elements contain a given integer n a refinement type of such lists can be written list member n l using the familiar member function one possible datatype definition corresponding to the refinement type above would be given by using an auxiliary datatype parameterized over an integer n and a boolean flag p to represent whether n has to appear in a list type of p of xint × xn and p n type n notice that is essentially int list and if a list without n is given type n then p must be false we do not think it is as easy to come up with a datatype definition like this as the refinement type above another issue is between a plain type and its refined versions just as casts between and int list are allowed we would hope that the language supports casts between and int list even when they have different sets of data constructors such is crucial for code reuse without it we must many functions such as sort member map etc every time a refined datatype is given as pointed out in and jhala one can give one generic datatype definition which is parameterized over predicates on components of the datatype and instantiate it to obtain plain and sorted list types but as we will show later refined datatype definitions may naturally come with more data constructors than the plain one in which case would not work the number of constructors is the same for every instantiation in short the two approaches are complementary our contributions our work aims at taking the best of both worlds first we give a provably correct syntactic translation from refinements on type constructors such as the boolean function sorted to equivalent type definitions where data constructors are refined namely this translation is closely related to the work by and and also concerned about systematic generation of a new datatype see section for comparison second we extend casts so that casts between similar but different datatypes what we call compatible types which are declared explicitly in datatype definitions are possible for example int list yields whereas int list raises blame thanks to the two ideas a programmer can automatically derive a datatype definition from a familiar boolean function exploit the resulting datatype for less dynamic checking as we saw in the example of insertion sort and also use it when necessary as if it were a refinement type using the boolean function we formalize these ideas as a manifest contract calculus and prove basic properties such as subject reduction and progress we follow the existing approach by et al to defining a manifest calculus without subtyping but improve it by modifying the semantics of casts slightly and simplifying the type equivalence relation these changes play a crucial role in proving subject reduction and other semantic properties such as parametricity we also give a first syntactic proof of the property that if a program is given a refinement type x t e and it results in a value v then v satisfies the predicate e in the context of manifest calculi this property was proved by using semantic methods in the literature a syntactic proof would have been possible for a polymorphic manifest calculus fh but the metatheory of fh depends on a few which unfortunately turned out to be false recently personal communication our contributions are summarized as follows · we propose casts between compatible datatypes to among a plain datatype and its refined versions · we define a manifest contract calculus to formalize the semantics of the casts · we formally define a translation from refinements on type constructors to type definitions where data constructors are refined and prove the translation is correct we also have a implementation of on top of ocaml and and it is available at a full version with proofs is also found there we note that this work gives type translation but does not give translation from a program with refinement types to one with refined datatypes so if a programmer has a program with for example then he has to rewrite it to one with a datatype like by hand automatic program transformation is left as future work the rest of the paper is organized as follows section gives an overview of our datatype mechanism and section formalizes and shows its type soundness then section gives a translation from refinement types to datatypes and proves its correctness we discuss related work in section and conclude in section overview in this section we informally describe our proposals of datatype definitions casts between compatible datatypes and translation mainly by means of examples as we have seen already in the example of sorted lists our datatype definition allows the argument types of data constructors to be refined using the set notation x t e and dependent product types x t × t we also allow over terms as in in the previous section casts for datatypes as we have discussed in the introduction in order to between refined datatypes we allow casts between two different datatypes if they are compatible in other words compatibility is used to casts between types for example the integer type and a function type compatibility for types other than datatypes means that two types are the same by ignoring refinements compatibility for datatypes means that there is a correspondence between the sets of the data constructors from two datatypes and the argument types of the corresponding constructors are also compatible in our proposal a correspondence between constructors has to be explicitly declared so the type in the previous section is actually written as follows type of xint × nil xs or x head xs the symbol followed by a data constructor from an existing datatype declares how constructors correspond the types int list and are compatible because both and take no arguments and the argument type xint × nil xs or x head xs of is compatible with int × int list of precisely speaking compatibility is defined readers may think that explicit declaration of a correspondence of data constructors seems however we could replace these declarations by a compatibility declaration for type names as int list and let the system infer the correspondence between data constructors such inference is easy for many cases where the argument types of data constructors are of different shapes as in this example a cast for datatypes converts data constructors to the corresponding ones and puts a new cast on components for example int list reduces to as follows int list int × nil xs or x head xs int × int list nil xs or head xs int list in the example above the correspondence between data constructors is but we actually allow correspondence too this means that a new datatype can have two or more or even no data constructors corresponding to a single data constructor from an existing type for example an alternative definition of is as follows type of × int list of × this version of has no constructors compatible to nil because the empty list does not include n by contrast there are two constructors and both compatible to the constructor is used to construct lists where the head is equal to n and to construct lists where the head is not equal to n but the tail list includes n a cast to the new version of works by choosing either or depending on the head of the input list list including int list list including int list this cast does not have to traverse a given list when it succeeds notice int list in the argument type of and in the second example above although it is fairly clear how to choose an appropriate constructor in the example above it may not be as easy in general in the formal semantics we give in this paper we model these choices as in practice a constructor choice function is specified along with a datatype definition either manually or often fact we will show that a constructor choice function can be systematically derived when a new datatype is generated from our translation more interestingly the asymptotic time complexity of the cast from a plain list to the generated datatype is no worse than the cast to the original refinement type in this sense the translation preserves efficiency of casts this efficiency preservation lets us conjecture that when a programmer rewrites a program with the refinement type to one with the generated datatype the asymptotic time complexity of the latter program becomes no worse than the former we discuss efficiency preservation in detail in section allowing correspondence between constructors simplifies our translation and makes dynamic contract checking more efficient as in the example above ideas for translation we informally describe the ideas behind our translation through the example of list including above we start with the refinement type x int list member n x where member n x is a usual function which returns whether n appears in list x let rec member list match l with false if x n then true else member n xs through this paper we always suppose that some logical operations such as and are to simplify our formalization and so here we write if x n then true else member n xs instead of x n member n xs we examine how list including corresponds to member for reference the definition of list including is shown below again type of × int list of × we expect that a value of list returns true when it is passed to member n modulo constructor names it is not difficult to observe two things first each constructor and its argument type represent when the predicate returns true in this example there are two reasons that member n x returns true either n is equal to the first element of x or n is not equal to the first element of x but member n is true for the tail of x the constructors and and their argument types represent these conditions since member n x never returns true when x is the empty list there is no constructor in list including second a recursive call on a corresponds to typelevel recursion member n xs in the in member is represented by list in the argument type of so the basic idea of our translation scheme is to analyze the body of a given predicate function and collect conditions on branches reaching true as mentioned above recursive calls on the tail become typelevel recursion this correspondence between execution paths and data constructors is also useful to derive a constructor choice function for a cast for example a cast to list will choose when the list being types t bool x t t x t × t x t e e constants values terms c true false v c fix f x tt e t t v v c ev e c x fix f x tt e e e e e e e c ee match e with ci xi ei i if e then e else e t t datatype definitions x t ci ti i x t ci di i ti figure program syntax the definition of the parameter name and its type of the set of constructors that belong to the type specification of c the data type that c belongs to the argument type of c table lookup functions checked is not empty and the head is equal to n just because corresponds to the path guarded by xn in the definition of member a manifest contract calculus we formalize a manifest contract calculus of datatypes with its syntax type system and operational semantics and prove its type soundness following et al we drop subtyping and subsumption from the core of the calculus to simplify the definition and metatheory in the following we write a sequence with an for example ci i n means a sequence c cn of data constructors we often omit the index set n when it is clear from the context or not important given a binary relation r the relation r denotes the reflexive transitive closure of r syntax we present the program syntax of in figure where there are various metavariables t ranges over types names of datatypes c and d constructors c constants x y z f etc variables v values e terms blame labels typing contexts datatype definitions type definition environments types consist of base types we have only boolean here but addition of other base types causes no problems dependent function types dependent product types refinement types and datatypes in a dependent function type x t t and a dependent product type x t × t variable x is bound in t a refinement type x t e in which x is bound in e denotes the subset of type t whose value v satisfies the boolean contract e that is e v x evaluates to true finally a datatype e takes the form of an application of to a term e note that unlike some refinement type systems which aim at decidable static verification the predicate e is allowed to be an arbitrary boolean expression which may diverge or raise blame as we will see soon however no computation is involved with typing rules for source programs and it is easy to show decidability of typing for source programs in fact two types with different predicates such as x int x and x int x are always distinguished and a cast is required to convert from one type to the other static verification amounts to checking a given cast is in fact an where the source type is a subtype of the target and subtyping is not in general decidable but the language is not equipped with subsumption terms are basically those from the calculus with booleans recursive functions products datatypes and casts a term fix f x tt e represents a recursive function in which vari ables x and f denote an argument and the function itself and are bound in e we often omit type annotations a data constructor application c ee takes two arguments e rep one for the type definition and e for data constructors respectively a match expression match e with ci xi ei i is as usual and binds each variable xi in ei the last form is a cast t t consisting of a target type t a source type t and a label and when applied to a value v of type t checks that the value v can behave as t the label is used to identify the cast when it is a datatype definition can take two forms the form x t ci ti i where x is bound in ti i declares a datatype over x of type t with data constructors ci whose argument types are ti the other form x t ci di i ti is the same except that it declares that ci is compatible with di from another datatype a type definition environment is a sequence of datatype we assume that datatype and constructor names declared in a type definition environment are distinct table shows tions to look up information on datatype definitions their tions are omitted since they are straightforward a type specification returned by and written x t t x of a constructor c consists of the datatype that c belongs to the pa x of and the type t of x and the argument type t of c in other and t x t the subscript from these for brevity if it is clear from the context we use the following familiar notations we write fv e to denote the set of free variables in a term e and e e x capture avoiding substitution of e for x in e we apply similar notations to values and types we say that a is closed if it has no free variables and identify equivalent ones in addition we introduce several a function type t t means x t t where the variable x does not occur free in t we write x te to denote fix f x tt e if f does not occur in the term e a let x e in e denotes x t e e where t is an appropriate type finally a datatype is said to be monomorphic if the definition of does not refer to a type argument variable and then we abbreviate e to type system this section introduces a type system for source programs in later we extend the syntax to include runtime terms to define operational semantics and give additional typing rules for those terms the type system consists of three judgments context wellformedness type wellformedness t and typing e t here a typing context is a sequence of variable declarations x t where declared variables are pairwise distinct we show inference rules in figure where a type definition environment in judgments are omitted for simplification typing rules for atomic terms such as booleans variables etc demand that types of a typing context of a judgment be wellformed in other rules wellformedness of a typing context and a type of a term is shown as a derived property inference rules for context and type wellformedness judgments are standard except for wt datatype which requires an argument to a datatype to be typed at the declared argument type most of typing rules are also standard or similar to the previous work the rule t cast means that the source and target types in a cast have to be compatible intuitively two types are compatible when a cast from one type to the other may succeed more formally type compatibility written t t is the least congruence satisfying rules in the bottom of figure the rule c allows casts from and to refinement types and the rule c datatype says that if datatypes are declared to be compatible in the type definition then they are compatible the typing rule t ctr demands that arguments e and e respect the argument types of c and the datatype that c belongs to respectively the rule t match for match expressions demands the matched term e to be typed at a datatype e using the the rule demands that the patterns ci xi i be exhaustive moreover each branch ei has to be given the same type t which cannot contain pattern variables xi and so is well formed under semantics two rep basic computation such as reduction and the evaluation relation in which a subexpression is reduced the semantics is parameterized by a type definition ment and a constructor choice function which is a partial function that maps a term of the form e e to a constructor c we introduce this function as an oracle to decide which constructor a given constructor is converted to by a cast be datatypes as discussed in section the constructor c has to not only belong to but also be compatible with c we will give a more precise condition on later precisely speaking the two relations are parameterized by and but we fix certain and in what follows and usually omit them from relations and judgments before reduction and evaluation rules we introduce several run time terms to express dynamic contract checking in the semantics these runtime terms are assumed not to appear in a source pro gram or datatype definitions the syntax is extended as below e x t e e v x t e e the term denotes a cast failure which identifies which cast failed an active check x t e e v verifies that the value v of type t satisfies the contract e the term e represents an intermediate state of a check which starts by reducing e v x if the check succeeds namely e reduces to true then the active check evaluates to v otherwise if e reduces to false then it is with a waiting check x t e e which appears when an application of a cast to a refinement type is reduced checks that the value of e satisfies e waiting checks are introduced to avoid a technical problem recently found in et al we will discuss it in more detail at the end of this section figure shows reduction and evaluation rules reduction rules are standard except for those about casts and checks there are six reduction rules for casts the rule r base means that a cast between the same base type simply behaves like an identity function the rule r fun which shows that casts between function types behave like function contracts produces a lambda abstraction which the value v with the contravariant cast t t between the argument types and the covariant cast t t between the return types to avoid capture of the bound variable of t we take a fresh variable y and rename typing context wellformedness rules wc empty t x t wc t type wellformedness rules bool wt base t x x t t t t wt fun t x t x t × t t wt prod t x t e x t e bool wt refine x t e e t wt datatype e t typing rules c true false c bool t const x t x t t var f x t t x t fix f x tt e e t f x t fv t t t abs t t t t t t t t t cast e x t t e e e t e x t t app x t t e t e e e x t × t t e x t pair e x t × t e t t proj e e x t × t t e x t proj e bool e t if e then e else e t e t t if c e t e tx x e c ee e t ctr e for e all i t ci ti i ci for all n i xi ti e y ei t match e with ci xi ei i n t yt t match t t type compatibility t t x t e t c type x t ci di ti i e e for all i di c datatype figure type system variable x in t to it similar renaming is performed in r prod the rule r prod means that elements v and v are checked by covariant casts obtained by the source and target types the rules r and r are applied when source and target types of a cast are refinement types respectively the rule r the outermost refinement of the source type and the rule r means that inner refinements in the target type are first checked and then the outermost one is the side condition in r are needed to make the semantics deterministic for example the term x int x x int x v reduces to x int x int int v by applying first r and then r a waiting check turns into an active check when its second argument becomes a value r check there are three rules r datatype r and r for datatype casts the rule r datatype is applied when the choice function gives the constructor c then the original constructor argument v is passed to a cast between the argument types of c and c here note that e and e are substituted for variables x and x in the argument types of c and c respectively because these types depend on these variables the rule r is similar to r base the rule r says that if the choice function is undefined for the cast the cast application is with the last three rules r check r ok and r fail follow the intuitive meaning of active checks explained above evaluation rules are also shown in figure here evaluation contexts ranged over by e are defined as usual e e e v e e e v e e e c ee match e with ci xi ei i if e then e else e x t e e v x t e e the rule e red means that evaluation proceeds by reducing the redex indicated by an evaluation context the rule e blame means that a raised blame will abort program execution type soundness we show type soundness of as usual type soundness means that a welltyped term does not go wrong and is proved via subject reduction and progress moreover we will show that if a term is given a refinement type its value if it exists satisfies the contract this last property which was proved by using semantic methods is proved purely syntactically for the first time before stating the type soundness theorem we start with extending the type system to runtime terms and define wellformedness of type definition environments and constructor choice functions typing for runtime terms typing rules for runtime terms are shown in figure the rule t blame means that a blame can have any type because it is an exception in the rule t for an active check x t e e v the last premise e v x e means that e is an intermediate state of checking which started from e e reduction rules fix f x tt e v e v x fix f x tt e f v v v r proj if true then e else e e v v v r proj if false then e else e e r beta r r match cj ev with ci xi i ei ej v xj where cj i ci r match bool bool v v r base x t t x t t v x y t t x in t t y x v y where y is fresh r fun x t × t x t × t v v let x t t v in x t t v x v r prod t x t e v t t v r x t e t v x t e t t v r where t is not a refinement type e e e x t e x v r datatype where or is not monomorphic and e e c and i xi ti and ci ti for i v v r e e v r where or is not monomorphic and e e v is undefined x t e v x t e e v x v r check x t e true v v r ok x t e false v r fail e e evaluation rules e e e e e e e red e e e blame figure semantics e t t t t blame x t e bool x t e e v v t x e x t e t x t e x t e e e t x t e t x t e v t e t t t e t t t v x t v t e t e v x true v x t e t exact figure typing rules for runtime terms e v x this reference to the semantics in the typing rule is un usual but is important in et als syntactic approach the rule t for a waiting check is easy to understand the rule t is needed because r off the refinements in the source type of a cast the rule t exact allows a value which succeeds in dynamic checking to be typed at a refinement type finally t of the approach by et introduced as a technical device to prove subject reduction to see why this rule is required let us consider an application term v e from t app the type of v e is t e x for some t and x if to type of the application term changes x t e x in general subject reduction would not hold the rule t the gap by allowing a term to be typed at another but equivalent type the type equivalence denoted by is given as follows definition type equivalence the common subexpression reduction relation over types is defined as follows t t iff there exist some t x e and e such that t t e x and t t e x and e e the type equivalence is the symmetric transitive closure of the type equivalence given here relates fewer terms than that by et al but is sufficient to prove subject reduction the fact that typing contexts in premises are empty reflects that runtime terms are closed however they can appear under binders as part of types notice term substitution in the typing rules and so weakening is needed wellformed type definition environments intuitively a type definition environment is well formed when the parameter type is well formed constructor argument types are well formed and the argument types of compatible constructors are compatible definition wellformed type definition environments let x t ci ti i n a type definition is well formed under a type definition environment if it satisfies the a n b t holds c for any i n x t ti holds let x t ci di i n ti a type definition is well formed under a type definition environment if it satisfies the a n b t holds c for any i n x t ti holds d there exists some datatype in such that constructors di i n belong to it e for any i n ti is compatible with the argument type of di under that is ti holds a type definition environment is well formed if for any and implies that is well formed under we write to denote that is well formed intuitively a constructor choice function is well formed when it returns a constructor related by in type definitions and respects term equivalence which is defined similarly to type equivalence definition compatible constructors the compatibility relation over constructors is the least equivalence relation satisfying the following rule ci type yt cj dj j tj ci di the function which maps a datatype and a constructor c to the set of compatible constructors of is defined as follows c d c d and d definition term equivalence the common subexpression reduction relation over terms is defined as and e such e follows that e e e e iff there exist e e x and e some e e e x x e and the term equivalence is the symmetric transitive closure of definition wellformed constructor choice functions a constructor choice function is well formed iff if c e e then c c and for any e e and c if e e and e c then e c we suppose that the type definition environment and the choice function are well formed in what follows lemma subject reduction if e t and e e then e t lemma progress if e t then one of the holds e e for some e e is a value or e for some to show the additional property mentioned above about refinement types we need to show that the term equivalence respects the semantics in the following sense lemma suppose e e if e v then there exist some v such that e v and v v if e v then there exist some v such that e v and v v theorem type soundness if e t then one of the holds there exists v such that e v and v t e for some or there is an infinite sequence of evaluation e e moreover if t is a refinement type x t e and holds then e v x true proof ­ follow from subject reduction and progress for the additional property it suffices to show that if v t then v satisfies all contracts of type t we proceed by induction on the derivation of v t in the case of t we use lemma and the fact that for any v if v true or true v then v true remark on semantics of casts as we have mentioned our semantics of casts for nested refinement types is slightly different from the one for fh in the following respects first they had a rule to remove reflexive casts t t v v for any type including function and refinement types and a rule to start an active check x t e t v x t e e v x v second they define type equivalence based on parallel reduction they also left the property as a conjecture however with these rules does not quite hold consider e x bool y x bool false v then e false y e y and e false y v by removing the reflexive cast but e y x bool v which is a counterexample to it is easy to construct a similar counterexample using the second rule above this is quite bad because the property is quite important to show semantic properties such as of theorem or parametricity for fh the problem seems to from the fact that reduction of a subterm in this case can change the cast rule to be applied our calculus is carefully designed to avoid this problem by restricting reflexive casts r base and r and introducing waiting checks the price we pay is that we have to prove that reflexive casts can be eliminated translation from refinement types to datatypes we give a translation from refinement types to datatypes and prove that the datatype obtained by the translation has the same meaning as the refinement type in the sense that a cast from the refinement type to the datatype always succeeds and vice versa we formalize our translation and prove its correctness using integer lists for simplicity and but our translation scheme can be generalized to other datatypes we will informally discuss a more general case of binary trees later in this section we assume that we have unit and int as base types and int list with and infix cons x y as constructors for note that replacing based on parallel reduction with one based on common subexpression reduction would not help we should also note that subject reduction and progress of fh still hold because they do not depend on true none true false if f e z then e else e if e then e else e some e e if f e z then false else e e if e fv e y z if if e e then then e e e e if a term of the form f e z occurs in e or e match e with ci xi i ei n j n j ei false if a term of the form f e z occurs in some ei e none e otherwise figure generation of base contracts and arguments to recursive calls trans input fix f yt x int list match x with e z z e returns let be a fresh type name in let ti i × zt e e e t e aux e in let d and di i be fresh constructor names and z be a fresh variable in type yt d z unit e di i ti where aux e let e e fix f yt x int list f in match with some e e let z int list e z in e none int list e figure translation simplicity we also assume that the input predicate function is well typed and of the following form fix f yt x int list match x with e z z e where x fv e fv e we will use sorted as a running example for reasons the definition is slightly the nested if expression at the end is essentially z y sorted z let rec sorted xint list match x with true z z e where match z with true if z y then if sorted z then true else false else false translation formally we show the translation function trans in figure and the auxiliary function in figure the main function trans takes a recursive function as an input and returns a corresponding datatype definition on line on line information on how e which is the contract for can evaluate to true is by the auxiliary function in the definition variables f y z and z come from the input function and are fixed names this function takes an expression as an input and returns a set of pairs e each of which expresses one execution path that returns true in e e is derived from e by substituting false for all but one path and is the first argument to a recursive call if any on this path intuitively conjunction of e and f z gives one sufficient condition for e to be true and disjunction of the pairs in the returned set is logically equivalent to e for example returns a set consisting of none e where e is match z with true y ys false and some e where e is match z with false y ys if z y then true else false gray bits show differences from the first expression means that a nonempty list x is sorted when the tail is empty and the second means that x is sorted when the head z is equal to or smaller than the second element y and the recursive call sorted z returns true performs a kind of disjunctive normal form translation and each disjunct will correspond to a data constructor in the generated datatype now let us take a look at the definition of the first two clauses are trivial if the expression is true then it returns the trivial contract and if it is false then this branch should not be taken and hence the empty sequence is returned the third clause deals with a conditional on a recursive call f e z on the tail in this case it returns some e to signal there is a designated recursive call in this branch with the additional condition e and also the condition when the recursive call returns false but e is true the following two clauses are for the other cases where the input expression is case analysis in this case from each branch recursively collects execution paths and conditional expressions by replacing other branches with false the side conditions on these clauses mean that we can stop dnf translation if there is no recursive calls on the tail and simply return the given contract as it is by calling for the last clause which deals with other forms of expressions the collected execution path information is further transformed into dependent product types with the help of another auxiliary function aux this function takes a pair e obtained by together with the new datatype name as an input and returns the base type and its refinement for the tail part if there was no recursive call on the tail in a given execution path namely none then the base type is int list and the refinement is e obtained from e by replacing other recursive occurrences of f with the function itself otherwise the base type is the new datatype applied t the first argument e to the recursive call the refinement is essentially e except a cast back to int list for example for sorted we obtain t × list e from none e and t × z let z int list z in e from some e t is a type for singleton lists which are trivially sorted and t is a type for a list where the head is equal to or less than the second element and the tail is of type which is to represent sorted lists finally we combine ti to make a complete datatype definition the translation of sorted will be type of of z int × z int list e of × z let z int list sorted t z in e although the datatype certainly represents sorted lists its type definition is different from given in section the difference comes from the fact that the case for has a case analysis one of whose branch has a recursive call while it is possible to merge the argument types for and to make a datatype it is difficult in general it is interesting future work however to investigate how to generate type definitions closer to programmers expectation correctness we prove that the translation is correct in the sense that the cast from a refinement type to the datatype obtained by the translation always succeeds and vice versa we use a metavariable f to denote the recursive function used to define the refinement type in the typing judgment and the evaluation relation we write e t and e e to make a type definition environment and a constructor choice function explicit in the typing judgment and the evaluation relation first of all the translation trans always generates a wellformed datatype definition lemma translation generates wellformed datatype let be a wellformed type definition environment f t int list bool then the type definition var is well formed under the next theorem states that a cast from a refinement type to the generated datatype always succeeds theorem from refinement types to datatypes let be a wellformed type definition environment f t int list bool be the name of the datatype trans f then there exists some computable wellformed choice function such that for any e e x int list f e x v if trans f e e then trans f e v for some v it is a bit to prove the converse because the first argument to a predicate function is always evaluated whereas a parameter to a datatype is not so the converse holds under the following termination condition on a datatype definition termination let be a type definition environment and be a constructor choice function a closed term e terminates at a value under and written as e if e v for some v we say that argument terms to datatype in any v e terminate at values c under and e and v v if for implies e theorem from datatypes to refinement types let be a wellformed type definition environment f t int list bool be the name of the datatype trans f then there exists some computable wellformed choice function such that for any e x int list f e x e v if trans f e terminates at a value e under x int list f e x and v trans f and then we expect that the termination condition would not be needed if we change the semantics to evaluate argument terms to datatypes efficiency preservation in addition to correctness of the translation we are also concerned with the following question when i rewrite my program so that it uses the generated datatype is it as efficient as the original one to answer this question we consider the asymptotic time complexity of a cast for successful inputs which we simply call the complexity of a cast and show that the complexity of a cast from int list to its refinement is the same as that of a cast from int list to the datatype obtained from its refinement here we consider only successful inputs because we are mainly interested in programs or program runs that do not raise blame where checks caused by casts are successful this efficiency preservation is obtained from theorem and the following observation as stated in theorem we can construct a computable choice function in fact the algorithm of the choice function can be read off from the proof of theorem it returns constructors of the generated datatype from the execution trace of the refinement checking moreover the orders of both the execution time of the algorithm and the size of output constructors from the algorithm are linear in the size of the input execution trace which is proportional to the execution time of the refinement checking thus the asymptotic time of computation of the constructors and constructor replacement are no worse than that of the refinement checking from this observation we can implement the cast from int list to the generated datatype by checking the refinement given to the translation and the constructor generation and replacement described above since the complexity of the second step is the same as that of the refinement checking the of the cast from int list to a refinement type and the generated datatype are the same extension binary trees we informally describe how to extend the translation algorithm for lists to trees a kind of data structure with a data constructor which has more than one recursive part here we take binary trees as an example and show how to obtain a datatype for binary search trees from a predicate function although this section deals with only binary trees this extension can be adapted for other data structures a datatype for binary trees and a recursive predicate function which returns whether an argument binary tree is a binary search tree or not are defined as follows type bt l n of int t t we conjecture that for inputs that lead to blame the time complexity is also preserved by the translation but a proof is left for future work let rec min match t with l true n min x and and min x l and r let be a name for the new datatype the translation algorithm first calls with the sec branch of observing the predicate function we find that the body calls itself recursively for different recursive parts l and r with different auxiliary arguments and thus for binary trees looks for the first argument to each recursive call unlike for lists which stops searching for a recursive call after finding one recursive call for our running example taking the branch for constructor n for binary trees returns the singleton set some min x some x max min x and x max where we use the operator and instead of if expression for brevity of which the first two optional terms denote arguments for left and right subtrees respectively next for each element in the output from a dependent product type will be built in this case we obtain t x int × l min x × r x max min x and x max as we have seen for lists casts from e back to bt may have to be inserted finally the translation makes a datatype definition by using these type arguments and the contract for the corresponding datatype is given as follows type t sl sn of xint × x × x and x max discussion the translation algorithm works well for functions in the sense that there is no reference to the input predicate function in the generated datatype if their definitions meet the two requirements recursive calls are given the tail part of the input list and occur linearly for each execution path and free variables in arguments to recursive calls are only the argument variable y and the head variable z specifically translation works as we expect if given functions are written in the form or more generally in the primitive recursion form where the result of a recursive call is used at most once for each execution path in contrast there can remain recursive calls to an input predicate function in the generated datatype when the predicate function does not meet these requirements this happens when there is a recursive call on lists other than the tail of the input or as in the following quite artificial example when recursive calls which return true occur twice or more in one execution path let rec f list match x with true f xs and f xs or when e includes constructs as in let rec f xint list match x with true zz let z y in f z z in these cases generation of a datatype itself succeeds but the obtained datatype is probably not what we expect because f is not eliminated although our translation works well for many predicates there is a lot of room to improve first the current translation algorithm could generate a datatype with too many constructors even if some of them can be merged for example we demonstrated that the translation generated a datatype with three constructors from predicate function sorted but we can give a datatype with only two constructors for it as shown in section second our translation algorithm works only for a single recursive boolean function and so we cannot obtain a datatype from other forms of refinements for example conjunction of two predicate function calls this also means that the translation cannot deal with a predicate function that returns additional information by using say an option type our translation assumes an input refinement to be of a certain form we think however that it is not so restrictive because we can transform refinements before applying our method for example a predicate function of the form if e then match x with e z z e else e can be transformed to match x with if e then e else e z z if e then e else e even if such transformation cannot be applied we can always insert pattern matching on the input list in the beginning of a predicate refinement it may be the case though that we do not obtain an expected type definition related work contracts for datatypes there has been much work about lambda calculi with higherorder contracts since the work by findler and felleisen but little of them considers algebraic datatypes in detail and compare the two approaches to datatypes with contracts in particular as far as we know there is no work on conversion between compatible datatypes one exception is findler et al who compare the two approaches to datatypes and introduce lazy contract checking in an eager language lazy contract checking delays contract checking for arguments to data constructor until they are used as they already point out one of lazy contract checking is that it is not suitable for checking where relationship between elements in a data structure is important for example if we take the head of an arbitrary list which is subject to checking it simply returns its head the tail without verifying the tail is sorted also made a similar observation in the work on lazy contracts in a lazy language et al developed a programming language based on a manifest contract calculus with firstclass types and dynamic type can deal with datatypes with refined constructors by but does not formalize them in its core calculus in particular et al did not how casts between datatypes work proposed by et al is a firstorder functional programming language with refinement types and semantic subtyping the combination of these features is as powerful as various types such as algebraic datatypes intersection types and union types can be encoded unlike our calculus does not deal with higherorder functions and dynamic checking with type conversion xu developed a hybrid contract checker for ocaml in the static checking phase the checker performs symbolic simplification of program components wrapped by contracts with the help of context information to remove if a blame remains in the simplified programs the compiler reports errors or it issues warnings and leaves contract checking to run time although the checker supports variant types ie datatypes where constructors have no refinements it does not take care of relationship between elements in data structures for example it seems that it can not prove statically that the tail of a sorted list is also sorted unless programmers give axioms about sorted lists in a different line of work a statically typed functional programming language provides datatypes with laws which are rules to data structures according to certain specifications for example we suppose that a datatype integer has three constructors zero succ integer and pred integer and then a law converts succ pred x to x more interestingly can control application of laws by giving them conditional expressions using laws with conditionals we can define lists which are sorted automatically both and our calculus provide a mechanism to convert data structures but the purposes are different in our work type conversion is used only to check contracts and so does not change structures systematic derivation of datatype definitions as mentioned in section there is closely related work in which systematic derivation of indexed datatype definitions is studied propose the notion of which provide a mechanism to extend and to refine datatypes in a programming language for example the definition of lists can be derived from that of natural numbers by adding an element type and the definition of lists indexed by their lengths can be derived as far as we understand he does not consider deriving new type definitions by changing the number of data constructors as is the case for our work also it is not clear whether partial refinements the case where an index cannot be assigned to some values of the original datatype can be dealt with in this framework partial refinements are important in our setting because our refinement types are for some values in the underlying types et al developed derivation of inductive types from refinement types from a point of view moreover it can deal with partial refinements our translation seems to be a concrete syntactic instance of this framework however being abstract their technique is not concerned about concrete representations of datatypes which are significant when efficiency of casts is taken into account a similar idea is found in et al who develop a refinement type system for static verification of programs dealing with datatypes they allow programmers to write special terminating functions called measures which will be used as to the verifier by indexing a datatype with the measure information dependent andor refinement type systems the term refinement types seems to have many related but different meanings in the literature we use this term for types to denote subsets in some way or another refinement types are studied in the context of static program verification in and pfenning datatypes can be refined by giving data constructors appropriate types for example one may give a special type null and cons a special type int null singleton list which means that if cons takes an element and the empty list then it yields a singleton list here null and singleton list are atomic type names they did not allow refinement types to take arbitrary contracts to make type checking and type inference decidable on the other hand they combined refinement types with intersection types to express overloaded functionality of a single constructor xi and pfenning have designed and developed practical programming languages which support a restricted form of dependent types et al and et al have type inference algorithms for statically typed lambda calculi with refinement types and recursive refinements which provides recursive types with refinements and have implemented it for ocaml and haskell respectively the refinements used there are derived from decidable languages such as extensions of presburger because their main focus is static verification our type system allows arbitrary boolean predicates our datatypes inductive datatypes found in interactive proof such as coq or agda aside from compatibility relation and casts our syntax treats a formal argument x to a datatype to be parametric notice that only argument types of data constructors have to be given however since x can appear in a refinement conditions on the value of x can be enforced and so we do not lose much expressiveness conclusion we have proposed datatypes for manifest contracts with the mechanism of casts between different but compatible datatypes and prove type soundness of a manifest contract calculus with datatypes in particular the property that the value of a term of a refinement type satisfies the contract in the refinement type is proved for the first time in a purely syntactic manner we have also given a formal translation from a refinement on lists to a datatype definition with refined constructors and proved the translation is correct moreover the translation preserves the efficiency of casts as a proof of concept we have implemented our casts using our implementation does not support derivation of datatypes yet and a constructor choice function works by and error with backtracking but we are to extend the implementation with derivation of datatypes and an constructor choice function there are many directions of future work first we would like to investigate static contract checking using datatypes a key theoretical property is elimination a property that removing from a type to its not change the behavior of a program in a certain sense similarly to previous work we expect refining constructor argument types is useful also for static checking second a proof that a generalized version of the translation given in section is correct remains as future work although we do have translation third it is worth intersection types or even boolean operations in this setting so that properties on data structures can be easily combined acknowledgments we thank for valuable comments on an earlier draft we are to the anonymous reviewers for their comments and to findler for being our michael us during the visit to our laboratory this work was supported in part by for scientific research b no from of references the agda the coq proof assistant r p and n refining inductive types logical methods in computer science ­ j f m a and b c pierce polymorphic contracts in proc of esop volume of lncs pages ­ g m a d gordon c and d semantic subtyping with an smt solver in proc of acm icfp pages ­ m and d a sound and complete models of contracts j program july o a semantics for lazy assertions in proc of acm pages ­ m felleisen and r the revised report on the syntactic theories of sequential control and state theor comput sci ­ sept r b findler and m felleisen contracts for higherorder functions in proc of acm icfp pages ­ r b findler s and a lazy contract checking for immutable data structures in proc of volume of lncs pages ­ c flanagan hybrid type checking in proc of acm popl pages ­ t and f pfenning refinement types for ml in proc of acm pldi pages ­ m manifest contracts phd thesis university of pennsylvania m b c pierce and s weirich contracts made manifest in proc of acm popl pages ­ j k a s n and c flanagan hybrid checking for flexible specifications in scheme and functional programming workshop pages ­ d a and c flanagan gradual typing in in functional prog m p m and r jhala typebased data structure verification in proc of acm pldi pages ­ k and c flanagan hybrid type checking acm toplas ­ k a j s n and c flanagan unified hybrid checking for firstclass types general refinement types and dynamic extended report technical report c algebras algebraic j program to appear b meyer objectoriented software construction st edition prenticehall isbn p c s and d van horn soft contract verification in acm icfp b c pierce types and programming languages the mit press cambridge ma usa isbn p m m and r jhala types in acm pldi j g siek and p wadler with and without blame in proc of acm popl pages ­ d a turner a nonstrict functional language with polymorphic types in proc of acm volume of lncs pages ­ n p m and r jhala abstract refinement types in proc of esop volume of lncs pages ­ n e l r jhala d and s peyton jones refinement types for haskell in acm icfp a k wright and m felleisen a syntactic approach to type soundness information and computation ­ h xi dependent ml an approach to practical programming with dependent types j program ­ mar h xi and f pfenning dependent types in practical programming in proc of acm popl pages ­ d n xu hybrid contract checking via symbolic simplification in proc of acm pages ­ d n xu s l peyton jones and k static contract checking for haskell in proc of acm popl pages ­ 