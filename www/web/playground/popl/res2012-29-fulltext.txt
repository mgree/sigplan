algebraic foundations for optimisations gordon d plotkin laboratory for foundations of computer science school of university of edinburgh abstract we present a general theory of type and effect annotations where effect annotations are sets of effects generality is achieved by to the theory of algebraic effects a development of monadic theory of computational effects that the operations causing the effects at hand and their equational theory the key observation is that annotation effects can be identified with operation symbols we develop an annotated version of language with a kind of computations for every effect set it can be thought of as a sequential annotated intermediate language we develop a range of validated optimisations ie equivalences many existing ones and adding new ones we classify these optimisations as structural algebraic or abstract structural optimisations always hold algebraic ones depend on the effect theory at hand and abstract ones depend on the global nature of that theory we give sufficient conditions for their validity categories and subject descriptors d processors compilers optimization f specifying and verifying and reasoning about programs logics of programs f semantics of programming languages algebraic approaches to semantics denotational semantics program analysis f studies of program constructs type structure general terms languages theory keywords algebraic theory of effects code transformations compiler optimisations computational effects denotational semantics domain theory logic relevant and affine monads sum and tensor type and effect systems universal algebra introduction in type and effect analysis each term of a programming language is assigned a type and an effect set the type describes the values the term may evaluate to the effect set describes the effects the term may cause during its computation such as memory assignment exception raising or io for example consider the following term m if true then x else x deref y permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page to copy otherwise to republish to post on servers or to redistribute to lists requires prior specific permission andor a fee popl january ­ pa usa copyright © acm it has unit type as its purpose is to cause side effects it has effect set update lookup as it might cause memory updates or type and effect systems commonly this information via a type and effect judgement x loc y loc m update lookup the information by such effect analyses can be used to guarantee implementation correctness to prove properties to aid resource management or to code using transformations we focus on the last of these as an example purely functional code can be executed out of order x m y m n y m x m n this reordering holds more generally if the terms m and m have effects such transformations are commonly used in compilers they are traditionally called optimisations even if neither side is always the more optimal in a sequence of papers benton et al ­ prove soundness of such optimisations for complex sets of effects however any change in the language requires a complete of its semantics and so of the soundness proofs even though the essential reasons for the validity of the optimisations remain the same thus this approach is not robust as small language changes cause global theory changes a possible way to obtain is to study effect systems in general one would hope for a modular approach to those parts of the theory that change under small language changes and then them with the parts such a theory may not only be important for compiler optimisations in big stable languages it can also be used for equational reasoning this use may be especially helpful in the case of small domainspecific languages as compilers are ever designed for them and their the only available general work on effect systems seems to be that of and they a methodology to derive type and effect frameworks which they apply to a callbyvalue language with recursion and references however their methodology does not account for optimisations fortunately wadler and had previously made an important connection with the monadic approach to computational effects they translated judgements of the form m a in a region analysis calculus to judgements of the form m ta in a calculus they gave the latter calculus an operational semantics and the existence of a corresponding general monadic denotational semantics in which t would denote a monad corresponding to the effects in and in which the partial order of effect sets and would e cooper s p wadler and j links induce a hierarchy of monads and monad morphisms as follows t t t t hierarchies of monads in this spirit were identified by both and however neither hierarchy fully to their effect set partial order plotkin and algebraic theory of effects provides a semantic foundation for computational effects that focuses on the operations causing the effects these operations form a signature with a natural equational theory using tools from universal algebra and category theory one obtains the standard monadic semantics for such computational effects the shift in focus from monads to effect operations and their equational theories allows a modular treatment et al show that the theories of combinations of effects can often be built up from those for individual effects by simple operations such as disjoint sum to model recursion the algebraic theory of effects turns to domain theory replacing equational theories by theories we argue that the algebraic view of effects provides the missing link needed to develop a general theory of type and effect systems with the right choice of signature effects ie the elements of effect sets can be identified with the operations this suggests the way to a full and general account of type and effect systems effect systems and effect reconstruction arise out of the effect signature denotational semantics arises out of the and program logic including optimisations arises from this semantics we concentrate on denotational semantics and optimisations we present a language mail intermediate language which can be thought of as the intermediate language of a compiler its terms have both type and effect annotations these can be thought of as having from a source code syntactic analysis the denotational semantics of mail provides a foundation for optimisations an optimisation is simply an equation between mail terms and it is valid in a mail model if both terms have the same denotation we see optimisations as into three classes structural algebraic and abstract structural optimisations arise out of the structure of mail models hence hold in all models and sequencing laws provide typical examples algebraic optimisations arise from equations for individual effects in the theories underlying the semantics a typical example is x x x these are the and of effectful program optimisation finally abstract optimisations arise from global properties of effects the discard optimisation x m n n is one such example there is a strong connection to work he had previously considered properties of arrows in categories and their dependence on the nature of the monad and it turns out that these give rise to several abstract optimisations in particular as we see below discard holds if and only if the underlying monad is affine abstract optimisations reveals a connection to algebraic laws for example the underlying monad is affine if and only if the law f x x x holds generally ie for every operation f making use of one can then establish the validity of abstract optimisations for example if the law holds generally for each of two theories then it also holds for their disjoint sum our language from a formulation of the semantics specifically as of over partial orders of sets of effects in order to maintain an accessible account we use a minimum of category theory we hope this will allow readers to the inherent categorical structure without readers who are not familiar with category theory the syntax and denotational semantics of mail are given in sections and two classes of semantic models for mail are given theorems and both based on standard algebraic semantics wadler and conjecture while we write in terms of theories and their translations rather than monads and their morphisms their relationship is wellknown see eg the two classes of models are related to the semantics of an algebraic variant of the validity of effect dependent optimisations theorems and next section and effect dependent optimisations including new ones figure algebraic conditions for these optimisations are presented figure and algebraic techniques are given to and combine validity of optimisations theorem ­ proposition section considers an example effectful language with recursion memory regions exceptions normal and rollback terminal io and nondeterminism and applies our theory to validate effect dependent optimisations for it our modular methodology enables us to significantly cut down on the amount of work involved we conclude and discuss related and further work in sections and intermediate language mail is based on and inspired by ml metalanguage whose version on the paradigm subsumes callbyname and callbyvalue both syntactically and semantically and hence is for a general account also in evaluation order is explicit as in intermediate languages moreover expressing our optimisations in more complicated optimisations into orthogonal ones see section thus the paradigm seems for use in intermediate languages for optimisation we reuse as much of work as possible in order to focus on the issues inherent to effect systems mail is by signatures an auxiliary notion of makes the definition of signatures more definition a mail is a tuple e where is a set of basic types ranged over by k is a set of effect operation symbols ranged over by op with a distinguished element e p is a subset of the powerset of the set of effect sets ranged over by and is a set of builtin constants ranged over by c for example may include the types word for bit words loc for memory locations str for strings char for characters or for exceptions the effect operation symbol set may be finite lookup update input output throw choose or even infinite n n in the latter case we may want to restrict e to be a countable set such as that of all finite subsets a countable syntax the distinguished symbol represents nontermination the set typically includes primitives to manipulate basic values such as number constants arithmetic operators div boolean operations string manipulation primitives and exceptions kinds k val comp value types a b k a × a a a ub computation types a b ground value types g fa b × b a b k g × g g g value terms v c x v v v computation a v thunk m terms m n coerce m m to x a n m m m m x a m v m match v as x a x a m match v as b match v as a m a m force v µx ub m m figure mail syntax the syntax of mail for a given is displayed in figure it refines the between values and computations instead of one kind of computation for each effect set e we have computations comp that can cause effects in we view mail as multiple copies of one for each sharing the same values one can translate between these different by means of coercion see below our types are a slight variation on types note that basic types are always value types the unit product zero and sum value types are standard we have modified the thunk type to thunks ub of computations of type b for each e the type fa is the type of computations that return a value of type a it plays a similar role to that of the monadic type t a where t is a monad in haskell also has products of computations which we include and functions are computations that depend on a value the ground value types g are those value types which do not include thunks we call types of the form fg ground types all of the builtin constants of mail are value terms the variables unit value and pairing construct are standard are annotated with their sum type computations m are into values thunk m just as in ordinary many type and effect systems contain a rule if m is an computation and then m is an computation one implication of such a rule is that welltyped terms can have multiple types and even multiple type derivations as a the denotational semantics can no longer be defined di on terms instead it needs to be defined on the proofs that these terms are welltyped and then coherence results are needed to show that the different semantics are compatible with each other this issue is familiar from languages that support subtyping one standard way to it followed here is to use ex coercion between a subtype and its supertype the terms coerce m explicitly coerce computations to computations as usual in we can turn any value into an computation by returning it the m to x a n construct sequences computations it is analogous to x m n in haskell note the typing typing the standard operational semantics of uses a stack machine the two terms pop from the stack while the application terms m push onto it thus m m a tag off the stack and executes m or m accordingly in turn m pushes the tag onto the stack and continues to execute m sim k k val k a val k a val k val k a × a val k a val k a val k val k a a val k b comp k ub val k a val k b comp k b comp k fa comp k b × b comp k a val k b comp k a b comp figure mail kind system x a m a value of type a and binds x to it while v m pushes v onto the stack the patternmatching terms eliminating products zero and sum values are standard computations are eliminated by forcing recursion is expressed by least as usual importantly computational effects are caused by the m terms as an example the following computation consists of a memory lookup operation dereferencing memory location followed by returning the memory word w stored there deref def word w word the effect operation symbol lookup takes as a parameter the location to be and requires as argument a computation depending on the memory word as another example consider a nondeterministic choice operator choose and a computation for nondeterministic def v return v in this case the parameter is the unit value in general is an effect operation term with parameter v and argument m terms of the form v def x a are called generic effects thus deref and are the generic effects corresponding to lookup and choose respectively our combination of syntax typing and explicit coercion leads to a and syntax however considering our setting as an intermediate representation used by an compiler this issue becomes irrelevant as the syntax is generated automatically being seen only by the compiler the kind system for mail given a is displayed in figure it consists of a kind judgement relation k between types and kinds we denote by val the set of value types v k v val similarly we write comp for the set of computation types a context dom val is a function from a finite set of variables to val we write x a for the extension x a given a an arity assignment ar sends elements of to pairs of ground types such that ar when a p we write instead op a p the first component a is called the arity type and the second component p is called the parameter type when the parameter type is p we simply write op a when op we call op an effect constant symbol thus is a constant symbol for example one would have lookup word loc as lookup has a location parameter and its argument expects the cor x a v c ac v x a v v ai v v v a v v a v v v a × a m b v v a a m f a v thunk m ub v v a coerce m f a fa m fa x a n b m to x a n b m b m b m b × b m m b × b im bi x a m b v v a m a b x a m a b v m b v v a × a x a y a m b match v as x a x a m b v v match v as b b v v a a x a m b x a m b match v as a m a m b v v ub x ub m b force v b µx ub m b v p m a b op a p op m b figure mail type system memory word similarly one would have choose where as choose has a trivial parameter we say that choose is a binary operation symbol example constant type assignments are a char × str and for def × word definition a mail signature is a triple ar a where is a ar is an arity assignment and a val is a type assignment for the builtin constant symbols the type system of mail given a signature is displayed in figure it is given by type judgement relations v v a and m b where a b are contexts value types and computation kinds respectively and where v m are value and computation terms respectively signatures determine the language of mail meaning its syntax and kind and typing relations when we need to mention this dependence we write mail we call closed ground p fg programs the type system is straightforward apart from the rules for co recursion and effect operation symbols the coercion rule may seem surprising we only allow coercion of how ever this restriction which is semantically natural allows sufficient generality for if then for any b comp one can inductively define a type b comp by fa f a b × there is b b then an evident × b and coercion from a b to b b a b we note too that from a perspective callbyvalue types are always translated into hence the coercion rule immediately suffices to existing effect systems we do not know of any callbyname effect systems see also section next the recursion rule only allows recursive calls when the effect set includes possible divergence finally the effect operation rule the informal explanation given earlier another way to view this rule is via continuation passing we pass a continuation m that depending on the effects result proceeds after the effect has been caused for example the rules for the io effects input char and output char are for suitable s m char b v v char m b b m b the latter is analogous to print statement for the corresponding generic effects we derive the familiar get put get v v char put f semantics we begin with some preliminary material on domain theory in section concerning cpos and then consider theories and their models in cpos in section we can then define models of mail and its denotational semantics in section in section we consider the validity of optimisations and construct our two main mail models the conservative and axiomatic restriction models cpos domain theory provides the mathematical machinery needed to model recursion here we review terminology and relevant notation the simplest type of domains sufficient for our needs are complete partial orders cpos ie partial orders w w closed under an of increasing chains an a scott continuous function f w w between cpos is a monotone function preserving such ie f an f an for any increasing chain an a discrete cpo is a set ordered by equality a the empty cpo is we write w w for the empty map the singleton cpo is we write w w for the map the sum w w of two cpos is the evident cpo over their disjoint union w w we write i wi w w for the evident given two continuous functions fi wi w i the map f f w w w where f f w def fw fw w w w w is continuous we write n for the discrete domain over n elements namely the product w × w of two cpos is the component partial order over their cartesian product w × w we write i w × w wi for the evident projections given two continuous functions fi w wi i the map f f w w × w where f f w def fw fw is continuous the product n i wi of any finite number of cpos is defined similarly the function space ww of two cpos consists of all functions from w to w ordered pointwise f g iff for all w w f w gw its are also given pointwise we write eval ww × w w for the evaluation map given by f d f w if f i wi w is continuous then the jth component di ij wj f di yields a continuous map f ij wi w wj an cpo w is pointed if it has a least element continuous functions over pointed cpos have least and the least fixedpoint operation µ w w w is continuous theories a full account of plotkin and algebraic theory of effects requires the notion of discrete countable theories here we restrict to the simpler and more elementary finitary theories an equational signature is a pair ar where is a set of operation symbols and the arity function ar assigns to each operation f a finite set ar f called its arity we adopt the notation f a for a when f n we say that f is nary operations are also called constants we will write f fn for the signature f fn ar for example the nondeterminism signature nd is it consists of exactly one binary operation again given a finite set v of values the global signature is given by a lookup operation lookup v and unary operations for updating the state v v fix a countable set of variables var ranged over by x y etc given a signature we define the set terms of terms inductively a term is either a variable x or of the form f where f a and a terms when f is nary we may use the usual notation f t tn to write such terms and in the binary case we may use infix notation it is routine to define substitutions var terms and their applications t to terms recall that a preorder is a reflexive transitive binary relation an theory t is a pair where is a signature and is a preorder over terms which is a congruence meaning that it satisfies the following two properties congruence for all substitutions satisfying for all x in var x x and for all terms t we have t t substitution for all terms tt for which t t and for all substitutions we have t t we write t s iff t s and s t let be a signature the free or empty theory for is given by syntactic equality the inconsistent theory for is given by the full relation terms note that all theories lie between these two theories ie terms let ax terms × terms be any set of axioms the theory generated from ax is th ax where is the least preorder over terms that contains ax and which is a congruence note that the empty theory is th and the inconsistent theory is th x y th x y the lifting theory t is given by th x a more interesting example is the theory of which consists of commutativity associativity and equations for the nondeterminism signature nd x y y x x y z x y z x x x the theory of lower is obtained by adding the axiom x x y the theory of upper is obtained by instead adding x xy as a final example let v be a finite set of values the corresponding theory of global state arises out of the following three equations over the global state signature lookup v x lookup v xv x x given a signature an cpo algebra a consists of a pair a a where a is an cpo and a assigns to each operation f a a continuous function f aa a every cpo algebra a induces an interpretation function ia terms × a given for every variable assignment inductively over terms t by ia t def x f a a a a tx t f f a let a a be two such algebras their product a × a is given by a × a × where for all f a f × is given pointwise by f a f a let a be a algebra and w an cpo the power algebra aw is given by aw where for all f a f is given pointwise by wf a a aw given an theory t an cpo t model is a algebra a such that for all t t and for all we have t t for example the collection of all nonempty finite subsets of a set with the union operation is a model of the theory of as another example let v be a finite discrete cpo of values and let w be any cpo then v × w v is the carrier set for a with the obvious operations the product of two t models is again a t model if a is a t model and w an cpo then aw is also a t model given two algebras a a a algebra homomorphism h a a is a continuous function h a a that satisfies for all f a and aa h f f h homomorphisms between two t models are algebra between them as algebras for example the projections i a × a ai are algebra homomorphisms from the product a × a for all algebras a a let t be a theory and w an cpo the free t model over w is a t model ft w for which exists a continuous function wt w ft w called the unit of the free model such that for all t models a and continuous functions f w a there exists a unique t algebra homomorphism ft ft w a satisfying f f for example the free model of the lifting theory defined by th x over an cpo w is given by w with w v iff w or w w v as another example the on v × w v described above is the free model over w the free model for any theory over any cpo always exists by to adjoint functor theorem cf abramsky and however its structure may be nontrivial let be signatures a translation t is a pair x t where xf a var is an injection for each operation f a and t terms such that for each operation f all the variables in t f are in the image of xf ie for each a in a there is a distinct variable and the variables in t f may only involve these variables each translation t induces a translation function t terms terms where tx x and where tf is given by substituting t a for in tf simultaneously for all a a ie tf tf t aa let t t be theories a translation t t t is a translation t that respects the inequalities t t tt tt for example given a finite set v consider the theory given by the signature v v and the ax map to we will only use such trivial translations which have the form f a xa f f ie they translate opera tion symbols to themselves they are translations from t to t iff and let t t t be a translation every a induces a ta as follows the carrier cpo ta is a for each operation f a in we have a term tf terms recall the interpretation function ia and set for all in f ta def ia tf we obtain a continuous function ta thus ta is a algebra and because t preserves and a is a ta is a given an cpo w the t unit over w is a map wt w w therefore by the free definition there exists a unique homomorphism def wt t ft w w such that wt wt following layered monads we call the function ft w ft w the of ft w over ft w along t finally we introduce two common methods to combine theories let be signatures their sum is given by def and ar if def given a term t in the operations in t according to the injection i i yields a term it in terms we can apply this to binary relations over i in the obvious manner let t t be two theories their sum t t is given by th their tensor t t is given by th ax where ax contains all equations of the form f af f af where f i ai in ii and ai ai semantics given a mail signature a mail model consists of a b t t k which we describe to each basic type k we assign an cpo bk this assignment allows us to interpret ground value types g gk def bk g def gg × g def gg × gg g def gg g def gg gg we impose on b that for all op a p ga is a finite discrete cpo and gp is discrete for example we may choose and to be in a bit setting and to be for characters as these interpretations are finite discrete domains every ground type involving them will denote a finite discrete cpo the signature and this assignment induce an equational signature s def ga op a p p gp which in turn induces an equational for each e su b def s op vk def bk v def va × a def a × a v def va a def a a def b cx t def x cfa def fa cb × b def b × b ca b def ba figure type interpretation the next component t assigns to each e an theory t such that su b as a sub signature and such that if then x thus we get for each e and cpo w the free cpo fw and its corresponding unit and bijection the side condition guarantees that if then all are pointed cpos this assignment allows us to interpret the mail type system see figure value types are interpreted as cpos via v computations as via c and contexts as products via cx t for example take t to be th the empty theory over the empty signature in this case are just cpos and fw w the third component t assigns to each pair of subsets in e to be all op and t t op t op top for every triple in e and op a p in for example if t th we can choose t to be the empty translation these translations induce an m the final component k assigns to each builtin constant c an element kc it is to interpret the arithmetic constants on bit integers that can cause exceptions as an example we the definition of a mail model definition let be a mail signature a mail model is a m b t t k where b assigns to each basic type k an cpo such that all are in as finite discrete domains t assigns to each effect set a theory whose signature includes sub such that if then x t assigns to each inclusion a translation t to each t t in builtin constant a c compatible an element manner and k kc assigns given a mail model m we interpret mail terms as follows see figure value terms v v a are interpreted as continuous functions vt v cx t va and computation terms m b are interpreted as continuous functions ct m cx t cb the semantic functions have straightforward definitions the only exception is coercion from to via the m also note how the type system and the side condition over t ensures these semantic functions are welldefined validity and models first we define the validity of optimisations in mail definition let m be a mail model and pi x i be two welltyped mail terms we say that the optimisation p p x is valid in m if mp mp in this case we write m p p x when and x are clear we simply write m p p vt c def c vt x def x vt def vt v v def v v vt a v def iv ct coerce m def m m ct def v ct m to x a n def an x a m ct im def im ct v m def m v ct match v as b def b ct match v as a m a m def m x a v a m x a v a ct µx ub m def µf bm x f ct m def b m figure term interpretation however we are actually interested in the validity of optimisations with the effect annotations erased as that will correspond to the validity of optimisations in the source language so we need a suitable algebraic version of we obtain such a language by mail to signatures with e def models of consist of interpretations for basic types a single theory t and interpretations for the builtin constants thus we obtain a syntax and semantics for with recursion and algebraic effects definition a simple mail signature is a mail signature such that e and for each builtin constant c the only effect set appearing in ac is let be a simple signature then by replacing e with and s with one obtains an signature there is an obvious erasure operation that yields for each syntactic mail entity such as type x or term p a corresponding entity such as x or p respectively this erasure operation preserves and models for algebraic with common combinations of effects and means to combine and construct them are readily available in the literature given a simple signature and one such model we now give three corresponding mail models that can be used for reasoning about programs lemma let be a simple mail signature for each model m there exists a mail model m such that t t and t is the identity translation further for all welltyped terms p x we have mx mx and mp mp the proof is straightforward where the notion of a simple signature guarantees our ability to choose interpretations for constants it would be useful to extend our results to signatures we call m the benchmark model lemma immediately yields a connection between mail and validity theorem let m be a model for any two welltyped mail programs pi fg i we have m p p m p p this theorem then allows us to compare other mail models to a given model via logical relations arguments comparing mail models with the benchmark model the benchmark model completely ignores the effect annotations we next introduce a model that takes them into account definition let t be an theory for any the conservative restriction of t theory terms × terms to t is the theorem let m be an model there exists a mail model m such that t is t and t is the trivial translation further for any two welltyped mail programs pi fg i we have m p p m p p we call m the conservative restriction model optimisations in m depends on finding t explicitly this is nontrivial but is easier with simpler theories one might hope to express restrictions of a combination of theories in terms of the restrictions of their components this hope leads to the following incomplete conjecture conjecture let tt be theories and let be any subset under some conditions the restriction t t is identical to the sum of restrictions t t similarly under some conditions t t is identical to t t to see that the conjecture is not trivial consider the theory for monoids the signature is · e and the axioms are x · y · z x · y · z x · e x e · x the yet elementary argument shows that the two theories monoids and monoids are different multiplication is commutative in the former but not the latter as an intermediate solution we give a model based on the presentation of a theory as a collection of axioms definition let be a signature and ax a set of axioms over it for any the is the t ax we then have an analogue of theorem theorem let ax be a set of axioms over and m a model such that t th ax there exists a mail model m such that t is th ax and t is the trivial translation further for any two welltyped programs pi x i we have m p p m p p we call m the axiomatic restriction model note that by construction m has an explicit of t moreover if t t t and ti then t ax and the axiomatic restriction model resulting for ax ax satisfies for all i i i t th ax ax t t laws match v v as x a y a m m v x v y match v as a m a m mi force thunk m m to x a m m v x i m m mi v x a m m v x laws v m v z match v as x a y a m x yz x y fresh in m m match v as b m v z match v as a m a m x y fresh in m v thunk force v m m to x a m m m n x a xn x fresh in n sequencing m to x a n to y a n m to x a n to y a n x fresh in n m to x a n n m to x a n m to x a n m to x a y a n y a m to x a n y fresh in m effects x a m to y a n a m to y a n x fresh in n x a m m x a m x a m b x a y a m y a x a m x y recursion µx ub m m thunk µx ub m x coercion coerce coerce m coerce m coerce return m return m coerce m to x a n coerce m to x a coerce n coerce a x a m a x a coerce m figure structural optimisations similarly if t t t then t t t in the axiomatic restriction model resulting for ax ax ax thus the analogue of conjecture holds by construction for m also note that for our purposes this theorem implies that validation of optimisations in the modular approximation model is sound however it may not be complete some sound optimisations may not be valid in this model optimisations we turn to optimisations formulated as mail equations this is done semantically using theorems or either one can be used in all cases considered below we divide optimisations into structural algebraic and abstract groups we validate versions of almost all the optimisations in benton et al ­ and also some others not previously considered in the semantics literature the only optimisations considered by benton et al ­ that we do not treat deal with exception handlers see section structural optimisations reflect the general structure of our models let be a mail signature then a mail structural optimisation is one that is valid in all mail models figure shows example schemes for such optimisations they are all variants of the standard sequencing and similar laws found in the literature together with ones concerning effect coercion algebraic optimisations locally in the theories t associated to a given model of mail each equation yields such an optimisation to derive these optimisations from the equations one follows we just give an example here the global state theory includes the axiom lookup xv the corresponding algebraic optimisation is lookup m v m abstract optimisations follow from overall global properties of the theories each appears in two forms which we call and the form readily applies to program optimisation the form is and easier to validate but perhaps less useful for example the form of discard is m fa n b m coerce m to x a n n and its form is m fa m m to x a return return the two forms can always be shown equivalent using structural optimisations instances of both appear in the work of benton et al this optimisation is valid if for example t is the environment theory whose signature is lookup v and axioms are x lookup lookup note that the optimisation obtained by erasure m to x a n n is in general not valid let p fg be a welltyped mail program let p be a welltyped mail program obtained by applying the discard optimisation to p if discard is valid in the conservative axiomatic restriction model then theorem respectively theorem guarantees that p p is valid this equation is valid even if the erased discard used is invalid thus theorems and the justification for effect dependent optimisation discard also a taking m to be a thunk in the form of the optimisation yields on the right hand side the term m force m to x a return and on the left the term m return when discard is valid these two terms are equal when the erased discard is invalid the erased terms are not equal note that these are closed term of the type f this demonstrates why it is important to restrict to ground in theorems and abstract optimisations reveals an connection to work on the structure of callbyvalue each has a in semantic terms for example the discard optimisation holds iff t is an affine theory that is iff f is an isomorphism there are also algebraic of these semantic properties for example a theory t is affine iff for every term t tx x x that is iff a global law holds here and below we are all the variables of the terms at hand such algebraic properties can be investigated using the equational presentation of the theory as an example the theory for environments and the various semilattice theories are affine a summary of the results appears in figure in any row all the conditions are equivalent in any model of mail taking the condition in the first column as universally quantified over all such that benton et al ­ considered callbyvalue of the optimisations labelled by b respectively f in figure for particular combinations of effects respectively for a fixed monad also showed the private communication figure abstract optimisations name discard b f copy b f form m fa n b to x a n n m fa x a y a n b to x a to y a n to x a n xy form m fa bf m to x a return return m fa bf m to x a m to y a return x y m to x a x weak copy m fa x a n b to x a to y a n to x a n swap m x fa ax am n f a b f to x a to x a n to x a to x a n m fa m to x a m m m f a m f a bf to x a to x a return x x to x a to x a return x x weak swap m nm f a same as swap m f a m f a to x a to x a to x a to x a isolated swap m fan m f a same as swap m f a m f a to x a to x a return to x a to x a return unique b mi f i m m same as form pure m fa x a n b b f return thunk to x a n m to x a return thunk n m fa x a n b b f m to x a return thunk to x a n m to x a return thunk n m fa b f return thunk m m to x a return thunk m fa m to x a b f thunk return x thunk m m to x a thunk return x thunk abstract side condition t affine f f has a continuous inverse t relevant f l algebraic equivalent for all terms t tx x x for all terms t xn tx µ str id t t commute m × m f m × m for all terms t xn tx xn tx xn t translations commute with t translations see tensor equations example basic theories readonly state convex upper and lower exceptions lifting readonly state state any affine or relevant theory lifting exceptions readonly and state all three semilattice theories t t t t eg distinct global memory cells m id × m id × m × m × f for all terms t tt s ts x xn xn tx xn for all terms t tt s ts x sx x x tx x t all constants when t is affine eg readonly state and convex upper and lower when t is affine readonly state and convex upper and lower all three state theories all three semilattice theories a single exception lifting f lw fw all terms are equal to variables in t the empty theory inconsistent theories f l id str all terms are either a variable or independent of their variables via t all theories containing only constants lifting and exceptions equivalence of the two forms and the abstract side condition in his setting the abstract conditions in figure use the following standard categorical notions the diagonal function w w w × w is given by w def w w let t be an theory given a continuous function f v w we can lift it to a homomorphism f fv fw we denote the underlying map by lf fv fw the multiplication µ fw is the underlying map of the homomorphism id fw the left strength str v × fw fv × w is given by v w curry similarly we define the right strength str fv × w fv × w the two double strength functions fv × fw fv × w are defined by l str str and by l str str note how copy corresponds to a global law and how swap corresponds to commutativity slight variations on these two laws yield the weak copy and weak and isolated swap optimisations which are new in the formal methods optimisation literature also note the algebraic condition for pure it means that t is either inconsistent or the operations project one of their arguments without effect note too the two optimisations and compare them to the structural optimisations dealing with effect operations figure the simplicity of the latter over the former suggests that the complications arise from the process of rather than abstracting over variables this clean separation between thunks and abstraction supports our use of most but unfortunately not all of the optimisations can be validated theorem for each of the optimisations discard pure and the algebraic condition holds for a theory t iff for all operations f a it holds for the term t f analogously for each of the various swap optimisations the algebraic condition holds for t t t t t iff for each f i i ai i it holds for the terms t f and s f the theorem is proved by a straightforward induction over terms the benefits of the algebraic the theorem was used to obtain most of the examples column in figure we can also use this it to deduce optimisation validity corollary for each algebraic condition for discard pure and if t t satisfy it then so does t t analogously for each algebraic condition for the various swap optimisations if ti ti t tj tj for all i j satisfy it then so does t t t t t optimisation validity is inherited by proposition if t satisfies any of the algebraic conditions in figure and if t is any theory with and then t satisfies the same condition analogously if t t t t t satisfy the algebraic condition for any of the various swap optimisations and if further t t t t t are such that i i ti ti and for each f i ti f then t t t t t satisfy the same algebraic condition for example the semilattice theories are commutative the identity translations commute thus given two locations in paul b private communication memory with associated operations lookup and the trivial translations of into the theory with two distinct memory cells and nondeterminism commute note that each algebraic condition for discard and copy implies that of weak copy similarly the algebraic condition for swap implies that of weak swap which implies that of isolated swap the exceptions to theorem are the copy weak copy and unique optimisations for example in the global state theory both lookup and update are idempotent but the term is not idempotent however in practice we can use equational reasoning to establish them for example the state theory is relevant because any term can be rewritten to a single operation as these are idempotent all terms satisfy the law we can use similar equational arguments to establish these laws for theory combinations theorem let t t be two relevant algebraic theories · if all operations have arity then t t is relevant · if all operations have arity then t t is relevant · if t is also affine then t t is relevant the same is true replacing relevant by the weak copy in practice the relevant theories with which one usually are the lifting theory or with the readonly and state theories and they all satisfy the conditions of this theorem similarly we can deduce the condition for the unique optimisation in the following case proposition let t be an theory if every operation in with every operation then t satisfies the algebraic condition for the unique optimisation example language to demonstrate our results we consider a nontrivial language assume the memory has been partitioned into a finite set of disjoint regions reg the set reg is partitioned into three subsets readonly regions regions and readwrite regions we denote by the readable regions and by the regions the mail signature in question is given as follows the basic types are char word str and loc the effect operations and their are as required input char for terminal input output char for terminal output raise for causing an exception throw str for causing an exception with an error message rollback for causing a rollback exception abort str for causing a rollback exception with an error message for all regions lookup word loc note that each region consists of locations for all readable regions in update loc × word and finally for nondeterministic choice the effect sets e are given by all finite effect subsets p finally the builtin constants we choose are c char for each character c n for each bit number n s for each character string s l for each bit memory address the resulting is indeed simple the signature is ar a the chosen model m the basic types as follows char is the usual encoding word is which we also denote by v str is char the set of finite char sequences and loc is the theory t is given by t t t t where the lookup operations in the signature in the th com of the tensor t are tagged with and ie lookup and similarly for the other finally the constants are given the obvious interpretations by theorem we have an axiomatic restriction model m for the natural modular of t optimisations in this model yields valid optimisations for for each optimisation o in discard pure we define a set o of the operations that satisfy its algebraic condition discard def lookup pure def def raise throw abort rollback by theorem we obtain the following condition proposition for each optimisation o in discard pure if o then o is valid in the theory t of m analogously for each o in swap weak swap isolated swap and for each op define the set of effect operations that with op for weak swap op replaces t in the algebraic condition note that because swap implies weak swap which implies isolated swap we have these sets are given in figure from theorem we can deduce the validity of proposition let o be one of the various swap optimisations let be optimisation o two effect sets if is valid for t t opt o op then the we should note that despite our force method of examining pairs of effect operations we are still exponentially better off than trying to the space of possible pairs it is to whether is possible it would also be good to be able to decide exactly which of the possible optimisations is valid in the benchmark model theorem let if input update and for all in lookup update then t the copy optimisation note that the premise of the theorem and the structure of the axiomatic restriction model guarantees that t is of the form where each of the theories may be omitted note that all of them are relevant repeated application of theorem shows the combinations the optimisation weak copy is treated similarly theorem let if input output and for all in lookup update then t the weak copy optimisation to conclude our example we treat the unique optimisation using proposition theorem let if raise rollback op and or if the intersection is empty then t the unique optimisation related work used ml to investigate effect reification its earlier callbyvalue versions had a denotational semantics and inspired our mail and developed a technique to derive type and effect frameworks based on the notions of redexes and contexts these frameworks are by two functions check and they applied their technique to a fixed mllike callbyvalue language with recursion exceptions and higherorder dynamic allocation capturing many existing effect systems mostly more general than the they gave a mechanically checked soundness proof of their effect system with respect to a suitable operational semantics applied monads to the semantics of type and effect systems more general than ones his monads can be generated by a notion of equational theory in which the signature assigns input and output permissions to operations thereby connecting operations and effects permissions he also established relations to standard monadic semantics analogous to theorems and conclusions and further work we have given a theory of effect systems and unifying existing work the algebraic approach provides a valuable general point of view resulting in the connection between effect operations and effect sets the conservative and the axiomatic restriction models the relation between semantics and standard algebraic semantics optimisation classification and discovery of new optimisations criteria for the validity of abstract optimisations and methods to derive the validity of optimisations for combinations of effects rather than having to proceed from case to case by analogy we hope that the generality of our approach will provide a first step on the way to obtaining a engineering methodology the use of enabled a systematic account that the between programming constructs and effects categorical language greatly the of this work it was also crucial in the connection with work and unifying it with benton et als finally the example language demonstrated the ease of application of the theory to a language equipped with an algebraic semantics note too that model constructions are not ad hoc they come for free given only the algebraic theory of the effects at hand further work it would be good to resolve conjecture and to establish means to decide the validity of optimisations in the benchmark model it is also important to include effect handlers such as exception handlers and rollback in the language and plotkin describe a rule for handlers and a rule for the interaction of algebraic operations and handlers these rules have many consequences in their logic and will be valid in our setting there may also be useful abstract optimisations involving handlers possibly unifying existing accounts effect reconstruction is of immediate importance it should be possible to derive general algorithms for type and effect annotation our semantics can then be used to give semantics to such programs translations of callbyvalue and callbyname into could then be used to deduce general effect systems for these and unifying existing work notions of locality particularly local state are very important it may be possible to make use of work on the algebraic treatment of locality eg to obtain a more general optimisation theory this should enable the work of benton et al on dynamic allocation to be incorporated higherorder store would require solving recursive domain equations op input output raise throw rollback abort lookup update swap lookup update lookup update lookup update lookup raise lookup lookup update rollback lookup update input output raise throw abort rollback abort lookup update input output rollback abort lookup update raise throw rollback abort lookup update swap lookup input output update input output input output raise throw rollback abort output raise throw rollback abort input raise throw rollback abort input output throw rollback abort update input output raise throw rollback abort update input output raise throw abort input output raise throw rollback abort raise throw update figure swap sets in a different direction the distributive combination of theories used for combining ordinary and probabilistic computation should be investigated also our theory should be extended to include effects such as continuations our are required to be ground finite and discrete the and conditions can be relaxed by using respectively theories and theories our treatment of the finite discrete case exploited logic in the case corresponding proof theories are needed to types may involve recursive domain equations as in the treatment of higherorder store the logic we used for our optimisations is a simple equational logic we have only considered equations between terms it seems straightforward to a richer counterpart to plotkin and logic additional work is needed to the general account into in particular it is desirable to the exponential improvement in validation for the other optimisations also machine and modelchecking tools could the burden of validation we conjecture that benton et als logical relations method can be related to the conservative restriction model our approach is denotational it would be interesting to an operational account a precise relationship between our theory and is in order particularly with his monads finally it would be good to go beyond eg allowing effect traces and to account for parallelism as in work acknowledgments we thank robert benton paul wadler and the anonymous reviewers for helpful discussions and comments this research was supported by a and computer science and a society references s abramsky and a hand of log in cs ­ r proc rd ­ r ­ n benton and p proc rd ­ n benton and a kennedy ­ n benton et al proc th ­ n benton et al proc th ­ n benton et al proc th ­ b and p j math ann ­ a proc th popl ­ a ­ a proc th popl ­ c phd thesis university of edinburgh c proc th ­ a d gordon and a jeffrey j comput ­ m hennessy and g d plotkin proc th ­ m and j power ­ m and j power ­ m g d plotkin and j power ­ m et al ­ b of pure and applied logic ­ p et al proc th lics ­ r b proc rd icfp ­ a ­ p b proc th csl ­ p b springer j m and d k proc th popl ­ d and t proc th ­ pa proc th lics ­ j c mitchell hand of g d plotkin siam j of computing ­ g d plotkin lncs ­ g d plotkin and j power proc th ­ g d plotkin and j power lncs ­ g d plotkin and j power ­ g d plotkin and m proc rd lics ­ g d plotkin and m proc th esop ­ j power theory and applications of categories ­ j power ­ m phd thesis university of edinburgh j reynolds proc nd icalp ­ s ­ t coquand et al inf comp ­ m tofte and jp inf comp ­ a p proc nd tic ­ p wadler proc rd icfp ­ p wadler and p acm trans comp log ­ a k wright and m felleisen inf comp ­ 