probabilistic coherence spaces are fully abstract for probabilistic pcf thomas paris paris abstract probabilistic coherence spaces yield a semantics of higherorder probabilistic computation interpreting types as convex sets and programs as power series we prove that the equality of interpretations in characterizes the operational of programs in pcf with a random primitive this is the first result of full abstraction for a semantics of probabilistic pcf the key relies on the of power series along the way to the theorem we design a weighted intersection type assignment system giving a logical presentation of categories and subject descriptors d programming languages formal definitions and theory semantics keywords full abstraction probabilistic pcf introduction probabilistic behaviors appear in many places in the study of languages for instance if the environment of a program behaves randomly or if the program uses probabilistic constructs to understand how the introduction of probabilities changes the computational we use semantics indeed in the last semantics has in giving insights on the way programs compute more precisely operational semantics allows one to formalize a program by the sequence of its execution steps while denotational semantics represents programs by functions in some mathematical space relating the interpretations of inputs and outputs in a compositional way if this last mathematical representation is correct and accurate enough then denotational properties lead to computational features a key example is full abstraction stating that operational ie in the same way in any context is characterized by denotational equivalence ie having the same interpretation so semantics is useful both to give a precise meaning to constructs and to separate programs partially by project number js and et permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page for components of this work owned by others than the authors must be abstracting with credit is permitted to copy otherwise or republish to post on servers or to redistribute to lists requires prior specific permission andor a fee request permissions from popl january Г san diego ca usa copyright is held by the publication to acm acm of course probabilistic semantics have already been investigated first the approach has led to a probabilistic powerdomain which is a sibling of the nondeterministic power domain this approach follows the computational monad method programs are interpreted as functions from the input domain to the powerdomain of the output domain intuitively a program takes an input and returns a probability distribution on outputs this line of work has been by the continuous random variable construction introducing standard tools of probability theory into semantics secondly the approach has been extended with probabilistic features intuitively probabilistic programs are interpreted as probabilistic strategies that are stochastic processes on the plays of the games associated with the types of the programs quantitative semantics follows another from linear logic models from the very beginning linear logic has been associated with coming from calculus and linear algebra indeed programs are interpreted as entire series between mathematical spaces or as analytic functors between sets and programs that use their resources only once are interpreted as linear functions this connection with resource consumption has been in the last with the introduction of differential nets and resource calculus recently quantitative semantics has been explicitly related to the study of quantitative properties such as time or space consumed by a computation this illustrates a new paradigm where a semiring of scalars allows one to encode nondeterministic or probabilistic computations as opposed to the domain paradigm where monads are used another important of linear logic is the perfect duality between programs and environments since a program can be seen as the environment of other programs therefore representing probabilistic environments or programs will down to the same study probabilistic coherence spaces provide a quantitative semantics which model probabilistic computations the main contribution of the present work is to show that probabilistic coherence spaces provide a fully abstract model of a probabilistic extension of the functional language pcf although the proof follows the general pattern that consists in finding a definable context that two terms the key is based on calculus see lemma since programs are interpreted as power series to our knowledge no known model of probabilistic pcf has yet been proved to be fully abstract games semantics provide fully abstract models of standard pcf via an extensional this technique has been adapted to probabilistic game semantics providing a fully abstract model of probabilistic algol an extension of probabilistic pcf with references our result characterizes the operational without the need of an extensional and deals with a functional probabilistic language with no references section is to an insight on the way programs and data are interpreted in probabilistic coherence spaces section is to the syntax and the operational semantics next in section we describe the key notions of probabilistic coherence spaces that will be useful to prove in section full abstraction along the way to the theorem we define an intersection type assignment system figure giving a logical presentation to the model this system has an interest by its own allowing one to turn a question of computing the semantics of a term and hence its operational behavior into a proof search problem finally in section we show that full abstraction fails ie the order does not coincide with the operational one for this we achieve a context lemma for probabilistic pcf proposition notation we write n for the set of non negative integers n for the set of positive integers n n r for the set of non negative real numbers and r r for the completed real half line let s be a set s denotes its cardinality multisets of elements of s are identified with functions s n if m is such a multiset m denotes its support set a s st ma a finite multiset is a multiset with a finite support we write mf s for the set of all finite multisets of elements of s we enumerate m by using a i m to denote a m and i ma whenever a an sn we write a an for the finite multiset a s i st ai a the empty multiset is and is the multiset union m pa ma pa a vector v rs is given by its values va on any index a s given a multiset m mf s we define the power vm for any a s let ea rs be the base vector ab with ab denoting the symbol let us fix our conventions a b c range over web elements and m p q over multisets v w u range over vectors over matrices over a b c range over simple types int being the integer type x y z range over term variables m n p range over terms finally х range over scalars in r and denotes a list of scalars and similarly for the other metavariables denoting probabilistic probabilistic programs use two levels of the first one on data ie terms of ground type the second one on programs ie terms of higherorder type a probabilistic datum is a random variable whose outcome is given to the program thus a probabilistic datum will be characterized by its law that will be its interpretation then a probabilistic program uses random instructions and behaves like a function from probabilistic data to probabilistic data moreover a program can call several times its argument x each of its occurrences is represented by the outcome of an independent random variable with the same distribution as x we consider two examples of probabilistic data of type int the first one is the of a fair the second one follows the discrete uniform distribution with outcomes between and n if we are only interested in resulting values then int is interpreted by the set of non negative integers int n first we consider and as non deterministic data and interpret them by the range of the corresponding random variables and n then to take into account the randomized behavior of the datum we associate a to each outcome its probability to happen the interpretation of a datum is now given by a sequence of nonnegative integers indexed by the possible outcomes and n n n in general we will interpret the integer type by distributions over n p int rn st nn n for probabilistic programs we follow the same pattern as for probabilistic data first their non deterministic behavior is described then coefficients are introduced in order to their quantitative behavior as an example let us consider the program rand int int that takes an input value n and returns any non negative integer strictly less than n with equal and make it interact with probabilistic data eg a probabilistic distribution over n focusing on the association between input and output values its non deterministic behavior is described as a relation rand int О int rand n a st n n a n then we associate a to each pair inputoutput it rep the quantitative account of getting the given output know ing the input the interpretation of the program is now turned into a matrix indexed by the values interpreting inputs column indices and outputs raw indices rand иии n иии иии n и и и иии n и и и rand n n the interaction between the program rand and a probabilistic datum x is then given by the product of the matrix interpreting the program and of the sequence interpreting the datum besides this probabilistic program preserves distributions actually this approach is valid only if the program uses exactly once its argument indeed as a side effect of the callbyname execution strategy each occurrence of a probabilistic datum behaves as an independent sample of a random variable so if a program makes several calls to a given probabilistic datum then the outcomes of the calls may differ due to the randomized we the input values into a finite multiset finite since if the execution of a program terminates then the number of resources effectively used is finite multiset rather than a sequence since this model is not accurate enough to distinguish the order of the inputs to illustrate this point we examine the probabilistic programs once twice where branches depending whether x evaluates to zero or not notice that the two programs uses among others probabilistic since a call to a datum can fail the total probability distribution over the possible values may be less than rand is the of a stochastic matrix and the image of a distribution is the matrix product rand и v this will also appear in a callbyvalue setting if every probabilistic datum x is replaced by its cps translation instructions and that they call once or twice their input their interpretation is given by a matrix indexed by finite multisets the input and integers the output coefficients are non zero only if the multiset is of size one or two once a if a m a otherwise twice a if a a b if a b m a otherwise on the second example two quantitative are mixed up the first one is probabilistic comes from the use of the second one from branching construction two different execution traces are leading to either the two outcomes of the random variable x are first and then a or its outcomes are first a and then in our model these traces are in the same multiset a and the is the combinatorial counterpart this gives a of why programs are not represented as random variables now the interaction of a probabilistic program with a probabilistic data down to a matrix product adapted to take into account let us consider a probabilistic datum x int and a program m int int as a the x a is the probability that a is the outcome of x the probability m x b that m x returns b is given by the computation in pairwise disjoint events each event corresponds to an intermediate multiset m the input values that are effectively used during computation m x b m mb x m n see notation for x m is the probability that independent calls to x returns the values in m in this way every m x b is a power series with infinitely many variables that are the x a for a n applying formula we compute the non zero coefficients once x once x x once x xa a twice x x xa xb ab twice x x twice x x xa a notice that every of once x is a linear function and every of twice x is a polynomial of degree besides once and twice preserve distributions once x b x x x a b a twice x b b x x x a x a a a x a a probabilistic pcf we define the language in figure this system is a minor variant with respect to the probabilistic extension of pcf presented in see remark the grammar of terms is obtained by adding to standard pcf a random number generator typing rules figure b are the usual ones with rand of type int int from now on we call program a closed term of type int figure c gives the one step reduction relation imple a weak ie a lazy callbyname strategy the relation is weighted with a probability equal to except for steps a rand n redex reducing to any in n with equal probability n the probability of a reduction sequence is the product of the weights of all its steps some notational conventions are introduced in figure d and will be used example notice by induction on n that the term for i n reduces in several steps to any mi with equal probability n in general any reduction sequence has a probability given by a rational number in since rand n introduces just example the fixpoint constructor yields infinite reduction sequences like the typical loop a a a however we can have terms with infinite reduction sequences but to a normal form with probability indeed take m see notations in figure d we have m m m the probability that m reduces to is equal to the sum of the probabilities of all finite reductions sequences from m to which is n n n being the number of loops taken by a sequence a way for precisely defining the probability of convergence of a term to a normal form is by giving the operational semantics as a markov process over the set of terms following the transition matrix is defined by if m n if m n is a normal form otherwise notice that is welldefined since there exists at most one reduction step m n once fixed m and n is a stochastic matrix ie for all m the value of intuitively describes the probability of from the state m to the state n in one step a term m is whenever the ing states are those which are invariant under the transition matrix notice that the normal forms are all but the converse is false eg is an term the nth power of the matrix is a stochastic matrix on in case n we have the identity matrix on intuitively the value of is the probability of from the state m to the state n in exactly n steps proposition lemma let m and n the sequence nn is monotonic we can thus define for every program m and n n k intuitively defines the probability that m reaches a n in an arbitrary number of steps in standard pcf the observational preorder is defined with respect to the termination of a term in a context of type int in a probabilistic framework like one can refine such a preorder types a b c int a b terms m n p x m n sm pm n p rand a grammar of types and terms the constant int is the base type of integers given n n n will denote its associated defined as sn x a x a x a m b a b int p int sp int p int pp int m ab n a m n b m aa a m int n a p a n p a rand int int b simple type assignment system n m nx m if n p n n p p pn n rand n n k for k n m m m not abstract m n m n m m sm sm m m pm pm m m n p n p m m rand m rand m c reduction rules in case n rand n is a normal form a choose a n p n n p n p m n m n mn n mn mn n p n p p n n p n n p d notational conventions also we can use as a for mn figure probabilistic extension of pcf by comparing the probability of convergence let ca be the set of contexts q mapping terms m of type a in the environment into programs qm ie closed terms of type int definition observational preorder given m a and n a we define m n iff q ca let be the equivalence induced by remark there are slightly different probabilistic primitives that can be added to pcf we have chosen a quite standard one rand implementing caml function in it is also considered the more basic rand another possibility is to allow an arbitrary of two terms m n for evaluating to m with probability and to n with probability see eg concerning nary distributions there is evaluating to any mi with probability i finally allows any probabilistic distribution over the whole set of evaluating to n with probability n obviously can be defined as as well as rand also both and rand are definable as and the latter the chosen for testing the equality is not significant indeed from a context q two terms m n on a n ie such that one can get a context m and n on another m by applying a suitable number of p or s constructors as however the are less trivial in figure the authors show how to define rand as a recursive program using just on the contrary is strictly more expressive than rand and since it is not true that all real numbers can be approximated by series of rational numbers generated from terms hence recursively enumerable series one can then whether the observational equivalence on pcf terms depends on the chosen probabilistic primitive the full abstraction gives a negative answer to the question all such primitives induce the same observational equivalence on pcf terms which is in fact the equivalence induced by corollary probabilistic coherence spaces we present probabilistic coherence spaces and recall the main results needed to state and prove the full abstraction theorem the category of probabilistic coherence spaces is a model of as usual types are interpreted as objects of the category and programs as maps between the interpretation of the input and output types actually is by a model of linear logic that we do not make explicit for the sake of brevity but we refer to probabilistic coherence spaces a probabilistic coherence space is a pair a p a of a set a and a set p a of vectors in the module a r intuitively the elements in a represent atomic data while the vectors in p a express probabilistic data at the ground type p int is in fact the convex set of the distributions of the elements in int however at higherorder types this intuition is lost and the definition of p a depends on a duality condition describing the probability of having an interaction between a datum of type a which is a program and an environment consider a program and an environment interacting on atomic data a included in a set a such that their respective interpretation are positive real vectors v w ra their pairing gives a quantitative of the interaction success v w va wa r aa we say that their interaction is probabilistic whenever v w we then define a operation on sets of vectors p a r as p w a r st v p v w the probabilistic duality is then enforced in our model by the condition p p definition a probabilistic coherence space or for short is a pair a a p a where a is a countable set called the web of a and p a is a subset of a r satisfying p a p a a a v p a va a a ea p a as a side effect condition forces p a to be a convex set condition requires the projection of p a in any direction to be bounded while forces p a to cover every direction example the set p int of distributions over n yields a in particular p int p int its being p int n the category the objects of are the and the set b of morphisms from a to b is the set of matrices such that v p a v p b where b b vb mb и vm a see notation for the definition of vm following section a morphism is presented as a matrix that the coefficients of the power series described by the equation the identity on a is given by the matrix if m a otherwise in fact we have v for every v p a let b and c their composition must satisfy v p a v v in terms this comes out as c c mc и vm pc и v p a b pc и qb и pb b p a is not a subset of a see discussion in section these conditions are introduced in for keeping finite all the scalars involved yet they are not explicitly stated in the definition of in now to extract the of the vm we dis product over sum this amounts to choosing a partition of m matching the enumeration b i st b p i pb of p therefore the composition is defined as the matrix coefficients for m mf a and c c mc pc b b st m is cartesian closed the cartesian product of any countable family of is ii ai i О ai ii p ii ai v r ii ai st i i iv p ai where iv is the vector in denoting the ith component of v ie iv a via the jth projection ii ai aj and the product i ii ii ai are given by a if m j a otherwise i ii j pa the terminal object is given by the empty product notice that the set of points of a a ie the set a is isomorphic to the convex set p a notation we write for the binary product in the sequel we present any v p a О a as the pair v v p a О p a of its components notice that the set mf ii ai is isomorphic to the settheoretic cartesian product ii mf ai via the map associating any m mf ii ai with the family defined as mi a this means that any morphism ii ai b can be presented as a matrix indexed by sequences in ii mf ai О b the object of morphisms is defined as a b mf a О b p a b b is then turned into a cartesian closed category by the evaluation ev b О a b and the cur a b for every О a b defined as if m p v otherwise notice that the above equations use notation eg representing a multiset in mf a b О a as a pair m p of multisets in mf a b О mf a actually the category is in the sense that the equality of morphisms is extensional ie given two matrices b if for every v p a v v then to sum up we have the definition of equation is due to on a side note remark that in the authors use another formulation in which identical produced by different partitions are this gives rise to coefficients that are hidden in the sums of the present formulation however the two definitions give rise to the same matrix proposition Д is a well pointed cartesian closed category object of and the object of of is the int n p int equipped with the morphisms z int p int pred succ int and О int О int int defined as zn n mn mn if m p q n or m p q k n otherwise the natural order on r with a defined on morphisms ie given b iff m mf a b mf b mb mb the matrix is the minimum element and the lub of a directed net is then given by dd sup mb dd remark the order on matrices is not extensional ie there are b such that v p a v v but for example take int mn if m k n otherwise mn if m n otherwise although for every distribution of natural numbers v p int we get v k vk v in fact we will use this for the inequality full abstraction in section is an adequate model of the model of is obtained by extending the usual categorical interpretation of pcf to rand with a type a we associate a a by induction on the type int int and a b a b let x a xn an the interpretation of a judgment m b is a morphism m of n i ai b defined in figure by structural induction on the unique derivation of m b the fixpoint operator is the lub of its given by induction by fix ev the operator rand is defined by using a multiset variant of the matrix rand of equation rand mk n if m n k n otherwise together with the categorical interpretation of a term we describe its action on the vectors in the convex set associated with its input type notice that since the category is well pointed of the category this action determines the interpretation of the term notice also that the matrices interpreting the basic constructs in figure have coefficients except for rand which is interpreted as the random function that introduces rational numbers in coefficients greater than may be produced by composition of morphisms equation thanks to notation m can be described as a vector indexed by a tuple m b of m mf and a web element b b this convention will be used example if is identified with rand then the tation of once and twice are the matrices given in section consider the term a notice that is different from zero only on the web elements of the form a a so that for any natural number n we conclude a as expected consider now the term p we have that ma x m a am ie it is equal to when m a or when m and a otherwise it is equal to this means that и и и n for any n we conclude that p proposition soundness the semantics is invariant under reduction ie for every m b m n n proof sketch the invariance under reduction rules of the standard pcf redexes follows by cartesian and the of the soundness of the reduction of rand n is straight from the definition of rand the soundness of the context rules depends on the fact that the interpretation of a context is linear in the argument associated with the redex for example the soundness of the context rule associated with application depends on the equality ev х ev theorem adequacy let m be a closed term of type int then m is the distribution on n such that n n m n remark adequacy allows one to prove that specific are not definable in the language a example is the parallel or function in our setting this should be a closed term por int and por ee por e por e by definition of a morphism in por ee must be a distribution hence por ee that implies por on the other hand por ee por e por e por which that por ee is a distribution we con that por is not a term of however let us mention that the function is a valid morphism of see full abstraction extends to higherorder types the perfect matching syntax semantics stated by adequacy on int one direction of full abstraction is indeed a consequence of theorem corollary abstraction given m a and n a we have that m n implies m n in particular m n implies m n proof by induction on c one proves that m n implies cm cn then the result follows from theorem full abstraction we prove equational full abstraction theorem that is the converse of the part of corollary dealing with equality this is a straightforward consequence of lemma stating that for any ai v vi xi cur m xb ab v v u xb m with m xb m n a b a ev b v vv m n with m n t z int v m succ int int v w w sm with w m v m pred int int v w w pm with w m v t rand int int v rand rand m n n int О a О a int v wu n n p with w m v u n v u n v m a v with w m v figure the standard semantics of terms together with its action on v p closed terms m and n having different interpretations in there is a testing term p such that p m and p n reduce to with different probabilities let us outline the path to this result with any web element a we associate a testing term pa that is described in figure and that the contexts used in pa is not an ordinary term of since its construction uses a random operator weighted by a list x of formal parameters however a parameterized term becomes an ordinary term when we substitute x by a list of in following we introduce in figure an intersection type system that defines semantics of parameterized terms this interpretation is a formal power series over x definition moreover parameterized semantics is compatible with through substitution of parameters lemma now assume that m and n are interpreted by different matrices and pick a web element a such that m a n a then the semantics of the parameterized terms pa m and pa n are distinct formal power series indeed lemma implies that they differ at least on one finally lemma ensures the existence of a list of in on which these power series so the substitution of x by in pa produces a testing context separating m and n we first describe parameterized in subsection then testing terms are presented in subsection we conclude in subsection with the full abstraction theorem parameterized let p be a set of formal parameters x y z range over parameters in p the grammar of parameterized is an extension of figure a by multiplication of terms by parameters и и и x и m where x p the simple type of x и m under a context is a whenever m a in figure b the substitution of parameters by scalars let us recover ordinary terms from parameterized ones more precisely let m and n m be a rational number we define m n m x as the term obtained by replacing in m any subterm of shape x и n with n mn n n times mn times see figure d for choose definition substitution is then to lists x of parameters and of as m x fact if x is the list of all parameters in m and a list of rational numbers in then m x is a term of the semantics of is a refinement of semantics taking into account parameters yet for the sake of the full abstraction proof we give a different presentation and use a weighted intersection type system roughly speaking types are web elements and with each type derivation we associate a weight which is a positive ie a product of in and of finitely many parameters then the interpretation m of a term m is a matrix indexed by web elements for each web element there can be several type derivations and the corresponding is the sum of their weights more precisely figure describes the rules for constructing a derivation и m a of what we call a web judgment и m a notice that m a is a valid simple type judgment a a and is a besides a web context и is defined as a function mapping any typed variable xc occurring in to a finite multiset m mf c of web elements and mapping variables in to the empty multiset for instance for any x c xn cn and m mf m denotes the web context mi for i n disjoint unions и и of web contexts are defined pointwise fact if и m a is derivable and is a nonempty multiset then x is free in m rules app and fix some comments application of terms is interpreted following equation that defines composition remark that indices of app mainly coincide with the indices of the sums in with one more difficulty since we have to split contexts now fix is derived from the rule app and from var xa a x a n n nat kn rand rand n k n и xa m m a и m a abs и m m b и a i m aim ai m n b ai n a aim m mf a st и и aim и m m b a i m ai a и aim ai b aim m mf a st и и aim и и m n pm n pred и m n и sm n succ и m и n a и и n p a if и m n и p a и и n p a figure semantics of parameterized и m a и x x и m a par m to illustrate this point and the we detail examples and at the end of this subsection fact if m a then m ma is a power series with finitely many variables in p and non negative coefficients thus for any list of non negative reals is well defined m ma the following fundamental lemma ensures the soundness of the weighted type system that computes the semantics of lemma soundness let m be a term of such that m b and x lists its parameters for any p mf b b and any list of rational numbers in m x pb p m b proof we prove equation by structural induction on m using rules of figure and the definition of the categorical interpretation of a term in we consider the term greater than m n y for any natural number n and variable y in fact we are using the induction on the most cases follow directly from induction hypothesis we only detail three cases i multiplication with a parameter ii tion iii fixpoint we i assume m get m x and i choose n example so m x pb n m n x pb now any derivation p m x b consists of a sequence of h n rules with on top the rule if with a derivation p n x b as right premise indeed the subterm has no web type see example when is fixed m and there are as many derivations as many choices of h n so we compute n x x m p m b p n b which is equal to n m n x by induction hypothesis pb we conclude by the equalities of the two ii assume m n p thanks to the categorical semantics n p pb ev n p pb then by definition of composition equation and left linearity of ev n p pb is n p a st aim mb p a aim by induction hypothesis and product over sum we get ai q n mb aim st where qp aim st aim p a although the indices of the sums might be they precisely describe all possible derivations of p n p b namely the first sum defines the label of the terminal application rule while the other sums give the choices of the derivations of their premises the total weight is then the product of premise weights iii assume m any derivation p b ends with a cluster of fix rules see example for n n let n be the set of derivations whose cluster height is at most n now remark that a derivation in n can be transformed into a derivation p yb n n y b where y is fresh by replacing fix rules with app rules keeping labels and each occurrence of with n h y for the suitable h n besides this transformation preserves weights therefore n n since pb nn n n y y p b and by induction hypothesis n n y y p b nn pb nn n n n p b according to this result we generalize the semantics notation to parameterized definition for any term m in with n parameters m и a и m a it is a power series whose domain of convergence contains n the weighted type assignment system of figure has an interest by its own it turns computation of semantics of terms and hence its observational behavior into a proof search problem the reader can that this approach is useful by computing the semantics of the following examples by applying directly rules of figure example let k and k be non negative integers let us consider the possible derivations of the application m n with m int int n k k the derivable judgments on the term n are of the form n n k with k k k in fact once fixed n the derivation is unique and is given at the lefthand side of figure as for the term m the derivable judgments are of the form m h h with h h however in this case we have two different derivations whenever h h one derivation is given at the righthand side of figure while the other one is obtained by the order between the var rules on h and h the weight of a derivation of m n is however the number of derivation of a fix judgment n n m n depends on n n k k following cases и if k k and n n then there is exactly one derivation и if k k and n n then there are two derivations one ending with the rule and the other one with the rule kn и if k k and n n then there are two possible derivations depending on which is the derivation used for inferring the judgment on m notice that the final rule typing m n must be n и if k k and n n then there are four possible derivations depending on the last rule ie n or kn k n and on the derivation for inferring m actually by lemma weights of possible derivations sums into m n y ie m n y if h k k m n n if h k k m n n or h k k m n n if h k k m n n otherwise example any derivation of a fixpoint term ends with a cluster of fix rules each rule has one premise typing m and a number of premises typing and along which the cluster grows since the derivation must be finite the cluster eventually ends with fix rules of label they have exactly one premise pn n int n n n pa pc z и n n a x n c c figure testing terms in the higherorder case ie a b c we suppose a b bn c with bi b and c c terms are to have disjoint parameters and the occurring in the definition of pa are assumed to be fresh typing m with a web element of shape a as a consequence the term a has no web type as cannot have a web type of shape a we find again a on the other hand any derivation of will end with a branch of n fix rules n rules labelled by and the rule at the top of the branch labelled by and having as premise the unique derivation of the whole derivation has conclusion and the n sum of these weights for n yields we find again the results of examples and testing terms figure associates with every web element a a two closed terms of one term pa of type a int and one term n a of type a defined by mutual induction on a pa and n a are named testing terms the parameters occurring in this terms are in a correspondence with the elements of the multisets appearing in a at all in the following we focus on pa m and n a a for any m mf a and a a which are formal series in the parameters occurring in the terms fact more precisely we are interested in the of the having each parameter of the term occurring with degree this is called the skeleton of a and is denoted by lemma let a be a type a a a and m mf a in the series pa m resp n a a the has a non zero if and only if m a resp a a proof by definition the of the in pa m can be from the sum of the weights of the derivations of shape p pa m and similarly for n a a hence the statement is equivalent to the following property which will be proved by induction on type a for any a a there is a derivation of pa m with if and only if m a for any a a there is a derivation of n a a with if and only if a a for the ground type int testing terms have no parameters so that the is the constant term of the series the derivations of pn and n n are unique and of shape m n xm xn x m n n m a n na n y n k k n n k xint h x h xint xint h x h xint h int xint h h int int m h h figure weighted derivations discussed in the example bj ij n bj m p c p b bk ij и n bj q c z m z p c j k k ij и n bj pc q z m z и n c p pc z и n p pc z и n m figure proof derivation in the in pa we conclude that the is non zero iff m n and a n for the inductive case let us assume that the result holds for type b and c and that a b bk c b c no that k i a derivation of pa m with must be as described in figure as justified below the only possible rule is the abstraction one for using the application rule we have to choose an intermediate multiset q mf b c and a context и such that и pc q is derivable since pc is a closed term by fact и must be empty ie mapping all variables to the empty multiset moreover by definition the parameters occur ring in pc must be different from those occurring in each xi и n bi therefore with by induction hypothesis in we infer that q c we then deduce that is a binary applicative rule of label hence the right premise is the sequent z m z и n c for a of the shape х k i xi и the shape of the term forces us to use the application rule again let p b bk denote the intermediate multiset since the left premise is the only one in which z appears there is only one possible way of separating the context и z m and since the only possible rule for is the var rule we get m p c we conclude that is an applicative rule with k premises the k right premises being of shape j и n bj for any j k there is a cluster of h k rules and at the top of it a rule if with as right premise a weighted typing of a и n from that we must apply a par rule and get as premise a sequent of shape ij n bj for ij k and weight ij then notice that the weight of the conclusion of is ij and that of the conclusion of is k ij on the one hand the reasoning on gives us х k i xi и while the definition of the weight of the conclusion of gives us k j k и ij since by definition no parameter xi occurs in n hence no xi appears in ij we have that the mapping j ij is a correspondence between k and k so k k finally since the sets of parameters occurring in the n are pairwise disjoint we deduce that ij is proportional to we can then apply the induction hypothesis on and deduce that bi and so p b bk combining all these results we eventually get that m p c b bk c a we conclude that there is a derivation of pa m if and only if m a now let us consider a derivation of n a a which must have the following form x p x n c c c x n c c p c we prove by recursion on k j the property if x p x n c c c is derivable then is proportional to k ij if and only if c c and p bj bk the base case j k is the induction hypothesis indeed if x p n c c is derivable then by fact p is empty so that the weight is proportional to if and only if c c the inductive case is proved accordingly to figure since c has no web type example the only possible rule is if the choice of how to partition the context m m will be from the type derivation since by definition the set of parameters in and the set of parameters in x n c c are disjoint we have that is proportional to and is proportional to k ij for the right premise we can then apply the hypothesis and deduce that c c and m bj bk for the left premise the only possible rule is app we have then to choose the intermediate multiset m as in the previous cases one can argue that the left premise has empty context m bj m x m x m x x m c c m bj bk x m x n c c c x m m x n c c c figure proof derivation in the in n a since is closed and then the induction hypothesis gives m bj this means that has only one premise at the righthand side which is a conclusion of a var rule so that m m we conclude by combining all these results we get that the context m m bj bk and c c we have proved that rh holds c c and p b bk hence a a main result the theory of analytic functions can be than single variable ones for instance of functions are not isolated in general in the following lemma we that the coefficients of a power series on a of zero have to be null indeed coefficients are computed by successive derivations as limits of difference we then apply this result to power series with possibly negative coefficients lemma let f be a power series from rn to r on n if f on a subset of n then the coefficients of the power series f are zero lemma let m and n be two closed terms of with the same type a if m n then there is a term p of type a int such that m n proof let a a such that m a n a consider the testing term pa as defined in figure is let f denote the series pa m a power series from n to which where n by definition is the number of parameters in pa let f denote the of the in f by definition equation this is given by the sum of the weights of the possible derivations of pa m for proportional to the last rule of this derivation must be an app rule of shape pa m a i m a i m a a im a i p a m since m has no free parameter it is a term of each a i is a positive real number hence a im a i is proportional to iff is proportional to we can then apply lemma and get m a moreover by lemma the sum of the weights of the derivations of m a is equal to the scalar m a to sum up we conclude f pa a m a with pa a by an analogous reasoning g pa a n a where g denotes the power series pa n we can conclude that f and g have a different for the as soon as m a n a now we apply lemma to the series f g which is not the zero power series because of the of therefore as rational numbers are in there is a list of rational numbers in such that f g by lemma this is equivalent to pa x m pa x n we conclude by setting p pa x actually p is a well defined term by fact so by adequacy theorem m p m p n n theorem full abstraction given m a and a we have m n iff m n n proof by corollary and lemma as a consequence the observational equivalence does not depend on the chosen probabilistic primitive recall remark corollary for any p rand ii let p denote the observational equivalence induced by the extension of pcf with the probabilistic primitive p the equivalence p coincides with the equality of the interpretations in in particular p gives the same equivalence on pcf terms for any choice of p proof sketch we have that rand since the two and rand are by similarly by the discussion of remark we have rand ii in the adequacy property of is established for the language containing the the primitive hence contains the equality of the interpretations in finally by theorem we have rand and we can conclude a counterexample to fa we prove that full abstraction fails for the proof consists in i showing that the morphisms of remark that proves the of the order are definable in equation ii achieving a context lemma proposition allowing us to infer the observational inequality by just observing the behavior of closed terms in applicative contexts if one would like to the language in order to make observable also the order of one should add a kind of differential operator to in the spirit of however such an extension is not trivial since is known not to be sound for the whole differential calculus let us define m and m as follows m m xint by using rules of figure and lemma one can check that the semantics of the two terms is given by the morphisms of example ie m and m hence the two matrices m and m are incomparable in in order to prove m m we use a standard reasoning and introduce a logical relation definition allowing us to the set of contexts proposition we conclude with corollary definition by structural induction on a type a we define the binary relation a over closed terms of type a as int n iff n n n n n n and m ab m iff n a n m n b m n lemma let m be a term of type x a xn an m a if for all i ni ai ni then m n x a m n x proposition let m and n be closed terms of type a then m a n iff m a n corollary the terms m and m of equation are logically related m m hence m m conclusion we show that the observational equality over probabilistic programs is described by a relatively abstract model based on convex sets and extensional functions the proof uses tools which might be useful to study probabilistic from a viewpoint in a language with random functions two programs should be considered different not only when they give different results but also when they give the same result but with different probabilities showing this difference can be much harder than in a deterministic language indeed it requires a control over coefficients expressing probabilities denotes programs with power series this allows us to use standard tools of calculus for handling probabilities although we chose one probabilistic primitive see remark corollary shows that our result does not depend on this choice moreover we focused on a callbyname functional language but our result might be extended to other frameworks in fact comes from a model of linear logic it is the category associated with the exponential that corresponds to the translation of the functional arrow a b into the linear logic formula a b callbyvalue can be obtained by using the construction ie translating a b into a b control operators can be introduced considering a fragment of linear logic yet extending this model to concurrent systems or references is certainly more challenging a crucial tool in the proof of full abstraction is the use of the type system of figure which is a kind of intersection type system in fact a web element a an b can be seen as a type a и и b where the intersection is this system is a quantitative refinement of de and yields the first logical presentation of a based semantics clearly both type inference and type checking are undecidable however one can look for interesting restrictions of where the system becomes decidable in the spirit of last it should be that unlike most full abstraction models for pcf our model has no simple properties our full abstraction proof builds applicative contexts using terms which belong to a very small subset of the domains associated with types their power relies on a strong property of power series unlike smooth functions a power series which on an open set must be equal to see for example to the function defined by ex for x and for x in contrast most full abstraction proofs build applicative contexts using terms which belong to a subset of the corresponding domains references s abramsky r and p full abstraction for pcf information and computation Г dec g pl curien and c a semantics for lambda calculi with resources math struct comp sci Г a a t g et al full abstraction for resource calculus with tests in csl Г annual conference of the volume pages Г v and t probabilistic coherence spaces as a model of higherorder probabilistic computation inf comput Г v and r probabilistic game semantics acm transactions on computational logic Г july d de execution time of terms via denotational semantics and intersection types t on sequence spaces and linear logic math struct comput sci Г t spaces math struct comput sci Г t and l the differential lambdacalculus theor comput sci Г jy girard the system f of variable types years later theor comput sci Г jy girard linear logic theor comput sci Г jy girard normal functors power series and lambdacalculus ann pure logic Г jy girard coherent spaces a continuous denotational semantics theor comput sci jy girard between logic and a in t jy girard p and p scott editors linear logic in computer science volume of london math notes j and d continuous random variables in lics pages Г ieee computer society i r two applications of analytic functors theor comput sci Г m and l on full abstraction for pcf information and computation Г dec c jones and g plotkin a probabilistic of evaluation in lics ieee computer society a j and j b and decidable type inference for intersection types in popl pages Г u d and m probabilistic operational semantics for the lambda calculus theor inf and Г j g g and m weighted relational models of typed in lics ieee press june r milner fully abstract models of typed theor comput sci Г r milner and c a theory of programming language semantics and hall london e moggi computational lambdacalculus and monads in lics pages Г ieee computer society a d c and h probabilistic lambdacalculus and quantitative program analysis j log comput Г g d plotkin a powerdomain construction siam j comput Г g d plotkin considered as a programming language theor comput sci Г n cpos of measures for nondeterminism theor comput sci Г d scott continuous lattices in editor algebraic geometry and logic volume of lecture notes in math pages Г springer 